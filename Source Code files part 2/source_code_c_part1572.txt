ncr,
        parms->uchMaxRetryCnt,
        parms->uchMaxMembers,
        parms->usMaxI_Field,
        parms->uchSapValue,
        parms->uchOptionsPriority,
        parms->uchcStationCount,
        parms->uchReserved2[0],
        parms->uchReserved2[1],
        parms->cGroupCount,
        parms->pGroupList,
        parms->DlcStatusFlags,
        parms->uchReserved3[0],
        parms->uchReserved3[1],
        parms->uchReserved3[2],
        parms->uchReserved3[3],
        parms->uchReserved3[4],
        parms->uchReserved3[5],
        parms->uchReserved3[6],
        parms->uchReserved3[7],
        parms->cLinkStationsAvail
        ));
}

PRIVATE
VOID
DumpDlcOpenStationParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DLC_OPEN_STATION_PARMS parms = (PLLC_DLC_OPEN_STATION_PARMS)Parameters;
    LPBYTE dest = parms->pRemoteNodeAddress;
    char destAddr[19];

    DumpParameterTableHeader("DLC.OPEN.STATION", Parameters);

    destAddr[0] = 0;
    if (dest) {
        sprintf(destAddr, "%02x-%02x-%02x-%02x-%02x-%02x",
                dest[0],
                dest[1],
                dest[2],
                dest[3],
                dest[4],
                dest[5]
                );
    }
    PUT(("SAP station . . %04x\n"
        "link station. . %04x\n"
        "T1. . . . . . . %02x\n"
        "T2. . . . . . . %02x\n"
        "Ti. . . . . . . %02x\n"
        "max out . . . . %02x\n"
        "max in. . . . . %02x\n"
        "max out incr. . %02x\n"
        "max retry count %02x\n"
        "remote SAP. . . %02x\n"
        "max I field . . %04x\n"
        "access priority %02x\n"
        "remote node . . %08x [%s]\n",
        parms->usSapStationId,
        parms->usLinkStationId,
        parms->uchT1,
        parms->uchT2,
        parms->uchTi,
        parms->uchMaxOut,
        parms->uchMaxIn,
        parms->uchMaxOutIncr,
        parms->uchMaxRetryCnt,
        parms->uchRemoteSap,
        parms->usMaxI_Field,
        parms->uchAccessPriority,
        dest,
        destAddr
        ));
}

PRIVATE
VOID
DumpDlcReallocateParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_REALLOCATE_PARMS parms = (PLLC_DLC_REALLOCATE_PARMS)Parameters;

    DumpParameterTableHeader("DLC.REALLOCATE", Parameters);

    PUT(("station id. . . %04x\n"
        "option. . . . . %02x [%screase link stations]\n"
        "station count . %02x\n"
        "adapter stns. . %02x\n"
        "SAP stations. . %02x\n"
        "adapter total . %02x\n"
        "SAP total . . . %02x\n",
        parms->usStationId,
        parms->uchOption,
        parms->uchOption & 0x80 ? "De" : "In",
        parms->uchStationCount,
        parms->uchStationsAvailOnAdapter,
        parms->uchStationsAvailOnSap,
        parms->uchTotalStationsOnAdapter,
        parms->uchTotalStationsOnSap
        ));
}

PRIVATE
VOID
DumpDlcResetParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n", HIWORD(Parameters)));
}

PRIVATE
VOID
DumpDlcSetThresholdParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_SET_THRESHOLD_PARMS parms = (PLLC_DLC_SET_THRESHOLD_PARMS)Parameters;

    DumpParameterTableHeader("DLC.SET.THRESHOLD", Parameters);

    PUT(("station id. . . %04x\n"
        "buf threshold . %04x\n"
        "event . . . . . %08x\n",
        parms->usStationId,
        parms->cBufferThreshold,
        parms->AlertEvent
        ));
}

PRIVATE
VOID
DumpDlcStatisticsParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_STATISTICS_PARMS parms = (PLLC_DLC_STATISTICS_PARMS)Parameters;

    DumpParameterTableHeader("DLC.STATISTICS", Parameters);

    PUT(("station id. . . %04x\n"
        "log buf size. . %04x\n"
        "log buffer. . . %08x\n"
        "actual log len. %04x\n"
        "options . . . . %02x [%s]\n",
        parms->usStationId,
        parms->cbLogBufSize,
        parms->pLogBuf,
        parms->usActLogLength,
        parms->uchOptions,
        parms->uchOptions & 0x80 ? "Reset counters" : ""
        ));
}

PRIVATE
VOID
DumpReadParms(
    IN PVOID Parameters
    )
{
    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)Parameters;

    DumpParameterTableHeader("READ", Parameters);

    try {
        PUT(("station id. . . %04x\n"
            "option ind. . . %02x [%s]\n"
            "event set . . . %02x\n"
            "event . . . . . %02x [%s]\n"
            "crit. subset. . %02x\n"
            "notify flag . . %08x\n",
            parms->usStationId,
            parms->uchOptionIndicator,
            MapOptionIndicator(parms->uchOptionIndicator),
            parms->uchEventSet,
            parms->uchEvent,
            MapReadEvent(parms->uchEvent),
            parms->uchCriticalSubset,
            parms->ulNotificationFlag
            ));

        //
        // rest of table interpreted differently depending on whether status change
        //

        if (parms->uchEvent & 0x38) {
            PUT(("station id. . . %04x\n"
                "status code . . %04x [%s]\n"
                "FRMR data . . . %02x %02x %02x %02x %02x\n"
                "access pri. . . %02x\n"
                "remote addr . . %02x-%02x-%02x-%02x-%02x-%02x\n"
                "remote SAP. . . %02x\n"
                "reserved. . . . %02x\n"
                "user stat . . . %04x\n",
                parms->Type.Status.usStationId,
                parms->Type.Status.usDlcStatusCode,
                MapDlcStatus(parms->Type.Status.usDlcStatusCode),
                parms->Type.Status.uchFrmrData[0],
                parms->Type.Status.uchFrmrData[1],
                parms->Type.Status.uchFrmrData[2],
                parms->Type.Status.uchFrmrData[3],
                parms->Type.Status.uchFrmrData[4],
                parms->Type.Status.uchAccessPritority,
                parms->Type.Status.uchRemoteNodeAddress[0],
                parms->Type.Status.uchRemoteNodeAddress[1],
                parms->Type.Status.uchRemoteNodeAddress[2],
                parms->Type.Status.uchRemoteNodeAddress[3],
                parms->Type.Status.uchRemoteNodeAddress[4],
                parms->Type.Status.uchRemoteNodeAddress[5],
                parms->Type.Status.uchRemoteSap,
                parms->Type.Status.uchReserved,
                parms->Type.Status.usUserStatusValue
                ));
        } else {
            PUT(("CCB count . . . %04x\n"
                "CCB list. . . . %08x\n"
                "buffer count. . %04x\n"
                "buffer list . . %08x\n"
                "frame count . . %04x\n"
                "frame list. . . %08x\n"
                "error code. . . %04x\n"
                "error data. . . %04x %04x %04x\n",
                parms->Type.Event.usCcbCount,
                parms->Type.Event.pCcbCompletionList,
                parms->Type.Event.usBufferCount,
                parms->Type.Event.pFirstBuffer,
                parms->Type.Event.usReceivedFrameCount,
                parms->Type.Event.pReceivedFrame,
                parms->Type.Event.usEventErrorCode,
                parms->Type.Event.usEventErrorData[0],
                parms->Type.Event.usEventErrorData[1],
                parms->Type.Event.usEventErrorData[2]
                ));

            IF_DEBUG(DUMP_ASYNC_CCBS) {
                if (parms->Type.Event.usCcbCount) {
                    DumpCcb(parms->Type.Event.pCcbCompletionList,
                            TRUE,   // DumpAll
                            FALSE   // CcbIsInput
                            );
                }
            }

            IF_DEBUG(DUMP_RX_INFO) {
                if (parms->Type.Event.usReceivedFrameCount) {
                    DumpReceiveDataBuffer(parms->Type.Event.pReceivedFrame);
                }
            }
        }
    } except(1) {
        PUT(("*** Error: Bad READ Parameter Table @ %x ***\n", parms));
    }
}

PRIVATE
LPSTR
MapOptionIndicator(
    IN UCHAR OptionIndicator
    )
{
    switch (OptionIndicator) {
    case 0:
        return "Match READ command using station id nnss";

    case 1:
        return "Match READ command using SAP number nn00";

    case 2:
        return "Match READ command using all events";
    }
    return "*** Unknown READ Option Indicator ***";
}

PRIVATE LPSTR MapReadEvent(UCHAR Event) {
    switch (Event) {
    case 0x80:
        return "Reserved Event!";

    case 0x40:
        return "System Action (non-critical)";

    case 0x20:
        return "Network Status (non-critical)";

    case 0x10:
        return "Critical Exception";

    case 0x8:
        return "DLC Status Change";

    case 0x4:
        return "Receive Data";

    case 0x2:
        return "Transmit Completion";

    case 0x1:
        return "Command Completion";
    }
    return "*** Unknown READ Event ***";
}

PRIVATE LPSTR MapDlcStatus(WORD Status) {
    if (Status & 0x8000) {
        return "Link lost";
    } else if (Status & 0x4000) {
        return "DM/DISC Received -or- DISC ack'd";
    } else if (Status & 0x2000) {
        return "FRMR Received";
    } else if (Status & 0x1000) {
        return "FRMR Sent";
    } else if (Status & 0x0800) {
        return "SABME Received for open link station";
    } else if (Status & 0x0400) {
        return "SABME Received - link station opened";
    } else if (Status & 0x0200) {
        return "REMOTE Busy Entered";
    } else if (Status & 0x0100) {
        return "REMOTE Busy Left";
    } else if (Status & 0x0080) {
        return "Ti EXPIRED";
    } else if (Status & 0x0040) {
        return "DLC counter overflow - issue DLC.STATISTICS";
    } else if (Status & 0x0020) {
        return "Access Priority lowered";
    } else if (Status & 0x001e) {
        return "*** ERROR - INVALID STATUS ***";
    } else if (Status & 0x0001) {
        return "Entered LOCAL Busy";
    }
    return "*** Unknown DLC Status ***";
}

PRIVATE
VOID
DumpReadCancelParms(
    IN PVOID Parameters
    )
{
}

PRIVATE
VOID
DumpReceiveParms(
    IN  PVOID   Parameters
    )
{
    PLLC_RECEIVE_PARMS parms = (PLLC_RECEIVE_PARMS)Parameters;

    DumpParameterTableHeader("RECEIVE", Parameters);

    PUT(("station id. . . %04x\n"
        "user length . . %04x\n"
        "receive flag. . %08x\n"
        "first buffer. . %08x\n"
        "options . . . . %02x [%s]\n"
        "reserved. . . . %02x %02x %02x\n"
        "rcv read optns. %02x [%s]\n",
        parms->usStationId,
        parms->usUserLength,
        parms->ulReceiveFlag,
        parms->pFirstBuffer,
        parms->uchOptions,
        MapReceiveOptions(parms->uchOptions),
        parms->auchReserved1[0],
        parms->auchReserved1[1],
        parms->auchReserved1[2],
        parms->uchRcvReadOption,
        MapRcvReadOption(parms->uchRcvReadOption)
        ));
}

PRIVATE
LPSTR
MapReceiveOptions(
    IN UCHAR Options
    )
{
    static char buf[80];
    BOOL space = FALSE;

    buf[0] = 0;
    if (Options & 0x80) {
        strcat(buf, "Contiguous MAC");
        Options &= 0x7f;
        space = TRUE;
    }
    if (Options & 0x40) {
        if (space) {
            strcat(buf, " ");
        }
        strcat(buf, "Contiguous DATA");
        Options &= 0xbf;
        space = TRUE;
    }
    if (Options & 0x20) {
        if (space) {
            strcat(buf, " ");
        }
        strcat(buf, "Break");
        Options &= 0xdf;
        space = TRUE;
    }
    if (Options) {
        if (space) {
            strcat(buf, " ");
        }
        strcat(buf, "*** Invalid options ***");
    }
    return buf;
}

PRIVATE
LPSTR
MapRcvReadOption(
    IN UCHAR Option
    )
{
    switch (Option) {
    case 0:
        return "Receive frames not chained";

    case 1:
        return "Chain receive frames for link station";

    case 2:
        return "Chain receive frames for SAP";
    }
    return "*** Unknown option ***";
}

PRIVATE
VOID
DumpReceiveCancelParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n", HIWORD(Parameters)));
}

PRIVATE
VOID
DumpReceiveModifyParms(
    IN PVOID Parameters
    )
{
}

PRIVATE
VOID
DumpTransmitDirFrameParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.DIR.FRAME", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitIFrameParms(
    IN PVOID Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.I.FRAME", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitTestCmdParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.TEST.CMD", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitUiFrameParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.UI.FRAME", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitXidCmdParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.CMD", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitXidRespFinalParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.RESP.FINAL", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitXidRespNotFinalParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.RESP.NOT.FINAL", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitFramesParms(
    IN PVOID Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.FRAMES", Parameters);
//    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitParms(
    IN PVOID Parameters
    )
{
    PLLC_TRANSMIT_PARMS parms = (PLLC_TRANSMIT_PARMS)Parameters;

    try {
        PUT(("StationId . . . %04x\n"
            "Transmit FS . . %02x\n"
            "Remote SAP. . . %02x\n"
            "Xmit Queue 1. . %08x\n"
            "Xmit Queue 2. . %08x\n"
            "Buffer Length 1 %02x\n"
            "Buffer Length 2 %02x\n"
            "Buffer 1. . . . %08x\n"
            "Buffer 2. . . . %08x\n"
            "Xmt Read Option %02x [%s]\n"
            "\n",
            parms->usStationId,
            parms->uchTransmitFs,
            parms->uchRemoteSap,
            parms->pXmitQueue1,
            parms->pXmitQueue2,
            parms->cbBuffer1,
            parms->cbBuffer2,
            parms->pBuffer1,
            parms->pBuffer2,
            parms->uchXmitReadOption,
            MapXmitReadOption(parms->uchXmitReadOption)
            ));

        IF_DEBUG(DUMP_TX_INFO) {
            if (parms->pXmitQueue1) {
                PUT(("XMIT_QUEUE_ONE:\n"));
                DumpTransmitQueue(parms->pXmitQueue1);
            }

            if (parms->pXmitQueue2) {
                PUT(("XMIT_QUEUE_TWO:\n"));
                DumpTransmitQueue(parms->pXmitQueue2);
            }
        }

        IF_DEBUG(DUMP_TX_DATA) {
            if (parms->cbBuffer1) {
                DumpData("BUFFER_ONE. . . ",
                        (PBYTE)parms->pBuffer1,
                        (DWORD)parms->cbBuffer1,
                        DD_NO_ADDRESS
                        | DD_LINE_AFTER
                        | DD_INDENT_ALL
                        | DD_UPPER_CASE
                        | DD_DOT_DOT_SPACE,
                        DEFAULT_FIELD_WIDTH
                        );
            }

            if (parms->cbBuffer2) {
                DumpData("BUFFER_TWO. . . ",
                        (PBYTE)parms->pBuffer2,
                        (DWORD)parms->cbBuffer2,
                        DD_NO_ADDRESS
                        | DD_LINE_AFTER
                        | DD_INDENT_ALL
                        | DD_UPPER_CASE
                        | DD_DOT_DOT_SPACE,
                        DEFAULT_FIELD_WIDTH
                        );
            }
        }
    } except(1) {
        PUT(("*** Error: Bad Transmit Parameter Table @ %x ***\n", parms));
    }
}

PRIVATE
VOID
DumpTransmitQueue(
    IN PLLC_XMIT_BUFFER Buffer
    )
{
    try {
        while (Buffer) {
            PUT(("Next. . . . . . %08x\n"
                "Reserved. . . . %04x\n"
                "Data In Buffer. %04x\n"
                "User Data . . . %04x\n"
                "User Length . . %04x\n"
                "\n",
                Buffer->pNext,
                Buffer->usReserved1,
                Buffer->cbBuffer,
                Buffer->usReserved2,
                Buffer->cbUserData
                ));

            IF_DEBUG(DUMP_TX_DATA) {
                DumpData(NULL,
                        (PBYTE)Buffer->auchData,
                        (DWORD)Buffer->cbBuffer + (DWORD)Buffer->cbUserData,
                        DD_DEFAULT_OPTIONS,
                        DEFAULT_FIELD_WIDTH
                        );
            }
            Buffer = Buffer->pNext;
        }
    } except(1) {
        PUT(("*** Error: Bad Transmit Queue/Buffer @ %x ***\n", Buffer));
    }
}

PRIVATE
LPSTR
MapXmitReadOption(
    IN UCHAR Option
    )
{
    switch (Option) {
    case 0:
        return "Chain this Transmit on Link station basis";

    case 1:
        return "Do not chain this Transmit completion";

    case 2:
        return "Chain this Transmit on SAP station basis";
    }
    return "*** Unknown XMIT_READ_OPTION ***";
}

VOID
DumpReceiveDataBuffer(
    IN PVOID Buffer
    )
{
    PLLC_BUFFER pBuf = (PLLC_BUFFER)Buffer;
    BOOL contiguous;
    WORD userLength;
    WORD dataLength;
    WORD userOffset;

    try {
        contiguous = pBuf->Contiguous.uchOptions & 0xc0;
        userLength = pBuf->Next.cbUserData;
        dataLength = pBuf->Next.cbBuffer;
        userOffset = pBuf->Next.offUserData;
    } except(1) {
        PUT(("*** Error: Bad received data buffer address %x ***\n", pBuf));
        return;
    }

    //
    // Buffer 1: [not] contiguous MAC/DATA
    //

    try {
        PUT(("\n"
            "%sContiguous MAC/DATA frame @%08x\n"
            "next buffer . . %08x\n"
            "frame length. . %04x\n"
            "data length . . %04x\n"
            "user offset . . %04x\n"
            "user length . . %04x\n"
            "station id. . . %04x\n"
            "options . . . . %02x\n"
            "message type. . %02x [%s]\n"
            "buffers left. . %04x\n"
            "rcv FS. . . . . %02x\n"
            "adapter num . . %02x\n"
            "next frame. . . %08x\n",
            contiguous ? "" : "Not",
            pBuf,
            pBuf->Contiguous.pNextBuffer,
            pBuf->Contiguous.cbFrame,
            pBuf->Contiguous.cbBuffer,
            pBuf->Contiguous.offUserData,
            pBuf->Contiguous.cbUserData,
            pBuf->Contiguous.usStationId,
            pBuf->Contiguous.uchOptions,
            pBuf->Contiguous.uchMsgType,
            MapMessageType(pBuf->Contiguous.uchMsgType),
            pBuf->Contiguous.cBuffersLeft,
            pBuf->Contiguous.uchRcvFS,
            pBuf->Contiguous.uchAdapterNumber,
            pBuf->Contiguous.pNextFrame
            ));

        if (!contiguous) {

            //
            // dump NotContiguous header
            //

            DWORD cbLanHeader = (DWORD)pBuf->NotContiguous.cbLanHeader;
            DWORD cbDlcHeader = (DWORD)pBuf->NotContiguous.cbDlcHeader;

            PUT(("LAN hdr len . . %02x\n"
                "DLC hdr len . . %02x\n",
                cbLanHeader,
                cbDlcHeader
                ));
            DumpData("LAN header. . . ",
                    pBuf->NotContiguous.auchLanHeader,
                    cbLanHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH
                    );
            DumpData("DLC header. . . ",
                    pBuf->NotContiguous.auchDlcHeader,
                    cbDlcHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH
                    );

            if (userLength) {
                DumpData("user space. . . ",
                        (PBYTE)pBuf + userOffset,
                        userLength,
                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                        DEFAULT_FIELD_WIDTH
                        );
            } else {
                PUT(("user space. . . \n"));
            }

            IF_DEBUG(DUMP_RX_DATA) {

                if (dataLength) {
                    DumpData("rcvd data . . . ",
                            (PBYTE)pBuf + userOffset + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                } else {
                    PUT(("rcvd data . . . \n"));
                }
            }
        } else {

            //
            // dump Contiguous header
            //
            // data length is size of frame in contiguous buffer?
            //

            if (userLength) {
                DumpData("user space. . . ",
                        (PBYTE)pBuf + userOffset,
                        userLength,
                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                        DEFAULT_FIELD_WIDTH
                        );
            } else {
                PUT(("user space. . . \n"));
            }

            IF_DEBUG(DUMP_RX_DATA) {

                dataLength = pBuf->Contiguous.cbFrame;

                if (dataLength) {
                    DumpData("rcvd data . . . ",
                            (PBYTE)pBuf + userOffset + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                } else {
                    PUT(("rcvd data . . . \n"));
                }
            }
        }

        //
        // dump second & subsequent buffers
        //

        IF_DEBUG(DUMP_DATA_CHAIN) {

            for (pBuf = pBuf->pNext; pBuf; pBuf = pBuf->pNext) {

                userLength = pBuf->Next.cbUserData;
                dataLength = pBuf->Next.cbBuffer;

                PUT(("\n"
                    "Buffer 2/Subsequent @%08x\n"
                    "next buffer . . %08x\n"
                    "frame length. . %04x\n"
                    "data length . . %04x\n"
                    "user offset . . %04x\n"
                    "user length . . %04x\n",
                    pBuf,
                    pBuf->pNext,
                    pBuf->Next.cbFrame,
                    dataLength,
                    pBuf->Next.offUserData,
                    userLength
                    ));

                if (userLength) {
                    DumpData("user space. . . ",
                            (PBYTE)&pBuf + pBuf->Next.offUserData,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                } else {
                    PUT(("user space. . . \n"));
                }

                IF_DEBUG(DUMP_RX_DATA) {

                    //
                    // there must be received data
                    //

                    DumpData("rcvd data . . . ",
                            (PBYTE)pBuf + pBuf->Next.offUserData + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                }
            }
        }

        if (((PLLC_BUFFER)Buffer)->Contiguous.pNextFrame) {
            DumpReceiveDataBuffer(((PLLC_BUFFER)Buffer)->Contiguous.pNextFrame);
        }

    } except(1) {
        PUT(("*** Error: Bad Receive Data Buffer @ %x ***\n", Buffer));
    }
}

PRIVATE
LPSTR
MapMessageType(
    IN UCHAR MessageType
    )
{
    switch (MessageType) {
    case 0x00:
        return "Direct Transmit Frame";

    case 0x02:
        return "MAC Frame (Direct Station on Token Ring only)";

    case 0x04:
        return "I-Frame";

    case 0x06:
        return "UI-Frame";

    case 0x08:
        return "XID Command (POLL)";

    case 0x0a:
        return "XID Command (not POLL)";

    case 0x0c:
        return "XID Response (FINAL)";

    case 0x0e:
        return "XID Response (not FINAL)";

    case 0x10:
        return "TEST Response (FINAL)";

    case 0x12:
        return "TEST Response (not FINAL)";

    case 0x14:
        return "Direct 802.2/OTHER - non-MAC frame (Direct Station only)";

    case 0x16:
        return "TEST Command (POLL)";

    case 0x18:
        return "Direct Ethernet Frame";

    case 0x1a:
        return "Last Frame Type";

//    case 0x5dd:
//        return "First Ethernet Frame Type";

    default:
        return "*** BAD FRAME TYPE ***";
    }
}

//PRIVATE
//VOID
//DumpData(
//    IN PBYTE Address,
//    IN DWORD Length
//    )
//{
//    char dumpBuf[80];
//    char* bufptr;
//    int i, n;
//
//    //
//    // the usual dump style: 16 columns of hex bytes, followed by 16 columns
//    // of corresponding ASCII characters, or '.' where the character is < 0x20
//    // (space) or > 0x7f (del?)
//    //
//
//    while (Length) {
//        bufptr = dumpBuf;
//        bufptr += sprintf(bufptr, "%08x: ", Address);
//        if (Length < 16) {
//            n = Length;
//        } else {
//            n = 16;
//        }
//        for (i = 0; i < n; ++i) {
//            bufptr += sprintf(bufptr, "%02x", Address[i]);
//            if (i == 7) {
//                *bufptr = '-';
//            } else {
//                *bufptr = ' ';
//            }
//            ++bufptr;
//        }
//        if (n < 16) {
//            for (i = 0; i < 16-n; ++i) {
//                bufptr += sprintf(bufptr, "   ");
//            }
//        }
//        bufptr += sprintf(bufptr, "  ");
//        for (i = 0; i < n; ++i) {
//            if (Address[i] < 0x20 || Address[i] > 0x7f) {
//                *bufptr++ = '.';
//            } else {
//                *bufptr++ = Address[i];
//            }
//        }
//        *bufptr++ = '\n';
//        *bufptr = 0;
//        PUT((dumpBuf));
//        Length -= n;
//        Address += n;
//    }
//    PUT(("\n"));
//}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\api\dlcdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcdebug.h

Abstract:

    Contains debugging prototypes and manifests for ACSLAN

Author:

    Richard L Firth (rfirth) 28-May-1992

Revision History:

--*/

#define ARRAY_ELEMENTS(a)   (sizeof(a)/sizeof((a)[0]))
#define LAST_ELEMENT(a)     (ARRAY_ELEMENTS(a)-1)

#if DBG

#define PRIVATE

#define ACSLAN_DEBUG_ENV_VAR    "ACSLAN_DEBUG_FLAGS"
#define ACSLAN_DUMP_FILE_VAR    "ACSLAN_DUMP_FILE"
#define ACSLAN_DUMP_FILTER_VAR  "ACSLAN_DUMP_FILTER"

#define DEBUG_DUMP_INPUT_CCB    0x00000001L // dump CCB input to AcsLan
#define DEBUG_DUMP_OUTPUT_CCB   0x00000002L // dump CCB output from AcsLan
#define DEBUG_DUMP_TX_INFO      0x00000004L // dump transmit buffers
#define DEBUG_DUMP_RX_INFO      0x00000008L // dump receive buffers
#define DEBUG_DUMP_TX_DATA      0x00000010L // dump data buffer in TRANSMIT commands
#define DEBUG_DUMP_RX_DATA      0x00000020L // dump received data frames
#define DEBUG_DUMP_DATA_CHAIN   0x00000040L // dump entire chain of received data buffers
#define DEBUG_DUMP_FRAME_CHAIN  0x00000080L // dump entire chain of received frames
#define DEBUG_DUMP_TX_ASCII     0x00000100L // dump transmitted data as hex & ASCII
#define DEBUG_DUMP_RX_ASCII     0x00000200L // dump received data as hex & ASCII
#define DEBUG_DUMP_ASYNC_CCBS   0x00000400L // dump READ async. completed CCBs
#define DEBUG_RETURN_CODE       0x01000000L // dump return code from AcsLan/NtAcsLan
#define DEBUG_DUMP_NTACSLAN     0x02000000L // dump CCBs for NtAcsLan, not AcsLan
#define DEBUG_DUMP_ACSLAN       0x04000000L // dump CCBs for AcsLan, not NtAcsLan
#define DEBUG_DUMP_TIME         0x08000000L // dump relative time between commands
#define DEBUG_DLL_INFO          0x10000000L // dump info about DLL attach/detach
#define DEBUG_BREAKPOINT        0x20000000L // break at conditional breakpoints
#define DEBUG_TO_FILE           0x40000000L // dump info to file
#define DEBUG_TO_TERMINAL       0x80000000L // dump info to console

#define IF_DEBUG(c)             if (AcslanDebugFlags & DEBUG_##c)
#define PUT(x)                  AcslanDebugPrint x
#define DUMPCCB                 DumpCcb

//
// misc.
//

#define DEFAULT_FIELD_WIDTH     16          // amount of description before a number

//
// DumpData options
//

#define DD_DEFAULT_OPTIONS      0x00000000  // use defaults
#define DD_NO_ADDRESS           0x00000001  // don't display address of data
#define DD_LINE_BEFORE          0x00000002  // linefeed before first dumped line
#define DD_LINE_AFTER           0x00000004  // linefeed after last dumped line
#define DD_INDENT_ALL           0x00000008  // indent all lines
#define DD_NO_ASCII             0x00000010  // don't dump ASCII respresentation
#define DD_UPPER_CASE           0x00000020  // upper-case hex dump (F4 instead of f4)
#define DD_DOT_DOT_SPACE        0x00000040  // fill unused hex space with '..'

//
// Filters for individual CCB commands: 4 flags max, because each command is
// represented by a single ASCII character
//

#define CF_DUMP_CCB_IN          0x00000001  // dump CCB on input
#define CF_DUMP_CCB_OUT         0x00000002  // dump CCB on output
#define CF_DUMP_PARMS_IN        0x00000004  // dump parameter table on input
#define CF_DUMP_PARMS_OUT       0x00000008  // dump parameter table on output

//
// global data
//

#ifndef ACSLAN_DEBUG_FLAGS
#define ACSLAN_DEBUG_FLAGS      0
#endif

extern DWORD AcslanDebugFlags;
extern FILE* hDumpFile;

//
// prototypes
//

VOID
GetAcslanDebugFlags(
    VOID
    );

VOID
SetAcslanDebugFlags(
    IN DWORD Flags
    );

VOID
AcslanDebugPrint(
    IN LPSTR Format,
    IN ...
    );

VOID
DumpCcb(
    IN PLLC_CCB Ccb,
    IN BOOL DumpAll,
    IN BOOL CcbIsInput
    );

VOID
DumpData(
    IN LPSTR Title,
    IN PBYTE Address,
    IN DWORD Length,
    IN DWORD Options,
    IN DWORD Indent
    );

LPSTR
MapCcbRetcode(
    IN BYTE Retcode
    );

#else

#define PRIVATE                 static

#define IF_DEBUG(c)             if (0)
#define PUT(x)
#define DUMPCCB                 (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\api\acslan.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    acslan.c

Abstract:

    The module is the entry to the OS/2 ACSLAN emulation module.
    It uses the secure native NT DLC API to implement the full
    IBM OS/2 DLC compatible interface for Windows/NT.

    Contents:
        AcsLan
        NtAcsLan
        GetCcbStationId
        OpenDlcApiDriver
        GetAdapterNameAndParameters
        GetAdapterNameFromNumber
        GetAdapterNumberFromName
        DoSyncDeviceIoControl
        DlcGetInfo
        DlcSetInfo
        DlcCallDriver
        DllEntry
        QueueCommandCompletion

Author:

    Antti Saarenheimo (o-anttis) 06-JUN-1991

Revision History:

--*/

#include "dlcdll.h"
#include "dlcdebug.h"

#define DLC_UNSUPPORTED_COMMAND ((ULONG)0x7fffffff)
#define DLC_ASYNCHRONOUS_FLAG   ((ULONG)0x80000000)
#define IS_SYNCHRONOUS(command) (!(IoctlCodes[command] & DLC_ASYNCHRONOUS_FLAG))
#define DLC_IOCTL(command)      (IoctlCodes[command] & ~DLC_ASYNCHRONOUS_FLAG)
#define IS_TRANSMIT(command)    (((command) == LLC_TRANSMIT_DIR_FRAME) \
                                || ((command) == LLC_TRANSMIT_I_FRAME) \
                                || ((command) == LLC_TRANSMIT_UI_FRAME) \
                                || ((command) == LLC_TRANSMIT_XID_CMD) \
                                || ((command) == LLC_TRANSMIT_XID_RESP_FINAL) \
                                || ((command) == LLC_TRANSMIT_XID_RESP_NOT_FINAL) \
                                || ((command) == LLC_TRANSMIT_TEST_CMD))

#define DEFAULT_QUERY_BUFFER_LENGTH 1024    // 512 wide chars, approx. 32 bindings
#define DEFAULT_BINDING_LENGTH      64      // 32 wide chars, double typical

#ifdef GRAB_READ

typedef struct {
    PVOID List;
    PLLC_CCB pCcb;
    HANDLE OriginalEventHandle;
    HANDLE NewEventHandle;
} READ_GRABBER, *PREAD_GRABBER;

VOID ReadGrabber(VOID);
DWORD MungeReadGrabberHandles(VOID);
VOID AddReadGrabber(PREAD_GRABBER);
PREAD_GRABBER RemoveReadGrabber(HANDLE);

#endif

//
// private data
//

static USHORT aMinDirLogSize[3] = {
    sizeof(LLC_ADAPTER_LOG),
    sizeof(LLC_DIRECT_LOG),
    sizeof(LLC_ADAPTER_LOG) + sizeof(LLC_DIRECT_LOG)
};

CRITICAL_SECTION DriverHandlesCritSec;
HANDLE aDlcDriverHandles[LLC_MAX_ADAPTER_NUMBER];
IO_STATUS_BLOCK GlobalIoStatus;

//
// IoctlCodes - combines actual IOCTL code (giving device type, request vector,
// I/O buffer method and file access) and synchronous/asynchronous flag (high bit)
//

ULONG IoctlCodes[LLC_MAX_DLC_COMMAND] = {
    DLC_UNSUPPORTED_COMMAND,                            // 0x00 DIR.INTERRUPT
    DLC_UNSUPPORTED_COMMAND,                            // 0x01 DIR.MODIFY.OPEN.PARMS       CCB1 ONLY
    DLC_UNSUPPORTED_COMMAND,                            // 0x02 DIR.RESTORE.OPEN.PARMS      CCB1 ONLY
    IOCTL_DLC_OPEN_ADAPTER,                             // 0x03 DLC.OPEN.ADAPTER
    IOCTL_DLC_CLOSE_ADAPTER | DLC_ASYNCHRONOUS_FLAG,    // 0x04 DIR.CLOSE.ADAPTER
    IOCTL_DLC_SET_INFORMATION,                          // 0x05 DIR.SET.MULTICAST.ADDRESS
    IOCTL_DLC_SET_INFORMATION,                          // 0x06 DIR.SET.GROUP.ADDRESS
    IOCTL_DLC_SET_INFORMATION,                          // 0x07 DIR.SET.FUNCTIONAL.ADDRESS
    DLC_UNSUPPORTED_COMMAND,                            // 0x08 DIR.READ.LOG
    IOCTL_DLC_TRANSMIT2 | DLC_ASYNCHRONOUS_FLAG,        // 0x09 TRANSMIT.FRAMES
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0a TRANSMIT.DIR.FRAME
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0b TRANSMIT.I.FRAME
    DLC_UNSUPPORTED_COMMAND,                            // 0x0c no command
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0d TRANSMIT.UI.FRAME
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0e TRANSMIT.XID.CMD
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0f TRANSMIT.XID.RESP.FINAL
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x10 TRANSMIT.XID.RESP.NOT.FINAL
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x11 TRANSMIT.TEST.CMD
    IOCTL_DLC_QUERY_INFORMATION,                        // 0x12 no command
    IOCTL_DLC_SET_INFORMATION,                          // 0x13 no command
    IOCTL_DLC_RESET | DLC_ASYNCHRONOUS_FLAG,            // 0x14 DLC.RESET
    IOCTL_DLC_OPEN_SAP,                                 // 0x15 DLC.OPEN.SAP
    IOCTL_DLC_CLOSE_SAP | DLC_ASYNCHRONOUS_FLAG,        // 0x16 DLC.CLOSE.SAP
    IOCTL_DLC_REALLOCTE_STATION,                        // 0x17 DLC.REALLOCATE
    DLC_UNSUPPORTED_COMMAND,                            // 0x18 no command
    IOCTL_DLC_OPEN_STATION,                             // 0x19 DLC.OPEN.STATION
    IOCTL_DLC_CLOSE_STATION | DLC_ASYNCHRONOUS_FLAG,    // 0x1a DLC.CLOSE.STATION
    IOCTL_DLC_CONNECT_STATION | DLC_ASYNCHRONOUS_FLAG,  // 0x1b DLC.CONNECT.STATION
    DLC_UNSUPPORTED_COMMAND,                            // 0x1c DLC.MODIFY
    IOCTL_DLC_FLOW_CONTROL,                             // 0x1d DLC.FLOW.CONTROL
    DLC_UNSUPPORTED_COMMAND,                            // 0x1e DLC.STATISTICS
    IOCTL_DLC_FLOW_CONTROL,                             // 0x1f no command
    IOCTL_DLC_CLOSE_ADAPTER | DLC_ASYNCHRONOUS_FLAG,    // 0x20 DIR.INITIALIZE
    IOCTL_DLC_QUERY_INFORMATION,                        // 0x21 DIR.STATUS
    IOCTL_DLC_TIMER_SET | DLC_ASYNCHRONOUS_FLAG,        // 0x22 DIR.TIMER.SET
    IOCTL_DLC_TIMER_CANCEL,                             // 0x23 DIR.TIMER.CANCEL
    DLC_UNSUPPORTED_COMMAND,                            // 0x24 PDT.TRACE.ON                CCB1 ONLY
    DLC_UNSUPPORTED_COMMAND,                            // 0x25 PDT.TRACE.OFF               CCB1 ONLY
    IOCTL_DLC_BUFFER_GET,                               // 0x26 BUFFER.GET
    IOCTL_DLC_BUFFER_FREE,                              // 0x27 BUFFER.FREE
    IOCTL_DLC_RECEIVE | DLC_ASYNCHRONOUS_FLAG,          // 0x28 RECEIVE
    IOCTL_DLC_RECEIVE_CANCEL,                           // 0x29 RECEIVE.CANCEL
    DLC_UNSUPPORTED_COMMAND,                            // 0x2a RECEIVE.MODIFY
    DLC_UNSUPPORTED_COMMAND,                            // 0x2b DIR.DEFINE.MIF.ENVIRONMENT  CCB1 ONLY
    IOCTL_DLC_TIMER_CANCEL_GROUP,                       // 0x2c DIR.TIMER.CANCEL.GROUP
    IOCTL_DLC_SET_EXCEPTION_FLAGS,                      // 0x2d DIR.SET.EXCEPTION.FLAGS
    DLC_UNSUPPORTED_COMMAND,                            // 0x2e no command
    DLC_UNSUPPORTED_COMMAND,                            // 0x2f no command
    IOCTL_DLC_BUFFER_CREATE,                            // 0x30 BUFFER.CREATE
    IOCTL_DLC_READ | DLC_ASYNCHRONOUS_FLAG,             // 0x31 READ
    IOCTL_DLC_READ_CANCEL,                              // 0x32 READ.CANCEL
    DLC_UNSUPPORTED_COMMAND,                            // 0x33 DLC.SET.THRESHOLD
    IOCTL_DLC_CLOSE_DIRECT | DLC_ASYNCHRONOUS_FLAG,     // 0x34 DIR.CLOSE.DIRECT
    IOCTL_DLC_OPEN_DIRECT,                              // 0x35 DIR.OPEN.DIRECT
    DLC_UNSUPPORTED_COMMAND                             // 0x36 PURGE.RESOURCES
};

CRITICAL_SECTION AdapterOpenSection;


//
// macros
//

//
// The next procedure has been implemented as macro, because it is on
// the critical path (used by BufferFree and all old transmit commands)
//

#ifdef DLCAPI_DBG

VOID
CopyToDescriptorBuffer(
    IN OUT PLLC_TRANSMIT_DESCRIPTOR pDescriptors,
    IN PLLC_XMIT_BUFFER pDlcBufferQueue,
    IN BOOLEAN DeallocateBufferAfterUse,
    IN OUT PUINT pIndex,
    IN OUT PLLC_XMIT_BUFFER *ppBuffer,
    IN OUT PUINT pDlcStatus
    )

/*++

Routine Description:

    Function translates the link list of DLC buffers to a NT DLC descriptor
    array to be used as the input parameter for dlc device driver.
    (NT driver may have only one input buffer => we cannot use any link
     list structures to give parameters to a NT dlc driver).

Arguments:

    pDescriptors - NT DLC descriptor array

    pDlcBufferQueue - pointer to a link list of DLC buffers

    DeallocateBufferAfterUse - the flag is set, if the dlc buffers
        are released back to buffer pool when the frame is sent or
        if this routine is called by buffer free.

    pIndex - current index of the descriptor array

    ppLastBuffer - pointer to the next buffer, if the maximum size of
        the current descriptor table in stack is exceeded.  This feature
        is used, if the number buffers in free list given to BufferFree
        is bigger that the maximum number of slots in the descriptor
        array (allocated from stack).
        It's an error, if this parameter has non null value, when we
        returne back to the transmit command.


Return Value:

    LLC_STATUS_TRANSMIT_ERROR - there are too many transmit buffers
        (over 128) for the static descriptor buffer, that is allocated
        from the stack.

--*/

{
    *ppBuffer = pDlcBufferQueue;
    *pDlcStatus = LLC_STATUS_SUCCESS;

    while (*ppBuffer != NULL) {

        //
        // Check the overflow of the internal xmit buffer in stack and
        // the loop counter, that prevents the forever loop of zero length
        // transmit buffer (the buffer chain might be circular)
        //

        if (*pIndex >= MAX_TRANSMIT_SEGMENTS) {
            *pDlcStatus = LLC_STATUS_TRANSMIT_ERROR;
            break;
        }

        //
        // Buffer free may free buffers having 0 data bytes (just the
        // lan and LLC headers).
        //

        pDescriptors[*pIndex].pBuffer = &(*ppBuffer)->auchData[(*ppBuffer)->cbUserData];
        pDescriptors[*pIndex].cbBuffer = (*ppBuffer)->cbBuffer;
        pDescriptors[*pIndex].eSegmentType = LLC_NEXT_DATA_SEGMENT;
        pDescriptors[*pIndex].boolFreeBuffer = DeallocateBufferAfterUse;

        //
        // We will reset all next pointers of the released buffers
        // to break loops in the buffer chain of BufferFree
        // request.  BufferFree would loop for ever with a circular
        // buffer link list.
        //

        if (DeallocateBufferAfterUse) {

            PLLC_XMIT_BUFFER    pTempNext;

            pTempNext = (*ppBuffer)->pNext;
            (*ppBuffer)->pNext = NULL;
            *ppBuffer = pTempNext;
        } else {
            *ppBuffer = (*ppBuffer)->pNext;
        }
        *pIndex++;
    }
}

#else

#define CopyToDescriptorBuffer(pDescriptors,                                                \
                               pDlcBufferQueue,                                             \
                               DeallocateBufferAfterUse,                                    \
                               pIndex,                                                      \
                               ppBuffer,                                                    \
                               pDlcStatus                                                   \
                               )                                                            \
{                                                                                           \
    (*ppBuffer) = pDlcBufferQueue;                                                          \
    (*pDlcStatus) = LLC_STATUS_SUCCESS;                                                     \
                                                                                            \
    while ((*ppBuffer) != NULL) {                                                           \
                                                                                            \
        if (*pIndex >= MAX_TRANSMIT_SEGMENTS) {                                             \
            (*pDlcStatus) = LLC_STATUS_TRANSMIT_ERROR;                                      \
            break;                                                                          \
        }                                                                                   \
                                                                                            \
        pDescriptors[*pIndex].pBuffer = &((*ppBuffer)->auchData[(*ppBuffer)->cbUserData]);  \
        pDescriptors[*pIndex].cbBuffer = (*ppBuffer)->cbBuffer;                             \
        pDescriptors[*pIndex].eSegmentType = LLC_NEXT_DATA_SEGMENT;                         \
        pDescriptors[*pIndex].boolFreeBuffer = DeallocateBufferAfterUse;                    \
                                                                                            \
        if (DeallocateBufferAfterUse) {                                                     \
                                                                                            \
            PLLC_XMIT_BUFFER pTempNext;                                                     \
                                                                                            \
            pTempNext = (*ppBuffer)->pNext;                                                 \
            (*ppBuffer)->pNext = NULL;                                                      \
            (*ppBuffer) = pTempNext;                                                        \
        } else {                                                                            \
            (*ppBuffer) = (*ppBuffer)->pNext;                                               \
        }                                                                                   \
        (*pIndex)++;                                                                        \
    }                                                                                       \
}

#endif

//
// functions
//


ACSLAN_STATUS
AcsLan(
    IN OUT PLLC_CCB pCCB,
    OUT PLLC_CCB* ppBadCcb
    )

/*++

Routine Description:

    Native NT DLC API (ACSLAN) entry point.  Called from Win32 applications

Arguments:

    pCCB        - pointer to CCB (CCB2 = OS/2 DLC Command Control Block)
    ppBadCcb    - returned pointer to failing CCB

Return Value:

    ACSLAN_STATUS
        Success - ACSLAN_STATUS_COMMAND_ACCEPTED
                    Successfully accepted or completed CCB

        Failure - ACSLAN_STATUS_INVALID_CCB_POINTER
                    Next CCB pointer field is invalid

                  ACSLAN_STATUS_CCB_IN_ERROR
                    Error code returned in only/first CCB

                  ACSLAN_STATUS_CHAINED_CCB_IN_ERROR
                    Error code returned in a chained CCB

                  ACSLAN_STATUS_SYSTEM_STATUS
                    Unexpected system error, check the system status field

                  ACSLAN_STATUS_INVALID_COMMAND
                    The first CCB pointer or bad CCB pointer was invalid

--*/

{

    UINT AcslanStatus;
    UINT Status;
    PLLC_CCB pFirstCcb = pCCB;

    IF_DEBUG(DUMP_ACSLAN) {
        IF_DEBUG(DUMP_INPUT_CCB) {
            DUMPCCB(pCCB, TRUE, TRUE);
        }
    }

    try {

        if (pCCB->uchDlcCommand >= LLC_MAX_DLC_COMMAND) {

            pCCB->uchDlcStatus = LLC_STATUS_INVALID_COMMAND;
            AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;

        } else if (pCCB->pNext == NULL) {

            //
            // 99.9% of all DLC commands are not chained. We execute
            // them as a special case to avoid the wasting of the CPU
            // cycles with that CCB chaining stuff
            //

            //
            // DOS DLC needs three different CCB pointers.
            // In Windows/Nt there is only one.
            // We cannot complete the synchronous commands
            // by the io-system, because another thread waiting
            // for the event to complete might be signalled before
            // the status and the output parameters have been set
            // in the CCB and its parameter table
            //

            AcslanStatus = ACSLAN_STATUS_COMMAND_ACCEPTED;

            if (IS_SYNCHRONOUS(pCCB->uchDlcCommand)) {

                //
                // synchronous command: let the driver do the work then set
                // the status field in the output CCB to the value returned
                // by the driver
                //

                Status = NtAcsLan(pCCB, pCCB, pCCB, NULL);
                pCCB->uchDlcStatus = (UCHAR)Status;
                if (Status != LLC_STATUS_SUCCESS) {
                    AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;

                    //
                    // RLF 05/18/93
                    //
                    // If NtAcsLan returns the CCB.NEXT field pointing at the CCB,
                    // set it to NULL
                    //

                    if (pCCB->pNext == pCCB) {
                        pCCB->pNext = NULL;
                    }

                }

                //
                // here we handle asyncronous completion of the synchronous
                // commands by using the READ command
                //
                // RLF 04/23/93 Bogus: This should be handled in the driver
                //

                if (pCCB->ulCompletionFlag != 0) {
                    QueueCommandCompletion(pCCB);
                }

                //
                // Signal the event when everything has been done
                //

                if (pCCB->hCompletionEvent != NULL) {
                    SetEvent(pCCB->hCompletionEvent);
                }
            } else {

                //
                // The command completion field is used as special
                // input parameter for the chained READ commands
                //

                if (pCCB->uchDlcCommand == LLC_READ) {
                    ((PNT_DLC_READ_INPUT)pCCB->u.pParameterTable)->CommandCompletionCcbLink = NULL;
                }

                //
                // The asynchronous commands always returns a pending status
                // (we cannot touch the CCB status field because it may be
                // simultaneously accessed by another processor in MP systems)
                //

                Status = NtAcsLan(pCCB, pCCB, pCCB, pCCB->hCompletionEvent);
                if ((Status != LLC_STATUS_PENDING) && (Status != LLC_STATUS_SUCCESS)) {

//printf("ACSLAN: Async Command %#x Retcode %#x\n", pCCB->uchDlcCommand, pCCB->uchDlcStatus);

                    //
                    // Only return immediate error status on asynchronous
                    // commands if this is a transmit
                    //

                    if (IS_TRANSMIT(pCCB->uchDlcCommand)) {
                        AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                    } else if (pCCB->hCompletionEvent) {
                        SetEvent(pCCB->hCompletionEvent);
                    }
                }
            }
        } else {

            //
            // here if there is a chain of CCBs
            //

            PLLC_CCB pNextCCB;
            INT CcbCount;

            //
            // An evil app may have linked the CCBs in a circular list (it
            // happens very easily when the same transmit commands are reused
            // before they have been read from the command completion list.
            // We prevent looping forever by checking the number of linked CCBs
            // beforehand. (We will save the current command count, because the
            // CCB chain may also be corrupted during its execution)
            //

            pNextCCB = pCCB->pNext;

            //
            // note: 10240 is an arbitrary number. Any reasonably large number
            // will do, this is too large, but we'll stick with it for now
            //

            for (CcbCount = 1; pNextCCB != NULL && CcbCount < 10240; CcbCount++) {
                pNextCCB = pNextCCB->pNext;
            }
            if (CcbCount == 10240) {

                //
                // Too many commands, the CCB list must be circular
                //

                AcslanStatus = ACSLAN_STATUS_INVALID_CCB_POINTER;
            } else {

                //
                // Several CCBs may be chained together. Loop until end of
                // the list or the next CCB is a special READ CCB bound to
                // the current command
                //

                do {

                    //
                    // Set the default ACSLAN error status returned in case the
                    // given CCB pointer is invalid
                    //

                    AcslanStatus = ACSLAN_STATUS_INVALID_COMMAND;

                    //
                    // Reset the command completion link by default. We will set
                    // it if we find a READ command linked to the previous command
                    //

                    if (pCCB->uchDlcCommand == LLC_READ) {
                        ((PNT_DLC_READ_INPUT)pCCB->u.pParameterTable)->CommandCompletionCcbLink = NULL;
                    } else if (pCCB->uchDlcCommand >= LLC_MAX_DLC_COMMAND) {
                        AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                        pCCB->uchDlcStatus = LLC_STATUS_INVALID_COMMAND;
                        break;
                    }

                    //
                    // Check if there is a READ command linked to the CCB
                    // pointer of this command to be used for the command
                    // completion
                    //

                    pNextCCB = pCCB->pNext;
                    if (pNextCCB != NULL) {
                        AcslanStatus = ACSLAN_STATUS_INVALID_CCB_POINTER;
                        if (pNextCCB->uchAdapterNumber != pCCB->uchAdapterNumber) {
                            pCCB->uchDlcStatus = LLC_STATUS_CHAINED_DIFFERENT_ADAPTERS;
                            break;
                        } else {
                            if (pCCB->uchReadFlag && pCCB->ulCompletionFlag
                            && pNextCCB->uchDlcCommand == LLC_READ) {

                                //
                                // Swap the actual CCB and its read command in
                                // the linked list of sequential CCBs.
                                // Note: the chain may continue after READ
                                //

                                pNextCCB = pCCB;
                                pCCB = pCCB->pNext;
                                pNextCCB->pNext = pCCB->pNext;
                                pCCB->pNext = pNextCCB;
                                ((PNT_DLC_READ_INPUT)pCCB->u.pParameterTable)->CommandCompletionCcbLink = pNextCCB;
                            }
                        }
                    }

                    //
                    // CCB is now safe, any exceptions returned by NtAcsLan
                    // indicate an invalid (parameter) pointer within CCB
                    //

                    AcslanStatus = ACSLAN_STATUS_COMMAND_ACCEPTED;

                    //
                    // DOS DLC needs three different CCB pointers.
                    // In Windows/Nt there is only one.
                    // We cannot complete the synchronous commands
                    // by the io-system, because another thread waiting for
                    // the event to complete might be signalled before
                    // the status and the output parameters have been set
                    // in the CCB and its parameter table
                    //

                    Status = NtAcsLan(pCCB,
                                      pCCB,
                                      pCCB,
                                      IS_SYNCHRONOUS(pCCB->uchDlcCommand)
                                        ? NULL
                                        : pCCB->hCompletionEvent
                                      );
                    if (Status != LLC_STATUS_PENDING) {
                        pCCB->uchDlcStatus = (UCHAR)Status;
                    }

                    //
                    // We must stop the command execution of all commands, when we
                    // hit the first error (the next commands would assume that
                    // this command succeeded)
                    //

                    if (pCCB->uchDlcStatus != LLC_STATUS_PENDING) {

                        //
                        // here, we handle the asyncronous command completion
                        // of the synchronous commands by using the READ
                        //

                        if (IS_SYNCHRONOUS(pCCB->uchDlcCommand)) {

                            //
                            // RLF 04/23/93 Bogus: This should be handled in the driver
                            //

                            if (pCCB->ulCompletionFlag != 0) {
                                QueueCommandCompletion(pCCB);
                            }

                            //
                            // Signal the event when everything has been done
                            //

                            if (pCCB->hCompletionEvent != NULL) {
                                SetEvent(pCCB->hCompletionEvent);
                            }
                        }
                        if (pCCB->uchDlcStatus != LLC_STATUS_SUCCESS) {
                            AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                            break;
                        }
                    }
                    pCCB = pNextCCB;
                    CcbCount--;
                } while (pCCB != NULL && CcbCount > 0);

                //
                // Check if the CCB list was corrupted during its use. There
                // must be the same number of linked CCBs as in the beginning
                //

                if (pCCB != NULL && CcbCount == 0) {
                    AcslanStatus = ACSLAN_STATUS_INVALID_CCB_POINTER;
                } else if (AcslanStatus != ACSLAN_STATUS_COMMAND_ACCEPTED) {
                    if (pCCB != pFirstCcb) {
                        *ppBadCcb = pCCB;
                        AcslanStatus = ACSLAN_STATUS_CHAINED_CCB_IN_ERROR;
                    } else {
                        AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                    }
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // There was a bad pointer in the parameter table if the exception
        // occurred in NtAcsLan! If we have a chain of CCBs then we have to
        // return which was is bad, else just notify the caller that their
        // data is unacceptable
        //

        if (AcslanStatus == ACSLAN_STATUS_COMMAND_ACCEPTED) {
            pCCB->uchDlcStatus = LLC_STATUS_INVALID_PARAMETER_TABLE;
            if (pCCB != pFirstCcb) {
                *ppBadCcb = pCCB;
                AcslanStatus = ACSLAN_STATUS_CHAINED_CCB_IN_ERROR;
            } else {
                AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
            }
        }
    }

    IF_DEBUG(DUMP_ACSLAN) {
        IF_DEBUG(DUMP_OUTPUT_CCB) {
            DUMPCCB(pCCB, TRUE, FALSE);
        }
        IF_DEBUG(RETURN_CODE) {
            PUT(("AcsLan: returning %d [0x%x]\n", AcslanStatus, AcslanStatus));
        }
    }

    return AcslanStatus;
}


LLC_STATUS
NtAcsLan(
    IN PLLC_CCB pCCB,
    IN PVOID pOriginalCcbAddress,
    OUT PLLC_CCB pOutputCcb,
    IN HANDLE EventHandle OPTIONAL
    )

/*++

Routine Description:

    Extended ACSLAN entrypoint used by the native NT DLC API and DOS (and
    OS/2) DLC subsystem emulators.

    This procedure can use the smaller original DOS CCBs. All unknown
    DOS CCB parameter fields are optional parameters on the stack

Arguments:

    pCCB                - OS/2 DLC Command control block.
                          This must be double word aligned

    pOriginalCcbAddress - the original (possibly virtual DOS) CCB address.
                          This pointer cannot be used in Windows/Nt address
                          space.

    pOutputCcb          - the original CCB (32bit) pointer where the status and
                          next CCB fields are updated.
                          Might not be double word aligned.

    EventHandle         - NT event object handle

Return Value:

    LLC_STATUS - See the DLC API return values.

--*/

{
    NT_DLC_PARMS NtDlcParms;
    PNT_DLC_PARMS pNtParms;
    PLLC_PARMS pDlcParms;
    PVOID pOutputBuffer;
    UINT OutputBufferLength;
    PVOID pInputBuffer;
    UINT InputBufferSize;
    ULONG IoctlCommand;
    UINT DlcStatus;
    HANDLE DriverHandle;
    NTSTATUS NtStatus;
    UINT InfoClass;
    UINT cElement;
    UCHAR FrameType;
    UCHAR AdapterNumber;
    PUCHAR pBuffer;
    UINT CopyLength;
    UINT cbLogBuffer;
    PLLC_XMIT_BUFFER pFirstBuffer;

    IF_DEBUG(DUMP_NTACSLAN) {
        IF_DEBUG(DUMP_INPUT_CCB) {
            DUMPCCB(pCCB, TRUE, TRUE);
        }
    }

    //
    // Setup first the default values for this CCB
    //

    pCCB->uchDlcStatus = (UCHAR)LLC_STATUS_PENDING;
    pCCB->pNext = pOriginalCcbAddress;
    pDlcParms = pCCB->u.pParameterTable;

    //
    // Discard immediately any commands for closed adapters,
    // except adapter open and initialize
    //

    AdapterNumber = pCCB->uchAdapterNumber;
    EnterCriticalSection(&DriverHandlesCritSec);
    DriverHandle = aDlcDriverHandles[AdapterNumber];
    LeaveCriticalSection(&DriverHandlesCritSec);
    if (DriverHandle == NULL) {

        //
        // OS/2 DLC applications may issue DIR_INITIALIZE_ADAPTER before
        // DIR_OPEN_ADAPTER. In that case it is simply a NOP
        //

        if (pCCB->uchDlcCommand != LLC_DIR_OPEN_ADAPTER
        && pCCB->uchDlcCommand != LLC_DIR_INITIALIZE) {

            pCCB->uchDlcStatus = LLC_STATUS_ADAPTER_CLOSED;

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n",
                        pCCB->uchDlcStatus,
                        pCCB->uchDlcStatus
                        ));
                }
            }

            return pCCB->uchDlcStatus;
        }
    }

    //
    // Set the default input and output buffers and their sizes
    //

    IoctlCommand = DLC_IOCTL(pCCB->uchDlcCommand);
    if (IoctlCommand != DLC_UNSUPPORTED_COMMAND) {

        InputBufferSize = aDlcIoBuffers[((USHORT)IoctlCommand) >> 2].InputBufferSize;
        OutputBufferLength = aDlcIoBuffers[((USHORT)IoctlCommand) >> 2].OutputBufferSize;

        //
        // Set the default input and output buffers.
        //

        if (OutputBufferLength != 0) {
            pOutputBuffer = pOutputCcb;
        } else {
            pOutputBuffer = NULL;
        }
    } else {
        OutputBufferLength = 0;
        pOutputBuffer = NULL;
    }
    pInputBuffer = (PVOID)&NtDlcParms;

    switch (pCCB->uchDlcCommand) {
    case LLC_BUFFER_FREE:

        //
        // Copy the link list headers to the descriptor array
        // and build NT CCB.  Application may want to
        // free more buffers at the time then allowed by
        // by the maximum descriptor buffer size =>
        // we must loop until the whole buffer list has been released
        //

        pFirstBuffer = pDlcParms->BufferFree.pFirstBuffer;

        for ( pFirstBuffer = pDlcParms->BufferFree.pFirstBuffer,
                DlcStatus = LLC_STATUS_SUCCESS ;
              pFirstBuffer != NULL ; ) {

            cElement = 0;

            //
            // We don't need to care about errors in the buffer chain,
            // because the procedure automatically breaks all loops
            // in the buffer chain
            //

            CopyToDescriptorBuffer(NtDlcParms.BufferFree.DlcBuffer,
                                   pFirstBuffer,
                                   TRUE,    // DEALLOCATE_AFTER_USE
                                   &cElement,
                                   &pFirstBuffer,
                                   &DlcStatus
                                   );
            NtDlcParms.BufferFree.BufferCount = (USHORT)cElement;
            InputBufferSize = sizeof(LLC_TRANSMIT_DESCRIPTOR) * cElement
                            + sizeof(NT_DLC_BUFFER_FREE_PARMS)
                            - sizeof(LLC_TRANSMIT_DESCRIPTOR);

            DlcStatus = DoSyncDeviceIoControl(DriverHandle,
                                              IoctlCommand,
                                              &NtDlcParms,
                                              InputBufferSize,
                                              pDlcParms,
                                              OutputBufferLength
                                              );
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_INITIALIZE:

        //
        // DIR.INITIALIZE is actually adapter close + hardware reset, but we
        // must return OK status if the adapter is not opened. Apps should
        // not reset the adapter without a good reason because it terminates
        // all other network communication for a while, and may disconnect
        // the sessions
        //

        RtlZeroMemory(pDlcParms, sizeof(LLC_DIR_INITIALIZE_PARMS));
        if (DriverHandle == NULL) {
            pCCB->uchDlcStatus = LLC_STATUS_SUCCESS;

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n",
                        pCCB->uchDlcStatus,
                        pCCB->uchDlcStatus
                        ));
                }
            }

            return pCCB->uchDlcStatus;
        }

    case LLC_DIR_CLOSE_ADAPTER:

        //
        // protect the close with the open critical section. We do this because
        // we need to protect the driver against simultaneous closes on the same
        // handle from multiple threads within the same process. The driver needs
        // to be fixed ultimately
        //

        EnterCriticalSection(&AdapterOpenSection);

        NtStatus = NtDeviceIoControlFile(DriverHandle,
                                         EventHandle,   // Event signaled when cmd compleletes
                                         NULL,
                                         NULL,
                                         &GlobalIoStatus,
                                         IOCTL_DLC_CLOSE_ADAPTER,
                                         pCCB,
                                         InputBufferSize,
                                         pOutputCcb,
                                         OutputBufferLength
                                         );
        if (NT_SUCCESS(NtStatus)) {

            if ((NtStatus != STATUS_PENDING) && (pOutputCcb->uchDlcStatus == LLC_STATUS_PENDING)) {

//printf("ACSLAN: Success: DirCloseAdapter: DD returns %#x. Retcode=%#x\n",
//        NtStatus, pOutputCcb->uchDlcStatus);

                pOutputCcb->uchDlcStatus = (UCHAR)NtStatus;

//printf("ACSLAN: Success: DirCloseAdapter: DD returns %#x. Retcode=%#x\n",
//        NtStatus, pOutputCcb->uchDlcStatus);

            }

            //
            // it is safe to enter the handle array critical section whilst we
            // are still holding the open critical section - this is the only
            // code path that grabs both
            //

            EnterCriticalSection(&DriverHandlesCritSec);
            aDlcDriverHandles[AdapterNumber] = NULL;
            LeaveCriticalSection(&DriverHandlesCritSec);

            //
            // if the DirCloseAdapter IOCTL returns STATUS_PENDING, NtClose
            // will block in the io-system until the close adapter IOCTL completes
            //

            NtClose(DriverHandle);
        } else {

//            printf("ACSLAN: Failure: DirCloseAdapter: DD returns %#x. Retcode=%#x\n",
//                    NtStatus, pOutputCcb->uchDlcStatus);

            //
            // RLF 04/21/94
            //
            // If we picked up a handle that has been subsequently closed by
            // another thread, Io will return STATUS_INVALID_HANDLE. In this
            // case, change the status code to LLC_STATUS_ADAPTER_CLOSED
            //

            if (NtStatus == STATUS_INVALID_HANDLE) {
                pOutputCcb->uchDlcStatus = LLC_STATUS_ADAPTER_CLOSED;
            }
        }

        LeaveCriticalSection(&AdapterOpenSection);

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n",
                    pCCB->uchDlcStatus,
                    pCCB->uchDlcStatus
                    ));
            }
        }

        return pCCB->uchDlcStatus;

    case LLC_DIR_CLOSE_DIRECT:
        pCCB->u.dlc.usStationId = 0;

        //
        // fall through
        //

    case LLC_DLC_CLOSE_STATION:
    case LLC_DLC_CLOSE_SAP:
    case LLC_DLC_RESET:
        pInputBuffer = pCCB;
        break;

    case LLC_DIR_INTERRUPT:

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n",
                    LLC_STATUS_SUCCESS,
                    LLC_STATUS_SUCCESS
                    ));
            }
        }

        return LLC_STATUS_SUCCESS;


//
// define a few macros to make DIR.OPEN.ADAPTER code easier to read
//

//
// IO_PARMS - specifies DirOpenAdapter structure in NT_DLC_PARMS union for input
// to DLC device driver
//
#define IO_PARMS NtDlcParms.DirOpenAdapter

//
// OA_PARMS - specifies pointer to DIR.OPEN.ADAPTER parameter table which contains
// pointers to 4 other parameter tables
//
#define OA_PARMS pDlcParms->DirOpenAdapter

//
// EX_PARMS - specifies pointer to LLC_EXTENDED_ADAPTER_PARMS parameter table
//
#define EX_PARMS pDlcParms->DirOpenAdapter.pExtendedParms

//
// DLC_PARMS - specifies pointer to LLC_DLC_PARMS parameter table
//
#define DLC_PARMS pDlcParms->DirOpenAdapter.pDlcParms

    case LLC_DIR_OPEN_ADAPTER:

        //
        // We can only open one adapter at a time. It is very hard to completely
        // synchronize this in the driver
        //

        EnterCriticalSection(&AdapterOpenSection);

        if (DriverHandle != NULL) {
            DlcStatus = LLC_STATUS_ADAPTER_OPEN;
        } else {
            DlcStatus = OpenDlcApiDriver(EX_PARMS->pSecurityDescriptor, &DriverHandle);
        }
        if (DlcStatus == LLC_STATUS_SUCCESS) {

            //
            // We read the output to the original OS/2 CCB buffer,
            // but it is too small for the complete NDIS adapter
            // name => we will copy all input parameters to the NT CCB
            //

            pOutputBuffer = OA_PARMS.pAdapterParms;

            //
            // copy any input adapter parameters from the caller's
            // LLC_ADAPTER_OPEN_PARMS to the device driver input buffer
            //

            RtlMoveMemory(&IO_PARMS.Adapter,
                          OA_PARMS.pAdapterParms,
                          sizeof(IO_PARMS.Adapter)
                          );
            IO_PARMS.AdapterNumber = AdapterNumber;

            //
            // WE MUST CREATE NEW FIELD TO DEFINE, IF APPLICATION WANT
            // TO USE DIX or 802.3 ethernet frames under 802.2
            // (unnecessary feature, config parameter would be enough)
            //

            IO_PARMS.NtDlcIoctlVersion = NT_DLC_IOCTL_VERSION;
            IO_PARMS.pSecurityDescriptor = EX_PARMS->pSecurityDescriptor;
            IO_PARMS.hBufferPoolHandle = EX_PARMS->hBufferPool;
            IO_PARMS.LlcEthernetType = EX_PARMS->LlcEthernetType;
            IO_PARMS.NdisDeviceName.Buffer = (WCHAR *)IO_PARMS.Buffer;
            IO_PARMS.NdisDeviceName.MaximumLength = sizeof(IO_PARMS.Buffer);

            //
            // get the configuration info from the registry
            //

            DlcStatus = GetAdapterNameAndParameters(
                            AdapterNumber % LLC_MAX_ADAPTERS,
                            &IO_PARMS.NdisDeviceName,
                            (PUCHAR)&IO_PARMS.LlcTicks,
                            &IO_PARMS.LlcEthernetType
                            );
            if (DlcStatus == LLC_STATUS_SUCCESS) {

                //
                // copy the name buffer into the IO buffer and free the former
                //

                RtlMoveMemory(&IO_PARMS.Buffer,
                              IO_PARMS.NdisDeviceName.Buffer,
                              IO_PARMS.NdisDeviceName.Length
                              );

                //
                // ensure the name is actually zero-terminated for the call to
                // RtlInitUnicodeString
                //

                IO_PARMS.Buffer[IO_PARMS.NdisDeviceName.Length/sizeof(WCHAR)] = 0;

                //
                // finished with UNICODE_STRING allocated in GetAdapterName...
                //

                RtlFreeUnicodeString(&IO_PARMS.NdisDeviceName);

                //
                // fill the UNICODE_STRING back in to point at our buffer
                //

                RtlInitUnicodeString(&IO_PARMS.NdisDeviceName, IO_PARMS.Buffer);

                //
                // now perform the actual open of the adapter for this process
                //

                DlcStatus = DoSyncDeviceIoControl(
                                DriverHandle,
                                IOCTL_DLC_OPEN_ADAPTER,
                                &NtDlcParms,
                                sizeof(NT_DIR_OPEN_ADAPTER_PARMS),
                                pOutputBuffer,
                                sizeof(LLC_ADAPTER_OPEN_PARMS)
                                );
            }
            if (DlcStatus == LLC_STATUS_SUCCESS) {

                //
                // get the timer tick values from the driver for this adapter
                //

                DlcStatus = DlcGetInfo(DriverHandle,
                                       DLC_INFO_CLASS_DLC_TIMERS,
                                       0,
                                       &DLC_PARMS->uchT1_TickOne,
                                       sizeof(LLC_TICKS)
                                       );

                //
                // set the returned maxima to the default maxima as per the
                // IBM LAN Tech. Ref.
                //

                DLC_PARMS->uchDlcMaxSaps = 127;
                DLC_PARMS->uchDlcMaxStations = 255;
                DLC_PARMS->uchDlcMaxGroupSaps = 126;
                DLC_PARMS->uchDlcMaxGroupMembers = 127;

                //
                // this adapter is now successfully opened for this process
                //

                EnterCriticalSection(&DriverHandlesCritSec);
                aDlcDriverHandles[AdapterNumber] = DriverHandle;
                LeaveCriticalSection(&DriverHandlesCritSec);
            }
        }
        LeaveCriticalSection(&AdapterOpenSection);

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_OUTPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

#undef IO_PARMS
#undef PO_PARMS
#undef EX_PARMS
#undef DLC_PARMS


    case LLC_BUFFER_CREATE:
    case LLC_BUFFER_GET:
    case LLC_DIR_OPEN_DIRECT:
    case LLC_DIR_SET_EXCEPTION_FLAGS:
    case LLC_DLC_REALLOCATE_STATIONS:

        //
        //  We can use the standard OS/2 CCB for input and output!
        //

        pOutputBuffer = pDlcParms;
        pInputBuffer = pDlcParms;
        break;

    case LLC_DLC_STATISTICS:

        //
        //  User may read either SAP or link statistics log
        //

        if ((NtDlcParms.DlcStatistics.usStationId & 0xff) == 0) {
            InputBufferSize = sizeof(DLC_SAP_LOG);
        } else {
            InputBufferSize = sizeof(DLC_LINK_LOG);
        }

        if (pDlcParms->DlcStatistics.uchOptions & 0x80) {
            InfoClass = DLC_INFO_CLASS_STATISTICS_RESET;
        } else {
            InfoClass = DLC_INFO_CLASS_STATISTICS;
        }
        DlcStatus = DlcGetInfo(DriverHandle,
                               InfoClass,
                               pDlcParms->DlcStatistics.usStationId,
                               NtDlcParms.DlcGetInformation.Info.Buffer,
                               InputBufferSize
                               );
        if ((ULONG)pDlcParms->DlcStatistics.cbLogBufSize < InputBufferSize) {
            InputBufferSize = (ULONG)pDlcParms->DlcStatistics.cbLogBufSize;
        }

        RtlMoveMemory(pDlcParms->DlcStatistics.pLogBuf,
                      NtDlcParms.DlcGetInformation.Info.Buffer,
                      InputBufferSize
                      );

        if (DlcStatus == LLC_STATUS_SUCCESS
        && (ULONG)pDlcParms->DlcStatistics.cbLogBufSize < InputBufferSize) {
            DlcStatus = LLC_STATUS_LOST_LOG_DATA;
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_READ_LOG:

        //
        //  We use two get info functions to read necessary stuff.
        //  Must must read even partial log buffer if user buffer
        //  is too small for the whole data (the user buffer could
        //  be even zero).
        //

        if (pDlcParms->DirReadLog.usTypeId > LLC_DIR_READ_LOG_BOTH) {

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n",
                        LLC_STATUS_INVALID_LOG_ID,
                        LLC_STATUS_INVALID_LOG_ID
                        ));
                }
            }

            return LLC_STATUS_INVALID_LOG_ID;
        }
        DlcStatus = STATUS_SUCCESS;
        CopyLength = cbLogBuffer = pDlcParms->DirReadLog.cbLogBuffer;
        pBuffer = (PUCHAR)pDlcParms->DirReadLog.pLogBuffer;

        switch (pDlcParms->DirReadLog.usTypeId) {
        case LLC_DIR_READ_LOG_BOTH:
        case LLC_DIR_READ_LOG_ADAPTER:
            if (DlcStatus == STATUS_SUCCESS) {
                DlcStatus = DlcGetInfo(DriverHandle,
                                        DLC_INFO_CLASS_ADAPTER_LOG,
                                        0,
                                        NtDlcParms.DlcGetInformation.Info.Buffer,
                                        sizeof(LLC_ADAPTER_LOG)
                                        );
            }
            if (cbLogBuffer > sizeof(LLC_ADAPTER_LOG)) {
                CopyLength = sizeof(LLC_ADAPTER_LOG);
            }
            if (pDlcParms->DirReadLog.usTypeId == LLC_DIR_READ_LOG_BOTH) {
                RtlMoveMemory(pBuffer,
                              NtDlcParms.DlcGetInformation.Info.Buffer,
                              CopyLength
                              );
                cbLogBuffer -= CopyLength;
                pBuffer += CopyLength;
                CopyLength = cbLogBuffer;

                DlcStatus = DlcGetInfo(DriverHandle,
                                        DLC_INFO_CLASS_STATISTICS_RESET,
                                        0,
                                        NtDlcParms.DlcGetInformation.Info.Buffer,
                                        sizeof(LLC_DIRECT_LOG)
                                        );
                if (cbLogBuffer > sizeof(LLC_DIRECT_LOG)) {
                    CopyLength = sizeof(LLC_DIRECT_LOG);
                }
            }

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;

        case LLC_DIR_READ_LOG_DIRECT:
            DlcStatus = DlcGetInfo(DriverHandle,
                                    DLC_INFO_CLASS_STATISTICS_RESET,
                                    0,
                                    NtDlcParms.DlcGetInformation.Info.Buffer,
                                    sizeof(LLC_DIRECT_LOG)
                                    );
            if (cbLogBuffer > sizeof(LLC_DIRECT_LOG)) {
                CopyLength = sizeof(LLC_DIRECT_LOG);
            }
            break;
        }
        RtlMoveMemory(pBuffer,
                      NtDlcParms.DlcGetInformation.Info.Buffer,
                      CopyLength
                      );

        if (aMinDirLogSize[pDlcParms->DirReadLog.usTypeId] > pDlcParms->DirReadLog.cbLogBuffer) {
            pDlcParms->DirReadLog.cbActualLength = aMinDirLogSize[pDlcParms->DirReadLog.usTypeId];
            DlcStatus = LLC_STATUS_LOST_LOG_DATA;
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_SET_FUNCTIONAL_ADDRESS:
        if (pCCB->u.auchBuffer[0] & (UCHAR)0x80) {
            InfoClass = DLC_INFO_CLASS_RESET_FUNCTIONAL;
        } else {
            InfoClass = DLC_INFO_CLASS_SET_FUNCTIONAL;
        }
        DlcStatus = DlcSetInfo(DriverHandle,
                               InfoClass,
                               0,
                               &NtDlcParms.DlcSetInformation,
                               pCCB->u.auchBuffer,
                               sizeof(TR_BROADCAST_ADDRESS)
                               );

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_SET_GROUP_ADDRESS:
        return DlcSetInfo(DriverHandle,
                          DLC_INFO_CLASS_SET_GROUP,
                          0,
                          &NtDlcParms.DlcSetInformation,
                          pCCB->u.auchBuffer,
                          sizeof(TR_BROADCAST_ADDRESS)
                          );

    case LLC_DIR_SET_MULTICAST_ADDRESS:
        return DlcSetInfo(DriverHandle,
                          DLC_INFO_CLASS_SET_MULTICAST,
                          0,
                          &NtDlcParms.DlcSetInformation,
                          pCCB->u.pParameterTable,
                          sizeof(LLC_DIR_MULTICAST_ADDRESS)
                          );

    case LLC_DIR_STATUS:

        //
        // We will generic DlcGetInfo to read the status info.
        // some parameters must be moved ot correct places.
        //

        RtlZeroMemory(pDlcParms, sizeof(LLC_DIR_STATUS_PARMS));
        DlcStatus = DlcGetInfo(DriverHandle,
                               DLC_INFO_CLASS_DIR_ADAPTER,
                               0,
                               &NtDlcParms.DlcGetInformation.Info.DirAdapter,
                               sizeof(LLC_ADAPTER_INFO)
                               );
        if (DlcStatus != LLC_STATUS_SUCCESS) {

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;
        }
        RtlMoveMemory(pDlcParms->DirStatus.auchNodeAddress,
                      &NtDlcParms.DlcGetInformation.Info.DirAdapter,
                      sizeof(LLC_ADAPTER_INFO)
                      );
        pDlcParms->DirStatus.usAdapterType =
            NtDlcParms.DlcGetInformation.Info.DirAdapter.usAdapterType;

        //
        // Set the adapter config flags, the only thing we actually
        // can know, if the current link speed on the adapter.
        // In the other fields we just use the default values.
        // Keep the bit defining extended DOS parameters unchanged,
        // but all other bits may be changed.
        //

        pDlcParms->DirStatus.uchAdapterConfig &= ~0x20; // DOS extended parms
        if (NtDlcParms.DlcGetInformation.Info.DirAdapter.ulLinkSpeed ==
            TR_16Mbps_LINK_SPEED) {
            pDlcParms->DirStatus.uchAdapterConfig |=
                0x10 |      // early release token
                0x0c |      // 64 kB RAM on a 4/16 IBM token-ring adapter
                0x01;       // adapter rate is 16 Mbps
        } else {
            pDlcParms->DirStatus.uchAdapterConfig |=
                0x0c;       // 64 kB RAM on adapter
        }
        DlcStatus = DlcGetInfo(DriverHandle,
                               DLC_INFO_CLASS_PERMANENT_ADDRESS,
                               0,
                               pDlcParms->DirStatus.auchPermanentAddress,
                               6
                               );
        if (DlcStatus != LLC_STATUS_SUCCESS) {

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;
        }
        DlcStatus = DlcGetInfo(DriverHandle,
                               DLC_INFO_CLASS_DLC_ADAPTER,
                               0,
                               &pDlcParms->DirStatus.uchMaxSap,
                               sizeof(struct _DlcAdapterInfoGet)
                               );

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_READ_CANCEL:
    case LLC_DIR_TIMER_CANCEL:
    case LLC_RECEIVE_CANCEL:

        //
        //  Copy pointer of the cancelled command to the
        //  byte aligned output buffer.
        //

        NtDlcParms.DlcCancelCommand.CcbAddress = (PVOID)pDlcParms;
        //SmbPutUlong(&pOutputCcb->pNext, (ULONG_PTR) pDlcParms);
        pOutputCcb->pNext = (PVOID) pDlcParms;
        break;

    case LLC_DIR_TIMER_CANCEL_GROUP:
    case LLC_DIR_TIMER_SET:
        pInputBuffer = pCCB;
        break;

    case LLC_DLC_CONNECT_STATION:

        NtDlcParms.Async.Ccb = *(PNT_DLC_CCB)pCCB;
        NtDlcParms.Async.Parms.DlcConnectStation.StationId = pDlcParms->DlcConnectStation.usStationId;

        if (pDlcParms->DlcConnectStation.pRoutingInfo != NULL) {

            NtDlcParms.Async.Parms.DlcConnectStation.RoutingInformationLength = *pDlcParms->DlcConnectStation.pRoutingInfo & (UCHAR)0x1f;

            RtlMoveMemory(NtDlcParms.Async.Parms.DlcConnectStation.aRoutingInformation,
                          pDlcParms->DlcConnectStation.pRoutingInfo,
                          NtDlcParms.Async.Parms.DlcConnectStation.RoutingInformationLength
                          );
        } else {

            NtDlcParms.Async.Parms.DlcConnectStation.RoutingInformationLength=0;

        }
        break;

    case LLC_DOS_DLC_FLOW_CONTROL:

        //
        // This is an official entry to DlcFlowControl used by
        // VDM DLC support DLL to set a link buffer busy state.
        //

        NtDlcParms.DlcFlowControl.FlowControlOption = (UCHAR)pCCB->u.dlc.usParameter;
        NtDlcParms.DlcFlowControl.StationId = pCCB->u.dlc.usStationId;
        break;

    case LLC_DLC_FLOW_CONTROL:

        //
        // This is the official entry to DlcFlowControl
        //

        NtDlcParms.DlcFlowControl.FlowControlOption = (UCHAR)(pCCB->u.dlc.usParameter & LLC_VALID_FLOW_CONTROL_BITS);
        NtDlcParms.DlcFlowControl.StationId = pCCB->u.dlc.usStationId;
        break;

    case LLC_DLC_MODIFY:
        RtlMoveMemory(&NtDlcParms.DlcSetInformation.Info.LinkStation,
                      &pDlcParms->DlcModify.uchT1,
                      sizeof(DLC_LINK_PARAMETERS)
                      );
        NtDlcParms.DlcSetInformation.Info.LinkStation.TokenRingAccessPriority = pDlcParms->DlcModify.uchAccessPriority;

        //
        // This is a non-standard extension: DlcModify returns
        // the maximum allowed information field lentgh for a link station.
        // (it depends on length of source routing and bridges
        // between two stations).
        //

        if ((pDlcParms->DlcModify.usStationId & 0x00ff) != 0) {
            DlcStatus = DlcGetInfo(DriverHandle,
                                   DLC_INFO_CLASS_LINK_STATION,
                                   pDlcParms->DlcModify.usStationId,
                                   &pDlcParms->DlcModify.usMaxInfoFieldLength,
                                   sizeof(USHORT)
                                   );
        }
        DlcStatus = DlcSetInfo(DriverHandle,
                               DLC_INFO_CLASS_LINK_STATION,
                               pDlcParms->DlcModify.usStationId,
                               &NtDlcParms.DlcSetInformation,
                               NULL,
                               sizeof(DLC_LINK_PARAMETERS)
                               );

        //
        // Set the group information, if there is any
        //

        if (DlcStatus == LLC_STATUS_SUCCESS && pDlcParms->DlcModify.cGroupCount != 0) {
            NtDlcParms.DlcSetInformation.Info.Sap.GroupCount = pDlcParms->DlcModify.cGroupCount;
            RtlMoveMemory(NtDlcParms.DlcSetInformation.Info.Sap.GroupList,
                          pDlcParms->DlcModify.pGroupList,
                          pDlcParms->DlcModify.cGroupCount
                          );
            DlcStatus = DlcSetInfo(DriverHandle,
                                   DLC_INFO_CLASS_GROUP,
                                   pDlcParms->DlcModify.usStationId,
                                   &NtDlcParms.DlcSetInformation,
                                   NULL,
                                   sizeof(struct _DlcSapInfoSet)
                                   );
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DLC_OPEN_SAP:

        //
        // DlcOpenSap uses the original OS/2 CCB, but it has to modify a couple
        // fields. There is a separate call to setup the group SAPS because
        // they cannot use the original CCB parameter table (it's a pointer)
        //

        pNtParms = (PNT_DLC_PARMS)pDlcParms;

        pNtParms->DlcOpenSap.LinkParameters.TokenRingAccessPriority = pDlcParms->DlcOpenSap.uchOptionsPriority & (UCHAR)0x1F;

        DlcStatus = DoSyncDeviceIoControl(DriverHandle,
                                          IOCTL_DLC_OPEN_SAP,
                                          pNtParms,
                                          sizeof(NT_DLC_OPEN_SAP_PARMS),
                                          pNtParms,
                                          sizeof(NT_DLC_OPEN_SAP_PARMS)
                                          );
        if (DlcStatus != LLC_STATUS_SUCCESS) {
            pOutputCcb->uchDlcStatus = (UCHAR)DlcStatus;

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;
        }

        //
        // Check if there is defined any group saps
        //

        if (pDlcParms->DlcOpenSap.cGroupCount != 0) {
            NtDlcParms.DlcSetInformation.Info.Sap.GroupCount = pDlcParms->DlcOpenSap.cGroupCount;
            RtlMoveMemory(&NtDlcParms.DlcSetInformation.Info.Sap.GroupList,
                          pDlcParms->DlcOpenSap.pGroupList,
                          pDlcParms->DlcOpenSap.cGroupCount
                          );
            DlcStatus = DlcSetInfo(DriverHandle,
                                   DLC_INFO_CLASS_GROUP,
                                   pDlcParms->DlcOpenSap.usStationId,
                                   &NtDlcParms.DlcSetInformation,
                                   NULL,
                                   sizeof(struct _DlcSapInfoSet)
                                   );
        }
        pOutputCcb->uchDlcStatus = (UCHAR)DlcStatus;

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DLC_OPEN_STATION:
        NtDlcParms.DlcOpenStation.RemoteSap = pDlcParms->DlcOpenStation.uchRemoteSap;
        NtDlcParms.DlcOpenStation.LinkStationId = pDlcParms->DlcOpenStation.usSapStationId;
        RtlMoveMemory(NtDlcParms.DlcOpenStation.aRemoteNodeAddress,
                      pDlcParms->DlcOpenStation.pRemoteNodeAddress,
                      6
                      );
        RtlMoveMemory(&NtDlcParms.DlcOpenStation.LinkParameters,
                      &pDlcParms->DlcOpenStation.uchT1,
                      sizeof(DLC_LINK_PARAMETERS)
                      );
        NtDlcParms.DlcOpenStation.LinkParameters.TokenRingAccessPriority = pDlcParms->DlcOpenStation.uchAccessPriority;
        pOutputBuffer = &pDlcParms->DlcOpenStation.usLinkStationId;
        break;

    case LLC_READ:

#ifdef GRAB_READ

        if (pCCB->hCompletionEvent) {

            PREAD_GRABBER pGrabberStruct;

            pGrabberStruct = (PREAD_GRABBER)LocalAlloc(LMEM_FIXED, sizeof(READ_GRABBER));
            pGrabberStruct->pCcb = pCCB;
            pGrabberStruct->OriginalEventHandle = pCCB->hCompletionEvent;
            pGrabberStruct->NewEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
            EventHandle = pGrabberStruct->NewEventHandle;
            AddReadGrabber(pGrabberStruct);
        } else {
            OutputDebugString(L"NtAcsLan: LLC_READ with no event!\n");
        }

#endif

        //
        // IOCTL_DLC_READ have two output buffer, one for CCB and another
        // for the actual data.  IOCTL_DLC_READ2 is a read request, that
        // have the second outbut buffer immediately after the firt one =>
        // we don't need to lock, map, copy, unmap and unlock the second
        // output buffer.  The same thing has been implemented for receive.
        //

        if (pDlcParms != NULL && pDlcParms != (PVOID)&pCCB[1]) {
            OutputBufferLength = sizeof(NT_DLC_CCB_OUTPUT);
            NtDlcParms.Async.Ccb = *(PNT_DLC_CCB)pCCB;
            NtDlcParms.Async.Parms.ReadInput = *(PNT_DLC_READ_INPUT)pDlcParms;
        } else {
            IoctlCommand = IOCTL_DLC_READ2;
            OutputBufferLength = sizeof(NT_DLC_READ_PARMS) + sizeof(LLC_CCB);
            pInputBuffer = pCCB;
        }
        break;

    case LLC_RECEIVE:
        OutputBufferLength = sizeof(NT_DLC_CCB_OUTPUT);
        if (pDlcParms != NULL && pDlcParms != (PVOID)&pCCB[1]) {
            NtDlcParms.Async.Ccb = *(PNT_DLC_CCB)pCCB;
            NtDlcParms.Async.Parms.Receive = pDlcParms->Receive;

            //
            // We don't actually receive any data with receive command,
            // if the receive flag is set.
            //

            if (NtDlcParms.Async.Parms.Receive.ulReceiveFlag != 0) {
                IoctlCommand = IOCTL_DLC_RECEIVE2;
            }
        } else {
            IoctlCommand = IOCTL_DLC_RECEIVE2;
            pInputBuffer = pCCB;
        }
        break;

    case LLC_TRANSMIT_DIR_FRAME:
        FrameType = LLC_DIRECT_TRANSMIT;
        goto TransmitHandling;

    case LLC_TRANSMIT_UI_FRAME:
        FrameType = LLC_UI_FRAME;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_CMD:
        FrameType = LLC_XID_COMMAND_POLL;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_RESP_FINAL:
        FrameType = LLC_XID_RESPONSE_FINAL;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
        FrameType = LLC_XID_RESPONSE_NOT_FINAL;
        goto TransmitHandling;

    case LLC_TRANSMIT_TEST_CMD:
        FrameType = LLC_TEST_COMMAND_POLL;
        goto TransmitHandling;

    case LLC_TRANSMIT_I_FRAME:
        FrameType = LLC_I_FRAME;

TransmitHandling:

        //
        // Copy the link list headers to the descriptor array and build NT CCB.
        // (BUG-BUG-BUG: We should implement the send of multiple frames.
        // loop CCB chain as far as the same CCB command and transmit commands
        // completed with READ)
        //

        OutputBufferLength = sizeof(NT_DLC_CCB_OUTPUT);

        //
        // This stuff is for DOS DLC, the transmit parameter table may have been
        // copied if it was unaligned
        //

        //SmbPutUlong((PULONG)&pOutputCcb->pNext, (ULONG)pOriginalCcbAddress);
        pOutputCcb->pNext = (PVOID) pOriginalCcbAddress;
        RtlMoveMemory((PUCHAR)&NtDlcParms.Async.Ccb, (PUCHAR)pOutputCcb, sizeof(NT_DLC_CCB));

        pOutputCcb->uchDlcStatus = (UCHAR)LLC_STATUS_PENDING;
        NtDlcParms.Async.Parms.Transmit.FrameType = FrameType;
        NtDlcParms.Async.Parms.Transmit.StationId = pDlcParms->Transmit.usStationId;
        NtDlcParms.Async.Parms.Transmit.RemoteSap = pDlcParms->Transmit.uchRemoteSap;
        NtDlcParms.Async.Parms.Transmit.XmitReadOption = pDlcParms->Transmit.uchXmitReadOption;

        cElement = 0;
        if (pDlcParms->Transmit.pXmitQueue1 != NULL) {
            CopyToDescriptorBuffer(NtDlcParms.Async.Parms.Transmit.XmitBuffer,
                                   pDlcParms->Transmit.pXmitQueue1,
                                   FALSE,   // DO_NOT_DEALLOCATE
                                   &cElement,
                                   &pFirstBuffer,
                                   &DlcStatus
                                   );
            if (DlcStatus != STATUS_SUCCESS) {
                pCCB->uchDlcStatus = (UCHAR)DlcStatus;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
        }
        if (pDlcParms->Transmit.pXmitQueue2 != NULL) {
            CopyToDescriptorBuffer(NtDlcParms.Async.Parms.Transmit.XmitBuffer,
                                   pDlcParms->Transmit.pXmitQueue2,
                                   TRUE,    // DEALLOCATE_AFTER_USE
                                   &cElement,
                                   &pFirstBuffer,
                                   &DlcStatus
                                   );

            //
            // The Queue2 pointer must be reset always.
            // This doesn't work for DOS DLC buffers, but it does not
            // matter, because this feature is not needed by VDM DLC
            // (we cannot access pOutputCcb or its parameter block,
            // because they may be unaligned)
            //

            pDlcParms->Transmit.pXmitQueue2 = NULL;

            if (DlcStatus != STATUS_SUCCESS) {
                pCCB->uchDlcStatus = (UCHAR)DlcStatus;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
        }
        if (pDlcParms->Transmit.cbBuffer1 != 0) {
            if (cElement == MAX_TRANSMIT_SEGMENTS) {
                pCCB->uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].pBuffer = pDlcParms->Transmit.pBuffer1;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].cbBuffer = pDlcParms->Transmit.cbBuffer1;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].boolFreeBuffer = FALSE;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            cElement++;
        }
        if (pDlcParms->Transmit.cbBuffer2 != 0) {
            if (cElement == MAX_TRANSMIT_SEGMENTS) {
                pCCB->uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].pBuffer = pDlcParms->Transmit.pBuffer2;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].cbBuffer = pDlcParms->Transmit.cbBuffer2;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].boolFreeBuffer = FALSE;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            cElement++;
        }
        NtDlcParms.Async.Parms.Transmit.XmitBuffer[0].eSegmentType = LLC_FIRST_DATA_SEGMENT;
        NtDlcParms.Async.Parms.Transmit.XmitBufferCount = cElement;
        InputBufferSize = sizeof(LLC_TRANSMIT_DESCRIPTOR) * cElement
                        + sizeof(NT_DLC_TRANSMIT_PARMS)
                        + sizeof(NT_DLC_CCB)
                        - sizeof(LLC_TRANSMIT_DESCRIPTOR);
        break;

        //
        // Multiple frame transmit:
        //     - atomic operation: single error => all are discarded
        //       by error, but some successful packets may have been sent
        //       after the unsuccessful one.
        //     - No DLC frame headers are included
        //     - LAN header must always be in the first buffer,
        //     - 3 dwords reserved for DLC in the beginning.
        // good: provides the minimal system overhead
        // bad: error handling may be difficult in some cases
        // new data link operation:
        //     cancel packets by request handle, called when an
        //     error has occurred (this would require a new
        //     one level request handle)
        //

    case LLC_TRANSMIT_FRAMES:

        //
        // We must copy the actual CCB to the parameter table only if
        // the CCB is not allocated within the transmit command structure
        //

        if (&pDlcParms->Transmit2.Ccb != pCCB) {
            pDlcParms->Transmit2.Ccb = *pCCB;
        }
        pInputBuffer = pDlcParms;
        InputBufferSize = (sizeof(LLC_TRANSMIT_DESCRIPTOR)
                        * (UINT)pDlcParms->Transmit2.cXmitBufferCount)
                        + sizeof(LLC_TRANSMIT2_COMMAND)
                        - sizeof(LLC_TRANSMIT_DESCRIPTOR);
        break;

    default:
        return LLC_STATUS_INVALID_COMMAND;
    }

    NtStatus = NtDeviceIoControlFile(DriverHandle,
                                     EventHandle,       // Event signaled when cmd completes
                                     NULL,              // no APC routine
                                     NULL,              // no context for APC
                                     &GlobalIoStatus,   // global I/O status block
                                     IoctlCommand,      // map DLC cmd codes to Nt IoCtl codes
                                     pInputBuffer,
                                     InputBufferSize,
                                     pOutputBuffer,
                                     OutputBufferLength
                                     );

    //
    // The io-completion directly updates Status and next CCB pointer
    // of this CCB when the main function return status pending.
    // If the status code is non-pending (error or ok), then we
    // must save the status code to CCB and reset next CCB pointer.
    //

    if (NtStatus != STATUS_PENDING) {

        //
        // Reset the next pointer if the command is still linked to itself.
        // For example the cancel command returns a pointer to the cancelled
        // CCB in the next CCB pointer (pNext)
        //

        if (pCCB->pNext == pOutputCcb) {
            pCCB->pNext = NULL;
        }

        pCCB->uchDlcStatus = (UCHAR)NtStatus;

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_OUTPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", pCCB->uchDlcStatus, pCCB->uchDlcStatus));
            }
        }

#if DBG
        if (pOutputCcb->uchDlcStatus == 0xA1) {
            OutputDebugString(TEXT("NtAcsLan returning 0xA1\n"));
            //DebugBreak();
        }

        if (pOutputCcb->uchDlcCommand == LLC_TRANSMIT_I_FRAME && pOutputCcb->uchDlcStatus != LLC_STATUS_SUCCESS) {

            WCHAR buf[80];

            wsprintf(buf, TEXT("NtAcsLan: I-Frame returning %#02x\n"), pOutputCcb->uchDlcStatus);
            OutputDebugString(buf);
        }

        if (pCCB->uchDlcStatus != pOutputCcb->uchDlcStatus) {

            WCHAR buf[80];

            wsprintf(buf, TEXT("NtAcsLan: pCCB->uchDlcStatus = %#02x; pOutputCcb->uchDlcStatus = %#02x\n"),
                    pCCB->uchDlcStatus,
                    pOutputCcb->uchDlcStatus
                    );
            OutputDebugString(buf);
        }
#endif

        return pCCB->uchDlcStatus;

    } else {

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_OUTPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
            }
        }

        return LLC_STATUS_PENDING;

    }
}


USHORT
GetCcbStationId(
    IN PLLC_CCB pCCB
    )

/*++

Routine Description:

    The function returns the station id used by the given ccb.
    -1 is returned, if the command didn't have any station id.

Arguments:

    pCCB - OS/2 DLC Command control block


Return Value:

    Station Id
    -1          No station id

--*/

{
    switch (pCCB->uchDlcCommand) {
    case LLC_BUFFER_FREE:
    case LLC_BUFFER_CREATE:
    case LLC_BUFFER_GET:
    case LLC_DLC_REALLOCATE_STATIONS:
    case LLC_DLC_STATISTICS:
    case LLC_READ:
    case LLC_RECEIVE:
    case LLC_TRANSMIT_DIR_FRAME:
    case LLC_TRANSMIT_UI_FRAME:
    case LLC_TRANSMIT_XID_CMD:
    case LLC_TRANSMIT_XID_RESP_FINAL:
    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
    case LLC_TRANSMIT_TEST_CMD:
    case LLC_TRANSMIT_I_FRAME:
    case LLC_TRANSMIT_FRAMES:
    case LLC_DLC_CONNECT_STATION:
    case LLC_DLC_MODIFY:
        return pCCB->u.pParameterTable->DlcModify.usStationId;

    case LLC_DLC_FLOW_CONTROL:
    case LLC_DLC_CLOSE_STATION:
    case LLC_DLC_CLOSE_SAP:
    case LLC_DIR_CLOSE_DIRECT:
    case LLC_DLC_RESET:
        return pCCB->u.dlc.usStationId;

    default:
        return (USHORT)-1;
    }
}


LLC_STATUS
OpenDlcApiDriver(
    IN PVOID pSecurityDescriptor,
    OUT HANDLE* pHandle
    )

/*++

Routine Description:

    Opens a handle to the DLC driver

Arguments:

    pSecurityDescriptor - pointer to security descriptor
    pHandle             - pointer to returned handle if success

Return Value:

    LLC_STATUS
        Success - LLC_STATUS_SUCCESS
        Failure - LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED

--*/

{
    IO_STATUS_BLOCK iosb;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING DriverName;
    NTSTATUS Status;

    RtlInitUnicodeString(&DriverName, DD_DLC_DEVICE_NAME);

    InitializeObjectAttributes(
            &objattr,                       // obj attr to initialize
            &DriverName,                    // string to use
            OBJ_CASE_INSENSITIVE,           // Attributes
            NULL,                           // Root directory
            pSecurityDescriptor             // Security Descriptor
            );

    Status = NtCreateFile(
                pHandle,                    // ptr to handle
                GENERIC_READ                // desired...
                | GENERIC_WRITE,            // ...access
                &objattr,                   // name & attributes
                &iosb,                      // I/O status block.
                NULL,                       // alloc size.
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_DELETE           // share...
                | FILE_SHARE_READ
                | FILE_SHARE_WRITE,         // ...access
                FILE_OPEN_IF,               // create disposition
                0,                          // ...options
                NULL,                       // EA buffer
                0L                          // Ea buffer len
                );

    if (Status != STATUS_SUCCESS) {
        return LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED;
    }
    return LLC_STATUS_SUCCESS;
}


LLC_STATUS
GetAdapterNameAndParameters(
    IN UINT AdapterNumber,
    OUT PUNICODE_STRING pNdisName,
    OUT PUCHAR pTicks,
    OUT PLLC_ETHERNET_TYPE pLlcEthernetType
    )

/*++

Routine Description:

    Get the adapter mapping for AdapterNumber from the registry. Also, get the
    Ethernet type and

Arguments:

    AdapterNumber - DLC adapter number (0, 1, 2 ... 15)

    pNdisName - the returned unicode name string

    pTicks -

    pLlcEthernetType -

Return Value:

    LLC_STATUS

--*/

{
    LLC_STATUS llcStatus;
    LONG regStatus;
    HKEY hkey;

    static LPTSTR subkey = TEXT("System\\CurrentControlSet\\Services\\Dlc\\Linkage");

    regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             subkey,
                             0,
                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                             &hkey
                             );
    if (regStatus == ERROR_SUCCESS) {

        DWORD type;
        DWORD dataSize;
        LPTSTR buffer;
        LPTSTR tempbuffer;

        //
        // here we try to get all the info in one go from the registry. If
        // the "Bind" value has grown to more than 1024 bytes, then we must
        // try to reallocate the buffer and try again. If it fails a second
        // time, then give up
        //

        buffer = (LPTSTR)LocalAlloc(LMEM_FIXED, DEFAULT_QUERY_BUFFER_LENGTH);
        if (buffer) {
            dataSize = DEFAULT_QUERY_BUFFER_LENGTH;
            regStatus = RegQueryValueEx(hkey,
                                        TEXT("Bind"),
                                        NULL,   // lpdwReserved
                                        &type,
                                        (LPBYTE)buffer,
                                        &dataSize
                                        );
            if (regStatus == ERROR_SUCCESS || regStatus == ERROR_MORE_DATA) {
                llcStatus = LLC_STATUS_SUCCESS;

                //
                // This code not tested - Realloc don't work
                //
                if (dataSize > DEFAULT_QUERY_BUFFER_LENGTH) {

                    DWORD oldSize;

                    //
                    // more available than I anticipated. Try growing the buffer.
                    // Add an extra DEFAULT_BINDING_LENGTH in case somebody's
                    // adding to this entry whilst we're reading it (unlikely)
                    //

                    oldSize = dataSize;
                    dataSize += DEFAULT_BINDING_LENGTH;
                    tempbuffer = buffer;
                    buffer = (LPTSTR)LocalReAlloc((HLOCAL)buffer, dataSize, 0);
                    if (buffer) {
                        regStatus = RegQueryValueEx(hkey,
                                                    subkey,
                                                    NULL,   // lpdwReserved
                                                    &type,
                                                    (LPBYTE)buffer,
                                                    &dataSize
                                                    );
                        if (regStatus != ERROR_SUCCESS) {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        } else if (dataSize > oldSize) {

                            //
                            // data has grown since last call? Bogus?
                            //

                            llcStatus = LLC_STATUS_NO_MEMORY;
                        }
                    } else {
                        LocalFree(tempbuffer);

                        //
                        // Is this error code acceptable in this circumstance?
                        //

                        llcStatus = LLC_STATUS_NO_MEMORY;
                    }
                }
                if (llcStatus == LLC_STATUS_SUCCESS) {

                    //
                    // we managed to read something from the registry. Try to
                    // locate our adapter. The returned data is wide-character
                    // strings (better be, lets check the type first)
                    //

                    if (type == REG_MULTI_SZ) {

                        DWORD i;
                        LPTSTR pBinding = buffer;

                        for (i = 0; i != AdapterNumber; ++i) {
                            pBinding = wcschr(pBinding, L'\0') + 1;
                            if (!*pBinding) {
                                break;
                            }
                        }

                        //
                        // if there is a binding corresponding to this adapter
                        // number (e.g. \Device\IbmTok01) then make a copy of
                        // the string and make it into a UNICODE_STRING. The
                        // caller uses RtlFreeUnicodeString
                        //
                        // Does RtlFreeUnicodeString know that I used
                        // LocalAlloc to allocate the string?
                        //

                        if (*pBinding) {

                            LPTSTR bindingName;

                            bindingName = (LPTSTR)LocalAlloc(
                                                LMEM_FIXED,
                                                (wcslen(pBinding) + 1)
                                                    * sizeof(WCHAR)
                                                );
                            if (bindingName) {
                                wcscpy(bindingName, pBinding);
                                RtlInitUnicodeString(pNdisName, bindingName);

//#if DBG
//                                DbgPrint("DLCAPI.DLL: Adapter %d maps to %ws\n",
//                                         AdapterNumber,
//                                         pBinding
//                                         );
//#endif
                            } else {
                                llcStatus = LLC_STATUS_NO_MEMORY;
                            }
                        } else {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        }
                    } else {

                        //
                        // unexpected type in registry
                        //

                        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                    }
                }
            } else {
                llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
            }
            if (buffer) {
                LocalFree(buffer);
            }

            //
            // for now, default the ticks and ethernet type
            //

            RtlZeroMemory(pTicks, sizeof(LLC_TICKS));

            //
            // if the app passed in anything other than those values we
            // recognize, convert to AUTO.
            //
            // Note: we should really return an error (invalid parameter) in
            // this case, since it means the app is passing in a bad value,
            // but at this late stage, it is better to accept invalid input
            // and default it than to risk an app/printer monitor stopping
            // working (RLF 05/10/93)
            //

            if (*pLlcEthernetType != LLC_ETHERNET_TYPE_AUTO
            && *pLlcEthernetType != LLC_ETHERNET_TYPE_DEFAULT
            && *pLlcEthernetType != LLC_ETHERNET_TYPE_DIX
            && *pLlcEthernetType != LLC_ETHERNET_TYPE_802_3) {
                *pLlcEthernetType = LLC_ETHERNET_TYPE_AUTO;
            }
        } else {

            //
            // Is this error code acceptable in this circumstance?
            //

            llcStatus = LLC_STATUS_NO_MEMORY;
        }
        RegCloseKey(hkey);
    } else {
        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
    }

    return llcStatus;
}



LLC_STATUS
GetAdapterNameFromNumber(
    IN UINT AdapterNumber,
    OUT LPTSTR pNdisName
    )

/*++

Routine Description:

    Get the adapter name mapping for AdapterNumber from the registry.

Arguments:

    AdapterNumber - DLC adapter number (0, 1, 2 ... 15)

    pNdisName - the returned zero-terminated wide character string

Return Value:

    LLC_STATUS

--*/

{
    LLC_STATUS llcStatus;
    LONG regStatus;
    HKEY hkey;

    static LPTSTR subkey = TEXT("System\\CurrentControlSet\\Services\\Dlc\\Linkage");

    regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             subkey,
                             0,
                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                             &hkey
                             );
    if (regStatus == ERROR_SUCCESS) {

        DWORD type;
        DWORD dataSize;
        LPTSTR buffer;

        //
        // here we try to get all the info in one go from the registry. If
        // the "Bind" value has grown to more than 1024 bytes, then we must
        // try to reallocate the buffer and try again. If it fails a second
        // time, then give up
        //

        buffer = (LPTSTR)LocalAlloc(LMEM_FIXED, DEFAULT_QUERY_BUFFER_LENGTH);
        if (buffer) {
            dataSize = DEFAULT_QUERY_BUFFER_LENGTH;
            regStatus = RegQueryValueEx(hkey,
                                        TEXT("Bind"),
                                        NULL,   // lpdwReserved
                                        &type,
                                        (LPBYTE)buffer,
                                        &dataSize
                                        );
            if (regStatus == ERROR_SUCCESS || regStatus == ERROR_MORE_DATA) {
                llcStatus = LLC_STATUS_SUCCESS;

                //
                // this code not tested - Realloc don't work
                //

                if (dataSize > DEFAULT_QUERY_BUFFER_LENGTH) {

                    DWORD oldSize;

                    //
                    // more available than I anticipated. Try growing the buffer.
                    // Add an extra DEFAULT_BINDING_LENGTH in case somebody's
                    // adding to this entry whilst we're reading it (unlikely)
                    //

                    oldSize = dataSize;
                    dataSize += DEFAULT_BINDING_LENGTH;
                    buffer = (LPTSTR)LocalReAlloc((HLOCAL)buffer, dataSize, 0);
                    if (buffer) {
                        regStatus = RegQueryValueEx(hkey,
                                                    subkey,
                                                    NULL,   // lpdwReserved
                                                    &type,
                                                    (LPBYTE)buffer,
                                                    &dataSize
                                                    );
                        if (regStatus != ERROR_SUCCESS) {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        } else if (dataSize > oldSize) {

                            //
                            // data has grown since last call? Bogus?
                            //

                            llcStatus = LLC_STATUS_NO_MEMORY;
                        }
                    } else {

                        //
                        // Is this error code acceptable in this circumstance?
                        //

                        llcStatus = LLC_STATUS_NO_MEMORY;
                    }
                }
                if (llcStatus == LLC_STATUS_SUCCESS) {

                    //
                    // we managed to read something from the registry. Try to
                    // locate our adapter. The returned data is wide-character
                    // strings (better be, lets check the type first)
                    //

                    if (type == REG_MULTI_SZ) {

                        DWORD i;
                        LPTSTR pBinding = buffer;

                        for (i = 0; i != AdapterNumber; ++i) {
                            pBinding = wcschr(pBinding, L'\0') + 1;
                            if (!*pBinding) {
                                break;
                            }
                        }

                        //
                        // if there is a binding corresponding to this adapter
                        // number (e.g. \Device\IbmTok01)

                        if (*pBinding) {
			    wcscpy(pNdisName, pBinding);
                        } else {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        }
                    } else {

                        //
                        // unexpected type in registry
                        //

                        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                    }
                }
            } else {
                llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
            }

	    LocalFree(buffer);

        }

	else {
	  llcStatus = LLC_STATUS_NO_MEMORY;
	}
	
        RegCloseKey(hkey);
    } else {
      llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
    }

    return llcStatus;
}



LLC_STATUS
GetAdapterNumberFromName(
    IN LPTSTR pNdisName,
    OUT UINT *AdapterNumber
    )

/*++

Routine Description:

    Get the adapter number mapping for AdapterName from the registry.

Arguments:

    pNdisName - zero-terminated wide character string

    AdapterNumber - returned DLC adapter number (0, 1, 2 ... 15)

Return Value:

    LLC_STATUS

--*/

{
    LLC_STATUS llcStatus;
    LONG regStatus;
    HKEY hkey;

    static LPTSTR subkey = TEXT("System\\CurrentControlSet\\Services\\Dlc\\Linkage");

    regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             subkey,
                             0,
                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                             &hkey
                             );
    if (regStatus == ERROR_SUCCESS) {

        DWORD type;
        DWORD dataSize;
        LPTSTR buffer;

        //
        // here we try to get all the info in one go from the registry. If
        // the "Bind" value has grown to more than 1024 bytes, then we must
        // try to reallocate the buffer and try again. If it fails a second
        // time, then give up
        //

        buffer = (LPTSTR)LocalAlloc(LMEM_FIXED, DEFAULT_QUERY_BUFFER_LENGTH);
        if (buffer) {
            dataSize = DEFAULT_QUERY_BUFFER_LENGTH;
            regStatus = RegQueryValueEx(hkey,
                                        TEXT("Bind"),
                                        NULL,   // lpdwReserved
                                        &type,
                                        (LPBYTE)buffer,
                                        &dataSize
                                        );
            if (regStatus == ERROR_SUCCESS || regStatus == ERROR_MORE_DATA) {
                llcStatus = LLC_STATUS_SUCCESS;

                //
                // this code not tested - Realloc don't work
                //

                if (dataSize > DEFAULT_QUERY_BUFFER_LENGTH) {

                    DWORD oldSize;

                    //
                    // more available than I anticipated. Try growing the buffer.
                    // Add an extra DEFAULT_BINDING_LENGTH in case somebody's
                    // adding to this entry whilst we're reading it (unlikely)
                    //

                    oldSize = dataSize;
                    dataSize += DEFAULT_BINDING_LENGTH;
                    buffer = (LPTSTR)LocalReAlloc((HLOCAL)buffer, dataSize, 0);
                    if (buffer) {
                        regStatus = RegQueryValueEx(hkey,
                                                    subkey,
                                                    NULL,   // lpdwReserved
                                                    &type,
                                                    (LPBYTE)buffer,
                                                    &dataSize
                                                    );
                        if (regStatus != ERROR_SUCCESS) {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        } else if (dataSize > oldSize) {

                            //
                            // data has grown since last call? Bogus?
                            //

                            llcStatus = LLC_STATUS_NO_MEMORY;
                        }
                    } else {

                        //
                        // is this error code acceptable in this circumstance?
                        //

                        llcStatus = LLC_STATUS_NO_MEMORY;
                    }
                }
                if (llcStatus == LLC_STATUS_SUCCESS) {

                    //
                    // we managed to read something from the registry. Try to
                    // locate our adapter. The returned data is wide-character
                    // strings (better be, lets check the type first)
                    //

                    if (type == REG_MULTI_SZ) {

                        DWORD i;
                        LPTSTR pBinding = buffer;

			// here we map the name to number
			
			i = 0;
			while (*pBinding) {
			  if (!_wcsnicmp(pBinding, pNdisName, DEFAULT_BINDING_LENGTH)) {
			    break;
			  }
			  pBinding = wcschr(pBinding, L'\0') + 1;
			  if (!*pBinding) {
			    break;
			  }
			  i++;
			}
			
                        //
                        // if there is a binding corresponding to this adapter
                        // name (e.g. \Device\IbmTok01)
                        //

                        if (*pBinding) {
			    *AdapterNumber = i;
                        } else {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        }
                    } else {

                        //
                        // unexpected type in registry
                        //

                        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                    }
                }
            } else {
                llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
            }

	    LocalFree(buffer);
	}
	
	else {
	  llcStatus = LLC_STATUS_NO_MEMORY;
	}
	
        RegCloseKey(hkey);
    }

    else {
      llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
    }

    return llcStatus;
}


LLC_STATUS
DoSyncDeviceIoControl(
    IN HANDLE DeviceHandle,
    IN ULONG IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler

Arguments:

    DeviceHandle        - device handle of the current address object
    IoctlCommand        - DLC command code
    pInputBuffer        - input parameters
    InputBufferLength   - lenght of input parameters
    pOutputBuffer       - the returned data
    OutputBufferLength  - the length of the returned data

Return Value:

    LLC_STATUS

--*/

{
    NTSTATUS NtStatus;

    NtStatus = NtDeviceIoControlFile(DeviceHandle,
                                     NULL,  // Event
                                     NULL,  // ApcRoutine
                                     NULL,  // ApcContext
                                     &GlobalIoStatus,
                                     IoctlCommand,
                                     pInputBuffer,
                                     InputBufferLength,
                                     pOutputBuffer,
                                     OutputBufferLength
                                     );

    //
    // NT DLC driver never returns any errors as NT error status.
    // => the CCB pointer had to be invalid, if NtDeviceIoctl returns
    // error
    //

    if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_PENDING) {
        if (NtStatus > LLC_STATUS_MAX_ERROR) {

            //
            // NT DLC driver should never any errors as NT error status.
            // => the CCB pointer must be invalid, if NtDeviceIoctl
            // returns an nt error status.
            //

            NtStatus = LLC_STATUS_INVALID_POINTER_IN_CCB;
        }
    }
    return (LLC_STATUS)NtStatus;
}


LLC_STATUS
DlcGetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler.

Arguments:

    DriverHandle        - the device handle of the address object
    InfoClass           - the type of the requested information
    StationId           - direct, link or sap station id
    pOutputBuffer       - the returned info structure
    OutputBufferLength  - output buffer length

Return Value:

    LLC_STATUS

--*/

{
    NT_DLC_QUERY_INFORMATION_PARMS GetInformation;

    GetInformation.Header.StationId = StationId;
    GetInformation.Header.InfoClass = (USHORT)InfoClass;

    return DoSyncDeviceIoControl(DriverHandle,
                                 IOCTL_DLC_QUERY_INFORMATION,
                                 &GetInformation,
                                 sizeof(NT_DLC_QUERY_INFORMATION_INPUT),
                                 pOutputBuffer,
                                 OutputBufferLength
                                 );
}


LLC_STATUS
DlcSetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PNT_DLC_SET_INFORMATION_PARMS pSetInfoParms,
    IN PVOID DataBuffer,
    IN UINT DataBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler.

Arguments:

    DriverHandle        - the device handle of the address object
    InfoClass           - the type of the requested information
    StationId           - direct, link or sap station id
    pSetInfoParms       - NT DLC parameter buffer
    DataBuffer          - actual set data buffer copied to the parameter buffer
    DataBufferLength    - length of the data buffer.

Return Value:

    LLC_STATUS

--*/

{
    pSetInfoParms->Header.StationId = StationId;
    pSetInfoParms->Header.InfoClass = (USHORT)InfoClass;

    if (DataBuffer != NULL) {
        RtlMoveMemory(pSetInfoParms->Info.Buffer, DataBuffer, DataBufferLength);
    }

    return DoSyncDeviceIoControl(DriverHandle,
                                 IOCTL_DLC_SET_INFORMATION,
                                 pSetInfoParms,
                                 DataBufferLength + sizeof(struct _DlcSetInfoHeader),
                                 NULL,
                                 0
                                 );
}


LLC_STATUS
DlcCallDriver(
    IN UINT AdapterNumber,
    IN UINT IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler.

Arguments:

    AdapterNumber       - the requested adapter number (0 or 1)
    IoctlCommand        - DLC driver Ioctl code
    pInputBuffer        - input parameters
    InputBufferLength   - length of input parameters
    pOutputBuffer       - the returned data
    OutputBufferLength  - the length of the returned data

Return Value:

    LLC_STATUS

--*/

{
    NTSTATUS NtStatus;
    HANDLE driverHandle;

    EnterCriticalSection(&DriverHandlesCritSec);
    driverHandle = aDlcDriverHandles[AdapterNumber];
    LeaveCriticalSection(&DriverHandlesCritSec);

    if (driverHandle) {
        NtStatus = NtDeviceIoControlFile(driverHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &GlobalIoStatus,
                                         IoctlCommand,
                                         pInputBuffer,
                                         InputBufferLength,
                                         pOutputBuffer,
                                         OutputBufferLength
                                         );
    } else {
        NtStatus = STATUS_INVALID_HANDLE;
    }

    //
    // if we get a real NT error (e.g. because the handle was invalid) then
    // convert it into an adapter closed error
    //

    if (!NT_SUCCESS(NtStatus)) {
        if ((NtStatus == STATUS_INVALID_HANDLE) || (NtStatus == STATUS_OBJECT_TYPE_MISMATCH)) {

            //
            // bad handle
            //

            return LLC_STATUS_ADAPTER_CLOSED;
        } else if (NtStatus > LLC_STATUS_MAX_ERROR) {

            //
            // the NT DLC driver does not return any NT-level errors. If we get
            // an NT-level error, then it must be because the IO subsystem
            // detected an invalid pointer in the data we passed. Return an
            // invalid pointer error
            //

            NtStatus = LLC_STATUS_INVALID_POINTER_IN_CCB;
        }
    } else if (NtStatus == STATUS_PENDING) {

        //
        // STATUS_PENDING is a success status
        //

        NtStatus = LLC_STATUS_PENDING;
    }

    return (LLC_STATUS)NtStatus;
}

#ifdef GRAB_READ

DWORD ReadGrabberCount = 2;
HANDLE ReadGrabberHandles[64];
PREAD_GRABBER ReadGrabberListHead = NULL;
PREAD_GRABBER ReadGrabberListTail = NULL;
CRITICAL_SECTION ReadGrabberListSect;

#endif


BOOLEAN
DllEntry(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    Function initializes dlc for a new thread and terminates it in the
    process exit.

Arguments:

    DllHandle   - don't need this
    Reason      - why this function is being called
    Context     - don't need this either

Return Value:

    TRUE    - nothing cannot go wrong in the initialization and
              we cannot return error in close (or should we?).

--*/

{
    static LLC_CCB OutputCcb;           // MUST BE STATIC!!!

    UNREFERENCED_PARAMETER(DllHandle);  // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);    // avoid compiler warnings

    if (Reason == DLL_PROCESS_ATTACH) {

#ifdef GRAB_READ

        DWORD threadId;

        OutputDebugString(L"DllEntry: Initializing ReadGrabber\n");
        InitializeCriticalSection(&ReadGrabberListSect);
        ReadGrabberHandles[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
        ReadGrabberHandles[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReadGrabber, NULL, 0, &threadId);

#endif

        //
        // The global event handle is used to prevent the io-system
        // to block calls, that are completed by READ.
        //

        InitializeCriticalSection(&AdapterOpenSection);
        InitializeCriticalSection(&DriverHandlesCritSec);
        RtlZeroMemory((PVOID)aDlcDriverHandles, sizeof(aDlcDriverHandles));

#if DBG
        GetAcslanDebugFlags();
#endif

    } else if (Reason == DLL_PROCESS_DETACH) {

        UINT i;
        LLC_CCB CloseCcb;

#ifdef GRAB_READ

        ResetEvent(ReadGrabberHandles[0]);

#endif

        //
        // We must issue DIR_CLOSE_ADAPTER command for all
        // opened adapters.  Process exit does not close these
        // handles before all pending IRPs have been completed.
        // Thus this code actually flush all IRPs on dlc and lets
        // IO- system to complete the cleanup.
        //

        RtlZeroMemory(&CloseCcb, sizeof(CloseCcb));
        CloseCcb.uchDlcCommand = LLC_DIR_CLOSE_ADAPTER;

        for (i = 0; i < LLC_MAX_ADAPTER_NUMBER; i++) {
            if (aDlcDriverHandles[i] != NULL) {
                CloseCcb.uchAdapterNumber = (UCHAR)i;
                NtDeviceIoControlFile(aDlcDriverHandles[i],
                                      NULL,
                                      NULL,
                                      NULL,
                                      &GlobalIoStatus,
                                      IOCTL_DLC_CLOSE_ADAPTER,
                                      &CloseCcb,
                                      sizeof(NT_DLC_CCB_INPUT),
                                      &OutputCcb,
                                      sizeof(NT_DLC_CCB_OUTPUT)
                                      );
            }
        }

#if DBG
        if (hDumpFile) {
            fflush(hDumpFile);
            fclose(hDumpFile);
        }
#endif

        //DeleteCriticalSection(&AdapterOpenSection);
        //DeleteCriticalSection(&DriverHandlesCritSec);
    }

    return TRUE;
}


VOID
QueueCommandCompletion(
    IN PLLC_CCB pCCB
    )

/*++

Routine Description:

    The routine queues a command completion event of a synchronous DLC command
    to the command completion queue on the DLC driver.

    RLF 04/23/93 Bogus: This should be handled in the driver

Arguments:

    pCCB - OS/2 DLC Command control block, this must be double word aligned

Return Value:

    LLC_STATUS - See the DLC API return values.

--*/

{
    NT_DLC_COMPLETE_COMMAND_PARMS CompleteCommand;
    UINT Status;

    CompleteCommand.pCcbPointer = pCCB;
    CompleteCommand.CommandCompletionFlag = pCCB->ulCompletionFlag;
    CompleteCommand.StationId = GetCcbStationId(pCCB);

    Status = DoSyncDeviceIoControl(aDlcDriverHandles[pCCB->uchAdapterNumber],
                                   IOCTL_DLC_COMPLETE_COMMAND,
                                   &CompleteCommand,
                                   sizeof(CompleteCommand),
                                   NULL,
                                   0
                                   );
    if (Status != STATUS_SUCCESS) {
        pCCB->uchDlcStatus = (UCHAR)Status;
    }
}

#ifdef GRAB_READ

PLLC_CCB Last8ReadCcbs[8];
DWORD LastReadCcbIndex = 0;

PLLC_PARMS Last8ReadParameterTables[8];
DWORD LastReadParameterTableIndex = 0;

DWORD Last8IFramesReceived[8];
DWORD LastReceivedIndex = 0;

DWORD NextIFrame = 0;

VOID ReadGrabber() {

    DWORD status;
    PLLC_CCB readCcb;
    WCHAR buf[100];
//    static DWORD NextIFrame = 0;
    PREAD_GRABBER grabbedRead;

    while (1) {
        if (ReadGrabberCount > 3) {
            wsprintf(buf, L"ReadGrabber: waiting for %d handles\n", ReadGrabberCount);
            OutputDebugString(buf);
        }
        status = WaitForMultipleObjects(ReadGrabberCount,
                                        ReadGrabberHandles,
                                        FALSE,
                                        INFINITE
                                        );
        if (status >= WAIT_OBJECT_0 && status < WAIT_OBJECT_0 + ReadGrabberCount) {
            if (status == WAIT_OBJECT_0) {
                OutputDebugString(L"ReadGrabber terminating\n");
                ExitThread(0);
            } else if (status != WAIT_OBJECT_0+1) {
//                wsprintf(buf, L"ReadGrabber: READ completed. Index %d\n", status);
//                OutputDebugString(buf);
                if (grabbedRead = RemoveReadGrabber(ReadGrabberHandles[status])) {
                    readCcb = grabbedRead->pCcb;
                    Last8ReadCcbs[LastReadCcbIndex] = readCcb;
                    LastReadCcbIndex = (LastReadCcbIndex + 1) & 7;
                    Last8ReadParameterTables[LastReadParameterTableIndex] = readCcb->u.pParameterTable;
                    LastReadParameterTableIndex = (LastReadParameterTableIndex + 1) & 7;
                    if (readCcb->u.pParameterTable->Read.uchEvent & LLC_EVENT_RECEIVE_DATA) {

                        PLLC_BUFFER pBuffer;
                        INT i;

                        if (readCcb->u.pParameterTable->Read.uchEvent != LLC_EVENT_RECEIVE_DATA) {
                            OutputDebugString(L"ReadGrabber: RECEIVED DATA + other events\n");
                        }
                        pBuffer = readCcb->u.pParameterTable->Read.Type.Event.pReceivedFrame;
                        for (i = readCcb->u.pParameterTable->Read.Type.Event.usReceivedFrameCount; i; --i) {
                            if (pBuffer->NotContiguous.uchMsgType == LLC_I_FRAME) {

                                DWORD thisDlcHeader;

                                thisDlcHeader = *(ULONG UNALIGNED*)(pBuffer->NotContiguous.auchDlcHeader);
                                if (thisDlcHeader & 0x00FF0000 != NextIFrame) {
                                    wsprintf(buf,
                                             L"Error: ReadGrabber: This=%08X. Next=%08X\n",
                                             thisDlcHeader,
                                             NextIFrame
                                             );
                                    OutputDebugString(buf);
                                }
                                NextIFrame = (thisDlcHeader + 0x00020000) & 0x00FF0000;
                                Last8IFramesReceived[LastReceivedIndex] = thisDlcHeader & 0x00FF0000;
                                LastReceivedIndex = (LastReceivedIndex + 1) & 7;
                                wsprintf(buf, L"%08X ", thisDlcHeader);
                                OutputDebugString(buf);
                            }
                            pBuffer = pBuffer->NotContiguous.pNextFrame;
                            if (!pBuffer && i > 1) {
                                OutputDebugString(L"ReadGrabber: Next frame is NULL, Count > 1!\n");
                                break;
                            }
                        }
                        if (pBuffer) {
                            OutputDebugString(L"ReadGrabber: Error: More frames linked!\n");
                        }
                    } else {
                        if (!(readCcb->u.pParameterTable->Read.uchEvent & LLC_EVENT_TRANSMIT_COMPLETION)) {
                            wsprintf(buf,
                                    L"\nReadGrabber: Event = %02X\n",
                                    readCcb->u.pParameterTable->Read.uchEvent
                                    );
                            OutputDebugString(buf);
                        }
                    }
//                    DUMPCCB(readCcb, TRUE, FALSE);
//                    wsprintf(buf, L"ReadGrabber: Closing Handle %08X\n", grabbedRead->NewEventHandle);
//                    OutputDebugString(buf);
                    CloseHandle(grabbedRead->NewEventHandle);
                    readCcb->hCompletionEvent = grabbedRead->OriginalEventHandle;
//                    wsprintf(buf, L"ReadGrabber: Signalling Event %08X\n", grabbedRead->OriginalEventHandle);
//                    OutputDebugString(buf);
                    SetEvent(grabbedRead->OriginalEventHandle);
                    LocalFree((HLOCAL)grabbedRead);
                }
//            } else {
//                OutputDebugString(L"ReadGrabber: something added to list!\n");
            }
            ReadGrabberCount = MungeReadGrabberHandles();
            if (status == WAIT_OBJECT_0+1) {
                ResetEvent(ReadGrabberHandles[1]);
            }
        } else {

            INT i;

            if (status == 0xFFFFFFFF) {
                status = GetLastError();
            }
            wsprintf(buf, L"Yoiks: didn't expect this? status = %d\nHandle array:\n", status);
            OutputDebugString(buf);

            for (i = 0; i < ReadGrabberCount; ++i) {
                wsprintf(buf, L"Handle %d: %08X\n", i, ReadGrabberHandles[i]);
                OutputDebugString(buf);
            }
        }
    }
}

DWORD MungeReadGrabberHandles() {

    INT i;
    PREAD_GRABBER p;
    WCHAR buf[100];

    EnterCriticalSection(&ReadGrabberListSect);
    p = ReadGrabberListHead;
    for (i = 2; p; ++i) {
        ReadGrabberHandles[i] = p->NewEventHandle;
//        wsprintf(buf, L"MungeReadGrabber: adding Struct %08X Ccb %08X Handle %08X, index %d\n",
//                p,
//                p->pCcb,
//                ReadGrabberHandles[i],
//                i
//                );
//        OutputDebugString(buf);
        p = p->List;
    }
    LeaveCriticalSection(&ReadGrabberListSect);
    return i;
}

VOID AddReadGrabber(PREAD_GRABBER pStruct) {

    WCHAR buf[100];
    PREAD_GRABBER pRead;
    BOOL found = FALSE;

    EnterCriticalSection(&ReadGrabberListSect);
//    for (pRead = ReadGrabberListHead; pRead; pRead = pRead->List) {
//        if (pRead->pCcb == pStruct->pCcb) {
//            wsprintf(buf, L"AddReadGrabber: CCB %08X already on list. Ignoring\n",
//                    pStruct->pCcb
//                    );
//            OutputDebugString(buf);
//            LocalFree((HLOCAL)pStruct);
//            found = TRUE;
//            break;
//        }
//    }
//    if (!found) {
        if (!ReadGrabberListHead) {
            ReadGrabberListHead = pStruct;
        } else {
            ReadGrabberListTail->List = pStruct;
        }
        ReadGrabberListTail = pStruct;
        pStruct->List = NULL;
//        wsprintf(buf, L"AddReadGrabber: adding %08X, CCB %08X New Handle %08X Old Handle %08X\n",
//                pStruct,
//                pStruct->pCcb,
//                pStruct->NewEventHandle,
//                pStruct->OriginalEventHandle
//                );
//        OutputDebugString(buf);
        SetEvent(ReadGrabberHandles[1]);
//    }
    LeaveCriticalSection(&ReadGrabberListSect);
}

PREAD_GRABBER RemoveReadGrabber(HANDLE hEvent) {

    PREAD_GRABBER this, prev;
    WCHAR buf[100];

    EnterCriticalSection(&ReadGrabberListSect);
    prev = NULL;
    for (this = ReadGrabberListHead; this; this = this->List) {
        if (this->NewEventHandle == hEvent) {
            break;
        } else {
            prev = this;
        }
    }
    if (!this) {
        wsprintf(buf, L"RemoveReadGrabber: Can't find handle %08X in ReadGrabberList\n",
                hEvent
                );
        OutputDebugString(buf);
    } else {
        if (prev) {
            prev->List = this->List;
        } else {
            ReadGrabberListHead = this->List;
        }
        if (ReadGrabberListTail == this) {
            ReadGrabberListTail = prev;
        }
    }
    LeaveCriticalSection(&ReadGrabberListSect);

//    wsprintf(buf, L"RemoveReadGrabber: removed %08X, CCB %08X Handle %08X\n",
//            this,
//            this ? this->pCcb : 0,
//            this ? this->NewEventHandle : 0
//            );
//    OutputDebugString(buf);

    return this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dbgmsg.h ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
       dbgmsg.h

 Abstract:       
       
       Debug message macros and zones.
       
 Author:
 
       Scott Holden (sholden)  2/8/1999
       
 Revision History:

--*/

#if DBG

extern  int DbgSettings;

#define DEBUGZONE(n)  (DbgSettings & (0x00000001<<n))

#define DEBUGMSG(dbgs,format) ((dbgs) ? DbgPrint format:0)

#define DBG_INIT                DEBUGZONE(0)
#define DBG_NDIS_OPEN           DEBUGZONE(1)
#define DBG_NDIS_BIND           DEBUGZONE(2)
#define DBG_NDIS_TX             DEBUGZONE(3)
#define DBG_NDIS_RX             DEBUGZONE(4)

#define DBG_REF                 DEBUGZONE(28)
#define DBG_VERBOSE             DEBUGZONE(29)
#define DBG_WARN                DEBUGZONE(30)
#define DBG_ERROR               DEBUGZONE(31)

#else

#define DEBUGMSG(d,f)   (0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\api\dlcdll.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    dlcdll.h

Abstract:

    This module incldes all files needed to compile
    the NT DLC DLL API module.

Author:

    Antti Saarenheimo (o-anttis) 20-09-1991

Revision History:

--*/

//
// System APIs:
//

#include <nt.h>

#ifndef OS2_EMU_DLC

#include <ntrtl.h>
#include <nturtl.h>

#if !defined(UNICODE)
#define UNICODE                         // want wide character registry functions
#endif

#include <windows.h>
#include <winreg.h>
#define INCLUDE_IO_BUFFER_SIZE_TABLE    // includes the io buffer sizes

#endif  // OS2_EMU_DLC

#include <memory.h>
#include <stdlib.h>
#include <stdio.h>

//
// Inlcude the smb macros to handle the unaligned dos ccb and parameter tables
//

#include <smbgtpt.h>

//
// NT DLC API interface files:
//

#include <dlcapi.h>                     // Official DLC API definition
#include <ntdddlc.h>                    // IOCTL commands
#include <dlcio.h>                      // Internal IOCTL API interface structures

//
// Local types and function prototypes:
//

typedef
VOID
(*PFDLC_POST_ROUTINE)(
    IN PVOID hApcContext,
    IN PLLC_CCB pCcb
    );

#define SUPPORT_DEBUG_NAMES     0

//
// In DOS the adapter number and NetBIOS command use the same
// byte in CCB/NCB data structure.
// The smallest NetBIOS command is NCB.CALL (10H), which limits
// the maximum adapter numbers 0 - 15 in DOS (and Windows NT)
// The extra adapter numbers above 15 may be used as extra
// alternate adapter handles to extend the number of available
// link stations.  Only the first instance of a SAP can receive
// remote connect requests.
//

#define LLC_MAX_ADAPTER_NUMBER  255
#define LLC_MAX_ADAPTERS        16

#define TR_16Mbps_LINK_SPEED    0x1000000

VOID
QueueCommandCompletion(
    PLLC_CCB pCCB
    );
VOID
InitializeAcsLan(
    VOID
    );
LLC_STATUS
OpenDlcApiDriver(
    IN PVOID SecurityDescriptor,
    OUT HANDLE *pHandle
    );
LLC_STATUS
GetAdapterNameAndParameters(
    IN UINT AdapterNumber,
    OUT PUNICODE_STRING pNdisName,
    OUT PUCHAR pTicks,
    OUT PLLC_ETHERNET_TYPE pLlcEthernetType
    );
VOID
CopyAsciiStringToUnicode(
    IN PUNICODE_STRING  pUnicodeDest,
    IN PSZ              pAsciiSrc
    );
VOID
BuildDescriptorList(
    IN PLLC_TRANSMIT_DESCRIPTOR pDescriptor,
    IN PLLC_CCB pCCB,
    IN OUT PUINT pCurrentDescriptor
    );
LLC_STATUS
DoSyncDeviceIoControl(
    IN HANDLE DeviceHandle,
    IN ULONG IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    );
LLC_STATUS
DlcGetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    );
VOID
CopyToDescriptorBuffer(
    IN OUT PLLC_TRANSMIT_DESCRIPTOR pDescriptors,
    IN PLLC_BUFFER pDlcBufferQueue,
    IN BOOLEAN DeallocateBufferAfterUse,
    IN OUT PUINT pIndex,
    IN OUT PLLC_BUFFER *ppLastBuffer,
    OUT LLC_STATUS *pStatus
    );
LLC_STATUS
DlcSetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PNT_DLC_SET_INFORMATION_PARMS pSetInfoParms,
    IN PVOID DataBuffer,
    IN UINT DataBufferLength
    );

USHORT
GetCcbStationId(
    IN PLLC_CCB pCCB
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    dlc.h

Abstract:

    This module incldes all files needed to compile
    the NT DLC driver.

Author:

    Antti Saarenheimo (o-anttis) 20-09-1991

Revision History:

--*/

#ifndef DLC_INCLUDED
#define DLC_INCLUDED

#include <ntddk.h>
#include <ndis.h>

#include <ntdddlc.h>

#undef APIENTRY
#define APIENTRY

#include <dlcapi.h>
#include <dlcio.h>
#include <llcapi.h>

#include <dlcdef.h>
#include <dlctyp.h>
#include <dlcext.h>

#include "dlcreg.h"

#include <memory.h>         // prototype for inline memcpy

#include "llc.h"

#endif  // DLC_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcdebug.h

Abstract:

    Contains various debugging/diagnostic stuff for DLC.SYS, checked

Author:

    Richard L Firth (rfirth) 25-Jun-1992

Revision History:

--*/

#if DBG

#ifdef DEFINE_DLC_DIAGNOSTICS

//
// we can preset the diagnostics at compile-time by defining DEFAULT_DIAGNOSTICS
//

#ifndef DEFAULT_DIAGNOSTICS

#define DEFAULT_DIAGNOSTICS 0

#endif

ULONG   DlcDiagnostics = DEFAULT_DIAGNOSTICS;

#else

extern  ULONG   DlcDiagnostics;

#endif

#define DIAG_FUNCTION_NAME  0x00000001
#define DIAG_MDL_ALLOC      0x00000002
#define DIAG_DEVICE_IO      0x00000004

#define IF_DIAG(p)          if (DlcDiagnostics & DIAG_ ## p)
#define DIAG_FUNCTION(s)    IF_DIAG(FUNCTION_NAME) { \
                                DbgPrint(s "\n"); \
                            }

#else

#define IF_DIAG(p)          if (0)
#define DIAG_FUNCTION(s)    if (0) {(void)(s);}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcdef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcdef.h

Abstract:

    This module includes all defines and constants of DLC API driver.

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <ntddk.h>  // required for PAGE_SIZE

//
// minima, maxima and defaults for registry parameters
//

#define MIN_TIMER_TICK_VALUE            1
#define MAX_TIMER_TICK_VALUE            255
#define MIN_AUTO_FRAMING_CACHE_SIZE     0   // means NO CACHING!
#define MAX_AUTO_FRAMING_CACHE_SIZE     256 // arbitrary maximum

//
// if non-TR cards && using max ethernet frame length then 1514 is the value
// we use (came from ELNKII, EE16, LANCE, et al)
//

#define MAX_ETHERNET_FRAME_LENGTH       1514

//
// default values for parameters retrieved from registry
//

#define DEFAULT_SWAP_ADDRESS_BITS       1
#define DEFAULT_DIX_FORMAT              0
#define DEFAULT_T1_TICK_ONE             5
#define DEFAULT_T1_TICK_TWO             25
#define DEFAULT_T2_TICK_ONE             1
#define DEFAULT_T2_TICK_TWO             10
#define DEFAULT_Ti_TICK_ONE             25
#define DEFAULT_Ti_TICK_TWO             125
#define DEFAULT_USE_ETHERNET_FRAME_SIZE 1
#define DEFAULT_AUTO_FRAMING_CACHE_SIZE 16

//
// The event and command queue structures overlaps => we cane save the
// duplicate code.  The defined name makes code more readable.
//

#define SearchAndRemoveEvent( a, b, c, d ) \
        (PDLC_EVENT)SearchAndRemoveCommand( a, b, c, d )

#define MAX_SAP_STATIONS                128
#define MAX_LINK_STATIONS               255
#define GROUP_SAP_BIT                   0x0100
#define DLC_INDIVIDUAL_SAP              0x04
#define XID_HANDLING_BIT                0x08

#define MIN_DLC_BUFFER_SIZE             PAGE_SIZE

#define MAX_FREE_SIZE_THRESHOLD         0x2000

#define INVALID_RCV_READ_OPTION         3
#define DLC_INVALID_OPTION_INDICATOR    3
#define DLC_NO_RECEIVE_COMMAND          4

#define DLC_CONTIGUOUS_MAC              0x80
#define DLC_CONTIGUOUS_DATA             0x40
#define DLC_BREAK                       0x20

#if defined(ALPHA)
#define DLC_BUFFER_SEGMENTS             6     // 256, 512, 1024, 2048, 4096, 8192 => 6
#else
#define DLC_BUFFER_SEGMENTS             5     // 256, 512, 1024, 2048, 4096 => 5
#endif

#define MAX_USER_DATA_LENGTH            128   // anything less than 256

//
// Transmit timeout = 20 * 250 ms = 5 seconds
//

#define MAX_TRANSMIT_RETRY              20
#define TRANSMIT_RETRY_WAIT             2500000L

#define LLC_RECEIVE_COMMAND_FLAG        0x80

#define DLC_IGNORE_SEARCH_HANDLE        NULL
#define DLC_MATCH_ANY_COMMAND           (PVOID)-1
#define DLC_IGNORE_STATION_ID           0x00ff
#define DLC_STATION_MASK_SPECIFIC       0xffff
#define DLC_STATION_MASK_SAP            0xff00
#define DLC_STATION_MASK_ALL            0


#define IOCTL_DLC_READ_INDEX            ((IOCTL_DLC_READ >> 2) & 0x0fff)
#define IOCTL_DLC_RECEIVE_INDEX         ((IOCTL_DLC_RECEIVE >> 2) & 0x0fff)
#define IOCTL_DLC_TRANSMIT_INDEX        ((IOCTL_DLC_TRANSMIT >> 2) & 0x0fff)
#define IOCTL_DLC_OPEN_ADAPTER_INDEX    ((IOCTL_DLC_OPEN_ADAPTER >> 2) & 0x0fff)

enum _DLC_OBJECT_STATES {
    DLC_OBJECT_OPEN,
    DLC_OBJECT_CLOSING,
    DLC_OBJECT_CLOSED,
    DLC_OBJECT_INVALID_TYPE
};

//
// The Token-Ring status codes documented in Appendix B of the IBM LAN
// Tech Reference are shifted right one bit from the NDIS values 
// documented in "ntddndis.h."
//
// In versions 3.xx of Windows NT, DLC returns a Network Status that
// agrees with the NDIS values.  In version 4.xx and newer, IBM
// compatible values are used.
//
// These macros may be used to convert between the two conventions.
//

#define NDIS_RING_STATUS_TO_DLC_RING_STATUS(status) ((status)>>1)
#define DLC_RING_STATUS_TO_NDIS_RING_STATUS(status) ((status)<<1)


#define NDIS_RING_STATUS_MASK \
	NDIS_RING_SIGNAL_LOSS\
	|NDIS_RING_HARD_ERROR\
	|NDIS_RING_SOFT_ERROR\
	|NDIS_RING_TRANSMIT_BEACON\
	|NDIS_RING_LOBE_WIRE_FAULT\
	|NDIS_RING_AUTO_REMOVAL_ERROR\
	|NDIS_RING_REMOVE_RECEIVED\
	|NDIS_RING_COUNTER_OVERFLOW\
	|NDIS_RING_SINGLE_STATION\
	|NDIS_RING_RING_RECOVERY

#define DLC_RING_STATUS_MASK NDIS_RING_STATUS_TO_DLC_RING_STATUS(NDIS_RING_STATUS_MASK)

#define IS_NDIS_RING_STATUS(status) (((status)&NDIS_RING_STATUS_MASK)!=0)
#define IS_DLC_RING_STATUS(status) (((status)&DLC_RING_STATUS_MASK)!=0)

//
// ENTER/LEAVE_DLC - acquires or releases the per-file context spin lock. Use
// Ndis spin locking calls
//

#define ENTER_DLC(p)    ACQUIRE_SPIN_LOCK(&p->SpinLock)
#define LEAVE_DLC(p)    RELEASE_SPIN_LOCK(&p->SpinLock)

//
// ACQUIRE/RELEASE_DLC_LOCK - acquires or releases global DLC spin lock. Use
// kernel spin locking calls
//

#define ACQUIRE_DLC_LOCK(i) KeAcquireSpinLock(&DlcSpinLock, &(i))
#define RELEASE_DLC_LOCK(i) KeReleaseSpinLock(&DlcSpinLock, (i))

#define ADAPTER_ERROR_COUNTERS          11  // # adapter error log counters

#define ReferenceFileContextByTwo(pFileContext) (pFileContext)->ReferenceCount += 2
#define ReferenceFileContext(pFileContext)      (pFileContext)->ReferenceCount++

#if DBG

#define DereferenceFileContext(pFileContext)                \
    if (pFileContext->ReferenceCount <= 0) {                \
        DbgPrint("DLC.DereferenceFileContext: Error: file context %08x: reference count %x\n",\
                pFileContext,                               \
                pFileContext->ReferenceCount                \
                );                                          \
        DbgBreakPoint();                                    \
    }                                                       \
    (pFileContext)->ReferenceCount--;                       \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#define DereferenceFileContextByTwo(pFileContext)           \
    if (pFileContext->ReferenceCount <= 1) {                \
        DbgPrint("DLC.DereferenceFileContextByTwo: Error: file context %08x: reference count %x\n",\
                pFileContext,                               \
                pFileContext->ReferenceCount                \
                );                                          \
        DbgBreakPoint();                                    \
    }                                                       \
    (pFileContext)->ReferenceCount -= 2;                    \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#else

#define DereferenceFileContext(pFileContext)                \
    (pFileContext)->ReferenceCount--;                       \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#define DereferenceFileContextByTwo(pFileContext)           \
    (pFileContext)->ReferenceCount -= 2;                    \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#endif  // DBG

#define BufferPoolCount(hBufferPool) \
    (((PDLC_BUFFER_POOL)hBufferPool)->FreeSpace >= (256L * 0x0000ffffL) ? \
        0xffff : \
        (((PDLC_BUFFER_POOL)hBufferPool)->FreeSpace / 256))

#define BufGetUncommittedSpace(handle) \
    ((PDLC_BUFFER_POOL)(handle))->UncommittedSpace

#define BufCommitBuffers(handle, BufferSize) \
    ExInterlockedAddUlong( \
        (PULONG)&((PDLC_BUFFER_POOL)(handle))->UncommittedSpace, \
        (ULONG)(-((LONG)BufferSize)), \
        &(((PDLC_BUFFER_POOL)(handle))->SpinLock))

#define BufUncommitBuffers(handle, BufferSize) \
    ExInterlockedAddUlong(\
        (PULONG)&((PDLC_BUFFER_POOL)(handle))->UncommittedSpace,\
        (ULONG)(BufferSize),\
        &(((PDLC_BUFFER_POOL)(handle))->SpinLock))

/*++

BOOLEAN
BufferPoolCheckThresholds(
    IN PDLC_BUFFER_POOL pBufferPool
    )

Routine Description:

    The function checks the minimum and maximum size Thresholds and
    returns TRUE, if buffer pool needs reallocation.

    We do this check outside the spinlocks to avoid
    unnecessary locking in 99 % of the cases.

Arguments:

    pBufferPool - handle of buffer pool data structure.

Return Value:

    Returns     TRUE => Buffer pool needs extending
                FALSE => no need for it
--*/
#define BufferPoolCheckThresholds( pBufferPool ) \
    (((pBufferPool) != NULL && \
      (((PDLC_BUFFER_POOL)(pBufferPool))->UncommittedSpace < 0 || \
       ((PDLC_BUFFER_POOL)(pBufferPool))->MissingSize > 0) && \
      ((PDLC_BUFFER_POOL)(pBufferPool))->BufferPoolSize < \
      ((PDLC_BUFFER_POOL)(pBufferPool))->MaxBufferSize && \
     MemoryLockFailed == FALSE) ? TRUE : FALSE)


//
//  These routines closes a llc object, when there are no
//  more references to it
//
#define ReferenceLlcObject( pDlcObject ) (pDlcObject)->LlcReferenceCount++

#define DereferenceLlcObject( pDlcObject ) { \
        (pDlcObject)->LlcReferenceCount--; \
        if ((pDlcObject)->LlcReferenceCount == 0) {\
            CompleteLlcObjectClose( pDlcObject ); \
        } \
        DLC_TRACE('O'); \
        DLC_TRACE( (UCHAR)(pDlcObject)->LlcReferenceCount ); \
    }


//
// We need the same kind of routines to reference the buffer pool.
// The adapter closing have quite many times deleted the buffer pool
// just before it was called (after LEAVE_DLC).
//

#define ReferenceBufferPool(pFileContext)   (pFileContext)->BufferPoolReferenceCount++

#if DBG

#define DereferenceBufferPool(pFileContext) {\
        (pFileContext)->BufferPoolReferenceCount--; \
        if ((pFileContext)->BufferPoolReferenceCount == 0) {\
            BufferPoolDereference( \
                pFileContext, \
                (PDLC_BUFFER_POOL*)&(pFileContext)->hBufferPool); \
        } \
    }

#else

#define DereferenceBufferPool(pFileContext) {\
        (pFileContext)->BufferPoolReferenceCount--; \
        if ((pFileContext)->BufferPoolReferenceCount == 0) {\
            BufferPoolDereference((PDLC_BUFFER_POOL*)&(pFileContext)->hBufferPool); \
        } \
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcdrvr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcdrvr.c

Abstract:

    This module contains code which implements the NT DLC driver API
    using the generic data link module.

    Contents:
        DriverEntry
        CreateAdapterFileContext
        CleanupAdapterFileContext
        DlcDriverUnload
        CloseAdapterFileContext
        DlcKillFileContext
        DlcDeviceIoControl
        DlcCompleteIoRequest

Author:

    Antti Saarenheimo 8-Jul-1991

Environment:

    Kernel mode

Revision History:


--*/

#define INCLUDE_IO_BUFFER_SIZE_TABLE        // includes the io buffer sizes

#include <dlc.h>
#include "dlcreg.h"
#include "dbgmsg.h"

#define DEFINE_DLC_DIAGNOSTICS
#include "dlcdebug.h"

/*++

The queueing of asynchronous commands (21 Oct. 1991)
----------------------------------------------------

DLC driver uses basically three different methods to queue and
complete its asyncronous commands:

1. Using LLC request handle

In this case the LLC driver takes care of the command queueing.
This method is used by:
- all transmit commands
- all close commands
- dlc connect
- dlc disconnect

2. DLC (READ / RECEIVE) Command queue (FIFO)

The read and receive commands are saved to the command completion
queue, that is is circular single enty link list.
The events are handled by the oldest pending command.
These commands also check the event queue and the command
is queued only if there are no pending events.

3. Timer queue

Timer queue is a null terminated single entry link list.
They are sorted by the relative expiration time.  The timer
tick completes all timer commands having the same expiration
time.  The expiration times are relative to all previous
commands.  For example, timer commands having expiration times 1, 2 and 3
would all have 1 tick count in the queue.  Thus the timer tick
needs to increment only one tick from the beginning of the list
and complete all timer commands having zero expiration time.
When command is cancelled, its tick count must be added
to the next element in the queue.

--*/


/*++

New stuff in Feb-20-1992


(reason: with a free build (because it is so fast) I run out of
 non-paged pool and several problems did arise in DLC driver:
 commands were sometimes lost, DLC.RESET did never complete and
 the adapter close


The recovery rules when no non-paged memory is available:

1. The adapter close (or file context close by handle) must work always =>
   the adapter close packet must be in the file context.

2. The commands must allocate all resources needed to complete the
   command before they return a pending status (transmit!), if that
   cannot be done then the command must fail immediately.

3. The received data must not be acknowledged before all resources
   have been allocated to receive it.

4. Probablem: we may lose an important link state change indication if we
   cannot allocate a packet for it.  For example, the application may
   not know, that the link is in the local busy state.  The dlc status events
   of quite many link stations (255) may also very soon eat all non-paged
   pool, if they are not read by client.  A static event packet would
   prevent that.
   A solution: a static event indication packet
   in the dlc object, connect and disconnect confirmation would be handled
   as now (they are indicated in the command completion entry).
   The indication status would be reset, when it is read from the command
   queue.  The same event indication may have several flags.


(Do first 1, 2, 3 and 4, make the test even more stressing for non-paged
 pool and test then what happens.  Then we may fix the bug in the buffer
 pool shrinkin and implement dynamic packet pools).

The long term solutions:

Dynamic memory management in dlc!  The current dlc memory management
is very fast and the top memory consumption is minimal (without the
default 33% overhead of binary buddy algorithm), but it never release
the resources, that it has once allocated.


1. The packet pools should release the extra memory when they are not
   needed any more, implementation: each memory block allocated for
   the packet pool has a reference count, that memory block is deallocated
   when the reference count is zero.  This cleanup could be done once in
   a second.  The algorithm scans the free list of packets, removes the
   packet from the free list, if the reference count of free packets
   is the same as the total packet count on a memory block.
   The memory blocks can be relesed in the next loop while the block itself
   is disconnected from the single entry list of all memory blocks in
   the packet pool.

2. The buffer pool memory management should also be able to shrink the
   number of locked pages (there must be a bug in the current implementation)
   AND also to free all MDLs and extra packets, when the buffer pool pages
   are unlocked.


3. Data link driver should not allocated any memory resources (except
   packet pools to send its own frames).  The objects should be created
   by in the dlc driver => all extra resources are released when
   a dlc driver is released (actually not a big deal, because dynamic
   packet pool management fixes the problem with the link stations).

--*/

//  Local IOCTL dispatcher table:
// ***************************************************
//  THE ORDER OF THESE FUNCTIONS MUST BE THE SAME AS
//  THE IOCTL COMMAND CODES IN NTDDDLC.H
// ***************************************************

static PFDLC_COMMAND_HANDLER DispatchTable[IOCTL_DLC_LAST_COMMAND] = {
    DlcReadRequest,
    DlcReceiveRequest,
    DlcTransmit,
    DlcBufferFree,
    DlcBufferGet,
    DlcBufferCreate,
    DirSetExceptionFlags,
    DlcCloseStation,                    // DLC.CLOSE.STATION
    DlcConnectStation,
    DlcFlowControl,
    DlcOpenLinkStation,
    DlcReset,
    DlcReadCancel,
    DlcReceiveCancel,
    DlcQueryInformation,
    DlcSetInformation,
    DirTimerCancel,
    DirTimerCancelGroup,
    DirTimerSet,
    DlcOpenSap,
    DlcCloseStation,                    // DLC.CLOSE.SAP
    DirOpenDirect,
    DlcCloseStation,                    // DIR.CLOSE.DIRECT
    DirOpenAdapter,
    DirCloseAdapter,
    DlcReallocate,
    DlcReadRequest,
    DlcReceiveRequest,
    DlcTransmit,
    DlcCompleteCommand
};

USHORT aSpecialOutputBuffers[3] = {
    sizeof(LLC_READ_OUTPUT_PARMS),
    sizeof(PVOID),                     // pFirstBuffer
    sizeof(UCHAR)                      // TransmitFrameStatus
};

NDIS_SPIN_LOCK DlcDriverLock;

#ifdef LOCK_CHECK

LONG DlcDriverLockLevel = 0;

ULONG __line = 0;
PCHAR __file = NULL;
LONG __last = 1;
HANDLE __process = (HANDLE)0;
HANDLE __thread = (HANDLE)0;

#endif

#if LLC_DBG

extern PVOID pAdapters;

ULONG AllocatedNonPagedPool = 0;
ULONG LockedPageCount = 0;
ULONG AllocatedMdlCount = 0;
ULONG AllocatedPackets = 0;
ULONG cExAllocatePoolFailed = 0;
ULONG FailedMemoryLockings = 0;
NDIS_SPIN_LOCK MemCheckLock;

ULONG cFramesReceived = 0;
ULONG cFramesIndicated = 0;
ULONG cFramesReleased = 0;

ULONG cLockedXmitBuffers = 0;
ULONG cUnlockedXmitBuffers = 0;

#endif

//UINT InputIndex = 0;
//LLC_SM_TRACE aLast[LLC_INPUT_TABLE_SIZE];

#if DBG & DLC_TRACE_ENABLED

UINT LlcTraceIndex = 0;
UCHAR LlcTraceTable[LLC_TRACE_TABLE_SIZE];

#endif // DBG & DLC_TRACE_ENABLED


//
// prototypes
//

VOID
LinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    );

PDLC_FILE_CONTEXT
UnlinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    );

//
// global data
//

BOOLEAN MemoryLockFailed = FALSE;   // this limits unneceasary memory locks
KSPIN_LOCK DlcSpinLock;             // syncnhronize the final cleanup
PDEVICE_OBJECT ThisDeviceContext;   // required for unloading driver

//
// we now maintain a singly-linked list of FILE_CONTEXTs for debug and retail
// versions
//

SINGLE_LIST_ENTRY FileContexts = {NULL};
KSPIN_LOCK FileContextsLock;
KIRQL PreviousIrql;

#if DBG

BOOLEAN Prolix;
MEMORY_USAGE DriverMemoryUsage;
MEMORY_USAGE DriverStringUsage; // how much string does it take to hang a DLC driver?

#endif

//
// external data
//


//
// functions
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This function is called when the I/O subsystem loads the DLC driver

    This routine performs the initialization of NT DLC API driver.
    Eventually this should be called after the first reference to
    DLC driver.

Arguments:

    pDriverObject   - Pointer to driver object created by the system
    RegistryPath    - The name of DLC's node in the registry

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS Status;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING DriverName;

    ASSUME_IRQL(PASSIVE_LEVEL);

#if DBG
    if (Prolix) {
        DbgPrint("DLC.DriverEntry\n");
    }
    KeInitializeSpinLock(&DriverMemoryUsage.SpinLock);
    KeInitializeSpinLock(&DriverStringUsage.SpinLock);
    InitializeMemoryPackage();
#endif

    KeInitializeSpinLock(&FileContextsLock);

    //
    // load any initialization-time parameters from the registry
    //

    DlcRegistryInitialization(RegistryPath);
    LoadDlcConfiguration();

    //
    // LLC init makes ourselves known to the NDIS wrapper,
    // but we don't yet bind to any NDIS driver (don't know even the name)
    //

    Status = LlcInitialize();
    if (Status != STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create the DLC device object. For now, we simply create \Device\Dlc
    // using a Unicode string. In the future we may need to load an ACL
    //

    RtlInitUnicodeString(&DriverName, DD_DLC_DEVICE_NAME);

    //
    // Create the device object for DLC driver, we don't have any
    // device specific data, because DLC needs only one device context.
    // Thus it can just use statics and globals.
    //

    Status = IoCreateDevice(pDriverObject,
                            0,
                            &DriverName,
                            FILE_DEVICE_DLC,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &pDeviceObject
                            );
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {

        //
        // need to keep a pointer to device context for IoDeleteDevice
        //

        ThisDeviceContext = pDeviceObject;
    }

    //
    // DLC driver never calls other device drivers: 1 I/O stack in IRP is enough
    //

    pDeviceObject->StackSize = 1;
    pDeviceObject->Flags |= DO_DIRECT_IO;

    KeInitializeSpinLock(&DlcSpinLock);

    NdisAllocateSpinLock(&DlcDriverLock);

    //
    // Initialize the driver object with this driver's entry points.
    //

    pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateAdapterFileContext;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseAdapterFileContext;
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP] = CleanupAdapterFileContext;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DlcDeviceIoControl;
    pDriverObject->DriverUnload = DlcDriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS
CreateAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This function is called when a handle to the DLC driver is opened (via
    NtCreateFile)

    The Create function creates file context for a DLC application.
    A DLC application needs at least one file context for each
    network adapter it is using.  The DLC file contexts may share
    the same buffer pool, but otherwise they are totally isolated
    from each other.

Arguments:

    DeviceObject    - Pointer to the device object for this driver
    Irp             - Pointer to the request packet representing the I/O request

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDLC_FILE_CONTEXT pFileContext;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSUME_IRQL(PASSIVE_LEVEL);

#if LLC_DBG == 2
    PrintMemStatus();
#endif

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pFileContext = (PDLC_FILE_CONTEXT)ALLOCATE_ZEROMEMORY_DRIVER(sizeof(DLC_FILE_CONTEXT));
    if (pFileContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    // #126745: Enqueue after initialization
    /*    //
    // add this file context to our global list of opened file contexts
    //

    LinkFileContext(pFileContext); */

#if DBG

    //
    // record who owns this memory usage and add it to our global list of
    // memory usages
    //

    pFileContext->MemoryUsage.Owner = (PVOID)pFileContext;
    pFileContext->MemoryUsage.OwnerObjectId = FileContextObject;
    LinkMemoryUsage(&pFileContext->MemoryUsage);
#endif

    pIrpSp->FileObject->FsContext = pFileContext;
    pFileContext->FileObject = pIrpSp->FileObject;

    InitializeListHead(&pFileContext->EventQueue);
    InitializeListHead(&pFileContext->CommandQueue);
    InitializeListHead(&pFileContext->ReceiveQueue);
    InitializeListHead(&pFileContext->FlowControlQueue);

    //
    // create pool of command/event packets
    //

    pFileContext->hPacketPool = CREATE_PACKET_POOL_FILE(DlcPacketPoolObject,
                                                        sizeof(DLC_PACKET),
                                                        8
                                                        );
    if (pFileContext->hPacketPool == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit1;
    }

    //
    // create pool of DLC-level SAP/LINK/DIRECT objects
    //

    pFileContext->hLinkStationPool = CREATE_PACKET_POOL_FILE(DlcLinkPoolObject,
                                                             sizeof(DLC_OBJECT),
                                                             4
                                                             );
    if (pFileContext->hLinkStationPool == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit1;
    }

    //
    // add this file context to our global list of opened file contexts
    //
    LinkFileContext(pFileContext); 

    //
    // set the file context reference count to 1 - this file context is ALIVE!
    //

    ReferenceFileContext(pFileContext);

    //
    // the call to open a handle to the driver may have succeeded, but we don't
    // yet have an open adapter context
    //

    pFileContext->State = DLC_FILE_CONTEXT_CLOSED;
    ALLOCATE_SPIN_LOCK(&pFileContext->SpinLock);

    KeInitializeEvent(&pFileContext->CleanupEvent, SynchronizationEvent, FALSE);

ErrorExit1:

    if (Status != STATUS_SUCCESS) {

        DELETE_PACKET_POOL_FILE(&pFileContext->hLinkStationPool);
        DELETE_PACKET_POOL_FILE(&pFileContext->hPacketPool);
        CHECK_MEMORY_RETURNED_FILE();

	// UnlinkFileContext(pFileContext);

#if DBG
        // UnlinkMemoryUsage(&pFileContext->MemoryUsage);
#endif

        FREE_MEMORY_DRIVER(pFileContext);
    }

ErrorExit2:

    pIrp->IoStatus.Status = Status;
    DlcCompleteIoRequest(pIrp, FALSE);
    return Status;
}


NTSTATUS
CleanupAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This function is called when the last reference to an open file handle is
    removed. This is an opportunity, given us by the I/O subsystem, to ensure
    that all pending I/O requests for the file object being closed have been
    completed

    The routine checks, that the file context is really closed.
    Otherwise it executes a panic closing of all resources in
    the same way as in the DirCloseAdapter call.
    It happens when an application makes process exit without
    calling the DirCloseAdapter.

Arguments:

    DeviceObject    - Pointer to the device object for this driver
    Irp             - Pointer to the request packet representing the I/O request

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION pIrpSp;
    PDLC_FILE_CONTEXT pFileContext;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDeviceObject);

    DIAG_FUNCTION("CleanupAdapterFileContext");

#if DBG
    if (Prolix) {
        DbgPrint("CleanupAdapterFileContext\n");
    }
#endif

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pFileContext = pIrpSp->FileObject->FsContext;

    //
    // We may have a pending close or Initialize operation going on
    //

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    KeResetEvent(&pFileContext->CleanupEvent);
    
    if (pFileContext->State == DLC_FILE_CONTEXT_OPEN) {
        //
        // as for Ioctl processing, add 2 to the file context reference count
        // The combination of the dereference below, the completion of the
        // close adapter call and the processing of a close IRP will cause the
        // file context to be destroyed
        //

        ReferenceFileContextByTwo(pFileContext);
        Status = DirCloseAdapter(pIrp,
                                 pFileContext,
                                 NULL,
                                 0,
                                 0
                                 );

#if LLC_DBG
        if (Status != STATUS_PENDING) {
            DbgBreakPoint();
        }
#endif

        //
        // We always return a pending status from DirCloseAdapter
        //

        MY_ASSERT(Status == STATUS_PENDING);

        DereferenceFileContext(pFileContext);
    } 
    
    //
    // Remove the original DLC_FILE_CONTEXT reference.
    //

    DereferenceFileContext(pFileContext);

    LEAVE_DLC(pFileContext);
    RELEASE_DRIVER_LOCK();

    //
    // Wait for all references to the DLC_FILE_CONTEXT to be removed. When
    // the last reference is removed, DlcKillFileContext is called which will
    // clean up most of the file context's resources and then set the event.
    // CloseAdapterFileContext/IRP_MJ_CLOSE will free the actual memory
    // for the file context.
    //

    KeWaitForSingleObject(
        &pFileContext->CleanupEvent, 
        UserRequest,
        KernelMode,
        FALSE,
        NULL);

    DlcCompleteIoRequest(pIrp, FALSE);
    
    return Status;
}


VOID
DlcDriverUnload(
    IN PDRIVER_OBJECT pDeviceObject
    )

/*++

Routine Description:

    This functions is called when a called is made to the I/O subsystem to
    remove the DLC driver

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    The function value is the status of the operation.

--*/

{
    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSUME_IRQL(PASSIVE_LEVEL);

    DEBUGMSG(DBG_INIT,
        (TEXT("DlcDriverUnload(%#x)\n"), pDeviceObject));
    
    LlcTerminate();
    DlcRegistryTermination();

    CHECK_MEMORY_RETURNED_DRIVER();
    CHECK_STRING_RETURNED_DRIVER();
    CHECK_DRIVER_MEMORY_USAGE(TRUE);

    NdisFreeSpinLock(&DlcDriverLock);

    //
    // now tell I/O subsystem that this device context is no longer current
    //

    IoDeleteDevice(ThisDeviceContext);
}


NTSTATUS
CloseAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine is called when the file object reference count is zero. The file
    object is really being deleted by the I/O subsystem. The file context had
    better be closed by now (should have been cleared out by Cleanup)

Arguments:

    DeviceObject    - Pointer to the device object for this driver
    Irp             - Pointer to the request packet representing the I/O request

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION pIrpSp;
    PDLC_FILE_CONTEXT pFileContext;

    UNREFERENCED_PARAMETER(pDeviceObject);

    DIAG_FUNCTION("CloseAdapterFileContext");

#if DBG
    if (Prolix) {
        DbgPrint("CloseAdapterFileContext\n");
    }
#endif

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileContext = pIrpSp->FileObject->FsContext;

    //
    // The original reference was removed in CleanupAdapterFileContext and
    // blocked until all references were removed and the file context 
    // resources cleaned up, except for the following. 
    //

    ASSERT(pFileContext->ReferenceCount == 0);
    ASSERT(UnlinkFileContext(pFileContext) == NULL);

    pIrpSp->FileObject->FsContext = NULL;
    DEALLOCATE_SPIN_LOCK(&pFileContext->SpinLock);
    FREE_MEMORY_DRIVER(pFileContext);

    //
    // complete the Close IRP
    //

    DlcCompleteIoRequest(pIrp, FALSE);

#if DBG
    if (Prolix) {
        CHECK_DRIVER_MEMORY_USAGE(FALSE);
    }
#endif

    return STATUS_SUCCESS;
}


VOID
DlcKillFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Called when the reference count on a file context structure is decremented
    to zero. Frees all memory owned by the file context and removes it from the
    file context list.

    After this function, no references to the file context structure can be made!

Arguments:

    pFileContext    - pointer to DLC file context structure to kill

Return Value:

    None.

--*/

{
    KIRQL irql;
    PVOID pBindingContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    // Shouldn't need lock since only called when reference count is 0.
    // ENTER_DLC(pFileContext);

    //
    // delete all events on the file context event list before we delete the
    // packet pool
    //

    PurgeDlcEventQueue(pFileContext);
    PurgeDlcFlowControlQueue(pFileContext);

    DELETE_PACKET_POOL_FILE(&pFileContext->hPacketPool);
    DELETE_PACKET_POOL_FILE(&pFileContext->hLinkStationPool);

    // LEAVE_DLC(pFileContext);


    pBindingContext = pFileContext->pBindingContext;

    //
    // Finally, close the NDIS adapter. we have already disabled all
    // indications from it
    //

    if (pBindingContext) {

        //
        // RLF 04/26/94
        //
        // We need to call LlcDisableAdapter here to terminate the DLC timer
        // if it is not already terminated. Else we can end up with the timer
        // still in the adapter's tick list (if there are other bindings to
        // the adapter), and sooner or later that will cause an access
        // violation, followed very shortly thereafter by a blue screen
        //

        LlcDisableAdapter(pBindingContext);
        LlcCloseAdapter(pBindingContext, TRUE);
    }

    CHECK_MEMORY_RETURNED_FILE();

    UnlinkFileContext(pFileContext);

#if DBG

    UnlinkMemoryUsage(&pFileContext->MemoryUsage);

#endif

    KeSetEvent(&pFileContext->CleanupEvent, 0, FALSE);

#if LLC_DBG

    if ((LockedPageCount != 0
    || AllocatedMdlCount != 0
    || AllocatedNonPagedPool != 0)
    && pAdapters == NULL) {
        DbgPrint("DLC.CloseAdapterFileContext: Error: Resources not released\n");
        //PrintMemStatus();
        DbgBreakPoint();
    }
    FailedMemoryLockings = 0;

#endif

}


NTSTATUS
DlcDeviceIoControl(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine dispatches DLC requests to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various DLC request handlers so that they are
    not IRP-dependent.

    DlcDeviceControl and LlcReceiveIndication are the most time critical
    procedures in DLC.  This code has been optimized for the asynchronous
    command (read and transmit)

Arguments:

    pDeviceContext  - Pointer to the device object for this driver (unused)
    pIrp            - Pointer to the request packet representing the I/O request

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
                    The I/O request has been successfully completed

                  STATUS_PENDING
                    The I/O request has been submitted and will be completed
                    asynchronously

        Failure - DLC_STATUS_XXX
                  LLC_STATUS_XXX
                    The I/O request has been completed, but an error occurred

--*/

{
    USHORT TmpIndex;
    PDLC_FILE_CONTEXT pFileContext; // FsContext in FILE_OBJECT.
    PIO_STACK_LOCATION pIrpSp;
    ULONG ioControlCode;

    UNREFERENCED_PARAMETER(pDeviceContext);

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // Make sure status information is consistent every time
    //

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Branch to the appropriate request handler, but do first
    // preliminary checking of the input and output buffers,
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    //

    ioControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    
    // Check the complete IoControl Code

    switch (ioControlCode) {
      case IOCTL_DLC_READ:
      case IOCTL_DLC_RECEIVE:
      case IOCTL_DLC_TRANSMIT:
      case IOCTL_DLC_BUFFER_FREE:
      case IOCTL_DLC_BUFFER_GET:
      case IOCTL_DLC_BUFFER_CREATE:
      case IOCTL_DLC_SET_EXCEPTION_FLAGS:
      case IOCTL_DLC_CLOSE_STATION:
      case IOCTL_DLC_CONNECT_STATION:
      case IOCTL_DLC_FLOW_CONTROL:
      case IOCTL_DLC_OPEN_STATION:
      case IOCTL_DLC_RESET:
      case IOCTL_DLC_READ_CANCEL:
      case IOCTL_DLC_RECEIVE_CANCEL:
      case IOCTL_DLC_QUERY_INFORMATION:
      case IOCTL_DLC_SET_INFORMATION:
      case IOCTL_DLC_TIMER_CANCEL:
      case IOCTL_DLC_TIMER_CANCEL_GROUP:
      case IOCTL_DLC_TIMER_SET:
      case IOCTL_DLC_OPEN_SAP:
      case IOCTL_DLC_CLOSE_SAP:
      case IOCTL_DLC_OPEN_DIRECT:
      case IOCTL_DLC_CLOSE_DIRECT:
      case IOCTL_DLC_OPEN_ADAPTER:
      case IOCTL_DLC_CLOSE_ADAPTER:
      case IOCTL_DLC_REALLOCTE_STATION:
      case IOCTL_DLC_READ2:
      case IOCTL_DLC_RECEIVE2:
      case IOCTL_DLC_TRANSMIT2:
      case IOCTL_DLC_COMPLETE_COMMAND:
      case IOCTL_DLC_TRACE_INITIALIZE:
        TmpIndex = (((USHORT)ioControlCode) >> 2) & 0x0fff;
        break;
      default:
        TmpIndex = IOCTL_DLC_LAST_COMMAND;
    }
    
    //    TmpIndex = (((USHORT)ioControlCode) >> 2) & 0x0fff;
    if (TmpIndex >= IOCTL_DLC_LAST_COMMAND) {

        pIrp->IoStatus.Information = 0;

        // DlcCompleteIoRequest(pIrp, FALSE);
        // Don't call DlcCompleteIoRequest, it tries to free MDLs we haven't yet allocated
        // Instead of putting some more checks in DlcCompleteIoRequest, complete request here itself

        pIrp->IoStatus.Status = DLC_STATUS_INVALID_COMMAND;
        SetIrpCancelRoutine(pIrp, FALSE);
        IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);
        return DLC_STATUS_INVALID_COMMAND;
    }

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            < (ULONG)aDlcIoBuffers[TmpIndex].InputBufferSize
        ||

        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                            < (ULONG)aDlcIoBuffers[TmpIndex].OutputBufferSize) {

        //
        // This error code should never be returned to user
        // If this happpens, then there is something wrong with ACSLAN
        //

        pIrp->IoStatus.Information = 0;

        // DlcCompleteIoRequest(pIrp, FALSE);
        // Don't call DlcCompleteIoRequest, it tries to free MDLs we haven't yet allocated
        // Instead of putting some more checks in DlcCompleteIoRequest, complete request here itself

        pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        SetIrpCancelRoutine(pIrp, FALSE);
        IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Save the length of the actual output buffer to Information field.
    // This number of bytes will be copied back to user buffer.
    //

    pIrp->IoStatus.Information = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // there are 3 cases of asynchronous commands where we need to lock extra
    // user memory for returned information. This goes in the parameter table
    // which can be anywhere in user memory (ie not near the CCB):
    //
    //  TRANSMIT
    //      - TRANSMIT_FS - a single byte!
    //
    //  RECEIVE
    //      - FIRST_BUFFER - a DWORD - pointer to the first received frame
    //
    //  READ
    //      - the entire parameter table needs to be locked. Virtually all
    //        the fields are output. Still, this is only a max of 30 bytes
    //

    if (TmpIndex <= IOCTL_DLC_TRANSMIT_INDEX) {

        PVOID pDestination;
        PNT_DLC_PARMS pDlcParms;

        pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

        //
        // Get the pointer of output parameters in user memory.
        // Note that we are not accessing anything in user address space.
        //

        switch (TmpIndex) {
        case IOCTL_DLC_READ_INDEX:
            pDestination = &pDlcParms->Async.Ccb.u.pParameterTable->Read.uchEvent;
            break;

        case IOCTL_DLC_RECEIVE_INDEX:
            pDestination = &pDlcParms->Async.Ccb.u.pParameterTable->Receive.pFirstBuffer;
            break;

        case IOCTL_DLC_TRANSMIT_INDEX:
            pDestination = &pDlcParms->Async.Ccb.u.pParameterTable->Transmit.uchTransmitFs;
            break;
        }

        //
        // allocate another MDL for the 1, 4, or 30 byte parameter table and lock
        // the page(s!)
        //

        pDlcParms->Async.Ccb.u.pMdl = AllocateProbeAndLockMdl(
                                            pDestination,
                                            aSpecialOutputBuffers[TmpIndex]
                                            );
        if (pDlcParms->Async.Ccb.u.pMdl == NULL) {
            pIrp->IoStatus.Status = DLC_STATUS_MEMORY_LOCK_FAILED;
            DlcCompleteIoRequest(pIrp, FALSE);
            return DLC_STATUS_MEMORY_LOCK_FAILED;
        }
    }

    pFileContext = (PDLC_FILE_CONTEXT)pIrpSp->FileObject->FsContext;

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    //
    // We must leave immediately, if the reference counter is zero
    // or if we have a pending close or Initialize operation going on.
    // (This is not 100% safe, if app would create a file context,
    // open adapter, close adapter and immediately would close it again
    // when the previous command is pending, but that cannot be happen
    // with dlcapi.dll)
    //

    if ((pFileContext->ReferenceCount == 0)
    || ((pFileContext->State != DLC_FILE_CONTEXT_OPEN)
    && (TmpIndex != IOCTL_DLC_OPEN_ADAPTER_INDEX))) {

        LEAVE_DLC(pFileContext);

        RELEASE_DRIVER_LOCK();

        pIrp->IoStatus.Status = LLC_STATUS_ADAPTER_CLOSED;
        DlcCompleteIoRequest(pIrp, FALSE);
        return LLC_STATUS_ADAPTER_CLOSED;

    } else {

        NTSTATUS Status;

        DLC_TRACE('F');

        //
        // set the default IRP cancel routine. We are not going to handle
        // transmit cases now
        //

        //SetIrpCancelRoutine(pIrp,
        //                    (BOOLEAN)
        //                    !( (ioControlCode == IOCTL_DLC_TRANSMIT)
        //                    || (ioControlCode == IOCTL_DLC_TRANSMIT2) )
        //                    );

        //
        // and set the irp I/O status to pending
        //

        IoMarkIrpPending(pIrp);

        //
        // The reason why we add 2 here is that during the processing of the
        // current IRP we may complete the request, causing us to decrement the
        // reference counter on the file context. If we just incremented by 1
        // here, the decrement could cause a pending close IRP to be allowed to
        // delete the file context while we are still using it
        //

        ReferenceFileContextByTwo(pFileContext);

        //
        // Irp and IrpSp are used just as in NBF
        //

        Status = DispatchTable[TmpIndex](
                    pIrp,
                    pFileContext,
                    (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer,
                    pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                    );

        //
        // ensure the function returned with the correct IRQL
        //

        ASSUME_IRQL(DISPATCH_LEVEL);

        //
        // the following error codes are valid:
        //
        //  STATUS_PENDING
        //      The request has been accepted
        //      The driver will complete the request asynchronously
        //      The output CCB should contain 0xFF in its status field (unless
        //      already completed)
        //
        //  STATUS_SUCCESS
        //      The request has successfully completed synchronously
        //      The output CCB should contain 0x00 in its status field
        //
        //  0x6001 - 0x6069
        //  0x6080 - 0x6081
        //  0x60A1 - 0x60A3
        //  0x60C0 - 0x60CB
        //  0x60FF
        //      The request has failed with a DLC-specific error
        //      The error code is converted to a DLC status code (-0x6000) and
        //      the output CCB status field is set to the DLC status code
        //      No asynchronous completion will be taken for this request
        //

        if (Status != STATUS_PENDING) {

            DLC_TRACE('G');

            pIrpSp->Control &= ~SL_PENDING_RETURNED;

            if (Status != STATUS_SUCCESS) {

                PNT_DLC_PARMS pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

                if (Status >= DLC_STATUS_ERROR_BASE && Status < DLC_STATUS_MAX_ERROR) {
                    Status -= DLC_STATUS_ERROR_BASE;
                }

                //
                // RLF 04/20/94
                //
                // make sure the CCB has the correct value written to it on
                // output if we're not returning pending status
                //

                pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)Status;

                //
                // the CCB request has failed. Make sure the pNext field is reset
                //

                if ((pIrpSp->Parameters.DeviceIoControl.IoControlCode & 3) == METHOD_OUT_DIRECT) {

                    //
                    // the CCB address may actually be unaligned DOS CCB1
                    //

                    LLC_CCB UNALIGNED * pCcb;

                    pCcb = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
                    
                    if (pCcb) {
                        pCcb->pNext = NULL;
                    }
                    // Failure case. Don't override previous failure status.
                    // It is likely STATUS_INSUFFICIENT_RESOURCES.
                } else {
                    pDlcParms->Async.Ccb.pCcbAddress = NULL;
                }
            }

            if (ioControlCode != IOCTL_DLC_RESET) {

                //
                // DLC.RESET returns an immediate status and does not complete
                // asynchronously
                //

                DereferenceFileContextByTwo(pFileContext);
            } else {

                //
                // everything else that returns a non-pending status completes
                // asynchronously, which also causes the other reference count
                // to be removed
                //

                DereferenceFileContext(pFileContext);
            }

            LEAVE_DLC(pFileContext);

            RELEASE_DRIVER_LOCK();

            //
            // RLF 06/07/93
            //
            // if the request is DLC.RESET, the IRP will have already been
            // completed if we're here, so don't complete it again (else we'll
            // bugcheck)
            //

            if (ioControlCode != IOCTL_DLC_RESET) {
                DlcCompleteIoRequest(pIrp, FALSE);
            }

            return Status;

        } else {

            DLC_TRACE('H');

            //
            // Reallocate the buffer pool size, if a threshold has been exceeded
            //

            if (BufferPoolCheckThresholds(pFileContext->hBufferPool)) {

                ReferenceBufferPool(pFileContext);

                LEAVE_DLC(pFileContext);

#if DBG
                BufferPoolExpand(pFileContext, (PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#else 
                BufferPoolExpand((PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#endif

                ENTER_DLC(pFileContext);

                DereferenceBufferPool(pFileContext);
            }

            LEAVE_DLC(pFileContext);

            //
            // if this dereference causes the count to go to 0, the file context
            // will be destroyed. Implicitly we must be closing the adapter and
            // have received a close IRP for this to happen
            //

            DereferenceFileContext(pFileContext);

            RELEASE_DRIVER_LOCK();

            return STATUS_PENDING;
        }
    }
}


VOID
DlcCompleteIoRequest(
    IN PIRP pIrp,
    IN BOOLEAN InCancel
    )

/*++

Routine Description:

    This routine completes the given DLC IRP

Arguments:

    pIrp        - Pointer to the request packet representing the I/O request.
    InCancel    - TRUE if called on Irp cancel path

Return Value:

    None

--*/

{
    //
    // we are about to complete this IRP - remove the cancel routine. The check
    // stops us spinning forever if this function is called from within an IRP
    // cancellation
    //

    if (!InCancel) {
        SetIrpCancelRoutine(pIrp, FALSE);
    }

    //
    // unlock and free any MDLs we allocated
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL
    && IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode <= IOCTL_DLC_TRANSMIT) {

        //
        // We enter here only if something has gone wrong in the main
        // function of an async operation => the status field and
        // next pointer will be updated synchronously.
        // On the other hand, all other async functions having no output
        // parameters except CCB status and next pointer are upated
        // by the normal code path.  They should just copy
        // back the pending status and next pointer pointing to CCB itself.
        // That should not affect anything, because the DLL will update
        // those fields, when we return synchronous status
        //

        PNT_DLC_PARMS pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

        if (pDlcParms->Async.Ccb.u.pMdl != NULL) {
            UnlockAndFreeMdl(pDlcParms->Async.Ccb.u.pMdl);
        }
    }
    IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);
}

VOID
LinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    )
{
    KeAcquireSpinLock(&FileContextsLock, &PreviousIrql);
    PushEntryList(&FileContexts, &pFileContext->List);
    KeReleaseSpinLock(&FileContextsLock, PreviousIrql);
}

PDLC_FILE_CONTEXT
UnlinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    )
{
    PSINGLE_LIST_ENTRY p, prev = (PSINGLE_LIST_ENTRY)&FileContexts;

    KeAcquireSpinLock(&FileContextsLock, &PreviousIrql);
    for (p = FileContexts.Next; p && p != (PSINGLE_LIST_ENTRY)pFileContext; ) {
        prev = p;
        p = p->Next;
    }
    if (p) {
        prev->Next = p->Next;
//    } else {
//
//#if DBG
//        DbgPrint("DLC.UnlinkFileContext: Error: FILE_CONTEXT @%08X not on list??\n",
//                pFileContext
//                );
//#endif
//
    }
    KeReleaseSpinLock(&FileContextsLock, PreviousIrql);

    return (PDLC_FILE_CONTEXT)p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcbuf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcbuf.c

Abstract:

    This module implements the DLC buffer pool manager and provides routines
    to lock and unlock transmit buffers outside of the buffer pool

    DLC has a buffering scheme inherited from its progenitors right back to
    the very first DOS implementation. We must share a buffer pool with an
    application: the application allocates memory using any method it desires
    and gives us a pointer to that memory and the length. We page-align the
    buffer and carve it into pages. Any non page-aligned buffer at the start
    or end of the buffer are discarded.

    Once DLC has a buffer pool defined, it allocates buffers in a fashion
    similar to binary-buddy, or in a method that I shall call 'binary
    spouse'. Blocks are initially all contained in page sized units. As
    smaller blocks are required, a larger block is repeatedly split into 2
    until a i-block is generated where 2**i >= block size required. Unlike
    binary-buddy, the binary-spouse method does not coalesce buddy blocks to
    create larger buffers once split. Once divorced from each other, binary
    spouse blocks are unlikely to get back together.

    BufferPoolAllocate is the function that single-handedly implements the
    allocator mechanism. It basically handles 2 types of request in the same
    routine: the first request is from BUFFER.GET where a buffer will be
    returned to the app as a single buffer if we have a block available that
    is large enough to satisfy the request. If the request cannot be satisfied
    by a single block, we return a chain of smaller blocks. The second type of
    request is from the data receive DPC processing where we have to supply a
    single block to contain the data. Luckily, through the magic of MDLs, we
    can return several smaller blocks linked together by MDLs which masquerade
    as a single buffer. Additionally, we can create buffers larger than a
    single page in the same manner. This receive buffer must later be handed
    to the app in the same format as the buffer allocated by BUFFER.GET, so we
    need to be able to view this kind of buffer in 2 ways. This accounts for
    the complexity of the various headers and MDL descriptors which must be
    applied to the allocated blocks

    Contents:
        BufferPoolCreate
        BufferPoolExpand
        BufferPoolFreeExtraPages
        DeallocateBuffer
        AllocateBufferHeader
        BufferPoolAllocate
        BufferPoolDeallocate
        BufferPoolDeallocateList
        BufferPoolBuildXmitBuffers
        BufferPoolFreeXmitBuffers
        GetBufferHeader
        BufferPoolDereference
        BufferPoolReference
        ProbeVirtualBuffer
        AllocateProbeAndLockMdl
        BuildMappedPartialMdl
        UnlockAndFreeMdl

Author:

    Antti Saarenheimo 12-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include <memory.h>
#include "dlcdebug.h"

//
// LOCK/UNLOCK_BUFFER_POOL - acquires or releases per-buffer pool spin lock.
// Use kernel spin locking calls. Assumes variables are called "pBufferPool" and
// "irql"
//

#define LOCK_BUFFER_POOL()      KeAcquireSpinLock(&pBufferPool->SpinLock, &irql)
#define UNLOCK_BUFFER_POOL()    KeReleaseSpinLock(&pBufferPool->SpinLock, irql)

//
// data
//

PDLC_BUFFER_POOL pBufferPools = NULL;


#define CHECK_FREE_SEGMENT_COUNT(pBuffer)

/*
Enable this, if the free segment size checking fails:

#define CHECK_FREE_SEGMENT_COUNT(pBuffer) CheckFreeSegmentCount(pBuffer)

VOID
CheckFreeSegmentCount(
    PDLC_BUFFER_HEADER pBuffer
    );

VOID
CheckFreeSegmentCount(
    PDLC_BUFFER_HEADER pBuffer
    )
{
    PDLC_BUFFER_HEADER pTmp;
    UINT FreeSegments = 0;

    for (pTmp = (pBuffer)->FreeBuffer.pParent->Header.pNextChild;
         pTmp != NULL;
         pTmp = pTmp->FreeBuffer.pNextChild) {
        if (pTmp->FreeBuffer.BufferState == BUF_READY) {
             FreeSegments += pTmp->FreeBuffer.Size;
        }
    }
    if (FreeSegments != (pBuffer)->FreeBuffer.pParent->Header.FreeSegments) {
        DbgBreakPoint();
    }
}
*/


/*++

DLC Buffer Manager
------------------

The buffer pool consists of virtual memory blocks, that must be allocated
by the application program. The buffer block descriptors are allocated
separately from the non-paged pool, because they must be safe from
any memory corruption done in by an application.

The memory allocation strategy is binary buddy. All segments are
exponents of 2 between 256 and 4096. There is no official connection with
the system page size, but actually all segments are allocated within
a page and thus we minimize MDL sizes needed for them.  Contiguous
buffer blocks decrease also the DMA overhead. The initial user buffer
is first split to its maximal binary components. The components
are split further in the run time, when the buffer manager runs
out of the smaller segments (eg. it splits a 1024 segment to one
512 segment and two 256 segments, if it run out of 256 segments and
there were no free 512 segments either).

The clients of the buffer manager allocates buffer lists. They consists
of minimal number of binary segments. For example, a 1600 bytes buffer
request would return a list of 1024, 512 and 256 segments. The smallest
segment is the first and the biggest is the last. The application
program must deallocate all segments returned to it in the receive.
The validity of all deallocated segments is checked with a reservation list.

Buffer Manager provides api commands:
- to initialize a buffer pool (pool constructor)
- to add locked and mapped virtual memory to the buffer
- to deallocate the buffer pool (destructor)
- to allocate a segment list (allocator)
- to deallocate a segment list (deallocator)
- to set Thresholds for the minimum buffer size

--*/


/*++


MEMORY COMMITMENT


The commitement of buffer pools is a special service expecially for
the local busy state management of the link stations.  By default
the uncommitted memory is the same as the free memory in the buffer
pool minus the minimum free Threshold, but when a link enters to a
busy state we know how much buffer space the link will need
to receive at least the next frame.  Actually we will commit all
I- packets received in the local busy state.  The local 'out of buffers' busy
state will be cleared only when there is enough uncommited space in the
buffer pool to receive all expected packets.  We still indicate the local
busy state to user, because the flow control function can expand the buffer
pool, if it is necessary.  We will just queue the clear local busy state
command to a command queue (even if we complete it immediately),
we don;t execute the queued command before there is enough uncommited space
to enable the link receive.

The buffer space is committed by the size of all expected packets,
when the local busy state of a link is cleared.
All received packets are subracted from the commited buffer space
as far as the link has any committed memory.  This may happen only
after a local busy states.


We will provide three macroes to

BufGetPacketSize(PacketSize) - returns probable size of packet in buffers
BufGetUncommittedSpace(hBufferPool) - gets the current uncommited space
BufCommitBuffers(hBufferPool, BufferSize) - commits the given size
BufUncommitBuffers(hBufferPool, PacketSize) - uncommites a packet

--*/

NTSTATUS
ProbeVirtualBuffer(
    IN PUCHAR pBuffer,
    IN LONG Length
    );


NTSTATUS
BufferPoolCreate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PVOID pUserBuffer,
    IN LONG MaxBufferSize,
    IN LONG MinFreeSizeThreshold,
    OUT HANDLE *pBufferPoolHandle,
    OUT PVOID* AlignedAddress,
    OUT PULONG AlignedSize
    )

/*++

Routine Description:

    This routine performs initialization of the NT DLC API buffer pool.
    It allocates the buffer descriptor and the initial header blocks.

Arguments:

    pFileContext            - pointer to DLC_FILE_CONTEXT structure
    pUserBuffer             - virtual base address of the buffer
    MaxBufferSize           - the maximum size of the buffer space
    MinFreeSizeThreshold    - the minimum free space in the buffer
    pBufferPoolHandle       - the parameter returns the handle of buffer pool,
                              the same buffer pool may be shared by several
                              open contexts of one or more dlc applications.
    AlignedAddress          - we return the page-aligned buffer pool address
    AlignedSize             - and the page-aligned buffer pool size

Return Value:

    Returns NTSTATUS is a NT system call fails.

--*/

{
    NTSTATUS status;
    PDLC_BUFFER_POOL pBufferPool;
    PVOID pAlignedBuffer;
    INT i;
    register PPACKET_POOL pHeaderPool;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // page-align the buffer
    //

    pAlignedBuffer = (PVOID)(((ULONG_PTR)pUserBuffer + PAGE_SIZE - 1) & -(LONG)PAGE_SIZE);

    //
    // and make the length an integral number of pages
    //

    MaxBufferSize = (MaxBufferSize - (ULONG)((ULONG_PTR)pAlignedBuffer - (ULONG_PTR)pUserBuffer)) & -(LONG)PAGE_SIZE;

    //
    // the buffer size must be at least one page (BufferSize will be 0 if
    // this is not so)
    //

    if (MaxBufferSize <= 0) {
        return DLC_STATUS_BUFFER_SIZE_EXCEEDED;
    }

    //
    // if MinFreeSizeThreshold  < 0, we can have problems since it is negated later
    // on leaving buffer pool uninitialized
    //

    if (MinFreeSizeThreshold < 0) {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }

    //
    // if the size of the buffer is less than the minimum lock size then we lock
    // the entire buffer
    //

    if (MaxBufferSize < MinFreeSizeThreshold) {
        MinFreeSizeThreshold = MaxBufferSize;
    }

    //
    // allocate the DLC_BUFFER_POOL structure. This is followed by an array
    // of pointers to buffer headers describing the pages in the buffer pool
    //

    pBufferPool = ALLOCATE_ZEROMEMORY_DRIVER(sizeof(DLC_BUFFER_POOL)
                                             + sizeof(PVOID)
                                             * BYTES_TO_PAGES(MaxBufferSize)
                                             );
    if (!pBufferPool) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // pHeaderPool is a pool of DLC_BUFFER_HEADER structures - one of these
    // is used per page locked
    //

    pHeaderPool = CREATE_BUFFER_POOL_FILE(DlcBufferPoolObject,
                                          sizeof(DLC_BUFFER_HEADER),
                                          8
                                          );

    if (!pHeaderPool) {

        FREE_MEMORY_DRIVER(pBufferPool);

        return DLC_STATUS_NO_MEMORY;
    }

    //
    // initialize the buffer pool structure
    //

    pBufferPool->hHeaderPool = pHeaderPool;

    KeInitializeSpinLock(&pBufferPool->SpinLock);

    //
    // UncommittedSpace is the space above the minimum free threshold in the
    // locked region of the buffer pool. We set it to the negative of the
    // minimum free threshold here to cause BufferPoolExpand to lock down
    // the number of pages required to commit the minimum free threshold
    //

    pBufferPool->UncommittedSpace = -MinFreeSizeThreshold;

    //
    // MaxBufferSize is the size of the buffer pool rounded down to an integral
    // number of pages
    //

    pBufferPool->MaxBufferSize = (ULONG)MaxBufferSize;

    //
    // BaseOffset is the page-aligned address of the buffer pool
    //

    pBufferPool->BaseOffset = pAlignedBuffer;

    //
    // MaxOffset is the last byte + 1 (?) in the buffer pool
    //

    pBufferPool->MaxOffset = (PUCHAR)pAlignedBuffer + MaxBufferSize;

    //
    // MaximumIndex is the number of pages that describe the buffer pool. This
    // number is irrespective of the locked state of the pages
    //

    pBufferPool->MaximumIndex = (ULONG)(MaxBufferSize / MAX_DLC_BUFFER_SEGMENT);

    //
    // Link all unlocked pages to a link list.
    // Put the last pages in the buffer to the end of the list.
    //

    for (i = (INT)pBufferPool->MaximumIndex - 1; i >= 0; i--) {
        pBufferPool->BufferHeaders[i] = pBufferPool->pUnlockedEntryList;
        pBufferPool->pUnlockedEntryList = (PDLC_BUFFER_HEADER)&pBufferPool->BufferHeaders[i];
    }
    for (i = 0; i < DLC_BUFFER_SEGMENTS; i++) {
        InitializeListHead(&pBufferPool->FreeLists[i]);
    }
    InitializeListHead(&pBufferPool->PageHeaders);

    //
    // We can now lock the initial page buffers for the buffer pool.
    // The buffer pool allocation has been failed, if the procedure
    // returns an error.
    //

#if DBG
    status = BufferPoolExpand(pFileContext, pBufferPool);
#else
    status = BufferPoolExpand(pBufferPool);
#endif
    if (status != STATUS_SUCCESS) {

        //
        // We must use the standard procedure for deallocation,
        // because the memory locking may have succeeded partially.
        // The derefence free all resources in the buffer pool.
        //

        BufferPoolDereference(
#if DBG
            pFileContext,
#endif
            &pBufferPool
            );
    } else {

        KIRQL irql;

        //
        // Save the buffer pool handle to the link list of
        // buffer pools
        //

        ACQUIRE_DLC_LOCK(irql);

        pBufferPool->pNext = pBufferPools;
        pBufferPools = pBufferPool;

        RELEASE_DLC_LOCK(irql);

        *pBufferPoolHandle = pBufferPool;
        *AlignedAddress = pAlignedBuffer;
        *AlignedSize = MaxBufferSize;
    }
    return status;
}


NTSTATUS
BufferPoolExpand(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    )

/*++

Routine Description:

    The function checks the minimum and maximum size Thresholds and
    locks new pages or unlocks the extra pages and deallocates their
    buffer headers.
    The procedure uses the standard memory management functions
    to lock, probe and map the pages.

    The MDL buffer is split to smaller buffers (256, 512, ... 4096).
    The orginal buffer is split in the 4 kB even address (usually
    page border or even with any page size) to minimize PFNs associated
    with the MDLs (each MDL needs now only one PFN, to make
    DMA overhead smaller and to save locked memory).
    This procedure does not actually assume anything about the paging,
    but it should work quite well with any paging implementation.

    This procedure MUST be called only from the synchronous code path and
    all spinlocks unlocked, because of the page locking (the async
    code in always on the DPC level and you cannot make pagefaults on
    that level).

Arguments:

    pBufferPool - handle of buffer pool data structure.

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDLC_BUFFER_HEADER pBuffer;
    KIRQL irql;

    ASSUME_IRQL(DISPATCH_LEVEL);

    LOCK_BUFFER_POOL();

    //
    // UncommittedSpace < 0 just means that we've encroached past the minimum
    // free threshold and therefore we're in need of more buffer space (hence
    // this function)
    //

    if (((pBufferPool->UncommittedSpace < 0) || (pBufferPool->MissingSize > 0))
    && (pBufferPool->BufferPoolSize < pBufferPool->MaxBufferSize)) {

        UINT FreeSlotIndex;

        while ((pBufferPool->UncommittedSpace < 0) || (pBufferPool->MissingSize > 0)) {

            pBuffer = NULL;

            //
            // if there are no more pages to lock or we can't allocate a header
            // to describe the buffer then quit
            //

            if (!pBufferPool->pUnlockedEntryList
            || !(pBuffer = ALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool))) {
                status = DLC_STATUS_NO_MEMORY;
                break;
            }

            //
            // We use a direct mapping to find the immediately
            // the buffer headers.  Unallocated pages are in a single entry
            // link list in that table.  We must remove the locked entry
            // from the link list and save the buffer header address to the
            // new slot.  The offset of the entry defines also the free
            // unlocked buffer in the buffer pool.
            // I have used this funny structure to minimize header
            // information for the unlocked virtual pages (you could have
            // a huge virtual buffer pool with a very small overhead in DLC).
            //

            FreeSlotIndex = (UINT)(((ULONG_PTR)pBufferPool->pUnlockedEntryList - (ULONG_PTR)pBufferPool->BufferHeaders) / sizeof(PVOID));

            pBuffer->Header.BufferState = BUF_READY;
            pBuffer->Header.pLocalVa = (PVOID)((PCHAR)pBufferPool->BaseOffset + FreeSlotIndex * MAX_DLC_BUFFER_SEGMENT);
            pBufferPool->pUnlockedEntryList = pBufferPool->pUnlockedEntryList->pNext;
            pBufferPool->BufferHeaders[FreeSlotIndex] = pBuffer;

            //
            // Lock memory always outside the spin locks on 0 level.
            //

            UNLOCK_BUFFER_POOL();

            RELEASE_DRIVER_LOCK();

            pBuffer->Header.pMdl = AllocateProbeAndLockMdl(pBuffer->Header.pLocalVa,
                                                           MAX_DLC_BUFFER_SEGMENT
                                                           );

            ACQUIRE_DRIVER_LOCK();

            LOCK_BUFFER_POOL();

            if (pBuffer->Header.pMdl) {
                pBuffer->Header.pGlobalVa = MmGetSystemAddressForMdl(pBuffer->Header.pMdl);
                pBuffer->Header.FreeSegments = MAX_DLC_BUFFER_SEGMENT / MIN_DLC_BUFFER_SEGMENT;
                status = AllocateBufferHeader(
#if DBG
                            pFileContext,
#endif
                            pBufferPool,
                            pBuffer,
                            MAX_DLC_BUFFER_SEGMENT / MIN_DLC_BUFFER_SEGMENT,
                            0,                  // logical index within the page
                            0                   // page in the free page table
                            );
            } else {
                MemoryLockFailed = TRUE;
                status = DLC_STATUS_MEMORY_LOCK_FAILED;

#if DBG
                DbgPrint("DLC.BufferPoolExpand: AllocateProbeAndLockMdl(a=%x, l=%x) failed\n",
                        pBuffer->Header.pLocalVa,
                        MAX_DLC_BUFFER_SEGMENT
                        );
#endif

            }
            if (status != STATUS_SUCCESS) {

                //
                // It failed => free MDL (if non-null) and
                // restore the link list of available buffers
                //

                if (pBuffer->Header.pMdl != NULL) {
                    UnlockAndFreeMdl(pBuffer->Header.pMdl);
                }
                pBufferPool->BufferHeaders[FreeSlotIndex] = pBufferPool->pUnlockedEntryList;
                pBufferPool->pUnlockedEntryList = (PDLC_BUFFER_HEADER)&(pBufferPool->BufferHeaders[FreeSlotIndex]);

                DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pBuffer);

                break;
            }

#if LLC_DBG

            CHECK_FREE_SEGMENT_COUNT(pBuffer->Header.pNextChild);

#endif

            pBufferPool->FreeSpace += MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->UncommittedSpace += MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->BufferPoolSize += MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->MissingSize -= MAX_DLC_BUFFER_SEGMENT;
            LlcInsertTailList(&pBufferPool->PageHeaders, pBuffer);
        }
        pBufferPool->MissingSize = 0;

        //
        // We will return success, if at least the minimal amount
        // memory was allocated.  The initial pool size may be too
        // big for the current memory constraints set by the
        // operating system and actual available physical memory.
        //

        if (pBufferPool->UncommittedSpace < 0) {
            status = DLC_STATUS_NO_MEMORY;
        }
    }

    UNLOCK_BUFFER_POOL();

    return status;
}


VOID
BufferPoolFreeExtraPages(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    )

/*++

Routine Description:

    The function checks the maximum Thresholds and
    unlocks the extra pages and deallocates their buffer headers.

Arguments:

    pBufferPool - handle of buffer pool data structure.

Return Value:

    None.

--*/

{
    PDLC_BUFFER_HEADER pBuffer;
    KIRQL irql;
    PDLC_BUFFER_HEADER pNextBuffer;

    ASSUME_IRQL(DISPATCH_LEVEL);

/*
    DbgPrint("MaxBufferSize: %x\n", pBufferPool->MaxBufferSize);
    DbgPrint("Uncommitted size: %x\n", pBufferPool->UncommittedSpace);
    DbgPrint("BufferPoolSize: %x\n", pBufferPool->BufferPoolSize);
    DbgPrint("FreeSpace : %x\n", pBufferPool->FreeSpace);
*/

    LOCK_BUFFER_POOL();

    //
    // Free the extra pages until we have enough free buffer space.
    //

    pBuffer = (PDLC_BUFFER_HEADER)pBufferPool->PageHeaders.Flink;

    while ((pBufferPool->UncommittedSpace > MAX_FREE_SIZE_THRESHOLD)
    && (pBuffer != (PVOID)&pBufferPool->PageHeaders)) {

        //
        // We may free (unlock) only those buffers given, that have
        // all buffers free.
        //

        if ((UINT)(pBuffer->Header.FreeSegments == (MAX_DLC_BUFFER_SEGMENT / MIN_DLC_BUFFER_SEGMENT))) {
            pNextBuffer = pBuffer->Header.pNextHeader;
#if DBG
            DeallocateBuffer(pFileContext, pBufferPool, pBuffer);
#else
            DeallocateBuffer(pBufferPool, pBuffer);
#endif
            pBufferPool->FreeSpace -= MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->UncommittedSpace -= MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->BufferPoolSize -= MAX_DLC_BUFFER_SEGMENT;
            pBuffer = pNextBuffer;
        } else {
            pBuffer = pBuffer->Header.pNextHeader;
        }
    }

    UNLOCK_BUFFER_POOL();

}


VOID
DeallocateBuffer(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBuffer
    )

/*++

Routine Description:

    The routine unlinks all segments of a page from the free lists and
    deallocates the data structures.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pBuffer     - the deallocated buffer header

Return Value:

    None

--*/

{
    UINT FreeSlotIndex;
    PDLC_BUFFER_HEADER pSegment, pNextSegment;

    //
    // First we unlink the segments from the free lists and
    // then free and unlock the data structs of segment.
    //

    for (pSegment = pBuffer->Header.pNextChild; pSegment != NULL; pSegment = pNextSegment) {
        pNextSegment = pSegment->FreeBuffer.pNextChild;

        //
        // Remove the buffer from the free lists (if it is there)
        //

        if (pSegment->FreeBuffer.BufferState == BUF_READY) {
            LlcRemoveEntryList(pSegment);
        }

#if LLC_DBG

        else {

            //
            // This else can be possible only if we are
            // deleting the whole buffer pool (ref count=0)
            //

            if (pBufferPool->ReferenceCount != 0) {
                DbgPrint("Error: Invalid buffer state!");
                DbgBreakPoint();
            }
            pSegment->FreeBuffer.pNext = NULL;
        }

#endif

        IoFreeMdl(pSegment->FreeBuffer.pMdl);

        DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);

        DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pSegment);
    }

    //
    // Link the page to the free page list in buffer pool header
    //

    FreeSlotIndex = (UINT)(((ULONG_PTR)pBuffer->Header.pLocalVa - (ULONG_PTR)pBufferPool->BaseOffset) / MAX_DLC_BUFFER_SEGMENT);
    pBufferPool->BufferHeaders[FreeSlotIndex] = pBufferPool->pUnlockedEntryList;
    pBufferPool->pUnlockedEntryList = (PDLC_BUFFER_HEADER)&(pBufferPool->BufferHeaders[FreeSlotIndex]);
    UnlockAndFreeMdl(pBuffer->Header.pMdl);
    LlcRemoveEntryList(pBuffer);

    DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pBuffer);

}


NTSTATUS
AllocateBufferHeader(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pParent,
    IN UCHAR Size,
    IN UCHAR Index,
    IN UINT FreeListTableIndex
    )

/*++

Routine Description:

    The routine allocates and initializes a new buffer segment
    and links it to the given free segment list.

Arguments:

    pBufferPool         - handle of buffer pool data structure.
    pParent             - the parent (page) node of this segemnt
    Size                - size of this segment in 256 byte units
    Index               - index of this segment in 256 byte units
    FreeListTableIndex  - log2(Size), (ie. 256 bytes=>0, etc.)

Return Value:

    Returns NTSTATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_BUFFER_HEADER pBuffer;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (!(pBuffer = ALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool))) {
        return DLC_STATUS_NO_MEMORY;
    }

    pBuffer->FreeBuffer.pMdl = IoAllocateMdl((PUCHAR)pParent->Header.pLocalVa
                                                + (UINT)Index * MIN_DLC_BUFFER_SEGMENT,
                                             (UINT)Size * MIN_DLC_BUFFER_SEGMENT,
                                             FALSE,       // not used (no IRP)
                                             FALSE,       // we can't take this from user quota
                                             NULL
                                             );
    if (pBuffer->FreeBuffer.pMdl == NULL) {

        DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pBuffer);

        return DLC_STATUS_NO_MEMORY;
    }

    DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

    pBuffer->FreeBuffer.pNextChild = pParent->Header.pNextChild;
    pParent->Header.pNextChild = pBuffer;
    pBuffer->FreeBuffer.pParent = pParent;
    pBuffer->FreeBuffer.Size = Size;
    pBuffer->FreeBuffer.Index = Index;
    pBuffer->FreeBuffer.BufferState = BUF_READY;
    pBuffer->FreeBuffer.FreeListIndex = (UCHAR)FreeListTableIndex;

    //
    // Link the full page buffer to the first free list
    //

    LlcInsertHeadList(&(pBufferPool->FreeLists[FreeListTableIndex]), pBuffer);
    return STATUS_SUCCESS;
}


NTSTATUS
BufferPoolAllocate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferSize,
    IN UINT FrameHeaderSize,
    IN UINT UserDataSize,
    IN UINT FrameLength,
    IN UINT SegmentSizeIndex,
    IN OUT PDLC_BUFFER_HEADER *ppBufferHeader,
    OUT PUINT puiBufferSizeLeft
    )

/*++

Routine Description:

    Function allocates the requested buffer (locked and mapped) from the
    buffer pool and returns its MDL and descriptor table of user segments.
    The returned buffer is actually the minimal combination of some segments
    (256, 512, 1024, 2048, 4096).

    There is a header in each buffer segment. The size of the frame
    header and the user data added to all frames are defined by the caller.

    The allocated segments will be linked in three level:

        - Segment headers will be linked in the reserved list to
          be checked when the application program releases the buffers
          back to pool. The actual segments cannot be used, because
          they are located in unsafe user memory.

        - Segments are linked (from smaller to bigger) for application program,
          this link list is used nowhere in the driver (because it is in ...)

        - MDLs of the same buffer list are linked for the driver

        The link lists goes from smaller segment to bigger, because
        the last segment should be the biggest one in a transmit call
        (it actually works very nice with 2 or 4 token ring frames).

    DON'T TOUCH the calculation of the segment size (includes operations
    with BufferSize, ->Cont.DataLength and FirstHeaderSize),  the logic is
    very complex. The current code has been tested by hand using some
    test values, and it seems to work (BufferSize = 0, 1, 0xF3,
    FirstHeader = 0,2).

Arguments:

    pBufferPool         - handle of buffer pool data structure.

    BufferSize          - the size of the actual data in the requested buffers.
                          This must really be the actual data. Nobody can know
                          the size of all segment headers beforehand. The buffer
                          size must include the frame header size added to the
                          first buffer in the list!

    FrameHeaderSize     - the space reserved for the frame header depends on
                          buffer format (OS/2 or DOS) and if the data is read
                          contiguously or not. The buffer manager reserves four
                          bytes from the beginning of the first segment in frame
                          to link this frame to next frames.

    UserDataSize        - buffer area reserved for user data (nobody uses this)

    FrameLength         - the total frame length (may not be the same as
                          BufferSize, because the LAN and DLC headers may be
                          saved into the header.

    SegmentSizeIndex    - the client may ask a number segments having a fixed
                          size (256, 512, ... 4096).

    ppBufferHeader      - parameter returns the arrays of the user buffer
                          segments. The array is allocated in the end of this
                          buffer. This may include a pointer to a buffer pool,
                          that is already allocated. The old buffer list will
                          be linked behind the new buffers.

    puiBufferSizeLeft   - returns the size of buffer space, that is not yet
                          allocated. The client may extend the buffer pool
                          and then continue the allocation of the buffers.
                          Otherwise you could not allocate more buffers than
                          defined by MinFreeSizeThreshold.

Return Value:

    NTSTATUS
        STATUS_SUCCESS
        DLC_STATUS_NO_MEMORY - no available memory in the non paged pool

--*/

{
    INT i, j, k;        // loop indexes (three level loop)
    INT LastIndex;      // index of smallest allowed segment size.
    INT LastAvailable;  // Index of free list having biggest segments
    UINT SegmentSize;   // current segment size
    PDLC_BUFFER_HEADER pPrev;
    PMDL pPrevMdl;
    PDLC_BUFFER_HEADER pNew;
    PFIRST_DLC_SEGMENT pDlcBuffer, pLastDlcBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL irql;
    USHORT SavedDataLength;

    static USHORT SegmentSizes[DLC_BUFFER_SEGMENTS] = {
#if defined(ALPHA)
        8192,
#endif
        4096,
        2048,
        1024,
        512,
        256
    };

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Link the old buffers behind the new ones.
    // This is really sick:  BufferGet is calling this second (or more)
    // time after it has expanded the buffer pool for the new retry,
    // we must search the last buffer header, because the extra
    // buffer space is removed from it.
    //

    pPrev = *ppBufferHeader;
    if (pPrev != NULL) {
        for (pNew = pPrev;
            pNew->FrameBuffer.pNextSegment != NULL;
            pNew = pNew->FrameBuffer.pNextSegment) {
            ;       // NOP
        }
        pLastDlcBuffer = (PFIRST_DLC_SEGMENT)
                (
                    (PUCHAR)pNew->FreeBuffer.pParent->Header.pGlobalVa
                    + (UINT)pNew->FreeBuffer.Index * MIN_DLC_BUFFER_SEGMENT
                );
    }

    //
    // the first frame size has been added to the total length
    // (excluding the default header), but we must
    // exclude the default buffer header.
    //

    if (FrameHeaderSize > sizeof(NEXT_DLC_SEGMENT)) {
        FrameHeaderSize -= sizeof(NEXT_DLC_SEGMENT);
    } else {
        FrameHeaderSize = 0;
    }

    //
    // The frame header must be included in the total buffer space
    // just as any other stuff. We must add the maximum extra size
    // to get all stuff to fit into buffers.
    //

    BufferSize += MIN_DLC_BUFFER_SEGMENT - 1 + FrameHeaderSize;

    //
    // Initialize the index variables for the loop
    //

    if (SegmentSizeIndex == -1) {
        i = 0;
        LastIndex = DLC_BUFFER_SEGMENTS - 1;
        SegmentSize = MAX_DLC_BUFFER_SEGMENT;
    } else {
        i = SegmentSizeIndex;
        LastIndex = SegmentSizeIndex;
        SegmentSize = SegmentSizes[SegmentSizeIndex];
    }
    LastAvailable = 0;

    LOCK_BUFFER_POOL();

    //
    // Loop until we have found enough buffers for
    // the given buffer space (any kind, but as few as possible)
    // or for the given number of requested buffers.
    // Initialize each new buffer. The frame header is a special case.
    // We go from bigger segments to smaller ones.  The last (and smallest)
    // will be initialized as a frame header (if needed).
    //

    for (; (i <= LastIndex) && BufferSize; i++) {
        while (((SegmentSize - sizeof(NEXT_DLC_SEGMENT) - UserDataSize) < BufferSize) || (i == LastIndex)) {

            //
            // Check if there are any buffers having the optimal size
            //

            if (IsListEmpty(&pBufferPool->FreeLists[i])) {

                //
                // Split a bigger segment to smallers.  Link the
                // extra segments to the free lists and return
                // after that to the current size level.
                //

                for (j = i; j > LastAvailable; ) {
                    j--;
                    if (!IsListEmpty(&pBufferPool->FreeLists[j])) {

                        //
                        // Take the first available segment header in
                        // the free list
                        //

                        pNew = LlcRemoveHeadList(&pBufferPool->FreeLists[j]);

                        //
                        // Split segments until we reach the desired level.
                        // We leave every (empty) level between a new segment
                        // header (including the current level  (= i).
                        //

                        k = j;
                        do {
                            k++;

                            //
                            // We must also split the orginal buffer header
                            // and its MDL.
                            //

                            pNew->FreeBuffer.Size /= 2;
                            pNew->FreeBuffer.FreeListIndex++;

                            //
                            // We create the new buffer header for
                            // the upper half of the old buffer segment.
                            //

                            Status = AllocateBufferHeader(
#if DBG
                                            pFileContext,
#endif
                                            pBufferPool,
                                            pNew->FreeBuffer.pParent,
                                            pNew->FreeBuffer.Size,
                                            (UCHAR)(pNew->FreeBuffer.Index +
                                                    pNew->FreeBuffer.Size),
                                            (UINT)k
                                            );

                            //
                            // We cannot stop on error, but we try to
                            // allocate several smaller segments before
                            // we will give up.
                            //

                            if (Status != STATUS_SUCCESS) {

                                //
                                // We couldn't split the buffer, return
                                // the current buffer back to its slot.
                                //

                                pNew->FreeBuffer.Size *= 2;
                                pNew->FreeBuffer.FreeListIndex--;
                                LlcInsertHeadList(&pBufferPool->FreeLists[k-1],
                                                  pNew
                                                  );
                                break;
                            }
                        } while (k != i);
                        break;
                    }
                }

                //
                // Did we succeed to split the bigger segments
                // to smaller ones?
                //

                if (IsListEmpty(&pBufferPool->FreeLists[i])) {

                    //
                    // We have run out of bigger segments, let's try to
                    // use the smaller ones instead.  Indicate, that
                    // there exist no bigger segments than current one.
                    // THIS BREAK STARTS A NEW LOOP WITH A SMALLER
                    // SEGMENT SIZE.
                    //

                    LastAvailable = i;
                    break;
                }
            } else {
                pNew = LlcRemoveHeadList(&pBufferPool->FreeLists[i]);
            }
            pDlcBuffer = (PFIRST_DLC_SEGMENT)
                    ((PUCHAR)pNew->FreeBuffer.pParent->Header.pGlobalVa
                    + (UINT)pNew->FreeBuffer.Index * MIN_DLC_BUFFER_SEGMENT);

            //
            // The buffers must be chained together on three level:
            //      - using kernel Buffer headers (for driver)
            //      - by user pointer (for apps)
            //      - MDLs (for NDIS)
            //

            if (pPrev == NULL) {

                //
                // Frame header - initialize the list
                // HACK-HACK!!!!
                //

                pPrevMdl = NULL;
                pDlcBuffer->Cont.pNext = NULL;
                pLastDlcBuffer = pDlcBuffer;
            } else {
                pPrevMdl = pPrev->FrameBuffer.pMdl;
                pDlcBuffer->Cont.pNext = (PNEXT_DLC_SEGMENT)
                    ((PUCHAR)pPrev->FrameBuffer.pParent->Header.pLocalVa
                    + (UINT)pPrev->FrameBuffer.Index * MIN_DLC_BUFFER_SEGMENT);
            }
            pBufferPool->FreeSpace -= SegmentSize;
            pBufferPool->UncommittedSpace -= SegmentSize;
            pNew->FrameBuffer.pNextFrame = NULL;
            pNew->FrameBuffer.BufferState = BUF_USER;
            pNew->FrameBuffer.pNextSegment = pPrev;
            pNew->FrameBuffer.pParent->Header.FreeSegments -= pNew->FreeBuffer.Size;

#if LLC_DBG

            if ((UINT)(MIN_DLC_BUFFER_SEGMENT * pNew->FreeBuffer.Size) != SegmentSize) {
                DbgPrint("Invalid buffer size.\n");
                DbgBreakPoint();
            }
            CHECK_FREE_SEGMENT_COUNT(pNew);

#endif

            pPrev = pNew;
            pDlcBuffer->Cont.UserOffset = sizeof(NEXT_DLC_SEGMENT);
            pDlcBuffer->Cont.UserLength = (USHORT)UserDataSize;
            pDlcBuffer->Cont.FrameLength = (USHORT)FrameLength;
     	    // Save this length in a local var since pDlcBuffer->Cont.DataLength can be changed by user
            // but this is used later on also.
            SavedDataLength = (USHORT)(SegmentSize - sizeof(NEXT_DLC_SEGMENT) - UserDataSize);
            pDlcBuffer->Cont.DataLength = SavedDataLength;

            //
            // Check if we have done it!
            // Remember, that the buffer size have been round up/over to
            // the next 256 bytes even adderss => we never go negative.
            //
	
     	    // 127041: User can change this value between this and the last instruction
            //BufferSize -= pDlcBuffer->Cont.DataLength;
	        BufferSize -= SavedDataLength;

            if (BufferSize < MIN_DLC_BUFFER_SEGMENT) {
                pDlcBuffer->Cont.UserOffset += (USHORT)FrameHeaderSize;
                pDlcBuffer->Cont.DataLength -= (USHORT)FrameHeaderSize;
                SavedDataLength -= (USHORT)FrameHeaderSize;

                //
                // The data must be read to the beginning of the
                // buffer chain (eg. because of NdisTransferData).
                // => the first buffer must be full and the last
                // one must always be odd. The extra length
                // in the partial MDL does not matter.
                //

                BufferSize -= MIN_DLC_BUFFER_SEGMENT - 1;
                pLastDlcBuffer->Cont.DataLength += (USHORT)BufferSize;

                BuildMappedPartialMdl(
                    pNew->FrameBuffer.pParent->Header.pMdl,
                    pNew->FrameBuffer.pMdl,
                    pNew->FrameBuffer.pParent->Header.pLocalVa
                        + pNew->FrameBuffer.Index * MIN_DLC_BUFFER_SEGMENT
                        + FrameHeaderSize
         		        + UserDataSize
                        + sizeof(NEXT_DLC_SEGMENT),
                        SavedDataLength
                    );
                pNew->FrameBuffer.pMdl->Next = pPrevMdl;

                //
                // The buffer headers must be procted (the flag prevents
                // user to free them back buffer pool before we have
                // indicated the chained receive frames to him).
                // The linkage of frame headers will crash, if
                // the header buffer is released before the frame
                // was indicated!
                //

                pNew->FrameBuffer.BufferState = BUF_RCV_PENDING;
                BufferSize = 0;
                break;
            } else {

                //
                // MDL must exclude the buffer header from the actual data.
                //

                BuildMappedPartialMdl(
                    pNew->FrameBuffer.pParent->Header.pMdl,
                    pNew->FrameBuffer.pMdl,
                    pNew->FrameBuffer.pParent->Header.pLocalVa
                        + pNew->FrameBuffer.Index * MIN_DLC_BUFFER_SEGMENT
                        + UserDataSize
                        + sizeof(NEXT_DLC_SEGMENT),
                    pDlcBuffer->Cont.DataLength
                    );
                pNew->FrameBuffer.pMdl->Next = pPrevMdl;
            }
        }
        SegmentSize /= 2;
    }
    if (BufferSize == 0) {
        Status = STATUS_SUCCESS;
    } else {
        BufferSize -= (MIN_DLC_BUFFER_SEGMENT - 1);

        //
        // The client, that is not running in DPC level may extend
        // the buffer pool, if there is still available space left
        // in the buffer pool
        //

        if (pBufferPool->MaxBufferSize > pBufferPool->BufferPoolSize) {

            //
            // We can expand the buffer pool, sometimes we must
            // allocate new bigger segments, if the available
            // smaller segments cannot satisfy the request.
            //

            if ((LONG)BufferSize > pBufferPool->MissingSize) {
                pBufferPool->MissingSize = (LONG)BufferSize;
            }
            Status = DLC_STATUS_EXPAND_BUFFER_POOL;
        } else {
            Status = DLC_STATUS_INADEQUATE_BUFFERS;
        }
    }

    UNLOCK_BUFFER_POOL();

    *ppBufferHeader = pPrev;
    *puiBufferSizeLeft = BufferSize;

    return Status;
}


NTSTATUS
BufferPoolDeallocate(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers
    )

/*++

Routine Description:

    Function deallocates the requested buffers. It first checks
    the user buffer in the page table and then adds its header to
    the free list.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    BufferCount - number of user buffers to be released
    pBuffers    - array of the user buffers

Return Value:

    NTSTATUS

--*/

{
    PDLC_BUFFER_HEADER pBuffer;
    UINT i;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;

    ASSUME_IRQL(PASSIVE_LEVEL);

    LOCK_BUFFER_POOL();

    //
    // Return all buffers
    //

    for (i = 0; i < BufferCount; i++) {
        pBuffer = GetBufferHeader(pBufferPool, pBuffers[i].pBuffer);
        if (pBuffer && (pBuffer->FreeBuffer.BufferState == BUF_USER)) {

            register ULONG bufsize;

            //
            // Set the buffer state READY and restore the modified
            // size and offset fields in MDL
            //

            pBuffer->FreeBuffer.BufferState = BUF_READY;
            pBuffer->FreeBuffer.pParent->Header.FreeSegments += pBuffer->FreeBuffer.Size;

#if LLC_DBG
            if (pBuffer->FreeBuffer.pParent->Header.FreeSegments > 16) {
                DbgPrint("Invalid buffer size.\n");
                DbgBreakPoint();
            }
            CHECK_FREE_SEGMENT_COUNT(pBuffer);
#endif

            //
            // a microscopic performance improvement: the compiler (x86 at
            // least) generates the sequence of instructions to work out
            // the buffer size (number of blocks * block size) TWICE,
            // presumably because it can't assume that the structure hasn't
            // changed between the 2 accesses? Anyhow, Nature abhors a
            // vacuum, which is why my house is such a mess
            //

            bufsize = pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
            pBufferPool->FreeSpace += bufsize;
            pBufferPool->UncommittedSpace += bufsize;
            LlcInsertTailList(&pBufferPool->FreeLists[pBuffer->FreeBuffer.FreeListIndex], pBuffer);
        } else {

            //
            // At least one of the released buffers is invalid,
            // may be already released, or it may not exist in
            // the buffer pool at all
            //

            status = DLC_STATUS_INVALID_BUFFER_ADDRESS;
        }
    }

    UNLOCK_BUFFER_POOL();

    return status;
}


VOID
BufferPoolDeallocateList(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBufferList
    )

/*++

Routine Description:

    Function deallocates the requested buffer list.
    The buffer list may be circular or null terminated.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pBufferList - link list of user

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBuffer, pNextBuffer, pFrameBuffer, pNextFrameBuffer;
    KIRQL irql;

    if (pBufferList == NULL) {
        return;
    }

    LOCK_BUFFER_POOL();

    //
    // Return all buffers to the free lists.
    // The segments are always linked to a null terminated link list.
    // The frames are linked either circular or null terminated
    // link list!
    //
    // Note: both next segment and frame pointers are overlayed with
    // the pPrev and pNext pointers of the double linked free lists.
    //

    pNextFrameBuffer = pBufferList;
    do {
        pBuffer = pFrameBuffer = pNextFrameBuffer;
        pNextFrameBuffer = pFrameBuffer->FrameBuffer.pNextFrame;
        do {
            pNextBuffer = pBuffer->FrameBuffer.pNextSegment;

#if LLC_DBG

            if (pBuffer->FreeBuffer.BufferState != BUF_USER
            && pBuffer->FreeBuffer.BufferState != BUF_RCV_PENDING) {
                DbgBreakPoint();
            }
            if (pBuffer->FreeBuffer.pParent->Header.FreeSegments > 16) {
                DbgPrint("Invalid buffer size.\n");
                DbgBreakPoint();
            }
            CHECK_FREE_SEGMENT_COUNT(pBuffer);

#endif

            //
            // Set the buffer state READY and restore the modified
            // size and offset fields in MDL
            //

            pBuffer->FreeBuffer.BufferState = BUF_READY;
            pBuffer->FreeBuffer.pParent->Header.FreeSegments += pBuffer->FreeBuffer.Size;
            pBufferPool->FreeSpace += pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
            pBufferPool->UncommittedSpace += pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
            LlcInsertTailList(&pBufferPool->FreeLists[pBuffer->FreeBuffer.FreeListIndex],
                              pBuffer
                              );
        } while ( pBuffer = pNextBuffer );
    } while (pNextFrameBuffer && (pNextFrameBuffer != pBufferList));

    UNLOCK_BUFFER_POOL();

}


NTSTATUS
BufferPoolBuildXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers,
    IN OUT PDLC_PACKET pPacket
    )

/*++

Routine Description:

    Function build a MDL and buffer header list for a frame defined by
    a scatter/gather array. All buffers outside the buffer pool
    are probed and locked. All MDLs (the locked and ones for buffer pool)
    are chained together. The buffer pool headers are also chained.
    If any errors have been found the buffers are released using the
    reverse function (BufferPoolFreeXmitBuffers).

    THIS FUNCTION HAS A VERY SPECIAL SPIN LOCKING DESIGN:

    First we free the global spin lock (and lower the IRQ level to the lowest),
    Then, if the transmit is made from DLC buffers, we lock the
    spin lock again using NdisSpinLock function, that saves and restores
    the IRQL level, when it acquires and releases the spin lock.

    This all is done to minimize the spin locking overhead when we are
    locking transmit buffers, that are usually DLC buffers or normal
    user memory but not both.

Arguments:

    pBufferPool - handle of buffer pool data structure, THIS MAY BE NULL!!!!
    BufferCount - number of user buffers in the frame
    pBuffers    - array of the user buffers of the frame
    pPacket     - generic DLC packet used in transmit

Return Value:

    NTSTATUS

--*/

{
    PDLC_BUFFER_HEADER pBuffer, pPrevBuffer = NULL;
    PMDL pMdl, pPrevMdl = NULL;
    INT i;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN FirstBuffer = TRUE;
    UINT InfoFieldLength = 0;
    BOOLEAN BufferPoolIsLocked = FALSE; // very neat optimization!
    KIRQL irql;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // The client may allocate buffer headers without any buffers!
    //

    if (BufferCount != 0) {

        //
        // walk the buffers in a reverse order to build the
        // list in a convinient way.
        //

        for (i = BufferCount - 1; i >= 0; i--) {

            if (pBuffers[i].cbBuffer == 0) {
                continue;
            }

            InfoFieldLength += pBuffers[i].cbBuffer;

            //
            // Check first if the given address is in the same area as the
            // buffer pool
            //

            if (pBufferPool != NULL
            && (ULONG_PTR)pBuffers[i].pBuffer >= (ULONG_PTR)pBufferPool->BaseOffset
            && (ULONG_PTR)pBuffers[i].pBuffer < (ULONG_PTR)pBufferPool->MaxOffset) {

                //
                // Usually all transmit buffers are either in the buffer
                // pool or they are elsewhere in the user memory.
                // This boolean flag prevents us to toggle the buffer
                // pool spinlock for each transmit buffer segment.
                // (and nt spinlock is slower than its critical section!!!)
                //

                if (BufferPoolIsLocked == FALSE) {

                    LOCK_BUFFER_POOL();

                    BufferPoolIsLocked = TRUE;
                }
            }

            //
            // The previous check does not yet garantee, that the given buffer
            // if really a buffer pool segment, but the buffer pool is
            // is now unlocked if it was aboslutely outside of the buffer pool,
            // GetBufferHeader- function requires, that the buffer pool
            // is locked, when it is called!
            //

            if (BufferPoolIsLocked
            && (pBuffer = GetBufferHeader(pBufferPool, pBuffers[i].pBuffer)) != NULL) {

                //
                // The provided buffer must be inside the allocated
                // buffer, otherwise the user has corrupted its buffers.
                // user offset within buffer + user length <= buffer
                // length
                // The buffer must be also be owned by the user
                //

                if (((ULONG_PTR)pBuffers[i].pBuffer & (MIN_DLC_BUFFER_SEGMENT - 1))
                         + (ULONG)pBuffers[i].cbBuffer
                         > (ULONG)(pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT)
                    || (pBuffer->FrameBuffer.BufferState & BUF_USER) == 0) {

                    Status = DLC_STATUS_BUFFER_SIZE_EXCEEDED;
                    break;
                }

                //
                // The same DLC buffer may be referenced several times.
                // Create a partial MDL for it and add the reference
                // counter.
                //

                if (pBuffer->FrameBuffer.BufferState & BUF_LOCKED) {
                    pMdl = IoAllocateMdl(pBuffers[i].pBuffer,
                                         pBuffers[i].cbBuffer,
                                         FALSE, // not used (no IRP)
                                         FALSE, // can't charge from quota now
                                         NULL   // Do not link it to IRPs
                                         );
                    if (pMdl == NULL) {
                        Status = DLC_STATUS_NO_MEMORY;
                        break;
                    }

                    DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

                    BuildMappedPartialMdl(pBuffer->FrameBuffer.pParent->Header.pMdl,
                                          pMdl,
                                          pBuffers[i].pBuffer,
                                          pBuffers[i].cbBuffer
                                          );
                    pBuffer->FrameBuffer.ReferenceCount++;

                    if (pBuffers[i].boolFreeBuffer) {
                        pBuffer->FrameBuffer.BufferState |= DEALLOCATE_AFTER_USE;
                    }

                } else {

                    //
                    // Modify the MDL for this request, the length must
                    // not be bigger than the buffer length and the
                    // offset must be within the first 255 bytes of
                    // the buffer.  Build also the buffer header list
                    // (i don't know why?)
                    //

                    pMdl = pBuffer->FrameBuffer.pMdl;

                    if (

                    ((UINT)(ULONG_PTR)pBuffers[i].pBuffer & (MIN_DLC_BUFFER_SEGMENT - 1))

                    + pBuffers[i].cbBuffer

                    > (UINT)pBuffer->FrameBuffer.Size * MIN_DLC_BUFFER_SEGMENT) {

                        Status = DLC_STATUS_INVALID_BUFFER_LENGTH;
                        break;
                    }

                    pBuffer->FrameBuffer.pNextSegment = pPrevBuffer;
                    pBuffer->FrameBuffer.BufferState |= BUF_LOCKED;
                    pBuffer->FrameBuffer.ReferenceCount = 1;

                    if (pBuffers[i].boolFreeBuffer) {
                        pBuffer->FrameBuffer.BufferState |= DEALLOCATE_AFTER_USE;
                    }
                    pPrevBuffer = pBuffer;

                    //
                    // DLC applications may change the user length or
                    // buffer length of the frames given to them =>
                    // we must reinitialize global buffer and its length
                    //

                    BuildMappedPartialMdl(pBuffer->FrameBuffer.pParent->Header.pMdl,
                                          pMdl,
                                          pBuffers[i].pBuffer,
                                          pBuffers[i].cbBuffer
                                          );
                }
            } else {
                if (BufferPoolIsLocked == TRUE) {

                    UNLOCK_BUFFER_POOL();

                    BufferPoolIsLocked = FALSE;
                }

                //
                // Setup the exception handler around the memory manager
                // calls and clean up any extra data if this fails.
                //

                pMdl = AllocateProbeAndLockMdl(pBuffers[i].pBuffer, pBuffers[i].cbBuffer);
                if (pMdl == NULL) {
                    Status = DLC_STATUS_MEMORY_LOCK_FAILED;

#if DBG
                    DbgPrint("DLC.BufferPoolBuildXmitBuffers: AllocateProbeAndLockMdl(a=%x, l=%x) failed\n",
                            pBuffers[i].pBuffer,
                            pBuffers[i].cbBuffer
                            );
#endif

                    break;
                }

#if LLC_DBG
                cLockedXmitBuffers++;
#endif

            }

            //
            // Chain all MDLs together
            //

            pMdl->Next = pPrevMdl;
            pPrevMdl = pMdl;
        }
    }
    if (BufferPoolIsLocked == TRUE) {

        UNLOCK_BUFFER_POOL();

    }

    pPacket->Node.pNextSegment = pPrevBuffer;
    pPacket->Node.pMdl = pPrevMdl;
    pPacket->Node.LlcPacket.InformationLength = (USHORT)InfoFieldLength;

    if (Status != STATUS_SUCCESS) {

        //
        // Free all allocated buffer (but the last one because there
        // was an error with it)
        //

        BufferPoolFreeXmitBuffers(pBufferPool, pPacket);
    }
    return Status;
}


VOID
BufferPoolFreeXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_PACKET pXmitNode
    )

/*++

Routine Description:

    Function unlocks the xmit buffers that are not in the buffer pool.
    The caller must use DeallocateBufferPool routine to
    and deallocates and the buffers are returned back to the pool.
    The function has to separate the MDLs of user buffers and
    buffer pool MDLs.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pXmitNode   - pointer to a structure, that includes the buffer header list,
                  MDL chain or it chains serveral transmits nodes and IRP together.

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBuffer;
    PDLC_BUFFER_HEADER pOtherBuffer = NULL;
    PDLC_BUFFER_HEADER pNextBuffer = NULL;
    PMDL pMdl, pNextMdl;
    KIRQL irql;

#if LLC_DBG
    BOOLEAN FrameCounted = FALSE;
#endif

    //
    // Free all DLC buffers and MDLs linked in the transmit node.
    // MDL list may be larger than the buffer header list.
    //

    if (pXmitNode != NULL) {
        if (pBufferPool != NULL) {

            LOCK_BUFFER_POOL();

        }
        pBuffer = pXmitNode->Node.pNextSegment;
        for (pMdl = pXmitNode->Node.pMdl; pMdl != NULL; pMdl = pNextMdl) {
            pNextMdl = pMdl->Next;
            pMdl->Next = NULL;

            //
            // Unlock only those MDLs, that are outside the buffer pool.
            //

            if ((pBuffer == NULL || pBuffer->FrameBuffer.pMdl != pMdl)
            && (pOtherBuffer = GetBufferHeader(pBufferPool, MmGetMdlVirtualAddress(pMdl))) == NULL) {

#if LLC_DBG
                cUnlockedXmitBuffers++;
#endif

                UnlockAndFreeMdl(pMdl);
            } else {

                //
                // This pointer can be NULL only if the first condition
                // if the previous 'if statement' was true => this cannot
                // be an orginal buffer header.
                //

                if (pOtherBuffer != NULL) {

                    //
                    // This is not the first reference of the buffer pool
                    // segment, but a partial MDL created by a new
                    // reference to a buffer segment already in use.
                    // Free the paritial MDL and setup the buffer
                    // pointer for the next loop.
                    //

                    pNextBuffer = pBuffer;
                    pBuffer = pOtherBuffer;
                    pOtherBuffer = NULL;
                    IoFreeMdl(pMdl);
                    DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
                } else if (pBuffer != NULL) {

                    //
                    // This is the orginal refence of the buffer pool
                    // segment, we may advance also in the buffer header
                    // link list.
                    //

                    pNextBuffer = pBuffer->FrameBuffer.pNextSegment;
                }

                //
                // The same DLC buffer may be referenced several times.
                // Decrement the reference counter and free the
                // list if this was the last released reference.
                //

                pBuffer->FrameBuffer.ReferenceCount--;
                if (pBuffer->FrameBuffer.ReferenceCount == 0) {
                    if (pBuffer->FrameBuffer.BufferState & DEALLOCATE_AFTER_USE) {

                        //
                        // Set the buffer state READY and restore the modified
                        // size and offset fields in MDL
                        //

                        pBuffer->FreeBuffer.BufferState = BUF_READY;
                        pBuffer->FreeBuffer.pParent->Header.FreeSegments += pBuffer->FreeBuffer.Size;

#if LLC_DBG
                        if (pBuffer->FreeBuffer.pParent->Header.FreeSegments > 16) {
                            DbgPrint("Invalid buffer size.\n");
                            DbgBreakPoint();
                        }
                        CHECK_FREE_SEGMENT_COUNT(pBuffer);
#endif

                        pBufferPool->FreeSpace += (UINT)pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
                        pBufferPool->UncommittedSpace += (UINT)pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;

                        LlcInsertTailList(&pBufferPool->FreeLists[pBuffer->FreeBuffer.FreeListIndex], pBuffer);

#if LLC_DBG
                        if (FrameCounted == FALSE) {
                            FrameCounted = TRUE;
                            cFramesReleased++;
                        }
#endif

                    } else {
                        pBuffer->FreeBuffer.BufferState = BUF_USER;
                    }
                }
                pBuffer = pNextBuffer;
            }
        }
        if (pBufferPool != NULL) {

            UNLOCK_BUFFER_POOL();

        }
    }
}


PDLC_BUFFER_HEADER
GetBufferHeader(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PVOID pUserBuffer
    )

/*++

Routine Description:

    Function returns the buffer pool header of the given
    buffer in the user address space or NULL, if the given
    address has no buffer.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pUserBuffer - DLC buffer address in user memory

Return Value:

    Pointer of DLC buffer header
    or NULL (if not found)

--*/

{
    UINT PageTableIndex;
    UINT IndexWithinPage;
    PDLC_BUFFER_HEADER pBuffer;

    //
    // The buffer pool may not exist, when we are transmitting frames.
    //

    if (pBufferPool == NULL) {
        return NULL;
    }

    PageTableIndex = (UINT)(((ULONG_PTR)pUserBuffer - (ULONG_PTR)pBufferPool->BaseOffset)
                   / MAX_DLC_BUFFER_SEGMENT);

    //
    // We simply discard the buffers outside the preallocated
    // virtual buffer in user space.  We must also check,
    // that the buffer is really reserved and locked (ie.
    // it is not in the free list of unlocked entries).
    // Note, that the buffer pool base address have been aligned with
    // the maximum buffer segment size.
    //

    if (PageTableIndex >= (UINT)pBufferPool->MaximumIndex
    || ((ULONG_PTR)pBufferPool->BufferHeaders[PageTableIndex] >= (ULONG_PTR)pBufferPool->BufferHeaders
    && (ULONG_PTR)pBufferPool->BufferHeaders[PageTableIndex] < (ULONG_PTR)&pBufferPool->BufferHeaders[pBufferPool->MaximumIndex])) {
        return NULL;
    }

    IndexWithinPage = (UINT)(((ULONG_PTR)pUserBuffer & (MAX_DLC_BUFFER_SEGMENT - 1)) / MIN_DLC_BUFFER_SEGMENT);

    for (
        pBuffer = pBufferPool->BufferHeaders[PageTableIndex]->Header.pNextChild;
        pBuffer != NULL;
        pBuffer = pBuffer->FreeBuffer.pNextChild) {

        if (pBuffer->FreeBuffer.Index == (UCHAR)IndexWithinPage) {

            //
            // We MUST not return a locked buffer, otherwise the app
            // will corrupt the whole buffer pool.
            //

            if ((pBuffer->FreeBuffer.BufferState & BUF_USER) == 0) {
                return NULL;
            } else {
                return pBuffer;
            }
        }
    }
    return NULL;
}


VOID
BufferPoolDereference(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL *ppBufferPool
    )

/*++

Routine Description:

    This routine decrements the reference count of the buffer pool
    and deletes it when the reference count hits to zero.

Arguments:

    pFileContext    - pointer to DLC_FILE_CONTEXT
    pBufferPool     - opaque handle of buffer pool data structure.

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBufferHeader, pNextHeader;
    KIRQL irql;
    PDLC_BUFFER_POOL pBufferPool = *ppBufferPool;

    ASSUME_IRQL(ANY_IRQL);

    *ppBufferPool = NULL;

    if (pBufferPool == NULL) {
        return;
    }

    LOCK_BUFFER_POOL();

    if (pBufferPool->ReferenceCount != 0) {
        pBufferPool->ReferenceCount--;
    }
    if (pBufferPool->ReferenceCount == 0) {

        KIRQL Irql2;

        ACQUIRE_DLC_LOCK(Irql2);

        RemoveFromLinkList((PVOID*)&pBufferPools, pBufferPool);

        RELEASE_DLC_LOCK(Irql2);

        //
        // The buffer pool does not exist any more !!!
        // => we can remove the spin lock and free all resources
        //

        UNLOCK_BUFFER_POOL();

        for (pBufferHeader = (PDLC_BUFFER_HEADER)pBufferPool->PageHeaders.Flink;
             !IsListEmpty(&pBufferPool->PageHeaders);
             pBufferHeader = pNextHeader) {

            pNextHeader = pBufferHeader->Header.pNextHeader;
#if DBG
            DeallocateBuffer(pFileContext, pBufferPool, pBufferHeader);
#else
            DeallocateBuffer(pBufferPool, pBufferHeader);
#endif

        }

        DELETE_BUFFER_POOL_FILE(&pBufferPool->hHeaderPool);

        FREE_MEMORY_DRIVER(pBufferPool);

    } else {

#if DBG

        DbgPrint("Buffer pool not released, reference count = %d\n",
                 pBufferPool->ReferenceCount
                 );

#endif

        UNLOCK_BUFFER_POOL();

    }
}


NTSTATUS
BufferPoolReference(
    IN HANDLE hExternalHandle,
    OUT PVOID *phOpaqueHandle
    )

/*++

Routine Description:

    This routine translates the the external buffer pool handle to
    a local opaque handle (=void pointer of the structure) and
    optioanlly checks the access rights of the current process to
    the buffer pool memory. The probing may raise an exeption to
    the IO- system, that will return error when this terminates.
    The function also increments the reference count of the buffer pool.

Arguments:

    hExternalHandle - buffer handle allocated from the handle table
    phOpaqueHandle  - opaque handle of buffer pool data structure

Return Value:

    None

--*/

{
    PDLC_BUFFER_POOL pBufferPool;
    NTSTATUS Status;
    KIRQL irql;

    ASSUME_IRQL(DISPATCH_LEVEL);

    ACQUIRE_DLC_LOCK(irql);

    for (pBufferPool = pBufferPools; pBufferPool != NULL; pBufferPool = pBufferPool->pNext) {
        if (pBufferPool == hExternalHandle) {
            break;
        }
    }

    RELEASE_DLC_LOCK(irql);

    if (pBufferPool == NULL) {
        return DLC_STATUS_INVALID_BUFFER_HANDLE;
    }

    //
    // We must do the optional probing outside of the spinlocks
    // and before we have incremented the reference count.
    // We do only read probing, because it is simpler.
    //

    RELEASE_DRIVER_LOCK();

    Status = ProbeVirtualBuffer(pBufferPool->BaseOffset, pBufferPool->BufferPoolSize);

    ACQUIRE_DRIVER_LOCK();

    if (Status == STATUS_SUCCESS) {

        LOCK_BUFFER_POOL();

        pBufferPool->ReferenceCount++;
        *phOpaqueHandle = (PVOID)pBufferPool;

        UNLOCK_BUFFER_POOL();

    }
    return Status;
}


NTSTATUS
ProbeVirtualBuffer(
    IN PUCHAR pBuffer,
    IN LONG Length
    )

/*++

Routine Description:

    Tests an address range for accessability. Actually reads the first and last
    DWORDs in the address range, and assumes the rest of the memory is paged-in.

Arguments:

    pBuffer - address to test
    Length  - in bytes of region to check

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_MEMORY_LOCK_FAILED

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    ASSUME_IRQL(PASSIVE_LEVEL);

    try {
        ProbeForRead(pBuffer, Length, sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {

#if DBG
        DbgPrint("DLC.ProbeVirtualBuffer: Error: Can't ProbeForRead a=%x, l=%x\n",
                pBuffer,
                Length
                );
#endif

        status = DLC_STATUS_MEMORY_LOCK_FAILED;
    }
    return status;
}


PMDL
AllocateProbeAndLockMdl(
    IN PVOID UserBuffer,
    IN UINT UserBufferLength
    )

/*++

Routine Description:

    This function just allocates, probes, locks and optionally maps
    any user buffer to kernel space.  Returns NULL, if the operation
    fails for any reason.

Remarks:

    This routine can be called only below DPC level and when the user
    context is known (ie. a spin locks must not be set!).

Arguments:

    UserBuffer          - user space address
    UserBufferLength    - length of that buffer is user space

Return Value:

    PMDL - pointer if successful
    NULL if not successful

--*/

{
    PMDL pMdl;

    ASSUME_IRQL(PASSIVE_LEVEL);

    try {
        pMdl = IoAllocateMdl(UserBuffer,
                             UserBufferLength,
                             FALSE, // not used (no IRP)
                             FALSE, // we don't charge the non-paged pool quota
                             NULL   // Do not link it to IRP
                             );
        if (pMdl != NULL) {

#if DBG
            IF_DIAG(MDL_ALLOC) {

                PVOID caller, callerscaller;

                RtlGetCallersAddress(&caller, &callerscaller);
                DbgPrint("A: pMdl=%#x caller=%#x caller's=%#x\n",
                         pMdl,
                         caller,
                         callerscaller
                         );
            }
#endif

            DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

            MmProbeAndLockPages(pMdl,
                                UserMode,   // Current user must have access!
                                IoModifyAccess
                                );

            DBG_INTERLOCKED_ADD(
                LockedPageCount,
                +(ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                    ((ULONG)pMdl->StartVa | pMdl->ByteOffset),
                    pMdl->ByteCount))
                );
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        DBG_INTERLOCKED_INCREMENT(FailedMemoryLockings);
        if (pMdl != NULL) {
            IoFreeMdl(pMdl);
            DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
            pMdl = NULL;
        }
    }
    return pMdl;
}


VOID
BuildMappedPartialMdl(
    IN PMDL pSourceMdl,
    IN OUT PMDL pTargetMdl,
    IN PVOID BaseVa,
    IN ULONG Length
    )

/*++

Routine Description:

    This function builds a partial MDL from a mapped source MDL.
    The target MDL must have been initialized for the given size.
    The target MDL cannot be used after the source MDL has been
    unmapped.

Remarks:

    MDL_PARTIAL_HAS_BEEN_MAPPED flag is not set in MdlFlag to
    prevent IoFreeMdl to unmap the virtual address.

Arguments:

    pSourceMdl  - Mapped source MDL
    pTargetMdl  - Allocate MDL
    BaseVa      - virtual base address
    Length      - length of the data

Return Value:

    None

--*/

{
    ASSUME_IRQL(ANY_IRQL);

    if (Length) {
        LlcMemCpy(&pTargetMdl[1],
                  &pSourceMdl[1],
                  (UINT)(sizeof(ULONG) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(BaseVa, Length))
                  );
    }
    pTargetMdl->Next = NULL;
    pTargetMdl->StartVa = (PVOID)PAGE_ALIGN(BaseVa);
    pTargetMdl->ByteOffset = BYTE_OFFSET(BaseVa);
    pTargetMdl->ByteCount = Length;

    //
    // HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK
    //
    // The excellent NT memory manager doesn't provide any fast way to
    // create temporary MDLs that will be deallocated before their
    // actual source MDLs.
    // We will never map this MDL, because its mapped orginal source mdl
    // will be kept in memory until this (and its peers) have been
    // deallocated.
    //

    pTargetMdl->MdlFlags = (UCHAR)((pTargetMdl->MdlFlags & ~MDL_MAPPED_TO_SYSTEM_VA)
                         | MDL_SOURCE_IS_NONPAGED_POOL);

    pTargetMdl->MappedSystemVa = (PVOID)((PCHAR)MmGetSystemAddressForMdl(pSourceMdl)
                               + ((ULONG_PTR)BaseVa - (ULONG_PTR)MmGetMdlVirtualAddress(pSourceMdl)));
}


VOID
UnlockAndFreeMdl(
    PMDL pMdl
    )

/*++

Routine Description:

    This function unmaps (if not a partial buffer), unlocks and
    and free a MDL.

    OK to call at DISPATCH_LEVEL

Arguments:

    pMdl - pointer to MDL to free

Return Value:

    None

--*/

{
    ASSUME_IRQL(ANY_IRQL);

    DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
    DBG_INTERLOCKED_ADD(LockedPageCount,
                        -(ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                            ((ULONG)((PMDL)pMdl)->StartVa | ((PMDL)pMdl)->ByteOffset),
                            (((PMDL)pMdl)->ByteCount)))
                        );

    MmUnlockPages((PMDL)pMdl);
    IoFreeMdl((PMDL)pMdl);

#if DBG

    IF_DIAG(MDL_ALLOC) {

        PVOID caller, callerscaller;

        RtlGetCallersAddress(&caller, &callerscaller);
        DbgPrint("F: pMdl=%#x caller=%#x caller's=%#x\n",
                 pMdl,
                 caller,
                 callerscaller
                 );
    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlccncl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlccncl.c

Abstract:

    This module contains functions which handle IRP cancellations for DLC
    commands

    Contents:
        SetIrpCancelRoutine
        DlcCancelIrp
        CancelCommandIrp
        CancelTransmitIrp
        (MapIoctlCode)

Author:

    Richard L Firth (rfirth) 22-Mar-1993

Environment:

    kernel mode only

Revision History:

    22-Mar-1993 rfirth
        Created

--*/

#include "dlc.h"

VOID
CancelCommandIrp(
    IN PIRP Irp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PLIST_ENTRY Queue
    );

VOID
CancelTransmitIrp(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext
    );

#if DBG
PSTR MapIoctlCode(ULONG);

//BOOLEAN DebugCancel = TRUE;
BOOLEAN DebugCancel = FALSE;
#endif


VOID
SetIrpCancelRoutine(
    IN PIRP Irp,
    IN BOOLEAN Set
    )

/*++

Routine Description:

    Sets or resets the cancel routine in a cancellable IRP. We MUST NOT be
    holding the driver spinlock when we call this function - if another thread
    is cancelling an IRP we will deadlock - exactly the reason why we now only
    have a single spinlock for the DLC driver!

Arguments:

    Irp - pointer to cancellable IRP
    Set - TRUE if the cancel routine in the IRP is to be set to DlcCancelIrp
          else the cancel routine is set to NULL (no longer cancellable)

Return Value:

    None.

--*/

{
    KIRQL irql;

    
    IoAcquireCancelSpinLock(&irql);

    if (!Irp->Cancel) {

        IoSetCancelRoutine(Irp, Set ? DlcCancelIrp : NULL);

    }

    IoReleaseCancelSpinLock(irql);
}


VOID
DlcCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is set as the cancel function in all cancellable DLC IRPs -
    TRANSMIT, RECEIVE and READ

    NB: !!! IopCancelSpinLock is held when this function is called !!!

Arguments:

    DeviceObject    - pointer to DEVICE_OBJECT
    Irp             - pointer to IRP being cancelled

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    ULONG command;
    PDLC_FILE_CONTEXT pFileContext;
    PLIST_ENTRY queue;

    IoSetCancelRoutine(Irp, NULL);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    if (DebugCancel) {
        DbgPrint("DlcCancelIrp. IRP @ %08X Type = %08X [%s]\n",
                 Irp,
                 irpStack->Parameters.DeviceIoControl.IoControlCode,
                 MapIoctlCode(irpStack->Parameters.DeviceIoControl.IoControlCode)
                 );
    }
#endif

    pFileContext = irpStack->FileObject->FsContext;
    command = irpStack->Parameters.DeviceIoControl.IoControlCode;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    switch (command) {
    case IOCTL_DLC_READ:
    case IOCTL_DLC_READ2:
        queue = &pFileContext->CommandQueue;
        break;

    case IOCTL_DLC_RECEIVE:
    case IOCTL_DLC_RECEIVE2:
        queue = &pFileContext->ReceiveQueue;
        break;

    case IOCTL_DLC_TRANSMIT:
    case IOCTL_DLC_TRANSMIT2:
        CancelTransmitIrp(Irp, pFileContext);
        queue = NULL;
        break;

    default:

#if DBG
        DbgPrint("DlcCancelIrp: didn't expect to cancel %s: add handler!\n", MapIoctlCode(command));
#endif

        queue = NULL;

    }

    if (queue) {
        CancelCommandIrp(Irp, pFileContext, queue);
    }

    LEAVE_DLC(pFileContext);

    RELEASE_DRIVER_LOCK();

}


VOID
CancelCommandIrp(
    IN PIRP Irp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PLIST_ENTRY Queue
    )

/*++

Routine Description:

    Cancels a pending I/O request. Typically, this will be one of the DLC requests
    which stays pending for a long time e.g. READ or RECEIVE

Arguments:

    Irp             - IRP to cancel
    pFileContext    - file context owning command to cancel
    Queue           - pointer to command queue from which to delete

Return Value:

    None.

--*/

{
    PDLC_COMMAND pCmdPacket;
    PVOID searchHandle;
    BOOLEAN IsReceive;
    USHORT StationId;
    PDLC_OBJECT pAbortedObject = NULL;

#if DBG
    if (DebugCancel) {
        DbgPrint("CancelCommandIrp\n");
    }
#endif

    //
    // the thing to search for is the address of the CCB
    //

    searchHandle = ((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;

    if (((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Ccb.uchDlcCommand == LLC_RECEIVE) {
        StationId = ((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Parms.Receive.usStationId;
        GetStation(pFileContext, StationId, &pAbortedObject);
        IsReceive = TRUE;
    } else {
        IsReceive = FALSE;
    }

    //
    // remove the command info from this file context's command queue
    //

    pCmdPacket = SearchAndRemoveSpecificCommand(Queue, searchHandle);
    if (pCmdPacket) {

        //
        // if we are cancelling a RECEIVE which has a non-NULL data completion
        // flag then we also need to dissociate the receive parameters (the
        // address of the system buffer in the IRP being cancelled)
        //

        if (IsReceive
        && pAbortedObject
        && pCmdPacket->pIrp->AssociatedIrp.SystemBuffer == pAbortedObject->pRcvParms) {
            pAbortedObject->pRcvParms = NULL;
        }

        //
        // increment file context reference count; CompleteAsyncCommand will
        // dereference the file context
        //

        ReferenceFileContext(pFileContext);
        CompleteAsyncCommand(pFileContext,
                             DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION,
                             Irp,
                             NULL,  // pointer for pNext field
                             TRUE   // called on cancel path
                             );

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pCmdPacket);

        DereferenceFileContext(pFileContext);
    } else {

        //
        // race condition?: the command completed before we got chance to cancel it
        //

#if DBG
        DbgPrint("DLC.CancelCommandIrp: Command NOT located. CCB=%08X\n", searchHandle);
#endif

    }
}


VOID
CancelTransmitIrp(
    IN PIRP Irp,
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Cancels a pending transmit command. We are only interested in I-Frame
    transmit requests since these only complete when a corresponding ACK is
    received from the remote station. U-Frame transmissions don't get retried
    so will normally complete virtually immediately

	This routine currently does nothing in the retail version, and just
	complains about things in the debug version.

	Cancel transmit is not defined in the IBM LAN Reference, nor is it
	defined for NT DLC.  This is only called by the IO subsystem when
	somebody terminates a thread or process with outstanding IO requests
	that include a DLC transmit request.

	For application termination, this is not really a problem since eventually
	the termination process will close the application's FileContext(s) and
	all SAPs, link stations, etc. belonging to the application will get closed
	down anyway.

	For thread termination, it is a real problem if an application abandons
	a transmit (usually Transmit I-Frame) by closing the thread that
	requested the transmit.  DLC has no defined course of action to toss
	the transmit, without changing the associated link station state.  This
	happened with hpmon.dll when the remote station (printer) got jammed
	and sent Receiver Not Ready in response to attempts to give it the
	frame.  When something like this happens, it is up to the application
	to reset or close the link station, or wait, and not rely on thread
	termination to do the right thing here (because it won't).

Arguments:

    Irp             - pointer to IRP to cancel
    pFileContext    - pointer to owning file context

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PNT_DLC_CCB pCcb;

#if DBG

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    pCcb = &((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Ccb;

#endif

#if DBG

    DbgPrint("DLC.CancelTransmitIrp: Cancel %s not supported! CCB %08X\n",
             pCcb->uchDlcCommand == LLC_TRANSMIT_FRAMES ? "TRANSMIT_FRAMES"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_DIR_FRAME ? "TRANSMIT_DIR_FRAME"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_UI_FRAME ? "TRANSMIT_UI_FRAME"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_XID_CMD ? "TRANSMIT_XID_CMD"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_XID_RESP_FINAL ? "TRANSMIT_XID_RESP_FINAL"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_XID_RESP_NOT_FINAL ? "TRANSMIT_XID_RESP_NOT_FINAL"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_TEST_CMD ? "TRANSMIT_TEST_CMD"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_I_FRAME ? "TRANSMIT_I_FRAME"
             : "UNKNOWN TRANSMIT COMMAND!",
             pCcb
             );

	ASSERT ( pCcb->uchDlcCommand != LLC_TRANSMIT_I_FRAME );

#endif

}

#if DBG
PSTR MapIoctlCode(ULONG IoctlCode) {
    switch (IoctlCode) {
    case IOCTL_DLC_READ:
        return "READ";

    case IOCTL_DLC_RECEIVE:
        return "RECEIVE";

    case IOCTL_DLC_TRANSMIT:
        return "TRANSMIT";

    case IOCTL_DLC_BUFFER_FREE:
        return "BUFFER_FREE";

    case IOCTL_DLC_BUFFER_GET:
        return "BUFFER_GET";

    case IOCTL_DLC_BUFFER_CREATE:
        return "BUFFER_CREATE";

    case IOCTL_DLC_SET_EXCEPTION_FLAGS:
        return "SET_EXCEPTION_FLAGS";

    case IOCTL_DLC_CLOSE_STATION:
        return "CLOSE_STATION";

    case IOCTL_DLC_CONNECT_STATION:
        return "CONNECT_STATION";

    case IOCTL_DLC_FLOW_CONTROL:
        return "FLOW_CONTROL";

    case IOCTL_DLC_OPEN_STATION:
        return "OPEN_STATION";

    case IOCTL_DLC_RESET:
        return "RESET";

    case IOCTL_DLC_READ_CANCEL:
        return "READ_CANCEL";

    case IOCTL_DLC_RECEIVE_CANCEL:
        return "RECEIVE_CANCEL";

    case IOCTL_DLC_QUERY_INFORMATION:
        return "QUERY_INFORMATION";

    case IOCTL_DLC_SET_INFORMATION:
        return "SET_INFORMATION";

    case IOCTL_DLC_TIMER_CANCEL:
        return "TIMER_CANCEL";

    case IOCTL_DLC_TIMER_CANCEL_GROUP:
        return "TIMER_CANCEL_GROUP";

    case IOCTL_DLC_TIMER_SET:
        return "TIMER_SET";

    case IOCTL_DLC_OPEN_SAP:
        return "OPEN_SAP";

    case IOCTL_DLC_CLOSE_SAP:
        return "CLOSE_SAP";

    case IOCTL_DLC_OPEN_DIRECT:
        return "OPEN_DIRECT";

    case IOCTL_DLC_CLOSE_DIRECT:
        return "CLOSE_DIRECT";

    case IOCTL_DLC_OPEN_ADAPTER:
        return "OPEN_ADAPTER";

    case IOCTL_DLC_CLOSE_ADAPTER:
        return "CLOSE_ADAPTER";

    case IOCTL_DLC_REALLOCTE_STATION:
        return "REALLOCTE_STATION";

    case IOCTL_DLC_READ2:
        return "READ2";

    case IOCTL_DLC_RECEIVE2:
        return "RECEIVE2";

    case IOCTL_DLC_TRANSMIT2:
        return "TRANSMIT2";

    case IOCTL_DLC_COMPLETE_COMMAND:
        return "COMPLETE_COMMAND";

    case IOCTL_DLC_TRACE_INITIALIZE:
        return "TRACE_INITIALIZE";

    }
    return "*** UNKNOWN IOCTL CODE ***";
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcindc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcindc.c

Abstract:

    This module includes primitives to handle all events
    and indications from the LLC (802.2 data link) module.

    Contents:
        LlcReceiveIndication
        LlcEventIndication
        LlcCommandCompletion
        CompleteTransmitCommand
        CompleteDlcCommand

Author:

    Antti Saarenheimo 01-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

//
// This define enables the private DLC function prototypes
// We don't want to export our data types to the llc layer.
// MIPS compiler doesn't accept hiding of the internal data
// structures by a PVOID in the function prototype.
// i386 will check the type defines
//

#ifndef i386
#define DLC_PRIVATE_PROTOTYPES
#endif
#include <dlc.h>
#include <smbgtpt.h>

#if 0

//
// if DLC and LLC share the same driver then we can use macros to access fields
// in the BINDING_CONTEXT and ADAPTER_CONTEXT structures
//

#if DLC_AND_LLC
#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include "llcdef.h"
#include "llctyp.h"
#include "llcapi.h"
#endif
#endif

//
// Table includes all llc header length of different frame types
//

static UCHAR aDlcHeaderLengths[LLC_LAST_FRAME_TYPE / 2] = {
    0,  // DLC_UNDEFINED_FRAME_TYPE = 0,
    0,  // DLC_MAC_FRAME = 0x02,
    4,  // DLC_I_FRAME = 0x04,
    3,  // DLC_UI_FRAME = 0x06,
    3,  // DLC_XID_COMMAND_POLL = 0x08,
    3,  // DLC_XID_COMMAND_NOT_POLL = 0x0a,
    3,  // DLC_XID_RESPONSE_FINAL = 0x0c,
    3,  // DLC_XID_RESPONSE_NOT_FINAL = 0x0e,
    3,  // DLC_TEST_RESPONSE_FINAL = 0x10,
    3,  // DLC_TEST_RESPONSE_NOT_FINAL = 0x12,
    0,  // DLC_DIRECT_8022 = 0x14,
    3,  // DLC_TEST_COMMAND = 0x16,
    0   // DLC_DIRECT_ETHERNET_TYPE = 0x18
};


DLC_STATUS
LlcReceiveIndication(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PUCHAR pLookBuf,
    IN UINT cbPacketSize
    )

/*++

Routine Description:

    The primitive handles the receive data indication from
    the lower level
    the returned parameter block of the read command.

    IBM has successfully made the receive extremly complicated.
    We can distinguish at least four different ways to gather the
    receive information to the frame header, when we have received
    an I- frame for a link station:

    1. Rcv command for link station, frames linked in link basis
        - user length and read options from link object
        - receive buffer base in link object
        - station information from link object

    2. Rcv command for link station, frames linked in sap bases
        - user length and read options from link object
        - receive buffer base in sap object
        - station information from link object

    3. Rcv command only for sap station, frames linked in link basis
        - user length and read options from sap object
        - receive buffer base in link object
        - station information from link object

    4. Rcv command only for sap station, frames linked in sap basis
        - user length and read options from sap object
        - receive buffer base in sap object
        - station information from link object

    =>  We have three different DLC objects in receive:

    1. The orginal destination of the frame, we will read station id
       from that object.
    2. The owner of the receive, the read command must match to the
       station id of the events owner.  The owner also chains the
       the received data in its frame list.
    3. Receive object: the receive object defines the recieve options
       saved to the frame header and the read flag saved to the read
       parameters.

    At least two objects are same (the different ones in different cases),
    and in most cases all objects are the same dlc object.

    We will need to save these in rcv event:
    -  The owner dlc object
    -  Pointer to linked frame header list or to a single frame
       (defined by the receive read option in the next object).
       We can directly use the owner object, because the frames
       need to be chained.  In that case we must save directly the
       reference of the buffer header.
    -  The receive object,  the dlc object having a pending receive,
       that was used to received this event.

Arguments:

    pFileContext    - the device context of this DLC client
    pDlcObject      - the DLC client, that received the event.
    FrameType       - current frame type
    pLookBuf        - points to the data from the LLC header (ie. excludes the
                      LAN header). MAY NOT CONTAIN ALL DATA
    cbPacketSize    - amount of data to copy, including DLC header, but not
                      including LLC header

Return Value:

    DLC_STATUS:

--*/

{
    PDLC_OBJECT pRcvObject = pDlcObject;
    PDLC_OBJECT pOwnerObject;
    PDLC_BUFFER_HEADER pBufferHeader;
    DLC_STATUS Status = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    UINT uiLlcOffset;
    UINT FrameHeaderSize;
    UINT LlcLength;
    PDLC_EVENT pRcvEvent;
    UINT DataSize;
    PFIRST_DLC_SEGMENT pFirstBuffer;
    PDLC_COMMAND pDlcCommand;
    UINT BufferSizeLeft;

    //
    // this function is called in the context of a DPC: it is the receive data
    // indication from NDIS
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('D');

    if (pFileContext->State != DLC_FILE_CONTEXT_OPEN) {
        return DLC_STATUS_ADAPTER_CLOSED;
    }

    ENTER_DLC(pFileContext);

#if LLC_DBG

    if (pDlcObject->State > DLC_OBJECT_CLOSED) {
       DbgPrint("Invalid object type!");
       DbgBreakPoint();
    }

#endif

    //
    // Search the first object having a pending receive, loop
    // the link, the sap and the direct station until we find one.
    //

    while (pRcvObject != NULL && pRcvObject->pRcvParms == NULL) {
        if (pRcvObject->Type == DLC_LINK_OBJECT) {
            pRcvObject = pRcvObject->u.Link.pSap;
        } else if (pRcvObject->Type == DLC_SAP_OBJECT) {
            pRcvObject = pFileContext->SapStationTable[0];
        } else if (pRcvObject->Type == DLC_DIRECT_OBJECT) {
            pRcvObject = NULL;
        }
    }

    //
    // return error status if we cannot find any receive command.
    //

    if (pRcvObject == NULL) {
        Status = DLC_STATUS_NO_RECEIVE_COMMAND;

//#if DBG
//        DbgPrint("DLC.LlcReceiveIndication.%d: Error: No receive command\n", __LINE__);
//#endif

        goto ErrorExit;
    }

    //
    // Now we must figure out the actual owner of the received frame.
    // There are actually only two special cases:
    //

    if (pRcvObject->pRcvParms->Async.Parms.Receive.uchRcvReadOption == LLC_RCV_CHAIN_FRAMES_ON_LINK
    && pRcvObject->Type == DLC_SAP_OBJECT) {
        pOwnerObject = pDlcObject;
    } else if (pRcvObject->pRcvParms->Async.Parms.Receive.uchRcvReadOption == LLC_RCV_CHAIN_FRAMES_ON_SAP
    && pRcvObject->Type == DLC_LINK_OBJECT) {
        pOwnerObject = pRcvObject->u.Link.pSap;
    } else {

        //
        // In all other cases we chain the frames to the receive object
        // (actually IBM has not defined the case), the frames are
        // chained for direct if the rcv read option is set chaining for
        // sap or link station
        //

        pOwnerObject = pRcvObject;

        //
        // direct station can recieve only the frame
        // types defined by station id of the receive command
        // There are three types, we need to check the one, that does not work:
        //
        //      DLC_DIRECT_ALL_FRAMES       0
        //      DLC_DIRECT_MAC_FRAMES       1
        //      DLC_DIRECT_NON_MAC_FRAMES   2
        //

        if (pRcvObject->Type == DLC_DIRECT_OBJECT) {
            if (FrameType == LLC_DIRECT_MAC) {
                if (pRcvObject->pRcvParms->Async.Parms.Receive.usStationId == LLC_DIRECT_8022) {
                    Status = DLC_STATUS_NO_RECEIVE_COMMAND;
                    goto ErrorExit;
                }
            } else {

                //
                // It must be a non-MAC frame
                //

                if (pRcvObject->pRcvParms->Async.Parms.Receive.usStationId == LLC_DIRECT_MAC) {
                    Status = DLC_STATUS_NO_RECEIVE_COMMAND;
                    goto ErrorExit;
                }
            }
        }
    }

    //
    // The frame length must be known when the buffers are allocated,
    // This may not be the same as the actual length of the received
    // LAN header (if we received a DIX frame)
    //

    uiLlcOffset = LlcGetReceivedLanHeaderLength(pFileContext->pBindingContext);

    //
    // Check first the buffer type (contiguous or non contiguous),
    // and then allocate it.
    // Note: WE DO NOT SUPPORT THE BREAK OPTION (because it would make
    // the current buffer management even more complicated)
    //

    LlcLength = aDlcHeaderLengths[FrameType / 2];

    //
    // DIX frames are a special case: they must be filtered
    // (DIX Llc header == ethernet type word is always 2 bytes,
    // nobody else use this llc type size).
    // A DIX application may define an offset, mask and match to
    // filter only those frames it is really needing.
    // This method works very well with XNS and TCP socket types
    //

	if ( LlcLength > cbPacketSize ) {
		Status = DLC_STATUS_INVALID_FRAME_LENGTH;
        goto ErrorExit;
	}

    if ((FrameType == LLC_DIRECT_ETHERNET_TYPE)
    && (pDlcObject->u.Direct.ProtocolTypeMask != 0)) {

        ULONG ProtocolType;

        //
        // there's a real good possibility here that if the app supplies a very
        // large value for the protocol offset, we will blow up - there's no
        // range checking performed!
        //

        ASSERT(pDlcObject->u.Direct.ProtocolTypeOffset >= 14);

        //
        // let's add that range check: if the protocol offset is before the
        // data part of the frame or past the end of this particular frame
        // then we say there's no receive defined for this frame
        //

        if ((pDlcObject->u.Direct.ProtocolTypeOffset < 14)
        || (pDlcObject->u.Direct.ProtocolTypeOffset > cbPacketSize + 10)) {
            return DLC_STATUS_NO_RECEIVE_COMMAND;
        }

        //
        // the offset to the protocol type field is given as offset from the
        // start of the frame: we only get to look in the lookahead buffer,
        // but we know that since this is an ethernet frame, the lookahead
        // buffer starts 14 bytes into the frame, so remove this length from
        // the protocol offset
        //

        ProtocolType = SmbGetUlong(&pLookBuf[pDlcObject->u.Direct.ProtocolTypeOffset - 14]);

        if ((ProtocolType & pDlcObject->u.Direct.ProtocolTypeMask) != pDlcObject->u.Direct.ProtocolTypeMatch) {
            return DLC_STATUS_NO_RECEIVE_COMMAND;
        }
    }

    //
    // The created MDL must not include the LAN header because it is not copied
    // by LlcTransferData. We use a temporary frame header size to allocate space
    // for the LAN header. The LLC header will be copied just as any other data
    //

    if (FrameType == LLC_DIRECT_MAC) {
        if (pRcvObject->pRcvParms->Async.Parms.Receive.uchOptions & DLC_CONTIGUOUS_MAC) {
            FrameHeaderSize = sizeof(DLC_CONTIGUOUS_RECEIVE) + uiLlcOffset;
            DataSize = cbPacketSize;
        } else {
            FrameHeaderSize = sizeof(DLC_NOT_CONTIGUOUS_RECEIVE);
            DataSize = cbPacketSize - LlcLength;
        }
    } else {
        if (pRcvObject->pRcvParms->Async.Parms.Receive.uchOptions & DLC_CONTIGUOUS_DATA) {
            FrameHeaderSize = sizeof(DLC_CONTIGUOUS_RECEIVE) + uiLlcOffset;
            DataSize = cbPacketSize;
        } else {
            FrameHeaderSize = sizeof(DLC_NOT_CONTIGUOUS_RECEIVE);
            DataSize = cbPacketSize - LlcLength;
        }
    }

    pBufferHeader = NULL;
    NtStatus = BufferPoolAllocate(
#if DBG
                pFileContext,
#endif
                pFileContext->hBufferPool,
                DataSize,                       // size of actual MDL buffers
                FrameHeaderSize,                // frame hdr (and possibly lan hdr)
                pRcvObject->pRcvParms->Async.Parms.Receive.usUserLength,
                cbPacketSize + uiLlcOffset,     // size of the packet
                (UINT)(-1),                     // any size is OK.
                &pBufferHeader,                 // returned buffer pointer
                &BufferSizeLeft
                );
    if (NtStatus != STATUS_SUCCESS) {
        if (FrameType != LLC_I_FRAME) {

            //
            // We must complete the receive with the given error status,
            // if this frame is not a I- frame.  (I-frames can be dropped
            // to the floor, the other frames completes the receive with
            // an error status)
            // -----------------------------------------------
            // We should not complete commands in receive lookahead.
            // The correct way could be to queue this somehow in
            // data link and process this, when the command is completed
            // in the command completion indication.
            // On the other hand, NBF DOES THIS FOR EVERY IRP!
            //

            pDlcCommand = SearchAndRemoveCommandByHandle(
                            &pFileContext->ReceiveQueue,
                            (ULONG)-1,
                            (USHORT)DLC_IGNORE_STATION_ID,
                            (USHORT)DLC_STATION_MASK_SPECIFIC,
                            pRcvObject->pRcvParms->Async.Ccb.pCcbAddress
                            );

            //
            // RLF 11/24/92
            //
            // if pDlcCommand is NULL then check the command queue - this may
            // be a receive without a RECEIVE_FLAG parameter
            //

            if (!pDlcCommand) {
                pDlcCommand = SearchAndRemoveCommandByHandle(
                                &pFileContext->CommandQueue,
                                (ULONG)-1,
                                (USHORT)DLC_IGNORE_STATION_ID,
                                (USHORT)DLC_STATION_MASK_SPECIFIC,
                                pRcvObject->pRcvParms->Async.Ccb.pCcbAddress
                                );
                ASSERT(pDlcCommand);
            }

            pRcvObject->pRcvParms = NULL;

#if LLC_DBG

            DbgPrint("cFramesReceived: %x\n", cFramesReceived);
            DbgPrint("cFramesIndicated: %x\n", cFramesIndicated);
            DbgPrint("cFramesReleased: %x\n", cFramesReleased);

            if (pDlcCommand == NULL) {
                DbgPrint("Lost receive command???");
            } else

#endif

            CompleteDlcCommand(pFileContext,
                               pRcvObject->StationId,
                               pDlcCommand,
                               DLC_STATUS_LOST_DATA_NO_BUFFERS
                               );
        }

        //
        // Free the partial buffer
        //

        BufferPoolDeallocateList(pFileContext->hBufferPool, pBufferHeader);

//#if DBG
//        DbgPrint("DLC.LlcReceiveIndication.%d: Error: Out of receive buffers\n", __LINE__);
//#endif

        Status = DLC_STATUS_OUT_OF_RCV_BUFFERS;
        goto ErrorExit;
    }

    //
    // A link station may have committed memory from the buffer pool
    // when it local busy state was enabled after a local busy state
    // because of 'out of receive buffers'.  We must uncommit all
    // packets received by that link station until the size of
    // the commited buffer space is zero
    //

    if (pDlcObject->CommittedBufferSpace != 0) {

        ULONG UncommittedBufferSpace;

        //
        // get the smaller
        //

        UncommittedBufferSpace = (pDlcObject->CommittedBufferSpace < BufGetPacketSize(cbPacketSize)
                               ? pDlcObject->CommittedBufferSpace
                               : BufGetPacketSize(cbPacketSize));

        pDlcObject->CommittedBufferSpace -= UncommittedBufferSpace;
        BufUncommitBuffers(pFileContext->hBufferPool, UncommittedBufferSpace);
    }

    //
    // By default this is linked only to itself.
    // We must create a event information every time,
    // because app might read the old chained frames
    // just between TransferData and its confirmation.
    // => we cannot chain frames before TransmitData is confirmed.
    // We should not either save any pointers to other objects,
    // because they might disappear before the confirm
    // (we use the pending transmit count to prevent OwnerObject
    // to disappear before the confirm)
    //

    pBufferHeader->FrameBuffer.pNextFrame = pBufferHeader;

    pRcvEvent = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pRcvEvent == NULL) {
        Status = DLC_STATUS_NO_MEMORY;
        BufferPoolDeallocateList(pFileContext->hBufferPool, pBufferHeader);

#if DBG
        DbgPrint("DLC.LlcReceiveIndication.%d: Error: Out of memory\n", __LINE__);
#endif

        goto ErrorExit;
    }

    pRcvEvent->Event = LLC_RECEIVE_DATA;
    pRcvEvent->StationId = pOwnerObject->StationId;
    pRcvEvent->pOwnerObject = pOwnerObject;
    pRcvEvent->Overlay.RcvReadOption = pRcvObject->pRcvParms->Async.Parms.Receive.uchRcvReadOption;
    pRcvEvent->SecondaryInfo = pRcvObject->pRcvParms->Async.Parms.Receive.ulReceiveFlag;
    pRcvEvent->pEventInformation = pBufferHeader;
    pOwnerObject->PendingLlcRequests++;

    pFirstBuffer = (PFIRST_DLC_SEGMENT)
        ((PUCHAR)pBufferHeader->FrameBuffer.pParent->Header.pGlobalVa
        + MIN_DLC_BUFFER_SEGMENT * pBufferHeader->FrameBuffer.Index);

    pFirstBuffer->Cont.Options = pRcvObject->pRcvParms->Async.Parms.Receive.uchOptions;
    pFirstBuffer->Cont.MessageType = (UCHAR)FrameType;
    pFirstBuffer->Cont.BuffersLeft = (USHORT)(BufferPoolCount(pFileContext->hBufferPool));
    pFirstBuffer->Cont.RcvFs = 0xCC;
    pFirstBuffer->Cont.AdapterNumber = pFileContext->AdapterNumber;
    pFirstBuffer->Cont.pNextFrame = NULL;
    pFirstBuffer->Cont.StationId = pDlcObject->StationId;

    //
    // A receive command without read flag is used only once.
    // The receive completion will complete also the receive command
    //

    if (pRcvObject->pRcvParms->Async.Parms.Receive.ulReceiveFlag == 0) {
        pRcvObject->pRcvParms = NULL;
    }

    //
    // copy NOT_CONTIGUOUS or CONTIGUOUS frame header to beginning of buffer
    //

    if (FrameHeaderSize == sizeof(DLC_NOT_CONTIGUOUS_RECEIVE)) {
        pFirstBuffer->Cont.UserOffset = sizeof(DLC_NOT_CONTIGUOUS_RECEIVE);
        LlcCopyReceivedLanHeader(pFileContext->pBindingContext,
                                 pFirstBuffer->NotCont.LanHeader,
                                 NULL
                                 );
        pFirstBuffer->NotCont.LanHeaderLength = (UCHAR)uiLlcOffset;
        if (FrameType != LLC_DIRECT_ETHERNET_TYPE) {
            pFirstBuffer->NotCont.DlcHeaderLength = (UCHAR)LlcLength;
            LlcMemCpy((PCHAR)pFirstBuffer->NotCont.DlcHeader,
                      (PCHAR)pLookBuf,
                      LlcLength
                      );
        } else {

            USHORT ethernetType = LlcGetEthernetType(pFileContext->pBindingContext);
            UCHAR byte = ethernetType & 0xff;

            pFirstBuffer->NotCont.DlcHeaderLength = 2;
            ethernetType >>= 8;
            ethernetType |= ((USHORT)byte) << 8;
            *(PUSHORT)&pFirstBuffer->NotCont.DlcHeader = ethernetType;
            LlcLength = 0;
        }
    } else {

        //
        // We have included the LAN header size in the frame header size to
        // make room for this copy, but now we fix the UserOffset and everything
        // should be OK
        //

        LlcLength = 0;
        pFirstBuffer->Cont.UserOffset = sizeof(DLC_CONTIGUOUS_RECEIVE);
        LlcCopyReceivedLanHeader(pFileContext->pBindingContext,
                                 (PCHAR)pFirstBuffer
                                    + sizeof(DLC_CONTIGUOUS_RECEIVE)
                                    + pFirstBuffer->Cont.UserLength,
                                 NULL
                                 );
    }

#if LLC_DBG
    cFramesReceived++;
#endif

    //
    // Save the event only if this is the first chained frame.
    // The sequential received frames will be queued behind it.
    //

    LEAVE_DLC(pFileContext);

    RELEASE_DRIVER_LOCK();

    LlcTransferData(
        pFileContext->pBindingContext,      // data link adapter context
		MacReceiveContext,
        &(pRcvEvent->LlcPacket),            // receive packet
        pBufferHeader->FrameBuffer.pMdl,    // destination mdl
        LlcLength,                          // offset in LookBuf to copy from
        cbPacketSize - LlcLength            // length of copied data
        );

    ACQUIRE_DRIVER_LOCK();

    //
    // Transfer data returns always a pending status,
    // the success/error status is returned asynchronously
    // in the the receive indication completion (really?)
    // We should copy the whole frame here, if is visiable
    // in the receive lookahead buffer.
    //

    return STATUS_SUCCESS;

ErrorExit:

    LEAVE_DLC(pFileContext);

    //
    // The receive status is very important for I- frames,
    // because  the llc driver set the link busy when we return
    // DLC_STATUS_NO_RECEIVE_COMMAND or DLC_STATUS_OUT_OF_RCV_BUFFERS.
    //

    if (Status == DLC_STATUS_NO_MEMORY) {
        Status = DLC_STATUS_OUT_OF_RCV_BUFFERS;
    }

    return Status;
}


VOID
LlcEventIndication(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PVOID hEventObject,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    )

/*++

Routine Description:

    The primitive handles all LLC and NDIS events
    and translates them to DLC events, that are either immediately
    executed by a pending (and matching) read command or
    they are queued to the event queue.
    LLC cannot provide any packet with these events, beacuse they
    were not initiated by the protocol, but they just happened
    asynchronously in the data link driver.

    Special:

    This routine must not call back the data link driver, if has
    gon any other DLC status indication except INDICATE_CONNECT_REQUEST
    (that may be closed by DLC, if there are no available station ids
    on the sap).

Arguments:

    pFileContext            - DLC object handle or a file context of the event
    hEventObject            - DLC object handle or a file context of the event
    Event                   - LLC event code. Usually it can be used directly as
                              a DLC event code
    pEventInformation       - information to DLC status change block
                              (or another pointer to some misc information)
    SecondaryInformation    - dword information used by some NDIS errors

Return Value:

    None.

--*/

{
    PDLC_OBJECT pDlcObject;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('E');

    if (pFileContext->State != DLC_FILE_CONTEXT_OPEN) {
        return;
    }

    ENTER_DLC(pFileContext);

    //
    // DLC status and NDIS adapter status events have different parameters,
    // => we cannot do any common preprocessing for them.
    //

    switch (Event) {
    case LLC_STATUS_CHANGE_ON_SAP:
        Event = LLC_STATUS_CHANGE;

    case LLC_STATUS_CHANGE:
        pDlcObject = (PDLC_OBJECT)hEventObject;

#if LLC_DBG

        if (pDlcObject != NULL && pDlcObject->State > DLC_OBJECT_CLOSED) {
            DbgPrint("Invalid object type!");
            DbgBreakPoint();
        }

#endif

        //
        // We must create a DLC driver object, if a
        // connect request has created a new link station
        // in the data link driver.
        //

        if (SecondaryInfo & INDICATE_CONNECT_REQUEST) {

            //
            // Create the DLC driver object, if remote connection
            // request created a new link station on LLC.
            // The connect request may be done as well for
            // a disconnected station.
            //

            if (pDlcObject->Type == DLC_SAP_OBJECT) {

                NTSTATUS Status;

                Status = InitializeLinkStation(
                            pFileContext,
                            pDlcObject,     // Sap station id
                            NULL,
                            ((PDLC_STATUS_TABLE)pEventInformation)->hLlcLinkStation,
                            &pDlcObject     // NEW Link station id
                            );
                if (Status != STATUS_SUCCESS) {

                    //
                    // This client has all its available link stations
                    // reserved or we are simply run out of memory.
                    // Several LLC clients may share the same SAP.
                    // All remote connections are handled by the
                    // first client registered on the sap
                    // until it runs out of available link stations.
                    // LlcCloseStation for a link indicating connect request
                    // will redirect the connection request to the next
                    // possible LLC client having opened the same sap or
                    // deletes the link station, if there are no clients left
                    //

                    LEAVE_DLC(pFileContext);

                    LlcCloseStation(
                        ((PDLC_STATUS_TABLE)pEventInformation)->hLlcLinkStation,
                        NULL
                        );

                    ENTER_DLC(pFileContext);

                    break;          // We have done it
                }
            }
        }

        //
        // The remotely created link station may send also other indications
        // than Connect, even if there is not yet a link station object
        // created in DLC driver. We must skip all those events.
        //

        if (pDlcObject->Type == DLC_LINK_OBJECT) {

            PDLC_EVENT pDlcEvent = pDlcObject->u.Link.pStatusEvent;

            pDlcEvent->Event = Event;
            pDlcEvent->StationId = pDlcObject->StationId;
            pDlcEvent->pOwnerObject = pDlcObject;
            pDlcEvent->pEventInformation = pEventInformation;
            pDlcEvent->SecondaryInfo |= SecondaryInfo;

            //
            // The next pointer is reset whenever the status event
            // packet is read and disconnected from the event queue.
            //

            if (pDlcEvent->LlcPacket.pNext == NULL) {
                QueueDlcEvent(pFileContext, (PDLC_PACKET)pDlcEvent);
            }
        }
        break;

    case NDIS_STATUS_RING_STATUS:

		ASSERT ( IS_NDIS_RING_STATUS(SecondaryInfo) );

        //
        // The secondary information is directly the
        // the network statys code as defined for
        // ibm token-ring and dlc api!
        //

        Event = LLC_NETWORK_STATUS;

        //
        // This event should go to all READ having defined the
        // the network status flag!
        //

        MakeDlcEvent(pFileContext,
                     Event,
                     (USHORT)(-1),
                     NULL,
                     pEventInformation,
                     NDIS_RING_STATUS_TO_DLC_RING_STATUS(SecondaryInfo),
                     FALSE
                     );
        break;

    case NDIS_STATUS_CLOSED:

        //
        // NDIS status closed is given only when the network
        // administrator is for some reason unloading NDIS.
        // Thus we must always return the 'System Action' error
        // code ('04') with LLC_CRITICAL_ERROR, but
        // we will add it later when all stations has been closed.
        //

        if (pFileContext->State != DLC_FILE_CONTEXT_CLOSED) {
            pFileContext->State = DLC_FILE_CONTEXT_CLOSED;
            CloseAllStations(
                pFileContext,
                NULL,                  // we don't have any command to complete
                LLC_CRITICAL_EXCEPTION,
                NULL,
                NULL,
                &pFileContext->ClosingPacket
                );
        }
        break;

    case LLC_TIMER_TICK_EVENT:

        //
        // This flag is used to limit the number of the failing expand
        // operations for the buffer pool.  We don't try to do it again
        // for a while, if we cannot lock memory.
        //

        MemoryLockFailed = FALSE;

        //
        // We free the extra locked pages in the buffer pool once
        // in five seconds. The unlocking takes some time, and we
        // don't want to do it whenever a read command is executed
        // (as we do with the expanding)
        //

        pFileContext->TimerTickCounter++;
        if ((pFileContext->TimerTickCounter % 10) == 0 && pFileContext->hBufferPool != NULL) {
            BufferPoolFreeExtraPages(
#if DBG
                                     pFileContext,
#endif
                                     (PDLC_BUFFER_POOL)pFileContext->hBufferPool
                                     );
        }

        //
        // Decrement the tick count of the first object in the timer queue
        // (if there is any) and complete its all sequential commands
        // having zero tickout.
        //

        if (pFileContext->pTimerQueue != NULL) {
            pFileContext->pTimerQueue->Overlay.TimerTicks--;

            while (pFileContext->pTimerQueue != NULL
            && pFileContext->pTimerQueue->Overlay.TimerTicks == 0) {

                PDLC_COMMAND pCommand;

                pCommand = pFileContext->pTimerQueue;
                pFileContext->pTimerQueue = (PDLC_COMMAND)pCommand->LlcPacket.pNext;

#if LLC_DBG

                pCommand->LlcPacket.pNext = NULL;

#endif

                CompleteDlcCommand(pFileContext, 0, pCommand, STATUS_SUCCESS);
            }
        }
        break;

#if LLC_DBG

    default:
        LlcInvalidObjectType();
        break;

#endif

    }

    LEAVE_DLC(pFileContext);
}


VOID
LlcCommandCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine completes the asynchronous DLC operations: Transmit,
    TransferData (for receive), LlcConnect and LlcDisconnect.

Arguments:

    pFileContext    - DLC process and adapter specific file context
    pDlcObject      - the object, that was assosiated with the command
    pPacket         - packet assosiated with the command

Return Value:

    None

--*/

{
    PDLC_PACKET pRootNode;
    UINT Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('B');

    Status = (UINT)pPacket->LlcPacket.Data.Completion.Status;

    ENTER_DLC(pFileContext);

#if LLC_DBG

    if (pDlcObject != NULL && pDlcObject->State > DLC_OBJECT_CLOSED) {
        DbgPrint("Invalid object type!");
        DbgBreakPoint();
    }

#endif

    switch (pPacket->LlcPacket.Data.Completion.CompletedCommand) {
    case LLC_RECEIVE_COMPLETION:

        //
        // The receiving object may be different from the
        // actual object given by data link.
        // (this case should be moved to a subprocedure, that would
        // be called directly from the receive data handler, if
        // TransferData is executed synchronously (it always does it).
        // That would save at least 100 instructions.)
        //

        DLC_TRACE('h');

        pDlcObject = pPacket->Event.pOwnerObject;
        pDlcObject->PendingLlcRequests--;

        if (Status != STATUS_SUCCESS || pDlcObject->State != DLC_OBJECT_OPEN) {

            //
            // We must free the receive buffers, the packet
            // will be deallocated in the end of this procedure.
            //

            BufferPoolDeallocateList(pFileContext->hBufferPool,
                                     pPacket->Event.pEventInformation
                                     );

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

        } else {
            if (pPacket->Event.Overlay.RcvReadOption != LLC_RCV_READ_INDIVIDUAL_FRAMES) {

                //
                // The received frames must be chained,
                // add the new buffer header to the old
                // link list if there is any,  The buffers
                // are saved to a circular link list to make
                // possible to build easily the final link list in
                // application address space.
                //

                if (pDlcObject->pReceiveEvent != NULL) {

                    //
                    // new: pPacket->Event.pEventInformation
                    // base: pDlcObject->pReceiveEvent->pEventInformation
                    // Operations when a new element is added to base:
                    //

                    //
                    // 1. new->next = base->next
                    //

                    ((PDLC_BUFFER_HEADER)pPacket->Event.pEventInformation)->FrameBuffer.pNextFrame
                        = ((PDLC_BUFFER_HEADER)pDlcObject->pReceiveEvent->pEventInformation)->FrameBuffer.pNextFrame;

                    //
                    // 2. base->next = new
                    //

                    ((PDLC_BUFFER_HEADER)pDlcObject->pReceiveEvent->pEventInformation)->FrameBuffer.pNextFrame
                        = (PDLC_BUFFER_HEADER)pPacket->Event.pEventInformation;

                    //
                    // 3. base = new
                    //

                    pDlcObject->pReceiveEvent->pEventInformation = pPacket->Event.pEventInformation;

                    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

                    //
                    // This event is already queued =>
                    // we may leave this procedure
                    //

                    break;          // **********  EXIT ************
                } else {
                    pDlcObject->pReceiveEvent = &pPacket->Event;
                }
            }

            //
            // All receives are events.  The event is handled immediately
            // if there is a pending command in the command queue,
            // otherwise the command is queued to the event queue to be
            // read by a command issued later.
            //

            pPacket->Event.Overlay.StationIdMask = (USHORT)(-1);
            QueueDlcEvent(pFileContext, pPacket);
        }
        break;

    case LLC_SEND_COMPLETION:

        //
        // We first free or/and unlock all buffers, that
        // were used in the transmit of this frame.
        //

        DLC_TRACE('i');

        BufferPoolFreeXmitBuffers(pFileContext->hBufferPool, pPacket);

        //
        // Reset the local busy states, if there is now enough
        // buffers the receive the expected stuff for a link station.
        //

        if (!IsListEmpty(&pFileContext->FlowControlQueue)
        && pFileContext->hBufferPool != NULL
        && BufGetUncommittedSpace(pFileContext->hBufferPool) >= 0) {
            ResetLocalBusyBufferStates(pFileContext);
        }

        //
        // This code completes a transmit command.
        // It releases all resources allocated for the transmit
        // and completes the command, if this was the last
        // transmit associated with it.
        // Note:
        // Single transmit command may consists of several frames.
        // We must wait until all NDIS send requests have been completed
        // before we can complete the command. That's why the first transmit
        // node is also a root node.  All transmit nodes have a reference
        // to the root node.
        // (why we incrment/decrement the object reference count separately
        // for each frame,  we could do it only once for a transmit command).
        //

        pDlcObject->PendingLlcRequests--;
        pRootNode = pPacket->Node.pTransmitNode;

        //
        // Don't delete root node packet, we will need it to queue the
        // command completion (if the command completion flag is used)
        //

        if (pPacket != pRootNode) {

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

        }

        //
        // We will save and keep the first asynchronous error status
        //

        if (Status != STATUS_SUCCESS && pRootNode->Node.pIrp->IoStatus.Status == STATUS_SUCCESS) {
            pRootNode->Node.pIrp->IoStatus.Status = Status;
        }

        pRootNode->Node.FrameCount--;
        if (pRootNode->Node.FrameCount == 0) {
            CompleteTransmitCommand(pFileContext,
                                    pRootNode->Node.pIrp,
                                    pDlcObject,
                                    pRootNode
                                    );
        }
        break;

    case LLC_RESET_COMPLETION:
        pPacket->ResetPacket.pClosingInfo->CloseCounter--;
        if (pPacket->ResetPacket.pClosingInfo->CloseCounter == 0) {
            CompleteCloseReset(pFileContext, pPacket->ResetPacket.pClosingInfo);
        }

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

        break;

    case LLC_CONNECT_COMPLETION:

        DLC_TRACE('e');

        CompleteDlcCommand(pFileContext,
                           pDlcObject->StationId,
                           &pPacket->DlcCommand,
                           Status
                           );
        pDlcObject->PendingLlcRequests--;
        break;

    case LLC_DISCONNECT_COMPLETION:

        //
        // The disconnect is in dlc driver always connected to
        // the closing of the link station.  We just continue
        // the asynchronous command.  Still this process (waiting
        // the other side to ack to disconnect packet DISC)
        // may be interrupted by an immediate close command
        // (DLC.RESET or DIR.CLOSE.ADAPTER).
        //

        DLC_TRACE('g');

        if (pDlcObject->LlcObjectExists == TRUE) {
            pDlcObject->LlcObjectExists = FALSE;

            LEAVE_DLC(pFileContext);

            LlcCloseStation(pDlcObject->hLlcObject, (PLLC_PACKET)pPacket);

            ENTER_DLC(pFileContext);

            DereferenceLlcObject(pDlcObject);

            //
            // We don't want to complete a dlc object twice.
            //

            LEAVE_DLC(pFileContext);

            return;
        }

    case LLC_CLOSE_COMPLETION:

        //
        // Just free the command packet and update the reference counter.
        // The end of this procedure takes care of the rest.
        //

        DLC_TRACE('f');

        pDlcObject->PendingLlcRequests--;

        if (&pDlcObject->ClosePacket != (PLLC_PACKET) pPacket) {
            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);
        } else {
            pDlcObject->ClosePacketInUse = 0;
        }

        break;

#if LLC_DBG

    default:
        LlcInvalidObjectType();
        break;

#endif

    };

#if LLC_DBG

    if (pDlcObject != NULL && pDlcObject->PendingLlcRequests < 0) {
        DbgPrint("Error: PendingLlcRequests < 0!!!\n");
        DbgBreakPoint();
    }

#endif

    //
    // we can try to complete the close/reset only when there are no
    // pending commands issued to LLC (and NDIS).
    // The procedure will check, if there is still pending commands.
    //

    if (pDlcObject != NULL && pDlcObject->State != DLC_OBJECT_OPEN) {
        CompleteCloseStation(pFileContext, pDlcObject);
    }

    LEAVE_DLC(pFileContext);
}


VOID
CompleteTransmitCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp,
    IN PDLC_OBJECT pChainObject,
    IN PDLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine completes the DLC transmit command and optionally
    chains its CCB(s) to the completion list.
    The transmit read option defines, if the transmit commands
    are chained or if each command is completed with a separate
    READ- command.

Arguments:

    pFileContext    - DLC process and adapter specific file context
    pIrp            - Io- request packet of the completed command
    pChainObject    - the DLC object the packet(s) was transmitted from
    pPacket         - the orginal packet of the transmit command

Return Value:

    None

--*/

{
    PVOID pUserCcbPointer = NULL;
    PNT_DLC_PARMS pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

    //
    // MODMOD RLF 01/19/93
    //

    BOOLEAN queuePacket = FALSE;
    PVOID pCcb;
    ULONG eventFlags;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // MODMOD ends
    //

    pDlcParms->Async.Parms.Transmit.FrameStatus = 0xCC;

    //
    // Check if the transmit commands should be linked to the completion list
    //

    if (pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {

        //
        // Are they linked together in the same completion event?
        //

        if (pDlcParms->Async.Parms.Transmit.XmitReadOption != LLC_COMPLETE_SINGLE_XMIT_FRAME) {
            if (pDlcParms->Async.Parms.Transmit.XmitReadOption == LLC_CHAIN_XMIT_COMMANDS_ON_SAP
            && pChainObject->Type == DLC_LINK_OBJECT) {
                pChainObject = pChainObject->u.Link.pSap;
            }
            pChainObject->ChainedTransmitCount++;
            pUserCcbPointer = pChainObject->pPrevXmitCcbAddress;
            pChainObject->pPrevXmitCcbAddress = pDlcParms->Async.Ccb.pCcbAddress;

            //
            // Make new event only for the first transmit completion
            //

            if (pChainObject->ChainedTransmitCount == 1) {
                pChainObject->pFirstChainedCcbAddress = pDlcParms->Async.Ccb.pCcbAddress;
                pPacket->Event.pOwnerObject = pChainObject;
            } else {

                //
                // There is already a pending event for the
                // this transmit command, we may free this one.
                // The space & speed optimal code execution requires
                // a shameful jump.
                //

                DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

                //
                // MODMOD RLF 01/21/93
                //

                pCcb = pDlcParms->Async.Ccb.pCcbAddress;

                //
                // MODMOD ends
                //

                //
                // ***** G-O-T-O ********
                //

                goto ThisIsA_SHAME;
            }
        } else {
            pPacket->Event.pOwnerObject = NULL;
        }

        //
        // MODMOD RLF 01/19/93
        //

        ////
        //// We translate the orginal transit packet to a new event packet
        ////
        //
        //pPacket->Event.Event = LLC_TRANSMIT_COMPLETION;
        //pPacket->Event.StationId = (USHORT)pChainObject->StationId;
        //pPacket->Event.pEventInformation = pDlcParms->Async.Ccb.pCcbAddress;
        //pPacket->Event.SecondaryInfo = pDlcParms->Async.Ccb.CommandCompletionFlag;
        //QueueDlcEvent(pFileContext, pPacket);

        queuePacket = TRUE;
        pCcb = pDlcParms->Async.Ccb.pCcbAddress;
        eventFlags = pDlcParms->Async.Ccb.CommandCompletionFlag;

        //
        // MODMOD ends
        //

    } else {

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

    }

ThisIsA_SHAME:

    //
    // Set the default value to the returned frame status
    //

    if (pIrp->IoStatus.Status != STATUS_SUCCESS) {

        //
        // Set the FS (frame status) error code, NDIS has
        // returned an FS-related error code.
        // Note: This error status is never returned in the
        // case of I- frames (or should it be?).
        //

        if (pIrp->IoStatus.Status == NDIS_STATUS_NOT_RECOGNIZED) {
            pDlcParms->Async.Parms.Transmit.FrameStatus = 0;
            pDlcParms->Async.Ccb.uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR_FS;
        } else if (pIrp->IoStatus.Status == NDIS_STATUS_NOT_COPIED) {
            pDlcParms->Async.Parms.Transmit.FrameStatus = 0x44;
            pDlcParms->Async.Ccb.uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR_FS;
        } else if (pIrp->IoStatus.Status == NDIS_STATUS_INVALID_PACKET) {
            pDlcParms->Async.Parms.Transmit.FrameStatus = 0;
            pDlcParms->Async.Ccb.uchDlcStatus = LLC_STATUS_INVALID_FRAME_LENGTH;
        } else {

            //
            // Don't overwrite the existing DLC error codes!
            //

            if (pIrp->IoStatus.Status < DLC_STATUS_ERROR_BASE
            || pIrp->IoStatus.Status > DLC_STATUS_MAX_ERROR) {
                pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)LLC_STATUS_TRANSMIT_ERROR;
            } else {
                pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)(pIrp->IoStatus.Status - DLC_STATUS_ERROR_BASE);
            }
        }
        pIrp->IoStatus.Status = STATUS_SUCCESS;
    } else {
        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)STATUS_SUCCESS;
    }

    pDlcParms->Async.Ccb.pCcbAddress = pUserCcbPointer;

    //
    // Copy the optional second output buffer to user memory.
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_DLC_TRANSMIT) {

        //
        // MODMOD RLF 01/21/93
        //
        // Transmit now uses METHOD_OUT_DIRECT which means we update the CCB
        // with the pNext and uchDlcStatus fields
        //

        PLLC_CCB pInputCcb;
        PUCHAR pFrameStatus;

        pInputCcb = (PLLC_CCB)MmGetSystemAddressForMdl(pIrp->MdlAddress);

        //
        // the pointer may be an unaligned VDM pointer!
        //

        RtlStoreUlongPtr((PULONG_PTR)(&pInputCcb->pNext),
                         (ULONG_PTR)pUserCcbPointer);
        pInputCcb->uchDlcStatus = pDlcParms->Async.Ccb.uchDlcStatus;

        //
        // MODMOD ends
        //

        //
        // performance (slight) improvement. The following copies A SINGLE BYTE
        // (the frame status field). Replace call to copy routine with single
        // byte move
        //

        //LlcMemCpy(MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl),
        //          &pDlcParms->Async.Parms.Transmit.FrameStatus,
        //          aSpecialOutputBuffers[IOCTL_DLC_TRANSMIT_INDEX]
        //          );

        pFrameStatus = (PUCHAR)MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl);
        *pFrameStatus = pDlcParms->Async.Parms.Transmit.FrameStatus;

        UnlockAndFreeMdl(pDlcParms->Async.Ccb.u.pMdl);
    }

    //
    // we are about to complete this IRP - remove the cancel routine
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, FALSE);
    IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);

//    ACQUIRE_DRIVER_LOCK();

    //
    // MODMOD RLF 01/19/93
    //
    // Moved queueing of the event until after the IoCompleteRequest because it
    // was possible for the following to occur:
    //
    //  Thread A:
    //
    //  1.  app allocates transmit CCB & submits it. Transmit completion is to
    //      be picked up on a READ CCB
    //  2.  transmit completes
    //  3.  DLC queues event for transmit completion
    //
    //  Thread B:
    //
    //  4.  app submits READ CCB
    //  5.  READ finds completed transmit event on DLC event queue & removes it
    //  6.  READ IRP is completed (IoCompleteRequest)
    //  7.  app checks READ CCB and deallocates transmit CCB
    //  8.  app reallocates memory previously used for transmit CCB
    //
    //  Thread A:
    //
    //  9.  transmit IRP is completed (IoCompleteRequest)
    //
    // At this point, the IoCompleteRequest for the transmit copies some
    // completion info over the area which used to be the original transmit CCB
    // but has since been reallocated, causing lachrymae maximus
    //
    // This is safe because in this case we know we have a transmit which is
    // destined to be picked up by a READ (its ulCompletionFlag parameter is
    // non-zero), so it doesn't do any harm if we complete the IRP before
    // queueing the event for a READ
    //

    if (queuePacket) {
        pPacket->Event.Event = LLC_TRANSMIT_COMPLETION;
        pPacket->Event.StationId = (USHORT)pChainObject->StationId;
        pPacket->Event.pEventInformation = pCcb;
        pPacket->Event.SecondaryInfo = eventFlags;
        QueueDlcEvent(pFileContext, pPacket);
    }

    //
    // MODMOD ends
    //

    DereferenceFileContext(pFileContext);
}


VOID
CompleteDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN PDLC_COMMAND pDlcCommand,
    IN UINT Status
    )

/*++

Routine Description:

    The routine completes the DLC command and optionally
    saves its CCB(s) to the completion list, if the command
    has a command completion flag.

Arguments:

    pFileContext    - DLC process and adapter specific file context
    StationId       - the station id of the completed command (0 for non station
                      based commands)
    pDlcCommand     - the caller must provide either command completion packet
                      or IRP
    Status          - command completion status

Return Value:

    None

--*/

{
    PVOID pCcbAddress;
    ULONG CommandCompletionFlag;
    PIRP pIrp;

    pIrp = pDlcCommand->pIrp;

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

    pCcbAddress = ((PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;
    CommandCompletionFlag = ((PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.CommandCompletionFlag;
    CompleteAsyncCommand(pFileContext, Status, pIrp, NULL, FALSE);

    //
    // Queue command completion event, if the command completion flag was set
    //

    if (CommandCompletionFlag != 0) {
        MakeDlcEvent(pFileContext,
                     DLC_COMMAND_COMPLETION,
                     StationId,
                     NULL,
                     pCcbAddress,
                     CommandCompletionFlag,
                     FALSE
                     );
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcext.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcext.h
Abstract:

    This module includes all internal prototypes and
    externals of dlc (api driver) module.

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

extern USHORT aSpecialOutputBuffers[];
extern BOOLEAN MemoryLockFailed;
extern KSPIN_LOCK DlcSpinLock;

NTSTATUS
BufferPoolCreate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PVOID pUserBuffer,
    IN LONG MaxBufferSize,
    IN LONG MinFreeSizeThreshold,
    OUT HANDLE *pBufferPoolHandle,
    OUT PVOID* AlignedAddress,
    OUT PULONG AlignedSize
    );

NTSTATUS
BufferPoolExpand(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    );

VOID
BufferPoolFreeExtraPages(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    );

VOID
DeallocateBuffer(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBuffer
    );

NTSTATUS
AllocateBufferHeader(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pParent,
    IN UCHAR Size,
    IN UCHAR Index,
    IN UINT FreeListTableIndex
    );

NTSTATUS
BufferPoolAllocate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferSize,
    IN UINT FrameHeaderSize,
    IN UINT UserDataSize,
    IN UINT FrameLength,
    IN UINT SegmentSizeIndex,
    IN OUT PDLC_BUFFER_HEADER *ppBufferHeader,
    OUT PUINT puiBufferSizeLeft
    );

NTSTATUS
BufferPoolDeallocate(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers
    );

NTSTATUS
BufferPoolBuildXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers,
    IN OUT PDLC_PACKET pPacket
    );

VOID
BufferPoolFreeXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN OUT PDLC_PACKET pPacket
    );

PDLC_BUFFER_HEADER
GetBufferHeader(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PVOID pUserBuffer
    );

VOID
BufferPoolDereference(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL *pBufferPool
    );

NTSTATUS
BufferPoolReference(
    IN HANDLE hExternalHandle,
    OUT PVOID *phOpaqueHandle
    );

VOID
BufferPoolDeallocateList(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBufferList
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
CreateAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
CloseAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
DlcKillFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
DlcDriverUnload(
    IN PDRIVER_OBJECT pDeviceObject
    );

NTSTATUS
CleanupAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
DlcDeviceIoControl(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    );

VOID
DlcCompleteIoRequest(
    IN PIRP pIrp,
    IN BOOLEAN InCancel
    );

VOID
DlcCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SetIrpCancelRoutine(
    IN PIRP Irp,
    IN BOOLEAN Set
    );

#ifdef DLC_PRIVATE_PROTOTYPES

DLC_STATUS
LlcReceiveIndication(
    IN PDLC_FILE_CONTEXT hFileContext,
    IN PDLC_OBJECT hDlcObject,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PUCHAR pLookBuf,
    IN UINT cbLookBuf
    );

VOID
LlcEventIndication(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PVOID hEventObject,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

VOID
LlcCommandCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_PACKET pPacket
    );

#else

DLC_STATUS
LlcReceiveIndication(
    IN PVOID hFileContext,
    IN PVOID hClientHandle,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf
    );

VOID
LlcEventIndication(
    IN PVOID hFileContext,
    IN PVOID hEventObject,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInformation
    );

VOID
LlcCommandCompletion(
    IN PVOID        hFileContext,
    IN PVOID        hDlcObject,
    IN PVOID        hRequest
    );

#endif

VOID
CompleteTransmitCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp,
    IN PDLC_OBJECT pChainObject,
    IN PDLC_PACKET pRootXmitNode
    );

NTSTATUS
DlcQueryInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcSetInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

VOID
GetOpenSapAndStationCount(
    IN PDLC_FILE_CONTEXT pFileContext,
    OUT PUCHAR OpenSaps,
    OUT PUCHAR OpenStations
    );

NTSTATUS
SetupGroupSaps(
    IN PDLC_FILE_CONTEXT  pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN UINT GroupSapCount,
    IN PUCHAR pGroupSapList
    );

NTSTATUS
MakeDlcEvent(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN PDLC_OBJECT pDlcObject,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo,
    IN BOOLEAN FreeEventInfo
    );

NTSTATUS
QueueDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PIRP pIrp,
    IN PVOID AbortHandle,
    IN PFCOMPLETION_HANDLER pfCompletionHandler
    );

NTSTATUS
AbortCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID AbortHandle,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    );

VOID
CancelDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMMAND pDlcCommand,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    );

VOID
PurgeDlcEventQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
PurgeDlcFlowControlQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
CompleteDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN PDLC_COMMAND pDlcCommand,
    IN UINT Status
    );

PDLC_COMMAND
IsCommandOnList(
    IN PVOID RequestHandle,
    IN PLIST_ENTRY List
    );

PDLC_COMMAND
SearchAndRemoveCommand(
    IN PLIST_ENTRY pListHead,
    IN ULONG EventMask,
    IN USHORT StationId,
    IN USHORT StationIdMask
    );

PDLC_COMMAND
SearchAndRemoveCommandByHandle(
    IN PLIST_ENTRY pListHead,
    IN ULONG EventMask,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID AbortHandle
    );

PDLC_COMMAND
SearchAndRemoveSpecificCommand(
    IN PLIST_ENTRY pListHead,
    IN PVOID AbortHandle
    );

PDLC_COMMAND
SearchAndRemoveAnyCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID pSearchHandle
    );

VOID
SearchReadCommandForClose(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbAddress,
    IN ULONG CommandCompletionFlag,
    IN USHORT StationId,
    IN USHORT StationIdMask
    );

NTSTATUS
DlcBufferFree(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcBufferGet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcBufferCreate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcBufferMaintain(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcConnectStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcFlowControl(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcReallocate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcReset(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
ConnectCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

NTSTATUS
DirSetExceptionFlags(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

VOID
DlcCompleteRequest(
    IN PIRP pIrp,
    IN PVOID pUserCcbPointer
    );

VOID
CompleteAsyncCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN UINT Status,
    IN PIRP pIrp,
    IN PVOID pUserCcbPointer,
    IN BOOLEAN InCancel
    );

NTSTATUS
GetLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppLinkStation
    );

NTSTATUS
GetSapStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppLinkStation
    );

NTSTATUS
GetStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppStation
    );

NTSTATUS
DlcReadCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirOpenAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirCloseAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

VOID
CompleteDirInitialize(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    );

VOID
CompleteDirCloseAdapter(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    );

NTSTATUS
DlcTransmit(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pParameters,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirTimerSet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
DirTimerSetCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

NTSTATUS
DirTimerCancelGroup(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirTimerCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

PDLC_COMMAND*
SearchTimerCommand(
    IN PDLC_COMMAND *ppQueue,
    IN PVOID pSearchHandle,
    IN BOOLEAN SearchCompletionFlags
    );

PDLC_COMMAND
SearchPrevCommandWithFlag(
    IN PDLC_COMMAND pQueueBase,
    IN ULONG Event,
    IN ULONG CommandCompletionFlag
    );

VOID
AbortCommandsWithFlag(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG CommandCompletionFlag,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus
    );

NTSTATUS
DlcOpenSap(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirOpenDirect(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcOpenLinkStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
InitializeLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT  pSap,
    IN PNT_DLC_PARMS pDlcParms OPTIONAL,
    IN PVOID LlcLinkHandle OPTIONAL,
    OUT PDLC_OBJECT *ppLinkStation
    );

NTSTATUS
DlcCloseStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
CloseAllStations(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PFCLOSE_COMPLETE pfCloseComplete,
    IN PNT_DLC_PARMS pDlcParms,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    );

VOID
CloseAnyStation(
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN BOOLEAN DoImmediateClose
    );

VOID
CompleteCloseReset(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    );

NTSTATUS
DlcReceiveRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
ReceiveCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

NTSTATUS
DlcReadRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
ReadCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

VOID
CreateBufferChain(
    IN PDLC_BUFFER_HEADER pBufferHeaders,
    OUT PVOID *pFirstBuffer,
    OUT PUSHORT pReceivedFrameCount
    );

NTSTATUS
DlcReceiveCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcCompleteCommand(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

VOID
GetDlcErrorCounters(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PUCHAR pAdapterErrors
    );

VOID
QueueDlcEvent(
    IN PDLC_FILE_CONTEXT  pFileContext,
    IN PDLC_PACKET pPacket
    );

VOID
CompleteCloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject
    );

VOID
CloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN BOOLEAN DoImmediateClose
    );

VOID
CleanUpEvents(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PDLC_OBJECT pDlcObject
    );

VOID
CompleteCompletionPacket(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMPLETION_EVENT_INFO pCompletionInfo,
    IN OUT PNT_DLC_PARMS pParms
    );

PMDL
AllocateProbeAndLockMdl(
    IN PVOID UserBuffer,
    IN UINT UserBufferLength
    );

VOID
BuildMappedPartialMdl(
    IN PMDL pMappedSourceMdl,
    IN OUT PMDL pTargetMdl,
    IN PVOID BaseVa,
    IN ULONG Length
    );

VOID
BufferTrace(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PSZ  DebugString
    );

VOID
CheckIrql(
    PKIRQL  pOldIrqLevel
    );

VOID
ResetLocalBusyBufferStates(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
CompleteLlcObjectClose(
    IN PDLC_OBJECT pDlcObject
    );

VOID
UnlockAndFreeMdl(
    PMDL pMdl
    );

BOOLEAN
DecrementCloseCounters(
    PDLC_FILE_CONTEXT pFileContext,
    PDLC_CLOSE_WAIT_INFO pClosingInfo
    );

VOID
CompleteDirectOutIrp(
    IN PIRP Irp,
    IN UCHAR Status,
    IN PLLC_CCB NextCcb
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcopen.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcopen.c

Abstract:

    This module implements all open and close operations for DLC objects

    Contents:
        DlcOpenSap
        DirOpenDirect
        DlcOpenLinkStation
        InitializeLinkStation
        DlcCloseStation
        CloseAllStations
        CloseAnyStation
        CloseStation
        CompleteCloseStation
        CompleteCloseReset
        CleanUpEvents
        SearchReadCommandForClose
        CompleteLlcObjectClose
        DecrementCloseCounters
        CompleteDirectOutIrp

Author:

    Antti Saarenheimo 29-Aug-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include "dlcdebug.h"
#include <smbgtpt.h>


NTSTATUS
DlcOpenSap(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure implements DLC.OPEN.SAP function in DLC API.
    This implements DLC.OPEN.SAP.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - not used

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_OBJECT pDlcObject;
    UINT SapIndex = (pDlcParms->DlcOpenSap.SapValue >> 1);
    UINT Status;
    USHORT XidHandlingOption;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    DIAG_FUNCTION("DlcOpenSap");

    //
    //  The group saps do not have any open/close context in NT DLC,
    //  but there is an group sap object on data link level.
    //  The individual sap is registered to all its group saps
    //  and llc level automatically routes all packets sent to
    //  a group sap to all its registered members.  The groups saps
    //  are actually always open and they disappear automatically,
    //  when there are no references to them any more.
    //

    if (!(pDlcParms->DlcOpenSap.OptionsPriority &
          (LLC_INDIVIDUAL_SAP | LLC_MEMBER_OF_GROUP_SAP | LLC_GROUP_SAP))) {

        //
        //  Richard!!!!
        //  IBM spec says, that one of those bits must be set, on the
        //  other hand, Mike Allmond said, that IBM DLC accepts these
        //  command.  I don't belive it before a DOS application
        //  tries to open dlc sap with all bits reset, then you
        //  must accept it as a undocumented feature of IBM DLC.
        //

        return DLC_STATUS_INVALID_OPTION;
    } else if (!(pDlcParms->DlcOpenSap.OptionsPriority &
             (LLC_INDIVIDUAL_SAP | LLC_MEMBER_OF_GROUP_SAP))) {

        //
        //  It was a group sap, they do not have an open context,
        //  but their llc objects are created when they are referenced.
        //

        pDlcParms->DlcOpenSap.StationId = (USHORT)(((USHORT)pDlcParms->DlcOpenSap.SapValue << 8) | 0x0100);
        return STATUS_SUCCESS;
    }

    //
    //  The lowest byte in sap value is undefine, we must reset
    //  it to make it a valid individual DLC SAP number.
    //

    pDlcParms->DlcOpenSap.SapValue &= 0xfe;

    //
    //  Check the double open, the slot must be empty
    //

    if (SapIndex == 0
    || SapIndex >= MAX_SAP_STATIONS
    || pFileContext->SapStationTable[SapIndex] != NULL) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }

    //
    //  All DLC objects have the same size and they are allocated from
    //  the packet pool (the normal binary buddy allocation has an average
    //  33% overhead).
    //

    pDlcObject = (PDLC_OBJECT)ALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool);

    if (pDlcObject) {
        pFileContext->SapStationTable[SapIndex] = pDlcObject;
    } else {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    //  We should do here some security checking using the security
    //  descriptor of the current file context, but we do
    //  not yet care about those things (nbf must implement
    //  them first!)
    //

    pDlcObject->pFileContext = pFileContext;
    pDlcObject->Type = DLC_SAP_OBJECT;
    pDlcParms->DlcOpenSap.StationId = pDlcObject->StationId = (USHORT)pDlcParms->DlcOpenSap.SapValue << 8;
    pDlcObject->u.Sap.OptionsPriority = pDlcParms->DlcOpenSap.OptionsPriority;
    pDlcObject->u.Sap.DlcStatusFlag = pDlcParms->DlcOpenSap.DlcStatusFlag;
    pDlcObject->u.Sap.UserStatusValue = pDlcParms->DlcOpenSap.UserStatusValue;
    pDlcObject->u.Sap.MaxStationCount = pDlcParms->DlcOpenSap.StationCount;
    pDlcParms->DlcOpenSap.AvailableStations = pFileContext->LinkStationCount;

    XidHandlingOption = 0;
    if (!(pDlcObject->u.Sap.OptionsPriority & (UCHAR)XID_HANDLING_BIT)) {
        XidHandlingOption = LLC_HANDLE_XID_COMMANDS;
    }
    Status = LlcOpenSap(pFileContext->pBindingContext,
                        pDlcObject,
                        (UINT)pDlcParms->DlcOpenSap.SapValue,
                        XidHandlingOption,
                        &pDlcObject->hLlcObject
                        );

    if (Status == STATUS_SUCCESS) {

        //
        //  We will save the access priority bits with the other
        //  link station parameters using LlcSetInformation.
        //

        pDlcParms->DlcOpenSap.LinkParameters.TokenRingAccessPriority = pDlcParms->DlcOpenSap.OptionsPriority & (UCHAR)0xE0;

        //
        //  We know, that there will be no call backs from this
        //  set information function => we don't need to release spin
        //  locks.
        //

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pDlcObject->hLlcObject,
                                   DLC_INFO_CLASS_LINK_STATION,
                                   (PLLC_SET_INFO_BUFFER)&(pDlcParms->DlcOpenSap.LinkParameters),
                                   sizeof(DLC_LINK_PARAMETERS)
                                   );

        ENTER_DLC(pFileContext);
    }
    if (Status == STATUS_SUCCESS) {

        //
        //  The global group SAP (0xFF) is opened for all sap
        //  stations of dlc api.
        //  BUG-BUG-BUG: How incompatible XID handling options are
        //      handled in the case of the global group sap.
        //

        Status = LlcOpenSap(pFileContext->pBindingContext,
                            pDlcObject,
                            0xff,
                            LLC_HANDLE_XID_COMMANDS,
                            &pDlcObject->u.Sap.GlobalGroupSapHandle
                            );
    }
    if (Status == STATUS_SUCCESS) {

        //
        //  Each SAP station 'allocates' a fixed number link stations.
        //  This compatibility feature was implemented, because
        //  some dlc apps might assume to be have only a fixed number
        //  of link stations.  We can't do the check earlier, because
        //  another DlcOpenSap command would have been able to allocate
        //  the link stations before this moment.
        //

        if (pDlcParms->DlcOpenSap.StationCount > pFileContext->LinkStationCount) {
            Status = DLC_STATUS_INADEQUATE_LINKS;
        } else {
            pFileContext->LinkStationCount -= pDlcObject->u.Sap.MaxStationCount;
            pDlcObject->State = DLC_OBJECT_OPEN;
            pFileContext->DlcObjectCount++;

            //
            //  The flag and these reference counters keeps the llc object
            //  alive, when we are working on it.  We decerement
            //  the llc object reference count when we don't have any more
            //  synchronous commands going on.  Zero llc reference count
            //  on Dlc object dereferences the llc object.
            //

            pDlcObject->LlcObjectExists = TRUE;
            ReferenceLlcObject(pDlcObject);
            LlcReferenceObject(pDlcObject->hLlcObject);
            return STATUS_SUCCESS;
        }
    }

    //
    // error handling
    //

    pDlcParms->DlcOpenSap.AvailableStations = pFileContext->LinkStationCount;
    if (pDlcObject->hLlcObject != NULL) {
        pDlcObject->PendingLlcRequests++;

        LEAVE_DLC(pFileContext);

        LlcCloseStation(pDlcObject->hLlcObject, NULL);
        if (pDlcObject->u.Sap.GlobalGroupSapHandle != NULL) {
            LlcCloseStation(pDlcObject->u.Sap.GlobalGroupSapHandle, NULL);
        }

        ENTER_DLC(pFileContext);
    }

#if LLC_DBG
    pDlcObject->pLinkStationList = NULL;
#endif

    DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pDlcObject);

    pFileContext->SapStationTable[SapIndex] = NULL;
    return Status;
}


NTSTATUS
DirOpenDirect(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure opens the only direct station for a process specific adapter
    context. This implements DIR.OPEN.STATION.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - the length of output parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS
            DLC_STATUS_NO_MEMORY
            DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE
--*/

{
    PDLC_OBJECT pDlcObject;
    UINT Status;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    //  Check the double open, the slot must be empty
    //

    if (pFileContext->SapStationTable[0] != NULL) {
        return DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE;
    }

    //
    //  All DLC objects are allocated from the same size
    //  optimized pool (the std binary buddy has ave. 33% overhead).
    //

    pDlcObject = pFileContext->SapStationTable[0] = (PDLC_OBJECT)ALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool);

    if (pDlcObject == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    //  We should do here some security checking, but we do
    //  not care about those things now (nbf must implement
    //  them first!)
    //

    pDlcObject->pFileContext = pFileContext;
    pDlcObject->Type = DLC_DIRECT_OBJECT;
    pDlcObject->StationId = 0;
    pDlcObject->State = DLC_OBJECT_OPEN;

    LEAVE_DLC(pFileContext);

    if (pDlcParms->DirOpenDirect.usEthernetType > 1500) {

        //
        //  Open a dix station to receive the defined frames
        //

        Status = LlcOpenDixStation(pFileContext->pBindingContext,
                                   (PVOID)pDlcObject,
                                   pDlcParms->DirOpenDirect.usEthernetType,
                                   &pDlcObject->hLlcObject
                                   );

        pDlcObject->u.Direct.ProtocolTypeMask = pDlcParms->DirOpenDirect.ulProtocolTypeMask;
        pDlcObject->u.Direct.ProtocolTypeMatch = pDlcParms->DirOpenDirect.ulProtocolTypeMatch;
        pDlcObject->u.Direct.ProtocolTypeOffset = pDlcParms->DirOpenDirect.usProtocolTypeOffset;
    } else {

        //
        //  Open a dix station to receive the defined frames
        //

        Status = LlcOpenDirectStation(pFileContext->pBindingContext,
                                      (PVOID)pDlcObject,
                                      0,
                                      &pDlcObject->hLlcObject
                                      );
    }

    ENTER_DLC(pFileContext);

    if (Status == STATUS_SUCCESS) {

        //
        //  The flag and these reference counters keeps the llc object
        //  alive, when we are working on it.  We decerement
        //  the llc object reference count when we don't have any more
        //  synchronous commands going on.  Zero llc reference count
        //  on Dlc object dereferences the llc object.
        //

        pDlcObject->LlcObjectExists = TRUE;
        ReferenceLlcObject(pDlcObject);
        LlcReferenceObject(pDlcObject->hLlcObject);

        //
        //  We will receive ALL mac frame types if any of the
        //  mac bits has been set in the open options.
        //

        if (pDlcParms->DirOpenDirect.usOpenOptions & LLC_DIRECT_OPTIONS_ALL_MACS) {
            pDlcObject->u.Direct.OpenOptions = (USHORT)(-1);
        } else {
            pDlcObject->u.Direct.OpenOptions = (USHORT)~DLC_RCV_MAC_FRAMES;
        }
        pFileContext->DlcObjectCount++;
    } else {
        pFileContext->SapStationTable[0] = NULL;

#if LLC_DBG
        pDlcObject->pLinkStationList = NULL;
#endif

        DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pDlcObject);

    }
    return Status;
}


NTSTATUS
DlcOpenLinkStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure opens a new link station. DlcConnect is still needed to
    create the actual connection to the remote node.
    This implements DLC.OPEN.STATION

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS
            DLC_STATUS_NO_MEMORY
            DLC_STATUS_INADEQUATE_LINKS
--*/

{
    NTSTATUS    Status;
    PDLC_OBJECT pDlcObject;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // The local SAP must not be the NULL SAP or a group SAP!
    //

    if ((pDlcParms->DlcOpenStation.LinkStationId & 0x100) != 0
    || pDlcParms->DlcOpenStation.LinkStationId == 0) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }

    //
    // This must be a SAP station!
    //

    Status = GetSapStation(pFileContext,
                           pDlcParms->DlcOpenStation.LinkStationId,
                           &pDlcObject
                           );
    if (Status == STATUS_SUCCESS) {

        //
        // Check the remote destination address, the broadcast bit
        // must not be set in that address.  The remote SAP must not
        // either be a group or nul SAP
        //

        if ((pDlcParms->DlcOpenStation.aRemoteNodeAddress[0] & 0x80) != 0
        || pDlcParms->DlcOpenStation.RemoteSap == 0
        || (pDlcParms->DlcOpenStation.RemoteSap & 1) != 0) {
            return DLC_STATUS_INVALID_REMOTE_ADDRESS;
        }
        Status = InitializeLinkStation(pFileContext,
                                       pDlcObject,
                                       pDlcParms,
                                       NULL,    // this is a local connect, no LLC link handle
                                       &pDlcObject
                                       );

        //
        // Set also the link station parameters,  all nul
        // parameters are discarded by the data link.
        //

        if (Status == STATUS_SUCCESS) {
            LlcSetInformation(
                pDlcObject->hLlcObject,
                DLC_INFO_CLASS_LINK_STATION,
                (PLLC_SET_INFO_BUFFER)&pDlcParms->DlcOpenStation.LinkParameters,
                sizeof(DLC_LINK_PARAMETERS)
                );
        }
    }
    return Status;
}


NTSTATUS
InitializeLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT  pSap,
    IN PNT_DLC_PARMS pDlcParms OPTIONAL,
    IN PVOID LlcLinkHandle OPTIONAL,
    OUT PDLC_OBJECT *ppLinkStation
    )

/*++

Routine Description:

    This procedure allocates and initializes the link station.

Arguments:

    pFileContext    - DLC adapter context
    pSap            - Sap object of the new link station
    pDlcParms       - the current parameter block
    LlcHandle       - Handle
    ppLinkStation   - the new created link station

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                  DLC_STATUS_INADEQUATE_LINKS

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pLinkStation;
    UINT LinkIndex;

    //
    // There is allocated a limited number link stations for
    // this SAP, check if there is available link stations
    //

    if (pSap->u.Sap.LinkStationCount >= pSap->u.Sap.MaxStationCount) {
        return DLC_STATUS_INADEQUATE_LINKS;
    }

    //
    // Search the first free link station id
    //

    for (LinkIndex = 0;
        LinkIndex < MAX_LINK_STATIONS
        && pFileContext->LinkStationTable[LinkIndex] != NULL;
        LinkIndex++) {
        ; // NOP
    }

//#ifdef DEBUG_CHK
//    //
//    //  Link counters are out of sync ????
//    //
//    if (LinkIndex == MAX_LINK_STATIONS)
//    {
//        DEBUG_ERROR("DLC: Linkstation counters are out of sync!");
//        return DLC_STATUS_INADEQUATE_LINKS;
//    }
//#endif

    //
    // Allocate the link station and initialize the station id field
    //

    pLinkStation = ALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool);

    if (pLinkStation == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // Each link station has a preallocated event packet to receive
    // all DLC Status indications from the data link.  There can
    // be several status indications set in the same status word.
    // The status is reset when its read from the event queue.
    //

    pLinkStation->u.Link.pStatusEvent = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pLinkStation->u.Link.pStatusEvent == NULL) {

#if LLC_DBG
        pLinkStation->pLinkStationList = NULL;
#endif

        DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pLinkStation);

        return DLC_STATUS_NO_MEMORY;
    }
    *ppLinkStation = pLinkStation;
    pFileContext->LinkStationTable[LinkIndex] = pLinkStation;
    pLinkStation->StationId = pSap->StationId | (USHORT)(LinkIndex + 1);
    pLinkStation->Type = DLC_LINK_OBJECT;
    pLinkStation->State = DLC_OBJECT_OPEN;
    pLinkStation->pFileContext = pFileContext;
    pSap->u.Sap.LinkStationCount++;

    //
    // Check if this is local or remote connection request, the remote
    // connection requests have already created an LLC link object
    //

    if (LlcLinkHandle == NULL) {

        //
        // local connection request
        //

        Status = LlcOpenLinkStation(pSap->hLlcObject,   // SAP handle!
                                    pDlcParms->DlcOpenStation.RemoteSap,
                                    pDlcParms->DlcOpenStation.aRemoteNodeAddress,
                                    NULL,
                                    pLinkStation,
                                    &pLinkStation->hLlcObject
                                    );
        if (Status != STATUS_SUCCESS) {

            //
            // It didn't work for some reason, we are probably out of memory.
            // Free the slot in the link station table.
            //

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pLinkStation->u.Link.pStatusEvent);

#if LLC_DBG
            pLinkStation->pLinkStationList = NULL;
#endif

            DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pLinkStation);

            pFileContext->LinkStationTable[LinkIndex] = NULL;
            pSap->u.Sap.LinkStationCount--;
            return Status;
        }
        pDlcParms->DlcOpenStation.LinkStationId = pLinkStation->StationId;
    } else {

        //
        // remote connection request
        //

        pLinkStation->hLlcObject = LlcLinkHandle;

        //
        // We must give the upper protocol handle to the link station,
        // otherwise the system bug checks, when the link is closed
        // before it is connected.
        //

        LlcBindLinkStation(LlcLinkHandle, pLinkStation);
    }

    //
    // The flag and these reference counters keeps the LLC object
    // alive, when we are working on it.  We decerement
    // the LLC object reference count when we don't have any more
    // synchronous commands going on.  Zero LLC reference count
    // on DLC object dereferences the LLC object
    //

    pLinkStation->LlcObjectExists = TRUE;
    ReferenceLlcObject(pLinkStation);
    LlcReferenceObject(pLinkStation->hLlcObject);

    //
    // Link this link station to the link list of all
    // link stations belonging to this sap (!?)
    //

    pFileContext->DlcObjectCount++;
    pLinkStation->u.Link.pSap = pSap;
    pLinkStation->pLinkStationList = pSap->pLinkStationList;
    pSap->pLinkStationList = pLinkStation;
    return STATUS_SUCCESS;
}


NTSTATUS
DlcCloseStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure closes a link, SAP or direct station. This implements
    DLC.CLOSE.STATION, DLC.CLOSE.SAP and DIR.CLOSE.DIRECT

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
                  STATUS_PENDING
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_OBJECT pDlcObject;
    NTSTATUS Status;
    PDLC_CLOSE_WAIT_INFO pClosingInfo;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    DIAG_FUNCTION("DlcCloseStation");

    //
    // It's OK to close any group sap id (we don't test them, because
    // those objects exists only in llc driver.  The full implementation
    // of group saps would make this driver just too complicated)
    //

    if (pDlcParms->Async.Ccb.u.dlc.usStationId & 0x0100) {
        CompleteDirectOutIrp(pIrp, STATUS_SUCCESS, NULL);
        CompleteAsyncCommand(pFileContext, STATUS_SUCCESS, pIrp, NULL, FALSE);
        return STATUS_PENDING;
    }

    //
    // Procedure checks the sap and link station ids and
    // returns the requested link station.
    // The error status indicates a wrong sap or station id.
    //

    Status = GetStation(pFileContext,
                        pDlcParms->Async.Ccb.u.dlc.usStationId,
                        &pDlcObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // Sap station cannot be closed until its all link stations
    // have been closed.
    //

    if ((pDlcObject->Type == DLC_SAP_OBJECT)
    && (pDlcObject->u.Sap.LinkStationCount != 0)) {
        return DLC_STATUS_LINK_STATIONS_OPEN;
    }

    pClosingInfo = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pClosingInfo == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }
    pClosingInfo->pIrp = pIrp;
    pClosingInfo->CloseCounter = 0;
    pClosingInfo->Event = DLC_COMMAND_COMPLETION;
    pClosingInfo->CancelStatus = DLC_STATUS_CANCELLED_BY_USER;
    pClosingInfo->CancelReceive = TRUE;

    if (pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {
        pClosingInfo->ChainCommands = TRUE;
        SearchReadCommandForClose(pFileContext,
                                  pClosingInfo,
                                  pDlcParms->Async.Ccb.pCcbAddress,
                                  pDlcParms->Async.Ccb.CommandCompletionFlag,
                                  pDlcObject->StationId,
                                  (USHORT)DLC_STATION_MASK_SPECIFIC
                                  );
    }

    CloseAnyStation(pDlcObject, pClosingInfo, FALSE);

    return STATUS_PENDING;
}

/*++

Design notes about the dlc close commands
-----------------------------------------

All close operation must wait until the pending NDIS transmits
have been completed.  Thus they are asynchronous commands.
The close commands of a DLC object will also return all
CCBs of the pending commands and the received frames not yet read
with the read command.  The normal non-urgent close commands must
wait also the queued DLC transmit to complete.


There are three functions closing the dlc stations:
- DlcCloseObject
- DlcReset (sap and its link stations or all link stations)
- DirCloseAdapter (almost same as reset, except marks the file object closed,
    the actual file close disconnects the NDIS adapter.

All higher level functions allocates close completion data structure,
that is used to complete the command, when there are no pending
transmits in the associated stations.

The lower level functions
    CloseAllStations - closes all open sap stations and the only direct station
    CloseAnyStation  - initializes the close of any station,
                       for a sap station it also calls recursively the
                       link stations.
    CloseStation    - closes the object immediately or waits
                      until transmits have been completed and then
                      does the same thing again.


About the simultaneous reset and close commands
-------------------------------------------------

There are some very difficult problems with the
simultaneous reset and close commands:  each command
must wait until all dlc objects associated with the command
has been closed before the command itself cab be completed.
It is completely legal to make first close for a station, then
reset the sap of the same station (before the close completes) and
then reset all sap stations (before the sap reset completes).
On the other hand a dlc object can be linked only to one
close/reset command and in this case all three commands should wait
the completion of the same link station.

//Solution 1 (a bad one):
//There can be any number aof simultaneous close commands, because it
//can be done to a dlc object only if it has no open substations.
//There must be no other pending reset or close commands when a reset
//command is executed, because some of its substations may already
//be closing and they cannot be linked to the reset command.
//
//=>
//We have a global close/reset command counter and a link list for the
//pending reset commands.  A close command can be given in any time
//(even during a reset command, because all stations associated with
//a reset are already closed and cannot be closed again).
//A reset can be executed only if the global close/reset is zero.
//The pending resets are queued.  The close command completion
//routines executes the first reset command from the queue, if the
//!! Reset command must immediately mark all associated stations
//   closed to prevent any further use of those commands.

Solution 2 (the final solution):
-------------------------------

The sequential and simultaneous close and reset commands can be given
only to the dlc object being higher (or same) level than the destination
of the previous command (close link, reset sap, reset all saps, close adapter)
=> close/reset events can be linked in the dlc objects (simultaneous
close commands creates a split tree).
The counters in all close/reset events are decremented and possibly
executed when the dlc object is closed (when all transmits have been
completed and the link stations disconnected).


    //
    //  IBM has implemented the different close commands in this way:
    //
    //  1. DIR.CLOSE.DIRECT
    //      - Undefined, I will do the same as with DLC.CLOSE.X commands
    //  2. DLC.CLOSE.SAP, DLC.CLOSE.STATION
    //      - receive ccb linked to next ccb field without completion flag,
    //        the receive command is completed normally, only return code
    //        is set.
    //      - all terminated commands linked after the receive ccb if
    //        completion flag was defined and command itself read by
    //        READ from the compeltion list.
    //        The terminated commands (except receive) are completed normally.
    //  3. DLC.RESET
    //      - The terminated pending CCBs are linked only if command completion
    //        flag was defined.
    //  4. DIR.CLOSE.ADAPTER, DIR.INITIALIZE
    //      - the terminated CCBs linked to the next ccb field of the command.
    //        The command itself can be read with read command, if defined.
    //
    //  (and now we do the same (12-FEB-1992))

    Note: all close functions returns VOID, because they can never fail.
    A hanging close command hangs up the process or event the whole system.
    We have a problem: the llc adapter may be closed, while there are
    still active LLC command packets pending in the NDIS queues => the
    NDIS adapter close must wait (sleep and loop) until its all objects
    have been deleted.

--*/


BOOLEAN
CloseAllStations(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp OPTIONAL,
    IN ULONG Event,
    IN PFCLOSE_COMPLETE pfCloseComplete OPTIONAL,
    IN PNT_DLC_PARMS pDlcParms OPTIONAL,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    )

/*++

Routine Description:

    This routine initializes closing all DLC stations. The command is
    asynchronously completed when all pending transmits have been sent
    and the link stations have been disconnected

Arguments:

    pFileContext    - process specific device context
    pIrp            - the i.o request packet of the related command
    Event           - event flag used to search a matching read for this command
    pfCloseComplete - completion appendage used when the DLC driver (or its
                      process context) is closed.
    pDlcParms       - DLC parameters from original system call
    pClosingInfo    - pointer to DLC_CLOSE_WAIT_INFO structure

Return Value:

    None - this must succeed always!

--*/

{
    PDLC_PACKET pPacket;
    USHORT i;
    USHORT FirstSap;
    BOOLEAN DoImmediateClose;
    NT_DLC_CCB AsyncCcb;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pDlcParms == NULL) {

        //
        // Adapter Close always returns a pending status!
        // It completes the io- request by itself.
        //

        pDlcParms = (PNT_DLC_PARMS)&AsyncCcb;
        LlcZeroMem(&AsyncCcb, sizeof(AsyncCcb));
    }

    pClosingInfo->pIrp = pIrp;
    pClosingInfo->CloseCounter = 1; // keep object alive during sync path
    pClosingInfo->Event = Event;
    pClosingInfo->pfCloseComplete = pfCloseComplete;
    pClosingInfo->CancelStatus = (ULONG)DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION;

    //
    // We zero the memory by default:
    //      pClosingInfo->pCcbLink = NULL
    //      pClosingInfo->pReadCommand = NULL
    //

    //
    // DLC.RESET must not close the direct station.
    // This flag is false for DLC.RESET but set for DIR.CLOSE.ADAPTER etc.
    //

    if (pDlcParms->Async.Ccb.uchDlcCommand == LLC_DLC_RESET) {
        FirstSap = 1;                   // don't delete the direct station
        DoImmediateClose = FALSE;
        pClosingInfo->CancelStatus = DLC_STATUS_CANCELLED_BY_USER;
    } else {
        FirstSap = 0;   // if DIR.CLOSE.ADAPTER, can close everything
        DoImmediateClose = TRUE;
        pClosingInfo->ClosingAdapter = TRUE;
    }

    //
    // Chain the cancelled CCBs to the adapter close command or to a closing
    // event, if this is a global close command for adapter or a normal close
    // command (dlc.close.xxx, dlc.reset, dir.close.station) with a command
    // completion flag
    //

    if (Event == LLC_CRITICAL_EXCEPTION || pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {
        pClosingInfo->ChainCommands = TRUE;
        SearchReadCommandForClose(pFileContext,
                                  pClosingInfo,
                                  pDlcParms->Async.Ccb.pCcbAddress,
                                  pDlcParms->Async.Ccb.CommandCompletionFlag,
                                  0,
                                  0 // search commands for all station ids
                                  );
    }

    //
    // This flag has been set, when user has issued DIR.INITIALIZE command,
    // that makes the hard reset for NDIS
    //

    if (pDlcParms->Async.Ccb.uchDlcCommand == LLC_DIR_INITIALIZE) {

        //
        // We cannot stop to closing, if the memory allocation fails,
        // It's better just to close the adapter without hard reset
        // that to fail the whole DIR.INITIALIZE command.
        //

        pPacket = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pPacket != NULL) {
            pClosingInfo->CloseCounter++;

            pPacket->ResetPacket.pClosingInfo = pClosingInfo;

            //
            // The reset command cancels all pending transmit requests!
            // => the closing of the stations should be very fast
            //

            LEAVE_DLC(pFileContext);

            LlcNdisReset(pFileContext->pBindingContext, &pPacket->LlcPacket);

            ENTER_DLC(pFileContext);

        }
    }
    if (pFileContext->DlcObjectCount != 0) {
        for (i = FirstSap; i < MAX_SAP_STATIONS; i++) {
            if (pFileContext->SapStationTable[i] != NULL) {
                CloseAnyStation(pFileContext->SapStationTable[i],
                                pClosingInfo,
                                DoImmediateClose
                                );
            }
        }
    }

    //
    // Complete close command, if this was the last reference
    // of the close information
    //

    return DecrementCloseCounters(pFileContext, pClosingInfo);
}


VOID
CloseAnyStation(
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN BOOLEAN DoImmediateClose
    )

/*++

Routine Description:

    Procedure closes any station, and in the case of sap station it
    also calls recursively sap's all link stations before
    it closes the actual sap station.

Arguments:

    pDlcObject          - DLC object
    pClosingInfo        - the information needed for the close/reset command
                          completion (optionally by DLC read).
    DoImmediateClose    - flag set when the stations are closed immediately

Return Value:

    None - this must succeed always!

--*/

{
    PDLC_FILE_CONTEXT pFileContext = pDlcObject->pFileContext;
    PDLC_CLOSE_WAIT_INFO pCurrentClosingInfo;
    UINT i;

    DIAG_FUNCTION("CloseAnyStation");

    //
    // first close all link stations on this SAP. This must be done before the
    // object can be marked as deleted
    //

    if (pDlcObject->Type == DLC_SAP_OBJECT) {

        BOOLEAN SapObjectIsBadFood = FALSE;

        //
        //  Delete all link stations using the current sap station.
        //

        for (i = 0; i < MAX_LINK_STATIONS; i++) {
            if (pFileContext->LinkStationTable[i] != NULL
            && pFileContext->LinkStationTable[i]->u.Link.pSap == pDlcObject) {

                //
                // the SAP object will be deleted when its last link object has
                // been deleted
                //

                if (pDlcObject->State == DLC_OBJECT_CLOSING) {
                    SapObjectIsBadFood = TRUE;
                }
                CloseAnyStation(pFileContext->LinkStationTable[i],
                                pClosingInfo,
                                DoImmediateClose
                                );
            }
        }

        //
        // it is highly probable that the SAP object is already deleted. The
        // close info counter was also decremented because the current closing
        // info packet was linked behind the old close packet by link station
        // cleanup, then completed when the SAP was closed after its last link
        // station was deleted
        //

        if (SapObjectIsBadFood) {
            return;
        }
    }

    //
    // We must queue simultaneous close/reset commands
    //

    if (pDlcObject->State == DLC_OBJECT_OPEN) {
        pDlcObject->State = DLC_OBJECT_CLOSING;
        pDlcObject->pClosingInfo = pClosingInfo;

        //
        // The close command has been queued, increment the counter
        //

        pClosingInfo->CloseCounter++;
    } else {

        //
        // Queue all simultaneous close/reset commands to a spanning TREE
        //
        // The linked closing info packets creates a spanning tree.
        // The newest (and stronges) close command is always the
        // root node.  Even stronger close command would combine
        // the separate spanning trees to one single tree.
        // The root commands are completed, when its all sub-stations
        // have been closed and older commands have been completed.
        //
        // It is possible to have simultaneously pending:
        //     1. Close link station (pending)
        //     2. Close sap station (pending)
        //     3. Reset sap station (pending)
        //     4. Reset all saps with single command (pending)
        //     5. Resetting NDIS adapter with DirInitialize
        //        OR Closing adapter with DirCloseAdapter
        //        OR close initiated by process exit
        //
        // The commands cannot be executed in the reverse order,
        // because the stronger command would have already closed
        // affected station(s) or adapter.
        //

        for (pCurrentClosingInfo = pDlcObject->pClosingInfo;
            pCurrentClosingInfo != pClosingInfo;
            pCurrentClosingInfo = pCurrentClosingInfo->pNext) {

            if (pCurrentClosingInfo->pNext == NULL) {
                pCurrentClosingInfo->pNext = pClosingInfo;

                //
                // We link this close packet to many other close commands,
                // => we must add the count of all pending closing stations
                // to the current packet
                // (fix 28-03-1992, bug check when process exit during a
                // pending dlc reset).
                // (Bug-bug: close counter is not correct, when the previous
                // close command is still in sync code path => dlc reset
                // must decrement the next pointers in the queue).
                //

                pClosingInfo->CloseCounter += pCurrentClosingInfo->CloseCounter;
                break;
            }
        }
    }

    CloseStation(pFileContext, pDlcObject, DoImmediateClose);
}


VOID
CloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN BOOLEAN DoImmediateClose
    )

/*++

Routine Description:

    This procedure starts the asychronous close of any DLC station
    object.  It creates an asynchronous command completion packet
    for the station and returns.

Arguments:

    pFileContext        -
    pDlcObject          - DLC object
    DoImmediateClose    - the flag is set when the LLC object must be closed
                          immediately without waiting the pending transmits

Return Value:

    None - this must succeed always!

--*/

{
    PLLC_PACKET pClosePacket;

    DIAG_FUNCTION("CloseStation");

    //
    // we must cancel all pending transmits immediately,
    // when the adapter is closed.
    //

    if ((pDlcObject->State == DLC_OBJECT_CLOSING
    && (DoImmediateClose || pDlcObject->PendingLlcRequests == 0)
    && !(pDlcObject->Type == DLC_SAP_OBJECT && pDlcObject->u.Sap.LinkStationCount != 0))

    ||

    //
    // This condition forces the link to close even if
    // there was a pending disconnect command (it may be
    // waiting the other side and that may take a quite a while).
    // Otherwise the exit of a DLC app may hung up to 5 - 60 seconds)
    //

    (DoImmediateClose
    && pDlcObject->hLlcObject != NULL
    && pDlcObject->Type == DLC_LINK_OBJECT)) {

        //
        // Llc objects can be closed in any phase of operation.
        // The close command will cancel all transmit commands
        // not yet queued to NDIS and returns an asynchronous
        // completion status, when the pending NDIS commands
        // have been completed.  The CloseCompletion indication
        // handler uses the same PendingLlcRequestser as
        // with the normal pending transmit commands.
        // The immediate close first closes the LLC object and then
        // waits the pending transmits (=> waits only transmits
        // queued on NDIS).
        // A graceful close does it vice versa: it first waits
        // pending transmits and then does the actual close.
        //

        ASSERT(pDlcObject->ClosePacketInUse == 0);

        if (pDlcObject->ClosePacketInUse == 1) {
            pClosePacket = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

            if (pClosePacket == NULL) {
                //
                // We don't have enough memory to make a graceful closing,
                // We must do it in a quick and dirty way.
                // We cannoot either wait llc to acknowledge the
                // close, because we don't have any close packet
                //
                DoImmediateClose = TRUE;
            } else {
                pDlcObject->PendingLlcRequests++;
            }
        } else {
            pClosePacket = &pDlcObject->ClosePacket;
            pDlcObject->ClosePacketInUse = 1;
            pDlcObject->PendingLlcRequests++;
        }

        pDlcObject->State = DLC_OBJECT_CLOSED;
        if (pDlcObject->Type == DLC_LINK_OBJECT && !DoImmediateClose) {

            //
            // LlcDisconnect completion routine will close the link
            // station and call this routine again, when the
            // link station routine completes.
            // We must reference the LLC object before the operation,
            // otherwise there is a very small time window, that allows
            // LLC object to be deleted while the disconnect
            // operation is going on (and crash the system).
            // (I hate pointer based interfaces)
            //

            ReferenceLlcObject(pDlcObject);

            LEAVE_DLC(pFileContext);

            //
            // Data link driver returns a synchronous status only if
            // if cannot complete command asynchronously, because it
            // doesn't have a handle to the DLC object (the link
            // station has not yet been
            //

            LlcDisconnectStation(pDlcObject->hLlcObject, pClosePacket);

            ENTER_DLC(pFileContext);

            DereferenceLlcObject(pDlcObject);
        } else {

            //
            // we must close the link station immediately, if we for
            // some reason cannot disconnect it normally.
            //

            if (pDlcObject->LlcObjectExists == TRUE) {
                pDlcObject->LlcObjectExists = FALSE;

                LEAVE_DLC(pFileContext);

                LlcCloseStation(pDlcObject->hLlcObject, pClosePacket);

                ENTER_DLC(pFileContext);

                DereferenceLlcObject(pDlcObject);
            }
        }

        //
        // We must be able to close the driver even in out of memory conditions.
        // LLC driver won't acknowledge the close if we connot allocate a packet
        // for it
        //

        if (pClosePacket == NULL) {
            CompleteCloseStation(pFileContext, pDlcObject);
        }
    }
}


VOID
CompleteCloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject
    )

/*++

Routine Description:

    Procedure completes the close operation for any station object.
    It also completes all close commands, that have been waiting
    the closing of this station (or this station as the last member
    of a group).

Arguments:

    pFileContext    - identifies owner of object
    pDlcObject      - dlc object

Return Value:

    None.

--*/

{
    //
    // We must keep the LLC object alive, as far as there is any
    // pending (transmit) commands in LLC.
    //

    if (pDlcObject->PendingLlcRequests == 0) {

        //
        //  The station may still be waiting its transmit (and receive)
        //  commands to complete.  We must poll the close station.
        //  if the status is still just closing.
        //

        if (pDlcObject->State == DLC_OBJECT_CLOSING) {
            CloseStation(pFileContext, pDlcObject, FALSE);
        } else {

            PDLC_OBJECT pSapObject = NULL;
            PDLC_CLOSE_WAIT_INFO pClosingInfo;

            DLC_TRACE('N');

            //
            //  The object must have been deleted from the file
            //  context when we enable spin lock in the next time,
            //  because the object is not any more in a consistent
            //  state.
            //

            if (pDlcObject->Type == DLC_LINK_OBJECT) {

                DLC_TRACE('c');

                //
                //  Remove the link station from the link station
                //  link list of its sap and link station table
                //  of the file context.
                //

                RemoveFromLinkList((PVOID *)&(pDlcObject->u.Link.pSap->pLinkStationList),
                                   pDlcObject
                                   );
                pFileContext->LinkStationTable[(pDlcObject->StationId & 0xff) - 1] = NULL;

                //
                //  Data link events have always the next pointer
                //  non-null, when they are in the event queue.
                //  The cleanup routine will remove and deallocate
                //  the packet when it is in the event queue.
                //

                if (pDlcObject->u.Link.pStatusEvent->LlcPacket.pNext == NULL) {

                    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool,
                                              pDlcObject->u.Link.pStatusEvent
                                              );

                }

                //
                //  Remove the possible memory committed by this link
                //  station during a buffer busy state.  Normally
                //  the committed space is zero.
                //

                if (pFileContext->hBufferPool != NULL) {
                    BufUncommitBuffers(pFileContext->hBufferPool,
                                       pDlcObject->CommittedBufferSpace
                                       );
                }

                //
                //  The sap station must wait until its all link stations
                //  have been closed.
                //  Otherwise we will corrupt memory!!!!!!!!!
                //  ((would have been very hard and uncommon bug: reset
                //    of one station migth have corrupted a new dlc object
                //    created simultaneusly))
                //

                pDlcObject->u.Link.pSap->u.Sap.LinkStationCount--;
                if (pDlcObject->u.Link.pSap->u.Sap.LinkStationCount == 0
                && pDlcObject->u.Link.pSap->State == DLC_OBJECT_CLOSING) {
                    pSapObject = pDlcObject->u.Link.pSap;
                }
            } else {

                //
                //  SAP station must wait until its all link stations
                //  have been closed!
                //

                if (pDlcObject->Type == DLC_SAP_OBJECT) {
                    if (pDlcObject->u.Sap.LinkStationCount != 0) {
                        return;
                    }

                    DLC_TRACE('d');

                    //
                    //  All link stations have now been deleted, we can return
                    //  the sap's link stations back to the global pool.
                    //  The group sap can be deleted also.
                    //

                    pFileContext->LinkStationCount += pDlcObject->u.Sap.MaxStationCount;

                    LEAVE_DLC(pFileContext);

                    LlcCloseStation(pDlcObject->u.Sap.GlobalGroupSapHandle, NULL);

                    ENTER_DLC(pFileContext);

                    //
                    //  Delete all group saps defined for this sap station
                    //

                    SetupGroupSaps(pFileContext, pDlcObject, 0, NULL);
                }
                pFileContext->SapStationTable[pDlcObject->StationId >> 9] = NULL;
            }
            pFileContext->DlcObjectCount--;

            //
            //  The first and most specific close command will get all
            //  received frames and the transmit chain of the deleted object.
            //

            CleanUpEvents(pFileContext, pDlcObject->pClosingInfo, pDlcObject);

            //
            //  The parallel close/reset commands have been queued in a
            //  link list,  We must decrement and notify all dlc objects
            //

//            DecrementCloseCounters(pFileContext, pDlcObject->pClosingInfo);

            //
            //  It's best to deallocate event packet after the
            //  cleanup of the event queue
            //

#if LLC_DBG
            pDlcObject->pLinkStationList = NULL;
            pDlcObject->State = DLC_OBJECT_INVALID_TYPE;
#endif

            //
            // RLF 08/17/94
            //
            // grab the pointer to the closing info structure before deallocating
            // the DLC object
            //

            pClosingInfo = pDlcObject->pClosingInfo;
            DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pDlcObject);

            //
            //  the close completion of the last link station closes
            //  also the sap object of that link station, if the
            //  sap closing was waiting to closing of the link station
            //

            if (pSapObject != NULL) {
                CloseStation(pFileContext, pSapObject, TRUE);

                                                    //
                                                    // TRUE: must be at least
                                                    // DLC.RESET
                                                    //

            }

            //
            // RLF 08/17/94
            //
            // Moved this call to DecrementCloseCounters from its previous
            // place above. Once again, we find that things are happening out
            // of sequence: this time, if we decrement the close counters,
            // causing them to go to zero before we have freed the DLC object
            // then the file context structure and its buffer pools are
            // deallocated. But the DLC object was allocated from the now
            // deleted pool, meaning sooner or later we corrupt non-paged pool
            //

            //
            //  The parallel close/reset commands have been queued in a
            //  link list,  We must decrement and notify all dlc objects
            //

            DecrementCloseCounters(pFileContext, pClosingInfo);
        }
    }
}


VOID
CompleteCloseReset(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    )

/*++

Routine Description:

    The primitive builds a completion event for the close/reset
    of a dlc object. The close/reset may have been initiated by
    DlcReset, DirCloseAdapter, DirInitialize or because the NDIS
    driver is closing (eg. Unbind command).
    In the last case pClosingInfo->pIrp is NULL, because there
    is no command related to the event.

    The only (major) difference from the IBM OS/2 DLC is, that
    the first_buffer_addr parameter is not supported, because it
    is meaningless with he NT buffer management.
    The buffer pool is managed by dlc, not by the application.

Arguments:

    FileContext     - the process specific device context
    pClosingInfo    - all information needed for close or reset command completion
    pDlcObject      - the closed or deleted object

Return Value:

    None.

--*/

{
    BOOLEAN completeRead = FALSE;
    BOOLEAN deallocatePacket = FALSE;
    BOOLEAN derefFileContext = FALSE;

    //
    // Now we can cancel and chain all commands, that are still left,
    // if we are really closing this adapter context
    // (there should be no events any more, because the were deleted
    // with their owner objects).
    //

    if (pClosingInfo->ClosingAdapter) {
        for (;;) {

            NTSTATUS Status;

            Status = AbortCommand(
                        pFileContext,
                        DLC_IGNORE_STATION_ID,      // station id may be anything
                        DLC_STATION_MASK_ALL,       // mask for all station ids!
                        DLC_MATCH_ANY_COMMAND,      // mask for all commands
                        &pClosingInfo->pCcbLink,    // link them to here
                        pClosingInfo->CancelStatus, // cancel with this status
                        FALSE                       // Don't suppress completion
                        );
            if (Status != STATUS_SUCCESS) {
                break;
            }
            pClosingInfo->CcbCount++;
        }
    }

    //
    // The receive command must be linked to the first CCB immediately
    // after the actual cancelling command.
    //

    if (pClosingInfo->pRcvCommand != NULL) {
        CancelDlcCommand(pFileContext,
                         pClosingInfo->pRcvCommand,
                         &pClosingInfo->pCcbLink,
                         pClosingInfo->CancelStatus,
                         TRUE   // disable command completion for RECEIVE
                         );
        pClosingInfo->CcbCount++;
    }

    //
    // Should the completed commands to be saved as a completion event.
    //

    if (pClosingInfo->pCompletionInfo != NULL) {

        PDLC_COMPLETION_EVENT_INFO pCompletionInfo;

        pCompletionInfo = pClosingInfo->pCompletionInfo;

        //
        // search all receive data events destinated to the closed or
        // reset station or stations.  We must chain all those
        // buffer to the single NULL terminated list
        //

        pCompletionInfo->CcbCount = (USHORT)(pClosingInfo->CcbCount + 1);

        //
        // Save the received frames to the completion information!
        // NOTE: The received frames returned by DIR.CLOSE.ADAPTER
        // cannot be released using the same adapter handle.
        // They are released and unlocked if the closed adapter
        // was the only user of the pool.  Otherwise those frames
        // must be unlocked using another adapter handle, that
        // shares the same buffer pool.
        // !!! Actually we should automatically free all receive
        //     buffers when an adapter is closed and do not to return
        //     them to application !!!
        //

        pCompletionInfo->pReceiveBuffers = pClosingInfo->pRcvFrames;

        //
        // Execute the old READ command or queue the command completion
        // request to the command queue.
        //

        if (pClosingInfo->pReadCommand != NULL) {

            //
            // RLF 03/25/94
            //
            // See below
            //

            completeRead = TRUE;

            /*

            pClosingInfo->pReadCommand->Overlay.pfCompletionHandler(
                pFileContext,
                NULL,
                pClosingInfo->pReadCommand->pIrp,
                (UINT)pClosingInfo->Event,
                pCompletionInfo,
                0
                );

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo->pReadCommand);

            */

        } else {

            //
            // Queue the completion event, Note: we will return all
            // CCBs linked to the issued close CCB in any way.
            // It does not matter for eg. DirCloseAdapter, if there
            // is an extra event queued. It will be deleted when
            // the command completes and all memory resources are
            // released.
            //

            MakeDlcEvent(pFileContext,
                         pClosingInfo->Event,
                         pCompletionInfo->StationId,
                         NULL,
                         pCompletionInfo,
                         0,
                         pClosingInfo->FreeCompletionInfo
                         );
        }
    } else if (pFileContext->hBufferPool != NULL) {

        //
        // Free the received frames in the buffer pool, they are
        // not saved to the command completion list.
        //

        BufferPoolDeallocateList(pFileContext->hBufferPool,
                                 pClosingInfo->pRcvFrames
                                 );
    }

    //
    // DirCloseAdapter requires a special post routine, that will
    // close the NDIS binding when all pending transmits have completed
    // and the the requests have been cancelled.
    // Note: the close adapter packet is not allocated from packet pool!
    //

    /*

    //
    // RLF 08/17/94
    //

    if (pClosingInfo->pfCloseComplete != NULL) {
        pClosingInfo->pfCloseComplete(pFileContext,
                                      pClosingInfo,
                                      pClosingInfo->pCcbLink
                                      );

    } else {

    */

    if (pClosingInfo->pfCloseComplete == NULL) {
        if (pClosingInfo->pIrp != NULL) {
            CompleteDirectOutIrp(pClosingInfo->pIrp,
                                 STATUS_SUCCESS,
                                 pClosingInfo->pCcbLink
                                 );
            CompleteAsyncCommand(pFileContext,
                                 STATUS_SUCCESS,
                                 pClosingInfo->pIrp,
                                 pClosingInfo->pCcbLink,
                                 FALSE
                                 );
        }

#if LLC_DBG
        pClosingInfo->pNext = NULL;
#endif

        //
        // RLF 03/25/94
        //
        // More asynchronicity with READs causing fatal errors in an application.
        // This actual case was in HPMON:
        //
        //      1. application submits DLC.CLOSE.STATION
        //      2. this routine puts DLC.CLOSE.STATION command in command complete
        //         list of READ parameter table. READ IRP is completed
        //      3. app gets READ completion, sees DLC.CLOSE.STATION is complete
        //         and frees DLC.CLOSE.STATION CCB to heap: heap manager writes
        //         signature data over freed CCB
        //      4. this routine completes original DLC.CLOSE.STATION IRP, writing
        //         8 bytes over original CCB, now just part of heap
        //      5. some time later, heap allocation request made. Heap manager
        //         finds the heap has been trashed and goes on strike
        //

        if (completeRead) {
            pClosingInfo->pReadCommand->Overlay.pfCompletionHandler(
                pFileContext,
                NULL,
                pClosingInfo->pReadCommand->pIrp,
                (UINT)pClosingInfo->Event,
                pClosingInfo->pCompletionInfo,
                0
                );

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo->pReadCommand);

        }

        //
        // RLF 08/17/94
        //
        // don't deallocate the packet now - we may need to use it if we call
        // the close completion handler below
        //

        deallocatePacket = TRUE;

        /*
        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo);
        */

    }

    //
    // RLF 08/17/94
    //
    // Moved the DirCloseAdapter processing here to give the client chance to
    // receive the event before we close the adapter and maybe kill the file
    // context
    //

    if (pClosingInfo->pfCloseComplete) {

        //
        // RLF 08/17/94
        //
        // This is bad: this close complete call may cause the file context to
        // become completely dereferenced, and hence free it and its buffer
        // pools. But we still have the closing info packet allocated, so
        // increase the reference count, free up the packet below, then deref
        // the file context again, and cause it to be deleted (if that would
        // have happened anyway)
        //

        ReferenceFileContext(pFileContext);
        derefFileContext = TRUE;

        pClosingInfo->pfCloseComplete(pFileContext, pClosingInfo, pClosingInfo->pCcbLink);
    }

    if (deallocatePacket) {
        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo);
    }

    if (derefFileContext) {
        DereferenceFileContext(pFileContext);
    }
}


VOID
CleanUpEvents(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PDLC_OBJECT pDlcObject
    )

/*++

Routine Description:

    The primitive cleans up or modifies all events having a pointer
    to the closed station object.  This also chains one and only one
    transmit ccb chain to the end of CCB chain, because the completed
    commands (as transmit and command completion events in the event queue)
    cannot be linked any more to other commands.  Thus there can be
    only one single chain in the end of the actual chain of the pending
    commands.

    This routines cleans up the commands as well.

Arguments:

    FileContext     - the process specific device context
    pClosingInfo    - all information needed for close or reset command
                      completion
    pDlcObject      - the closed or deleted object

Return Value:

    STATUS_SUCCESS

--*/

{
    PDLC_EVENT pNextEvent;
    PDLC_EVENT pEvent;
    BOOLEAN RemoveNextPacket;

    for (pEvent = (PDLC_EVENT)pFileContext->EventQueue.Flink;
        pEvent != (PDLC_EVENT)&pFileContext->EventQueue;
        pEvent = pNextEvent) {

        pNextEvent = (PDLC_EVENT)pEvent->LlcPacket.pNext;

        if (pEvent->pOwnerObject == pDlcObject) {

            //
            //  By defult we free the next packet
            //

            RemoveNextPacket = TRUE;

            switch (pEvent->Event) {
            case LLC_RECEIVE_DATA:

                //
                //  The received frames are saved to circular lists,
                //  where the head points to the newest frame and
                //  the next element from it is the oldest one.
                //  We simply the new frames to the old head of list.
                //

                if (pClosingInfo->pRcvFrames == NULL) {
                    pClosingInfo->pRcvFrames = pEvent->pEventInformation;
                } else {

                    //
                    //  Initial state:
                    //      H1 = N1->O1...->N1  and  H2 = N2->O2...->N2
                    //
                    //  End state:
                    //      H1 = N1->O2...->N2->O1...->N1
                    //
                    //  => Operations must be:
                    //      Temp = H2->Next;
                    //      H2->Next = H1->Next;
                    //      H1->Next = Temp;
                    //  (where H = list head, N = newest element, O = oldest)
                    //

                    PDLC_BUFFER_HEADER pTemp;

                    pTemp = ((PDLC_BUFFER_HEADER)pEvent->pEventInformation)->FrameBuffer.pNextFrame;
                    ((PDLC_BUFFER_HEADER)pEvent->pEventInformation)->FrameBuffer.pNextFrame =
                        ((PDLC_BUFFER_HEADER)pClosingInfo->pRcvFrames)->FrameBuffer.pNextFrame;
                    ((PDLC_BUFFER_HEADER)pClosingInfo->pRcvFrames)->FrameBuffer.pNextFrame = pTemp;
                }
                pDlcObject->pReceiveEvent = NULL;
                break;

            case LLC_TRANSMIT_COMPLETION:

                //
                //  We cannot do nothing for single transmit commands, because
                //  they have already been completed, and the completed CCBs
                //  cannot any more be linked together.  Thus we leave
                //  them to the event queue and will hope, that somebody
                //  will read them from the event queue.  The memory is
                //  released when the file context is closed (eg. file close in
                //  the process exit).  We just reset the dlc object pointer,
                //  that nobody would later use invalid pointer.
                //
                //  The transmit commands chained of one closed station can
                //  be removed from the event list and chained to
                //  the end of the CCBs, BUT ONLY ONE!  All other
                //  transmit completion events must be saved as a normal
                //  events with an invalid CCB count!!!!!
                //

                if (pClosingInfo->pCcbLink == NULL && pClosingInfo->ChainCommands) {
                    pClosingInfo->pCcbLink = pDlcObject->pPrevXmitCcbAddress;
                    pClosingInfo->CcbCount += pDlcObject->ChainedTransmitCount;
                } else {

                    //
                    //  We must change the format of this transmit completion
                    //  into the similar to the command completion event
                    //  packet of close command.  Otherwise the application
                    //  could lose the transmit CCBs, when it closes or
                    //  resets a station.
                    //

                    PDLC_COMPLETION_EVENT_INFO pCompletionInfo;

                    pCompletionInfo = (PDLC_COMPLETION_EVENT_INFO)
                                        ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

                    if (pCompletionInfo != NULL) {
                        pCompletionInfo->CcbCount = pDlcObject->ChainedTransmitCount;
                        pCompletionInfo->pCcbAddress = pDlcObject->pPrevXmitCcbAddress;
                        pCompletionInfo->CommandCompletionFlag = pEvent->SecondaryInfo;
                        pEvent->SecondaryInfo = 0;
                        pEvent->pEventInformation = pCompletionInfo;
                        pEvent->bFreeEventInfo = TRUE;
                        RemoveNextPacket = FALSE;
                    }
                }
                break;

                //
                //  case DLC_COMMAND_COMPLETION ?
                //  The command completions have been saved without the
                //  the link to the Dlc structure -> they are automatically
                //  left into the completion queue.
                //

            case LLC_STATUS_CHANGE:

                //
                //  Link station status changes cannot mean anytging after the
                //  link station has been deleted.
                //

                break;

#if LLC_DBG
            default:
                LlcInvalidObjectType();
                break;
#endif
            };
            if (RemoveNextPacket) {
                LlcRemoveEntryList(pEvent);

                DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pEvent);

            } else {

                //
                //  We must remove the reference to the deleted object
                //

                pEvent->pOwnerObject = NULL;
            }
        }
    }

    //
    //  The optional receive command must be removed first, otherwise
    //  it is cancelled with the other commands given to the deleted
    //  object.
    //

    if (pClosingInfo->CancelReceive && pDlcObject->pRcvParms != NULL) {

        //
        //  The receive command linked to the DLC object is a special case:
        //  we must link it immediately after the close CCB
        //

        pClosingInfo->pRcvCommand = SearchAndRemoveAnyCommand(
                                        pFileContext,
                                        (ULONG)(-1),
                                        (USHORT)DLC_IGNORE_STATION_ID,
                                        (USHORT)DLC_STATION_MASK_SPECIFIC,
                                        pDlcObject->pRcvParms->Async.Ccb.pCcbAddress
                                        );
        pDlcObject->pRcvParms = NULL;
    }

    //
    //  Cleanup the commands given to the dleted object
    //

    for (;;) {

        NTSTATUS Status;

        Status = AbortCommand(pFileContext,
                              pDlcObject->StationId,
                              (USHORT)(pDlcObject->Type == (UCHAR)DLC_SAP_OBJECT
                                ? DLC_STATION_MASK_SAP
                                : DLC_STATION_MASK_SPECIFIC),
                              DLC_IGNORE_SEARCH_HANDLE,
                              &pClosingInfo->pCcbLink,
                              pClosingInfo->CancelStatus,
                              FALSE                       // Don't suppress completion
                              );
        if (Status != STATUS_SUCCESS) {
           break;
        }

        //
        //  Now we can cancel and chain all commands destinated to the
        //  closed/reset station id.
        //  We always complete the commands given to the deletcd object,
        //  but we chain them together only if this flag has been set.
        //

        if (pClosingInfo->ChainCommands == FALSE) {

            //
            //  Don't link the cancelled CCBs together
            //

            pClosingInfo->pCcbLink = NULL;
        } else {
            pClosingInfo->CcbCount++;
        }
    }
}


VOID
SearchReadCommandForClose(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbAddress,
    IN ULONG CommandCompletionFlag,
    IN USHORT StationId,
    IN USHORT StationIdMask
    )

/*++

Routine Description:

    The primitive searches a read command for a close command
    and saves it into the closing info structure.

Arguments:

    FileContext     - the process specific device context
    pClosingInfo    - all information needed for close or reset command
                      completion
    pCcbAddress     - ccb address of the searched read command
    StationId       -
    StationIdMask   -

Return Value:

    None.

--*/

{
    //
    // Allocate the parameter buffer for command completion with
    // read if it is needed OR if we are closing everything because
    // of a critical exception (ie. pIrp == NULL)
    //

    pClosingInfo->pCompletionInfo = (PDLC_COMPLETION_EVENT_INFO)
                                        ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pClosingInfo->pCompletionInfo != NULL) {

        pClosingInfo->FreeCompletionInfo = TRUE;

        //
        // We must link all commands given to the deleted objects
        //

        pClosingInfo->pCompletionInfo->pCcbAddress = pCcbAddress;
        pClosingInfo->pCompletionInfo->CommandCompletionFlag = CommandCompletionFlag;
        pClosingInfo->ChainCommands = TRUE;

        //
        // A link station close command we be read as a command completion
        // on its sap, but the other close commands cannot use any station id
        //

        if (StationIdMask == DLC_STATION_MASK_SPECIFIC) {
            pClosingInfo->pCompletionInfo->StationId = (USHORT)(StationId & DLC_STATION_MASK_SAP);
        } else {
            pClosingInfo->pCompletionInfo->StationId = 0;
        }

        //
        // Search first a special READ command dedicated only for
        // this command completion.  We must read the optional
        // read command NOW. Otherwise it will be canceled
        // with the other commands, that have been given for
        // the deleted station(s).
        //

        pClosingInfo->pReadCommand = SearchAndRemoveCommandByHandle(
                                            &pFileContext->CommandQueue,
                                            pClosingInfo->Event,
                                            (USHORT)DLC_IGNORE_STATION_ID,
                                            (USHORT)DLC_STATION_MASK_SPECIFIC,
                                            pCcbAddress
                                            );
        if (pClosingInfo->pReadCommand == NULL) {

            //
            // We do not really care about the result, because
            // it is OK to return NULL.  This completion event
            // may be read sometime later.
            //

            pClosingInfo->pReadCommand = SearchAndRemoveCommand(
                                            &pFileContext->CommandQueue,
                                            pClosingInfo->Event,
                                            StationId,
                                            StationIdMask
                                            );
        }
    }
}


VOID
CompleteLlcObjectClose(
    IN PDLC_OBJECT pDlcObject
    )

/*++

Routine Description:

    This routine just derefernces a llc object, when its reference count
    in DLC driver has been decremented to zero.
    The reference count is used to prevent the closing of llc object
    when it is simultaneously called elsewhere (that would invalidate
    the llc object pointer)

Arguments:

    pDlcObject  - any DLC object.

Return Value:

    none

--*/

{
    PVOID hLlcObject = pDlcObject->hLlcObject;

    if (hLlcObject != NULL) {

        DLC_TRACE('P');

        pDlcObject->hLlcObject = NULL;
        LEAVE_DLC(pDlcObject->pFileContext);

        LlcDereferenceObject(hLlcObject);

        ENTER_DLC(pDlcObject->pFileContext);
    }
}


BOOLEAN
DecrementCloseCounters(
    PDLC_FILE_CONTEXT pFileContext,
    PDLC_CLOSE_WAIT_INFO pClosingInfo
    )

/*++

Routine Description:

    This routine decrements the count of existing objects in the
    chianed close command packets and completes the close commands,
    if the count of the existing objects hits zero.

Arguments:

    pFileContext    - file handle context
    pClosingInfo    - close command packet

Return Value:

    BOOLEAN
        TRUE    - all pending close/resets have been completed
        FALSE   - close/resets still pending

--*/

{
    PDLC_CLOSE_WAIT_INFO pNextClosingInfo;
    UINT loopCounter, closeCounter;

    //
    //  Complete the reset command if all objects have been deleted,
    //  There may be another DirCloseAdapter chained its next pointer
    //

    for (loopCounter = 0, closeCounter = 0;
        pClosingInfo != NULL;
        pClosingInfo = pNextClosingInfo, ++loopCounter) {

        pNextClosingInfo = pClosingInfo->pNext;
        pClosingInfo->CloseCounter--;
        if (pClosingInfo->CloseCounter == 0) {

            //
            // Call the completion routine of the close command.
            // We don't need to check the status code.
            //

            CompleteCloseReset(pFileContext, pClosingInfo);
            ++closeCounter;
        }
    }

    //
    // if we completed every close/reset we found then return TRUE
    //

    return loopCounter == closeCounter;
}


VOID
CompleteDirectOutIrp(
    IN PIRP Irp,
    IN UCHAR Status,
    IN PLLC_CCB NextCcb
    )

/*++

Routine Description:

    For an IRP submitted as method DIRECT_OUT (DLC.CLOSE.STATION) complete the
    CCB in user space by getting the mapped system address of the CCB and update
    it with the completion code and next CCB pointer

Arguments:

    Irp     - pointer to DIRECT_OUT IRP to complete
    Status  - DLC status code
    NextCcb - pointer to next CCB to chain

Return Value:

    None.

--*/

{
    PLLC_CCB ccb;

    ccb = (PLLC_CCB)MmGetSystemAddressForMdl(Irp->MdlAddress);
    RtlStoreUlongPtr((PULONG_PTR)&ccb->pNext, (ULONG_PTR)NextCcb);
    ccb->uchDlcStatus = Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcinfo.c

Abstract:

    The module implements the Query/Set information commands.
    It also provides the statistics services for DLC api.

    Contents:
        GetDlcErrorCounters
        DlcQueryInformation
        DlcSetInformation
        GetOpenSapAndStationCount
        SetupGroupSaps

Author:

    Antti Saarenheimo (o-anttis) 29-AUG-1991

Revision History:

--*/

#include <dlc.h>

static ULONG aTokenringLogOid[ADAPTER_ERROR_COUNTERS] = {
    OID_802_5_LINE_ERRORS,
    0,
    OID_802_5_BURST_ERRORS,
    OID_802_5_AC_ERRORS,
    OID_802_5_ABORT_DELIMETERS,
    0,
    OID_802_5_LOST_FRAMES,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_5_FRAME_COPIED_ERRORS,
    OID_802_5_FREQUENCY_ERRORS,
    OID_802_5_TOKEN_ERRORS
};

static ULONG aEthernetLogOid[ADAPTER_ERROR_COUNTERS] = {
    OID_802_3_XMIT_TIMES_CRS_LOST,
    0,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    0,
    OID_GEN_XMIT_ERROR,
    0,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_GEN_RCV_NO_BUFFER,
    0,
    0,
    0
};

static ULONG aFddiLogOid[ADAPTER_ERROR_COUNTERS] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};


VOID
GetDlcErrorCounters(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PUCHAR pAdapterErrors
    )

/*++

Routine Description:

    Procedure reads the cumulative 32-bit adapter error counters from
    ethernet or token-ring adapter and returns 8-bit DLC error counters,
    that supports read and read & reset commands.  It also maintains
    local copies of the NDIS error counters in the process specific
    adapter context, because NDIS counters cannot be reset.

Arguments:

    pFileContext    - DLC address object
    pAdapterErrors  - DLC errors counters, if NULL => NDIS values are
                      copied to file context.

Return Value:

    None.

--*/

{
    LLC_NDIS_REQUEST Request;
    PULONG pOidBuffer;
    ULONG counter;
    UINT i;
    UINT Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Token-ring and ethernet uses different error counters
    //

    switch (pFileContext->ActualNdisMedium) {
    case NdisMedium802_3:
        pOidBuffer = aEthernetLogOid;
        break;

    case NdisMedium802_5:
        pOidBuffer = aTokenringLogOid;
        break;

    case NdisMediumFddi:
        pOidBuffer = aFddiLogOid;
        break;
    }

    //
    // read all error counters having non null NDIS OID and
    // decrement the previous error count value from it.
    // Overflowed DLC error counter is set 255 (the maximum).
    //

    Request.Ndis.RequestType = NdisRequestQueryInformation;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer = &counter;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(counter);

    for (i = 0; i < ADAPTER_ERROR_COUNTERS; i++) {
        if (pOidBuffer[i] != 0) {

            Request.Ndis.DATA.QUERY_INFORMATION.Oid = pOidBuffer[i];

            LEAVE_DLC(pFileContext);

            RELEASE_DRIVER_LOCK();

            Status = LlcNdisRequest(pFileContext->pBindingContext, &Request);

            ACQUIRE_DRIVER_LOCK();

            ENTER_DLC(pFileContext);

            if (Status != STATUS_SUCCESS) {

#if DBG
				if ( Status != STATUS_NOT_SUPPORTED ){
					// Only print real errors.
					DbgPrint("DLC.GetDlcErrorCounters: LlcNdisRequest returns %x\n", Status);
				}
#endif

                counter = 0;
            } else if ((counter - pFileContext->NdisErrorCounters[i] > 255)
            && (pAdapterErrors != NULL)) {
                counter = 255;
            } else {
                counter -= pFileContext->NdisErrorCounters[i];
            }
            if (pAdapterErrors != NULL) {
                pAdapterErrors[i] = (UCHAR)counter;
            }
            pFileContext->NdisErrorCounters[i] += counter;
        }
    }
}


NTSTATUS
DlcQueryInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    The routine returns the DLC specific information of any DLC object.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - the length of output parameters

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        STATUS_INVALID_COMMAND

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID hClientHandle = pFileContext->pBindingContext;
    PDLC_OBJECT pDlcObject;
    PLLC_ADAPTER_DLC_INFO pDlcAdapter;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // NOTE: DlcQueryBuffer output buffer size was not checked by 
    //       DlcDeviceIoControl. For each class we check the size
    //       based on what it will copy. Although it did check that
    //       the input buffer size was at least NT_DLC_QUERY_INFORMATION_INPUT
    //       size.
    //

    switch (pDlcParms->DlcGetInformation.Header.InfoClass) {
    case DLC_INFO_CLASS_DLC_ADAPTER:

        // union NT_DLC_PARMS
        //     LLC_ADAPTER_DLC_INFO     
        if (OutputBufferLength < sizeof(LLC_ADAPTER_DLC_INFO))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // The output data is just written to the
        // beginning of the current system buffer.
        //

        pDlcAdapter = (PLLC_ADAPTER_DLC_INFO)pDlcParms;
        GetOpenSapAndStationCount(pFileContext,
                                  &pDlcAdapter->OpenSaps,
                                  (PUCHAR)&pDlcAdapter->OpenStations
                                  );
        pDlcAdapter->MaxSap = 127;
        pDlcAdapter->MaxStations = 255;
        pDlcAdapter->AvailStations = (UCHAR)255 - pDlcAdapter->OpenStations;
        break;

    case DLC_INFO_CLASS_ADAPTER_LOG:

        // union NT_DLC_PARMS   (pDlcParms)
        //     union NT_DLC_QUERY_INFORMATION_PARMS DlcGetInformation
        //         union NT_DLC_QUERY_INFORMATION_OUTPUT Info
        //             union LLC_ADAPTER_LOG  AdapterLog
        if (OutputBufferLength < sizeof(LLC_ADAPTER_LOG))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        GetDlcErrorCounters(pFileContext, (PUCHAR)&pDlcParms->DlcGetInformation);
        break;

    case DLC_INFO_CLASS_LINK_STATION:
        
        // union NT_DLC_PARMS (pDlcParms)
        //     union NT_DLC_QUERY_INFORMATION_PARMS DlcGetInformation
        //         union NT_DLC_QUERY_INFORMATION_OUTPUT Info
        //             struct _DlcLinkInfoGet
        //                  USHORT MaxInformationField
        if (OutputBufferLength < sizeof(USHORT))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        Status = GetLinkStation(pFileContext,
                                pDlcParms->DlcGetInformation.Header.StationId,
                                &pDlcObject
                                );
        if (Status == STATUS_SUCCESS) {

            //
            // Round always the information field length to the full
            // dword even number => some copy operations may be much
            // faster (usually not, but worth of effor in any way)
            //

            pDlcParms->DlcGetInformation.Info.Link.MaxInformationField = (USHORT)(pDlcObject->u.Link.MaxInfoFieldLength & -3);
        }
        break;

    case DLC_INFO_CLASS_STATISTICS:
    case DLC_INFO_CLASS_STATISTICS_RESET:
        Status = GetStation(pFileContext,
                            pDlcParms->DlcGetInformation.Header.StationId,
                            &pDlcObject
                            );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        hClientHandle = pDlcObject->hLlcObject;

        //
        // **** FALL THROUGH ****
        //

    default:

        //
        //  LLC will return invalid command, if it is not supported
        //

        LEAVE_DLC(pFileContext);

        RELEASE_DRIVER_LOCK();

        //
        // LlcQueryInformation validates buffer size before copying.
        //

        Status = LlcQueryInformation(hClientHandle,
                                     pDlcParms->DlcGetInformation.Header.InfoClass,
                                     (PLLC_QUERY_INFO_BUFFER)&(pDlcParms->DlcGetInformation),
                                     (UINT)OutputBufferLength
                                     );

        ACQUIRE_DRIVER_LOCK();

        ENTER_DLC(pFileContext);

        break;
    }
    return (NTSTATUS)Status;
}


NTSTATUS
DlcSetInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:


    The routine sets new parameter values for the DLC objects.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS
        STATUS_SUCCESS
        STATUS_INVALID_COMMAND
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDLC_OBJECT pDlcObject;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    switch (pDlcParms->DlcSetInformation.Header.InfoClass) {
    case DLC_INFO_CLASS_LINK_STATION:
    case DLC_INFO_CLASS_DIRECT_INFO:
        Status = GetStation(pFileContext,
                            pDlcParms->DlcSetInformation.Header.StationId,
                            &pDlcObject
                            );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pDlcObject->hLlcObject,
                                   pDlcParms->DlcSetInformation.Header.InfoClass,
                                   (PLLC_SET_INFO_BUFFER)&(
                                   pDlcParms->DlcSetInformation.Info.LinkStation),
                                   sizeof(DLC_LINK_PARAMETERS)
                                   );
        break;

    case DLC_INFO_CLASS_DLC_TIMERS:

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pFileContext->pBindingContext,
                                   pDlcParms->DlcSetInformation.Header.InfoClass,
                                   (PLLC_SET_INFO_BUFFER)&(pDlcParms->DlcSetInformation.Info.TimerParameters),
                                   sizeof(LLC_TICKS)
                                   );
        break;

    case DLC_INFO_CLASS_SET_FUNCTIONAL:
    case DLC_INFO_CLASS_RESET_FUNCTIONAL:
    case DLC_INFO_CLASS_SET_GROUP:
    case DLC_INFO_CLASS_SET_MULTICAST:

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pFileContext->pBindingContext,
                                   pDlcParms->DlcSetInformation.Header.InfoClass,
                                   (PLLC_SET_INFO_BUFFER)&(pDlcParms->DlcSetInformation.Info.Broadcast),
                                   sizeof(TR_BROADCAST_ADDRESS)
                                   );
        break;

    case DLC_INFO_CLASS_GROUP:

        //
        // Setup DLC group SAPs.  Group saps are used as a common address
        // of a SAP group.  They can only receive frames.
        //

        Status = GetStation(pFileContext,
                            pDlcParms->DlcSetInformation.Header.StationId,
                            &pDlcObject
                            );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }
        Status = SetupGroupSaps(pFileContext,
                                pDlcObject,
                                (UINT)pDlcParms->DlcSetInformation.Info.Sap.GroupCount,
                                (PUCHAR)pDlcParms->DlcSetInformation.Info.Sap.GroupList
                                );
        LEAVE_DLC(pFileContext);

        break;

    default:

        LEAVE_DLC(pFileContext);

        Status = DLC_STATUS_INVALID_COMMAND;
        break;
    };

    ENTER_DLC(pFileContext);

    return Status;
}


//
// Function returns the number of open sap and link
// stations for a dlc application.
//
VOID
GetOpenSapAndStationCount(
    IN PDLC_FILE_CONTEXT pFileContext,
    OUT PUCHAR pOpenSaps,
    OUT PUCHAR pOpenStations
    )
{
    UINT i, SapCount = 0;

    for (i = 1; i < MAX_SAP_STATIONS; i++) {
        if (pFileContext->SapStationTable[i] != NULL) {
            SapCount++;
        }
    }
    *pOpenSaps = (UCHAR)SapCount;
    if (pFileContext->SapStationTable[0] != NULL) {
        SapCount++;
    }
    *pOpenStations = (UCHAR)(pFileContext->DlcObjectCount - SapCount);
}


NTSTATUS
SetupGroupSaps(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN UINT GroupSapCount,
    IN PUCHAR pGroupSapList
    )

/*++

Routine Description:

    The routine deletes the current group saps list and
    and new group saps. Fi the new group sap list is empty, then
    we just delete all current group saps.

Arguments:

    pFileContext    - DLC context
    pDlcObject      - SAP object
    GroupSapCount   - number of new group saps
    pGroupSapList   - list of new group saps

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        STATUS_INVALID_COMMAND

--*/

{
    UINT i;
    UINT OpenOptions;

    //
    // We must first remove all old groups sap defined for the
    // sap station (if any)
    //

    if (pDlcObject->u.Sap.GroupSapHandleList != NULL) {
        for (i = 0; i < pDlcObject->u.Sap.GroupSapCount; i++) {
            if (pDlcObject->u.Sap.GroupSapHandleList[i] != NULL) {

                LEAVE_DLC(pFileContext);

                LlcCloseStation(pDlcObject->u.Sap.GroupSapHandleList[i], NULL);

                ENTER_DLC(pFileContext);
            }
        }
        FREE_MEMORY_FILE(pDlcObject->u.Sap.GroupSapHandleList);
        pDlcObject->u.Sap.GroupSapHandleList = NULL;
    }

    //
    // Note: the old group saps can be deleted with a null list!
    //

    pDlcObject->u.Sap.GroupSapCount = (UCHAR)GroupSapCount;
    if (GroupSapCount != 0) {
        pDlcObject->u.Sap.GroupSapHandleList = (PVOID*)ALLOCATE_ZEROMEMORY_FILE(
                                                                GroupSapCount
                                                                * sizeof(PVOID)
                                                                );
        if (pDlcObject->u.Sap.GroupSapHandleList == NULL) {
            return DLC_STATUS_NO_MEMORY;
        }

        //
        // The groups sap implementation is based on the fact,
        // that the lower module things to run a normal sap.
        // The routing of UI, TEST and XID frames for all
        // saps sends the incoming U-frames automatically
        // all real saps registered to a sap.  This method
        // could theoretically use very much memory if there were
        // very many saps and group saps (eg: 50 * 50 = 2500 * 100),
        // but that situation is actually impossible.
        // SNA saps (3) have one command group sap and even SNA
        // sap is very rarely used (not used by CommServer)
        //

        for (i = 0; i < pDlcObject->u.Sap.GroupSapCount; i++) {

            UINT Status;

            OpenOptions = 0;
            if (~(pDlcObject->u.Sap.OptionsPriority & XID_HANDLING_BIT)) {
                OpenOptions = LLC_HANDLE_XID_COMMANDS;
            }

            LEAVE_DLC(pFileContext);

            Status = LlcOpenSap(pFileContext->pBindingContext,
                                (PVOID)pDlcObject,
                                (UINT)pGroupSapList[i] | 1,
                                OpenOptions,
                                &pDlcObject->u.Sap.GroupSapHandleList[i]
                                );

            ENTER_DLC(pFileContext);

            if (Status != STATUS_SUCCESS) {
                return Status;
            }
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcque.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcque.c

Abstract:

    This module provides primitives to manage the dlc command and
    event queues.

    Contents:
        QueueDlcEvent
        MakeDlcEvent
        IsCommandOnList
        SearchAndRemoveCommand
        SearchAndRemoveAnyCommand
        SearchAndRemoveCommandByHandle
        SearchAndRemoveSpecificCommand
        QueueDlcCommand
        AbortCommand
        CancelDlcCommand
        PurgeDlcEventQueue
        PurgeDlcFlowControlQueue

Author:

    Antti Saarenheimo 29-Aug-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include "dlcdebug.h"

/*++

Design notes about the DLC event and command queue management
-------------------------------------------------------------

In DLC API the READ command may be given before or after the actual
event has happened.  This means, that all DLC events of the READ command
must be queued and also the READ command must be queued to wait for
the set of events it was designated.

For each new DLC (READ) command the driver searches first the event queue
and then queues the command, if the desired event was not found.
The same thing is made also for the events:  the dlc command queue
is checked first and then the event is queued (if it was a read event)
or it is dropped away (if the event was not meant for READ and there
was no command waiting for it).

The events are implemented by the event masks.  The event is executed
if the result of bit-OR operation for the event masks in the command
and in the event is not zero.

All commands and receive events of a dlc station (direct, sap or link)
are returned as a DLC completion event when the station is closed.
The same operation is done also by the total reset or all sap stations
(and the only direct station).
A READ command may be used to read that command completion from
the event list.  The READ command may have been give before, in the
same time linked to the next CCB field of the close/reset command or
after the close/reset command has completed.
DirOpenAdapter command deletes all events (and commands) from the
event queue.  The received data and CCBs are not returned back, if
there is not given any READ command for that purpose.

(This has been fixed:
 There could be a minor incompatibility with IBM OS/2 DLC API,
 the NT DLC driver may not always complete a dlc command with
 the READ command linked to commmand's CCB,  if there is another
 matching DLC command pending)

    Here is the solution:

    Actually we could make a special
    READ command, that is chained to the very end of the command queue
    and that can be matched only with a CCB pointer of the completed
    DLC command.  We could modify the command aborting to support also
    this case, and there should be a special CCB input field in the
    NT READ for the completed command (do we also need to return
    the READ flag or command completion flag?).

----

We need at least these procedures:

MakeDlcEvent(
    pFileContext, Event, StationId, pOwnerObject, pEventInformation, SecInfo);

    - scans the command queues
    - saves the event if it can't find a matching command and
      if the command's event masks defines, that the event should be saved

QueueDlcCommand(
    pFileContext, Event, StationId, StationIdMask, pIrp, AbortHandle, pfComp );
    - scans the event queue for a matching event
    - saves the event if can't find a match

AbortCommand(
    pFileContext, Event, StationId, StationIdMask, AbortHandle, ppCcbLink );
    - aborts a command in the command queue

****** Subprocedures (used by the api functions)

PDLC_COMMAND
SearchPrevCommand(
    pQueue, EventMask, StationId, StationIdMask, SearchHandle, pPrevCommand
    - returns pointer to the previous element before the matching
      dlc command in a queue,

(Macro: SearchPrevEvent
            - searches and removes the given event from the event queue and
            returns its pointer)
--*/


VOID
QueueDlcEvent(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine tries first to find a matching event in the command
    queues and queues the DLC event if it can't find anything and if
    the event belongs to the mask of the queued commands.
    There are two event queues, both having a mask for the checked
    events.  The queue is checked only if the event bits are found
    in the mask of the queue.

Arguments:

    pFileContext    - process specific adapter context
    pPacket         - Event packet

Return Value:

    None

--*/

{
    PDLC_COMMAND pDlcCommand;

    DIAG_FUNCTION("QueueDlcEvent");

    //
    // get search mask
    //

    pPacket->Event.Overlay.StationIdMask = (USHORT)((pPacket->Event.StationId == -1) ? 0 : -1);

    //
    // DLC commands can be completed with a special READ command,
    // that is linked to the CCB pointer of the command.
    // NT DLC must queue that special read command before the
    // command that it was linked.  We must check here
    // if there is a special READ command just for this command
    // completion.
    // **************  HACK-HACK-HACK   **************
    //     Close/Reset command completions use different
    //     EventInformation from the other command completions
    //     and they search the read command by themself =>
    //     we don't need to care about it.
    //     If SeconadryInfo == 0
    //     then this is a Close/Reset command completion
    //     and we don't search the special read command.
    //
    // **************  HACK-HACK-HACK   **************
    //

    if (!IsListEmpty(&pFileContext->CommandQueue)) {

        pDlcCommand = NULL;

        if (pPacket->Event.Event == DLC_COMMAND_COMPLETION
        && pPacket->Event.SecondaryInfo != 0) {

            pDlcCommand = SearchAndRemoveCommandByHandle(
                                &pFileContext->CommandQueue,
                                (ULONG)-1,              // mask for all events
                                (USHORT)DLC_IGNORE_STATION_ID,
                                (USHORT)DLC_STATION_MASK_SPECIFIC,
                                pPacket->Event.pEventInformation
                                );
        }

        if (pDlcCommand == NULL) {
            pDlcCommand = SearchAndRemoveCommand(&pFileContext->CommandQueue,
                                                 pPacket->Event.Event,
                                                 pPacket->Event.StationId,
                                                 pPacket->Event.Overlay.StationIdMask
                                                 );
        }

        if (pDlcCommand != NULL) {

            BOOLEAN DeallocateEvent;

            DeallocateEvent = pDlcCommand->Overlay.pfCompletionHandler(
                                pFileContext,
                                pPacket->Event.pOwnerObject,
                                pDlcCommand->pIrp,
                                (UINT)pPacket->Event.Event,
                                pPacket->Event.pEventInformation,
                                pPacket->Event.SecondaryInfo
                                );

            if (DeallocateEvent) {

                DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

            }

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

            return;
        }
    }

    //
    // queue this event packet if it is to be picked up by a READ
    //

    if (pPacket->Event.Event & DLC_READ_FLAGS) {
        LlcInsertTailList(&pFileContext->EventQueue, pPacket);
    }
}


NTSTATUS
MakeDlcEvent(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN PDLC_OBJECT pDlcObject,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo,
    IN BOOLEAN FreeEventInfo
    )

/*++

Routine Description:

    The routine allocates a event packet, saves the event information
    into it and queues (or completes) the event packet.

Arguments:

    pFileContext        - process specific adapter context
    Event               - event code
    StationId           - station id the event is destined
    pDlcObject          - the optional dlc object used in the event completion
    pEventInformation   - generic event information
    SecondaryInfo       - optional misc. data
    FreeEventInfo       - TRUE if pEventInformation should be deallocated

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_EVENT pDlcEvent;

    DIAG_FUNCTION("MakeDlcEvent");

    //
    // We couldn't find any matching commands for this event and
    // this event is a queued event => allocate a packet and
    // queue the event.
    //

    pDlcEvent = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pDlcEvent ==  NULL) {
        return DLC_STATUS_NO_MEMORY;
    }
    pDlcEvent->Event = Event;
    pDlcEvent->StationId = StationId;
    pDlcEvent->pOwnerObject = pDlcObject;
    pDlcEvent->SecondaryInfo = SecondaryInfo;
    pDlcEvent->pEventInformation = pEventInformation;
    pDlcEvent->bFreeEventInfo = FreeEventInfo;
    QueueDlcEvent(pFileContext, (PDLC_PACKET)pDlcEvent);
    return STATUS_SUCCESS;
}


PDLC_COMMAND
IsCommandOnList(
    IN PVOID RequestHandle,
    IN PLIST_ENTRY List
    )

/*++

Routine Description:

    Searches the command queue of a DLC file context for a 'request handle'
    which is the address (in user space) of a command CCB, such as a READ

    If RequestHandle is located, a pointer to the DLC_COMMAND containing
    it is returned, else NULL

    Note: Assumes that handles are not shared between processes (it looks
    as though the entire driver assumes this) and this function is called
    within the context of the process to which the searched handle belongs

Arguments:

    RequestHandle   - address of CCB to look for
    List            - address of a list of DLC_COMMAND structures

Return Value:

    PDLC_COMMAND
        Success - address of located DLC_COMMAND structure containing
                  RequestHandle (in AbortHandle field)
        Failure - NULL

--*/

{
    PLIST_ENTRY entry;

    if (!IsListEmpty(List)) {
        for (entry = List->Flink; entry != List; entry = entry->Flink) {
            if (((PDLC_COMMAND)entry)->AbortHandle == RequestHandle) {
                return (PDLC_COMMAND)entry;
            }
        }
    }
    return NULL;
}


PDLC_COMMAND
SearchAndRemoveCommand(
    IN PLIST_ENTRY pQueueBase,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask
    )

/*++

Routine Description:

    The routine searches and removes the given command or event from
    command, event or receive command queue.
    The station id, its mask, event mask and search handle are used
    to define the search.

Arguments:

    pQueueBase - address of queue's base pointer

    Event - event code

    StationId - station id of this command

    StationIdMask - station id mask for the event station id

    pSearchHandle - additional search key,  this is actually an
        orginal user mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    PDLC_COMMAND pCmd;

    DIAG_FUNCTION("SearchAndRemoveCommand");

    //
    // Events and commands are both saved to entry lists and this
    // procedure is used to search a macthing event for a command
    // or vice verse.  Commands has a masks, that may defines
    // the search for a specific station id, all stations on a sap
    // or all station ids.
    // the newest element in the list and the next element is the oldest
    // The commands are always scanned from the oldest to the newest.
    //

    if (!IsListEmpty(pQueueBase)) {

        for (pCmd = (PDLC_COMMAND)pQueueBase->Flink;
             pCmd != (PDLC_COMMAND)pQueueBase;
             pCmd = (PDLC_COMMAND)pCmd->LlcPacket.pNext) {

            if ((pCmd->Event & Event)
            && (pCmd->StationId & pCmd->StationIdMask & StationIdMask)
                == (StationId & pCmd->StationIdMask & StationIdMask)) {

                LlcRemoveEntryList(pCmd);
                return pCmd;
            }
        }
    }
    return NULL;
}


PDLC_COMMAND
SearchAndRemoveAnyCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG EventMask,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID pSearchHandle
    )

/*++

Routine Description:

    The routine searches a dlc command from the normal read command queue
    for events and the special receive command queue.

Arguments:

    pQueueBase - address of queue's base pointer

    Event - event code

    StationId - station id of this command

    StationIdMask - station id mask for the event station id

    pSearchHandle - additional search key,  this is actually an
        orginal user mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    PDLC_COMMAND pDlcCommand;

    DIAG_FUNCTION("SearchAndRemoveAnyCommand");

    pDlcCommand = SearchAndRemoveCommandByHandle(&pFileContext->CommandQueue,
                                                 EventMask,
                                                 StationId,
                                                 StationIdMask,
                                                 pSearchHandle
                                                 );
    if (pDlcCommand == NULL) {
        pDlcCommand = SearchAndRemoveCommandByHandle(&pFileContext->ReceiveQueue,
                                                     EventMask,
                                                     StationId,
                                                     StationIdMask,
                                                     pSearchHandle
                                                     );
    }
    return pDlcCommand;
}


PDLC_COMMAND
SearchAndRemoveCommandByHandle(
    IN PLIST_ENTRY pQueueBase,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID pSearchHandle
    )

/*++

Routine Description:

    The routine searches and removes the given command or event from
    command, event or receive command queue using a search handle.
    This search routine is tailored to find the commands belonging
    only to the deleted object (this searches only the exact macthes).
    The other search routine supports wild cards only for the read
    commands and thus it cannot be used here.  We just want to remove
    only those commands, that read events from the deleted object but not
    from elsewhere.

Arguments:

    pQueueBase      - address of queue's base pointer
    Event           - event code or mask for the searched events
    StationId       - station id of this command
    StationIdMask   - station id mask for the event station id
    pSearchHandle   - additional search key,  this is actually an orginal user
                      mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    PDLC_COMMAND pCmd;

    DIAG_FUNCTION("SearchAndRemoveCommandByHandle");

    if (!IsListEmpty(pQueueBase)) {

        for (pCmd = (PDLC_COMMAND)pQueueBase->Flink;
             pCmd != (PDLC_COMMAND)pQueueBase;
             pCmd = (PDLC_COMMAND)pCmd->LlcPacket.pNext) {

            //
            // The event mask match always!
            //

            if ((pCmd->Event & Event)
            && (pSearchHandle == DLC_MATCH_ANY_COMMAND
            || pSearchHandle == pCmd->AbortHandle
            || (pCmd->StationId & StationIdMask) == (StationId & StationIdMask))) {

                LlcRemoveEntryList(pCmd);
                return pCmd;
            }
        }
    }
    return NULL;
}


PDLC_COMMAND
SearchAndRemoveSpecificCommand(
    IN PLIST_ENTRY pQueueBase,
    IN PVOID pSearchHandle
    )

/*++

Routine Description:

    Searches for a DLC_COMMAND structure having a specific search handle (ie
    abort handle or application CCB address). If found, removes the DLC_COMMAND
    from the queue, else returns NULL

Arguments:

    pQueueBase      - address of queue's base pointer
    pSearchHandle   - additional search key,  this is actually an orginal user
                      mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    DIAG_FUNCTION("SearchAndRemoveSpecificCommand");

    if (!IsListEmpty(pQueueBase)) {

        PDLC_COMMAND pCmd;

        for (pCmd = (PDLC_COMMAND)pQueueBase->Flink;
             pCmd != (PDLC_COMMAND)pQueueBase;
             pCmd = (PDLC_COMMAND)pCmd->LlcPacket.pNext) {

            //
            // The event mask match always!
            //

            if (pSearchHandle == pCmd->AbortHandle) {
                LlcRemoveEntryList(pCmd);
                return pCmd;
            }
        }
    }
    return NULL;
}


NTSTATUS
QueueDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PIRP pIrp,
    IN PVOID AbortHandle,
    IN PFCOMPLETION_HANDLER pfCompletionHandler
    )

/*++

Routine Description:

    The routine tries first to find a matching event in the event
    queue and  queues the DLC command if it can't find an event.

Arguments:

    pFileContext        - process specific adapter context
    Event               - event code
    StationId           - station id the event is destined
    StationIdMask       - mask used to define the destination station group
    pIrp                - the i/o request packet of the related DLC command,
                          link to the input and output parameters.
    AbortHandle         - handle used to cancel the command from the queue
    pfCompletionHandler - completion handler of the command, called when a
                          matching event has been found.

Return Value:

    NTSTATUS

--*/

{
    PDLC_COMMAND pDlcCommand;
    PDLC_EVENT pEvent;

    DIAG_FUNCTION("QueueDlcCommand");

    pEvent = SearchAndRemoveEvent(&pFileContext->EventQueue,
                                  Event,
                                  StationId,
                                  StationIdMask
                                  );
    if (pEvent != NULL) {

        BOOLEAN DeallocateEvent;

        DeallocateEvent = pfCompletionHandler(pFileContext,
                                              pEvent->pOwnerObject,
                                              pIrp,
                                              (UINT)pEvent->Event,
                                              pEvent->pEventInformation,
                                              pEvent->SecondaryInfo
                                              );
        if (DeallocateEvent) {

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pEvent);

        }
    } else {

        //
        // We couldn't find any matching command for this event and
        // this event is a queued event => allocate a packet and
        // queue the event.
        //

        pDlcCommand = (PDLC_COMMAND)ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pDlcCommand ==  NULL) {
            return DLC_STATUS_NO_MEMORY;
        }
        pDlcCommand->Event = Event;
        pDlcCommand->pIrp = pIrp;
        pDlcCommand->StationId = StationId;
        pDlcCommand->StationIdMask = StationIdMask;
        pDlcCommand->AbortHandle = AbortHandle;
        pDlcCommand->Overlay.pfCompletionHandler = pfCompletionHandler;

        //
        // The permanent receive commands, that do not actually read
        // anuting (just enable the data receiving) are put to another
        // queue to speed up the search of the read commands.
        //

        if (Event == LLC_RECEIVE_COMMAND_FLAG) {
            LlcInsertTailList(&pFileContext->ReceiveQueue, pDlcCommand);
        } else {
            LlcInsertTailList(&pFileContext->CommandQueue, pDlcCommand);
        }

        //
        // Asynchronous commands returns ALWAYS the pending status.
        //
    }
    return STATUS_PENDING;
}


NTSTATUS
AbortCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID AbortHandle,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    )

/*++

Routine Description:

    The routine searches and cancels a command from a command queue.
    The commands must always belong to the defined DLC object.
    A NULL value in abort handle selects all matching commands
    found in the queue.

Arguments:

    pFileContext                -
    StationId                   - station id the searched command is destined for
    StationIdMask               - station id mask used in the search
    AbortHandle                 - handle used to cancel the command from the
                                  queue. The whole command queue will be scanned
                                  if this handle is NULL
    ppCcbLink                   - the canceled commands are linked by their next
                                  CCB pointer fieldsr. The caller must provide
                                  the next CCB address in this parameter
                                  (usually *ppCcbLink == NULL) and the function
                                  will return the address of the last cancelled
                                  CCB field.
    CancelStatus                - Status for the command to be canceled
    SuppressCommandCompletion   - the flag is set, if the normal command
                                  completion is suppressed.

Return Value:

     - no mathing command was found
    STATUS_SUCCESS - the command was canceled

--*/

{
    PDLC_COMMAND pDlcCommand;

    DIAG_FUNCTION("AbortCommand");

    pDlcCommand = SearchAndRemoveAnyCommand(pFileContext,
                                            (ULONG)(-1), // search all commands
                                            StationId,
                                            StationIdMask,
                                            AbortHandle
                                            );
    if (pDlcCommand == NULL && AbortHandle == DLC_MATCH_ANY_COMMAND) {
        pDlcCommand = pFileContext->pTimerQueue;
        if (pDlcCommand != NULL) {
            pFileContext->pTimerQueue = (PDLC_COMMAND)pDlcCommand->LlcPacket.pNext;
        }
    }
    if (pDlcCommand != NULL) {
        CancelDlcCommand(pFileContext,
                         pDlcCommand,
                         ppCcbLink,
                         CancelStatus,
                         SuppressCommandCompletion
                         );
        return STATUS_SUCCESS;
    } else {
        return DLC_STATUS_INVALID_CCB_POINTER;
    }
}


VOID
CancelDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMMAND pDlcCommand,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    )

/*++

Routine Description:

    The cancels and optionally completes the given DLC command. Called when one
    DLC I/O request is used to kill another (e.g. READ.CANCEL, DIR.TIMER.CANCEL)

Arguments:

    pFileContext                -
    pDlcCommand                 -
    ppCcbLink                   - the canceled commands are linked by their next
                                  CCB pointer fields. The caller must provide
                                  the next CCB address in this parameter
                                  (usually *ppCcbLink == NULL) and the function
                                  will return the address of the last cancelled
                                  CCB field
    CancelStatus                - Status for the command to be canceled
    SuppressCommandCompletion   - if set, normal command completion is suppressed

Return Value:

    None

--*/

{
    PVOID pOldCcbLink;

    DIAG_FUNCTION("CancelDlcCommand");

    //
    // We must return the current CCB link to be linked to the next cancelled
    // CCB command (or to the CCB pointer of cancelling command). But first
    // save the previous CCB link before we read a new one
    //

    pOldCcbLink = *ppCcbLink;
    *ppCcbLink = ((PNT_DLC_PARMS)pDlcCommand->pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;

    //
    // Check if we must suppress any kind of command completion indications to
    // the applications. I/O system should not care, if its event handle is
    // removed
    //

    if (SuppressCommandCompletion) {
        pDlcCommand->pIrp->UserEvent = NULL;
    }
    CompleteAsyncCommand(pFileContext, CancelStatus, pDlcCommand->pIrp, pOldCcbLink, FALSE);

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

}


VOID
PurgeDlcEventQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Deletes all events from a FILE_CONTEXT event queue. Called when the
    FILE_CONTEXT is being deleted and before we deallocate the packet pool from
    which the events were allocated

Arguments:

    pFileContext    - pointer to FILE_CONTEXT owning the queue

Return Value:

    None.

--*/

{
    PDLC_EVENT p;

    while (!IsListEmpty(&pFileContext->EventQueue)) {
        p = (PDLC_EVENT)RemoveHeadList(&pFileContext->EventQueue);
        if (p->bFreeEventInfo && p->pEventInformation) {

#if DBG
            DbgPrint("PurgeDlcEventQueue: deallocating pEventInformation: %x\n", p->pEventInformation);
#endif

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, p->pEventInformation);

        }

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, p);

    }
}


VOID
PurgeDlcFlowControlQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Deletes all packets from the flow control queue. Called when the FILE_CONTEXT
    is being deleted and before we deallocate the packet pool from which flow
    control packets were allocated

Arguments:

    pFileContext    - pointer to FILE_CONTEXT owning the queue

Return Value:

    None.

--*/

{
    PDLC_RESET_LOCAL_BUSY_CMD p;

    while (!IsListEmpty(&pFileContext->FlowControlQueue)) {
        p = (PDLC_RESET_LOCAL_BUSY_CMD)RemoveHeadList(&pFileContext->FlowControlQueue);

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, p);

    }
}


/*
//
//  Internal consistency check to hunt a bougus event in the event queue.
//
//extern BOOLEAN EventCheckDisabled;
//
int
CheckEventQueue(
    PDLC_FILE_CONTEXT   pFileContext
    )
{
    static PDLC_FILE_CONTEXT   pOldFileContext = NULL;

    if (pFileContext == NULL)
    {
        pFileContext = pOldFileContext;
    }
    else
    {
        pOldFileContext = pFileContext;
    }
    if (pFileContext == NULL)
        return 0;

    if (!IsListEmpty( &pFileContext->EventQueue ) &&
        pFileContext->EventQueue.Flink == pFileContext->EventQueue.Blink &&
        &pFileContext->EventQueue != pFileContext->EventQueue.Flink->Flink)
    {
        FooDebugBreak();
    }
    return 0;
}

int
FooDebugBreak()
{
    INT i;

    return i++;
}
*/
//    PDLC_EVENT  pEvent;
//
//    if (EventCheckDisabled || pFileContext->AdapterNumber != 0 ||
//        pFileContext->EventQueue == NULL)
//        return;
//
//    pEvent = (PDLC_EVENT)pFileContext->pEventQueue->LlcPacket.pNext;
//    for (;;)
//    {
//        if (pEvent->Event == LLC_STATUS_CHANGE &&
//            pEvent->pOwnerObject == NULL)
//            DebugBreak();
//        if (pEvent == pFileContext->pEventQueue)
//            break;
//        pEvent = (PDLC_EVENT)pEvent->LlcPacket.pNext;
//    }
//}
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcreg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcreg.h

Abstract:

    Defines, Structures, Typedefs, Macros, Externs and Prototypes for dlcreg.c

Author:

    Richard L Firth (rfirth) 31-Mar-1993

Revision History:

    30-Mar-1993 rfirth
        created

    04-May-1994 rfirth
        Exposed GetAdapterParameters

--*/

#ifndef _DLCREG_
#define _DLCREG_

//
// manifests
//

#define PARAMETER_AS_SPECIFIED      ((ULONG)-1)
#define PARAMETER_IS_BOOLEAN        1
#define PARAMETER_IS_UCHAR          2

//
// types
//

//
// REGISTRY_PARAMETER_DESCRIPTOR - structure used to get values from registry
// entries. Maintains information about a registry entry and supplies a default
// value should the registry entry not be available
//

typedef struct {
    ULONG   Type;       // expected type
    ULONG   RealType;   // eg. PARAMETER_BOOLEAN
    PVOID   Value;      // default value if REG_DWORD, or pointer to default value
    ULONG   Length;     // IN: expected length of variable; OUT: actual length
    PVOID   Variable;   // pointer to variable to update from registry
    ULONG   LowerLimit; // lower limit for REG_DWORD values
    ULONG   UpperLimit; // upper limit for REG_DWORD values
} REGISTRY_PARAMETER_DESCRIPTOR, *PREGISTRY_PARAMETER_DESCRIPTOR;

//
// DLC_REGISTRY_PARAMETER - describes an entry in the DLC\Parameters\<adapter>
// section. Supplies the name of the parameter and its default value
//

typedef struct {
    PWSTR ParameterName;
    PVOID DefaultValue;
    REGISTRY_PARAMETER_DESCRIPTOR Descriptor;
} DLC_REGISTRY_PARAMETER, *PDLC_REGISTRY_PARAMETER;

//
// ADAPTER_CONFIGURATION_INFO - for each adapter that DLC can talk to, there is
// potentially the following configuration information which can be stored in
// the DLC\Parameters\<adapter_name> key. The values are not necessarily stored
// in the format in which they are used internally
//

typedef struct {

    //
    // SwapAddressBits - when talking over Ethernet, defines whether to swap the
    // outgoing destination address bits and incoming source address bits
    //

    BOOLEAN SwapAddressBits;

    //
    // UseDix - if the Ethernet type in the DIR.OPEN.ADAPTER is set to default,
    // then we consult this flag to determine whether to send DIX or 802.3
    // format Ethernet frames. The default is 802.3 (ie UseDix = 0)
    //

    BOOLEAN UseDix;

    //
    // T1TickOne, T2TickOne, TiTickOne, T1TickTwo, T2TickTwo, TiTickTwo - timer
    // tick values in 40mSec increments. Contained in LLC_TICKS structure
    //

    LLC_TICKS TimerTicks;

    //
    // UseEthernetFrameSize - if set for a non-TR card then we use the value
    // reported by ethernet cards for the maximum frame size, else we query
    // the MAC for the maximum supported frame size.
    // Bridging is the mother of this invention: we need some way to influence
    // DLC's maximum frame size when talking over non-Token Ring nets - FDDI
    // and Ethernet in this case.
    //

    BOOLEAN UseEthernetFrameSize;

} ADAPTER_CONFIGURATION_INFO, *PADAPTER_CONFIGURATION_INFO;

//
// prototypes
//

VOID
DlcRegistryInitialization(
    IN PUNICODE_STRING RegistryPath
    );

VOID
DlcRegistryTermination(
    VOID
    );

VOID
LoadDlcConfiguration(
    VOID
    );

VOID
LoadAdapterConfiguration(
    IN PUNICODE_STRING AdapterName,
    OUT PADAPTER_CONFIGURATION_INFO ConfigInfo
    );

NTSTATUS
GetAdapterParameters(
    IN PUNICODE_STRING AdapterName,
    IN PDLC_REGISTRY_PARAMETER Parameters,
    IN ULONG NumberOfParameters,
    IN BOOLEAN SetOnFail
    );

#ifdef NDIS40
NTSTATUS
GetAdapterWaitTimeout(PULONG pulWait);
#endif // NDIS40

#endif // _DLCREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlctimr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlctimr.c

Abstract:

    This module implements timer services of NT DLC API.

    Contents:
        DirTimerSet
        DirTimerCancelGroup
        DirTimerCancel
        SearchTimerCommand
        AbortCommandsWithFlag

Author:

    Antti Saarenheimo 02-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>


NTSTATUS
DirTimerSet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure queues a timer set command to a special timer command
    queue.  The timer commands are queue by the cumulative time in
    such way, that only the timer tick needs to decrement (and possibly
    to complete) only the first command in the queue.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - the length of output parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS

--*/

{
    PDLC_COMMAND* ppNode;
    PDLC_COMMAND pDlcCommand;
    UINT TimerTicks;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // Check the timer value (I don't know what 13107 half seconds
    // means, this is just as in IBM spec).
    //

    TimerTicks = pDlcParms->Async.Ccb.u.dir.usParameter0 + 1;
    if (TimerTicks > 13108) {
        return DLC_STATUS_TIMER_ERROR;
    }

    //
    // DIR.TIMER.CANCEL returns wrong error code !!!!
    // (0x0a insted of TIMER_ERROR)
    //

    pDlcCommand = (PDLC_COMMAND)ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pDlcCommand ==  NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    pDlcCommand->Event = 0;
    pDlcCommand->pIrp = pIrp;
    pDlcCommand->StationId = 0;
    pDlcCommand->StationIdMask = (USHORT)(-1);
    pDlcCommand->AbortHandle = pDlcParms->Async.Ccb.pCcbAddress;

    //
    // find the right place in the list to put this timer
    //

    for (ppNode = &pFileContext->pTimerQueue; ; ) {
        if (*ppNode == NULL) {
            pDlcCommand->LlcPacket.pNext = NULL;
            break;
        } else if ((*ppNode)->Overlay.TimerTicks >= TimerTicks) {
            (*ppNode)->Overlay.TimerTicks -= TimerTicks;
            pDlcCommand->LlcPacket.pNext = (PLLC_PACKET)*ppNode;
            break;
        } else {
            TimerTicks -= (*ppNode)->Overlay.TimerTicks;
        }
        ppNode = (PDLC_COMMAND *)&(*ppNode)->LlcPacket.pNext;
    }
    *ppNode = pDlcCommand;
    pDlcCommand->Overlay.TimerTicks = TimerTicks;
    return STATUS_PENDING;
}


NTSTATUS
DirTimerCancelGroup(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure cancels all DirTimerSet commands having the given
    command completion flag.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // All terminated DirTimerSet commands are chained to the
    // CCB pointer of this cancel group command.
    // Terminate the link list of the canceled CCBs.
    //

    pDlcParms->InputCcb.pCcbAddress = NULL;
    AbortCommandsWithFlag(pFileContext,
                          pDlcParms->InputCcb.u.ulParameter, // CompletionFlag
                          &pDlcParms->InputCcb.pCcbAddress,
                          DLC_STATUS_CANCELLED_BY_USER
                          );
    return STATUS_SUCCESS;
}


NTSTATUS
DirTimerCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive cancels the given timer command in a
    special timer queue.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_TIMER_ERROR
--*/

{
    PDLC_COMMAND pDlcCommand;
    PDLC_COMMAND *ppDlcCommand;
    PVOID pCcbAddress = NULL;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ppDlcCommand = SearchTimerCommand(&pFileContext->pTimerQueue,
                                      pDlcParms->DlcCancelCommand.CcbAddress,
                                      FALSE
                                      );

    //
    // if the timer queue is not empty, cancel the timed DLC request else
    // return an error
    //

    if (ppDlcCommand != NULL && *ppDlcCommand != NULL) {
        pDlcCommand = *ppDlcCommand;
        *ppDlcCommand = (PDLC_COMMAND)pDlcCommand->LlcPacket.pNext;

// >>> SNA bug #10126
		//
		// If there's a next timer after the canceled one we need to update
		// it's tick count. Things will go really wrong if the next timer's tick
		// count is 0 (it expires at the same time as the canceled one) because
		// the timer tick routine (LlcEventIndication) first decrements the tick
		// value and then checks if the result is 0.
		//
		if( *ppDlcCommand )
		{
			(*ppDlcCommand)->Overlay.TimerTicks += pDlcCommand->Overlay.TimerTicks;
			if((*ppDlcCommand)->Overlay.TimerTicks == 0)
			{
                (*ppDlcCommand)->Overlay.TimerTicks++;
			}
		}
// >>> SNA bug #10126

#if LLC_DBG
        pDlcCommand->LlcPacket.pNext = NULL;
#endif

        CancelDlcCommand(pFileContext,
                         pDlcCommand,
                         &pCcbAddress,
                         DLC_STATUS_CANCELLED_BY_USER,
                         TRUE
                         );
        return STATUS_SUCCESS;
    } else {
        return DLC_STATUS_TIMER_ERROR;
    }
}


PDLC_COMMAND*
SearchTimerCommand(
    IN PDLC_COMMAND *ppQueue,
    IN PVOID pSearchHandle,
    IN BOOLEAN SearchCompletionFlags
    )

/*++

Routine Description:

    This primitive cancels the given timer command in a
    special timer queue.

Arguments:

    ppQueue - the base address of the command queue

    pSearchHandle - command completion flag or ccb address of
        the timer command.

    SearchCompletionFlags - ste TRUE, if we are searching a completion flag

Return Value:

    PDLC_COMMAND * the address of the address of the found timer command

--*/

{
    PDLC_COMMAND pCmd;

    for (; *ppQueue != NULL; ppQueue = (PDLC_COMMAND *)&(*ppQueue)->LlcPacket.pNext) {

        pCmd = *ppQueue;

        //
        // A Timer command can be cancelled either by its CCB address
        // or by its command completion flag.  The boolean flag
        // defines the used search condition.
        // We will rather space than speed optimize the rarely used
        // procedures like this one.
        //

        if (pSearchHandle
            == (SearchCompletionFlags
                ? (PVOID)
                    UlongToPtr(((PNT_DLC_CCB)pCmd->pIrp->AssociatedIrp.SystemBuffer)->CommandCompletionFlag)
                : pCmd->AbortHandle)) {

            return ppQueue;

        }
    }
    return NULL;
}


VOID
AbortCommandsWithFlag(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG CommandCompletionFlag,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus
    )

/*++

Routine Description:

    The command cancels all (timer) commands having the given command
    completion flag.

Arguments:

    pFileContext - process specific adapetr context

    EventMask - the event mask defining the canceled command

    CommandCompletionFlag - the command completion flag of the canceled
        commands

    ppCcbLink - the canceled commands are linked by their next CCB pointer
        fields together.  The caller must provide the next CCB address
        in this parameter (usually *ppCcbLink == NULL) and the function
        will return the address of the last canceled CCB field.

Return Value:

    DLC_STATUS_TIMER_ERROR - no mathing command was found
    STATUS_SUCCESS - the command was canceled

--*/

{
    PDLC_COMMAND pDlcCommand;
    PDLC_COMMAND *ppQueue;
    PVOID pNextCcb = NULL;

    ppQueue = &pFileContext->pTimerQueue;

    for (;;) {

        ppQueue = SearchTimerCommand(ppQueue,
                                     (PVOID)UlongToPtr(CommandCompletionFlag),
                                     TRUE
                                     );
        if (ppQueue != NULL) {
            pDlcCommand = *ppQueue;
            *ppQueue = (PDLC_COMMAND)pDlcCommand->LlcPacket.pNext;

#if LLC_DBG
            pDlcCommand->LlcPacket.pNext = NULL;
#endif

            *ppCcbLink = ((PNT_DLC_PARMS)pDlcCommand->pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;

            //
            // We must suppress any kind of command
            // completion indications to the applications.
            // It is very intersting to see, if Io- system hangs up
            // because of this modification.
            //

            pDlcCommand->pIrp->UserEvent = NULL;
            pDlcCommand->pIrp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
            pDlcCommand->pIrp->Overlay.AsynchronousParameters.UserApcContext = NULL;
            CompleteAsyncCommand(pFileContext, CancelStatus, pDlcCommand->pIrp, pNextCcb, FALSE);
            pNextCcb = *ppCcbLink;

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

        } else {

            //
            // This procedure do not care if we find any commands
            // or not. Everything is ok, when there are no commands
            // in the queue.
            //

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcreq.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcreq.c

Abstract:

    This module handles the miscellaneous DLC requests (set & query information)

    Contents:
        DlcBufferFree
        DlcBufferGet
        DlcBufferCreate
        DlcConnectStation
        DlcFlowControl
        ResetLocalBusyBufferStates
        DlcReallocate
        DlcReset
        DirSetExceptionFlags
        CompleteAsyncCommand
        GetLinkStation
        GetSapStation
        GetStation
        DlcReadCancel
        DirOpenAdapter
        DirCloseAdapter
        CompleteDirCloseAdapter
        DlcCompleteCommand

Author:

    Antti Saarenheimo 22-Jul-1991 (o-anttis)

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include "dlcdebug.h"

#if 0

//
// if DLC and LLC share the same driver then we can use macros to access fields
// in the BINDING_CONTEXT and ADAPTER_CONTEXT structures
//

#if DLC_AND_LLC
#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include "llcdef.h"
#include "llctyp.h"
#include "llcapi.h"
#endif
#endif


NTSTATUS
DlcBufferFree(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure simply releases the given user buffers.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INADEQUATE_BUFFERS   - buffer pool does not exist
        DLC_STATUS_INVALID_STATION_ID   -
        DLC_STATUS_INVALID_BUFFER_LENGTH -

        NOTE!!!  BUFFER.FREE does not return error, if the
            given buffer is invalid, or released twice!!!

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (!pFileContext->hBufferPool) {
        return DLC_STATUS_INADEQUATE_BUFFERS;
    }

    //
    // The parameter list is a DLC desriptor array.
    // Get the number of descriptor elements in the array.
    //

    if (InputBufferLength != (sizeof(NT_DLC_BUFFER_FREE_PARMS)
                           - sizeof(LLC_TRANSMIT_DESCRIPTOR)
                           + pDlcParms->BufferFree.BufferCount
                           * sizeof(LLC_TRANSMIT_DESCRIPTOR))) {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }

    //
    // We refernce the buffer pool, because otherwise it may disappear
    // immeadiately after DLC_LEAVE (when the adapter is closed)
    //

    ReferenceBufferPool(pFileContext);

    //
    // Don't try to allocate 0 buffers, it will fail.
    //

    if (pDlcParms->BufferFree.BufferCount) {

        LEAVE_DLC(pFileContext);

        RELEASE_DRIVER_LOCK();

        status = BufferPoolDeallocate(pFileContext->hBufferPool,
                                      pDlcParms->BufferFree.BufferCount,
                                      pDlcParms->BufferFree.DlcBuffer
                                      );

        ACQUIRE_DRIVER_LOCK();

        ENTER_DLC(pFileContext);

        //
        // Reset the local busy states, if there is now enough
        // buffers the receive the expected stuff.
        //

        if (!IsListEmpty(&pFileContext->FlowControlQueue)
        && BufGetUncommittedSpace(pFileContext->hBufferPool) >= 0) {
            ResetLocalBusyBufferStates(pFileContext);
        }

#if LLC_DBG
        cFramesReleased++;
#endif

    }

    pDlcParms->BufferFree.cBuffersLeft = (USHORT)BufferPoolCount(pFileContext->hBufferPool);

    DereferenceBufferPool(pFileContext);

    return status;
}


NTSTATUS
DlcBufferGet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure allocates the requested number or size of DLC buffers
    and returns them back to user in a single entry link list..

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT SegmentSize;
    UINT SizeIndex;
    UINT BufferSize;
    UINT PrevBufferSize;
    UINT cBuffersToGet;
    PDLC_BUFFER_HEADER pBufferHeader = NULL;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pFileContext->hBufferPool == NULL) {
        return DLC_STATUS_INADEQUATE_BUFFERS;
    }

    //
    // If the segment size is 0, then we return the optimal mix
    // of buffer for the requested size.  Non null buffer count defines
    // how many buffers having the requested size is returned.
    //

    cBuffersToGet = pDlcParms->BufferGet.cBuffersToGet;

/*******************************************************************************

#if PAGE_SIZE == 8192
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 5;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 8192) {
        SegmentSize = 8192 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#elif PAGE_SIZE == 4096
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#else
#error "Target machine page size not 4096 or 8192"
#endif

*******************************************************************************/

#if defined(ALPHA)
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 5;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 8192) {
        SegmentSize = 8192 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#else
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#endif

    //
    // We refernce the buffer pool, because otherwise it may disappear
    // immeadiately after DLC_LEAVE (when the adapter is closed)
    //

    ReferenceBufferPool(pFileContext);

    //
    // We don't need to initialize the LAN and DLC header sizes
    // in the buffer header and we allocate the requested
    // frame as a single buffer.
    //

    BufferSize = SegmentSize * cBuffersToGet;
    if (BufferSize != 0) {

        pBufferHeader = NULL;
        PrevBufferSize = 0;

        LEAVE_DLC(pFileContext);

        do {

            //
            // We must again do this interlocked to avoid the buffer
            // pool to be deleted while we are allocating buffers.
            //

            Status = BufferPoolAllocate(
#if DBG
                        pFileContext,
#endif
                        (PDLC_BUFFER_POOL)pFileContext->hBufferPool,
                        BufferSize,
                        0,                  // FrameHeaderSize,
                        0,                  // UserDataSize,
                        0,                  // frame length
                        SizeIndex,          // fixed segment size set
                        &pBufferHeader,
                        &BufferSize
                        );

#if DBG
            BufferPoolExpand(pFileContext, (PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#else
            BufferPoolExpand((PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#endif

            //
            // Don't try to expand buffer pool any more, if it doesn't help!
            //

            if (BufferSize == PrevBufferSize) {
                break;
            }
            PrevBufferSize = BufferSize;

        } while (Status == DLC_STATUS_EXPAND_BUFFER_POOL);

        ENTER_DLC(pFileContext);

        if (pBufferHeader != NULL) {
            pBufferHeader->FrameBuffer.BufferState = BUF_USER;
        }

        if (Status == STATUS_SUCCESS) {
            pDlcParms->BufferGet.pFirstBuffer = (PLLC_XMIT_BUFFER)
                ((PUCHAR)pBufferHeader->FrameBuffer.pParent->Header.pLocalVa +
                  MIN_DLC_BUFFER_SEGMENT * pBufferHeader->FrameBuffer.Index);
        } else {
            BufferPoolDeallocateList(pFileContext->hBufferPool, pBufferHeader);
        }
    }

    pDlcParms->BufferGet.cBuffersLeft = (USHORT)BufferPoolCount(pFileContext->hBufferPool);

    DereferenceBufferPool(pFileContext);

    return Status;
}


NTSTATUS
DlcBufferCreate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure creates a new buffer pool and allocates the initial
    space for it.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_DUPLICATE_COMMAND

--*/

{
    NTSTATUS status;
    PVOID newBufferAddress;
    ULONG newBufferSize;
    PVOID hExternalBufferPool;
    PVOID hBufferPool;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // if we already have a buffer pool defined for this handle, fail the
    // request
    //

    if (pFileContext->hBufferPool) {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }

    hExternalBufferPool = pFileContext->hExternalBufferPool;

    LEAVE_DLC(pFileContext);

#if DBG
    status = BufferPoolCreate(pFileContext,
#else
    status = BufferPoolCreate(
#endif
                              pDlcParms->BufferCreate.pBuffer,
                              pDlcParms->BufferCreate.cbBufferSize,
                              pDlcParms->BufferCreate.cbMinimumSizeThreshold,
                              &hExternalBufferPool,
                              &newBufferAddress,
                              &newBufferSize
                              );

    ENTER_DLC(pFileContext);
    pFileContext->hExternalBufferPool = hExternalBufferPool;

    if (status == STATUS_SUCCESS) {

        //
        // The reference count keeps the buffer pool alive
        // when it is used (and simultaneously deleted by another
        // thread)
        //

        pFileContext->BufferPoolReferenceCount = 1;
	hBufferPool = pFileContext->hBufferPool;

	LEAVE_DLC(pFileContext);

        status = BufferPoolReference(hExternalBufferPool,
                                     &hBufferPool
                                     );
	
	ENTER_DLC(pFileContext);
	pFileContext->hBufferPool = hBufferPool;
        pDlcParms->BufferCreate.hBufferPool = pFileContext->hExternalBufferPool;
    }

    //    ENTER_DLC(pFileContext);

    return status;
}


NTSTATUS
DlcConnectStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure connects an local link station to a remote node
    or accepts a remote connection request.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    PDLC_OBJECT pLinkStation;
    NTSTATUS Status;
    PUCHAR pSourceRouting = NULL;
    PDLC_COMMAND pPacket;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // Procedure checks the sap and link station ids and
    // returns the requested link station.
    // The error status indicates a wrong sap or station id.
    //

    Status = GetLinkStation(pFileContext,
                            pDlcParms->Async.Parms.DlcConnectStation.StationId,
                            &pLinkStation
                            );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    pPacket = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pPacket == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    pPacket->pIrp = pIrp;

    //
    // IBM LAN Tech. Ref p 3-48 (DLC.CONNECT.STATION) states that ROUTING_ADDR
    // field is ignored if the link was created due to receipt of a SABME from
    // the remote station, EVEN IF THE ADDRESS IS NON-ZERO
    //

    if (pDlcParms->Async.Parms.DlcConnectStation.RoutingInformationLength != 0) {
        pSourceRouting = pDlcParms->Async.Parms.DlcConnectStation.aRoutingInformation;
    }
    pLinkStation->PendingLlcRequests++;
    ReferenceLlcObject(pLinkStation);

    LEAVE_DLC(pFileContext);

    //
    // LlcConnect returns the maximum information field,
    // through the tr bridges!
    //

    LlcConnectStation(pLinkStation->hLlcObject,
                      (PLLC_PACKET)pPacket,
                      pSourceRouting,
                      &pLinkStation->u.Link.MaxInfoFieldLength
                      );

    ENTER_DLC(pFileContext);

    DereferenceLlcObject(pLinkStation);

    return STATUS_PENDING;
}


NTSTATUS
DlcFlowControl(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure sets or resets the loacl busy state on the given link station
    or on all link stations of a sap station.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pDlcObject;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Procedure checks the sap and link station ids and
    // returns the requested link station.
    // The error status indicates a wrong sap or station id.
    //

    Status = GetStation(pFileContext,
                        pDlcParms->DlcFlowControl.StationId,
                        &pDlcObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // We will queue all reset local busy buffer commands
    // given to the link stations
    //

    if (((pDlcParms->DlcFlowControl.FlowControlOption & LLC_RESET_LOCAL_BUSY_BUFFER) == LLC_RESET_LOCAL_BUSY_BUFFER)
    && (pDlcObject->Type == DLC_LINK_OBJECT)) {

        PDLC_RESET_LOCAL_BUSY_CMD pClearCmd;

        pClearCmd = (PDLC_RESET_LOCAL_BUSY_CMD)ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pClearCmd == NULL) {
            return DLC_STATUS_NO_MEMORY;
        }
        pClearCmd->StationId = pDlcParms->DlcFlowControl.StationId;
        pClearCmd->RequiredBufferSpace = 0;
        LlcInsertTailList(&pFileContext->FlowControlQueue, pClearCmd);
        ResetLocalBusyBufferStates(pFileContext);
    } else {
        ReferenceLlcObject(pDlcObject);

        LEAVE_DLC(pFileContext);

        Status = LlcFlowControl(pDlcObject->hLlcObject,
                                pDlcParms->DlcFlowControl.FlowControlOption
                                );

        ENTER_DLC(pFileContext);

        DereferenceLlcObject(pDlcObject);
    }
    return Status;
}


VOID
ResetLocalBusyBufferStates(
    IN PDLC_FILE_CONTEXT pFileContext
    )
/*++

Routine Description:

    Procedure executes the pending busy state resets when there is
    enough memory in the buffer pool to receive the expected data.

Arguments:

    pFileContext    - DLC adapter context

Return Value:

    None

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pDlcObject;
    PDLC_RESET_LOCAL_BUSY_CMD pClearCmd;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We cannot reset anything, if the buffer pool is not yet
    // defined.
    //

    if (pFileContext->hBufferPool == NULL) {
        return;
    }

    ReferenceBufferPool(pFileContext);

    while (!IsListEmpty(&pFileContext->FlowControlQueue)) {
        pClearCmd = LlcRemoveHeadList(&pFileContext->FlowControlQueue);

        Status = GetLinkStation(pFileContext,
                                pClearCmd->StationId,
                                &pDlcObject
                                );

        //
        // All commands having an invalid station id will be just removed
        // from the queue. The local busy state can be reset only
        // for the existing link stations
        //

        if (Status == STATUS_SUCCESS) {

            //
            // The required space is nul, when a mew packet is checked
            // in the first time, the non-null value just prevents
            // us to check the commited memory in the second time.
            //

            if (pClearCmd->RequiredBufferSpace == 0) {

                //
                // We must also remove the old uncommited space,
                // otherwise the same buffer size could be
                // committed several times, but uncommitted only once
                //

                if (pDlcObject->CommittedBufferSpace != 0) {
                    BufUncommitBuffers(pFileContext->hBufferPool,
                                       pDlcObject->CommittedBufferSpace
                                       );
                }

                pDlcObject->CommittedBufferSpace =
                pClearCmd->RequiredBufferSpace = LlcGetCommittedSpace(pDlcObject->hLlcObject);

                BufCommitBuffers(pFileContext->hBufferPool,
                                 pDlcObject->CommittedBufferSpace
                                 );
            }

            //
            // We are be removing a local buffer busy state =>
            // we must expand the buffer pools before the local busy
            // is removed, but only if we are not calling this
            // from a DPC level.
            //

            if (BufGetUncommittedSpace(pFileContext->hBufferPool) < 0) {

                LEAVE_DLC(pFileContext);

#if DBG
                BufferPoolExpand(pFileContext, pFileContext->hBufferPool);
#else
                BufferPoolExpand(pFileContext->hBufferPool);
#endif

                ENTER_DLC(pFileContext);
            }

            //
            // Now we have expanded the buffer pool for the new
            // flow control command, check if we have now enough
            // memory to receive the commited size of data.
            //

            if (BufGetUncommittedSpace(pFileContext->hBufferPool) >= 0
            && pDlcObject->hLlcObject != NULL) {

                ReferenceLlcObject(pDlcObject);

                LEAVE_DLC(pFileContext);

                Status = LlcFlowControl(pDlcObject->hLlcObject,
                                        LLC_RESET_LOCAL_BUSY_BUFFER
                                        );

                ENTER_DLC(pFileContext);

                DereferenceLlcObject(pDlcObject);
            } else {

                //
                // We must exit this loop when there is not enough available
                // space in the buffer pool, but we must return
                // the command back to the head of the list
                //

                LlcInsertHeadList(&pFileContext->FlowControlQueue, pClearCmd);
                break;
            }
        }

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClearCmd);

    }

    DereferenceBufferPool(pFileContext);
}


NTSTATUS
DlcReallocate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure changes the number of link stations allocated to a SAP
    without closing or reopening the sap station.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    PDLC_OBJECT pSap;
    UCHAR ExtraStations;
    UCHAR StationCount;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // Procedure checks the sap and returns the requested sap station.
    // The error status indicates an invalid sap station id.
    //

    Status = GetSapStation(pFileContext,
                           pDlcParms->DlcReallocate.usStationId,
                           &pSap
                           );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // The new link station count must be more than current number
    // of open link stations but less than the available number
    // of link stations for the file context
    //

    StationCount = pDlcParms->DlcReallocate.uchStationCount;
    if (StationCount != 0 && Status == STATUS_SUCCESS) {

        //
        // Bit7 set in options => decrease the number of available
        // stations by the given station count.  Otherwise we increase it.
        //

        if (pDlcParms->DlcReallocate.uchOption & 0x80) {
            ExtraStations = pSap->u.Sap.MaxStationCount - pSap->u.Sap.LinkStationCount;
            if (StationCount > ExtraStations) {
                StationCount = ExtraStations;
                Status = DLC_STATUS_INADEQUATE_LINKS;
            }
            pFileContext->LinkStationCount += StationCount;
            pSap->u.Sap.MaxStationCount -= StationCount;
        } else {
            if (pFileContext->LinkStationCount < StationCount) {
                StationCount = pFileContext->LinkStationCount;
                Status = DLC_STATUS_INADEQUATE_LINKS;
            }
            pFileContext->LinkStationCount -= StationCount;
            pSap->u.Sap.MaxStationCount += StationCount;
        }
    }

    //
    // Set the return parameters even if there would be an error
    // (inadequate stations is a non fatal error)
    //

    pDlcParms->DlcReallocate.uchStationsAvailOnAdapter = pFileContext->LinkStationCount;
    pDlcParms->DlcReallocate.uchStationsAvailOnSap = pSap->u.Sap.MaxStationCount - pSap->u.Sap.LinkStationCount;
    pDlcParms->DlcReallocate.uchTotalStationsOnAdapter = MAX_LINK_STATIONS;
    pDlcParms->DlcReallocate.uchTotalStationsOnSap = pSap->u.Sap.MaxStationCount;
    return Status;
}


NTSTATUS
DlcReset(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure closes immediately a sap and its all link stations or
    all saps and all link stations.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        STATUS_PENDING
        DLC_STATUS_NO_MEMORY
--*/

{
    PDLC_OBJECT pDlcObject;
    PDLC_CLOSE_WAIT_INFO pClosingInfo;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Station id 0 resets the whole DLC
    //

    if (pDlcParms->Async.Ccb.u.dlc.usStationId == 0) {

        PDLC_CLOSE_WAIT_INFO pClosingInfo;

        pClosingInfo = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pClosingInfo == NULL) {
            Status = DLC_STATUS_NO_MEMORY;
        } else {
            CloseAllStations(pFileContext,
                             pIrp,
                             DLC_COMMAND_COMPLETION,
                             NULL,
                             pDlcParms,
                             pClosingInfo
                             );
            Status = STATUS_PENDING;
        }
    } else {

        BOOLEAN allClosed;

        //
        // We have a specific sap station
        //

        Status = GetSapStation(pFileContext,
                               pDlcParms->Async.Ccb.u.dlc.usStationId,
                               &pDlcObject
                               );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        //
        // Allocate the close/reset command completion info,
        // the station count is the number of link stations and
        // the sap station itself
        //

        pClosingInfo = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pClosingInfo == NULL) {
            return DLC_STATUS_NO_MEMORY;
        }
        pClosingInfo->pIrp = pIrp;
        pClosingInfo->Event = DLC_COMMAND_COMPLETION;
        pClosingInfo->CancelStatus = DLC_STATUS_CANCELLED_BY_USER;
        pClosingInfo->CloseCounter = 1; // keep command alive over sync path

        (USHORT)(pDlcObject->u.Sap.LinkStationCount + 1);

        CloseAnyStation(pDlcObject, pClosingInfo, FALSE);

        //
        // RLF 05/09/93
        //
        // PC/3270 (DOS program) is hanging forever when we try to quit.
        // It is doing this because we returned STATUS_PENDING to a DLC.RESET,
        // even though the reset completed; the DOS program spins forever on
        // the CCB.uchDlcStatus field, waiting for it to go non-0xFF, which it
        // will never do.
        //
        // If we determine that the station has been reset (all links closed)
        // then return success, else pending
        //

        allClosed = DecrementCloseCounters(pFileContext, pClosingInfo);

        //
        // RLF 07/21/92 Always return PENDING. Can't complete before return?
        //

        Status = allClosed ? STATUS_SUCCESS : STATUS_PENDING;
    }
    return Status;
}


NTSTATUS
DirSetExceptionFlags(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure sets the exception flags for the current adapter context.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    pFileContext->AdapterCheckFlag = pDlcParms->DirSetExceptionFlags.ulAdapterCheckFlag;
    pFileContext->NetworkStatusFlag = pDlcParms->DirSetExceptionFlags.ulNetworkStatusFlag;
    pFileContext->PcErrorFlag = pDlcParms->DirSetExceptionFlags.ulPcErrorFlag;
    pFileContext->SystemActionFlag = pDlcParms->DirSetExceptionFlags.ulSystemActionFlag;
    return STATUS_SUCCESS;
}


VOID
CompleteAsyncCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN UINT Status,
    IN PIRP pIrp,
    IN PVOID pUserCcbPointer,
    IN BOOLEAN InCancel
    )

/*++

Routine Description:

    Procedure completes an asynchronous DLC command.
    It also copies the optional output parameters to user parameter
    table, if there is the second output buffer.

Arguments:

    pFileContext    - DLC driver client context.
    Status          - status of the complete command.
    pIrp            - the completed I/O request packet.
    pUserCcbPointer - the next CCB address to which the command will be linked.
    InCancel        - TRUE if called on Irp cancel path

Return Value:

    None.

--*/

{
    PNT_DLC_PARMS pDlcParms;

    UNREFERENCED_PARAMETER(pFileContext);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("CompleteAsyncCommand");

    pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

    //
    // We first map the 32-bit DLC driver status code to 8- bit API status
    //

    if (Status == STATUS_SUCCESS) {
        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)STATUS_SUCCESS;
    } else if (Status >= DLC_STATUS_ERROR_BASE && Status < DLC_STATUS_MAX_ERROR) {

        //
        //  We can map the normal DLC error codes directly to the 8-bit
        //  DLC API error codes.
        //

        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)(Status - DLC_STATUS_ERROR_BASE);
    } else {

        //
        // we have an unknown NT error status => we will return it in the CCB
        //

        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)(DLC_STATUS_NT_ERROR_STATUS & 0xff);
    }
    pDlcParms->Async.Ccb.pCcbAddress = pUserCcbPointer;

    //
    // We always return success status to the I/O system. The actual status is
    // copied to the CCB (= the dafault output buffer)
    //

    LEAVE_DLC(pFileContext);

    RELEASE_DRIVER_LOCK();

    DlcCompleteIoRequest(pIrp, InCancel);

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    DereferenceFileContext(pFileContext);
}


NTSTATUS
GetLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppLinkStation
    )

/*++

Routine Description:

    Procedure checks and returns link station

Arguments:

    pFileContext    - DLC driver client context
    StationId       - DLC station id (ssnn, where ss = sap and nn = link station id
    ppDlcObject     - the returned link station

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INVALID_SAP_VALUE
        DLC_STATUS_INVALID_STATION_ID

--*/

{
    if ((StationId & 0xff) == 0 || (StationId & 0xff00) == 0) {
        return DLC_STATUS_INVALID_STATION_ID;
    }
    return GetStation(pFileContext, StationId, ppLinkStation);
}


NTSTATUS
GetSapStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppStation
    )

/*++

Routine Description:

    Procedure checks and returns link station

Arguments:

    pFileContext    - DLC driver client context
    StationId       - DLC station id (ssnn, where ss = sap and nn = link station id
    ppDlcObject     - the returned link station

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INVALID_SAP_VALUE
        DLC_STATUS_INVALID_STATION_ID

--*/

{
    UINT SapId = StationId >> 9;

    if (SapId >= MAX_SAP_STATIONS
    || SapId == 0
    || (StationId & GROUP_SAP_BIT)
    || (*ppStation = pFileContext->SapStationTable[SapId]) == NULL
    || (*ppStation)->State != DLC_OBJECT_OPEN) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
GetStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppStation
    )

/*++

Routine Description:

    Procedure checks the given station id and returns a pointer to
    sap, direct or link station object.

Arguments:

    pFileContext    - DLC driver client context
    StationId       - DLC station id (ssnn, where ss = sap and nn = link station id
    ppStation       - the returned station object

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INVALID_STATION_ID

--*/

{
    UINT SapId = StationId >> 9;

    //
    // Check if the sap or direct station exists,
    // but check also the link station, if we found a valid sap id.
    //

    if (SapId >= MAX_SAP_STATIONS
    || (StationId & GROUP_SAP_BIT)
    || (*ppStation = pFileContext->SapStationTable[SapId]) == NULL
    || (*ppStation)->State != DLC_OBJECT_OPEN) {
        if (SapId == 0) {
            return DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE;
        } else {
            return DLC_STATUS_INVALID_STATION_ID;
        }
    }

    //
    // The link station table will never be read, if we have found
    // a valid sap or direct station.  Link station must exist and
    // it must be opened.
    //

    if (SapId != 0
    && (StationId & 0xff) != 0
    && (*ppStation = pFileContext->LinkStationTable[((StationId & 0xff) - 1)]) == NULL
    || (*ppStation)->State != DLC_OBJECT_OPEN) {
        return DLC_STATUS_INVALID_STATION_ID;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
DlcReadCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive cancels a READ command, that have the given CCB pointer.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    DLC_STATUS:
        STATUS_SUCCESS

--*/

{
    PVOID pCcbAddress = NULL;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    DLC_TRACE('Q');

    return AbortCommand(pFileContext,
                        (USHORT)DLC_IGNORE_STATION_ID,
                        (USHORT)DLC_STATION_MASK_SPECIFIC,
                        pDlcParms->DlcCancelCommand.CcbAddress,
                        &pCcbAddress,
                        DLC_STATUS_CANCELLED_BY_USER,
                        TRUE    // Suppress completion
                        );
}


NTSTATUS
DirOpenAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive binds the DLC API driver to an adapter context of
    the LLC module.  The LLC mode may also bind to the given NDIS driver
    and open it, if this is the first reference to the driver from DLC.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    DLC_STATUS:
        STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    UINT OpenErrorCode;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pDlcParms->DirOpenAdapter.NtDlcIoctlVersion != NT_DLC_IOCTL_VERSION) {
        return DLC_STATUS_INVALID_VERSION;
    }

    //
    // This makes the DirOpenAdapter safe, even if there were two adapter
    // opens going on simultaneously
    //

    //
    // RLF 04/22/94
    //
    // this only protects against 2 threads in the same process performing
    // simultaneous opens on the same adapter
    //

    if (pFileContext->pBindingContext) {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }
    pFileContext->pBindingContext = (PVOID)-1;

    //
    // if a buffer pool handle was supplied (i.e. the app already created a
    // buffer pool or is otherwise sharing one) then reference it for this
    // file context
    //

    if (pDlcParms->DirOpenAdapter.hBufferPoolHandle) {
        Status = BufferPoolReference(pDlcParms->DirOpenAdapter.hBufferPoolHandle,
                                     &pFileContext->hBufferPool
                                     );
        if (Status == STATUS_SUCCESS) {
            pFileContext->BufferPoolReferenceCount = 1;
            pFileContext->hExternalBufferPool = pDlcParms->DirOpenAdapter.hBufferPoolHandle;
        } else {

            //
            // Invalid buffer pool handle, hopefully this status
            // code indicates correctly, that the buffer pool
            // handle is not valid.
            //

			pFileContext->pBindingContext = NULL;
            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }
    }

    LEAVE_DLC(pFileContext);

    //
    // XXXXXXX: BringUpDiagnostics are still missing!!!
    //

    //
    // RLF 04/19/93
    //
    // The string we pass to LlcOpenAdapter is a pointer to a zero terminated
    // wide character string, NOT a pointer to a UNICODE_STRING structure. The
    // string MUST be in system memory space, i.e. copied across the kernel
    // interface by NtDeviceIoControlFile
    //

    Status = LlcOpenAdapter(&pDlcParms->DirOpenAdapter.Buffer[0],
                            (PVOID)pFileContext,
                            LlcCommandCompletion,
                            LlcReceiveIndication,
                            LlcEventIndication,
                            NdisMedium802_5,    // Always token-ring!
                            pDlcParms->DirOpenAdapter.LlcEthernetType,
                            pDlcParms->DirOpenAdapter.AdapterNumber,
                            &pFileContext->pBindingContext,
                            &OpenErrorCode,
                            &pFileContext->MaxFrameLength,
                            &pFileContext->ActualNdisMedium
                            );

    //
    // make sure LlcOpenAdapter didn't return with lowered IRQL
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // IBM LAN Tech. Ref. defines the open error code as a 16-bit value, the
    // high 8 bits of which are 0. The MAC inclusive-ORs the open error code
    // into the NDIS status. Extract it
    //

    pDlcParms->DirOpenAdapter.Adapter.usOpenErrorCode = (USHORT)(UCHAR)OpenErrorCode;
    if (Status != STATUS_SUCCESS) {

        ENTER_DLC(pFileContext);

        //
        // It does not matter, if we have null buffer pool handle!
        //

#if DBG

        BufferPoolDereference(pFileContext,
                              (PDLC_BUFFER_POOL*)&pFileContext->hBufferPool
                              );

#else

        BufferPoolDereference((PDLC_BUFFER_POOL*)&pFileContext->hBufferPool);

#endif

        //
        // set the BINDING_CONTEXT pointer back to NULL - other routines check
        // for this value, like CloseAdapterFileContext
        //

        pFileContext->pBindingContext = NULL;

        //
        // Probably the adapter was missing or it was installed improperly
        //

        Status = DLC_STATUS_ADAPTER_NOT_INSTALLED;
    } else {

        //
        // Set the optional timer tick one/two values
        // (if they have been set in registry)
        //

        LlcSetInformation(pFileContext->pBindingContext,
                          DLC_INFO_CLASS_DLC_TIMERS,
                          (PLLC_SET_INFO_BUFFER)&(pDlcParms->DirOpenAdapter.LlcTicks),
                          sizeof(LLC_TICKS)
                          );

        LlcQueryInformation(pFileContext->pBindingContext,
                            DLC_INFO_CLASS_DIR_ADAPTER,
                            (PLLC_QUERY_INFO_BUFFER)pDlcParms->DirOpenAdapter.Adapter.auchNodeAddress,
                            sizeof(LLC_ADAPTER_INFO)
                            );

        ENTER_DLC(pFileContext);

        //
        // take the missing parameters from the hat
        //

        pDlcParms->DirOpenAdapter.Adapter.usOpenOptions = 0;
        pDlcParms->DirOpenAdapter.Adapter.usMaxFrameSize = (USHORT)(pFileContext->MaxFrameLength + 6);
        pDlcParms->DirOpenAdapter.Adapter.usBringUps = 0;
        pDlcParms->DirOpenAdapter.Adapter.InitWarnings = 0;

        pFileContext->AdapterNumber = pDlcParms->DirOpenAdapter.AdapterNumber;
        pFileContext->LinkStationCount = 255;
        pFileContext->pSecurityDescriptor = pDlcParms->DirOpenAdapter.pSecurityDescriptor;

        //
        // Read the most recent cumulative NDIS error counters
        // to the file context. DLC error counters will be counted
        // from 0 and they may be reset.
        //

        GetDlcErrorCounters(pFileContext, NULL);
        pFileContext->State = DLC_FILE_CONTEXT_OPEN;
    }

    //
    // We may directly return whatever the LLC binding primitive gives us
    //

    return Status;
}


NTSTATUS
DirCloseAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive initializes the close adapter operation.
    It first closes all open link and sap stations and
    then optionally chains the canceled commands and
    receive buffers to a READ command.  If no read commands
    was found, then the CCBs are linked to the CCB pointer
    of this command.

    The actual file close should only delete the file
    object, except, if the application exits, when it still has
    open dlc api handles. In that case the file close routine
    will call this procedure to shut down the dlc file context.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS

        STATUS_PENDING
            The adapter is being closed

        DLC_STATUS_ADAPTER_CLOSED
            The adapter is already closed

            NOTE: This is a SYNCHRONOUS return code! And will cause the IRP
                  to be completed

--*/

{
    UNREFERENCED_PARAMETER(pDlcParms);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("DirCloseAdapter");

    DLC_TRACE('J');

    if (pFileContext->State != DLC_FILE_CONTEXT_OPEN) {
        return DLC_STATUS_ADAPTER_CLOSED;
    }

#if LLC_DBG == 2
    DbgPrint( "*** Top memory consumption (before adapter close) *** \n" );
    PrintMemStatus();
#endif

    //
    // This disables any further commands (including DirCloseAdapter)
    //

    pFileContext->State = DLC_FILE_CONTEXT_CLOSE_PENDING;

    //
    // Remove first all functional, group or multicast addresses
    // set in the adapter by the current DLC application process
    //

    if (pFileContext->pBindingContext) {

        LEAVE_DLC(pFileContext);

        LlcResetBroadcastAddresses(pFileContext->pBindingContext);

        ENTER_DLC(pFileContext);
    }

    //
    // We must use the static closing packet, because the adapter close
    // must succeed even if we could not allocate any packets
    //

    CloseAllStations(pFileContext,
                     pIrp,
                     DLC_COMMAND_COMPLETION,
                     CompleteDirCloseAdapter,
                     pDlcParms,
                     &pFileContext->ClosingPacket
                     );

    return STATUS_PENDING;
}


VOID
CompleteDirCloseAdapter(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    )

/*++

Routine Description:

    Finishes DIR.CLOSE.ADAPTER command

Arguments:

    pFileContext    - DLC adapter open context
    pClosingInfo    - packet structure, that includes all data of this command
    pCcbLink        - the orginal user mode ccb address on the next CCB, that
                      will be chained to the completed command.

Return Value:

    None

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('K');

    //
    // reference the file context to stop any of the dereferences below, or in
    // functions called by this routine destroying it
    //

    ReferenceFileContext(pFileContext);

    //
    // Disconnect (or unbind) llc driver from us
    //

    if (pFileContext->pBindingContext) {

        LEAVE_DLC(pFileContext);

        LlcDisableAdapter(pFileContext->pBindingContext);

        ENTER_DLC(pFileContext);
    }
    if (IoGetCurrentIrpStackLocation(pClosingInfo->pIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        CompleteAsyncCommand(pFileContext, STATUS_SUCCESS, pClosingInfo->pIrp, pCcbLink, FALSE);
    } else {

        //
        // This is a normal FILE CLOSE !!! (IRP_MJ_CLEANUP)
        //

        ASSERT(IoGetCurrentIrpStackLocation(pClosingInfo->pIrp)->MajorFunction == IRP_MJ_CLEANUP);
        
        //
        // Dereference for the cleanup. This will allow cleanup to become
        // unblocked.
        //

        DereferenceFileContext(pFileContext);
    }

    //
    // We must delete the buffer pool now, because the dereference
    // of the driver object starts the final process exit
    // completion, that bug chekcs, if the number of the locked
    // pages is non zero.
    //

    DereferenceBufferPool(pFileContext);

    //
    // We create two references for file context, when it is created
    // the other is decremented here and the other when the synchronous
    // part of command completion has been done
    //

    pFileContext->State = DLC_FILE_CONTEXT_CLOSED;

    //
    // This should be the last reference of the file context
    // (if no IRPs operations are in execution or pending.
    //

    DereferenceFileContext(pFileContext);
}


NTSTATUS
DlcCompleteCommand(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure queues the given CCB to the completion list.
    This routine is used to save the synchronous commands from
    DLC API DLL to event queue.  This must be done whenever a
    synchronous command has a non null command completion flag.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    if (pDlcParms->CompleteCommand.CommandCompletionFlag == 0
    || pDlcParms->CompleteCommand.pCcbPointer == NULL) {

        //
        // This is more likely an internal error!
        //

        return DLC_STATUS_INTERNAL_ERROR;
    }
    return MakeDlcEvent(pFileContext,
                        DLC_COMMAND_COMPLETION,
                        pDlcParms->CompleteCommand.StationId,
                        NULL,
                        pDlcParms->CompleteCommand.pCcbPointer,
                        pDlcParms->CompleteCommand.CommandCompletionFlag,
                        FALSE
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    llc.h

Abstract:

    This module includes all files needed by LLC data link modules.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/


//
//  This define enables the private DLC function prototypes
//  We don't want to export our data types to the dlc layer.
//  MIPS compiler doesn't accept hiding of the internal data
//  structures by a PVOID in the function prototype.
//  i386 builds will use the same prototypes everywhere (and thus
//  they checks that the numebr of parameters is correct)

//
#ifndef i386

#define LLC_PRIVATE_PROTOTYPES

#ifndef LLC_PUBLIC_NDIS_PROTOTYPES
#define LLC_PRIVATE_NDIS_PROTOTYPES
#endif

#endif


#ifndef DLC_INCLUDED

#include <ntddk.h>
#include <ndis.h>

#define APIENTRY
#include <dlcapi.h>
#include <dlcio.h>
#include <llcapi.h>

#include <memory.h>

#endif

#include "dlcreg.h"

#ifndef LLC_INCLUDED

#define LLC_INCLUDED

#include <llcdef.h>
#include <llctyp.h>
#include <llcext.h>
#include <llcmac.h>

#endif // LLC_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcreg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcreg.c

Abstract:

    This module accesses the registry for DLC.SYS

    Contents:
        DlcRegistryInitialization
        LoadDlcConfiguration
        LoadAdapterConfiguration
        GetAdapterParameters
        OpenDlcRegistryHandle
        OpenDlcAdapterRegistryHandle
        GetRegistryParameter
        SetRegistryParameter
        DlcpGetParameter
        DlcRegistryTermination

Author:

    Richard L Firth (rfirth) 31-Mar-1993

Environment:

    kernel mode only

Revision History:

    30-Mar-1993 rfirth
        created

    04-May-1994 rfirth
        Exposed GetAdapterParameters

--*/

#include <ntddk.h>
#include <windef.h>
#include <dlcapi.h>
#include <dlcio.h>
#include <ndis.h>
#include "llcapi.h"
#include "dlcdef.h"
#include "dlcreg.h"
#include "dlctyp.h"
#include "llcdef.h"
#include "llcmem.h"
#include "llctyp.h"
#include "llcext.h"

//
// manifests
//

#define MAX_ADAPTER_NAME_LENGTH 32  // ?
#define MAX_INFORMATION_BUFFER_LENGTH   256 // ?
#define PARAMETERS_STRING       L"Parameters"

//
// indicies of parameters within parameter table
//

#define SWAP_INDEX              0
#define USEDIX_INDEX            1
#define T1_TICK_ONE_INDEX       2
#define T2_TICK_ONE_INDEX       3
#define Ti_TICK_ONE_INDEX       4
#define T1_TICK_TWO_INDEX       5
#define T2_TICK_TWO_INDEX       6
#define Ti_TICK_TWO_INDEX       7
#define FRAME_SIZE_INDEX        8

//
// typedefs
//

//
// macros
//

#define CloseDlcRegistryHandle(handle)      ZwClose(handle)
#define CloseAdapterRegistryHandle(handle)  ZwClose(handle)

//
// Global data
//

//
// private data
//

UNICODE_STRING DlcRegistryPath;
UNICODE_STRING ParametersPath;

//
// AdapterParameterTable - used for loading DLC parameters from registry in
// data-driven manner. Each adapter that DLC talks to can have a set of all
// or part of the following variables
//

DLC_REGISTRY_PARAMETER AdapterParameterTable[] = {
    L"Swap",
    (PVOID)DEFAULT_SWAP_ADDRESS_BITS,
    {
        REG_DWORD,
        PARAMETER_IS_BOOLEAN,
        NULL,
        sizeof(ULONG),
        NULL,
        0,
        0
    },

    L"UseDixOverEthernet",
    (PVOID)DEFAULT_DIX_FORMAT,
    {
        REG_DWORD,
        PARAMETER_IS_BOOLEAN,
        NULL,
        sizeof(ULONG),
        NULL,
        0,
        0
    },

    L"T1TickOne",
    (PVOID)DEFAULT_T1_TICK_ONE,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"T2TickOne",
    (PVOID)DEFAULT_T2_TICK_ONE,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"TiTickOne",
    (PVOID)DEFAULT_Ti_TICK_ONE,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"T1TickTwo",
    (PVOID)DEFAULT_T1_TICK_TWO,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"T2TickTwo",
    (PVOID)DEFAULT_T2_TICK_TWO,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"TiTickTwo",
    (PVOID)DEFAULT_Ti_TICK_TWO,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"UseEthernetFrameSize",
    (PVOID)DEFAULT_USE_ETHERNET_FRAME_SIZE,
    {
        REG_DWORD,
        PARAMETER_IS_BOOLEAN,
        NULL,
        sizeof(ULONG),
        NULL,
        0,
        0
    }
};

#ifdef NDIS40
DLC_REGISTRY_PARAMETER AdapterInitTimeout = 
{
    L"WaitForAdapter",
    (PVOID) 15, // Default is 15 seconds.
    {
        REG_DWORD,
        PARAMETER_AS_SPECIFIED,
        NULL,
        sizeof(ULONG),
        NULL,
        0, // Min acceptable value
        (ULONG) -1 // Allow to set anything.
    }
};
#endif // NDIS40

#define NUMBER_OF_DLC_PARAMETERS (sizeof(AdapterParameterTable)/sizeof(AdapterParameterTable[0]))

//
// private function prototypes
//

NTSTATUS
OpenDlcRegistryHandle(
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE DlcRegistryHandle
    );

NTSTATUS
OpenDlcAdapterRegistryHandle(
    IN HANDLE DlcRegistryHandle,
    IN PUNICODE_STRING AdapterName,
    OUT PHANDLE DlcAdapterRegistryHandle,
    OUT PBOOLEAN Created
    );

NTSTATUS
GetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter,
    IN BOOLEAN SetOnFail
    );

NTSTATUS
SetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter
    );

NTSTATUS
DlcpGetParameter(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

//
// debug display options
//

#if DBG
BOOLEAN DebugConfig = TRUE;
#endif


//
// functions
//

VOID
DlcRegistryInitialization(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initializes memory structures for functions in this module

Arguments:

    RegistryPath    - pointer to UNICODE_STRING giving base of DLC section in
                      registry

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    LlcInitUnicodeString(&DlcRegistryPath, RegistryPath);
    RtlInitUnicodeString(&ParametersPath, PARAMETERS_STRING);
}


VOID
DlcRegistryTermination(
    VOID
    )

/*++

Routine Description:

    Undoes anything done in DlcRegistryInitialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    LlcFreeUnicodeString(&DlcRegistryPath);
}


VOID
LoadDlcConfiguration(
    VOID
    )

/*++

Routine Description:

    Initializes the data structures used to access the registry and loads any
    configuration parameters for the driver

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // nothing else to do at present since we made all currently known
    // configuration parameters per-adapter
    //
}


VOID
LoadAdapterConfiguration(
    IN PUNICODE_STRING AdapterName,
    OUT PADAPTER_CONFIGURATION_INFO ConfigInfo
    )

/*++

Routine Description:

    Loads all of DLC initialization parameters for an adapter from registry:

        Swap                    0 or 1, default 1
        UseDixOverEthernet      0 or 1, default 0
        T1TickOne               1 - 255, default 5
        T1TickTwo               1 - 255, default 25
        T2TickOne               1 - 255, default 1
        T2TickTwo               1 - 255, default 10
        TiTickOne               1 - 255, default 25
        TiTickTwo               1 - 255, default 125
        UseEthernetFrameSize    0 or 1, default 1

    If any of the parameters do not exist in the DLC\Parameters\<AdapterName>
    section, then they are created

Arguments:

    AdapterName - pointer to UNICODE_STRING structure giving the name of the
                  adapter we are opening. This is the value of a key in the
                  DLC\Parameters section.
                  The string is EXPECTED to be of the form \Device\<adapter>
    ConfigInfo  - pointer to the structure that receives the values on output

Return Value:

    None.

--*/

{
    UINT i;
    PDLC_REGISTRY_PARAMETER parameterTable;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // fill in the adapter configuration structure with default values. These
    // will be used to update the registry if the value entry doesn't currently
    // exist
    //

    ConfigInfo->SwapAddressBits = (BOOLEAN)DEFAULT_SWAP_ADDRESS_BITS;
    ConfigInfo->UseDix = (BOOLEAN)DEFAULT_DIX_FORMAT;
    ConfigInfo->TimerTicks.T1TickOne = (UCHAR)DEFAULT_T1_TICK_ONE;
    ConfigInfo->TimerTicks.T2TickOne = (UCHAR)DEFAULT_T2_TICK_ONE;
    ConfigInfo->TimerTicks.TiTickOne = (UCHAR)DEFAULT_Ti_TICK_ONE;
    ConfigInfo->TimerTicks.T1TickTwo = (UCHAR)DEFAULT_T1_TICK_TWO;
    ConfigInfo->TimerTicks.T2TickTwo = (UCHAR)DEFAULT_T2_TICK_TWO;
    ConfigInfo->TimerTicks.TiTickTwo = (UCHAR)DEFAULT_Ti_TICK_TWO;
    ConfigInfo->UseEthernetFrameSize = (BOOLEAN)DEFAULT_USE_ETHERNET_FRAME_SIZE;

    //
    // create and initialize a copy of the DLC adapter parameters template
    //

    parameterTable = (PDLC_REGISTRY_PARAMETER)ALLOCATE_MEMORY_DRIVER(
                            sizeof(*parameterTable) * NUMBER_OF_DLC_PARAMETERS);
    if (parameterTable) {
        RtlCopyMemory(parameterTable, AdapterParameterTable, sizeof(AdapterParameterTable));
        for (i = 0; i < NUMBER_OF_DLC_PARAMETERS; ++i) {
            parameterTable[i].Descriptor.Value = (PVOID)&parameterTable[i].DefaultValue;
            switch (i) {
            case SWAP_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->SwapAddressBits;
                break;

            case USEDIX_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->UseDix;
                break;

            case T1_TICK_ONE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T1TickOne;
                break;

            case T2_TICK_ONE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T2TickOne;
                break;

            case Ti_TICK_ONE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.TiTickOne;
                break;

            case T1_TICK_TWO_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T1TickTwo;
                break;

            case T2_TICK_TWO_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T2TickTwo;
                break;

            case Ti_TICK_TWO_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.TiTickTwo;
                break;

            case FRAME_SIZE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->UseEthernetFrameSize;
                break;

            }
        }
        GetAdapterParameters(AdapterName, parameterTable, NUMBER_OF_DLC_PARAMETERS, FALSE);
        FREE_MEMORY_DRIVER(parameterTable);
    }

#if DBG
    if (DebugConfig) {
        DbgPrint("DLC.LoadAdapterConfigurationFromRegistry for adapter %ws:\n"
                 "\tSwap . . . . . . . . . : %d\n"
                 "\tUseDixOverEthernet . . : %d\n"
                 "\tT1TickOne. . . . . . . : %d\n"
                 "\tT2TickOne. . . . . . . : %d\n"
                 "\tTiTickOne. . . . . . . : %d\n"
                 "\tT1TickTwo. . . . . . . : %d\n"
                 "\tT2TickTwo. . . . . . . : %d\n"
                 "\tTiTickTwo. . . . . . . : %d\n"
                 "\tUseEthernetFrameSize . : %d\n",
                 AdapterName->Buffer,
                 ConfigInfo->SwapAddressBits,
                 ConfigInfo->UseDix,
                 ConfigInfo->TimerTicks.T1TickOne,
                 ConfigInfo->TimerTicks.T2TickOne,
                 ConfigInfo->TimerTicks.TiTickOne,
                 ConfigInfo->TimerTicks.T1TickTwo,
                 ConfigInfo->TimerTicks.T2TickTwo,
                 ConfigInfo->TimerTicks.TiTickTwo,
                 ConfigInfo->UseEthernetFrameSize
                 );
    }
#endif

}

#ifdef NDIS40

NTSTATUS
GetAdapterWaitTimeout(
    PULONG pulWait)

/*++

 Routine Description:
       
    Some adapters are delayed during initialization and are not completed
    even after the PnPBindsComplete event (such as ATM LANE adapter). 
    This timeout value 'WaitForAdapter' indicates how many seconds to wait for
    an adapter if is not already present/bound in LlcOpenAdapter    

 Arguments:
    
    pulWait -- Pointer to variable to store the wait timeout.
    
 Return Value:
 
    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/

{
    NTSTATUS          NtStatus;
    HANDLE            hDlc;
    HANDLE            hDlcParms;
    OBJECT_ATTRIBUTES ObjAttribs;
    ULONG             ulDisp;

    NtStatus = OpenDlcRegistryHandle(&DlcRegistryPath, &hDlc);

    if (NT_SUCCESS(NtStatus))
    {
        InitializeObjectAttributes(
            &ObjAttribs,
            &ParametersPath,
            OBJ_CASE_INSENSITIVE,
            hDlc,
            NULL);
    
        NtStatus = ZwCreateKey(
            &hDlcParms,
            KEY_READ,
            &ObjAttribs,
            0,
            NULL,
            0,
            &ulDisp);

        if (NT_SUCCESS(NtStatus))
        {
            PDLC_REGISTRY_PARAMETER pWaitTimeout;

            pWaitTimeout = (PDLC_REGISTRY_PARAMETER) ALLOCATE_MEMORY_DRIVER(
                sizeof(DLC_REGISTRY_PARAMETER));

            if (pWaitTimeout)
            {
                RtlCopyMemory(
                    pWaitTimeout, 
                    &AdapterInitTimeout, 
                    sizeof(AdapterInitTimeout));

                pWaitTimeout->Descriptor.Variable = pulWait;
                pWaitTimeout->Descriptor.Value = (PVOID)&pWaitTimeout->DefaultValue;

                NtStatus = GetRegistryParameter(
                    hDlcParms,
                    pWaitTimeout,
                    FALSE); // Don't set on fail.
            
                FREE_MEMORY_DRIVER(pWaitTimeout);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            ZwClose(hDlcParms);
        }

        CloseDlcRegistryHandle(hDlc);
    }

    return (NtStatus);
}
#endif // NDIS40


NTSTATUS
GetAdapterParameters(
    IN PUNICODE_STRING AdapterName,
    IN PDLC_REGISTRY_PARAMETER Parameters,
    IN ULONG NumberOfParameters,
    IN BOOLEAN SetOnFail
    )

/*++

Routine Description:

    Retrieves a list of parameters from the DLC\Parameters\<AdapterName> section
    in the registry

Arguments:

    AdapterName         - pointer to UNICODE_STRING identifying adapter section
                          in DLC section of registry to open
    Parameters          - pointer to array of DLC_REGISTRY_PARAMETER structures
                          describing variables and default values to retrieve
    NumberOfParameters  - number of structures in Parameters array
    SetOnFail           - TRUE if we should set the registry parameter if we
                          fail to get it

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    NTSTATUS status;
    HANDLE dlcHandle;

    ASSUME_IRQL(PASSIVE_LEVEL);

    status = OpenDlcRegistryHandle(&DlcRegistryPath, &dlcHandle);
    if (NT_SUCCESS(status)) {

        HANDLE adapterHandle;
        BOOLEAN created;

        status = OpenDlcAdapterRegistryHandle(dlcHandle,
                                              AdapterName,
                                              &adapterHandle,
                                              &created
                                              );
        if (NT_SUCCESS(status)) {
            while (NumberOfParameters--) {

                //
                // if this adapter section was created then create the parameter
                // value entries and set them to the defaults, else retrieve the
                // current registry values
                //

                if (created) {
                    SetRegistryParameter(adapterHandle, Parameters);
                } else {
                    GetRegistryParameter(adapterHandle, Parameters, SetOnFail);
                }
                ++Parameters;
            }
            CloseAdapterRegistryHandle(adapterHandle);
        }
        CloseDlcRegistryHandle(dlcHandle);
    }
    return status;
}


NTSTATUS
OpenDlcRegistryHandle(
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE DlcRegistryHandle
    )

/*++

Routine Description:

    Opens a handle to the DLC section in the registry

Arguments:

    RegistryPath        - pointer to UNICODE_STRING giving full registry path to
                          DLC section
    DlcRegistryHandle   - returned handle

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    ULONG disposition;

    ASSUME_IRQL(PASSIVE_LEVEL);

    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    status = ZwCreateKey(DlcRegistryHandle,
                         KEY_WRITE, // might want to update something in registry
                         &objectAttributes,
                         0,         // title index
                         NULL,      // class
                         0,         // create options
                         &disposition
                         );

#if DBG
    if (DebugConfig) {
        if (!NT_SUCCESS(status)) {
            DbgPrint("DLC.OpenDlcRegistryHandle: Error: %08x\n", status);
        }
    }
#endif

    return status;
}


NTSTATUS
OpenDlcAdapterRegistryHandle(
    IN HANDLE DlcRegistryHandle,
    IN PUNICODE_STRING AdapterName,
    OUT PHANDLE DlcAdapterRegistryHandle,
    OUT PBOOLEAN Created
    )

/*++

Routine Description:

    Opens a handle to the DLC\Parameters\<AdapterName> section in the registry.
    If this node does not exist, it is created

Arguments:

    DlcRegistryHandle           - open handle to DLC section in registry
    AdapterName                 - name of adapter in Parameters section. This
                                  MUST be of the form \Device\<adapter_name>
    DlcAdapterRegistryHandle    - returned open handle
    Created                     - returned TRUE if the handle was created

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    UNICODE_STRING keyName;
    UNICODE_STRING adapterName;
    WCHAR keyBuffer[sizeof(PARAMETERS_STRING) + MAX_ADAPTER_NAME_LENGTH];
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    ULONG disposition;

    ASSUME_IRQL(PASSIVE_LEVEL);

    keyName.Buffer = keyBuffer;
    keyName.Length = 0;
    keyName.MaximumLength = sizeof(keyBuffer);
    RtlCopyUnicodeString(&keyName, &ParametersPath);

    RtlInitUnicodeString(&adapterName, AdapterName->Buffer);
    adapterName.Buffer += sizeof(L"\\Device") / sizeof(L"") - 1;
    adapterName.Length -= sizeof(L"\\Device") - sizeof(L"");
    adapterName.MaximumLength -= sizeof(L"\\Device") - sizeof(L"");
    RtlAppendUnicodeStringToString(&keyName, &adapterName);

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               DlcRegistryHandle,
                               NULL
                               );

    //
    // if the DLC\Parameters\<adapter_name> key does not exist, then we will
    // create it
    //

    status = ZwCreateKey(DlcAdapterRegistryHandle,
                         KEY_WRITE,
                         &objectAttributes,
                         0,
                         NULL,
                         0,
                         &disposition
                         );
    *Created = (disposition == REG_CREATED_NEW_KEY);

#if DBG
    if (DebugConfig) {
        if (!NT_SUCCESS(status)) {
            DbgPrint("DLC.OpenDlcAdapterRegistryHandle: Error: %08x\n", status);
        }
    }
#endif

    return status;
}


NTSTATUS
GetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter,
    IN BOOLEAN SetOnFail
    )

/*++

Routine Description:

    Retrieves a parameter from a section of the registry. If the section cannot
    be accessed or returns invalid data, then we get the default value from the
    Parameter structure

Arguments:

    KeyHandle   - open handle to the required section in the registry
    Parameter   - pointer to DLC_REGISTRY_PARAMETER structure giving address and
                  type of the parameter to be retrieved, etc.
    SetOnFail   - if we fail to get the value from the registry, we try to set
                  the default value in the registry

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    NTSTATUS status;
    UNICODE_STRING parameterName;
    UCHAR informationBuffer[MAX_INFORMATION_BUFFER_LENGTH];
    PKEY_VALUE_FULL_INFORMATION valueInformation = (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    ULONG informationLength;

    ASSUME_IRQL(PASSIVE_LEVEL);

    RtlInitUnicodeString(&parameterName, Parameter->ParameterName);
    status = ZwQueryValueKey(KeyHandle,
                             &parameterName,
                             KeyValueFullInformation,
                             (PVOID)valueInformation,
                             sizeof(informationBuffer),
                             &informationLength
                             );
    if (NT_SUCCESS(status) && valueInformation->DataLength) {

        //
        // use the value retrieved from the registry
        //

        status = DlcpGetParameter(Parameter->ParameterName,
                                  valueInformation->Type,
                                  (PVOID)&informationBuffer[valueInformation->DataOffset],
                                  valueInformation->DataLength,
                                  NULL,
                                  (PVOID)&Parameter->Descriptor
                                  );
    } else {

#if DBG

        if (DebugConfig) {
            if (!NT_SUCCESS(status)) {
                DbgPrint("DLC.GetRegistryParameter: Error: %08x\n", status);
            } else {
                DbgPrint("DLC.GetRegistryParameter: Error: valueInformation->DataLength is 0\n");
            }
        }

#endif

        if (!NT_SUCCESS(status) && SetOnFail) {
            SetRegistryParameter(KeyHandle, Parameter);
        }

        //
        // set the default value
        //

        status = DlcpGetParameter(Parameter->ParameterName,
                                  Parameter->Descriptor.Type,
                                  Parameter->Descriptor.Value,
                                  Parameter->Descriptor.Length,
                                  NULL,
                                  (PVOID)&Parameter->Descriptor
                                  );
    }
    return status;
}


NTSTATUS
SetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter
    )

/*++

Routine Description:

    Sets a parameter in the DLC\Parameters\<AdapterName> section

Arguments:

    KeyHandle   - open handle to required section in registry
    Parameter   - pointer to DLC_REGISTRY_PARAMETER containing all required
                  parameter information

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    NTSTATUS status;
    UNICODE_STRING name;

    ASSUME_IRQL(PASSIVE_LEVEL);

    RtlInitUnicodeString(&name, Parameter->ParameterName);
    status = ZwSetValueKey(KeyHandle,
                           &name,
                           0,   // TitleIndex
                           Parameter->Descriptor.Type,
                           Parameter->Descriptor.Value,
                           Parameter->Descriptor.Length
                           );

#if DBG

    if (DebugConfig) {
        if (!NT_SUCCESS(status)) {
            DbgPrint("DLC.SetRegistryParameter: Error: %08x\n", status);
        }
    }

#endif

    return status;
}


NTSTATUS
DlcpGetParameter(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    Call-back function which copies the data retrieved from the registry to
    a variable

Arguments:

    ValueName       - pointer to name of parameter being set (ignored)
    ValueType       - type of parameter being set
    ValueData       - pointer to data retrieved from registry
    ValueLength     - length of data retrieved
    Context         - ignored
    EntryContext    - pointer to REGISTRY_PARAMETER_DESCRIPTOR structure

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{

#define Descriptor ((PREGISTRY_PARAMETER_DESCRIPTOR)EntryContext)

    //
    // if we have a registry entry for the parameter, but it is a different
    // type from that expected (say REG_SZ instead of REG_DWORD) then we use
    // the default type, length and value
    //

    if (ValueType != Descriptor->Type) {

#if DBG
        DbgPrint("DLC.DlcpGetParameter: Error: type for %ws is %d, expected %d, using default\n",
                 ValueName,
                 ValueType,
                 Descriptor->Type
                 );
#endif

        ValueType = Descriptor->Type;
        ValueData = Descriptor->Value;
        ValueLength = Descriptor->Length;
    }

    switch (ValueType) {
    case REG_DWORD: {

        ULONG value;

        if (Descriptor->RealType == PARAMETER_IS_BOOLEAN) {
            value = (*(PULONG)ValueData != 0);
            *(PBOOLEAN)(Descriptor->Variable) = (BOOLEAN)value;

            //
            // no limit check for BOOLEAN type
            //

            break;
        } else {
            value = *(PULONG)ValueData;
        }

        //
        // check range. If outside range, use default. Comparison is ULONG
        //

        if (value < Descriptor->LowerLimit || value > Descriptor->UpperLimit) {

#if DBG
            DbgPrint("DLC.DlcpGetParameter: Error: Parameter %ws = %d: Out of range (%d..%d). Using default = %d\n",
                     ValueName,
                     value,
                     Descriptor->LowerLimit,
                     Descriptor->UpperLimit,
                     *(PULONG)(Descriptor->Value)
                     );
#endif

            value = *(PULONG)(Descriptor->Value);
        }
        if (Descriptor->RealType == PARAMETER_IS_UCHAR) {
            *(PUCHAR)(Descriptor->Variable) = (UCHAR)value;
        } else {
            *(PULONG)(Descriptor->Variable) = value;
        }
        break;
    }

#if DBG
    default:
        DbgPrint("DLC.DlcpGetParameter: Error: didn't expect ValueType %d\n", ValueType);
#endif

    }
    return STATUS_SUCCESS;

#undef pDescriptor

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcxmit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcxmit.c

Abstract:

    This module implements all transmit commands of Windows/Nt DLC API

    Contents:
        DlcTransmit

Author:

    Antti Saarenheimo 01-Aug-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>

NTSTATUS
DlcTransmit(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    The procedure implements the gather send of one or more frames.
    DLC API DLL translates all transmit commands to the single command,
    that is implemented by this driver.  All frames must have the same type.

    The general pseudo code for procedure:
        Check input parameters
        for all frames until error
        {
            lock xmit buffers (buffer in buffer pool are already locked)
            if UI, TEST or XID command
                build DLC frame, set the sources address
            send frame
            if command status not pending
                call asynchronous completion routine
        }

Arguments:

    pIrp            - current io request packet
    pFileContext    - DLC process specific adapter context
    pParameters     - the current parameter block
    ParameterLength - the length of input parameters

Return Value:

    NTSTATUS
        STATUS_PENDING
        DLC_STATUS_TRANSMIT_ERROR
        DLC_STATUS_NO_MEMORY
        DLC_STATUS_INVALID_OPTION
        DLC_STATUS_INVALID_STATION_ID;

--*/

{
    PDLC_OBJECT pTransmitObject;
    UINT i;
    PDLC_PACKET pXmitNode, pRootXmitNode;
    UINT FirstSegment;
    NTSTATUS Status;
    UINT DescriptorCount;
    USHORT FrameType;
    USHORT RemoteSap;
    static LARGE_INTEGER UnlockTimeout = { (ULONG) -TRANSMIT_RETRY_WAIT, -1 };
    BOOLEAN mapFrameType = FALSE;

    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('T');

    //
    // first, get and check the DLC station (Direct, SAP or Link)
    //

    Status = GetStation(pFileContext,
                        pDlcParms->Async.Parms.Transmit.StationId,
                        &pTransmitObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    RemoteSap = (USHORT)pDlcParms->Async.Parms.Transmit.RemoteSap;
    FrameType = pDlcParms->Async.Parms.Transmit.FrameType;

    //
    // The object type and the transmitted frame types must be compatible!
    //

    if (FrameType == LLC_I_FRAME) {
        if (pTransmitObject->Type != DLC_LINK_OBJECT) {
            return DLC_STATUS_INVALID_STATION_ID;
        }
    } else if (FrameType == LLC_DIRECT_TRANSMIT
    || FrameType == LLC_DIRECT_MAC
    || FrameType == LLC_DIRECT_8022
    || FrameType >= LLC_FIRST_ETHERNET_TYPE) {

        if (pTransmitObject->Type != DLC_DIRECT_OBJECT) {
            return DLC_STATUS_INVALID_STATION_ID;
        }

        //
        // RLF 3/4/94
        //
        // This is somewhat bogus: it was originally intended that AcsLan would
        // pass in a meaningful FrameType value for TRANSMIT.DIR.FRAME.
        // However, it always passes through LLC_TRANSMIT_DIRECT. It is obvious
        // that for DIX frames, FrameType should contain the DIX type field. For
        // example, the RIPL server talks using DIX frame type 0x0600. Therefore,
        // the FrameType *should* be 0x0600 if comments and some of the code in
        // this driver is to be believed (not entirely a good idea). However,
        // AcsLan is missing an important piece of information: it doesn't know
        // if the direct station was opened to transmit DIX frames on ethernet,
        // or if its the originally intended direct station used to send and
        // receive MAC frames on Token Ring (although it wouldn't be too difficult
        // to make a good guess at this). So AcsLan just punts and hands
        // responsibility to this routine which then abnegates that responsibility.
        // So this following if (...) is always going to branch to the next block
        // if we were entered as a consequence of AcsLan (virtual 100% probability).
        // We'll leave it here just in case somebody has forsaken AcsLan and used
        // their own call into the driver (but lets face it, DIX frames will never
        // work without this fix, so its moot).
        // We instead set mapFrameType = TRUE if FrameType was LLC_DIRECT_TRANSMIT
        // on entry AND the protocol offset in the DIX station object is not zero.
        // Just before we submit the frame to LlcSendU we will convert the FrameType
        // and RemoteSap parameters - at that point we have all the information and
        // we know exactly where the DIX type field is kept
        //

        if (FrameType >= LLC_FIRST_ETHERNET_TYPE) {

            //
            // LlcSendU requires the ethernet type in RemoteSap
            //

            RemoteSap = FrameType;
            FrameType = 0;
        } else if (FrameType == LLC_DIRECT_TRANSMIT) {
            if (pTransmitObject->u.Direct.ProtocolTypeOffset) {
                mapFrameType = TRUE;
            }
        }
    } else if (FrameType > LLC_TEST_COMMAND_POLL || FrameType & 1) {
        return DLC_STATUS_INVALID_OPTION;
    } else {
        if (pTransmitObject->Type != DLC_SAP_OBJECT) {
            return DLC_STATUS_INVALID_STATION_ID;
        }
    }

    if (pDlcParms->Async.Parms.Transmit.XmitReadOption > DLC_CHAIN_XMIT_IN_SAP) {
        return DLC_STATUS_INVALID_OPTION;
    }

    //
    // check the input buffer size and that it is consistent
    // with the descriptor count
    //

    DescriptorCount = (UINT)pDlcParms->Async.Parms.Transmit.XmitBufferCount;

    if (sizeof(LLC_TRANSMIT_DESCRIPTOR) * (DescriptorCount - 1)
        + sizeof(NT_DLC_TRANSMIT_PARMS)
        + sizeof(NT_DLC_CCB) != (UINT)ParameterLength) {

        return DLC_STATUS_TRANSMIT_ERROR;
    }

    //
    // The transmit node (or packet) of the frame is also the root node of all
    // frames in this command. The transmit command is completed when all its
    // frames have been sent or acknowledged (if we are sending I-frames)
    //

    pXmitNode = pRootXmitNode = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pRootXmitNode == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // This counter keeps this object alive, when the transmit command is being
    // processed (actually it doesn't help when the adapter is closed or a DLC
    // SAP is reset)
    //

    pTransmitObject->PendingLlcRequests++;
    pRootXmitNode->Node.FrameCount = 1;
    pRootXmitNode->Node.pIrp = pIrp;
    FirstSegment = 0;

    for (i = 1; ; i++) {

        if (i == DescriptorCount
        || pDlcParms->Async.Parms.Transmit.XmitBuffer[i].eSegmentType == LLC_FIRST_DATA_SEGMENT) {

            //
            // The send completion routine will complete the whole IRP,
            // when the frame count hits zero => we must have one
            // extra frame all the time to prevent the command
            // to complete when we are still sending it in LLC.
            //

            pRootXmitNode->Node.FrameCount++;
            pTransmitObject->PendingLlcRequests++;

            //
            // We must reference the LLC object to keep it alive,
            // when the transmit command is queued on LLC.
            // For example, Control-C could kill the llc object and
            // reset its pointer while we are calling the llc object
            // (that really happened!)
            //

            ReferenceLlcObject(pTransmitObject);

            //
            // The xmit buffer building may cause a page fault =>
            // we must lower the IRQ level and release the spin locks.
            //

            LEAVE_DLC(pFileContext);

            RELEASE_DRIVER_LOCK();

            //
            // We don't need to reference the buffer pool, that may
            // exist, because the llc object reference counter
            // protects also the buffer pool.  The buffer pool
            // is not deleted before all llc objects have been deleted!
            //

            //
            // Operating system allows each process lock physical memory
            // only a limited amount.  The whole system may also be out
            // of the available physical memory (and it's a very typical
            // situation in Windows/Nt)
            //

            Status = BufferPoolBuildXmitBuffers(
                        pFileContext->hBufferPool,
                        i - FirstSegment,
                        &pDlcParms->Async.Parms.Transmit.XmitBuffer[FirstSegment],
                        pXmitNode
                        );

            ACQUIRE_DRIVER_LOCK();

            if (Status != STATUS_SUCCESS) {

                //
                // The muliple packet sends are very difficult to recover.
                // The caller cannot really know which frames were sent
                // and which ones were lost.  Thus we just spend 1 second
                // sleeping and retrying to send the data.  Note: this
                // time is aways from from any abortive closing, thus
                // this cannot be any longer wait.  Keep this stuff is also
                // outside of the main transmit code path.
                //

                if (i < DescriptorCount) {

                    UINT RetryCount;

                    for (RetryCount = 0;
                        (RetryCount < 10) && (Status != STATUS_SUCCESS);
                        RetryCount++) {

                        RELEASE_DRIVER_LOCK();

                        //
                        // Sleep 100 ms and try again.
                        //

                        LlcSleep(100000L);        // this is microseconds!

                        Status = BufferPoolBuildXmitBuffers(
                            pFileContext->hBufferPool,
                            i - FirstSegment,
                            &pDlcParms->Async.Parms.Transmit.XmitBuffer[FirstSegment],
                            pXmitNode
                            );

                        ACQUIRE_DRIVER_LOCK();

//#if DBG
//                            if (Status != STATUS_SUCCESS) {
//                                DbgPrint("DLC.DlcTransmit: Error: Can't build transmit buffer, retrying. Status=%x\n",
//                                        Status
//                                        );
//                            }
//#endif

                    }
                }
                if (Status != STATUS_SUCCESS) {

                    ENTER_DLC(pFileContext);

                    //
                    // We failed, cancel the transmit command
                    //

                    DereferenceLlcObject(pTransmitObject);

                    //
                    // The first error cancels the whole transmit command.
                    // Usually there is no sense to send more frames when
                    // the send of a frame has been failed.
                    //

                    pTransmitObject->PendingLlcRequests--;
                    pRootXmitNode->Node.FrameCount--;
                    if (pXmitNode != pRootXmitNode) {

                        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pXmitNode);

                        pXmitNode = NULL;
                    }
                    pIrp->IoStatus.Status = Status;

//#if DBG
//                    DbgPrint("DLC.DlcTransmit: Error: Can't build transmit buffer. Status=%x\n",
//                            Status
//                            );
//#endif

                    goto DlcTransmit_ErrorExit;
                }
            }

            //
            // Chain the returned buffers to the root xmit node
            // of this transmit command
            //

            pXmitNode->Node.pTransmitNode = pRootXmitNode;
            FirstSegment = i;

            if (FrameType == LLC_I_FRAME) {
                pXmitNode->LlcPacket.Data.Xmit.pMdl = pXmitNode->Node.pMdl;

                LlcSendI(pTransmitObject->hLlcObject,
                         &(pXmitNode->LlcPacket)
                         );
            } else {

                //
                // For non-I frames the LAN header and its actual information
                // buffers are in diffenret MDLs. The first MDL includes the
                // LAN header. The LAN header length must be excluded from the
                // length of the information field ?
                // We don't need to know the LAN header length, because figured
                // out by the data link layer (actually we could not know it
                // here, the real packet length depends on the LAN header type
                // we are really using).
                //

                pXmitNode->LlcPacket.Data.Xmit.pLanHeader = MmGetSystemAddressForMdl(pXmitNode->Node.pMdl);
                pXmitNode->LlcPacket.Data.Xmit.pMdl = pXmitNode->Node.pMdl->Next;
                pXmitNode->LlcPacket.InformationLength -= (USHORT)MmGetMdlByteCount(pXmitNode->Node.pMdl);

                //
                // RLF 3/4/94
                //
                // if the frame is being sent on the direct station, but we are
                // on ethernet and actually have the direct station open in DIX
                // mode, then we need to convert the FrameType and RemoteSap to
                // be 0 and the DIX identifier, respectively
                //

                if (mapFrameType) {

                    PUCHAR lanHeader = pXmitNode->LlcPacket.Data.Xmit.pLanHeader;

                    //
                    // the DIX format is fixed, and unlike the rest of DLC,
                    // expects ethernet format addresses, with no AC or FC
                    // bytes
                    //

                    RemoteSap = ((USHORT)lanHeader[12]) << 8 | lanHeader[13];
                    FrameType = 0;
                }

                LlcSendU(pTransmitObject->hLlcObject,
                         &(pXmitNode->LlcPacket),
                         FrameType,
                         RemoteSap
                         );
            }

            ENTER_DLC(pFileContext);

            //
            // Note: Llc object may be deleted during this dereference,
            // but is does not delete the DLC object.
            // We will return with an error, if there are more frames
            // to be sent and the dlc object is not any more open
            // (but not yet deleted).
            //

            DereferenceLlcObject(pTransmitObject);

            //
            // Allocate a new packet, if we are sending multiple packets,
            // We must also check, that the current object is still
            // alive and that we can send the packets
            //

            if (i < DescriptorCount) {
                if (pTransmitObject->State != DLC_OBJECT_OPEN) {
                    pIrp->IoStatus.Status = DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION;
                    break;
                }
                pXmitNode = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

                if (pXmitNode == NULL) {
                    pIrp->IoStatus.Status = DLC_STATUS_NO_MEMORY;
                    break;
                }
            } else {
                break;
            }
        }
    }

    //
    // fall through here on normal exit
    //

DlcTransmit_Exit:

    //
    // Decrement the frame counter to the correct value to make
    // the IRP command completion possible.
    //

    //
    // If we determine that we couldn't give the frame to LLC then we will
    // complete the transmit request with an immediate status IF there was
    // only 1 frame submitted. If the request was TRANSMIT.FRAMES then we
    // may have already submitted several frames which may have been completed
    // asynchronously
    //
    // If we are completed the request synchronously make sure that we have
    // gotten rid of any resources we allocated
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    pRootXmitNode->Node.FrameCount--;
    if (pRootXmitNode->Node.FrameCount == 0) {
        CompleteTransmitCommand(pFileContext, pIrp, pTransmitObject, pRootXmitNode);
    }
#if DBG
	else
	{
		//
		// this IRP is cancellable
		//

		SetIrpCancelRoutine(pIrp, TRUE);

	}
#endif	// DBG

    Status = STATUS_PENDING;

    //
    // Now this transmit operation is complete,
    // We must decrement the reference counter and
    // check, if we should call the close completion routine.
    //

DlcTransmit_CheckClose:

    pTransmitObject->PendingLlcRequests--;
    if (pTransmitObject->State != DLC_OBJECT_OPEN) {
        CompleteCloseStation(pFileContext, pTransmitObject);
    }

    //
    // The DLC completion routine will always complete the transmit
    // commands.   Usually the command is already completed here in
    // the case of connectionless frames.
    //

    return Status;

DlcTransmit_ErrorExit:

    //
    // come here if we determine that we couldn't give a frame to LLC. This may
    // be a single frame transmit, or multiple (TRANSMIT.FRAMES). If multiple
    // then we have to take the asynchronous way out if frames have already been
    // submitted. If a single frame then we can complete the IRP synchronously
    // and return an immediate error status
    //

    if (pRootXmitNode->Node.FrameCount > 1) {

        //
        // multiple frames!
        //

//#if DBG
//        DbgPrint("DLC.DlcTransmit: Multiple frame error exit! (%d). Status = %x\n",
//                pRootXmitNode->Node.FrameCount,
//                Status
//                );
//#endif

        goto DlcTransmit_Exit;
    }
    pRootXmitNode->Node.FrameCount--;

    ASSERT(pRootXmitNode->Node.FrameCount == 0);

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pRootXmitNode);

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    if (Status >= DLC_STATUS_ERROR_BASE && Status <= DLC_STATUS_MAX_ERROR) {
        Status -= DLC_STATUS_ERROR_BASE;
    }

    ASSERT(Status <= LLC_STATUS_MAX_ERROR);

    pDlcParms->Async.Ccb.uchDlcStatus = (LLC_STATUS)Status;

//#if DBG
//    DbgPrint("DLC.DlcTransmit: Returning Immediate Status %x\n", Status);
//#endif

    goto DlcTransmit_CheckClose;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcrcv.c ===
/*++

Copyright (c) 1991 Microsoft Corporation Copyright
          (c) 1991 Nokia Data Systems AB

Module Name:

    dlcrcv.c

Abstract:

    This module implements the DLC receive and read commands

    Contents:
        DlcReceiveRequest
        ReceiveCompletion
        DlcReadRequest
        ReadCompletion
        CompleteCompletionPacket
        CreateBufferChain
        DlcReceiveCancel

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif

#include <dlc.h>
#include "dlcdebug.h"
#include "llc.h"        // SwapMemCpy

//
// Option indicator defines how we will use the command and event queues:
// 0 => only this station id
// 1 => all events for the sap number in station id
// 2 => all events to any station id
// This table maps the option indicators to station id masks:
//

static USHORT StationIdMasks[3] = {
    (USHORT)(-1),
    0xff00,
    0
};

//
// receive station id of a direct station defines
// the received frame types.  This table swaps around
// the bits used by IBM.
//

static UCHAR DirectReceiveTypes[LLC_DIR_RCV_ALL_ETHERNET_TYPES + 1] = {
    DLC_RCV_MAC_FRAMES | DLC_RCV_8022_FRAMES,
    DLC_RCV_MAC_FRAMES,
    DLC_RCV_8022_FRAMES,
    0,                      // DLC_RCV_SPECIFIC_DIX,
    DLC_RCV_MAC_FRAMES | DLC_RCV_8022_FRAMES | DLC_RCV_DIX_FRAMES,
    DLC_RCV_DIX_FRAMES
};


NTSTATUS
DlcReceiveRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    DLC RECEIVE implements two different commands:

        1. It may receive a frame asynchronously when receive flag is zero

        2. It may enable data permanent receiving.  The received frames
           are save to event queue from which they read with READ command.

    The case 1 is not very much used, because there can be only
    one simultaneusly receive command on a dlc station and the frames
    are lost very easily before the next command can be be issued.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    ParameterLength     - not used
    OutputBufferLength  - not used

Return Value:

    NTSTATUS:
        DLC_STATUS_DUPLICATE_COMMAND
        STATUS_PENDING

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pRcvObject;
    ULONG Event;
    USHORT OpenOptions;

    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ParameterLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("DlcReceiveRequest");

    Status = GetStation(pFileContext,
                        pDlcParms->Async.Parms.Receive.usStationId,
                        &pRcvObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }
    if (pFileContext->hBufferPool == NULL) {
        return DLC_STATUS_INADEQUATE_BUFFERS;
    }

    //
    // There can be only one simultaneous receive command
    //

    if (pRcvObject->pRcvParms != NULL) {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }

    if (pDlcParms->Async.Parms.Receive.usUserLength > MAX_USER_DATA_LENGTH) {
        return DLC_STATUS_USER_LENGTH_TOO_LARGE;
    }

    if (pDlcParms->Async.Parms.Receive.ulReceiveFlag != 0) {
        if (pDlcParms->Async.Parms.Receive.uchRcvReadOption >= INVALID_RCV_READ_OPTION) {
            return DLC_STATUS_INVALID_OPTION;
        }

        //
        // Everything is ready for the receive, we will now use buffer pool
        // to receive frames sent to this object, but applications must
        // make READ command to get the data from the buffer pool.
        //

        Event = LLC_RECEIVE_COMMAND_FLAG;
    } else {

        //
        // Receive read option flag is set also for the normal receive
        // to make its handling the same as the data receiving with READ
        //

        Event = LLC_RECEIVE_DATA;    // we do only a normal receive
    }

    //
    // The receive command for a direct station defines the
    // type of the receive frames => we must set the
    // receive flags every time the receive command is issued
    // and remove them, when it is completed or canceled.
    //

    if (pRcvObject->Type == DLC_DIRECT_OBJECT) {
        if (pDlcParms->Async.Parms.Receive.usStationId > LLC_DIR_RCV_ALL_ETHERNET_TYPES) {
            return DLC_STATUS_INVALID_STATION_ID;
        }

        //
        // The two lowest bits the receive mask are inverted =>
        // They must be changed, when the llc driver is called.
        // ---
        // The MAC frames must have been enabled by the open options
        // of the direct station.
        //

        OpenOptions = (USHORT)(DirectReceiveTypes[pDlcParms->Async.Parms.Receive.usStationId]
                                & pRcvObject->u.Direct.OpenOptions);

        //
        // We create an appropriate LLC object only when the direct station
        // has an active receive. The LLC object is deleted when the receive
        // terminates. This feature is implemented to support two different
        // kinds of LLC objects: (i) DLC Direct stations receiving MAC and
        // IEEE 802.2 frames and (ii) DIX ethernet type stations receiving
        // all frames having the selected ethernet type
        //

        if (OpenOptions & LLC_VALID_RCV_MASK) {
            LlcSetDirectOpenOptions(pRcvObject->hLlcObject, OpenOptions);
        }
    }
    pRcvObject->pRcvParms = pDlcParms;

    //
    // this IRP is cancellable
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, TRUE);

//    ACQUIRE_DRIVER_LOCK();

    //
    // We must queue both receive command types, the other can receive
    // data normally, but the second is in the queue only be cancelled
    // with its CCB address.
    //

    Status = QueueDlcCommand(pFileContext,
                             Event,
                             pRcvObject->StationId,
                             (USHORT)(-1),                   // only this station id
                             pIrp,                           // IRP
                             pDlcParms->Async.Ccb.pCcbAddress,
                             ReceiveCompletion               // completion handler
                             );

    //
    // Reset receive parameter link if this receive
    // command was not pending for some reason (eg. an error)
    //

    if (Status != STATUS_PENDING) {
        pRcvObject->pRcvParms = NULL;
    } else if (pRcvObject->Type != DLC_DIRECT_OBJECT) {

        //
        // The link station may be in a local busy state, if they
        // do not have a pending receive.  That's why we must
        // clear the local busy states for a single link station
        // or all link stations of a sap station, if the receive
        // is made for the whole sap.  This will clear simultaneously
        // also the "out of receive buffers" states, but
        // it does nto matter, because they can be set again.
        // This command does not change the local busy state, if
        // it has been set by user.
        //

        ReferenceLlcObject(pRcvObject);

        LEAVE_DLC(pFileContext);

        LlcFlowControl(pRcvObject->hLlcObject, LLC_RESET_LOCAL_BUSY_BUFFER);

        ENTER_DLC(pFileContext);

        DereferenceLlcObject(pRcvObject);
    }
    return Status;
}


BOOLEAN
ReceiveCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    )

/*++

Routine Description:

    The function handles the data receive event and completes
    the pending receive command.

Arguments:

    pFileContext
    pDlcObject          - the DLC object (sap, link or direct station) of the
                          current event (or/and the read command)
    pIrp                - interrupt request packet of this READ command
    Event               - event code
    pEventInformation   - event specific information
    SecondaryInfo       - used as a miscellaneous secondary parameter
                          at least the ReadFlag of the received frame, as a
                          command completion flag in transmit completion

Return Value:

    BOOLEAN

--*/

{
    PNT_DLC_PARMS pDlcParms;
    USHORT ReceivedFrameCount;

    UNREFERENCED_PARAMETER(Event);
    UNREFERENCED_PARAMETER(SecondaryInfo);

    DIAG_FUNCTION("ReceiveCompletion");

    pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

    CreateBufferChain((PDLC_BUFFER_HEADER)pEventInformation,
                      (PVOID *)&pDlcParms->Async.Parms.Receive.pFirstBuffer,
                      &ReceivedFrameCount   // this should be always 1
                      );

    //
    // IBM DLC API defines, that there can be only one receive command
    // pending for an object.  The receive parameter table pointer
    // disables the further receive commands while one is pending.
    //

    pDlcObject->pRcvParms = NULL;

    //
    // Queue a command completion event, if the command completion
    // flag has been defined in the CCB
    //

    if (pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {
        MakeDlcEvent(pFileContext,
                     DLC_COMMAND_COMPLETION,
                     pDlcObject->StationId,
                     NULL,
                     pDlcParms->Async.Ccb.pCcbAddress,
                     pDlcParms->Async.Ccb.CommandCompletionFlag,
                     FALSE
                     );
    }

    //
    // If this is RECEIVE2 (CCB and its parameter block catenated
    // together), then we copy back the whole buffer).
    // => change the size of the parameter block copied back to user.
    // The default output buffer size is defined for the receive commands
    // with a read flag.
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_DLC_RECEIVE2) {
        pIrp->IoStatus.Information = sizeof(LLC_RECEIVE_PARMS) + sizeof(NT_DLC_CCB);
    } else {

        //
        // MODMOD RLF 01/23/93
        //
        // Performance (slight). The following is a single-dword write
        //

        //LlcMemCpy(MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl),
        //          &pDlcParms->Async.Parms.Receive.pFirstBuffer,
        //          aSpecialOutputBuffers[IOCTL_DLC_RECEIVE_INDEX]
        //          );

        PVOID* pChain;

        pChain = (PVOID*)MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl);
        *pChain = pDlcParms->Async.Parms.Receive.pFirstBuffer;

        //
        // MODMOD ends
        //

        UnlockAndFreeMdl(pDlcParms->Async.Ccb.u.pMdl);

        //
        // RLF 02/23/94
        //
        // zap the pMdl field to avoid trying to unlock and free the MDL again
        //

        pDlcParms->Async.Ccb.u.pMdl = NULL;
    }
    CompleteAsyncCommand(pFileContext, STATUS_SUCCESS, pIrp, NULL, FALSE);
    return TRUE;
}


NTSTATUS
DlcReadRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    The READ command emulates all posting features provided in DOS DLC API.

    The command can be used:
        1. To receive data
        2. To read DLC status indications (connect and disconnect indications)
        3. To complele other asynchronous commands (transmit, receive,
           close, reset, connect)
        4. To handle exceptions on NDIS (or on DLC) driver

    See IBM documentation for more information about DLC READ.

Arguments:

    pIrp            - current io request packet
    pFileContext    - DLC process specific adapter context
    pDlcParms       - the current parameter block
    ParameterLength - the length of input parameters

Return Value:

    DLC_STATUS:

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pReadObject;
    PVOID AbortHandle;

    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ParameterLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("DlcReadRequest");

//
//  Receive request alread checks, that buffer pool has been defined,
//  and we may complete commands or read dlc events before
//  the buffer pool has been created.
//
//    if (pFileContext->hBufferPool == NULL)
//    {
//        return DLC_STATUS_INADEQUATE_BUFFERS;
//    }

    //
    // RLF 04/09/93
    //
    // It should not be possible to have the same READ CCB queued more than once.
    // It could get the app into all sorts of difficulty
    //

    if (IsCommandOnList((PVOID)pDlcParms->Async.Ccb.pCcbAddress, &pFileContext->CommandQueue)) {

#if DBG
        DbgPrint("DLC.DlcReadRequest: Error: CCB %08X already on list\n",
                pDlcParms->Async.Ccb.pCcbAddress
                );
        DbgBreakPoint();
#endif

        return DLC_STATUS_DUPLICATE_COMMAND;
    }

    //
    // Check the input parameters of DLC READ
    //

    if (pDlcParms->Async.Parms.ReadInput.OptionIndicator >= DLC_INVALID_OPTION_INDICATOR) {
        return DLC_STATUS_INVALID_OPTION;
    }

    //
    // If the read is destined for a specific station then we check that the
    // station really exists
    //

    if ((UCHAR)pDlcParms->Async.Parms.ReadInput.OptionIndicator < LLC_OPTION_READ_ALL) {

        Status = GetStation(pFileContext,
                            (USHORT)(pDlcParms->Async.Parms.ReadInput.StationId
                                & StationIdMasks[pDlcParms->Async.Parms.ReadInput.OptionIndicator]),
                            &pReadObject
                            );

        if (Status != STATUS_SUCCESS) {
            return Status;
        }
    }

    //
    // Read commands can be linked to another command by CCB pointer,
    // command completion flag and read flag are a special case.  They
    // can be used only for the completion of a the given command.
    // We use the commands CCB address as a search handle and
    // save it as an abort handle instead of the read command's
    // own CCB address.
    //

    if (pDlcParms->Async.Parms.ReadInput.CommandCompletionCcbLink != NULL) {
        AbortHandle = pDlcParms->Async.Parms.ReadInput.CommandCompletionCcbLink;
        pDlcParms->Async.Parms.ReadInput.EventSet = LLC_RECEIVE_COMMAND_FLAG;
    } else {
        AbortHandle = pDlcParms->Async.Ccb.pCcbAddress;
        pDlcParms->Async.Parms.ReadInput.EventSet &= LLC_READ_ALL_EVENTS;
        if (pDlcParms->Async.Parms.ReadInput.EventSet == 0) {
            return DLC_STATUS_PARAMETER_MISSING;
        }
    }

    //
    // this IRP is cancellable
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, TRUE);

//    ACQUIRE_DRIVER_LOCK();

    return QueueDlcCommand(pFileContext,
                           (ULONG)pDlcParms->Async.Parms.ReadInput.EventSet,
                           pDlcParms->Async.Parms.ReadInput.StationId,
                           StationIdMasks[pDlcParms->Async.Parms.ReadInput.OptionIndicator],
                           pIrp,
                           AbortHandle,
                           ReadCompletion
                           );
}


BOOLEAN
ReadCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    )

/*++

Routine Description:

    The command reads a DLC event and saves its information to
    the returned parameter block of the read command.

Arguments:

    pFileContext        - process specific open context
    pDlcObject          - the DLC object (sap, link or direct station) of the
                          current event (or/and the read command)
    pIrp                - interrupt request packet of this READ command
    Event               - event code
    pEventInformation   - event specific information
    SecondaryInfo       - a miscallaneous secondary parameter, eg. the ReadFlag
                          of the received frame or the command completion flag
                          in transmit completion.

Return Value:

    BOOLEAN
        TRUE    - The packet containing the event information can be returned
                  to its pool
        FALSE   - Do not deallocate the event packet

--*/

{
    BOOLEAN boolDeallocatePacket;
    PNT_DLC_PARMS pParms;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("ReadCompletion");

    pParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;
    boolDeallocatePacket = TRUE;

    //
    // Reset always all unrefernced variables
    // (otherwise they may be garbage)
    //

    LlcZeroMem((PVOID)&pParms->Async.Parms.Read.Event, sizeof(NT_DLC_READ_PARMS) - 4);
    pParms->Async.Parms.Read.Event = (UCHAR)Event;

    switch (Event) {
    case LLC_RECEIVE_DATA:

        //
        // The caller checks always if the DLC object is ready to receive data
        // with read and to selects the correct receive buffer pool
        //

        pParms->Async.Parms.Read.NotificationFlag = SecondaryInfo;

        //
        // The read always resets the receive event
        //

        if (pDlcObject != NULL) {
            pDlcObject->pReceiveEvent = NULL;
        }
        CreateBufferChain(pEventInformation,
                          (PVOID*)&pParms->Async.Parms.Read.u.Event.pReceivedFrame,
                          &pParms->Async.Parms.Read.u.Event.ReceivedFrameCount
                          );
        break;

    case LLC_TRANSMIT_COMPLETION:
        if (SecondaryInfo == 0) {

            //
            // We have created a special completion packet for those chained
            // transmit command completions, whose DLC object have been deleted
            //

            CompleteCompletionPacket(pFileContext,
                                     (PDLC_COMPLETION_EVENT_INFO)pEventInformation,
                                     pParms
                                     );
        } else {

            //
            // Transmit commands do not use any command completion packets,
            // because the LLC module takes care of the command queueing
            // and completion routine. The previous transmit command
            // completion has left its CCB pointer to current object.
            // The sequential non null transmit CCBs create a CCB link
            // list, that is terminated in every READ call.
            //
            // Unlink the command completion event having the xmit
            // commands chained (the next xmit command with the
            // chaining option will setup the link again).
            //

            if (pDlcObject != NULL) {
                pEventInformation = pDlcObject->pPrevXmitCcbAddress;
                pDlcObject->pPrevXmitCcbAddress = NULL;
                pParms->Async.Parms.Read.u.Event.CcbCount = pDlcObject->ChainedTransmitCount;
                pDlcObject->ChainedTransmitCount = 0;
            } else {

                //
                // This is only an lonely unchained xmit completion
                // event. The CCB counter must be always one.
                //

                pParms->Async.Parms.Read.u.Event.CcbCount = 1;
            }
            pParms->Async.Parms.Read.NotificationFlag = SecondaryInfo;
            pParms->Async.Parms.Read.u.Event.pCcbCompletionList = pEventInformation;
        }
        break;

    case DLC_COMMAND_COMPLETION:

        //
        // Close command completions needs a special command completion
        // packet, the other command completions consists only of
        // the ccb address and command completion flag (secondary data).
        // The close command completions have reset the secondary data
        //

        if (SecondaryInfo != 0) {

            //
            // This is the command completion of a normal DLC command.
            //

            pParms->Async.Parms.Read.u.Event.CcbCount = 1;
            pParms->Async.Parms.Read.NotificationFlag = SecondaryInfo;
            pParms->Async.Parms.Read.u.Event.pCcbCompletionList = pEventInformation;
        } else {
            CompleteCompletionPacket(pFileContext,
                                     (PDLC_COMPLETION_EVENT_INFO)pEventInformation,
                                     pParms
                                     );
       }
       break;

    case LLC_CRITICAL_EXCEPTION:

// THIS DEPENDS ON NDIS 3.0
// Talk with Johnson about this case:
// Dos NDIS first return RING_STATUS and then CLOSING status
// LLC should put them together to CRITICAL_EXCEPTION.

        //
        // This event is not handled (?)
        //

        break;

    case LLC_NETWORK_STATUS:

        //
        // The network status change is not a fatal event.
        //

        pParms->Async.Parms.Read.NotificationFlag = pFileContext->NetworkStatusFlag;
        pParms->Async.Parms.Read.u.Event.EventErrorCode = (USHORT)SecondaryInfo;
        break;

    case LLC_STATUS_CHANGE:

        //
        // This is a DLC status change, WE MAY COPY SOME GRABAGE
        // IF THE LINK STATION HAS BEEN DELETED MEANWHILE, But
        // it does not matter, because the non-paged memory
        // alaways exists, and the status table can only be
        // owned by another link station (because the
        // link stations are allocated from a packet pool)
        //

        LlcMemCpy(&pParms->Async.Parms.Read.u.Status.DlcStatusCode,
                  pEventInformation,
                  sizeof(DLC_STATUS_TABLE) - sizeof(PVOID)
                  );

        //
        // RLF 02/23/93 If this is a CONNECT_REQUEST and the medium is Ethernet
        // or FDDI then swap the bits in the reported net address
        //

        if ((pParms->Async.Parms.Read.u.Status.DlcStatusCode == LLC_INDICATE_CONNECT_REQUEST)
        && ((pFileContext->ActualNdisMedium == NdisMedium802_3)
        || (pFileContext->ActualNdisMedium == NdisMediumFddi))) {

            //
            // swap bytes in situ
            //

            SwapMemCpy(TRUE,
                       &pParms->Async.Parms.Read.u.Status.RemoteNodeAddress[0],
                       &pParms->Async.Parms.Read.u.Status.RemoteNodeAddress[0],
                       6
                       );
        }
        pParms->Async.Parms.Read.u.Status.StationId = pDlcObject->StationId;
        pParms->Async.Parms.Read.u.Status.UserStatusValue = pDlcObject->u.Link.pSap->u.Sap.UserStatusValue;
        pParms->Async.Parms.Read.NotificationFlag = pDlcObject->u.Link.pSap->u.Sap.DlcStatusFlag;
        pParms->Async.Parms.Read.u.Status.DlcStatusCode = (USHORT)SecondaryInfo;

        //
        // Each link stations has a DLC status event packet.
        // Those packets must not be deallocated back to the
        // packet pool as the other event packets.
        //

        pDlcObject->u.Link.pStatusEvent->LlcPacket.pNext = NULL;
        pDlcObject->u.Link.pStatusEvent->SecondaryInfo = 0;
        boolDeallocatePacket = FALSE;
        break;

        //
        // System actions are based on the fact, that all apps share the
        // DLC same dlc and physical network adapter.
        // NT NDIS and DLC architectures provide full DLC for each
        // application separately => The system action indications are
        // not needed in NT DLC.
        //
        //        case LLC_SYSTEM_ACTION:
        //            break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    };

    //
    // Copy the optional second output buffer to user memory.
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_DLC_READ) {
        LlcMemCpy(MmGetSystemAddressForMdl((PMDL)pParms->Async.Ccb.u.pMdl),
                  &pParms->Async.Parms.Read.Event,
                  aSpecialOutputBuffers[IOCTL_DLC_READ_INDEX] -
				  ( (PCHAR)&pParms->Async.Parms.Read.Event -
				    (PCHAR)&pParms->Async.Parms.Read )
                  );
        UnlockAndFreeMdl(pParms->Async.Ccb.u.pMdl);
    }
    pParms->Async.Ccb.uchDlcStatus = (UCHAR)STATUS_SUCCESS;
    pParms->Async.Ccb.pCcbAddress = NULL;

    //
    // we are about to complete this IRP - remove the cancel routine
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, FALSE);
    IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);

//    ACQUIRE_DRIVER_LOCK();

    DereferenceFileContext(pFileContext);
    return boolDeallocatePacket;
}


VOID
CompleteCompletionPacket(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMPLETION_EVENT_INFO pCompletionInfo,
    IN OUT PNT_DLC_PARMS pParms
    )

/*++

Routine Description:

    Procedure reads the completion information from
    the command completion packet and saves it to the
    read parameter table.

Arguments:

    pFileContext    - process specific open context
    pCompletionInfo - dlc completion packet
    pParms          - pointer to DLC parameter table

Return Value:

    None

--*/

{
    pParms->Async.Parms.Read.u.Event.CcbCount = pCompletionInfo->CcbCount;
    pParms->Async.Parms.Read.NotificationFlag = pCompletionInfo->CommandCompletionFlag;
    pParms->Async.Parms.Read.u.Event.pCcbCompletionList = pCompletionInfo->pCcbAddress;
    CreateBufferChain(pCompletionInfo->pReceiveBuffers,
                      (PVOID*)&pParms->Async.Parms.Read.u.Event.pReceivedFrame,
                      &pParms->Async.Parms.Read.u.Event.ReceivedFrameCount
                      );

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pCompletionInfo);

}


VOID
CreateBufferChain(
    IN PDLC_BUFFER_HEADER pBufferHeaders,
    OUT PVOID *pFirstBuffer,
    OUT PUSHORT pReceivedFrameCount
    )

/*++

Routine Description:

    The procudedure links the received frames in user's address space
    to the same order as they were received.

    We will take all frames linked to the queue.
    We must count the received frames to get
    the exact number of them. We cound count the frames
    also in the fly, but this is probably fastest and
    simplest way to do it (usually there is only one frame).

    The received frames are always in a circular link list.
    and in a reverse order.  The newest
    frame is pointed by the list header and the oldes one
    is the next from it.

Arguments:

    pBufferHeaders      - circular DLC buffer list, the head point to the
                          newest frame.
    pFirstBuffer        - returned user's address space address of the
                          first received frame
    pReceivedFrameCount - returned number of the received frame

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBuffer;

    if (pBufferHeaders != NULL) {
        pBuffer = pBufferHeaders->FrameBuffer.pNextFrame;
        pBufferHeaders->FrameBuffer.pNextFrame = NULL;
        do {
            *pFirstBuffer = (PVOID)((PCHAR)pBuffer->FrameBuffer.pParent->Header.pLocalVa
                          + MIN_DLC_BUFFER_SEGMENT * pBuffer->FrameBuffer.Index);
            pFirstBuffer = (PVOID*)&((PFIRST_DLC_SEGMENT)
                    ((PUCHAR)pBuffer->FrameBuffer.pParent->Header.pGlobalVa
                    + MIN_DLC_BUFFER_SEGMENT * pBuffer->FrameBuffer.Index))->Cont.pNextFrame;
            (*pReceivedFrameCount)++;

#if LLC_DBG
            cFramesIndicated++;
#endif

            //
            // The new state makes it possible to free the
            // buffer immediately (should this be interlocked???)
            //

            {
                PDLC_BUFFER_HEADER pNextBuffer;

                pNextBuffer = pBuffer->FrameBuffer.pNextFrame;
                pBuffer->FrameBuffer.BufferState = BUF_USER;
                pBuffer = pNextBuffer;
            }
        } while (pBuffer != NULL);

#if LLC_DBG
        if (*pFirstBuffer != NULL) {
            DbgPrint("Improperly formed frame link list!!!\n");
            DbgBreakPoint();
        }
#endif

    }
}


NTSTATUS
DlcReceiveCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive cancels a pending receive command.  This is different
    from the general cancel command used for READ and DirTimerSet,
    because we must find the object having the active receive and
    disable it.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    ParameterLength     - the length of input parameters
    OutputBufferLength  -

Return Value:

    DLC_STATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_INVALID_CCB_PARAMETER1

--*/

{
    PDLC_OBJECT pRcvObject;
    PDLC_COMMAND pDlcCommand;
    PVOID pCcbLink = NULL;
    PNT_DLC_PARMS pCanceledParms;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ParameterLength);

    pDlcCommand = SearchAndRemoveAnyCommand(pFileContext,
                                            (ULONG)(LLC_RECEIVE_DATA | LLC_RECEIVE_COMMAND_FLAG),
                                            (USHORT)DLC_IGNORE_STATION_ID,
                                            (USHORT)DLC_STATION_MASK_SPECIFIC,
                                            pDlcParms->ReceiveCancel.pCcb
                                            );
    if (pDlcCommand != NULL) {
        pCanceledParms = (PNT_DLC_PARMS)pDlcCommand->pIrp->AssociatedIrp.SystemBuffer;
        GetStation(pFileContext,
                   pCanceledParms->Async.Parms.Receive.usStationId,
                   &pRcvObject
                   );

        //
        // I can't see any reason why the station id should be missing
        // => we don't check the error code.
        //

        pRcvObject->pRcvParms = NULL;

        //
        // We return the canceled CCB pointer
        //

        CancelDlcCommand(pFileContext,
                         pDlcCommand,
                         &pCcbLink,
                         DLC_STATUS_CANCELLED_BY_USER,
                         TRUE   // SuppressCommandCompletion !!!
                         );
    }

    //
    // IBM LAN Tech Ref didn't define any possible error code for the
    // case, if the receive command could not be found => we
    // must return a successful status.
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlctyp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlctyp.h

Abstract:

    This module defines all data structures of the DLC module.

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

//
// forward declarations
//

struct _DLC_OBJECT;
typedef struct _DLC_OBJECT DLC_OBJECT, *PDLC_OBJECT;

struct _DLC_EVENT;
typedef struct _DLC_EVENT DLC_EVENT, *PDLC_EVENT;

struct _DLC_COMMAND;
typedef struct _DLC_COMMAND DLC_COMMAND, *PDLC_COMMAND;

struct _DLC_CLOSE_WAIT_INFO;
typedef struct _DLC_CLOSE_WAIT_INFO DLC_CLOSE_WAIT_INFO, *PDLC_CLOSE_WAIT_INFO;

union _DLC_PACKET;
typedef union _DLC_PACKET DLC_PACKET, *PDLC_PACKET;

union _DLC_BUFFER_HEADER;
typedef union _DLC_BUFFER_HEADER DLC_BUFFER_HEADER;
typedef DLC_BUFFER_HEADER *PDLC_BUFFER_HEADER;

struct _DLC_FILE_CONTEXT;
typedef struct _DLC_FILE_CONTEXT DLC_FILE_CONTEXT;
typedef DLC_FILE_CONTEXT *PDLC_FILE_CONTEXT;

enum _DLC_FILE_CONTEXT_STATUS {
    DLC_FILE_CONTEXT_OPEN,
    DLC_FILE_CONTEXT_CLOSE_PENDING,
    DLC_FILE_CONTEXT_CLOSED
};

enum DlcObjectTypes {
    DLC_ADAPTER_OBJECT,
    DLC_SAP_OBJECT,
    DLC_LINK_OBJECT,
    DLC_DIRECT_OBJECT
};

//
// DLC structures/objects
//

struct _DLC_OBJECT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // single-linked list of link stations if this is a SAP object
    //

    PDLC_OBJECT pLinkStationList;

    //
    // pointer to owning FILE_CONTEXT
    //

    PDLC_FILE_CONTEXT pFileContext;

    //
    // pointer to RECEIVE command parameters active for this SAP/link station
    //

    PNT_DLC_PARMS pRcvParms;

    //
    // 'handle' (aka pointer to) of corresponding object in LLC
    //

    PVOID hLlcObject;
    PDLC_EVENT pReceiveEvent;
    PVOID pPrevXmitCcbAddress;
    PVOID pFirstChainedCcbAddress;
    PDLC_CLOSE_WAIT_INFO pClosingInfo;
    ULONG CommittedBufferSpace;

    USHORT ChainedTransmitCount;
    SHORT PendingLlcRequests;

    USHORT StationId;                       // nn00 or nnss
    UCHAR Type;
    UCHAR LinkAllCcbs;

    UCHAR State;
    BOOLEAN LlcObjectExists;
    USHORT LlcReferenceCount;               // protects LLC objects when used

    // Need to have a close packet just in case we are out of resources and
    // can't allocate a packet to close. 
    LLC_PACKET ClosePacket;
    UCHAR      ClosePacketInUse;

    //
    // u - variant fields depending on object type: SAP, LINK or DIRECT station
    //

    union {

        struct {
            ULONG DlcStatusFlag;
            PVOID GlobalGroupSapHandle;
            PVOID* GroupSapHandleList;
            USHORT GroupSapCount;
            USHORT UserStatusValue;
            UCHAR LinkStationCount;
            UCHAR OptionsPriority;
            UCHAR MaxStationCount;
        } Sap;

        struct {
            struct _DLC_OBJECT* pSap;
            PDLC_EVENT pStatusEvent;        // permanent status event
            USHORT MaxInfoFieldLength;
        } Link;

        struct {
            USHORT OpenOptions;
            USHORT ProtocolTypeOffset;
            ULONG ProtocolTypeMask;
            ULONG ProtocolTypeMatch;
        } Direct;

    } u;
};

typedef
VOID
(*PFCLOSE_COMPLETE)(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    );

typedef
BOOLEAN
(*PFCOMPLETION_HANDLER)(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

//
// DLC_COMMAND and DLC_EVENT structures may be
// overloaded by the code.  Do not change the field
// order and add the new fields only to the end.
//

struct _DLC_COMMAND {

    //
    // !!!!! Keep this fixed - same fields with DLC_EVENT !!!!!
    //

    LLC_PACKET LlcPacket;
    ULONG Event;
    USHORT StationId;
    USHORT StationIdMask;

    //
    // !!!!! Keep this fixed - same fields with DLC_EVENT !!!!!
    //

    PVOID AbortHandle;
    PIRP pIrp;

    union {
        PFCOMPLETION_HANDLER pfCompletionHandler;
        ULONG TimerTicks;
    } Overlay;
};

struct _DLC_EVENT {
    LLC_PACKET LlcPacket;
    ULONG Event;
    USHORT StationId;           // -1 => global event

    union {
        USHORT StationIdMask;
        UCHAR RcvReadOption;
    } Overlay;

    PDLC_OBJECT pOwnerObject;   // if null => no owner
    PVOID pEventInformation;
    ULONG SecondaryInfo;

    BOOLEAN bFreeEventInfo;
};

typedef struct {
    LLC_PACKET LlcPacket;
    PVOID pCcbAddress;
    PDLC_BUFFER_HEADER pReceiveBuffers;
    ULONG CommandCompletionFlag;
    USHORT CcbCount;
    USHORT StationId;
} DLC_COMPLETION_EVENT_INFO, *PDLC_COMPLETION_EVENT_INFO;

//
// CLOSE_WAIT_INFO
//
// The pointer of this structure is provided to CompleteReadRequest in
// the command completion of close/reset commands.  The info pointer
// is null for the other command completions.
//

struct _DLC_CLOSE_WAIT_INFO {
    PDLC_CLOSE_WAIT_INFO pNext;
    PIRP pIrp;
    ULONG Event;
    PFCLOSE_COMPLETE pfCloseComplete;
    PDLC_BUFFER_HEADER pRcvFrames;
    PVOID pCcbLink;
    PDLC_COMMAND pReadCommand;
    PDLC_COMMAND pRcvCommand;
    PDLC_COMPLETION_EVENT_INFO pCompletionInfo;
    ULONG CancelStatus;
    USHORT CcbCount;
    USHORT CloseCounter;        // event sent when 0
    BOOLEAN ChainCommands;
    BOOLEAN CancelReceive;
    BOOLEAN ClosingAdapter;
    BOOLEAN FreeCompletionInfo;
};


//
// This is a queued FlowControl command (the flow control commands
// are completed immediately synchronously, but the local 'out of buffers'
// busy state of the link is cleared when there is enough buffers
// in the buffer pool to receive all expected data.
//

typedef struct {
    LIST_ENTRY List;
    LONG RequiredBufferSpace;
    USHORT StationId;
} DLC_RESET_LOCAL_BUSY_CMD, *PDLC_RESET_LOCAL_BUSY_CMD;

//
// The transmit commands are not queued as a standard commands
// but using the linked buffer headers (each frame has own xmit
// header having links to buffer header list and MDL list).
// The xmit nodes of the same send are queued together.
//

typedef struct {
    LLC_PACKET LlcPacket;
    PDLC_BUFFER_HEADER pNextSegment;
    PDLC_PACKET pTransmitNode;
    PIRP pIrp;
    ULONG FrameCount;
    PMDL pMdl;
} DLC_XMIT_NODE, *PDLC_XMIT_NODE;

//
// DLC driver use the same packet pool for many small packets
// that have approximately the same size.
//

union _DLC_PACKET {
    union _DLC_PACKET* pNext;
    LLC_PACKET LlcPacket;
    DLC_XMIT_NODE Node;
    DLC_EVENT Event;
    DLC_COMMAND DlcCommand;
    DLC_CLOSE_WAIT_INFO ClosingInfo;
    DLC_RESET_LOCAL_BUSY_CMD ClearCmd;

    struct {
        LLC_PACKET LlcPacket;
        PDLC_CLOSE_WAIT_INFO pClosingInfo;
    } ResetPacket;
};

//
// The buffer pool states protects the app to corrupt the buffer pool!!
// All states are needed because of internal consistency checking code
// and implementation of the receive.
//

enum _DLC_BUFFER_STATES {

    //
    // major states:
    //

    BUF_READY = 0x01,           // buffer/page locked and ready for I/O
    BUF_USER = 0x02,            // buffer owned by user
    BUF_LOCKED = 0x04,          // buffer have been locked for I/O
    BUF_RCV_PENDING = 0x08,     // buffer not yet chained to other frames!

    //
    // free xmit buffer when used
    //

    DEALLOCATE_AFTER_USE = 0x80

};

union _DLC_BUFFER_HEADER {

    //
    // This struct is the header of the buffers split from a page.
    // We save the local and global virtual addresses here.
    // The individual offset is always GlobalVa + Index * 256.
    // An entry in main page table points to this header,
    // if the page has been locked in the memory.
    //

    struct {
        PDLC_BUFFER_HEADER pNextHeader;
        PDLC_BUFFER_HEADER pPrevHeader;
        PDLC_BUFFER_HEADER pNextChild;
        PUCHAR pLocalVa;
        PUCHAR pGlobalVa;
        UCHAR FreeSegments;           // free segments ready for alloc
        UCHAR SegmentsOut;            // number of segments given to user
        UCHAR BufferState;            // BUF_READY, BUF_USER, BUF_LOCKED ...
        UCHAR Reserved;               //
        PMDL pMdl;
    } Header;

    //
    // Structure is used in the double linked free lists.
    // All segments having the same buffer size have been linked
    // to the same link list.
    // On another level each segment is linked to the parent (Header)
    // and all childs of a parent are also linked together.
    //

    struct {
        PDLC_BUFFER_HEADER pNext;
        PDLC_BUFFER_HEADER pPrev;
        PDLC_BUFFER_HEADER pParent;
        PDLC_BUFFER_HEADER pNextChild;
        ULONG ReferenceCount;         // number of references to this buffer
        UCHAR Size;                   // size in 256 blocks
        UCHAR Index;                  // offset = Index * 256
        UCHAR BufferState;            // BUF_READY, BUF_USER, BUF_LOCKED ...
        UCHAR FreeListIndex;          //
        PMDL pMdl;
    } FreeBuffer;

    //
    // The allocated frames are linked in different ways:
    // - the segments of the same frame are together
    // - the frames are linked together
    // These links are discarded, when the frame is given to
    // client (the client may free them in any order back to the buffer pool)
    // (The last extra pointer doesn't actually take any extra space,
    // because packets are round up to next 8 byte boundary)
    //

    struct {
        PDLC_BUFFER_HEADER pReserved;
        PDLC_BUFFER_HEADER pNextFrame;
        PDLC_BUFFER_HEADER pParent;
        PDLC_BUFFER_HEADER pNextChild;
        ULONG ReferenceCount;         // number of references to this buffer
        UCHAR Size;                   // size in 256 blocks
        UCHAR Index;                  // offset = Index * 256
        UCHAR BufferState;            // BUF_READY, BUF_USER, BUF_LOCKED ...
        UCHAR FreeListIndex;
        PMDL pMdl;
        PDLC_BUFFER_HEADER pNextSegment;
    } FrameBuffer;

    PDLC_BUFFER_HEADER pNext;

};

typedef struct _DLC_BUFFER_POOL {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // control fields
    //

    struct _DLC_BUFFER_POOL* pNext;
    KSPIN_LOCK SpinLock;
    LONG ReferenceCount;                        // when -1 => deallocate

    //
    // buffer pool description fields (addresses, various lengths)
    //

    PVOID BaseOffset;                           // page-aligned base address of the pool
    PVOID MaxOffset;                            // maximum byte address in the pool + 1
    ULONG MaxBufferSize;                        // the maximum (free) size
    ULONG BufferPoolSize;                       // size of all memory in the pool
    ULONG FreeSpace;                            // size of free memory in the pool
    LONG UncommittedSpace;                      // size of free and reserved memory
    LONG MissingSize;                           // the size missing the last request
    ULONG MaximumIndex;                         // maximum index of buffer table
    PVOID hHeaderPool;                          // packet pool for buffer headers
    LIST_ENTRY PageHeaders;                     // the allocated blocks

    //
    // pUnlockedEntryList is a singly-linked list of DLC_BUFFER_HEADERS which
    // describe the free pages in the pool
    //

    PDLC_BUFFER_HEADER pUnlockedEntryList;

    //
    // FreeLists is an array of doubly-linked lists - one for each size of
    // block that can exists in the pool. The blocks start out at a page
    // length (4K on x86) and are successively halved until they reach
    // 256 bytes which is the smallest buffer that the DLC buffer manager
    // can deal with
    //

    LIST_ENTRY FreeLists[DLC_BUFFER_SEGMENTS];

    //
    // appended to the DLC_BUFFER_POOL structure is an array of pointers to
    // DLC_BUFFER_HEADER structures that describe the pages that comprise
    // the pool. There are MaximumIndex of these
    //

    PDLC_BUFFER_HEADER BufferHeaders[];

} DLC_BUFFER_POOL, *PDLC_BUFFER_POOL;

//
// The buffer header and frame headers have been define in the
// IBM LAN Architecture reference in the end of chapter 2.
// They have also been defined in dlcapi.h, but for cosmetic reason
// I want to use version without those funny prefixes.
//

typedef struct _NEXT_DLC_SEGMENT {
    struct _NEXT_DLC_SEGMENT* pNext;
    USHORT FrameLength;
    USHORT DataLength;
    USHORT UserOffset;
    USHORT UserLength;
} NEXT_DLC_SEGMENT, *PNEXT_DLC_SEGMENT;

union _FIRST_DLC_SEGMENT;
typedef union _FIRST_DLC_SEGMENT FIRST_DLC_SEGMENT, *PFIRST_DLC_SEGMENT;

typedef struct {
    PNEXT_DLC_SEGMENT pNext;
    USHORT FrameLength;
    USHORT DataLength;
    USHORT UserOffset;
    USHORT UserLength;
    USHORT StationId;
    UCHAR Options;
    UCHAR MessageType;
    USHORT BuffersLeft;
    UCHAR RcvFs;
    UCHAR AdapterNumber;
    PFIRST_DLC_SEGMENT pNextFrame;
} DLC_CONTIGUOUS_RECEIVE, *PDLC_CONTIGUOUS_RECEIVE;

typedef struct {
    PNEXT_DLC_SEGMENT pNext;
    USHORT FrameLength;
    USHORT DataLength;
    USHORT UserOffset;
    USHORT UserLength;
    USHORT StationId;
    UCHAR Options;
    UCHAR MessageType;
    USHORT BuffersLeft;
    UCHAR RcvFs;
    UCHAR AdapterNumber;
    PFIRST_DLC_SEGMENT pNextFrame;
    UCHAR LanHeaderLength;
    UCHAR DlcHeaderLength;
    UCHAR LanHeader[32];
    UCHAR DlcHeader[4];
} DLC_NOT_CONTIGUOUS_RECEIVE, *PDLC_NOT_CONTIGUOUS_RECEIVE;

union _FIRST_DLC_SEGMENT {
    DLC_CONTIGUOUS_RECEIVE Cont;
    DLC_NOT_CONTIGUOUS_RECEIVE NotCont;
};


//
// Each application using DLC create its own file
// context with the DlcOpenAdapter command.
//

struct _DLC_FILE_CONTEXT {

    //
    // all file contexts are put on single-entry list
    //

    SINGLE_LIST_ENTRY List;             // linked list of file contexts

#if DBG

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

#endif

#if !defined(DLC_UNILOCK)

    NDIS_SPIN_LOCK SpinLock;            // global lock for this file context

#endif

    //
    // hBufferPool - handle of buffer pool created by BufferPoolCreate
    //

    PVOID hBufferPool;
    PVOID hExternalBufferPool;
    PVOID hPacketPool;
    PVOID hLinkStationPool;
    PVOID pBindingContext;

    //
    // Notification flags for error situations
    //

    ULONG AdapterCheckFlag;
    ULONG NetworkStatusFlag;
    ULONG PcErrorFlag;
    ULONG SystemActionFlag;

    LIST_ENTRY EventQueue;
    LIST_ENTRY CommandQueue;
    LIST_ENTRY ReceiveQueue;
    LIST_ENTRY FlowControlQueue;

    PDLC_COMMAND pTimerQueue;
    PVOID pSecurityDescriptor;
    PFILE_OBJECT FileObject;            // back link to file obejct!

    ULONG WaitingTransmitCount;
    NDIS_MEDIUM ActualNdisMedium;

    LONG ReferenceCount;
    ULONG BufferPoolReferenceCount;
    ULONG TimerTickCounter;
    USHORT DlcObjectCount;              // count of all DLC objects
    USHORT State;
    USHORT MaxFrameLength;
    UCHAR AdapterNumber;
    UCHAR LinkStationCount;
    PDLC_OBJECT SapStationTable[MAX_SAP_STATIONS];
    PDLC_OBJECT LinkStationTable[MAX_LINK_STATIONS];
    ULONG NdisErrorCounters[ADAPTER_ERROR_COUNTERS];
    DLC_CLOSE_WAIT_INFO ClosingPacket;  // to close the adapter context

    // Event used to make cleanup synchronous and wait for all references on
    // DLC_FILE_CONTEXT to be removed before completing.
    KEVENT CleanupEvent;

#if DBG

    //
    // Debug allocation counters
    //

    MEMORY_USAGE MemoryUsage;

#endif

};

typedef
NTSTATUS
(*PFDLC_COMMAND_HANDLER)(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcapi.h

Abstract:

    This module defined the kernel API of data link driver.
    All function prototypes and typedefs of the interface
    have been defined here.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

#ifndef _LLC_API_
#define _LLC_API_

#include "llcmem.h"

//
//  The debug switches
//

//
//  LLC_DBG:
//
//  0   => No debug code is generated
//  1   => Enables the memory allocation accounting, state machine tracing,
//         procedure call tracing and internal consistency checks
//  2   => Enables memory block overflow checking
//
//

#define LLC_DBG  0
#define DBG_MP   0   // enables the MP safe versions of the accounting macros

#define DLC_TRACE_ENABLED 1	// Procedure call tracing, debug only.

extern NDIS_SPIN_LOCK DlcDriverLock;

//
// ANY_IRQL: pseudo value used in ASSUME_IRQL to mean routine is not IRQL sensitive.
// Use this value with ASSUME_IRQL instead of omitting ASSUME_IRQL from a routine
// (shows that we didn't forget this routine)
//

#define ANY_IRQL    ((ULONG)-1)

#if defined(LOCK_CHECK)

extern LONG DlcDriverLockLevel;
extern ULONG __line;
extern PCHAR __file;
extern LONG __last;
extern HANDLE __process;
extern HANDLE __thread;

//
// _strip - quick functionette to strip out the path garbage from __FILE__
//

__inline char* _strip(char* s) {

    char* e = s + strlen(s) - 1;

    while (e != s) {
        if (*e == '\\') {
            return e + 1;
        }
        --e;
    }
    return s;
}

#define $$_PLACE            "%s!%d"
#define $$_FILE_AND_LINE    _strip(__FILE__), __LINE__

//
// ACQUIRE_DRIVER_LOCK - acquires the global DLC driver Spin Lock, using
// NdisAcquireSpinLock(). We also check for re-entrancy and incorrect ordering
// of spin lock calls
//

#define ACQUIRE_DRIVER_LOCK() \
{ \
    KIRQL currentIrql; \
    HANDLE hprocess; \
    HANDLE hthread; \
\
    currentIrql = KeGetCurrentIrql(); \
    if (currentIrql == PASSIVE_LEVEL) { \
\
        PETHREAD pthread; \
\
        pthread = PsGetCurrentThread(); \
        hprocess = pthread->Cid.UniqueProcess; \
        hthread = pthread->Cid.UniqueThread; \
    } else { \
        hprocess = (HANDLE)-1; \
        hthread = (HANDLE)-1; \
    } \
    NdisAcquireSpinLock(&DlcDriverLock); \
    if (++DlcDriverLockLevel != 1) { \
        __last = DlcDriverLockLevel; \
        DbgPrint("%d.%d:" $$_PLACE ": ACQUIRE_DRIVER_LOCK: level = %d. Last = %d.%d:" $$_PLACE "\n", \
                 hprocess, \
                 hthread, \
                 $$_FILE_AND_LINE, \
                 DlcDriverLockLevel, \
                 __process, \
                 __thread, \
                 __file, \
                 __line \
                 ); \
        DbgBreakPoint(); \
    } \
    __file = _strip(__FILE__); \
    __line = __LINE__; \
    __process = hprocess; \
    __thread = hthread; \
    ASSUME_IRQL(DISPATCH_LEVEL); \
}

//
// RELEASE_DRIVER_LOCK - releases the global DLC driver Spin Lock, using
// NdisReleaseSpinLock(). We also check for re-entrancy and incorrect ordering
// of spin lock calls
//

#define RELEASE_DRIVER_LOCK() \
    if (DlcDriverLockLevel != 1) { \
        DbgPrint($$_PLACE ": RELEASE_DRIVER_LOCK: level = %d. Last = %d.%d:" $$_PLACE "\n", \
                 $$_FILE_AND_LINE, \
                 DlcDriverLockLevel, \
                 __process, \
                 __thread, \
                 __file, \
                 __line \
                 ); \
        DbgBreakPoint(); \
    } \
    --DlcDriverLockLevel; \
    __file = _strip(__FILE__); \
    __line = __LINE__; \
    NdisReleaseSpinLock(&DlcDriverLock);

//
// ASSUME_IRQL - used to check that a routine is being called at the IRQL we
// expect. Due to the design of DLC, most functions are called at raised IRQL
// (DISPATCH_LEVEL). Used mainly to assure that IRQL is at PASSIVE_LEVEL when
// we do something which may incur a page fault e.g.
//

#define ASSUME_IRQL(level) \
    if (((level) != ANY_IRQL) && (KeGetCurrentIrql() != (level))) { \
        DbgPrint($$_PLACE ": ASSUME_IRQL(%d): Actual is %d\n", \
                 $$_FILE_AND_LINE, \
                 level, \
                 KeGetCurrentIrql() \
                 ); \
        DbgBreakPoint(); \
    }

//
// MY_ASSERT - since ASSERT only expands to something meaningful in the checked
// build, we use this when we want an assertion check in a free build
//

#define MY_ASSERT(x) \
    if (!(x)) { \
        DbgPrint($$_PLACE ": Assertion Failed: " # x "\n", \
                 $$_FILE_AND_LINE \
                 ); \
        DbgBreakPoint(); \
    }

//
// IF_LOCK_CHECK - conditional compilation made cleaner
//

#define IF_LOCK_CHECK \
    if (TRUE)

#else

#define ACQUIRE_DRIVER_LOCK()   NdisAcquireSpinLock(&DlcDriverLock)
#define RELEASE_DRIVER_LOCK()   NdisReleaseSpinLock(&DlcDriverLock)
#define ASSUME_IRQL(level)      /* NOTHING */
#define MY_ASSERT(x)            /* NOTHING */
#define IF_LOCK_CHECK           if (FALSE)

#endif

//
// in the Unilock DLC, we do not need the LLC spin-lock
//

#if defined(DLC_UNILOCK)

#define ACQUIRE_LLC_LOCK(i)
#define RELEASE_LLC_LOCK(i)

#define ACQUIRE_SPIN_LOCK(p)
#define RELEASE_SPIN_LOCK(p)

#define ALLOCATE_SPIN_LOCK(p)
#define DEALLOCATE_SPIN_LOCK(p)

#else

#define ACQUIRE_LLC_LOCK(i)     KeAcquireSpinLock(&LlcSpinLock, (i))
#define RELEASE_LLC_LOCK(i)     KeReleaseSpinLock(&LlcSpinLock, (i))

#define ACQUIRE_SPIN_LOCK(p)    NdisAcquireSpinLock((p))
#define RELEASE_SPIN_LOCK(p)    NdisReleaseSpinLock((p))

#define ALLOCATE_SPIN_LOCK(p)   KeInitializeSpinLock(&(p)->SpinLock)
#define DEALLOCATE_SPIN_LOCK(p)

#endif

//
// IS_SNA_DIX_FRAME - TRUE if the frame just received & therefore described in
// the ADAPTER_CONTEXT (p) has DIX framing (SNA)
//

#define IS_SNA_DIX_FRAME(p) \
    (((PADAPTER_CONTEXT)(p))->IsSnaDixFrame)

//
// IS_AUTO_BINDING - TRUE if the BINDING_CONTEXT was created with
// LLC_ETHERNET_TYPE_AUTO
//

#define IS_AUTO_BINDING(p) \
    (((PBINDING_CONTEXT)(p))->EthernetType == LLC_ETHERNET_TYPE_AUTO)

#define FRAME_MASK_LLC_LOCAL_DEST       0x0001
#define FRAME_MASK_NON_LLC_LOCAL_DEST   0x0002
#define FRAME_MASK_NON_LOCAL_DEST       0x0004
#define FRAME_MASK_ALL_FRAMES           0x0007

#define LLC_EXCLUSIVE_ACCESS            0x0001
#define LLC_HANDLE_XID_COMMANDS         0x0002

//
// Direct station receive flags (bits 0 and 1 are inverted from dlcapi!!!)
//

#define DLC_RCV_SPECIFIC_DIX            0
#define DLC_RCV_MAC_FRAMES              1
#define DLC_RCV_8022_FRAMES             2
#define DLC_RCV_DIX_FRAMES              4
#define LLC_VALID_RCV_MASK              7
#define DLC_RCV_OTHER_DESTINATION       8

#define MAX_LLC_FRAME_TYPES 10

//
// The DLC link states reported by DLC API
//

enum _DATA_LINK_STATES {

    //
    // Primary states
    //

    LLC_LINK_CLOSED             = 0x80,
    LLC_DISCONNECTED            = 0x40,
    LLC_DISCONNECTING           = 0x20,
    LLC_LINK_OPENING            = 0x10,
    LLC_RESETTING               = 0x08,
    LLC_FRMR_SENT               = 0x04,
    LLC_FRMR_RECEIVED           = 0x02,
    LLC_LINK_OPENED             = 0x01,

    //
    // Secondary states (when primary state is LLC_LINK_OPENED)
    //

    LLC_CHECKPOINTING           = 0x80,
    LLC_LOCAL_BUSY_USER_SET     = 0x40,
    LLC_LOCAL_BUSY_BUFFER_SET   = 0x20,
    LLC_REMOTE_BUSY             = 0x10,
    LLC_REJECTING               = 0x08,
    LLC_CLEARING                = 0x04,
    LLC_DYNMIC_WIN_ALG_RUNNIG   = 0x02,
    LLC_NO_SECONDARY_STATE      = 0
};

//
// LAN802_ADDRESS - 8 bytes of frame address. Typically 6 bytes LAN address
// plus 1 byte destination SAP, plus 1 byte source SAP
//

typedef union {

    struct {
        UCHAR DestSap;
        UCHAR SrcSap;
        USHORT usHigh;
        ULONG ulLow;
    } Address;

    struct {
        ULONG High;
        ULONG Low;
    } ul;

    struct {
        USHORT Raw[4];
    } aus;

    struct {
        UCHAR DestSap;
        UCHAR SrcSap;
        UCHAR auchAddress[6];
    }  Node;

    UCHAR auchRawAddress[8];

} LAN802_ADDRESS, *PLAN802_ADDRESS;

//
// Structure is used by DlcNdisRequest function
//

typedef struct {
    NDIS_STATUS AsyncStatus;
    KEVENT SyncEvent;
    NDIS_REQUEST Ndis;
} LLC_NDIS_REQUEST, *PLLC_NDIS_REQUEST;

#define NDIS_INFO_BUF_SIZE          20

#define DLC_ANY_STATION             (-1)

//
// Internal event flags used by Timer, DlcConnect
// and DlcClose commands.
//

#define DLC_REPEATED_FLAGS          0x0700
#define LLC_TIMER_TICK_EVENT        0x0100
#define LLC_STATUS_CHANGE_ON_SAP    0x0800

//
// These enum types are used also as the index of a mapping table!
//

enum _LLC_OBJECT_TYPES {
    LLC_DIRECT_OBJECT,
    LLC_SAP_OBJECT,
    LLC_GROUP_SAP_OBJECT,
    LLC_LINK_OBJECT,
    LLC_DIX_OBJECT
};

//
// We moved these defines here because the macro is used by data link
//

#define MIN_DLC_BUFFER_SEGMENT      256
////#define MAX_DLC_BUFFER_SEGMENT      4096
//#define MAX_DLC_BUFFER_SEGMENT      8192
#define MAX_DLC_BUFFER_SEGMENT      PAGE_SIZE

#define BufGetPacketSize( PacketSize ) \
                (((PacketSize) + 2 * MIN_DLC_BUFFER_SEGMENT - 1) & \
                -MIN_DLC_BUFFER_SEGMENT)

//
// READ Event flags:
//

#define DLC_READ_FLAGS              0x007f
#define LLC_SYSTEM_ACTION           0x0040
#define LLC_NETWORK_STATUS          0x0020
#define LLC_CRITICAL_EXCEPTION      0x0010
#define LLC_STATUS_CHANGE           0x0008
#define LLC_RECEIVE_DATA            0x0004
#define LLC_TRANSMIT_COMPLETION     0x0002
#define DLC_COMMAND_COMPLETION      0x0001

#define ALL_DLC_EVENTS              -1

//
// LLC_STATUS_CHANGE indications:
//

#define INDICATE_LINK_LOST              0x8000
#define INDICATE_DM_DISC_RECEIVED       0x4000
#define INDICATE_FRMR_RECEIVED          0x2000
#define INDICATE_FRMR_SENT              0x1000
#define INDICATE_RESET                  0x0800
#define INDICATE_CONNECT_REQUEST        0x0400
#define INDICATE_REMOTE_BUSY            0x0200
#define INDICATE_REMOTE_READY           0x0100
#define INDICATE_TI_TIMER_EXPIRED       0x0080
#define INDICATE_DLC_COUNTER_OVERFLOW   0x0040
#define INDICATE_ACCESS_PRTY_LOWERED    0x0020
#define INDICATE_LOCAL_STATION_BUSY     0x0001

//
// LLC Command completion indications.
//

enum _LLC_COMPLETION_CODES {
    LLC_RECEIVE_COMPLETION,
    LLC_SEND_COMPLETION,
    LLC_REQUEST_COMPLETION,
    LLC_CLOSE_COMPLETION,
    LLC_RESET_COMPLETION,
    LLC_CONNECT_COMPLETION,
    LLC_DISCONNECT_COMPLETION
};

typedef union {
    LLC_ADAPTER_INFO Adapter;
    DLC_LINK_PARAMETERS LinkParms;
    LLC_TICKS Timer;
    DLC_LINK_LOG LinkLog;
    DLC_SAP_LOG SapLog;
    UCHAR PermanentAddress[6];
    UCHAR auchBuffer[1];
} LLC_QUERY_INFO_BUFFER, *PLLC_QUERY_INFO_BUFFER;

typedef union {
    DLC_LINK_PARAMETERS LinkParms;
    LLC_TICKS Timers;
    UCHAR auchFunctionalAddress[4];
    UCHAR auchGroupAddress[4];
    UCHAR auchBuffer[1];
} LLC_SET_INFO_BUFFER, *PLLC_SET_INFO_BUFFER;

//
// LLC_FRMR_INFORMATION - 5 bytes of FRaMe Reject code
//

typedef struct {
    UCHAR Command;              // format: mmmpmm11, m=modifiers, p=poll/final.
    UCHAR Ctrl;                 // control field of rejected frame.
    UCHAR Vs;                   // our next send when error was detected.
    UCHAR Vr;                   // our next receive when error was detected.
    UCHAR Reason;               // reason for sending FRMR: 000VZYXW.
} LLC_FRMR_INFORMATION, *PLLC_FRMR_INFORMATION;

//
// DLC_STATUS_TABLE - format of status information returned in a READ command
//

typedef struct {
    USHORT StatusCode;
    LLC_FRMR_INFORMATION FrmrData;
    UCHAR uchAccessPriority;
    UCHAR auchRemoteNode[6];
    UCHAR uchRemoteSap;
    UCHAR uchLocalSap;
    PVOID hLlcLinkStation;
} DLC_STATUS_TABLE, *PDLC_STATUS_TABLE;

typedef struct {
    ULONG IsCompleted;
    ULONG Status;
} ASYNC_STATUS, *PASYNC_STATUS;

union _LLC_OBJECT;
typedef union _LLC_OBJECT LLC_OBJECT, *PLLC_OBJECT;

struct _BINDING_CONTEXT;
typedef struct _BINDING_CONTEXT BINDING_CONTEXT, *PBINDING_CONTEXT;

//
// LLC packet headers
//

//
// LLC_XID_INFORMATION - 3 information bytes in a standard LLC XID packet
//

typedef struct {
    UCHAR FormatId;             // format of this XID frame.
    UCHAR Info1;                // first information byte.
    UCHAR Info2;                // second information byte.
} LLC_XID_INFORMATION, *PLLC_XID_INFORMATION;

//
// LLC_TEST_INFORMATION - information field for TEST frame
//

typedef struct {
    UCHAR Padding[4];
    PMDL pMdl;                  // we keep test MDL in the same slot as U-MDL
} LLC_TEST_INFORMATION, *PLLC_TEST_INFORMATION;

typedef union {
    LLC_XID_INFORMATION Xid;    // XID information.
    LLC_FRMR_INFORMATION Frmr;  // FRMR information.
    LLC_TEST_INFORMATION Test;  // Test MDL pointer
    UCHAR Padding[8];           //
} LLC_RESPONSE_INFO, *PLLC_RESPONSE_INFO;

//
// LLC_U_HEADER - Unnumbered format frame LLC header
//

typedef struct {
    UCHAR Dsap;                 // Destination Service Access Point.
    UCHAR Ssap;                 // Source Service Access Point.
    UCHAR Command;              // command code.
} LLC_U_HEADER, *PLLC_U_HEADER;

//
// LLC_S_HEADER - Supervisory format frame LLC header
//

typedef struct {
    UCHAR Dsap;                 // Destination Service Access Point.
    UCHAR Ssap;                 // Source Service Access Point.
    UCHAR Command;              // RR, RNR, REJ command code.
    UCHAR Nr;                   // receive seq #, bottom bit is poll/final.
} LLC_S_HEADER, *PLLC_S_HEADER;

//
// LLC_I_HEADER - Information frame LLC header
//

typedef struct {
    UCHAR Dsap;                 // Destination Service Access Point.
    UCHAR Ssap;                 // Source Service Access Point.
    UCHAR Ns;                   // send sequence number, bottom bit 0.
    UCHAR Nr;                   // rcv sequence number, bottom bit p/f.
} LLC_I_HEADER, *PLLC_I_HEADER;

typedef struct {
    LLC_U_HEADER U;             // normal U- frame
    UCHAR Type;                 // its lan header conversion type
} LLC_U_PACKET_HEADER, *PLLC_U_PACKET_HEADER;

typedef union {
    LLC_S_HEADER S;
    LLC_I_HEADER I;
    LLC_U_HEADER U;
    ULONG ulRawLLc;
    UCHAR auchRawBytes[4];
    USHORT EthernetType;
} LLC_HEADER, *PLLC_HEADER;

typedef struct _LLC_PACKET {

    struct _LLC_PACKET* pNext;
    struct _LLC_PACKET* pPrev;
    UCHAR CompletionType;
    UCHAR cbLlcHeader;
    USHORT InformationLength;
    PBINDING_CONTEXT pBinding;

    union {

        struct {
            PUCHAR pLanHeader;
            LLC_HEADER LlcHeader;
            PLLC_OBJECT pLlcObject;
            PMDL pMdl;
        } Xmit;

        struct {
            PUCHAR pLanHeader;
            UCHAR TranslationType;
            UCHAR Dsap;
            UCHAR Ssap;
            UCHAR Command;
            PLLC_OBJECT pLlcObject;
            PMDL pMdl;
        } XmitU;

        struct {
            PUCHAR pLanHeader;
            UCHAR TranslationType;
            UCHAR EthernetTypeHighByte;
            UCHAR EthernetTypeLowByte;
            UCHAR Padding;
            PLLC_OBJECT pLlcObject;
            PMDL pMdl;
        } XmitDix;

        struct {
            PUCHAR pLanHeader;
            UCHAR TranslationType;
            UCHAR Dsap;
            UCHAR Ssap;
            UCHAR Command;
            LLC_RESPONSE_INFO Info;
        } Response;

        //
        // Link station data packet may be acknowledged by the other
        // side, before it is completed by NDIS.  Ndis completion
        // routine expects to find pLlcObject link => we must not change
        // that field, when the xmit packet is translated to
        // a completion packet.  Otherwise is corrupt pFileContext pointer,
        // when NdisSendCount is incremented.
        //

        struct {
            ULONG Status;
            ULONG CompletedCommand;
            PLLC_OBJECT pLlcObject;
            PVOID hClientHandle;
        } Completion;

    } Data;

} LLC_PACKET, *PLLC_PACKET;

//
// DLC API return codes
//
// The base value of the error codes is not compatible with the other
// nt error codes, but it doesn't matter because these are internal
// for DLC driver (and its data link layer).
// 16 bit- error codes are used, because in MIPS they need less
// instructions (MIPS cannot load directly over 16 bits constants)
// and this code can also be emuulated on OS/2.
//

typedef enum _DLC_STATUS {
    DLC_STATUS_SUCCESS                          = 0,
    DLC_STATUS_ERROR_BASE                       = 0x6000,
    DLC_STATUS_INVALID_COMMAND                  = 0x01 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DUPLICATE_COMMAND                = 0x02 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ADAPTER_OPEN                     = 0x03 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ADAPTER_CLOSED                   = 0x04 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_PARAMETER_MISSING                = 0x05 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_OPTION                   = 0x06 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_COMMAND_CANCELLED_FAILURE        = 0x07 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CANCELLED_BY_USER                = 0x0A + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_SUCCESS_NOT_OPEN                 = 0x0C + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_TIMER_ERROR                      = 0x11 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NO_MEMORY                        = 0x12 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LOST_LOG_DATA                    = 0x15 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_BUFFER_SIZE_EXCEEDED             = 0x16 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_BUFFER_LENGTH            = 0x18 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INADEQUATE_BUFFERS               = 0x19 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_USER_LENGTH_TOO_LARGE            = 0x1A + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_CCB_POINTER              = 0x1B + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_POINTER                  = 0x1C + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_ADAPTER                  = 0x1D + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_FUNCTIONAL_ADDRESS       = 0x1E + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LOST_DATA_NO_BUFFERS             = 0x20 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_TRANSMIT_ERROR_FS                = 0x22 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_TRANSMIT_ERROR                   = 0x23 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_UNAUTHORIZED_MAC                 = 0x24 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LINK_NOT_TRANSMITTING            = 0x27 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_FRAME_LENGTH             = 0x28 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_NODE_ADDRESS             = 0x32 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_RECEIVE_BUFFER_LENGTH    = 0x33 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_TRANSMIT_BUFFER_LENGTH   = 0x34 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_STATION_ID               = 0x40 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LINK_PROTOCOL_ERROR              = 0x41 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_PARMETERS_EXCEEDED_MAX           = 0x42 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_SAP_VALUE                = 0x43 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_ROUTING_INFO             = 0x44 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LINK_STATIONS_OPEN               = 0x47 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INCOMPATIBLE_COMMAND_IN_PROGRESS = 0x4A + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CONNECT_FAILED                   = 0x4D + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_REMOTE_ADDRESS           = 0x4F + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CCB_POINTER_FIELD                = 0x50 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INADEQUATE_LINKS                 = 0x57 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_PARAMETER_1              = 0x58 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE    = 0x5C + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED      = 0x5d + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ADAPTER_NOT_INSTALLED            = 0x5e + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CHAINED_DIFFERENT_ADAPTERS       = 0x5f + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INIT_COMMAND_STARTED             = 0x60 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION       = 0x62 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_MEMORY_LOCK_FAILED               = 0x69 + DLC_STATUS_ERROR_BASE,

    //
    // New Nt DLC specific error codes begin from 0x80
    // These error codes are for new Windows/Nt DLC apps.
    // This far we have tried too much use the OS/2 error codes,
    // that results often uninformative return codes.
    //

    DLC_STATUS_INVALID_BUFFER_ADDRESS           = 0x80 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_BUFFER_ALREADY_RELEASED          = 0x81 + DLC_STATUS_ERROR_BASE,


    DLC_STATUS_INVALID_VERSION                  = 0xA1 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_BUFFER_HANDLE            = 0xA2 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NT_ERROR_STATUS                  = 0xA3 + DLC_STATUS_ERROR_BASE,

    //
    // These error codes are just internal for LLC- kernel level interface
    // and they are not returned to application level.
    //

    DLC_STATUS_UNKNOWN_MEDIUM                   = 0xC0 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DISCARD_INFO_FIELD               = 0xC1 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NO_ACTION                        = 0xC2 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ACCESS_DENIED                    = 0xC3 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_IGNORE_FRAME                     = 0xC4 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_WAIT_TIMEOUT                     = 0xC5 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NO_RECEIVE_COMMAND               = 0xC6 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_FILE_CONTEXT_DELETED             = 0xC7 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_EXPAND_BUFFER_POOL               = 0xC8 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INTERNAL_ERROR                   = 0xC9 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ASYNC_DATA_TRANSFER_FAILED       = 0xCA + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_OUT_OF_RCV_BUFFERS               = 0xCB + DLC_STATUS_ERROR_BASE,

    DLC_STATUS_PENDING                          = 0xFF + DLC_STATUS_ERROR_BASE,

    DLC_STATUS_MAX_ERROR                        = 0xFF + DLC_STATUS_ERROR_BASE
} DLC_STATUS;

//
// Data link indication handler prototypes.
// The protocols registering to data link driver
// must provide these entry points.
//

typedef
DLC_STATUS
(*PFLLC_RECEIVE_INDICATION)(
    IN PVOID hClientContext,
    IN PVOID hClientHandle,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf
    );

typedef
VOID
(*PFLLC_COMMAND_COMPLETE)(
    IN PVOID hClientContext,
    IN PVOID hClientHandle,
    IN PVOID hPacket
    );

typedef
VOID
(*PFLLC_EVENT_INDICATION)(
    IN PVOID hClientContext,
    IN PVOID hClientHandle,
    IN UINT uiEvent,
    IN PVOID pDlcStatus,
    IN ULONG SecondaryInformation
    );

UINT
LlcBuildAddressFromLanHeader(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR pRcvFrameHeader,
    IN OUT PUCHAR pLanHeader
    );

DLC_STATUS
LlcInitialize(
    VOID
    );

UINT
LlcBuildAddress(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR DestinationAddress,
    IN PVOID pSrcRouting,
    IN OUT PUCHAR pLanHeader
    );

USHORT
LlcGetMaxInfoField(
    IN NDIS_MEDIUM NdisMedium,
    IN PVOID hBinding,
    IN PUCHAR pLanHeader
    );

DLC_STATUS
LlcQueryInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_QUERY_INFO_BUFFER pQuery,
    IN UINT QueryBufferSize
    );

DLC_STATUS
LlcSetInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_SET_INFO_BUFFER pSetInfo,
    IN UINT ParameterBufferSize
    );

DLC_STATUS
LlcNdisRequest(
    IN PVOID hBindingContext,
    IN PLLC_NDIS_REQUEST pDlcParms
    );

DLC_STATUS
LlcOpenAdapter(
    IN PWSTR pAdapterName,
    IN PVOID hClientContext,
    IN PFLLC_COMMAND_COMPLETE pfCommandComplete,
    IN PFLLC_RECEIVE_INDICATION pfReceiveIndication,
    IN PFLLC_EVENT_INDICATION pfEventIndication,
    IN NDIS_MEDIUM NdisMedium,
    IN LLC_ETHERNET_TYPE EthernetType,
    IN UCHAR AdapterNumber,
    OUT PVOID *phBindingContext,
    OUT PUINT puiOpenStatus,
    OUT PUSHORT puiMaxFrameLength,
    OUT PNDIS_MEDIUM pActualNdisMedium
    );


#define LlcOpenSap(Context, Handle, Sap, Options, phSap) \
    LlcOpenStation(Context, Handle, (USHORT)(Sap), LLC_SAP_OBJECT, (USHORT)(Options), phSap)

#define LlcOpenDirectStation(Context, Handle, Sap, phSap) \
    LlcOpenStation(Context, Handle, (USHORT)(Sap), LLC_DIRECT_OBJECT, 0, phSap)

#define LlcOpenDixStation(Context, Handle, Sap, phSap) \
    LlcOpenStation(Context, Handle, (USHORT)(Sap), LLC_DIX_OBJECT, 0, phSap)


VOID
RemoveFromLinkList(
    OUT PVOID* ppBase,
    IN PVOID pElement
    );

VOID
LlcSleep(
    IN LONG lMicroSeconds
    );

VOID
LlcTerminate(
    VOID
    );

VOID
LlcDereferenceObject(
    IN PVOID pStation
    );

VOID
LlcReferenceObject(
    IN PVOID pStation
    );

DLC_STATUS
LlcTraceInitialize(
    IN PVOID UserTraceBuffer,
    IN ULONG UserTraceBufferSize,
    IN ULONG TraceFlags
    );

VOID
LlcTraceClose(
    VOID
    );

VOID
LlcTraceWrite(
    IN UINT Event,
    IN UCHAR AdapterNumber,
    IN UINT DataBufferSize,
    IN PVOID DataBuffer
    );

VOID
LlcTraceDump(
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    );

VOID
LlcTraceDumpAndReset(
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    );

#if DBG

typedef struct {
    USHORT Input;
    USHORT Time;
    PVOID pLink;
} LLC_SM_TRACE;

#define LLC_INPUT_TABLE_SIZE    500

extern ULONG AllocatedNonPagedPool;
extern ULONG LockedPageCount;
extern ULONG AllocatedMdlCount;
extern ULONG AllocatedPackets;
extern NDIS_SPIN_LOCK MemCheckLock;
extern ULONG cExAllocatePoolFailed;
extern ULONG FailedMemoryLockings;

VOID PrintMemStatus(VOID);

extern ULONG cFramesReceived;
extern ULONG cFramesIndicated;
extern ULONG cFramesReleased;

extern ULONG cLockedXmitBuffers;
extern ULONG cUnlockedXmitBuffers;

extern LLC_SM_TRACE aLast[];
extern UINT InputIndex;

#endif

//
// The inline memcpy and memset functions are faster,
// in x386 than RtlMoveMemory
//

#if defined(i386)

#define LlcMemCpy(Dest, Src, Len)   memcpy(Dest, Src, Len)
#define LlcZeroMem(Ptr, Len)        memset(Ptr, 0, Len)

#else

#define LlcMemCpy(Dest, Src, Len)   RtlMoveMemory(Dest, Src, Len)
#define LlcZeroMem(Ptr, Len)        RtlZeroMemory(Ptr, Len)

#endif

//
//
//  PVOID
//  PopEntryList(
//      IN PQUEUE_PACKET ListHead,
//      );
//

#define PopFromList(ListHead)               \
    (PVOID)(ListHead);                      \
    (ListHead) = (PVOID)(ListHead)->pNext;


//
//  VOID
//  PushToList(
//      IN PQUEUE_PACKET ListHead,
//      IN PQUEUE_PACKET Entry
//      );
//

#define PushToList(ListHead,Entry) {    \
    (Entry)->pNext = (PVOID)(ListHead); \
    (ListHead) = (Entry);               \
    }

//
//  About 30% of all bugs are related with the invalid operations with
//  packets.  A packet may be inserted to another list before it
//  has been removed from the previous one, etc.
//  The debug version of the list macroes reset the next pointer
//  every time it is removed from the list and check it when it is
//  inserted to a new list or released to a packet pool.  The packet
//  alloc will reset the next pointer automatically.
//  Problem: the packets are used for many other purposes as well =>
//  we must do quite a lot conditional code.
//

#if LLC_DBG

#if LLC_DBG_MP

#define DBG_INTERLOCKED_INCREMENT(Count)    \
    InterlockedIncrement(                   \
        (PLONG)&(Count)                     \
        )

#define DBG_INTERLOCKED_DECREMENT(Count)    \
    InterlockedDecrement(                   \
        (PLONG)&(Count)                     \
        )

#define DBG_INTERLOCKED_ADD(Added, Value)   \
    ExInterlockedAddUlong(                  \
        (PULONG)&(Added),                   \
        (ULONG)(Value),                     \
        &MemCheckLock.SpinLock              \
        )
#else

#define DBG_INTERLOCKED_INCREMENT(Count)    (Count)++
#define DBG_INTERLOCKED_DECREMENT(Count)    (Count)--
#define DBG_INTERLOCKED_ADD(Added, Value)   (Added) += (Value)

#endif // LLC_DBG_MP

#else

#define DBG_INTERLOCKED_INCREMENT(Count)
#define DBG_INTERLOCKED_DECREMENT(Count)
#define DBG_INTERLOCKED_ADD(Added, Value)

#endif // LLC_DBG


#if LLC_DBG

VOID LlcBreakListCorrupt( VOID );

#define LlcRemoveHeadList(ListHead)             \
    (PVOID)(ListHead)->Flink;                   \
    {                                           \
        PLIST_ENTRY FirstEntry;                 \
        FirstEntry = (ListHead)->Flink;         \
        FirstEntry->Flink->Blink = (ListHead);  \
        (ListHead)->Flink = FirstEntry->Flink;  \
        FirstEntry->Flink = NULL;               \
    }

#define LlcRemoveTailList(ListHead)             \
    (ListHead)->Blink;                          \
    {                                           \
        PLIST_ENTRY FirstEntry;                 \
        FirstEntry = (ListHead)->Blink;         \
        FirstEntry->Blink->Flink = (ListHead);  \
        (ListHead)->Blink = FirstEntry->Blink;  \
        FirstEntry->Flink = NULL;               \
    }

#define LlcRemoveEntryList(Entry)               \
    {                                           \
        RemoveEntryList((PLIST_ENTRY)Entry);    \
        ((PLIST_ENTRY)(Entry))->Flink = NULL;   \
    }

#define LlcInsertTailList(ListHead,Entry)       \
    if (((PLIST_ENTRY)(Entry))->Flink != NULL){ \
        LlcBreakListCorrupt();                  \
    }                                           \
    InsertTailList(ListHead, (PLIST_ENTRY)Entry)

#define LlcInsertHeadList(ListHead,Entry)                   \
            if (((PLIST_ENTRY)(Entry))->Flink != NULL) {    \
                LlcBreakListCorrupt();                      \
            }                                               \
            InsertHeadList(ListHead,(PLIST_ENTRY)Entry)

/*
#define DeallocatePacket( PoolHandle, pBlock ) {                        \
            if (((PLIST_ENTRY)pBlock)->Flink != NULL) {                 \
                LlcBreakListCorrupt();                                  \
            }                                                           \
            DBG_INTERLOCKED_DECREMENT( AllocatedPackets );              \
            ExFreeToZone(                                               \
                &(((PEXTENDED_ZONE_HEADER)PoolHandle)->Zone),           \
                pBlock);                                                \
        }
*/

#else


//
//  PVOID
//  LlcRemoveHeadList(
//      IN PLIST_ENTRY ListHead
//      );
//

#define LlcRemoveHeadList(ListHead) (PVOID)RemoveHeadList(ListHead)


//
//  PLIST_ENTRY
//  LlcRemoveTailList(
//      IN PLIST_ENTRY ListHead
//      );
//

#define LlcRemoveTailList(ListHead)             \
    (ListHead)->Blink; {                        \
        PLIST_ENTRY FirstEntry;                 \
        FirstEntry = (ListHead)->Blink;         \
        FirstEntry->Blink->Flink = (ListHead);  \
        (ListHead)->Blink = FirstEntry->Blink;  \
    }


//
//  VOID
//  LlcRemoveEntryList(
//      IN PVOID Entry
//      );
//

#define LlcRemoveEntryList(Entry) RemoveEntryList((PLIST_ENTRY)Entry)


//
//  VOID
//  LlcInsertTailList(
//      IN PLIST_ENTRY ListHead,
//      IN PVOID Entry
//      );
//

#define LlcInsertTailList(ListHead,Entry) \
            InsertTailList(ListHead, (PLIST_ENTRY)Entry)

//
//  VOID
//  LlcInsertHeadList(
//      IN PLIST_ENTRY ListHead,
//      IN PVOID Entry
//      );
//

#define LlcInsertHeadList(ListHead,Entry) \
            InsertHeadList(ListHead,(PLIST_ENTRY)Entry)

//
//  VOID
//  DeallocatePacket(
//      PEXTENDED_ZONE_HEADER PoolHandle,
//      PVOID pBlock
//      );
//

/*
#define DeallocatePacket( PoolHandle, pBlock ) {                        \
            ExFreeToZone( &(((PEXTENDED_ZONE_HEADER)PoolHandle)->Zone), \
                pBlock);                                                \
        }
*/

#endif // DBG

#if LLC_DBG == 2

VOID LlcMemCheck(VOID);

#define MEM_CHECK() LlcMemCheck()

#else

#define MEM_CHECK()

#endif


VOID LlcInvalidObjectType(VOID);

/*++

    Trace codes

    Big letters are reserved for actions, small letters are used to identify
    objects and packet types.  The trace macroes simply writes to DLC
    trace tree (remember: we have another trace for the state machine!!!)

    'a' = dix stations
    'b' = direct station
    'c' = link station
    'd' = sap station

    'e' = Connect command
    'f' = Close command
    'g' = Disconnect command
    'h' = Receive command
    'i' = transmit command

    'j' = Type1 packet
    'k' = type 2 packet
    'l' = data link packet

    'A' = CompleteSendAndLock
    'B' = LlcCommandCompletion
    'C' = LlcCloseStation
    'D' = LlcReceiveIndication
    'E' = LlcEventIndication
    'F' = DlcDeviceIoControl
    'G' = DlcDeviceIoControl sync exit
    'H' = DlcDeviceIoControl async exit
    'I' = LlcSendI
    'J' = DirCloseAdapter
    'K' = CompleteDirCloseAdapter
    'L' = LlcDereferenceObject
    'M' = LlcReferenceObject
    'N' = CompleteCloseStation (final)
    'O' = DereferenceLlcObject (in dlc)
    'P' = CompleteLlcObjectClose (final)
    'Q' = DlcReadCancel
    'R' =
    'S' =
    'T' = DlcTransmit
    'U' = LlcSendU
    'V' =
    'W' =
    'X' =
    'Y' =
    'Z' =

--*/

#if DBG & DLC_TRACE_ENABLED

#define LLC_TRACE_TABLE_SIZE    0x400   // this must be exponent of 2!

extern UINT LlcTraceIndex;
extern UCHAR LlcTraceTable[];

#define DLC_TRACE(a)  {\
    LlcTraceTable[LlcTraceIndex] = (a);\
    LlcTraceIndex = (LlcTraceIndex + 1) & (LLC_TRACE_TABLE_SIZE - 1);\
}

#else

#define DLC_TRACE(a)

#endif  // LLC_DBG

//
// the following functions can be macros if DLC and LLC live in the same driver
// and each knows about the other's structures
//

#if DLC_AND_LLC

//
//  UINT
//  LlcGetReceivedLanHeaderLength(
//      IN PVOID pBinding
//      );
//

#if 0

//
// this gives the wrong length for DIX lan header
//

#define LlcGetReceivedLanHeaderLength(pBinding) \
    ((((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMedium802_3) \
        ? (((PBINDING_CONTEXT)(pBinding))->pAdapterContext->FrameType == LLC_DIRECT_ETHERNET_TYPE) \
            ? 12 \
            : 14 \
        : (((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMediumFddi) \
            ? 14 \
            : ((PBINDING_CONTEXT)(pBinding))->pAdapterContext->RcvLanHeaderLength)

#else

//
// this always returns 14 as the DIX lan header length
//

#define LlcGetReceivedLanHeaderLength(pBinding) \
    ((((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMedium802_3) \
        ? 14 \
        : (((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMediumFddi) \
            ? 14 \
            : ((PBINDING_CONTEXT)(pBinding))->pAdapterContext->RcvLanHeaderLength)

#endif

//
//  USHORT
//  LlcGetEthernetType(
//      IN PVOID hContext
//      );
//

#define LlcGetEthernetType(hContext) \
    (((PBINDING_CONTEXT)(hContext))->pAdapterContext->EthernetType)

//
//  UINT
//  LlcGetCommittedSpace(
//      IN PVOID hLink
//      );
//

#define LlcGetCommittedSpace(hLink) \
    (((PDATA_LINK)(hLink))->BufferCommitment)

#else

//
// separation of church and state, or DLC and LLC even
//

UINT
LlcGetReceivedLanHeaderLength(
    IN PVOID pBinding
    );

USHORT
LlcGetEthernetType(
    IN PVOID hContext
    );

UINT
LlcGetCommittedSpace(
    IN PVOID hLink
    );

#endif // DLC_AND_LLC

#endif // _LLC_API_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llclib.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llclib.c

Abstract:

    This module includes some general purpose library routines

    Contents:
        SwapMemCpy
        RemoveFromLinkList
        LlcSleep
        LlcInitUnicodeString
        LlcFreeUnicodeString

Author:

    Antti Saarenheimo (o-anttis) 20-MAY-1991

Revision History:

--*/

#include <llc.h>
#include <memory.h>

//
// This table is used to swap the bits within each byte.
// The bits are in a reverse order in the token-ring frame header.
// We must swap the bits in a ethernet frame header, when the header
// is copied to a user buffer.
//

UCHAR Swap[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};


VOID
SwapMemCpy(
    IN BOOLEAN boolSwapBytes,
    IN PUCHAR pDest,
    IN PUCHAR pSrc,
    IN UINT Len
    )

/*++

Routine Description:

    conditionally swaps the bits within the copied bytes.

Arguments:

    boolSwapBytes   - TRUE if bytes are to be bit-swapped
    pDest           - where to copy to
    pSrc            - where to copy from
    Len             - number of bytes to copy

Return Value:

    None.

--*/

{
    if (boolSwapBytes) {
        SwappingMemCpy(pDest, pSrc, Len);
    } else {
        LlcMemCpy(pDest, pSrc, Len);
    }
}


VOID
RemoveFromLinkList(
    IN OUT PVOID* ppBase,
    IN PVOID pElement
    )

/*++

Routine Description:

    Searches and removes the given element from a single-entry link list.

    ASSUMES: the link points to the link field in the next object

Arguments:

    ppBase      - pointer to pointer to queue
    pElement    - pointer to element to remove from queue

Return Value:

    None.

--*/

{
    for (; (PQUEUE_PACKET)*ppBase; ppBase = (PVOID*)&(((PQUEUE_PACKET)*ppBase)->pNext)) {
        if (*ppBase == pElement) {
            *ppBase = ((PQUEUE_PACKET)pElement)->pNext;

#if LLC_DBG
            ((PQUEUE_PACKET)pElement)->pNext = NULL;
#endif

            break;
        }
    }
}


VOID
LlcSleep(
    IN LONG lMicroSeconds
    )

/*++

Routine Description:

    Suspends thread execution for a short time

Arguments:

    lMicroSeconds   - number of microseconds to wait

Return Value:

    None.

--*/

{
    TIME t;

    t.LowTime = -(lMicroSeconds * 10);
    t.HighTime = -1;
    KeDelayExecutionThread(UserMode, FALSE, &t);
}


DLC_STATUS
LlcInitUnicodeString(
    OUT PUNICODE_STRING pStringDest,
    IN PUNICODE_STRING pStringSrc
    )

/*++

Routine Description:

    initialize a UNICODE_STRING

Arguments:

    pStringDest - pointer to UNICODE_STRING structure to initialize
    pStringSrc  - pointer to UNICODE_STRING structure containing valid string

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                    Couldn't allocate memory from non-paged pool

--*/

{
    pStringDest->MaximumLength = (USHORT)(pStringSrc->Length + sizeof(WCHAR));
    pStringDest->Buffer = ALLOCATE_STRING_DRIVER(pStringDest->MaximumLength);
    if (pStringDest->Buffer == NULL) {
        return DLC_STATUS_NO_MEMORY;
    } else {
        RtlCopyUnicodeString(pStringDest, pStringSrc);
        return STATUS_SUCCESS;
    }
}


VOID
LlcFreeUnicodeString(
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Companion routine to LlcInitUnicodeString - frees memory allocated from
    non-paged pool for a UNICODE string

Arguments:

    UnicodeString   - pointer to UNICODE_STRING structure, the buffer for which
                      was allocated in LlcInitUnicodeString

Return Value:

    None.

--*/

{
    FREE_STRING_DRIVER(UnicodeString->Buffer);
}

//#if LLC_DBG
//
//VOID
//LlcInvalidObjectType( VOID )
//{
//    DbgPrint( "DLC: Invalid object type!\n");
//    DbgBreakPoint();
//}
//
//
//VOID LlcBreakListCorrupt( VOID )
//{
//    DbgPrint( "Link list is corrupt! ");
//    DbgBreakPoint();
//}
//
//static PUCHAR aLanLlcInputStrings[] = {
//    "DISC0",
//    "DISC1",
//    "DM0",
//    "DM1",
//    "FRMR0",
//    "FRMR1",
//    "SABME0",
//    "SABME1",
//    "UA0",
//    "UA1",
//    "IS_I_r0",
//    "IS_I_r1",
//    "IS_I_c0",
//    "IS_I_c1",
//    "OS_I_r0",
//    "OS_I_r1",
//    "OS_I_c0",
//    "OS_I_c1",
//    "REJ_r0",
//    "REJ_r1",
//    "REJ_c0",
//    "REJ_c1",
//    "RNR_r0",
//    "RNR_r1",
//    "RNR_c0",
//    "RNR_c1",
//    "RR_r0",
//    "RR_r1",
//    "RR_c0",
//    "RR_c1",
//    "LPDU_INVALID_r0",
//    "LPDU_INVALID_r1",
//    "LPDU_INVALID_c0",
//    "LPDU_INVALID_c1",
//    "ACTIVATE_LS",
//    "DEACTIVATE_LS",
//    "ENTER_LCL_Busy",
//    "EXIT_LCL_Busy",
//    "SEND_I_POLL",
//    "SET_ABME",
//    "SET_ADM",
//    "Ti_Expired",
//    "T1_Expired",
//    "T2_Expired"
//};
//
////
////  Procedure prints the last global inputs and time stamps. This
////  does not print the stamps of a specific link station!!!
////
//VOID
//PrintLastInputs(
//    IN PUCHAR pszMessage,
//    IN PDATA_LINK  pLink
//    )
//{
//    UINT    i;
//    UINT    j = 0;
//
//    DbgPrint( pszMessage );
//
//    //
//    //  Print 20 last time stamps and state inputs of the given
//    //  link station.
//    //
//    for (i = InputIndex - 1; i > InputIndex - LLC_INPUT_TABLE_SIZE; i--)
//    {
//        if (aLast[ i % LLC_INPUT_TABLE_SIZE ].pLink == pLink)
//        {
//            DbgPrint(
//                "%4x:%10s, ",
//                aLast[i % LLC_INPUT_TABLE_SIZE].Time,
//                aLanLlcInputStrings[ aLast[i % LLC_INPUT_TABLE_SIZE].Input]
//                );
//            j++;
//            if ((j % 4) == 0)
//            {
//                DbgPrint( "\n" );
//            }
//            if (j == 20)
//            {
//                break;
//            }
//        }
//    }
//}
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcinfo.c

Abstract:

    Includes set/get information primitives of the data link driver.

    Contents:
        LlcQueryInformation
        LlcSetInformation
        UpdateFunctionalAddress
        UpdateGroupAddress

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

#include <llc.h>

//
// We are using only a single state state machine defined
// in IBM Token-Ring Architecture.  On the other hand, DLC
// API requires a state machine having primary and secondary
// states.  The secondary states are used only when the link is
// open.  These tables converts the single internal state to
// the primary and secondary states.
//

UCHAR PrimaryStates[MAX_LLC_LINK_STATE] = {
    LLC_LINK_CLOSED,        //  LINK_CLOSED,
    LLC_DISCONNECTED,       //  DISCONNECTED,
    LLC_LINK_OPENING,       //  LINK_OPENING,
    LLC_DISCONNECTING,      //  DISCONNECTING,
    LLC_FRMR_SENT,          //  FRMR_SENT,
    LLC_LINK_OPENED,        //  LINK_OPENED,
    LLC_LINK_OPENED,        //  LOCAL_BUSY,
    LLC_LINK_OPENED,        //  REJECTION
    LLC_LINK_OPENED,        //  CHECKPOINTING
    LLC_LINK_OPENED,        //  CHKP_LOCAL_BUSY
    LLC_LINK_OPENED,        //  CHKP_REJECT
    LLC_RESETTING,          //  RESETTING
    LLC_LINK_OPENED,        //  REMOTE_BUSY
    LLC_LINK_OPENED,        //  LOCAL_REMOTE_BUSY
    LLC_LINK_OPENED,        //  REJECT_LOCAL_BUSY
    LLC_LINK_OPENED,        //  REJECT_REMOTE_BUSY
    LLC_LINK_OPENED,        //  CHKP_REJECT_LOCAL_BUSY
    LLC_LINK_OPENED,        //  CHKP_CLEARING
    LLC_LINK_OPENED,        //  CHKP_REJECT_CLEARING
    LLC_LINK_OPENED,        //  REJECT_LOCAL_REMOTE_BUSY
    LLC_FRMR_RECEIVED       //  FRMR_RECEIVED
};

//
// Note: the local busy state must be set separately!
//

UCHAR SecondaryStates[MAX_LLC_LINK_STATE] = {
    LLC_NO_SECONDARY_STATE,             //  LINK_CLOSED,
    LLC_NO_SECONDARY_STATE,             //  DISCONNECTED,
    LLC_NO_SECONDARY_STATE,             //  LINK_OPENING,
    LLC_NO_SECONDARY_STATE,             //  DISCONNECTING,
    LLC_NO_SECONDARY_STATE,             //  FRMR_SENT,
    LLC_NO_SECONDARY_STATE,             //  LINK_OPENED,
    LLC_NO_SECONDARY_STATE,             //  LOCAL_BUSY,
    LLC_REJECTING,                      //  REJECTION
    LLC_CHECKPOINTING,                  //  CHECKPOINTING
    LLC_CHECKPOINTING,                  //  CHKP_LOCAL_BUSY
    LLC_CHECKPOINTING|LLC_REJECTING,    //  CHKP_REJECT
    LLC_NO_SECONDARY_STATE,             //  RESETTING
    LLC_REMOTE_BUSY,                    //  REMOTE_BUSY
    LLC_REMOTE_BUSY,                    //  LOCAL_REMOTE_BUSY
    LLC_REJECTING,                      //  REJECT_LOCAL_BUSY
    LLC_REJECTING|LLC_REMOTE_BUSY,      //  REJECT_REMOTE_BUSY
    LLC_CHECKPOINTING|LLC_REJECTING,    //  CHKP_REJECT_LOCAL_BUSY
    LLC_CHECKPOINTING|LLC_CLEARING,     //  CHKP_CLEARING
    LLC_CHECKPOINTING|LLC_CLEARING|LLC_REJECTING,   //  CHKP_REJECT_CLEARING
    LLC_REJECTING|LLC_REMOTE_BUSY,      //  REJECT_LOCAL_REMOTE_BUSY
    LLC_NO_SECONDARY_STATE              //  FRMR_RECEIVED
};


DLC_STATUS
LlcQueryInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_QUERY_INFO_BUFFER pQuery,
    IN UINT QueryBufferSize
    )

/*++

Routine Description:

    Procedure returns the statistics or parameter information of
    the given LLC object.

Arguments:

    hObject         - LLC object
    InformationType - the requested information (NDIS, Statistics, params)
    pQuery          - buffer for the queried parameters
    QueryBufferSize - size of the buffer

Return Value:

    DLC_STATUS

--*/

{
    PVOID CopyBuffer = NULL;    // no warnings when -W4
    UINT CopyLength = 0;        // no warnings when -W4
    DLC_STATUS Status = STATUS_SUCCESS;
    PADAPTER_CONTEXT pAdapterContext;

    switch (InformationType) {
    case DLC_INFO_CLASS_STATISTICS:
    case DLC_INFO_CLASS_STATISTICS_RESET:
        switch (((PDATA_LINK)hObject)->Gen.ObjectType) {
        case LLC_DIRECT_OBJECT:

            //
            // We don't gather any staticstics for direct objects
            //

            CopyBuffer = &(((PLLC_STATION_OBJECT)hObject)->Statistics);
            CopyLength = sizeof(SAP_STATISTICS);
            break;

        case LLC_SAP_OBJECT:

            //
            // copy the SAP statistics, reset the old data if necessary.
            // We don't check the buffer, the upper part if responsible
            // of that.
            //

            CopyBuffer = &(((PLLC_SAP)hObject)->Statistics);
            CopyLength = sizeof(SAP_STATISTICS);
            break;

        case LLC_LINK_OBJECT:
            CopyBuffer = &(((PDATA_LINK)hObject)->Statistics);
            CopyLength = sizeof(LINK_STATION_STATISTICS);
            break;

#if LLC_DBG
        default:
            LlcInvalidObjectType();
#endif
        }

        //
        // Check the size of the receive buffers
        //

        if (CopyLength <= QueryBufferSize) {
            LlcMemCpy(pQuery->auchBuffer, CopyBuffer, CopyLength);

            //
            // Copy also the specific link station information
            //

            if (((PDATA_LINK)hObject)->Gen.ObjectType == LLC_LINK_OBJECT) {
                pQuery->LinkLog.uchLastCmdRespReceived = ((PDATA_LINK)hObject)->LastCmdOrRespReceived;
                pQuery->LinkLog.uchLastCmdRespTransmitted = ((PDATA_LINK)hObject)->LastCmdOrRespSent;
                pQuery->LinkLog.uchPrimaryState = PrimaryStates[((PDATA_LINK)hObject)->State];
                pQuery->LinkLog.uchSecondaryState = SecondaryStates[((PDATA_LINK)hObject)->State];

                //
                // We keep a separate state by whom the local
                // busy state has been set.
                //

                if (((PDATA_LINK)hObject)->Flags & DLC_LOCAL_BUSY_USER) {
                    pQuery->LinkLog.uchSecondaryState |= LLC_LOCAL_BUSY_USER_SET;
                }
                if (((PDATA_LINK)hObject)->Flags & DLC_LOCAL_BUSY_BUFFER) {
                    pQuery->LinkLog.uchSecondaryState |= LLC_LOCAL_BUSY_BUFFER_SET;
                }
                pQuery->LinkLog.uchSendStateVariable = ((PDATA_LINK)hObject)->Vs / (UCHAR)2;
                pQuery->LinkLog.uchReceiveStateVariable = ((PDATA_LINK)hObject)->Vr / (UCHAR)2;
                pQuery->LinkLog.uchLastNr = (UCHAR)(((PDATA_LINK)hObject)->Nr / 2);

                //
                // The lan header used by the link is in the same
                // format as the received lan headers
                //

                pQuery->LinkLog.cbLanHeader = (UCHAR)LlcCopyReceivedLanHeader(
                        ((PLLC_STATION_OBJECT)hObject)->Gen.pLlcBinding,
                        pQuery->LinkLog.auchLanHeader,
                        ((PDATA_LINK)hObject)->auchLanHeader
                        );
            }
        } else {

            //
            // The data will be lost, when it is reset
            //

            Status = DLC_STATUS_LOST_LOG_DATA;
            CopyLength = QueryBufferSize;
        }
        if (InformationType == DLC_INFO_CLASS_STATISTICS_RESET) {
            LlcZeroMem(CopyBuffer, CopyLength);
        }
        break;

    case DLC_INFO_CLASS_DLC_TIMERS:
        if (QueryBufferSize < sizeof( LLC_TICKS)) {

            //
            // This is a wrong error message, but there is no better one
            //

            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }
        LlcMemCpy(&pQuery->Timer,
                  &((PBINDING_CONTEXT)hObject)->pAdapterContext->ConfigInfo.TimerTicks,
                  sizeof(LLC_TICKS)
                  );
        break;

    case DLC_INFO_CLASS_DIR_ADAPTER:
        if (QueryBufferSize < sizeof(LLC_ADAPTER_INFO)) {
            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }

        pAdapterContext = ((PBINDING_CONTEXT)hObject)->pAdapterContext;
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->Adapter.auchFunctionalAddress,
                   ((PBINDING_CONTEXT)hObject)->Functional.auchAddress,
                   4
                   );
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->Adapter.auchGroupAddress,
                   (PUCHAR)&((PBINDING_CONTEXT)hObject)->ulBroadcastAddress,
                   4
                   );
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->Adapter.auchNodeAddress,
                   pAdapterContext->Adapter.Node.auchAddress,
                   6
                   );
        pQuery->Adapter.usMaxFrameSize = (USHORT)pAdapterContext->MaxFrameSize;
        pQuery->Adapter.ulLinkSpeed = pAdapterContext->LinkSpeed;

        if (pAdapterContext->NdisMedium == NdisMedium802_3) {
            pQuery->Adapter.usAdapterType = 0x0100;     // Ethernet type in OS/2
        } else if (pAdapterContext->NdisMedium == NdisMediumFddi) {

            //
            // NOTE: Using a currently free value to indicate FDDI
            //

            pQuery->Adapter.usAdapterType = 0x0200;
        } else {

            //
            // All token-ring adapters use type "IBM tr 16/4 Adapter A",
            //

            pQuery->Adapter.usAdapterType = 0x0040;
        }
        break;

    case DLC_INFO_CLASS_PERMANENT_ADDRESS:
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->PermanentAddress,
                   ((PBINDING_CONTEXT)hObject)->pAdapterContext->PermanentAddress,
                   6
                   );
        break;

    default:
        return DLC_STATUS_INVALID_COMMAND;
    }
    return Status;
}


DLC_STATUS
LlcSetInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_SET_INFO_BUFFER pSetInfo,
    IN UINT ParameterBufferSize
    )

/*++

Routine Description:

    Procedure sets different parameter sets to the link station objects.

Arguments:

    hObject             - LLC object
    InformationType     - the requested information (NDIS, Statistics, params)
    ParameterBuffer     - buffer for the queried parameters
    ParameterBufferSize - size of the buffer

Special:

    Must be called IRQL < DPC (at least when broadcast addresses
    are modifiled)

Return Value:

--*/

{
    DLC_STATUS Status = STATUS_SUCCESS;
    TR_BROADCAST_ADDRESS TempFunctional;

    //
    // There is only one high level functions, but InformationType
    // and the destination station type defines the actual changed
    // information.
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    switch (InformationType) {
    case DLC_INFO_CLASS_LINK_STATION:
        switch (((PDATA_LINK)hObject)->Gen.ObjectType) {
        case LLC_LINK_OBJECT:
            if (ParameterBufferSize < sizeof(DLC_LINK_PARAMETERS)) {
                return DLC_STATUS_INVALID_BUFFER_LENGTH;
            }
            Status = CheckLinkParameters(&pSetInfo->LinkParms);

            if (Status != STATUS_SUCCESS) {
                return Status;
            }

            ACQUIRE_SPIN_LOCK(&(((PLLC_GENERIC_OBJECT)hObject)->pAdapterContext->SendSpinLock));

            SetLinkParameters((PDATA_LINK)hObject, pSetInfo->auchBuffer);

            RELEASE_SPIN_LOCK(&(((PLLC_GENERIC_OBJECT)hObject)->pAdapterContext->SendSpinLock));

            break;

        case LLC_SAP_OBJECT:
            if (ParameterBufferSize < sizeof(DLC_LINK_PARAMETERS)) {
                return DLC_STATUS_INVALID_BUFFER_LENGTH;
            }
            Status = CheckLinkParameters(&pSetInfo->LinkParms);
            if (Status != STATUS_SUCCESS) {
                return Status;
            }
            CopyLinkParameters((PUCHAR)&((PLLC_SAP)hObject)->DefaultParameters,
                               (PUCHAR)&pSetInfo->LinkParms,
                               (PUCHAR)&DefaultParameters
                               );
            break;

        default:
            return DLC_STATUS_INVALID_STATION_ID;
        }
        break;

    case DLC_INFO_CLASS_DLC_TIMERS:
        if (ParameterBufferSize < sizeof(LLC_TICKS)) {
            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }

        //
        // We will copy all non-zero timer tick values from the
        // the given buffer.
        //

        CopyNonZeroBytes((PUCHAR)&((PBINDING_CONTEXT)hObject)->pAdapterContext->ConfigInfo.TimerTicks,
                         (PUCHAR)&pSetInfo->Timers,
                         (PUCHAR)&((PBINDING_CONTEXT)hObject)->pAdapterContext->ConfigInfo.TimerTicks,
                         sizeof(LLC_TICKS)
                         );
        break;

    case DLC_INFO_CLASS_SET_GROUP:
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   (PUCHAR)&((PBINDING_CONTEXT)hObject)->ulBroadcastAddress,
                   pSetInfo->auchGroupAddress,
                   sizeof(TR_BROADCAST_ADDRESS)
                   );

        Status = UpdateGroupAddress(((PBINDING_CONTEXT)hObject)->pAdapterContext,
                                    (PBINDING_CONTEXT)hObject
                                    );
        break;

    case DLC_INFO_CLASS_RESET_FUNCTIONAL:
    case DLC_INFO_CLASS_SET_FUNCTIONAL:
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   TempFunctional.auchAddress,
                   pSetInfo->auchFunctionalAddress,
                   sizeof(TR_BROADCAST_ADDRESS)
                   );

        //
        // We have now swapped the bits to ethernet format,
        // Highest bit is now 0x01... and lowest ones are ..30,
        // Reset the bits if highest (0x01) is set and set
        // them if it is zero, but do not hange yje orginal
        // bits: 31,1,0  that are now mapped to ethernet format.
        //

        if (InformationType == DLC_INFO_CLASS_SET_FUNCTIONAL) {
            ((PBINDING_CONTEXT)hObject)->Functional.ulAddress |= TempFunctional.ulAddress;
        } else {
            ((PBINDING_CONTEXT)hObject)->Functional.ulAddress &= ~TempFunctional.ulAddress;
        }
        ((PBINDING_CONTEXT)hObject)->ulFunctionalZeroBits = ~((PBINDING_CONTEXT)hObject)->Functional.ulAddress;
        Status = UpdateFunctionalAddress(((PBINDING_CONTEXT)hObject)->pAdapterContext);
        break;

    case DLC_INFO_CLASS_SET_MULTICAST:
        memcpy(&((PBINDING_CONTEXT)hObject)->usBroadcastAddress,
               pSetInfo->auchBuffer,
               6
               );
        Status = UpdateFunctionalAddress(((PBINDING_CONTEXT)hObject)->pAdapterContext);
        break;

    default:
        return DLC_STATUS_INVALID_COMMAND;
    }
    return Status;
}


DLC_STATUS
UpdateFunctionalAddress(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Procedure first makes inclusive or between the functionl address of
    this process context and the functional address defined
    for all bindings and then saves the new functional address to NDIS.
    The NT mutex makes this operation atomic.

Arguments:

    pAdapterContext - LLC context of the current adapter

Return Value:

--*/

{
    UCHAR aMulticastList[LLC_MAX_MULTICAST_ADDRESS * 6];
    TR_BROADCAST_ADDRESS NewFunctional;
    UINT MulticastListSize;
    ULONG CurrentMulticast;
    PBINDING_CONTEXT pBinding;
    UINT i;
    NDIS_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    NewFunctional.ulAddress = 0;

    //
    // We cannot be setting several functional addresses simultanously!
    //

    RELEASE_DRIVER_LOCK();

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeWaitForSingleObject(&NdisAccessMutex, UserRequest, KernelMode, FALSE, NULL);

    ACQUIRE_DRIVER_LOCK();

    //
    // The access to global data structures must be procted by
    // the spin lock.
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    for (pBinding = pAdapterContext->pBindings; pBinding; pBinding = pBinding->pNext) {
        NewFunctional.ulAddress |= pBinding->Functional.ulAddress;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    if ((pAdapterContext->NdisMedium == NdisMedium802_3)
    || (pAdapterContext->NdisMedium == NdisMediumFddi)) {

        //
        // Each bit in the functional address is translated
        // to a ethernet multicast address.
        // The bit order within byte has already been swapped.
        //

        CurrentMulticast = 1;
        MulticastListSize = 0;
        for (i = 0; i < 31; i++) {
            if (CurrentMulticast & NewFunctional.ulAddress) {
                aMulticastList[MulticastListSize] = 0x03;
                aMulticastList[MulticastListSize + 1] = 0;
                LlcMemCpy(&aMulticastList[MulticastListSize + 2],
                          &CurrentMulticast,
                          sizeof(CurrentMulticast)
                          );
                MulticastListSize += 6;
            }
            CurrentMulticast <<= 1;
        }

        //
        // Add the group addresses of all bindings behind
        // the functional addresses in the table.
        //

        for (pBinding = pAdapterContext->pBindings; pBinding; pBinding = pBinding->pNext) {

            //
            // We may drop some group addresses, but I don't expect that
            // it will ever happen (i don't know anybody using tr
            // group address, the possibility to have all functional
            // address bits in use and more than one group address in system
            // is almost impossible)
            //

            if (pBinding->ulBroadcastAddress != 0
            && MulticastListSize < LLC_MAX_MULTICAST_ADDRESS * 6) {

                //
                // Set the default bits in the group address,
                // but use ethernet bit order.
                //

                LlcMemCpy(&aMulticastList[MulticastListSize],
                          &pBinding->usBroadcastAddress,
                          6
                          );
                MulticastListSize += 6;
            }
        }

        RELEASE_DRIVER_LOCK();

        Status = SetNdisParameter(pAdapterContext,
                                  (pAdapterContext->NdisMedium == NdisMediumFddi)
                                    ? OID_FDDI_LONG_MULTICAST_LIST
                                    : OID_802_3_MULTICAST_LIST,
                                  aMulticastList,
                                  MulticastListSize
                                  );
    } else {

        //
        // The functional address bit (bit 0) must be always reset!
        //

        NewFunctional.auchAddress[0] &= ~0x80;

        RELEASE_DRIVER_LOCK();

        Status = SetNdisParameter(pAdapterContext,
                                  OID_802_5_CURRENT_FUNCTIONAL,
                                  &NewFunctional,
                                  sizeof(NewFunctional)
                                  );
    }

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeReleaseMutex(&NdisAccessMutex, FALSE);

    ACQUIRE_DRIVER_LOCK();

    if (Status != STATUS_SUCCESS) {
        return DLC_STATUS_INVALID_FUNCTIONAL_ADDRESS;
    }
    return STATUS_SUCCESS;
}


DLC_STATUS
UpdateGroupAddress(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    Procedure updates token-ring' group address.
    It is converted automatically multicast address
    on the ethernet.

Arguments:

    pAdapterContext - describes adapter to update group addresses for
    pBindingContext - describes binding context

Return Value:

    DLC_STATUS

--*/

{
    NDIS_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if ((pAdapterContext->NdisMedium == NdisMedium802_3)
    || (pAdapterContext->NdisMedium == NdisMediumFddi)) {

        PUCHAR pMulticastAddress = (PUCHAR)&pBindingContext->usBroadcastAddress;

        pMulticastAddress[0] = 0x03;
        pMulticastAddress[1] = 0;
        pMulticastAddress[2] |= 1;

        //
        // Because functional and group addresses are mapped into
        // the multicast addresses, the updated global multicast list
        // must inlcude both address types of all bindings,
        //

        Status = UpdateFunctionalAddress(pAdapterContext);
        return Status;
    } else {

        PUCHAR pGroupAddress = (PUCHAR)&pBindingContext->usBroadcastAddress;

        pGroupAddress[0] = 0xC0;
        pGroupAddress[1] = 0;

        //
        // The group/functional address bit must be always set!
        //

        pGroupAddress[2] |= 0x80;

        RELEASE_DRIVER_LOCK();

        Status = SetNdisParameter(pAdapterContext,
                                  OID_802_5_CURRENT_GROUP,
                                  &pGroupAddress[2],
                                  4
                                  );

        ACQUIRE_DRIVER_LOCK();

        //
        // The error status code is wrong, but IBM has defined no
        // error code for this case.
        //

        if (Status != STATUS_SUCCESS) {
            return DLC_STATUS_INVALID_FUNCTIONAL_ADDRESS;
        } else {
            return STATUS_SUCCESS;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcdef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dldef.h

Abstract:

    This module defines all internal constants in data link driver.

Author:

    Antti Saarenheimo (o-anttis) 25-MAY-1991

Revision History:

--*/

#define DEBUG_VERSION 1

//
// Marks for FSM compiler
//

#define FSM_DATA
#define FSM_PREDICATE_CASES
#define FSM_ACTION_CASES
#define FSM_CONST

#define MAX_NDIS_PACKETS        5       // 5 for XID/TEST and 5 for others
#define LLC_OPEN_TIMEOUT        1200    // 60 seconds (enough for tr open?)

#define DEFAULT_TR_ACCESS       0x50
#define NON_MAC_FRAME           0x40

//
// 2nd source routing control bit
//

#define SRC_ROUTING_LF_MASK     0x70

#define MAX_TR_LAN_HEADER_SIZE  32
#define LLC_MAX_LAN_HEADER      32
#define MAX_TR_SRC_ROUTING_INFO 18

//
// the next status values are used internally by DLCAPI driver:
//

#define CONFIRM_CONNECT         0x0008
#define CONFIRM_DISCONNECT      0x0004
#define CONFIRM_CONNECT_FAILED  0x0002

//
// The following structures define I-frame, U-frame, and S-frame DLC headers.
//

#define LLC_SSAP_RESPONSE       0x0001  // if (ssap & LLC_SSAP_RESP),it's a response.
#define LLC_DSAP_GROUP          0x0001  // Dsap lowest bit set when group sap
#define LLC_SSAP_GLOBAL         0x00ff  // the global SAP.
#define LLC_SSAP_NULL           0x0000  // the null SAP.
#define LLC_SSAP_MASK           0x00fe  // mask to wipe out the response bit.
#define LLC_DSAP_MASK           0x00fe  // mask to wipe out the group SAP bit.

#define LLC_RR                  0x01    // command code for RR.
#define LLC_RNR                 0x05    // command code for RNR.
#define LLC_REJ                 0x09    // command code for REJ.

#define LLC_SABME               0x6f    // command code for SABME.
#define LLC_DISC                0x43    // command code for DISC.
#define LLC_UA                  0x63    // command code for UA.
#define LLC_DM                  0x0f    // command code for DM.
#define LLC_FRMR                0x87    // command code for FRMR.
#define LLC_UI                  0x03    // command code for UI.
#define LLC_XID                 0xaf    // command code for XID.
#define LLC_TEST                0xe3    // command code for TEST.
#define IEEE_802_XID_ID         0x81    // IEEE 802.2 XID identifier
#define LLC_CLASS_II            3       // we support LLC Class II

#define LLC_S_U_TYPE_MASK       3
#define LLC_U_TYPE              3
#define LLC_U_TYPE_BIT          2
#define LLC_S_TYPE              1

#define LLC_NOT_I_FRAME         0x01
#define LLC_U_INDICATOR         0x03  // (cmd & LLC_U_IND) == LLC_U_IND --> U-frame.
#define LLC_U_POLL_FINAL        0x10  // (cmd & LLC_U_PF) -> poll/final set.

#define LLC_I_S_POLL_FINAL      1

//
// You may use 2048 or 1024 if you want to make link more aggressively to
// increment the transmit window when there has been a I-c1 retransmission
// after a T1 timeout.
//

#define LLC_MAX_T1_TO_I_RATIO   4096

//
// Link station flags
//

#define DLC_WAITING_RESPONSE_TO_POLL        0x01
#define DLC_FIRST_POLL                      0x02
#define DLC_ACTIVE_REMOTE_CONNECT_REQUEST   0x04
#define DLC_SEND_DISABLED                   0x10
#define DLC_FINAL_RESPONSE_PENDING_IN_NDIS  0x20

#define DLC_LOCAL_BUSY_BUFFER   0x40
#define DLC_LOCAL_BUSY_USER     0x80

//
// Test file for FSM compiler!!!!
//

#ifdef FSM_CONST

enum eLanLlcInput {
    DISC0 = 0,
    DISC1 = 1,
    DM0 = 2,
    DM1 = 3,
    FRMR0 = 4,
    FRMR1 = 5,
    SABME0 = 6,
    SABME1 = 7,
    UA0 = 8,
    UA1 = 9,
    IS_I_r0 = 10,
    IS_I_r1 = 11,
    IS_I_c0 = 12,
    IS_I_c1 = 13,
    OS_I_r0 = 14,
    OS_I_r1 = 15,
    OS_I_c0 = 16,
    OS_I_c1 = 17,
    REJ_r0 = 18,
    REJ_r1 = 19,
    REJ_c0 = 20,
    REJ_c1 = 21,
    RNR_r0 = 22,
    RNR_r1 = 23,
    RNR_c0 = 24,
    RNR_c1 = 25,
    RR_r0 = 26,
    RR_r1 = 27,
    RR_c0 = 28,
    RR_c1 = 29,
    LPDU_INVALID_r0 = 30,
    LPDU_INVALID_r1 = 31,
    LPDU_INVALID_c0 = 32,
    LPDU_INVALID_c1 = 33,
    ACTIVATE_LS = 34,
    DEACTIVATE_LS = 35,
    ENTER_LCL_Busy = 36,
    EXIT_LCL_Busy = 37,
    SEND_I_POLL = 38,
    SET_ABME = 39,
    SET_ADM = 40,
    Ti_Expired = 41,
    T1_Expired = 42,
    T2_Expired = 43
};

enum eLanLlcState {
    LINK_CLOSED = 0,
    DISCONNECTED = 1,
    LINK_OPENING = 2,
    DISCONNECTING = 3,
    FRMR_SENT = 4,
    LINK_OPENED = 5,
    LOCAL_BUSY = 6,
    REJECTION = 7,
    CHECKPOINTING = 8,
    CHKP_LOCAL_BUSY = 9,
    CHKP_REJECT = 10,
    RESETTING = 11,
    REMOTE_BUSY = 12,
    LOCAL_REMOTE_BUSY = 13,
    REJECT_LOCAL_BUSY = 14,
    REJECT_REMOTE_BUSY = 15,
    CHKP_REJECT_LOCAL_BUSY = 16,
    CHKP_CLEARING = 17,
    CHKP_REJECT_CLEARING = 18,
    REJECT_LOCAL_REMOTE_BUSY = 19,
    FRMR_RECEIVED = 20
};

#endif

#define MAX_LLC_LINK_STATE      21      // KEEP THIS IN SYNC WITH PREV ENUM!!!!

#define DLC_DSAP_OFFSET         0
#define DLC_SSAP_OFFSET         1
#define DLC_COMMAND_OFFSET      2
#define DLC_XID_INFO_ID         3
#define DLC_XID_INFO_TYPE       4
#define DLC_XID_INFO_WIN_SIZE   5

#define MAX_XID_TEST_RESPONSES  20

enum _LLC_FRAME_XLATE_MODES {
    LLC_SEND_UNSPECIFIED = -1,
    LLC_SEND_802_5_TO_802_3,
    LLC_SEND_802_5_TO_DIX,
    LLC_SEND_802_5_TO_802_5,
    LLC_SEND_802_5_TO_FDDI,
    LLC_SEND_DIX_TO_DIX,
    LLC_SEND_802_3_TO_802_3,
    LLC_SEND_802_3_TO_DIX,
    LLC_SEND_802_3_TO_802_5,
    LLC_SEND_UNMODIFIED,
    LLC_SEND_FDDI_TO_FDDI,
    LLC_SEND_FDDI_TO_802_5,
    LLC_SEND_FDDI_TO_802_3
};

#define DLC_TOKEN_RESPONSE  0
#define DLC_TOKEN_COMMAND   2

//*********************************************************************
//  **** Objects in _DLC_CMD_TOKENs enumeration and in auchLlcCommands
//  **** table bust MUST ABSOLUTELY BE IN THE SAME ORDER, !!!!!!!!
//  **** THEY ARE USED TO COMPRESS                             ********
//  **** THE SEND INITIALIZATION                               ********
//
enum _DLC_CMD_TOKENS {
    DLC_REJ_TOKEN = 4,
    DLC_RNR_TOKEN = 8,
    DLC_RR_TOKEN = 12,
    DLC_DISC_TOKEN = 16 | DLC_TOKEN_COMMAND,
    DLC_DM_TOKEN = 20,
    DLC_FRMR_TOKEN = 24,
    DLC_SABME_TOKEN = 28 | DLC_TOKEN_COMMAND,
    DLC_UA_TOKEN = 32
};

enum _LLC_PACKET_TYPES {
    LLC_PACKET_8022 = 0,
    LLC_PACKET_MAC,
    LLC_PACKET_DIX,
    LLC_PACKET_OTHER_DESTINATION,
    LLC_PACKET_MAX
};

#define MAX_DIX_TABLE 13      // good odd number!

enum _LlcSendCompletionTypes {
    LLC_XID_RESPONSE,       // 802.2 XID response packet
    LLC_U_COMMAND_RESPONSE, // link command response
    LLC_MIN_MDL_PACKET,     // all packets above this have MDL
    LLC_DIX_DUPLICATE,      // used to duplicate TEST and XID packets
    LLC_TEST_RESPONSE,      // Test response (buffer in non Paged Pool)
    LLC_MAX_RESPONSE_PACKET,// all packets above this are indicated to user
    LLC_TYPE_1_PACKET,
    LLC_TYPE_2_PACKET,

    //
    // We use extra status bits to indicate, when I- packet has been both
    // completed by NDIS and acknowledged the other side of link connection.
    // An I packet can be queued to the completion queue by
    // the second guy (either state machine or SendCompletion handler)
    // only when the first guy has set completed its work.
    // An I packet could be acknowledged by the other side before
    // its completion is indicated by NDIS.  Dlc Driver deallocates
    // the packet immediately, when Llc driver completes the acknowledged
    // packet => possible data corruption (if packet is reused before
    // NDIS has completed it).  This is probably not possible in a
    // single processor  NT- system, but very possible in multiprocessor
    // NT or systems without a single level DPC queue (like OS/2 and DOS).
    //

    LLC_I_PACKET_COMPLETE = 0x10,
    LLC_I_PACKET_UNACKNOWLEDGED = 0x20,
    LLC_I_PACKET_PENDING_NDIS   = 0x40,
    LLC_I_PACKET                = 0x70,          // when we are sending it
    LLC_I_PACKET_WAITING_NDIS   = 0x80
};

#define LLC_MAX_MULTICAST_ADDRESS 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llclink.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems Ab

Module Name:

    llclink.c

Abstract:

    The module implements the open, connect and close primitives
    for a link station object. The link stations have also been
    initialized within this module.

    Contents:
        LlcOpenLinkStation
        LlcConnectStation
        InitiateAsyncLinkCommand
        LlcDisconnectStation
        LlcFlowControl
        LinkFlowControl
        SearchLinkAddress
        SetLinkParameters
        CheckLinkParameters
        CopyLinkParameters
        CopyNonZeroBytes
        RunInterlockedStateMachineCommand

Author:

    Antti Saarenheimo (o-anttis) 28-MAY-1991

Revision History:

--*/

#include <llc.h>


DLC_STATUS
LlcOpenLinkStation(
    IN PLLC_SAP pSap,
    IN UCHAR DestinationSap,
    IN PUCHAR pDestinationAddress OPTIONAL,
    IN PUCHAR pReceivedLanHeader OPTIONAL,
    IN PVOID hClientStation,
    OUT PVOID* phLlcHandle
    )

/*++

Routine Description:

    creates a DATA_LINK structure and fills it in. Called either as a result
    of receiving a SABME, or via DLC.OPEN.STATION

    This operation is the same as ACTIVATE_LS primitive in IBM TR Arch. ref.

Arguments:

    pSap                - pointer to SAP
    DestinationSap      - remote SAP number
    pDestinationAddress - remote node address. If this function is being called
                          as a result of receiving a SABME for a new link then
                          this parameter is NULL
    pReceivedLanHeader  - LAN header as received off the wire, containing source
                          and destination adapter addresses, optional source
                          routing and source and destination SAPs
    hClientStation      - handle (address) of LLC client's link station object
    phLlcHandle         - pointer to returned handle (address) to LLC DATA_LINK
                          object

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
                    link station has been opened successfully
        Failure - DLC_STATUS_INVALID_SAP_VALUE
                    the link station already exists or the SAP is really invalid.
                  DLC_NO_MEMORY
                    there was no free preallocated link station

--*/

{
    PDATA_LINK pLink;
    PDATA_LINK* ppLink;
    PADAPTER_CONTEXT pAdapterContext = pSap->Gen.pAdapterContext;
    DLC_STATUS LlcStatus = STATUS_SUCCESS;
    UINT AddressTranslation;

    //
    // We need a temporary buffer to build lan header for link,
    // because user may use different ndis medium from network.
    //

    UCHAR auchTempBuffer[32];

    ASSUME_IRQL(DISPATCH_LEVEL);

    LlcZeroMem(auchTempBuffer, sizeof(auchTempBuffer));

    if (pSap->Gen.ObjectType != LLC_SAP_OBJECT) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);
    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    pLink = (PDATA_LINK)ALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool);

    if (pLink == NULL) {
        LlcStatus = DLC_STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    //
    // This reference keeps the object alive, until it is dereferenced
    // in the delete.
    //

    ReferenceObject(pLink);

    //
    // LLC driver have two different address formats:
    //
    // 1. External format of the binding (ethernet or token-ring,
    //    DLC driver uses always token-ring format, the ethernet
    //    support is compiled in conditionally.
    //
    // 2. Internal send format (always the actual lan type,
    //    ethernet, dix or tokenring).  The user provides link
    //    address in its own mode and we must build the actual
    //    lan link header from it.
    //

    if (pDestinationAddress != NULL) {

        //
        // link created by DLC.CONNECT.STATION
        //

        AddressTranslation = pSap->Gen.pLlcBinding->AddressTranslation;
        LlcBuildAddress(pSap->Gen.pLlcBinding->NdisMedium,
                        pDestinationAddress,
                        NULL,
                        auchTempBuffer
                        );
    } else {

        //
        // link created by incoming SABME
        //

        pLink->Flags |= DLC_ACTIVE_REMOTE_CONNECT_REQUEST;
        AddressTranslation = pAdapterContext->AddressTranslationMode;
        LlcBuildAddressFromLanHeader(pAdapterContext->NdisMedium,
                                     pReceivedLanHeader,
                                     auchTempBuffer
                                     );
    }

    //
    // We want to use always DIX lan headers in the token-ring case
    //

    if (AddressTranslation == LLC_SEND_802_5_TO_802_3) {
        AddressTranslation = LLC_SEND_802_5_TO_DIX;
    } else if (AddressTranslation == LLC_SEND_802_3_TO_802_3) {
        AddressTranslation = LLC_SEND_802_3_TO_DIX;
    }

    //
    // Now we can build the actual network header for the sending
    // (this same routine build lan header also for all
    // other packet types)
    //

    pLink->cbLanHeaderLength = CopyLanHeader(AddressTranslation,
                                             auchTempBuffer,
                                             pAdapterContext->NodeAddress,
                                             pLink->auchLanHeader,
                                             pAdapterContext->ConfigInfo.SwapAddressBits
                                             );

    //
    // We always build a DIX header but it is only used when the Ethernet type
    // is actually DIX
    //

    if (pAdapterContext->NdisMedium == NdisMedium802_3
    && pSap->Gen.pLlcBinding->EthernetType != LLC_ETHERNET_TYPE_DIX) {
        pLink->cbLanHeaderLength = 14;
    }

    //
    // Save the client handle, but reset and initailize everything else.
    // The link must be ready for any kind extrnal inputs when
    // we will connenct it to the hash table of the link stations.
    // (actually that's not true now, because we init the link to
    // LINK_CLOSED state, but we may change the state machine.
    // It would be a different thing with a 802.2 state machine)
    //

    pLink->Gen.ObjectType = LLC_LINK_OBJECT;

    //
    // RLF 07/22/92. The link state should be DISCONNECTED so that we can
    // accept incoming SABMEs for this SAP/link station. This is also
    // according to IBM LAN Tech. Ref. p. 2-33. It is safe to set the
    // DISCONNECTED state now because we have the send and object database
    // spin locks, so we can't get interrupted by NDIS driver
    //

    //
    // RLF 08/13/92. Ho Hum. This still isn't correct - we must put the link
    // into different states depending on how its being opened - DISCONNECTED
    // if the upper layers are creating the link, or LINK_CLOSED if we're
    // creating the link as a result of receiving a SABME. Use pReceivedLanHeader
    // as a flag: DLC calls this routine with this parameter set to NULL
    //

    ////pLink->State = LINK_CLOSED;
    //pLink->State = DISCONNECTED;

    pLink->State = pReceivedLanHeader ? LINK_CLOSED : DISCONNECTED;

    //
    // RLF 10/01/92. We need some way of knowing that the link station was
    // created by receiving a SABME. We need this to decide what to do with
    // the source routing info in a subsequent DLC.CONNECT.STATION command.
    // This field used to be Reserved
    //

    pLink->RemoteOpen = hClientStation == NULL;

    //
    // RLF 05/09/94
    //
    // We set the framing type to unspecified. This field is only used if the
    // adapter was opened in AUTO mode. It will be set to 802.3 or DIX by the
    // SABME received processing (new link created by remote station) or when
    // the first UA is received in response to the 2 SABMEs we send out (802.3
    // and DIX)
    //

    pLink->FramingType = (ULONG)LLC_SEND_UNSPECIFIED;

    pLink->Gen.hClientHandle = hClientStation;
    pLink->Gen.pAdapterContext = pAdapterContext;
    pLink->pSap = pSap;
    pLink->Gen.pLlcBinding = pSap->Gen.pLlcBinding;

    //
    // Save the node addresses used in link station
    //

    pDestinationAddress = pLink->auchLanHeader;
    if (pAdapterContext->NdisMedium == NdisMedium802_5) {
        pDestinationAddress += 2;
    } else if (pAdapterContext->NdisMedium == NdisMediumFddi) {
        ++pDestinationAddress;
    }

    memcpy(pLink->LinkAddr.Node.auchAddress, pDestinationAddress, 6);

    //
    // RLF 03/24/93
    //
    // if we're talking Ethernet or DIX, we need to report the bit-flipped
    // address at the DLC interface
    //

    SwapMemCpy((BOOLEAN)((AddressTranslation == LLC_SEND_802_3_TO_DIX)
               || (pAdapterContext->NdisMedium == NdisMediumFddi)),
               pLink->DlcStatus.auchRemoteNode,
               pDestinationAddress,
               6
               );

    //
    // Four different local saps: my code would need a cleanup
    // (four bytes doesn't use very much memory on the other hand)
    //

    pLink->LinkAddr.Address.DestSap = pLink->DlcStatus.uchRemoteSap = pLink->Dsap = DestinationSap;
    pLink->LinkAddr.Address.SrcSap = pLink->DlcStatus.uchLocalSap = pLink->Ssap = (UCHAR)pSap->SourceSap;
    pLink->DlcStatus.hLlcLinkStation = (PVOID)pLink;
    pLink->SendQueue.pObject = pLink;
    InitializeListHead(&pLink->SendQueue.ListHead);
    InitializeListHead(&pLink->SentQueue);
    pLink->Flags |= DLC_SEND_DISABLED;

    //
    // The next procedure returns the pointer of the slot for the
    // new link station pointer. The address may be in the
    // hash table or it may be the address of pRigth or pLeft
    // field within another link station structure.
    //

    ppLink = SearchLinkAddress(pAdapterContext, pLink->LinkAddr);

    //
    // this link station must not yet be in the table
    // of active link stations. If its slot is
    // empty, then save the new link station to the
    // list of the active link stations.
    //

    if (*ppLink != NULL) {
        LlcStatus = DLC_STATUS_INVALID_SAP_VALUE;

        DEALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool, pLink);

    } else {
        pLink->Gen.pNext = (PLLC_OBJECT)pSap->pActiveLinks;
        pSap->pActiveLinks = pLink;

        //
        // Set the default link parameters,
        // Note: This creates the timer ticks.  They must
        // be deleted with the terminate timer function,
        // when the link station is closed.
        //

        LlcStatus = SetLinkParameters(pLink, (PUCHAR)&pSap->DefaultParameters);
        if (LlcStatus != STATUS_SUCCESS) {

            //
            // We may have been started T1 and T2 timers.
            //

            TerminateTimer(pAdapterContext, &pLink->T1);
            TerminateTimer(pAdapterContext, &pLink->T2);

            DEALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool, pLink);

        } else {

            //
            // N2 is never initilaized by IBM state machine, when
            // the link is created by a remote connect request.
            // The link can be killed by this combination of state
            // transmitions:
            //  (LINK_OPENED),
            //  (RNR-r => REMOTE_BUSY),
            //  (RR-c => CHECKPOINTING)
            //  (T1 timeout => DISCONNECTED) !!!!!
            //
            // This will fix the bug in IBM state machine:
            //

            pLink->P_Ct = pLink->N2;
            *ppLink = *phLlcHandle = (PVOID)pLink;
            pAdapterContext->ObjectCount++;
        }
    }

ErrorExit:

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    return LlcStatus;
}


VOID
LlcBindLinkStation(
    IN PDATA_LINK pStation,
    IN PVOID hClientHandle
    )
{
    pStation->Gen.hClientHandle = hClientHandle;
}


VOID
LlcConnectStation(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket,
    IN PVOID pSourceRouting OPTIONAL,
    IN PUSHORT pusMaxInformationField
    )

/*++

Routine Description:

    The upper level protocol may call this primitive to initiate
    the connection negotiation with a remote link station,
    to accept the connection request or to reconnect a link station
    that have been disconnected for some reason with a new source
    routing information.
    The command is completed asynchronously and the status
    is returned as an event.

    The primitive is the same as SET_ABME primitive in "IBM TR Architecture
    reference".
    The function implements also CONNECT_REQUEST and CONNECT_RESPONSE
    primitives of IEEE 802.2.

Arguments:

    pStation                - address of link station
    pPacket                 - command completion packet
    pSourceRouting          - optional source routing information. This must
                              be NULL if the source routing information is not
                              used
    pusMaxInformationField  - the maximum data size possible to use with this
                              connection.  The source routing bridges may
                              decrease the maximum information field size.
                              Otherwise the maximum length is used

Return Value:

    None.

--*/

{
    NDIS_MEDIUM NdisMedium = pStation->Gen.pAdapterContext->NdisMedium;

    if (pSourceRouting) {

        //
        // We first read the destination address from the
        // lan header and then extend the source routing
        // field in the LAN header of link.
        //

        if (NdisMedium == NdisMedium802_5) {

            //
            // RLF 10/01/92. If RemoteOpen is TRUE then the link was opened
            // due to receiving a SABME and we ignore the source routing info
            // (we already got it from the SABME packet)
            //

            if (!pStation->RemoteOpen) {
                pStation->cbLanHeaderLength = (UCHAR)LlcBuildAddress(
                                                    NdisMedium,
                                                    &pStation->auchLanHeader[2],
                                                    pSourceRouting,
                                                    pStation->auchLanHeader
                                                    );
            }
        } else {
            pSourceRouting = NULL;
        }
    }
    *pusMaxInformationField = LlcGetMaxInfoField(NdisMedium,
                                                 pStation->Gen.pLlcBinding,
                                                 pStation->auchLanHeader
                                                 );
    pStation->MaxIField = *pusMaxInformationField;
    pStation->Flags &= ~DLC_ACTIVE_REMOTE_CONNECT_REQUEST;

    //
    // Activate the link station at first, the remotely connected
    // link station is already active and in that case the state
    // machine return logical error from ACTIVATE_LS input.
    //

    RunInterlockedStateMachineCommand(pStation, ACTIVATE_LS);
    InitiateAsyncLinkCommand(pStation, pPacket, SET_ABME, LLC_CONNECT_COMPLETION);
}

VOID
InitiateAsyncLinkCommand(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket,
    IN UINT StateMachineCommand,
    IN UINT CompletionCode
    )

/*++

Routine Description:

    Initiates or removes an LLC link. We have a link station in the DISCONNECTED
    state. We are either sending a SABME or DISC

Arguments:

    pLink               - pointer to LLC link station structure ('object')
    pPacket             - pointer to packet to use for transmission
    StateMachineCommand - command given to the state machine
    CompletionCode      - completion command type returned asynchronously

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;
    UINT Status;

    //
    // link will return an error status if it is already connected.
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    AllocateCompletionPacket(pLink, CompletionCode, pPacket);

    //
    // After RunStateMachineCommand
    // the link may be deleted in any time by an NDIS command completion
    // indication (send or receive) => we must not use link after this
    //

    Status = RunStateMachineCommand(pLink, StateMachineCommand);

    //
    // IBM state machine does not stop the send process => we
    // must do it here we will get a system bug check.
    //

    if (StateMachineCommand == SET_ADM) {
        DisableSendProcess(pLink);
    }

    //
    // disconnect or connect commands may fail, because there are
    // not enough memory to allocate packets for them.
    // In that case we must complete the command here with an error code.
    //

    if (Status != STATUS_SUCCESS) {
        QueueCommandCompletion((PLLC_OBJECT)pLink, CompletionCode, Status);
    }

    BackgroundProcessAndUnlock(pAdapterContext);
}


VOID
LlcDisconnectStation(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The primtive initiates the disconnection handshaking. The upper
    protocol must wait LLC_EVENT_DISCONNECTED event before it can close
    the link station. The link station must either be closed or
    reconnected after a disconnection event.  The DLC driver
    disconnects the link only when it is closed.

    This operation is the same as SET_ADM primitive in IBM TR Arch. ref.

Arguments:

    hStation - link station handle.

    hRequestHandle - opaque handle returned when the command completes

Return Value:

    None
        Complete always asynchronously by calling the
        command completion routine.

--*/

{
    //
    // We don't want send yet another DM, if the link station has
    // already disconnected.  We don't modify the state machine,
    // because the state machine should be as orginal as possible.
    //

    if (pLink->State == DISCONNECTED) {
        pPacket->Data.Completion.CompletedCommand = LLC_DISCONNECT_COMPLETION;
        pPacket->Data.Completion.Status = STATUS_SUCCESS;
        pLink->Gen.pLlcBinding->pfCommandComplete(
            pLink->Gen.pLlcBinding->hClientContext,
            pLink->Gen.hClientHandle,
            pPacket
            );
    } else {
        InitiateAsyncLinkCommand(
            pLink,
            pPacket,
            SET_ADM,
            LLC_DISCONNECT_COMPLETION
            );
    }
}


DLC_STATUS
LlcFlowControl(
    IN PLLC_OBJECT pStation,
    IN UCHAR FlowControlState
    )

/*++

Routine Description:

    The primitive sets or resets the local busy state of a single
    link station or all link stations of a sap.
    The routine also maintains the local busy user
    and local busy buffer states, that are returned in link station
    status query, because the IBM state machine support only one buffer
    busy state.


Arguments:

    pStation            - link station handle.
    FlowControlState    - new flow control command bits set for the link station.
                          The parameter is a bit field:
                            0       => Sets LOCAL_BUSY_USER state
                            0x80    => resets LOCAL_BUSY_USER state
                            0x40    => resets LOCAL_BUSY_BUFFER state
                            0xC0    => resets both local busy states

Return Value:

    STATUS_SUCCESS

--*/

{
    PDATA_LINK pLink;
    UINT Status = STATUS_SUCCESS;
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We must prevent any LLC object to be deleted, while we
    // are updating the flow control states
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    if (pStation->Gen.ObjectType != LLC_LINK_OBJECT) {
        if (pStation->Gen.ObjectType == LLC_SAP_OBJECT) {
            for (pLink = pStation->Sap.pActiveLinks;
                 pLink != NULL;
                 pLink = (PDATA_LINK)pLink->Gen.pNext) {
                Status |= LinkFlowControl(pLink, FlowControlState);
            }
        } else {
            Status = DLC_STATUS_INVALID_STATION_ID;
        }
    } else {
        Status = LinkFlowControl((PDATA_LINK)pStation, FlowControlState);
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    BackgroundProcess(pAdapterContext);
    return Status;
}


DLC_STATUS
LinkFlowControl(
    IN PDATA_LINK pLink,
    IN UCHAR FlowControlState
    )

/*++

Routine Description:

    The primitive sets or resets the local busy state for a
    single link.  The routine also maintains the local busy user
    and local busy buffer states.
    This level do not care about the interlocking.
    It is done  on the upper level.

Arguments:

    hStation            - link station handle.
    FlowControlState    - new flow control command bits set for the link station.

Return Value:

    STATUS_SUCCESS

--*/

{
    if ((FlowControlState & 0x80) == 0) {

        //
        // Bit5 is used as an undocumented flag, that sets
        // the link local busy buffer state.  We need this
        // in the DOS DLC emulation.
        //

        ACQUIRE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

        if (FlowControlState == LLC_SET_LOCAL_BUSY_BUFFER) {
            pLink->Flags |= DLC_LOCAL_BUSY_BUFFER;
        } else {
            pLink->Flags |= DLC_LOCAL_BUSY_USER;
        }

        RELEASE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

        return RunInterlockedStateMachineCommand(pLink, ENTER_LCL_Busy);
    } else {

        //
        // Optimize the buffer enabling, because RECEICE for a
        // SAP station should disable any non user busy states of
        // all link stations defined for sap (may take a long
        // time if a sap has very may links)
        //

        if (FlowControlState == LLC_RESET_LOCAL_BUSY_BUFFER) {
            FlowControlState = DLC_LOCAL_BUSY_BUFFER;
        } else {
            FlowControlState = DLC_LOCAL_BUSY_USER;
        }
        if (pLink->Flags & FlowControlState) {

            ACQUIRE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

            pLink->Flags &= ~FlowControlState;

            RELEASE_SPIN_LOCK(&pLink->Gen.pAdapterContext->SendSpinLock);

            if ((pLink->Flags & (DLC_LOCAL_BUSY_USER | DLC_LOCAL_BUSY_BUFFER)) == 0) {
                return RunInterlockedStateMachineCommand(pLink, EXIT_LCL_Busy);
            }
        } else {
            return DLC_STATUS_LINK_PROTOCOL_ERROR;
        }
    }
    return STATUS_SUCCESS;
}


#if LLC_DBG >= 2

PDATA_LINK
SearchLink(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    )
/*++

Routine Description:

    The routine searches a link from the hash table.
    All links in the same hash node has been saved to a simple
    link list.

    Note: the full link address is actually 61 bits long =
    7 (SSAP) + 7 (DSAP) + 47 (any non-broadcast source address).
    We save the address information into two ULONGs, that are used
    in the actual search. The hash key will be calculated by xoring
    all 8 bytes in the address.

Arguments:

    pAdapterContext - MAC adapter context of data link driver

    LanAddr - the complete 64 bit address of link (48 bit source addr + saps)

Return Value:
    PDATA_LINK - pointer to LLC link object or NULL if not found

--*/
{
    USHORT      usHash;
    PDATA_LINK  pLink;

    // this is a very simple hash algorithm, but result is modified
    // by all bits => it should be good enough for us.
    usHash =
        LanAddr.aus.Raw[0] ^ LanAddr.aus.Raw[1] ^
        LanAddr.aus.Raw[2] ^ LanAddr.aus.Raw[3];

    pLink =
        pAdapterContext->aLinkHash[
            ((((PUCHAR)&usHash)[0] ^ ((PUCHAR)&usHash)[1]) % LINK_HASH_SIZE)];

    //
    //  Search the first matching link in the link list.
    //
    while (pLink != NULL &&
           (pLink->LinkAddr.ul.Low != LanAddr.ul.Low ||
            pLink->LinkAddr.ul.High != LanAddr.ul.High))
    {
        pLink = pLink->pNextNode;
    }
    return pLink;
}
#endif

PDATA_LINK*
SearchLinkAddress(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    )

/*++

Routine Description:

    The routine searches the address of a link pointer in the hash table.
    All links in the same hash node has been saved to a simple
    link list.

    Note: the full link address is actually 61 bits long =
    7 (SSAP) + 7 (DSAP) + 47 (any non-broadcast source address).
    We save the address information into two ULONGs, that are used
    in the actual search. The hash key will be calculated by xoring
    all 8 bytes in the address.

Arguments:

    pAdapterContext - MAC adapter context of data link driver
    LanAddr         - the complete 64 bits address of link (48 bit source addr + saps)

Return Value:

    PDATA_LINK - pointer to LLC link object or NULL if not found

--*/

{
    USHORT usHash;
    PDATA_LINK *ppLink;

    //
    // this is a very simple hash algorithm, but result is modified
    // by all bits => it should be quite good enough
    //

    usHash = LanAddr.aus.Raw[0]
           ^ LanAddr.aus.Raw[1]
           ^ LanAddr.aus.Raw[2]
           ^ LanAddr.aus.Raw[3];

    ppLink = &pAdapterContext->aLinkHash[((((PUCHAR)&usHash)[0]
                                         ^ ((PUCHAR)&usHash)[1])
                                         % LINK_HASH_SIZE)];

    //
    // BUG-BUG-BUG Check, that the C- compliler produces optimal
    // dword compare for this.
    //

    while (*ppLink != NULL
    && ((*ppLink)->LinkAddr.ul.Low != LanAddr.ul.Low
    || (*ppLink)->LinkAddr.ul.High != LanAddr.ul.High)) {
        ppLink = &(*ppLink)->pNextNode;
    }
    return ppLink;
}

DLC_STATUS
SetLinkParameters(
    IN OUT PDATA_LINK pLink,
    IN PUCHAR pNewParameters
    )

/*++

Routine Description:

    Updates new parameters for a link station and reinitializes the
    timers and window counters.

Arguments:

    pLink           - LLC link station object
    pNewParameters  - new parameters set to a link station

Return Value:

    None.

--*/

{
    DLC_STATUS LlcStatus;
    USHORT MaxInfoField;

    CopyLinkParameters((PUCHAR)&pLink->TimerT1,
                       pNewParameters,
                       (PUCHAR)&pLink->pSap->DefaultParameters
                       );

    //
    // The application cannot set bigger information field than
    // supported by adapter and source routing bridges.
    //

    MaxInfoField = LlcGetMaxInfoField(pLink->Gen.pAdapterContext->NdisMedium,
                                      pLink->Gen.pLlcBinding,
                                      pLink->auchLanHeader
                                      );
    if (pLink->MaxIField > MaxInfoField) {
        pLink->MaxIField = MaxInfoField;
    }

    //
    // The initial transmit and receive window size (Ww) has
    // a fixed initial value, because it is dynamic, but we must
    // set  it always smaller than maxout.
    // The maxin value is fixed.  The dynamic management of N3
    // is not really worth of the effort.  By default, when it is
    // set to maximum 127, the sender searches the optimal window
    // size using the pool-bit.
    //

    pLink->N3 = pLink->RW;
    pLink->Ww = 16;          // 8 * 2;
    pLink->MaxOut *= 2;
    pLink->TW = pLink->MaxOut;
    if (pLink->TW < pLink->Ww) {
        pLink->Ww = pLink->TW;
    }
    LlcStatus = InitializeLinkTimers(pLink);
    return LlcStatus;
}

DLC_STATUS
CheckLinkParameters(
    PDLC_LINK_PARAMETERS pParms
    )

/*++

Routine Description:

    Procedure checks the new parameters to be set for a link and returns
    error status if any of them is invalid.

Arguments:

    pLink - LLC link station object

    pNewParameters - new parameters set to a link station

Return Value:

    None

--*/

{
    //
    // These maximum values have been defined in IBM LAN Tech-Ref
    //

    if (pParms->TimerT1 > 10
    || pParms->TimerT2 > 10
    || pParms->TimerTi > 10
    || pParms->MaxOut > 127
    || pParms->MaxIn > 127
    || pParms->TokenRingAccessPriority > 3) {
        return DLC_STATUS_PARMETERS_EXCEEDED_MAX;
    } else {
        return STATUS_SUCCESS;
    }
}

//
// Copies all non-null new link parameters, the default values are
// used when the new values are nul.  Used by SetLinkParameters and
// and SetInfo call of sap station.
//

VOID
CopyLinkParameters(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters
    )
{
    //
    // We must use the default value, if somebody has set nul.
    // All parameters are UCHARs => we can do the check for a byte stream
    //

    CopyNonZeroBytes(pOldParameters,
                     pNewParameters,
                     pDefaultParameters,
                     sizeof(DLC_LINK_PARAMETERS) - sizeof(USHORT)
                     );

    //
    // The information field is the only non-UCHAR value among the
    // link station parameters.
    //

    if (((PDLC_LINK_PARAMETERS)pNewParameters)->MaxInformationField != 0) {
        ((PDLC_LINK_PARAMETERS)pOldParameters)->MaxInformationField =
            ((PDLC_LINK_PARAMETERS)pNewParameters)->MaxInformationField;
    } else if (((PDLC_LINK_PARAMETERS)pOldParameters)->MaxInformationField == 0) {
        ((PDLC_LINK_PARAMETERS)pOldParameters)->MaxInformationField =
            ((PDLC_LINK_PARAMETERS)pDefaultParameters)->MaxInformationField;
    }
}


VOID
CopyNonZeroBytes(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters,
    IN UINT Length
    )

/*++

Routine Description:

    Copies and filters DLC parameter values. If the value is 0, the corresponding
    default is used, else the supplied value

Arguments:

    pOldParameters      - pointer to set of UCHAR values
    pNewParameters      - pointer to array of output values
    pDefaultParameters  - pointer to corresponding default values
    Length              - size of values in bytes (UCHARs)

Return Value:

    None.

--*/

{
    UINT i;

    for (i = 0; i < Length; i++) {
        if (pNewParameters[i] != 0) {
            pOldParameters[i] = pNewParameters[i];
        } else if (pOldParameters[i] == 0) {
            pOldParameters[i] = pDefaultParameters[i];
        }
    }
}


UINT
RunInterlockedStateMachineCommand(
    IN PDATA_LINK pStation,
    IN USHORT Command
    )

/*++

Routine Description:

    Runs the state machine for a link, within the adapter's SendSpinLock (&
    therefore at DPC)

Arguments:

    pStation    - pointer to DATA_LINK structure describing this link station
    Command     - state machine command to be run

Return Value:

    UINT
        Status from RunStateMachineCommand

--*/

{
    UINT Status;

    ACQUIRE_SPIN_LOCK(&pStation->Gen.pAdapterContext->SendSpinLock);

    Status = RunStateMachineCommand(pStation, Command);

    RELEASE_SPIN_LOCK(&pStation->Gen.pAdapterContext->SendSpinLock);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcaddr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcaddr.c

Abstract:

    This module provides a network independent interface to build
    lan headers for the sent and received frames.
    This is a re-entarnt library module having no access to the data
    structures of data link module.

    Contents:
        LlcBuildAddress
        LlcBuildAddressFromLanHeader
        LlcGetMaxInfoField
        LlcCopyReceivedLanHeader
        CopyLanHeader

Author:

    Antti Saarenheimo (o-anttis) 30-MAY-1991

Revision History:

--*/

#include <llc.h>

#define FDDI_FC 0x57    // Frame Control: async, 48-bit address, LLC, pri 7

static USHORT ausLongestFrameTranslation[8] = {
    516,
    1470,
    2052,
    4472,
    8144,
    11407,
    17800,
    17800
};


UINT
LlcBuildAddress(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR DestinationAddress,
    IN PVOID pSrcRouting,
    IN OUT PUCHAR pLanHeader
    )

/*++

Routine Description:

    The primitive implements a network independent handling of
    the address information in the LAN header. It builds LAN a
    802.3, DIX or 802.5 header from an address and an optional source
    routing info. The source SAP number and the current node address are
    provided by the link driver.

Arguments:

    NdisMedium          - medium that MAC talks over
    DestinationAddress  - LAN destination address (or a broadcast/multicast/
                          functional address).
    pSrcRouting         - optional source routing information. Must be set
                          NULL when not used.
    pLanHeader          - buffer provided by the upper protocol for the
                          address information of the frame header.

Return Value:

    length of the LAN header

--*/

{
    UCHAR SourceRoutingIndicator = 0x01;
    UINT minimumLanHeader = 14;

    if (NdisMedium == NdisMediumFddi) {
        pLanHeader[0] = FDDI_FC;
        ++pLanHeader;
        minimumLanHeader = 13;
    } else if (NdisMedium == NdisMedium802_5) {
        pLanHeader[0] = 0;          // DEFAULT_TR_ACCESS;
        pLanHeader[1] = 0x40;       // NON_MAC_FRAME;
        pLanHeader += 2;
        SourceRoutingIndicator = 0x80;
    } else {

        //
        // We build always the DIX ethernet header, even if it is not used
        // when the link works in 802.3.  IN the automatic mode
        // we need just to copy the lan header length from all received U-
        // command frames and we are using the same mode as the other side.
        // However, there is a problem: the remote node may response
        // the SAMBE request with Rxx or even with I-frame, but we
        // don't want to put any extra checking on our main code path
        // (U- command frames would definitely be outside of it).
        // The other side will send RR- if it cannot get any acknowledge
        // from us, and after a while it closes the link.
        //-----
        // We considered the using of connect timeout to change the
        // ethernet mode, but that might have procedured too long waithing
        // times (something 1s and 30s)
        //-----
        // Usually the client tries to connect to the host and the client
        // sends first the data.  We may also assume, that IBM host machines
        // use the standard LLC implementations (SABME is always acknowledged
        // by UA)
        //

        pLanHeader[12] = 0x80;
        pLanHeader[13] = 0xD5;
    }
    LlcMemCpy(pLanHeader, DestinationAddress, 6);

    //
    // We must support the source routing information also for
    // ethernet, because the underlaying network could be token-ring.
    // The source routing bit must be a local variable, because it
    // is different in token-ring and ethernet
    //

    if (!pSrcRouting) {
        pLanHeader[6] &= ~SourceRoutingIndicator;
        return minimumLanHeader;
    } else {
        pLanHeader[6] |= SourceRoutingIndicator;
        pLanHeader[0] &= ~SourceRoutingIndicator;

        //
        // 5 Lowest bits are the source routing information length.
        //

        if ( (*((PUCHAR)pSrcRouting) & 0x1f) > MAX_TR_SRC_ROUTING_INFO) {
            return DLC_STATUS_INVALID_ROUTING_INFO;
        }
        LlcMemCpy(&pLanHeader[12],
                  pSrcRouting,
                  *((PUCHAR)pSrcRouting) & 0x1f      // Length
                  );
        return minimumLanHeader + *((PUCHAR)pSrcRouting) & 0x1f;
    }
}


UINT
LlcBuildAddressFromLanHeader(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR pRcvLanHeader,
    IN OUT PUCHAR pLanHeader
    )

/*++

Routine Description:

    The routine builds a transmit lan header form the received frame and
    returns the frames header length, nul if invalid address

Arguments:

    NdisMedium      - Ndis menium of the address information
    pRcvFrameHeader - pointer to any frame received from the network.
                      The buffer must include the whole LAN header of the frame
                      including the LLC header.
    pLanHeader      - buffer to receive the information (minimum size is 32 bytes)

Return Value:

    None

--*/

{
    UINT LlcOffset;

    if (NdisMedium == NdisMedium802_3) {

#ifndef SUPPORT_ETHERNET_CLIENT

        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[6],
                                    NULL,
                                    pLanHeader
                                    );

#else

        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[6],
                                    (pRcvLanHeader[6] & 0x01)
                                        ? &pRcvLanHeader[12]
                                        : NULL,
                                    pLanHeader
                                    );

        //
        // We must swap the direction bit and reset the possible
        // broadcast type in the source routing header.
        //

        if (pLanHeader[6] & 0x01) {
            pLanHeader[12] &= 0x1f;
            pLanHeader[13] ^= 0x80;
        }

#endif

    } else if (NdisMedium == NdisMediumFddi) {
        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[7],
                                    NULL,   // no source routing in FDDI
                                    pLanHeader
                                    );
    } else {
        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[8],
                                    (pRcvLanHeader[8] & 0x80)
                                        ? &pRcvLanHeader[14]
                                        : NULL,
                                    pLanHeader
                                    );

        //
        // We must swap the direction bit and reset the possible broadcast type
        //

        if (pLanHeader[8] & 0x80) {
            pLanHeader[14] &= 0x1f;
            pLanHeader[15] ^= 0x80;
        }
    }
    return LlcOffset;
}


USHORT
LlcGetMaxInfoField(
    IN NDIS_MEDIUM NdisMedium,
    IN PVOID hBinding,
    IN PUCHAR pLanHeader
    )

/*++

Routine Description:

    Procedure returns the maximum informatiuon field for
    the given LAN header.  It checks both the source routing
    information and the maximum packet length defined for
    the adapter and decrements the LAN and LLC headers
    from the length

Arguments:

    NdisMedium  - Ndis medium of the address information
    pBinding    - current binding context on data link driver
    pLanHeader  - any lan header

Return Value:

    Maximum information field length

--*/

{
    PUCHAR pSourceRouting;
    UCHAR LanHeaderLength = 14;
    USHORT MaxFrameSize;
    USHORT usMaxBridgeSize;

    MaxFrameSize = (USHORT)((PBINDING_CONTEXT)hBinding)->pAdapterContext->MaxFrameSize;

    //
    // We may run DLC within the DIX in ethernet network, so add 3 bytes for
    // SNA DIX LAN header and padding
    //

    if (((PBINDING_CONTEXT)hBinding)->pAdapterContext->NdisMedium == NdisMedium802_3) {
        LanHeaderLength += 3;
    }

    pSourceRouting = NULL;
    if (NdisMedium == NdisMedium802_5) {
        if (pLanHeader[8] & 0x80) {
            pSourceRouting = pLanHeader + 14;
        }
    } else if (NdisMedium == NdisMediumFddi) {
        if (pLanHeader[6] & 0x80) {
            pSourceRouting = pLanHeader + 13;
        }
    } else {
        if (pLanHeader[6] & 0x01) {
            pSourceRouting = pLanHeader + 12;
        }
    }
    if (pSourceRouting != NULL) {

        //
        // Add the source routing info length to the LAN header length
        //

        LanHeaderLength += (UCHAR)(*pSourceRouting & (UCHAR)0x1f);
        usMaxBridgeSize = ausLongestFrameTranslation[(pSourceRouting[1] & SRC_ROUTING_LF_MASK) >> 4];

        //
        // RLF 10/01/92. Ignore the 'bridge size'. This is misleading. For
        // instance, the IBM mainframe is currently sending RI of 02 80 in
        // all frames, indicating that the max I-frame it can accept/transmit
        // is 516 bytes (x000xxxx in byte #2). It later sends us a 712 byte
        // frame, 683 bytes of which are info field. We reject it (FRMR)
        //

        //
        // must work this out properly
        //

        //if (MaxFrameSize > usMaxBridgeSize) {
        //    MaxFrameSize = usMaxBridgeSize;
        //}
    }
    return (USHORT)(MaxFrameSize - LanHeaderLength - sizeof(LLC_HEADER));
}


UINT
LlcCopyReceivedLanHeader(
    IN PBINDING_CONTEXT pBinding,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    )

/*++

Routine Description:

    Function copies and translates the received lan header to
    the address format used by the client.  By default the
    source is the current received frame.

Arguments:

    pBinding            - pointer to Binding Context
    DestinationAddress  - pointer to output destination net address
    SourceAddress       - pointer to input source net address

Return Value:

    Length of copied LAN header

--*/

{
    if (SourceAddress == NULL) {
        SourceAddress = pBinding->pAdapterContext->pHeadBuf;
    }
    if (pBinding->pAdapterContext->FrameType == LLC_DIRECT_ETHERNET_TYPE) {

        //
        // when receiving a DIX frame, the LAN header is always the 12 bytes
        // before the ethernet type field
        //

        LlcMemCpy(DestinationAddress, SourceAddress, 12);
        return 12;
    } else {

        UCHAR LanHeaderLength = 14;

        switch (pBinding->AddressTranslation) {
        case LLC_SEND_802_5_TO_802_5:

            //
            // Copy also the source routing info, if it has been defined
            //

            LlcMemCpy(DestinationAddress,
                      SourceAddress,
                      (SourceAddress[8] & 0x80)
                        ? LanHeaderLength + (SourceAddress[14] & 0x1f)
                        : LanHeaderLength
                      );
            break;

        case LLC_SEND_802_5_TO_802_3:
        case LLC_SEND_802_5_TO_DIX:
            DestinationAddress[0] = 0;          // default AC
            DestinationAddress[1] = 0x40;       // default frame type: non-MAC

            //
            // RLF 03/31/93
            //
            // we are receiving an Ethernet frame. We always reverse the bits
            // in the destination address (ie our node address). We reverse the
            // source (sender's node address) based on the SwapAddressBits flag.
            // If this is TRUE (default) then we also swap the source address
            // bits so that ethernet addresses are presented to the app in
            // standard non-canonical format. If SwapAddressBits is FALSE then
            // we leave them in canonical format (a real ethernet address) or
            // presumably the address is a Token Ring address from the other
            // side of an ethernet-token ring bridge
            //

            SwappingMemCpy(&DestinationAddress[2],
                           SourceAddress,
                           6
                           );
            SwapMemCpy(pBinding->pAdapterContext->ConfigInfo.SwapAddressBits,
                       &DestinationAddress[8],
                       SourceAddress+6,
                       6
                       );
            break;

        case LLC_SEND_802_5_TO_FDDI:
            DestinationAddress[0] = 0;
            DestinationAddress[1] = 0x40;
            SwappingMemCpy(&DestinationAddress[2],
                           SourceAddress+1,
                           6
                           );
            SwapMemCpy(pBinding->pAdapterContext->ConfigInfo.SwapAddressBits,
                       &DestinationAddress[8],
                       SourceAddress+7,
                       6
                       );
            break;

#ifdef SUPPORT_ETHERNET_CLIENT
        case LLC_SEND_802_3_TO_802_3:
        case LLC_SEND_802_3_TO_DIX:
            LlcMemCpy(DestinationAddress, SourceAddress, LanHeaderLength);
            break;

        case LLC_SEND_802_3_TO_802_5:

            //
            // check the source routing bit
            //

            SwappingMemCpy(DestinationAddress, &SourceAddress[2], 12);

            if (SourceAddress[8] & 0x80) {
                LanHeaderLength += SourceAddress[14] & 0x1f;
                LlcMemCpy(&DestinationAddress[12],
                          &SourceAddress[14],
                          SourceAddress[14] & 0x1f
                          );
            }
            break;
#endif

        case LLC_SEND_FDDI_TO_FDDI:
            DestinationAddress[0] = FDDI_FC;
            LlcMemCpy(DestinationAddress+1, SourceAddress, 12);
            return 13;

#if LLC_DBG
        default:
            LlcInvalidObjectType();
            break;
#endif

        }
        return LanHeaderLength;
    }
}


UCHAR
CopyLanHeader(
    IN UINT AddressTranslationMode,
    IN PUCHAR pSrcLanHeader,
    IN PUCHAR pNodeAddress,
    OUT PUCHAR pDestLanHeader,
    IN BOOLEAN SwapAddressBits
    )

/*++

Routine Description:

    The primitive translates the given LAN header and its type to
    a real network header and patches the local node address to
    the source address field.  It also returns the length
    of the LAN header (== offset of LLC header).

Arguments:

    AddressTranslationMode  - the network format mapping case
    pSrcLanHeader           - the initial LAN header
    pNodeAddress            - the current node address
    pDestLanHeader          - storage for the new LAN header
    SwapAddressBits         - TRUE if we will swap address bits for Ethernet/FDDI

Return Value:

    Length of the built network header

--*/

{
    UCHAR LlcOffset = 14;
    UCHAR NodeAddressOffset = 6;
    UCHAR SourceRoutingFlag = 0;

    //
    // LLC driver API supports both 802.3 (ethernet) and 802.5 (token-ring)
    // address presentation formats. The 802.3 header may include the source
    // routing information, when it is used on token-ring.
    //
    // Internally LLC supports 802.3, DIX and 802.5 networks.
    // The transport level driver needs to support only one format. It is
    // translated to the actual network header by LLC.
    // Thus we have these six address mappings.
    //

    switch (AddressTranslationMode) {
    case LLC_SEND_802_5_TO_802_5:

        //
        // TOKEN-RING 802.5 -> TOKEN-RING 802.5
        //

        NodeAddressOffset = 8;
        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 8);

        //
        // set the AC & FC bytes: FC = 0x40 == LLC-level frame
        //
        // THIS MAY NOT BE THE CORRECT PLACE TO DO THIS, UNLESS MAC
        // LEVEL FRAMES CHANGE FC BACK TO 0x00 AFTER THIS ROUTINE AND
        // BEFORE THE FRAME IS PUT ON THE WIRE
        //

        pDestLanHeader[0] = 0;      // AC = no pritority
        pDestLanHeader[1] = 0x40;   // FS = Non-MAC
        SourceRoutingFlag = pSrcLanHeader[8] & (UCHAR)0x80;
        if (SourceRoutingFlag) {

            //
            // Copy the source routing info
            //

            LlcOffset += pSrcLanHeader[14] & 0x1f;
            LlcMemCpy(&pDestLanHeader[14],
                      &pSrcLanHeader[14],
                      pSrcLanHeader[14] & 0x1f
                      );
        }
        break;

    case LLC_SEND_802_5_TO_DIX:

        //
        // TOKEN-RING -> DIX-ETHERNET
        //
        // The ethernet type is a small endiand!!
        //

        pDestLanHeader[12] = 0x80;
        pDestLanHeader[13] = 0xD5;
        LlcOffset = 17;

        //
        // **** FALL THROUGH ****
        //

    case LLC_SEND_802_5_TO_802_3:

        //
        // TOKEN-RING 802.5 -> ETHERNET 802.3
        //

        //
        // RLF 03/31/93
        //
        // Once again, we swap the bits in the destination address ONLY if the
        // SwapAddressBits flag is TRUE.
        // This *could* be a frame intended to go to an ethernet-token ring
        // bridge. The bridge may or may not swap the destination address bits
        // depending on whether there's a 'y' in the month
        //

        SwapMemCpy(SwapAddressBits,
                   pDestLanHeader,
                   &pSrcLanHeader[2],
                   6
                   );
        break;

    case LLC_SEND_802_5_TO_FDDI:
        pDestLanHeader[0] = FDDI_FC;
        SwapMemCpy(SwapAddressBits, pDestLanHeader+1, &pSrcLanHeader[2], 6);
        NodeAddressOffset = 7;
        LlcOffset = 13;
        break;

    case LLC_SEND_DIX_TO_DIX:
        LlcOffset = 12;

    case LLC_SEND_802_3_TO_802_3:

        //
        // ETHERNET 802.3 -> ETHERNET 802.3
        //

        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 6);
        break;

    case LLC_SEND_802_3_TO_DIX:

        //
        // The ethernet type is a small endiand!!
        //

        pDestLanHeader[12] = 0x80;
        pDestLanHeader[13] = 0xD5;
        LlcOffset = 17;

        //
        // ETHERNET 802.3 -> DIX-ETHERNET
        //

        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 6);
        break;

#ifdef SUPPORT_ETHERNET_CLIENT

    case LLC_SEND_802_3_TO_802_5:

        //
        // ETHERNET 802.3 -> TOKEN-RING 802.5
        //

        NodeAddressOffset = 8;
        pDestLanHeader[0] = 0;      // AC = no pritority
        pDestLanHeader[1] = 0x40;   // FS = Non-MAC
        SwappingMemCpy(pDestLanHeader + 2, pSrcLanHeader, 6);

        //
        // Note: Ethernet source routing info indication flag is swapped!
        //

        if (pSrcLanHeader[6] & 0x01) {
            SourceRoutingFlag = 0x80;

            //
            // Copy the source routing info, the source routing info
            // must always be in token-ring bit order (reverse)
            //

            pDestLanHeader[8] |= 0x80;
            LlcOffset += pSrcLanHeader[12] & 0x1f;
            LlcMemCpy(&pDestLanHeader[14],
                      &pSrcLanHeader[12],
                      pSrcLanHeader[12] & 0x1f
                      );
        }
        break;
#endif

    case LLC_SEND_UNMODIFIED:
        return 0;
        break;

    case LLC_SEND_FDDI_TO_FDDI:
        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 7);
        NodeAddressOffset = 7;
        LlcOffset = 13;
        break;

    case LLC_SEND_FDDI_TO_802_5:
        break;

    case LLC_SEND_FDDI_TO_802_3:
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif

    }

    //
    // copy the source address from the node address (ie. our adapter's address)
    // in the correct format for the medium (canonical or non-canonical address
    // format)
    //

    LlcMemCpy(&pDestLanHeader[NodeAddressOffset], pNodeAddress, 6);
    pDestLanHeader[NodeAddressOffset] |= SourceRoutingFlag;

    return LlcOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcext.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlext.h

Abstract:

    This module includes all internal function prototypes
    and external global variables.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

//
// External variables:
//

extern DLC_LINK_PARAMETERS DefaultParameters;
extern UCHAR auchLlcCommands[];
extern UCHAR Swap[];
extern LLC_TICKS TimerTicks;
extern ULONG AbsoluteTime;
extern BOOLEAN TraceEnabled;
extern LLC_XID_INFORMATION Ieee802Xid;
extern PMDL pXidMdl;
extern KSPIN_LOCK LlcSpinLock;
extern PVOID LlcProtocolHandle;
extern NDIS_PROTOCOL_CHARACTERISTICS LlcCharacteristics;
extern KMUTEX NdisAccessMutex;
extern KSEMAPHORE OpenAdapterSemaphore;
extern UINT NdisSendCount;
extern PADAPTER_CONTEXT pAdapters;
extern UCHAR PrimaryStates[];
extern UCHAR SecondaryStates[];
#ifdef NDIS40
extern NDIS_EVENT PnPBindsComplete;
#endif // NDIS40

UINT
CopyReceivedLanHeader(
    IN UINT TransltionCase,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    );

UCHAR
CopyLanHeader(
    IN UINT AddressTranslationMode,
    IN PUCHAR pSrcLanHeader,
    IN PUCHAR pNodeAddress,
    OUT PUCHAR pDestLanHeader,
    IN BOOLEAN SwapAddressBits
    );

VOID
SwappingMemCpy(
    IN PUCHAR pDest,
    IN PUCHAR pSrc,
    IN UINT Len
    );

UINT
RunStateMachine(
    IN OUT PDATA_LINK pLink,
    IN USHORT usInput,
    IN BOOLEAN boolPollFinal,
    IN BOOLEAN boolResponse
    );

UINT
RunInterlockedStateMachineCommand(
    PDATA_LINK pStation,
    USHORT Command
    );

VOID
SaveStatusChangeEvent(
    IN PDATA_LINK pLink,
    IN PUCHAR puchLlcHdr,
    IN BOOLEAN boolResponse
    );

VOID
ResendPackets(
    IN OUT PDATA_LINK pLink    // data link strcuture
    );

VOID
UpdateVa(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    );

VOID
UpdateVaChkpt(
    IN OUT PDATA_LINK pLink     // data link station strcuture
    );

VOID
AdjustWw(
    IN OUT PDATA_LINK pLink    // data link strcuture
    );

VOID
SendAck(
    IN OUT PDATA_LINK pLink
    );

UINT
RunStateMachineCommand(
    IN OUT PVOID hLink,
    IN UINT uiInput
    );

PDATA_LINK
SearchLink(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    );

PDATA_LINK *
SearchLinkAddress(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    );

DLC_STATUS
SetLinkParameters(
    IN OUT PDATA_LINK pLink,
    IN PUCHAR pNewParameters
    );

DLC_STATUS
CheckLinkParameters(
    PDLC_LINK_PARAMETERS pParms
    );

VOID
CopyLinkParameters(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters
    );

VOID
CompleteClose(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status
    );

NDIS_STATUS
InitNdisPackets(
    OUT PLLC_NDIS_PACKET * ppLlcPacketPool,
    IN NDIS_HANDLE hNdisPool
    );

VOID
LlcResetPacket(
    IN OUT PLLC_NDIS_PACKET pNdisPacket
    );

NDIS_STATUS
GetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID NdisOid,
    IN PVOID pDataAddress,
    IN UINT DataSize
    );

DLC_STATUS
SyncNdisRequest(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_REQUEST pRequest
    );

NDIS_STATUS
WaitAsyncOperation(
    IN PKEVENT pEvent,
    IN PNDIS_STATUS pAsyncStatus,
    IN NDIS_STATUS Status
    );

#ifdef LLC_PRIVATE_NDIS_PROTOTYPES

NDIS_STATUS
LlcNdisReceiveIndication (
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID pHeadBuf,
    IN UINT cbHeadBuf,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf,
    IN UINT cbPacketSize
    );

VOID
LlcNdisSendComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisReceiveComplete(
    IN PADAPTER_CONTEXT pAdapterContext
    );

VOID
LlcNdisTransferDataComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT uiBytesTransferred
    );

VOID
LlcNdisOpenAdapterComplete(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    );

VOID
LlcNdisCloseComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisRequestComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisResetComplete(
    PADAPTER_CONTEXT pAdapterContext,
    NDIS_STATUS NdisStatus
    );

VOID
NdisStatusHandler(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

#else

VOID
NdisStatusHandler(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

VOID
LlcNdisTransferDataComplete(
    IN PVOID hAdapterContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS NdisStatus,
    IN UINT uiBytesTransferred
    );

VOID
LlcNdisRequestComplete(
    IN PVOID hAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisOpenAdapterComplete(
    PVOID hAdapterContext,
    NDIS_STATUS NdisStatus,
    NDIS_STATUS OpenErrorStatus
    );

VOID
LlcNdisStatus(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS Status,
    IN UINT SpecificStatus
    );

VOID
LlcNdisStatusComplete(
    IN PVOID hAdapterContext
    );

NDIS_STATUS
LlcNdisReceiveIndication (
    IN PVOID pAdapterContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID pHeadBuf,
    IN UINT cbHeadBuf,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf,
    IN UINT cbPacketSize
    );

VOID
LlcNdisSendComplete(
    IN PVOID hAdapter,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisResetComplete(
    PVOID hAdapterContext,
    NDIS_STATUS NdisStatus
    );

VOID
LlcNdisCloseComplete(
    PVOID hAdapterContext,
    NDIS_STATUS NdisStatus
    );

VOID
LlcNdisReceiveComplete(
    IN PVOID hAdapter
    );

#ifdef NDIS40
VOID
LlcBindAdapterHandler(
    OUT PNDIS_STATUS  pStatus,
    IN  NDIS_HANDLE   BindContext,
    IN  PNDIS_STRING  pDeviceName,
    IN  PVOID         SystemSpecific1,
    IN  PVOID         SystemSpecific2
    );

VOID
LlcUnbindAdapterHandler(
    OUT PNDIS_STATUS pStatus,
    IN  NDIS_HANDLE  ProtocolBindingContext,
    IN  NDIS_HANDLE  UnbindContext
    );

NDIS_STATUS
LlcPnPEventHandler(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          pNetPnPEvent
    );

VOID
CloseAllAdapters();

#endif // NDIS40


#endif

VOID
ProcessType1_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    );

VOID
MakeRcvIndication(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_OBJECT pStation
    );

VOID
ProcessType2_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN OUT PDATA_LINK pLink,
    IN LLC_HEADER LlcHeader
    );

VOID
ProcessNewSabme(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    );

VOID
SaveReceiveEvent(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_TRANSFER_PACKET pTransferPacket
    );

VOID
RunSendTaskAndUnlock(
    IN PADAPTER_CONTEXT pAdapterContext
    );

VOID
BackgroundProcessAndUnlock(
    IN PADAPTER_CONTEXT pAdapter
    );

VOID
BackgroundProcess(
    IN PADAPTER_CONTEXT pAdapter
    );

PLLC_PACKET
GetI_Packet(
    IN PADAPTER_CONTEXT pAdapter
    );

VOID
StartSendProcess(
    IN PADAPTER_CONTEXT pAdapter,
    IN PDATA_LINK pLink
    );

VOID
EnableSendProcess(
    IN PDATA_LINK pLink
    );

VOID
StopSendProcess(
    IN PADAPTER_CONTEXT pAdapter,
    IN PDATA_LINK pLink
    );

VOID DisableSendProcess(
    IN PDATA_LINK pLink
    );

PLLC_PACKET
BuildDirOrU_Packet(
    PADAPTER_CONTEXT pAdapter
    );

DLC_STATUS
SendLlcFrame(
    IN PDATA_LINK pLink,
    IN UCHAR LlcCommandId
    );

PLLC_PACKET
GetLlcCommandPacket(
    PADAPTER_CONTEXT pAdapter
    );

VOID
SendNdisPacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_PACKET pPacket
    );

VOID
CompleteSendAndLock(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    );

VOID
RespondTestOrXid(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN LLC_HEADER LlcHeader,
    IN UINT SourceSap
    );

VOID
CopyNonZeroBytes(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters,
    IN UINT Length
    );

VOID
ScanTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
TerminateTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_TIMER pTimer
    );

DLC_STATUS
InitializeLinkTimers(
    IN OUT PDATA_LINK pLink
    );

DLC_STATUS
InitializeTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    PLLC_TIMER pTimer,
    UCHAR TickCount,
    UCHAR TickOne,
    UCHAR TickTwo,
    UINT Input,
    PVOID hContextHandle,
    UINT DefaultDelay,
    IN BOOLEAN StartNewTimer
    );

VOID
StartTimer(
    IN PLLC_TIMER pTimer
    );

BOOLEAN
StopTimer(
    IN PLLC_TIMER pTimer
    );

VOID
SwapMemCpy(
    IN BOOLEAN SwapBytes,
    IN PUCHAR pDest,
    IN PUCHAR pSrc,
    IN UINT Len
    );

VOID
LlcSleep(
    IN LONG lMicroSeconds
    );

DLC_STATUS
LlcInitUnicodeString(
    IN PUNICODE_STRING pStringDest,
    IN PUNICODE_STRING pStringSrc
    );

VOID
LlcFreeUnicodeString(
    IN PUNICODE_STRING UnicodeString
    );

VOID
InitiateAsyncLinkCommand(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket,
    UINT StateMachineCommand,
    UINT CompletionCode
    );

VOID
AllocateCompletionPacket(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN PVOID pPacket
    );

VOID
QueueCommandCompletion(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN UINT Status
    );

DLC_STATUS
LinkFlowControl(
    IN PDATA_LINK pLink,
    IN UCHAR FlowControlState
    );

VOID
LlcInitializeTimerSystem(
    VOID
    );

VOID
LlcTerminateTimerSystem(
    VOID
    );

VOID
ExecuteAllBackroundProcesses(
    VOID
    );

DLC_STATUS
UpdateFunctionalAddress(
    IN PADAPTER_CONTEXT pAdapter
    );

DLC_STATUS
UpdateGroupAddress(
    IN PADAPTER_CONTEXT pAdapter,
    IN PBINDING_CONTEXT pBindingContext
    );

NDIS_STATUS
SetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID pRequestInfo,
    IN UINT RequestLength
    );

VOID
CancelTransmitCommands(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status
    );

VOID
CancelTransmitsInQueue(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status,
    IN PLIST_ENTRY pQueue,
    IN PLLC_QUEUE pLlcQueue
    );

VOID
LlcNdis30RequestComplete(
    IN PVOID hAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_REQUEST_TYPE RequestType,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdis30TransferDataComplete(
    IN PVOID pAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    );

VOID
CompletePendingLlcCommand(
    PLLC_OBJECT pLlcObject
    );

DLC_STATUS
CheckAndDuplicatePacket(
#if DBG
    IN PADAPTER_CONTEXT pAdapterContext,
#endif
    IN PBINDING_CONTEXT pBinding,
    IN PLLC_PACKET pPacket,
    IN PLLC_QUEUE pQueue
    );

VOID
QueuePacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_QUEUE pQueue,
    IN PLLC_PACKET pPacket
    );

VOID
PrintLastInputs(
    IN PUCHAR pszMessage,
    IN PDATA_LINK pLink
    );

VOID
BackgroundProcessWithinLock(
    IN PADAPTER_CONTEXT pAdapterContext
    );


#ifdef LLC_PRIVATE_PROTOTYPES

//
// LLCADDR.C...
//

UINT
LlcCopyReceivedLanHeader(
    IN PBINDING_CONTEXT pBinding,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    );

//
// LLCLINK.C...
//

DLC_STATUS
LlcOpenLinkStation(
    IN PLLC_SAP pSap,
    IN UCHAR DestinationSap,
    IN PUCHAR pDestinationAddress OPTIONAL,
    IN PUCHAR pReceivedLanHeader OPTIONAL,
    IN PVOID hClientStation,
    OUT PVOID *phLlcHandle
    );

VOID
LlcBindLinkStation(
    IN PDATA_LINK pStation,
    IN PVOID hClientHandle
    );

VOID
LlcConnectStation(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket,
    IN PVOID pSourceRouting OPTIONAL,
    IN PUSHORT pusMaxInformationField
    );

VOID
LlcDisconnectStation(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket
    );

DLC_STATUS
LlcFlowControl(
    IN PLLC_OBJECT pStation,
    IN UCHAR FlowControlState
    );

DLC_STATUS
LlcResetBroadcastAddresses(
    IN PBINDING_CONTEXT pBindingContext
    );

//
// LLCNDIS.C...
//

VOID
LlcDisableAdapter(
    IN PBINDING_CONTEXT pBindingContext
    );

DLC_STATUS
LlcCloseAdapter(
    IN PBINDING_CONTEXT pBindingContext,
    IN BOOLEAN CloseAtNdisLevel
    );

VOID
LlcNdisReset(
    IN PBINDING_CONTEXT pBindingContext,
    IN PLLC_PACKET pPacket
    );

//
// LLCOBJ.C...
//

DLC_STATUS
LlcOpenStation(
    IN PBINDING_CONTEXT pBindingContext,
    IN PVOID hClientHandle,
    IN USHORT ObjectAddress,
    IN UCHAR ObjectType,
    IN USHORT OpenOptions,
    OUT PVOID* phStation
    );

DLC_STATUS
LlcCloseStation(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pCompletionPacket
    );

VOID
CompleteObjectDelete(
    IN PLLC_OBJECT pStation
    );

VOID
LlcSetDirectOpenOptions(
    IN PLLC_OBJECT pDirect,
    IN USHORT OpenOptions
    );

//
// LLCRCV.C...
//

VOID
LlcTransferData(
    IN PBINDING_CONTEXT pBindingContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_PACKET pPacket,
    IN PMDL pMdl,
    IN UINT uiCopyOffset,
    IN UINT cbCopyLength
    );

//
// LLCSEND.C...
//

VOID
LlcSendI(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket
    );

VOID
LlcSendU(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pPacket,
    IN UINT eFrameType,
    IN UINT uDestinationSap
    );

#else

//
// LLCADDR.C...
//

UINT
LlcCopyReceivedLanHeader(
    IN PVOID pBinding,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    );

//
// LLCLINK.C...
//

DLC_STATUS
LlcOpenLinkStation(
    IN PVOID pSap,
    IN UCHAR DestinationSap,
    IN PUCHAR pDestinationAddress OPTIONAL,
    IN PUCHAR pReceivedLanHeader OPTIONAL,
    IN PVOID hClientStation,
    OUT PVOID *phLlcHandle
    );

VOID
LlcBindLinkStation(
    IN PVOID pStation,
    IN PVOID hClientHandle
    );

VOID
LlcConnectStation(
    IN PVOID pStation,
    IN PLLC_PACKET pPacket,
    IN PVOID pSourceRouting OPTIONAL,
    IN PUSHORT pusMaxInformationField
    );

VOID
LlcDisconnectStation(
    IN PVOID pLink,
    IN PLLC_PACKET pPacket
    );

DLC_STATUS
LlcFlowControl(
    IN PVOID pStation,
    IN UCHAR FlowControlState
    );

DLC_STATUS
LlcResetBroadcastAddresses(
    IN PVOID pBindingContext
    );

//
// LLCNDIS.C...
//

VOID
LlcDisableAdapter(
    IN PVOID pBindingContext
    );


DLC_STATUS
LlcCloseAdapter(
    IN PVOID pBindingContext,
    IN BOOLEAN CloseAtNdisLevel
    );

VOID
LlcNdisReset(
    IN PVOID pBindingContext,
    IN PLLC_PACKET pPacket
    );

//
// LLCOBJ.C...
//

DLC_STATUS
LlcOpenStation(
    IN PVOID pBindingContext,
    IN PVOID hClientHandle,
    IN USHORT ObjectAddress,
    IN UCHAR ObjectType,
    IN USHORT OpenOptions,
    OUT PVOID* phStation
    );

DLC_STATUS
LlcCloseStation(
    IN PVOID pStation,
    IN PLLC_PACKET pCompletionPacket
    );

VOID
CompleteObjectDelete(
    IN PVOID pStation
    );

VOID
LlcSetDirectOpenOptions(
    IN PVOID pDirect,
    IN USHORT OpenOptions
    );

//
// LLCRCV.C...
//
VOID
LlcTransferData(
    IN PBINDING_CONTEXT pBindingContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_PACKET pPacket,
    IN PMDL pMdl,
    IN UINT uiCopyOffset,
    IN UINT cbCopyLength
    );

//
// LLCSEND.C...
//

VOID
LlcSendI(
    IN PVOID pStation,
    IN PLLC_PACKET pPacket
    );

VOID
LlcSendU(
    IN PVOID pStation,
    IN PLLC_PACKET pPacket,
    IN UINT eFrameType,
    IN UINT uDestinationSap
    );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcmac.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlmacro.h

Abstract:

    This module all c- macros of 802.2 data link driver.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

//
//  This routine just swaps the bits within bytes of
//  a network address, used only for a fast address
//  swapping to ethernet frame
//        
#define SwapCopy6( a, b )   (a)[0]=Swap[(b)[0]];\
                            (a)[1]=Swap[(b)[1]];\
                            (a)[2]=Swap[(b)[2]];\
                            (a)[3]=Swap[(b)[3]];\
                            (a)[4]=Swap[(b)[4]];\
                            (a)[5]=Swap[(b)[5]]


//
//  Copies and swaps the memory unconditionally
//
//VOID
//SwappingMemCpy(
//    IN PUCHAR pDest,
//    IN PUCHAR pSrc,
//    IN UINT Len 
//    )
//
#define SwappingMemCpy( pDest, pSrc, Len ) {\
    UINT i; \
    for (i = 0; i < Len; i++) \
        ((PUCHAR)pDest)[i] = Swap[ ((PUCHAR)pSrc)[i] ]; \
}

/*++

VOID
LlcResetPacket( 
    IN OUT PLLC_NDIS_PACKET pNdisPacket
    )

Routine Description: 

    Function rets the private partion of a NDIS packet.

Arguments: 

    pNdisPacket - 
        
Return Value:

    None

--*/
#define ResetNdisPacket( pNdisPacket ) { \
    (pNdisPacket)->private.PhysicalCount = 0;\
    (pNdisPacket)->private.TotalLength = 0;\
    (pNdisPacket)->private.Head = 0;\
    (pNdisPacket)->private.Tail = 0;\
    (pNdisPacket)->private.Count = 0;\
    }


/*++

AllocateCompletionPacket( 
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN PLLC_PACKET pPacket
    )

Routine Description:

    The function inserts and initializes a command completion packet 
    of an asynchronous command.

Arguments:

    pLlcObject - LLC object (link, sap or direct)

    CompletionCode - command completion code returned to upper protocol

Return Value:
    
    STATUS_SUCCESS
    DLC_STATUS_NO_MEMORY

--*/
#define AllocateCompletionPacket( pLlcObject, CompletionCode, pPacket ) {\
    pPacket->pBinding = pLlcObject->Gen.pLlcBinding; \
    pPacket->Data.Completion.CompletedCommand = (UCHAR)CompletionCode; \
    pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle; \
    pPacket->pNext = pLlcObject->Gen.pCompletionPackets; \
    pLlcObject->Gen.pCompletionPackets = pPacket; \
    }


#define RunStateMachineCommand( pLink, uiInput ) \
            RunStateMachine( (PDATA_LINK)pLink, (USHORT)uiInput, 0, 0 )



//
//  VOID
//  ScheduleQueue( 
//      IN PLIST_ENTRY ListHead 
//      );
//
//  The macro swaps the list element from the head to the tail 
//  if there are more than one element in the list.
//

#define ScheduleQueue( ListHead ) \
    if ((ListHead)->Blink != (ListHead)->Flink) \
    { \
        PLIST_ENTRY  pListEntry; \
        pListEntry = LlcRemoveHeadList( (ListHead) ); \
        LlcInsertTailList( (ListHead), pListEntry ); \
    }


#define ReferenceObject( pStation ) (pStation)->Gen.ReferenceCount++

//
//  We have made the most common functions macroes to
//  make the main code path as fast as possible. 
//  With the debug switch we use their local versions.
//
#if LLC_DBG >= 2

#define SEARCH_LINK( pAdapterContext, LanAddr, pLink ) \
            pLink = SearchLink( pAdapterContext, LanAddr )

#else

/*++

SEARCH_LINK(
    IN PADAPTER_CONTEXT pAdapterContext, 
    IN LAN802_ADDRESS LanAddr,
    IN PDATA_LINK pLink
    )
Routine Description:

    The routine searches a link from the hash table. 
    All links in the same hash node has been saved to a simple
    link list. 
    
    Note: the full link address is actually 61 bits long =
    7 (SSAP) + 7 (DSAP) + 47 (any non-broadcast source address).
    We save the address information into two ULONGs, that are used
    in the actual search. The hash key will be calculated by xoring
    all 8 bytes in the address.
    
Arguments:

    pAdapterContext - MAC adapter context of data link driver

    LanAddr - the complete 64 bit address of link (48 bit source addr + saps)

Return Value:
    PDATA_LINK - pointer to LLC link object or NULL if not found

--*/
#define SEARCH_LINK( pAdapterContext, LanAddr, pLink )\
{ \
    USHORT      usHash; \
    usHash = \
        LanAddr.aus.Raw[0] ^ LanAddr.aus.Raw[1] ^ \
        LanAddr.aus.Raw[2] ^ LanAddr.aus.Raw[3]; \
    pLink = \
        pAdapterContext->aLinkHash[ \
            ((((PUCHAR)&usHash)[0] ^ ((PUCHAR)&usHash)[1]) % LINK_HASH_SIZE)]; \
    while (pLink != NULL && \
           (pLink->LinkAddr.ul.Low != LanAddr.ul.Low || \
            pLink->LinkAddr.ul.High != LanAddr.ul.High)) \
    { \
        pLink = pLink->pNextNode; \
    } \
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcndis.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems Ab

Module Name:

    llcndis.c

Abstract:

    The module binds and unbinds a protocol level module to DLC and binds the
    data link driver to an NDIS driver if it is necessary.

    All NDIS specific code is also gathered into this module such as the network
    status indications.

    Note: The DLC driver assumes that all DLC level code assumes a Token Ring
    adapter. If we bind to an ethernet adapter, or the required NDIS medium
    type is Ethernet, then we set up DLC to transform Token Ring addresses and
    packet formats to Ethernet (including DIX ethernet format). However, we can
    build a version of DLC/LLC which understands Ethernet format at the API
    level. Define SUPPORT_ETHERNET_CLIENT in order to build such a DLC

    NB: As of 07/13/92, SUPPORT_ETHERNET_CLIENT code has not been tested!

    Contents:
        LlcOpenAdapter
        LlcNdisOpenAdapterComplete
        LlcDisableAdapter
        LlcCloseAdapter
        LlcResetBroadcastAddresses
        InitNdisPackets
        LlcNdisCloseComplete
        NdisStatusHandler
        GetNdisParameter
        SetNdisParameter
        SyncNdisRequest
        WaitAsyncOperation
        LlcNdisRequest
        LlcNdisRequestComplete
        LlcNdisReset
        LlcNdisResetComplete
        UnicodeStringCompare
        PurgeLlcEventQueue

Author:

    Antti Saarenheimo (o-anttis) 30-MAY-1991

Revision History:

    04-AUG-1991,    o-anttis
        Rewritten for NDIS 3.0 (and for real use).

    28-Apr-1994 rfirth

        * Modified to use single driver-level spinlock

        * Cleaned-up open/close - found a few bugs when stressing adapter
          open & close

    04-May-1994 rfirth

        * Added MAC address caching for TEST/XID/SABME frames when adapter
          opened in LLC_ETHERNET_TYPE_AUTO mode

--*/

#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include <dlc.h>    // need DLC_FILE_CONTEXT for memory allocation charged to handle
#include <llc.h>
#include <dbgmsg.h>

#if DBG 
int DbgSettings = 0x80000000;
//int DbgSettings = 0xC0000007;
#endif // DBG

//
// private prototypes
//

BOOLEAN
UnicodeStringCompare(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    );

VOID
PurgeLlcEventQueue(
    IN PBINDING_CONTEXT pBindingContext
    );

#ifdef NDIS40

//
// Private prototypes for PnP.
//

PADAPTER_CONTEXT
AllocateAdapterContext(
    PNDIS_STRING pAdapterName
    );

VOID
FreeAdapterContext(
    PADAPTER_CONTEXT pAdapterContext
    );

NDIS_STATUS
OpenAdapter(
    PADAPTER_CONTEXT pAdapterContext,
    BOOLEAN          fFirstOpen
    );

VOID
CloseAdapter(
    PVOID pv_pAdapterContext
    );

#endif 

//
// Internal statics used in NDIS 3.1 initialization in NT OS/2
//

KSPIN_LOCK LlcSpinLock;
PVOID LlcProtocolHandle;
PADAPTER_CONTEXT pAdapters = NULL;

#ifdef NDIS40
NDIS_EVENT  PnPBindsComplete;
ULONG       gWaitForAdapter;
#endif // NDIS40

//
// We do not support FDDI because it is the same as token-ring
//

UINT LlcMediumArray[3] = {
    NdisMedium802_5,
    NdisMedium802_3,
    NdisMediumFddi
};


DLC_STATUS
LlcOpenAdapter(
    IN PWSTR pAdapterName,
    IN PVOID hClientContext,
    IN PFLLC_COMMAND_COMPLETE pfCommandComplete,
    IN PFLLC_RECEIVE_INDICATION pfReceiveIndication,
    IN PFLLC_EVENT_INDICATION pfEventIndication,
    IN NDIS_MEDIUM NdisMedium,
    IN LLC_ETHERNET_TYPE EthernetType,
    IN UCHAR AdapterNumber,
    OUT PVOID *phBindingContext,
    OUT PUINT puiOpenStatus,
    OUT PUSHORT pusMaxFrameLength,
    OUT PNDIS_MEDIUM pActualNdisMedium
    )

/*++

Routine Description:

    The first call to a new adapter initializes the NDIS interface
    and allocates internal data structures for the new adapter.

    Subsequent opens for the same adapter only increment the reference count
    of that adapter context.

    The execution is synchronous! The procedure waits (sleeps) until
    the adapter has been opened by the MAC.

Special:

    Must be called IRQL < DPC

Arguments:

    pAdapterName......... MAC adapter name. Zero-terminated, wide-character string

    hClientContext....... client context for this adapter

    pfCommandComplete.... send/receive/request command completion handler of the
                          client

    pfReceiveIndication.. receive data indication handler of the client

    pfEventIndication.... event indication handler of the client

    NdisMedium........... the NdisMedium used by the protocol driver (ie DLC).
                          Only NdisMedium802_5 is supported

    EthernetType......... type of Ethernet connection - 802.3 or DIX

    AdapterNumber........ adapter mapping from CCB

    phBindingContext..... the returned binding context handle used with the file
                          context (by DirOpenAdapter)

    puiOpenStatus........ status of NdisOpenAadapter

    pusMaxFrameLength.... returned maximum I-frame length

    pActualNdisMedium.... returned actual NDIS medium; may be different from
                          that requested (NdisMedium)

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - all NDIS error status from NdisOpenAdapter
                  DLC_STATUS_TIMEOUT
                    asynchronous NdisOpenAdapter failed.

--*/

{
    NDIS_STATUS NdisStatus;
    PADAPTER_CONTEXT pAdapterContext;
    UINT OpenStatus = STATUS_SUCCESS;
    PBINDING_CONTEXT pBindingContext;
    UINT MediumIndex;
    KIRQL irql;
    BOOLEAN DoNdisClose = FALSE;
    UNICODE_STRING unicodeString;
    BOOLEAN newAdapter;
    ULONG cacheEntries;
    BOOLEAN initUnicodeString = TRUE;
    NTSTATUS ntstatus;

#ifdef NDIS40
    LONG          BindState;
    ULONG         DelaySeconds;
    LARGE_INTEGER SleepSec;
#endif // NDIS40

#if DBG

    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)hClientContext;

#endif

    DEBUGMSG(DBG_NDIS_OPEN,
        (TEXT("+LlcOpenAdapter(%#x...)\n"), pAdapterName));

    ASSUME_IRQL(DISPATCH_LEVEL);


#ifdef SUPPORT_ETHERNET_CLIENT

    if (NdisMedium != NdisMedium802_3 && NdisMedium != NdisMedium802_5) {
        return DLC_STATUS_UNKNOWN_MEDIUM;

    }

#else

    if (NdisMedium != NdisMedium802_5) {
        return DLC_STATUS_UNKNOWN_MEDIUM;
    }

#endif

    RELEASE_DRIVER_LOCK();

    ASSUME_IRQL(PASSIVE_LEVEL);

#ifdef NDIS40
    //
    // Wait for all NDIS bindings to have completed before trying to open
    // the adapter.
    //

    if (NdisWaitEvent(&PnPBindsComplete, 0) == FALSE)
    {

        ACQUIRE_DRIVER_LOCK();
        return (DLC_STATUS_WAIT_TIMEOUT);
    }
#endif // NDIS40

    //
    // RLF 04/19/93
    //
    // The adapter name passed to this routine is a zero-terminated wide
    // character string mapped to system space. Create a UNICODE_STRING for
    // the name and use standard Rtl function to compare with names of adapters
    // already opened by DLC
    //

    // Although its assumed that the adapter name is NULL-terminated,
    // we will anyway check whether this is the case or not
    // We know the length of the wide character string is 260 (MAX_PATH)
    // BUG: 127246 (security bug)

    {
      ULONG  len  = 0;

      while (len < MAX_PATH) {
        if (pAdapterName[len] == L'\0') {
          break;
        }
        len++;
      }

      if (len == MAX_PATH) {
        // the wchar string is not NULL terminated
        ACQUIRE_DRIVER_LOCK();
        return DLC_STATUS_INVALID_ADAPTER;
      }
    }

    RtlInitUnicodeString(&unicodeString, pAdapterName);

    //
    // if the adapter is being opened in LLC_ETHERNET_TYPE_AUTO mode then we
    // get the cache size from the registry
    //

    if (EthernetType == LLC_ETHERNET_TYPE_AUTO) {

        static DLC_REGISTRY_PARAMETER framingCacheParameterTemplate = {
            L"AutoFramingCacheSize",
            (PVOID)DEFAULT_AUTO_FRAMING_CACHE_SIZE,
            {
                REG_DWORD,
                PARAMETER_AS_SPECIFIED,
                NULL,
                sizeof(ULONG),
                NULL,
                MIN_AUTO_FRAMING_CACHE_SIZE,
                MAX_AUTO_FRAMING_CACHE_SIZE
            }
        };
        PDLC_REGISTRY_PARAMETER parameterTable;

        //
        // create a private copy of the parameter table descriptor
        //

        parameterTable = (PDLC_REGISTRY_PARAMETER)
                                ALLOCATE_ZEROMEMORY_DRIVER(sizeof(*parameterTable));
        if (!parameterTable) {
            ACQUIRE_DRIVER_LOCK();
            return DLC_STATUS_NO_MEMORY;
        }
        RtlCopyMemory(parameterTable,
                      &framingCacheParameterTemplate,
                      sizeof(framingCacheParameterTemplate)
                      );

        //
        // point the Variable field at cacheEntries and set it to the default
        // value then call GetRegistryParameters to retrieve the registry value.
        // (and set it if not already in the registry). Ignore the return value
        // - if GetAdapterParameters failed, cacheEntries will still contain the
        // default value
        //

        cacheEntries = DEFAULT_AUTO_FRAMING_CACHE_SIZE;
        parameterTable->Descriptor.Variable = (PVOID)&cacheEntries;
        parameterTable->Descriptor.Value = (PVOID)&parameterTable->DefaultValue;
        GetAdapterParameters(&unicodeString, parameterTable, 1, TRUE);
        FREE_MEMORY_DRIVER(parameterTable);
    } else {
        cacheEntries = 0;
    }

    //
    // allocate a BINDING_CONTEXT with enough additional space to store the
    // required framing discovery cache
    //
    // DEBUG: BINDING_CONTEXT structures are charged to the FILE_CONTEXT
    //

#if defined(DEBUG_DISCOVERY)

    DbgPrint("cacheEntries=%d\n", cacheEntries);

#endif

    pBindingContext = (PBINDING_CONTEXT)
                        ALLOCATE_ZEROMEMORY_FILE(sizeof(BINDING_CONTEXT)
                                                 + cacheEntries
                                                 * sizeof(FRAMING_DISCOVERY_CACHE_ENTRY)
                                                 );
    if (!pBindingContext) {
        ACQUIRE_DRIVER_LOCK();
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // set the maximum size of the framing discovery cache. Will be zero if the
    // requested ethernet type is not LLC_ETHERNET_TYPE_AUTO
    //

    pBindingContext->FramingDiscoveryCacheEntries = cacheEntries;

#if DBG

    //
    // we need the FILE_CONTEXT structure in the BINDING_CONTEXT in the event
    // the open fails and we need to deallocate memory. Normally this field is
    // not set til everything has successfully been completed
    //

    pBindingContext->hClientContext = hClientContext;

#endif

    //
    // RtlUpcaseUnicodeString is a paged routine - lower IRQL
    //

    //
    // to avoid having to case-insensitive compare unicode strings every time,
    // we do a one-shot convert to upper-cased unicode strings. This also helps
    // out since we do our own unicode string comparison (case-sensitive)
    //
    // Note that this modifies the input parameter
    //

    RtlUpcaseUnicodeString(&unicodeString, &unicodeString, FALSE);

    //
    // before we re-acquire the driver spin-lock, we wait on the OpenAdapter
    // semaphore. We serialize access to the following code because simultaneous
    // opens (in different processes) and closes (different threads within
    // same process) check to see if the adapter is on the pAdapters list.
    // We don't want multiple processes creating the same adapter context
    // simultaneously. Similarly, we must protect against the situation where
    // one process is adding a binding and another could be closing what it
    // thinks is the sole binding, thereby deleting the adapter context we
    // are about to update
    // Note that this is a non-optimal solution since it means an app opening
    // or closing an ethernet adapter could get stuck behind another opening
    // a token ring adapter (slow)
    //

    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    //
    // grab the global LLC spin lock whilst we are looking at/updating the list
    // of adapters
    //

    ACQUIRE_LLC_LOCK(irql);

    //
    // because we are doing the compare within spinlock, we use our own function
    // which checks for an exact match (i.e. case-sensitive). This is ok since
    // always upper-case the string before comparing it or storing it in an
    // ADAPTER_CONTEXT
    //

    for (pAdapterContext = pAdapters; pAdapterContext; pAdapterContext = pAdapterContext->pNext) {
        if (UnicodeStringCompare(&unicodeString, &pAdapterContext->Name)) {
            break;
        }
    }

    //
    // if we didn't locate an adapter context with our adapter name then we're
    // creating a new binding: allocate a new adapter context structure
    //

#ifdef NDIS40
    //
    // Some adapters may come up after the PnPBindsComplete event, such
    // as an ATM LANE. Just in case the adapter initialization is delayed,
    // we will wait for 'gWaitForAdapter' seconds or until the adapter
    // is found.
    //

    DEBUGMSG(DBG_NDIS_OPEN && pAdapterContext == NULL,
        (TEXT("LlcOpenAdapter - WaitForAdapter %d\n"),
        gWaitForAdapter));
    
    SleepSec.QuadPart = -(10*1000*1000); // 1 second.

    for (DelaySeconds = gWaitForAdapter; 
         (DelaySeconds > 0) && (pAdapterContext == NULL); 
         DelaySeconds--)
    {
        DEBUGMSG(DBG_NDIS_OPEN && DBG_VERBOSE,
            (TEXT("LlcOpenAdapter - waiting %d\n"), DelaySeconds));
        
        KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);
    
        KeDelayExecutionThread(KernelMode, FALSE, &SleepSec);
        
        KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                              Executive,
                              KernelMode,
                              FALSE,        // not alertable
                              NULL          // wait until object is signalled
                              );

        // Search for the adapter again.
        for (pAdapterContext = pAdapters; 
             pAdapterContext != NULL; 
             pAdapterContext = pAdapterContext->pNext) 
        {
            if (UnicodeStringCompare(&unicodeString, &pAdapterContext->Name)) 
            {
                break;
            }
        }
    }

    //
    // For NDIS40, with bind and unbind handlers, the ADAPTER_CONTEXT is 
    // managed by the bind/unbind handler. If the adapter is in the list,
    // then we can attach the binding context, else fail the open request.
    //

    newAdapter = FALSE;

    //
    // If NDIS has never indicated a binding for this adapter, then fail
    // open adapter request.
    //

    if (pAdapterContext == NULL)
    {
        DEBUGMSG(DBG_NDIS_OPEN || DBG_WARN,
            (TEXT("LlcOpenAdapter - adapter '%ws' not found.\n"),
             pAdapterName));
        
        RELEASE_LLC_LOCK(irql);

        FREE_MEMORY_FILE(pBindingContext);

        KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

        ACQUIRE_DRIVER_LOCK();

        return (DLC_STATUS_ADAPTER_NOT_INSTALLED);
    }

    //
    // Reference count the NdisBindingHandle to make sure that it doesn't
    // go away while initializing this binding instance.
    //

    REFADD(&pAdapterContext->AdapterRefCnt, 'nepO');

    //
    // Check to see if the adapter is BOUND/enabled.
    //

    BindState = InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND);

    if (BindState != BIND_STATE_BOUND)
    {
        //
        // Adapter is currently unbound (or unbinding).
        //

        RELEASE_LLC_LOCK(irql);

        FREE_MEMORY_FILE(pBindingContext);

        KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

        ACQUIRE_DRIVER_LOCK();
        
        REFDEL(&pAdapterContext->AdapterRefCnt, 'nepO');

        DEBUGMSG(DBG_NDIS_OPEN || DBG_WARN,
            (TEXT("LlcOpenAdapter - adapter %#x not bound.\n"),
             pAdapterName));
        
        return (DLC_STATUS_ADAPTER_NOT_INSTALLED);
    }
    
    //
    // if we allocated a framing discovery cache, but this adapter is not
    // ethernet or FDDI then disable the cache (we should free the
    // memory used by the cache in this case!!)
    //

    if ((pAdapterContext->NdisMedium != NdisMedium802_3) && 
        (pAdapterContext->NdisMedium != NdisMediumFddi)) 
    {
        pBindingContext->FramingDiscoveryCacheEntries = 0;

#if defined(DEBUG_DISCOVERY)

        DbgPrint("LlcOpenAdapter: setting cache entries to 0 (medium = %s)\n",
            (pAdapterContext->NdisMedium == NdisMedium802_5)       ? "802.5" :
            (pAdapterContext->NdisMedium == NdisMediumWan)         ? "WAN" :
            (pAdapterContext->NdisMedium == NdisMediumLocalTalk)   ? "LocalTalk" :
            (pAdapterContext->NdisMedium == NdisMediumDix)         ? "DIX?" :
            (pAdapterContext->NdisMedium == NdisMediumArcnetRaw)   ? "ArcnetRaw" :
            (pAdapterContext->NdisMedium == NdisMediumArcnet878_2) ? "Arcnet878_2" :
            "UNKNOWN!");
            
#endif
    }

    //
    // Fall through and link the BIND_CONTEXT with the adapter context.
    //

#else // NDIS40

    if (!pAdapterContext) {

        //
        // DEBUG: ADAPTER_CONTEXT structures are charged to the driver
        //

        pAdapterContext = (PADAPTER_CONTEXT)
                            ALLOCATE_ZEROMEMORY_DRIVER(sizeof(ADAPTER_CONTEXT));
        if (!pAdapterContext) {

            RELEASE_LLC_LOCK(irql);

            //
            // DEBUG: refund memory charged for BINDING_CONTEXT to FILE_CONTEXT
            //

            FREE_MEMORY_FILE(pBindingContext);

            KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

            ACQUIRE_DRIVER_LOCK();

            return DLC_STATUS_NO_MEMORY;
        }

        newAdapter = TRUE;

#if DBG

        //
        // record who owns this memory usage structure and add it to the
        // list of all memory usages created in the driver
        //

        pAdapterContext->MemoryUsage.Owner = (PVOID)pAdapterContext;
        pAdapterContext->MemoryUsage.OwnerObjectId = AdapterContextObject;
        pAdapterContext->StringUsage.Owner = (PVOID)pAdapterContext;
        pAdapterContext->StringUsage.OwnerObjectId = AdapterContextObject;
        LinkMemoryUsage(&pAdapterContext->MemoryUsage);
        LinkMemoryUsage(&pAdapterContext->StringUsage);

#endif

        //
        // We must allocate all spinlocks immediately after the
        // adapter context has been allocated, because
        // they can also deallocated simultaneously.
        //

        ALLOCATE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
        ALLOCATE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

        //
        // allocate space for the adapter name string from non-paged pool
        // and initialize the name in the adapter context structure
        //

        NdisStatus = LlcInitUnicodeString(&pAdapterContext->Name,
                                          &unicodeString
                                          );
        if (NdisStatus != STATUS_SUCCESS) {
	    initUnicodeString = FALSE;
            goto CleanUp;
        }

        pAdapterContext->OpenCompleteStatus = NDIS_STATUS_PENDING;

        //
        // and release the global spin lock: we have finished updating the
        // adapter list and initializing this adapter context. From now
        // on we use spin locks specific to this adapter context
        //

        RELEASE_LLC_LOCK(irql);

        //
        // We must initialize the list heads before we open the adapter!!!
        //

        InitializeListHead(&pAdapterContext->QueueEvents);
        InitializeListHead(&pAdapterContext->QueueCommands);
        InitializeListHead(&pAdapterContext->NextSendTask);

        pAdapterContext->OpenErrorStatus = NDIS_STATUS_PENDING;

        ASSUME_IRQL(PASSIVE_LEVEL);

        KeInitializeEvent(&pAdapterContext->Event, NotificationEvent, FALSE);

        //
        // when the NDIS level adapter open completes, it will call
        // LlcNdisOpenAdapterComplete which will reset the kernel event that
        // we are now going to wait on (note: this plagiarized from Nbf)
        //

        NdisOpenAdapter(&NdisStatus,
                        &pAdapterContext->OpenErrorStatus,
                        &pAdapterContext->NdisBindingHandle,
                        &MediumIndex,
                        (NDIS_MEDIUM *)&LlcMediumArray[0],
                        sizeof(LlcMediumArray),
                        (NDIS_HANDLE)LlcProtocolHandle,
                        (NDIS_HANDLE)pAdapterContext,
                        &pAdapterContext->Name,
                        NDIS_OPEN_RECEIVE_NOT_REENTRANT,
                        NULL    // no addressing information
                        );

        if (NdisStatus == NDIS_STATUS_PENDING) {

            ASSUME_IRQL(PASSIVE_LEVEL);

	    do {
	      ntstatus = KeWaitForSingleObject(&pAdapterContext->Event,
					       Executive,
					       KernelMode,
					       TRUE, // alertable
					       (PLARGE_INTEGER)NULL
					       );

	    } while (ntstatus == STATUS_ALERTED);

            //
            // get the return status from the Ndis adapter open call
            //

            NdisStatus = pAdapterContext->AsyncOpenStatus;

            //
            // place the event in not-signalled state. We don't expect to use
            // this event for this adapter context again: currently it's only
            // used for the adapter open at NDIS level
            //

            KeResetEvent(&pAdapterContext->Event);
        }

        *puiOpenStatus = (UINT)pAdapterContext->OpenErrorStatus;
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: NdisOpenAdapter failed\n");
            }

            goto CleanUp;
        } else {

            //
            // from this point on, if this function fails, we have to call
            // LlcCloseAdapter to close the adapter @ NDIS level
            //

            DoNdisClose = TRUE;
        }

        pAdapterContext->NdisMedium = LlcMediumArray[MediumIndex];

        ASSUME_IRQL(PASSIVE_LEVEL);

        //
        // fill-in some medium-specific fields
        //

        switch (pAdapterContext->NdisMedium) {
        case NdisMedium802_5:
            pAdapterContext->cbMaxFrameHeader = 32;  // 6 + 6 + 2 + 18

            //
            // the top bit of the destination address signifies a broadcast
            // frame. On Token Ring, the top bit is bit 7
            //

            pAdapterContext->IsBroadcast = 0x80;

            //
            // functional address starts C0-00-... The top 2 bytes are compared
            // as a USHORT = 0x00C0
            //

            pAdapterContext->usHighFunctionalBits = 0x00C0;
            pAdapterContext->AddressTranslationMode = LLC_SEND_802_5_TO_802_5;
            break;

        case NdisMedium802_3:
            pAdapterContext->cbMaxFrameHeader = 14;  // 6 + 6 + 2

            //
            // the top bit of the destination address signifies a broadcast
            // frame. On Ethernet, the top bit is bit 0
            //

            pAdapterContext->IsBroadcast = 0x01;

            //
            // functional address starts 03-00-... The top 2 bytes are compared as
            // a USHORT = 0x0003
            //

            pAdapterContext->usHighFunctionalBits = 0x0003;
            pAdapterContext->AddressTranslationMode = LLC_SEND_802_3_TO_802_3;
            break;

        case NdisMediumFddi:
            pAdapterContext->cbMaxFrameHeader = 13;  // 1 + 6 + 6

            //
            // bits are in same order as for ethernet
            //

            pAdapterContext->IsBroadcast = 0x01;
            pAdapterContext->usHighFunctionalBits = 0x0003;
            pAdapterContext->AddressTranslationMode = LLC_SEND_FDDI_TO_FDDI;
            break;

        }

        //
        // allocate the ndis packets. The NDIS packet must have space
        // for the maximum frame header and the maximum LLC response
        // and its information field (quite small)
        //

        NdisAllocatePacketPool(&NdisStatus,
                               &pAdapterContext->hNdisPacketPool,
                               MAX_NDIS_PACKETS + 1,
                               sizeof(LLC_NDIS_PACKET) - sizeof(NDIS_MAC_PACKET)
                               );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: NdisAllocatePacketPool failed\n");
            }

            goto CleanUp;
        }

        NdisStatus = InitNdisPackets(&pAdapterContext->pNdisPacketPool,
                                     pAdapterContext->hNdisPacketPool
                                     );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: InitNdisPackets failed\n");
            }

            goto CleanUp;
        }

        //
        // Initialize the LLC packet pool
        //

        pAdapterContext->hPacketPool = CREATE_PACKET_POOL_ADAPTER(
                                            LlcPacketPoolObject,
                                            sizeof(UNITED_PACKETS),
                                            8
                                            );
        if (!pAdapterContext->hPacketPool) {
            NdisStatus = DLC_STATUS_NO_MEMORY;

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: CreatePacketPool failed\n");
            }

            goto CleanUp;
        }
        pAdapterContext->hLinkPool = CREATE_PACKET_POOL_ADAPTER(
                                            LlcLinkPoolObject,
                                            pAdapterContext->cbMaxFrameHeader
                                            + sizeof(DATA_LINK),
                                            2
                                            );

        if (!pAdapterContext->hLinkPool) {
            NdisStatus = DLC_STATUS_NO_MEMORY;

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: CreatePacketPool #2 failed\n");
            }

            goto CleanUp;
        }

        //
        // Read the current node address and maximum frame size
        //

        NdisStatus = GetNdisParameter(pAdapterContext,
                                      (pAdapterContext->NdisMedium == NdisMedium802_3)
                                        ? OID_802_3_CURRENT_ADDRESS
                                        : (pAdapterContext->NdisMedium == NdisMediumFddi)
                                            ? OID_FDDI_LONG_CURRENT_ADDR
                                            : OID_802_5_CURRENT_ADDRESS,
                                      pAdapterContext->NodeAddress,
                                      sizeof(pAdapterContext->NodeAddress)
                                      );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: GetNdisParameter failed\n");
            }

            goto CleanUp;
        }

        NdisStatus = GetNdisParameter(pAdapterContext,
                                      (pAdapterContext->NdisMedium == NdisMedium802_3)
                                        ? OID_802_3_PERMANENT_ADDRESS
                                        : (pAdapterContext->NdisMedium == NdisMediumFddi)
                                            ? OID_FDDI_LONG_PERMANENT_ADDR
                                            : OID_802_5_PERMANENT_ADDRESS,
                                      pAdapterContext->PermanentAddress,
                                      sizeof(pAdapterContext->PermanentAddress)
                                      );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: GetNdisParameter #2 failed\n");
            }

            goto CleanUp;
        }

        {
            //
            // Mod RLF 07/10/92
            //
            // apparently, TR adapter does not support NDIS_PACKET_TYPE_MULTICAST
            // as a filter. Up to now, it seems to have been reasonably happy
            // with this type. However, we're not going to include it from now on
            //

            //
            // Mod RLF 01/13/93
            //
            // Similarly, Ethernet doesn't support FUNCTIONAL addresses (Token
            // Ring's functional address is equivalent to Ethernet's multicast
            // address)
            //

            ULONG PacketFilter = NDIS_PACKET_TYPE_DIRECTED
                               | NDIS_PACKET_TYPE_BROADCAST
                               | (((pAdapterContext->NdisMedium == NdisMedium802_3)
                               || (pAdapterContext->NdisMedium == NdisMediumFddi))
                                  ? NDIS_PACKET_TYPE_MULTICAST
                                  : NDIS_PACKET_TYPE_FUNCTIONAL
                               );

            //
            // EndMod
            //

            NdisStatus = SetNdisParameter(pAdapterContext,
                                          OID_GEN_CURRENT_PACKET_FILTER,
                                          &PacketFilter,
                                          sizeof(PacketFilter)
                                          );
#if DBG

            if (NdisStatus != NDIS_STATUS_SUCCESS) {
                DbgPrint("Error: NdisStatus = %x\n", NdisStatus);
                ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
            }

#endif

        }

        LlcMemCpy(pAdapterContext->Adapter.Node.auchAddress,
                  pAdapterContext->NodeAddress,
                  6
                  );

        NdisStatus = GetNdisParameter(pAdapterContext,
                                      OID_GEN_MAXIMUM_TOTAL_SIZE,
                                      &pAdapterContext->MaxFrameSize,
                                      sizeof(pAdapterContext->MaxFrameSize)
                                      );
        if (NdisStatus == STATUS_SUCCESS) {
            NdisStatus = GetNdisParameter(pAdapterContext,
                                          OID_GEN_LINK_SPEED,
                                          &pAdapterContext->LinkSpeed,
                                          sizeof(pAdapterContext->LinkSpeed)
                                          );
        }
        if (NdisStatus != STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: GetNdisParameter #3/#4 failed\n");
            }

            goto CleanUp;
        }

        //
        // RLF 04/12/93
        //
        // Here we used to load the LLC_TICKS array from TimerTicks - a global
        // array of timer tick values.
        // Instead, we get any per-adapter configuration information stored in
        // the registry
        //

        LoadAdapterConfiguration(&pAdapterContext->Name,
                                 &pAdapterContext->ConfigInfo
                                 );

        //
        // RLF 04/02/94
        //
        // if this is not a Token Ring card then check the MaxFrameSize retrieved
        // above. If the UseEthernetFrameSize parameter was set in the registry
        // then we use the smaller of the ethernet size (1514) and the value
        // reported by the MAC. If the parameter was not set then we just use
        // the value already retrieved. If the card is Token Ring then we use
        // the value already retrieved
        //

        if (pAdapterContext->NdisMedium != NdisMedium802_5
        && pAdapterContext->ConfigInfo.UseEthernetFrameSize
        && pAdapterContext->MaxFrameSize > MAX_ETHERNET_FRAME_LENGTH) {
            pAdapterContext->MaxFrameSize = MAX_ETHERNET_FRAME_LENGTH;
        }

        pAdapterContext->QueueI.pObject = (PVOID)GetI_Packet;

        InitializeListHead(&pAdapterContext->QueueI.ListHead);

        pAdapterContext->QueueDirAndU.pObject = (PVOID)BuildDirOrU_Packet;

        InitializeListHead(&pAdapterContext->QueueDirAndU.ListHead);

        pAdapterContext->QueueExpidited.pObject = (PVOID)GetLlcCommandPacket;

        InitializeListHead(&pAdapterContext->QueueExpidited.ListHead);

        pAdapterContext->AdapterNumber = (UCHAR)AdapterNumber;

        pAdapterContext->OpenCompleteStatus = STATUS_SUCCESS;

        //
        // if we allocated a framing discovery cache, but this adapter is not
        // ethernet or FDDI then disable the cache (we should free the
        // memory used by the cache in this case!!)
        //

        if ((pAdapterContext->NdisMedium != NdisMedium802_3)
        && (pAdapterContext->NdisMedium != NdisMediumFddi)) {

            pBindingContext->FramingDiscoveryCacheEntries = 0;

#if defined(DEBUG_DISCOVERY)

            DbgPrint("LlcOpenAdapter: setting cache entries to 0 (medium = %s)\n",
                     (pAdapterContext->NdisMedium == NdisMedium802_5) ? "802.5" :
                     (pAdapterContext->NdisMedium == NdisMediumWan) ? "WAN" :
                     (pAdapterContext->NdisMedium == NdisMediumLocalTalk) ? "LocalTalk" :
                     (pAdapterContext->NdisMedium == NdisMediumDix) ? "DIX?" :
                     (pAdapterContext->NdisMedium == NdisMediumArcnetRaw) ? "ArcnetRaw" :
                     (pAdapterContext->NdisMedium == NdisMediumArcnet878_2) ? "Arcnet878_2" :
                     "UNKNOWN!"
                     );

#endif

        }
    } else {
        newAdapter = FALSE;
    }
#endif // !NDIS40

    //
    // at this point, we have an allocated, but as yet not filled in binding
    // context and an adapter context that we either found on the pAdapters
    // list, or we just allocated and filled in. We are currently operating
    // at PASSIVE_LEVEL. Re-acquire the driver lock and fill in the binding
    // context
    //

    ACQUIRE_DRIVER_LOCK();

    ASSUME_IRQL(DISPATCH_LEVEL);

    switch (pAdapterContext->NdisMedium) {
    case NdisMedium802_5:
        pBindingContext->EthernetType = LLC_ETHERNET_TYPE_802_3;
        pBindingContext->InternalAddressTranslation = LLC_SEND_802_5_TO_802_5;

#ifdef SUPPORT_ETHERNET_CLIENT

        if (NdisMedium == NdisMedium802_3) {
            pBindingContext->SwapCopiedLanAddresses = TRUE;
            pBindingContext->AddressTranslation = LLC_SEND_802_3_TO_802_5;
        } else {
            pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_5;
        }

#else

        pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_5;

#endif

        pBindingContext->SwapCopiedLanAddresses = FALSE;
        break;

    case NdisMediumFddi:
        pBindingContext->EthernetType = LLC_ETHERNET_TYPE_802_3;
        pBindingContext->InternalAddressTranslation = LLC_SEND_FDDI_TO_FDDI;
        pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_FDDI;
        pBindingContext->SwapCopiedLanAddresses = TRUE;
        break;

    case NdisMedium802_3:

        //
        // if EthernetType is LLC_ETHERNET_TYPE_DEFAULT then set it to DIX based
        // on the UseDix entry in the registry
        //

        if (EthernetType == LLC_ETHERNET_TYPE_DEFAULT) {
            EthernetType = pAdapterContext->ConfigInfo.UseDix
                         ? LLC_ETHERNET_TYPE_DIX
                         : LLC_ETHERNET_TYPE_802_3
                         ;
        }
        pBindingContext->EthernetType = (USHORT)EthernetType;

        if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
            pBindingContext->InternalAddressTranslation = LLC_SEND_802_3_TO_DIX;
        } else {
            pBindingContext->InternalAddressTranslation = LLC_SEND_802_3_TO_802_3;
        }

#ifdef SUPPORT_ETHERNET_CLIENT

        if (NdisMedium == NdisMedium802_3) {
            pBindingContext->AddressTranslation = LLC_SEND_802_3_TO_802_3;
            if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
                pBindingContext->AddressTranslation = LLC_SEND_802_3_TO_DIX;
            }
        } else {
            pBindingContext->SwapCopiedLanAddresses = TRUE;
            pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_3;
            if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
                pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_DIX;
            }
        }

#else

        pBindingContext->SwapCopiedLanAddresses = TRUE;
        pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_3;
        if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
            pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_DIX;
        }

#endif

    }

    pBindingContext->NdisMedium = NdisMedium;
    pBindingContext->hClientContext = hClientContext;
    pBindingContext->pfCommandComplete = pfCommandComplete;
    pBindingContext->pfReceiveIndication = pfReceiveIndication;
    pBindingContext->pfEventIndication = pfEventIndication;
    *pusMaxFrameLength = (USHORT)pAdapterContext->MaxFrameSize;
    *pActualNdisMedium = pAdapterContext->NdisMedium;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // create a new timer tick (or update one that already exists) and add a
    // timer to it for the DLC timer (used by the DIR.TIMER.XXX routines). The
    // DLC timer fires every 0.5 seconds. The LLC timer fires every 40 mSec. The
    // multiplier is therefore 13 (13 * 40 mSec = 520 mSec). We need to add 5
    // because InitializeTimer is expecting DLC timer tick values of 1-5 and
    // 6-10. If the timer tick value is greater than 5, InitializeTimer will
    // subtract 5 and multiply by the second multiplier value
    //

    NdisStatus = InitializeTimer(pAdapterContext,
                                 &pBindingContext->DlcTimer,
                                 (UCHAR)13 + 5,
                                 (UCHAR)1,
                                 (UCHAR)1,
                                 LLC_TIMER_TICK_EVENT,
                                 pBindingContext,
                                 0, // ResponseDelay
                                 FALSE
                                 );
    if (NdisStatus != STATUS_SUCCESS) {

        IF_LOCK_CHECK {
            DbgPrint("LlcOpenAdapter: InitializeTimer failed\n");
        }

        //
        // we failed to initialize the timer. Free up all resources and return
        // the error
        //

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        RELEASE_DRIVER_LOCK();

        ASSUME_IRQL(PASSIVE_LEVEL);

        goto CleanUp;
    } else {
        StartTimer(&pBindingContext->DlcTimer);

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    }

    //
    // everything worked: point the binding context at the adapter context,
    // point the adapter context at the binding context, incrementing the binding
    // count (note that if this is the first binding, the count field will be
    // zero since we allocated the adapter context from ZeroMemory). Finally add
    // the adapter context to pAdapters if it wasn't already on the list
    //

    pBindingContext->pAdapterContext = pAdapterContext;

    IF_LOCK_CHECK {
        if (!pAdapterContext->BindingCount) {
            if (pAdapterContext->pBindings) {
                DbgPrint("**** binding count/pointer mismatch ****\n");
                DbgBreakPoint();
            }
        }
    }

    pBindingContext->pNext = pAdapterContext->pBindings;
    pAdapterContext->pBindings = pBindingContext;
    ++pAdapterContext->BindingCount;

    //
    // we can now add this adapter context structure to the global list
    // of adapter contexts
    //

#ifdef NDIS40
    ASSERT(newAdapter == FALSE);
#else // NDIS40
    if (newAdapter) {
        pAdapterContext->pNext = pAdapters;
        pAdapters = pAdapterContext;
    }
#endif // !NDIS40

    //
    // now release the semaphore, allowing any other threads waiting to open an
    // adapter to check the pAdapter list
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

#ifdef NDIS40
    //
    // Release the NdisBindingHandle reference.
    //

    REFDEL(&pAdapterContext->AdapterRefCnt, 'nepO');
#endif // NDIS40

    //
    // return a pointer to the allocated binding context
    //

    *phBindingContext = (PVOID)pBindingContext;

    return STATUS_SUCCESS;

CleanUp:

    //
    // an error occurred. If we just allocated and (partially) filled in an
    // adapter context then close the adapter (if required), release the adapter
    // context resources and free the adapter context.
    // We have a binding context that we just allocated. Deallocate it
    // N.B. We cannot be here if the binding context's timer was successfully
    // initialized/started
    //

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // if we are to close this adapter then this is the first and only open of
    // this adapter, so we don't need to worry about synchronizing other threads
    // open the same adapter
    //

#ifdef NDIS40
    ASSERT(DoNdisClose == FALSE);
    
    //
    // Release the NdisBindingHandle reference.
    //

    ASSERT(pAdapterContext);
    REFDEL(&pAdapterContext->AdapterRefCnt, 'nepO');
#else // NDIS40
    if (DoNdisClose) {

        NDIS_STATUS status;

        pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;
        NdisCloseAdapter(&status,
                         pAdapterContext->NdisBindingHandle
                         );
        WaitAsyncOperation(&pAdapterContext->Event,
						   &(pAdapterContext->AsyncCloseResetStatus),
						   status);
        pAdapterContext->NdisBindingHandle = NULL;
    }
#endif // !NDIS40

    //
    // release the semaphore - any other threads can now get in and access
    // pAdapters
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

#ifdef NDIS40
    ASSERT(newAdapter == FALSE);
#else // NDIS40
    //
    // if a newly allocated adapter context, release any resources allocated
    //

    if (newAdapter) {
        if (pAdapterContext->hNdisPacketPool) {

            //
            // Free MDLs allocated for each NDIS packet.
            //

            while (pAdapterContext->pNdisPacketPool) {

                PLLC_NDIS_PACKET pNdisPacket;

                pNdisPacket = PopFromList(((PLLC_PACKET)pAdapterContext->pNdisPacketPool));
                IoFreeMdl(pNdisPacket->pMdl);

                NdisFreePacket((PNDIS_PACKET)pNdisPacket);

                DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
            }

            NdisFreePacketPool(pAdapterContext->hNdisPacketPool);
        }

        //
        // DEBUG: refund memory charged for UNICODE buffer to driver string usage
        //
	
	if (initUnicodeString) {
	   FREE_STRING_DRIVER(pAdapterContext->Name.Buffer);
	}

        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hLinkPool);
        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hPacketPool);

        CHECK_MEMORY_RETURNED_ADAPTER();
        CHECK_STRING_RETURNED_ADAPTER();

        UNLINK_MEMORY_USAGE(pAdapterContext);
        UNLINK_STRING_USAGE(pAdapterContext);

        //
        // free the adapter context
        //

        FREE_MEMORY_DRIVER(pAdapterContext);

    }
#endif // !NDIS40

    //
    // free the binding context
    //

    FREE_MEMORY_FILE(pBindingContext);

    //
    // finally retake the spin lock and return the error status
    //

    ACQUIRE_DRIVER_LOCK();

    return NdisStatus;
}


VOID
LlcNdisOpenAdapterComplete(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    )

/*++

Routine Description:

    The routine completes the adapter opening.
    It only clears and sets the status flags, that are
    polled by the BindToAdapter primitive.

Arguments:

    hAdapterContext - describes adapter being opened
    NdisStatus      - the return status of NdisOpenAdapter
    OpenErrorStatus - additional error info from NDIS

Return Value:

    None.

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("LLcNdisOpenAdapterComplete(%#x, %#x, %#x)\n"),
        hAdapterContext, NdisStatus, OpenErrorStatus));
    
    //
    // set the relevant fields in the adapter context
    //

    ((PADAPTER_CONTEXT)hAdapterContext)->AsyncOpenStatus = NdisStatus;
    ((PADAPTER_CONTEXT)hAdapterContext)->OpenErrorStatus = OpenErrorStatus;

    //
    // signal the event that LlcOpenAdapter is waiting on
    //

    ASSUME_IRQL(ANY_IRQL);

    KeSetEvent(&((PADAPTER_CONTEXT)hAdapterContext)->Event, 0L, FALSE);
}


VOID
LlcDisableAdapter(
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    The primitive disables all network indications on a data link binding.
    This routine can be called from a llc indication handler.

Arguments:

    pBindingContext - The context of the current adapter binding.

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pAdapterContext = pBindingContext->pAdapterContext;
    if (pAdapterContext) {

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        TerminateTimer(pAdapterContext, &pBindingContext->DlcTimer);

        //
        // RLF 04/27/94
        //
        // this is a slight hack: we zap the pointer to the timer tick structure
        // so that if this is called again, TerminateTimer will see that the
        // pointer to the timer tick is NULL and will return immediately. We
        // shouldn't have to do this - we shouldn't poke around inside the
        // timer 'object' - but this function can potentially be called from two
        // places on the termination path - from DirCloseAdapter and now from
        // CloseAdapterFileContext.
        // We only do this for the DLC timer; if we did it for all timers - in
        // TerminateTimer - DLC would break (scandalous, I know)
        //

        pBindingContext->DlcTimer.pTimerTick = NULL;

#ifdef LOCK_CHECK

            pBindingContext->DlcTimer.Disabled = 0xd0bed0be; // do be do be do...

#endif

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    }
}


DLC_STATUS
LlcCloseAdapter(
    IN PBINDING_CONTEXT pBindingContext,
    IN BOOLEAN CloseAtNdisLevel
    )

/*++

Routine Description:

    remove a binding from an adapter. The binding context structure is unlinked
    from the adapter context structure and the count of bindings to the adapter
    context is decremented. The binding context structure is freed. If this is
    the last binding to the adapter then close the adapter at NDIS level, unlink
    the adapter context structure from the global adapter list and free the
    memory used by the adapter context structure

Arguments:

    pBindingContext     - describes adapter to close
    CloseAtNdisLevel    - TRUE if we need to perform NdisCloseAdapter

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - All NDIS error status from NdisCloseAdapter

--*/

{
    PADAPTER_CONTEXT pAdapterContext;
    NDIS_STATUS NdisStatus = STATUS_SUCCESS;
    KIRQL irql;
    USHORT bindingCount;

#if DBG

    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)(pBindingContext->hClientContext);

#endif

#ifdef LOCK_CHECK

    PBINDING_CONTEXT p;
    BOOLEAN found = FALSE;

    DEBUGMSG(DBG_NDIS_OPEN, (TEXT("+LlcCloseAdapter(%#x, %#x)\n"),
        pBindingContext, CloseAtNdisLevel));
    
#endif

    ASSUME_IRQL(DISPATCH_LEVEL);

    pAdapterContext = pBindingContext->pAdapterContext;

    if (!pAdapterContext) {

#if DBG

        DbgPrint("*** LlcCloseAdapter: NULL adapter context! ***\n");
        DbgBreakPoint();

#endif

        return STATUS_SUCCESS;
    }

    //
    // we must wait on the OpenAdapterSemaphore. We need to do this because a
    // thread in another process may be simultaneously generating a new binding
    // to this adapter context - it mustn't be removed until we are certain
    // there are no threads accessing this adapter context
    //

    RELEASE_DRIVER_LOCK();

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    ACQUIRE_DRIVER_LOCK();

    ASSUME_IRQL(DISPATCH_LEVEL);

    ACQUIRE_LLC_LOCK(irql);

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

#ifdef LOCK_CHECK

    for (p = pAdapterContext->pBindings; p; p = p->pNext) {
        if (p == pBindingContext) {
            found = TRUE;
            break;
        }
    }
    if (!found) {
        DbgPrint("\n**** LlcCloseAdapter: can't find BC %x ****\n\n", pBindingContext);
        DbgBreakPoint();
    } else if (p->pNext == p) {
        DbgPrint("\n**** LlcCloseAdapter: circular list ****\n\n");
        DbgBreakPoint();
    }

#endif

    RemoveFromLinkList((PVOID*)&(pAdapterContext->pBindings), pBindingContext);
    bindingCount = --pAdapterContext->BindingCount;

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

#ifdef LOCK_CHECK

    if (!pBindingContext->DlcTimer.Disabled) {
        DbgPrint("LlcCloseAdapter: mashing active timer. bc=%x\n", pBindingContext);
        DbgBreakPoint();
    }

#endif

    //
    // RLF 08/20/94
    //
    // here we must kill any events on the adapter context that may access
    // this binding context's event indication function pointer. If not, we
    // can end up with a blue screen (hey! it happened)
    //

    PurgeLlcEventQueue(pBindingContext);

    //
    // DEBUG: refund memory charged for BINDING_CONTEXT to FILE_CONTEXT
    //

    FREE_MEMORY_FILE(pBindingContext);


#ifdef NDIS40
    //
    // For PnP, the ADAPTER_CONTEXT is not cleaned up nor the NdisBindingHandle
    // closed when the last reference goes away. Instead this is controlled
    // by the NDIS bind/unbind handlers.
    //
    
    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();
#else
    if (!bindingCount) {

        RemoveFromLinkList((PVOID*)&pAdapters, pAdapterContext);

        //
        // Now the adapter is isolated from any global connections.
        // We may clear the global spin lock and free all resources
        // allocated for the adapter context.
        //

        RELEASE_LLC_LOCK(irql);

        RELEASE_DRIVER_LOCK();

        ASSUME_IRQL(PASSIVE_LEVEL);

        //
        // Out of memory conditions the upper driver cannot properly
        // wait until all pending NDIS packets have been sent.
        // In that case we must poll here.
        // (This should happen only if ExAllocatePool fails, but
        // after an inproper shutdown we will loop here forever)
        //

#if DBG

        if (pAdapterContext->ObjectCount) {
            DbgPrint("Waiting LLC objects to be closed ...\n");
        }

#endif

        while (pAdapterContext->ObjectCount) {
            LlcSleep(1000L);      // check the situation after 1 ms
        }

        //
        // RLF 10/26/92
        //
        // we used to test pAdapterContext->NdisBindingHandle for NULL here,
        // but that is an unreliable test since the NdisBindingHandle can be
        // non-NULL even though the binding was not made. We now use the
        // CloseAtNdisLevel parameter to indicate whether we should call the
        // Ndis function to close the adapter
        //

        //
        // MunilS 6/13/96
        //
        // Moved NdisFreePacketPool etc after NdisCloseAdapter to prevent
        // bugcheck in NDIS while handling outstanding sends.
        //

        if (CloseAtNdisLevel)
        {
            pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;

            NdisCloseAdapter(&NdisStatus,
                             pAdapterContext->NdisBindingHandle
                             );

            WaitAsyncOperation(&pAdapterContext->Event,
							   &(pAdapterContext->AsyncCloseResetStatus),
							   NdisStatus);
            pAdapterContext->NdisBindingHandle = NULL;
        }

        if (pAdapterContext->hNdisPacketPool)
        {

           //
           // Free MDLs allocated for each NDIS packet.
           //

           while (pAdapterContext->pNdisPacketPool) {

               PLLC_NDIS_PACKET pNdisPacket;

               pNdisPacket = PopFromList(((PLLC_PACKET)pAdapterContext->pNdisPacketPool));

               IoFreeMdl(pNdisPacket->pMdl);
	
               NdisFreePacket((PNDIS_PACKET)pNdisPacket);
	
               DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
           }

           NdisFreePacketPool(pAdapterContext->hNdisPacketPool);
       }

       //
       // DEBUG: refund memory charged for UNICODE buffer to driver string usage
       //

       FREE_STRING_DRIVER(pAdapterContext->Name.Buffer);

       DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hLinkPool);

       DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hPacketPool);

       CHECK_MEMORY_RETURNED_ADAPTER();

       CHECK_STRING_RETURNED_ADAPTER();

       UNLINK_MEMORY_USAGE(pAdapterContext);

       UNLINK_STRING_USAGE(pAdapterContext);

       FREE_MEMORY_DRIVER(pAdapterContext);

    } else {

       RELEASE_LLC_LOCK(irql);

       RELEASE_DRIVER_LOCK();

    }
#endif // !NDIS40

    //
    // now we can enable any other threads waiting on the open semaphore
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

    ACQUIRE_DRIVER_LOCK();

    return NdisStatus;
}


DLC_STATUS
LlcResetBroadcastAddresses(
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    The primitive deletes the broadcast addresses used by the binding.
    In the case of ethernet it updates multicast address list on
    the adapter, that excludes any addresses set by this binding.
    The last binding actually gives an empty list, that resets
    all addresses set by this protocol binding.

Arguments:

    pBindingContext - The context of the current adapter binding.

Return Value:

    DLC_STATUS:
        Success - STATUS_SUCCESS
        Failure - All NDIS error status from NdisCloseAdapter

--*/

{
    PADAPTER_CONTEXT pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pAdapterContext = pBindingContext->pAdapterContext;

    if (pAdapterContext == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // Reset the functional and group addresses of this binding context.
    // In the case of ethernet,  functional and group addresses of
    // binding contexts are mapped to one global multicast list of
    // this NDIS binding.  Token-ring may have only one group
    // address, that must be reset, when the application owning it
    // is closing its dlc adapter context.  Functional address
    // must also set again in that case.
    //

    pBindingContext->Functional.ulAddress = 0;
    UpdateFunctionalAddress(pAdapterContext);

    if (pBindingContext->ulBroadcastAddress != 0) {
        pBindingContext->ulBroadcastAddress = 0;
        UpdateGroupAddress(pAdapterContext, pBindingContext);
    }

    return STATUS_SUCCESS;
}


NDIS_STATUS
InitNdisPackets(
    OUT PLLC_NDIS_PACKET* ppLlcPacketPool,
    IN NDIS_HANDLE hNdisPool
    )

/*++

Routine Description:

    The primitive copies Ndis packets from the NDIS pool to the
    given internal packet pool.

Arguments:

    ppLlcPacketPool - pointer to pointer to packet pool
    hNdisPool       - handle of NDIS packet pool

Return Value:

    NDIS_STATUS
--*/

{
    PLLC_NDIS_PACKET pNdisPacket;
    NDIS_STATUS NdisStatus;
    UINT i;

    ASSUME_IRQL(PASSIVE_LEVEL);

    for (i = 0; i < MAX_NDIS_PACKETS; i++) {
        NdisAllocatePacket(&NdisStatus,
                           (PNDIS_PACKET*)&pNdisPacket,
                           hNdisPool
                           );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            return NdisStatus;
        }

        //
        // Every NDIS packet includes a MDL, that has been
        // initialized for the data buffer within the same
        // structure. Thus data link driver does need to
        // do any MDL calls during the runtime
        //

        pNdisPacket->pMdl = IoAllocateMdl(pNdisPacket->auchLanHeader,
                                          sizeof(pNdisPacket->auchLanHeader),
                                          FALSE,
                                          FALSE,
                                          NULL
                                          );
        if (pNdisPacket->pMdl == NULL) {
	    NdisFreePacket((PNDIS_PACKET) pNdisPacket);
            return DLC_STATUS_NO_MEMORY;
        }

        DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

        MmBuildMdlForNonPagedPool(pNdisPacket->pMdl);

        PushToList(((PLLC_PACKET)*ppLlcPacketPool),
                   ((PLLC_PACKET)pNdisPacket)
                   );
    }

    return NDIS_STATUS_SUCCESS;
}


VOID
LlcNdisCloseComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    call-back from NDIS when the adapter close operation is completed

Arguments:

    pAdapterContext - describes the adapter being closed
    NdisStatus      - the return status of NdisOpenAdapter

Return Value:

        None
--*/

{
    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

    pAdapterContext->AsyncCloseResetStatus = NdisStatus;

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();

    KeSetEvent(&pAdapterContext->Event, 0L, FALSE);

}


VOID
NdisStatusHandler(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    )

/*++

Routine Description:

    indication handler for all NDIS status events

Arguments:

    pAdapterContext     - context of the NDIS adapter
    NdisStatus          - the major NDIS status code
    StatusBuffer        - A buffer holding more status information
    StatusBufferSize    - The length of StatusBuffer.

Return Value:

    None.

--*/

{
    PBINDING_CONTEXT pBinding;
    PEVENT_PACKET pEvent;
    KIRQL irql;

    //
    // seems that this handler can be called at PASSIVE_LEVEL too
    //

    ASSUME_IRQL(ANY_IRQL);

    //
    // We must synchronize the access to the binding list,
    // the reference count will not allow the client
    // to delete or modify the bindings list while
    // we are routing the status indication to the
    // clients.
    //

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // The NDIS send process is stopped by the reset flag.
    //

    if (NdisStatus == NDIS_STATUS_RESET_START) {
        pAdapterContext->ResetInProgress = TRUE;
    } else if (NdisStatus == NDIS_STATUS_RESET_END) {
        pAdapterContext->ResetInProgress = FALSE;
    } else if (StatusBufferSize == sizeof(NTSTATUS)) {

        //
        // ADAMBA - Declare and assign SpecificStatus locally.
        //

        NTSTATUS SpecificStatus = *(PULONG)StatusBuffer;

		if ( NdisStatus == NDIS_STATUS_RING_STATUS ) {
#if DBG
			ASSERT (IS_NDIS_RING_STATUS(SpecificStatus));
#else	// DBG
			if (IS_NDIS_RING_STATUS(SpecificStatus))
#endif	// DBG
			{
				SpecificStatus = NDIS_RING_STATUS_TO_DLC_RING_STATUS(SpecificStatus);
			}
		}

        //
        // These ndis status codes are indicated to all LLC
        // protocol drivers, that have been bound to this adapter:
        //
        // NDIS_STATUS_ONLINE
        // NDIS_STATUS_CLOSED
        // NDIS_STATUS_RING_STATUS
        //

        for (pBinding = pAdapterContext->pBindings;
             pBinding;
             pBinding = pBinding->pNext) {

            pEvent = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

            if (pEvent) {
                pEvent->pBinding = pBinding;
                pEvent->hClientHandle = NULL;
                pEvent->Event = LLC_NETWORK_STATUS;
                pEvent->pEventInformation = (PVOID)UlongToPtr(NdisStatus);
                pEvent->SecondaryInfo = SpecificStatus;
                LlcInsertTailList(&pAdapterContext->QueueEvents, pEvent);
            }
        }
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();
}


NDIS_STATUS
GetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID NdisOid,
    IN PVOID pDataBuffer,
    IN UINT DataSize
    )

/*++

Routine Description:

    get parameter from NDIS using OID interface

Arguments:

    pAdapterContext - describes adapter
    NdisOid         - indentifies the requested NDIS data
    pDataBuffer     - the buffer for the returned data
    DataSize        - size of pDataBuffer

Return Value:

    NDIS_STATUS

--*/

{
    LLC_NDIS_REQUEST Request;

    ASSUME_IRQL(PASSIVE_LEVEL);

    Request.Ndis.RequestType = NdisRequestQueryInformation;
    Request.Ndis.DATA.QUERY_INFORMATION.Oid = NdisOid;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer = pDataBuffer;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = DataSize;

    return SyncNdisRequest(pAdapterContext, &Request);
}


NDIS_STATUS
SetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID NdisOid,
    IN PVOID pRequestInfo,
    IN UINT RequestLength
    )

/*++

Routine Description:

    set NDIS parameter using OID interface

Arguments:

    pAdapterContext - describes adapter
    NdisOid         - describes info to set
    pRequestInfo    - pointer to info
    RequestLength   - size of info

Return Value:

    NDIS_STATUS

--*/

{
    LLC_NDIS_REQUEST Request;

    ASSUME_IRQL(PASSIVE_LEVEL);

    Request.Ndis.RequestType = NdisRequestSetInformation;
    Request.Ndis.DATA.SET_INFORMATION.Oid = NdisOid;
    Request.Ndis.DATA.SET_INFORMATION.InformationBuffer = pRequestInfo;
    Request.Ndis.DATA.SET_INFORMATION.InformationBufferLength = RequestLength;
    return SyncNdisRequest(pAdapterContext, &Request);
}


DLC_STATUS
SyncNdisRequest(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_REQUEST pRequest
    )

/*++

Routine Description:

    Perform an NDIS request synchronously, even if the actual request would
    be asynchronous

Arguments:

    pAdapterContext - pointer to adapter context
    pRequest        - pointer to NDIS request structure

Return Value:

    DLC_STATUS

--*/

{
    DLC_STATUS Status;

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeInitializeEvent(&pRequest->SyncEvent, NotificationEvent, FALSE);

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'tqeR');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {                                           
        REFDEL(&pAdapterContext->AdapterRefCnt, 'tqeR');
        return (NDIS_STATUS_ADAPTER_NOT_OPEN);
    }

    // Above reference is removed by WaitAsyncOperation.
#endif // NDIS40

    pRequest->AsyncStatus = NDIS_STATUS_PENDING;
    NdisRequest((PNDIS_STATUS)&Status, pAdapterContext->NdisBindingHandle, &pRequest->Ndis);
    
    Status = (DLC_STATUS)WaitAsyncOperation(&pRequest->SyncEvent,
										  &(pRequest->AsyncStatus),
										  Status);

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'tqeR');
#endif // NDIS40

    return (Status);
}


NDIS_STATUS
WaitAsyncOperation(
    IN PKEVENT pEvent,
    IN PNDIS_STATUS pAsyncStatus,
    IN NDIS_STATUS  NdisStatus
    )

/*++

Routine Description:

    Wait for an asynchronous NDIS operation to complete

Arguments:

    pAsyncStatus    - pointer to status returned from NDIS
    NdisStatus      - status to wait for. Should be NDIS_STATUS_PENDING

Return Value:

    NDIS_STATUS

--*/

{
    NDIS_STATUS AsyncStatus;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // Check if we got a synchronous status
    //

    if (NdisStatus != NDIS_STATUS_PENDING) {
        AsyncStatus = NdisStatus;
    }

	else{
		//
		// Wait until the async status flag has been set
		//

		for ( ; ; ) {

			KIRQL irql;
			NTSTATUS ntstatus;

			do {
			ntstatus = KeWaitForSingleObject(pEvent,
							 Executive,
							 KernelMode,
							 TRUE, // alertable
							 (PLARGE_INTEGER)NULL
							 );
			} while (ntstatus == STATUS_ALERTED);

			//
			// The result may be undefined, if we read it in a wrong time.
			// Do it interlocked.
			//

			ACQUIRE_DRIVER_LOCK();

			ACQUIRE_LLC_LOCK(irql);

			AsyncStatus = *pAsyncStatus;

			RELEASE_LLC_LOCK(irql);

			RELEASE_DRIVER_LOCK();

			if (AsyncStatus != NDIS_STATUS_PENDING) {
				break;
			}
			else{
				KeClearEvent(pEvent);
			}

		}
        KeClearEvent(pEvent);
	}
    return AsyncStatus;
}


DLC_STATUS
LlcNdisRequest(
    IN PVOID hBindingContext,
    IN PLLC_NDIS_REQUEST pDlcParms
    )

/*++

Routine Description:

    makes an NDIS request

Arguments:

    hBindingContext - pointer to binding context
    pDlcParms       - pointer to request-specific parameters

Return Value:

    DLC_STATUS

--*/

{
    return SyncNdisRequest(((PBINDING_CONTEXT)hBindingContext)->pAdapterContext,
                           pDlcParms
                           );
}


VOID
LlcNdisRequestComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    receives control when an aync NDIS command completes

Arguments:

    pAdapterContext - pointer to ADAPTER_CONTEXT for which request was made
    RequestHandle   - handle of request
    NdisStatus      - returned status from NDIS

Return Value:

    None.

--*/

{
    KIRQL irql;
	PLLC_NDIS_REQUEST pLlcNdisRequest =
		CONTAINING_RECORD ( RequestHandle, LLC_NDIS_REQUEST, Ndis );

    UNREFERENCED_PARAMETER(pAdapterContext);

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

	pLlcNdisRequest->AsyncStatus = NdisStatus;

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();

    KeSetEvent(&pLlcNdisRequest->SyncEvent, 0L, FALSE);

}


VOID
LlcNdisReset(
    IN PBINDING_CONTEXT pBindingContext,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine issues a hardware reset command for a network adapter.

Arguments:

    pBindingContext - context of protocol module bound to the data link
    pPacket         - command packet

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pBindingContext->pAdapterContext;
    BOOLEAN ResetIt;
    NDIS_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pPacket->pBinding = pBindingContext;
    pPacket->Data.Completion.CompletedCommand = LLC_RESET_COMPLETION;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    ResetIt = FALSE;
    if (pAdapterContext->pResetPackets != NULL) {
        ResetIt = TRUE;
    }
    pPacket->pNext = pAdapterContext->pResetPackets;
    pAdapterContext->pResetPackets = pPacket;

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // We don't reset NDIS, if there is already a pending reset command
    //

    RELEASE_DRIVER_LOCK();

    if (ResetIt) {
        NdisReset(&Status, pAdapterContext->NdisBindingHandle);
    }

    if (Status != STATUS_PENDING) {
        LlcNdisResetComplete(pAdapterContext, Status);
    }

    //
    // Note: we will return always a pending status =>
    // multiple protocols may issue simultaneous reset
    // and complete it normally.
    //

    ACQUIRE_DRIVER_LOCK();
}


VOID
LlcNdisResetComplete(
    PADAPTER_CONTEXT pAdapterContext,
    NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    The routine is called when a hard reset command is complete.

Arguments:

    pAdapterContext - describes adapter being reset
    NdisStatus      - result of adapter reset operation from NDIS

Return Value:

    None.

--*/

{
    PLLC_PACKET pPacket;

    //
    // this function can be called from an NDIS DPC or from LlcNdisReset (above)
    //

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    //
    // Indicate the completed reset command completion to all
    // protocols, that had a pending reset command.
    //

    for (;;) {

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        pPacket = pAdapterContext->pResetPackets;
        if (pPacket != NULL) {
            pAdapterContext->pResetPackets = pPacket->pNext;
        }

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        if (pPacket == NULL) {
            break;
        } else {
            pPacket->Data.Completion.Status = NdisStatus;
            pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                                 NULL,
                                                 pPacket
                                                 );
        }
    }

    RELEASE_DRIVER_LOCK();
}


BOOLEAN
UnicodeStringCompare(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )

/*++

Routine Description:

    Compare 2 unicode strings. Difference between this and RtlEqualUnicodeString
    is that this is callable from within spinlocks (i.e. non-pageable)

Arguments:

    String1 - pointer to UNICODE_STRING 1
    String2 - pointer to UNICODE_STRING 2

Return Value:

    BOOLEAN
        TRUE    - String1 == String2
        FALSE   - String1 != String2

--*/

{
    if (String1->Length == String2->Length) {

        USHORT numChars = String1->Length / sizeof(*String1->Buffer);
        PWSTR buf1 = String1->Buffer;
        PWSTR buf2 = String2->Buffer;

        while (numChars) {
            if (*buf1++ == *buf2++) {
                --numChars;
            } else {
                return FALSE;
            }
        }
        return TRUE;
    }
    return FALSE;
}


VOID
PurgeLlcEventQueue(
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    If there are any outstanding events on the adapter context waiting to be
    indicated to the client of the current binding, they are removed

Arguments:

    pBindingContext - pointer to BINDING_CONTEXT about to be deleted

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pBindingContext->pAdapterContext;
    ASSUME_IRQL(DISPATCH_LEVEL);

    if (!IsListEmpty(&pAdapterContext->QueueEvents)) {

        PEVENT_PACKET pEventPacket;
        PEVENT_PACKET nextEventPacket;

        for (pEventPacket = (PEVENT_PACKET)pAdapterContext->QueueEvents.Flink;
             pEventPacket != (PEVENT_PACKET)&pAdapterContext->QueueEvents;
             pEventPacket = nextEventPacket) {

            nextEventPacket = pEventPacket->pNext;
            if (pEventPacket->pBinding == pBindingContext) {
                RemoveEntryList((PLIST_ENTRY)&pEventPacket->pNext);

#if DBG
                DbgPrint("PurgeLlcEventQueue: BC=%x PKT=%x\n", pBindingContext, pEventPacket);
#endif

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pEventPacket);

            }
        }
    }
}

#ifdef NDIS40

PADAPTER_CONTEXT
AllocateAdapterContext(
    PNDIS_STRING pAdapterName
    )
{
    PADAPTER_CONTEXT pAdapterContext;
    NDIS_STATUS      NdisStatus = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("+AllocateAdapterContext(%#x)\n"), pAdapterName));
    
    pAdapterContext = (PADAPTER_CONTEXT) ALLOCATE_ZEROMEMORY_DRIVER(
        sizeof(ADAPTER_CONTEXT));

    if (pAdapterContext == NULL)
    {
        NdisStatus = NDIS_STATUS_RESOURCES;
        goto done;
    }
    
    //
    // New PnP structure members.
    //

    REFINIT(
        &pAdapterContext->AdapterRefCnt,
        pAdapterContext,
        CloseAdapter,
        'tpdA');

    KeInitializeEvent(&pAdapterContext->CloseAdapterEvent, NotificationEvent, FALSE);

    pAdapterContext->BindState = BIND_STATE_UNBOUND;

#if DBG

    //
    // record who owns this memory usage structure and add it to the
    // list of all memory usages created in the driver
    //

    pAdapterContext->MemoryUsage.Owner = (PVOID)pAdapterContext;
    pAdapterContext->MemoryUsage.OwnerObjectId = AdapterContextObject;
    pAdapterContext->StringUsage.Owner = (PVOID)pAdapterContext;
    pAdapterContext->StringUsage.OwnerObjectId = AdapterContextObject;
    LinkMemoryUsage(&pAdapterContext->MemoryUsage);
    LinkMemoryUsage(&pAdapterContext->StringUsage);

#endif

    //
    // We must allocate all spinlocks immediately after the
    // adapter context has been allocated, because
    // they can also deallocated simultaneously.
    //

    ALLOCATE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    ALLOCATE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // allocate space for the adapter name string from non-paged pool
    // and initialize the name in the adapter context structure
    //

    NdisStatus = LlcInitUnicodeString(
        &pAdapterContext->Name,
        pAdapterName);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        goto done;
    }

    pAdapterContext->OpenCompleteStatus = NDIS_STATUS_PENDING;

    //
    // We must initialize the list heads before we open the adapter!!!
    //

    InitializeListHead(&pAdapterContext->QueueEvents);
    InitializeListHead(&pAdapterContext->QueueCommands);
    InitializeListHead(&pAdapterContext->NextSendTask);

    pAdapterContext->OpenErrorStatus = NDIS_STATUS_PENDING;

    KeInitializeEvent(&pAdapterContext->Event, NotificationEvent, FALSE);


done:

    if (NdisStatus != NDIS_STATUS_SUCCESS &&
        pAdapterContext)
    {
        FreeAdapterContext(pAdapterContext);
        pAdapterContext = NULL;
    }

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-AllocateAdapterContext [%#x]\n"), NdisStatus));

    return (pAdapterContext);
}


VOID
FreeAdapterContext(
    PADAPTER_CONTEXT pAdapterContext
    )
{
    ASSERT(pAdapterContext);

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("+FreeAdapterContext(%#x)\n"), pAdapterContext));
    
    if (pAdapterContext->hNdisPacketPool)
    {
        //
        // Free MDLs for each NDIS packet.
        //

        while (pAdapterContext->pNdisPacketPool)
        {
            PLLC_NDIS_PACKET pNdisPacket;

            pNdisPacket = PopFromList(((PLLC_PACKET)pAdapterContext->pNdisPacketPool));
            IoFreeMdl(pNdisPacket->pMdl);
            NdisFreePacket((PNDIS_PACKET)pNdisPacket);

            DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
        }

        NdisFreePacketPool(pAdapterContext->hNdisPacketPool);
    }

    if (pAdapterContext->Name.Buffer)
    {
        FREE_STRING_DRIVER(pAdapterContext->Name.Buffer);
    }

    if (pAdapterContext->hLinkPool)
    {
        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hLinkPool);
    }

    if (pAdapterContext->hPacketPool)
    {
        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hPacketPool);
    }

    CHECK_MEMORY_RETURNED_ADAPTER();
    CHECK_STRING_RETURNED_ADAPTER();
    
    UNLINK_MEMORY_USAGE(pAdapterContext);
    UNLINK_STRING_USAGE(pAdapterContext);
    
    FREE_MEMORY_DRIVER(pAdapterContext);
    
    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-FreeAdapterContext\n")));
    
    return;
}


NDIS_STATUS
OpenAdapter(
    PADAPTER_CONTEXT pAdapterContext,
    BOOLEAN          fFirstOpen
    )

/*++

 Routine Description:


 Arguments:

    pAdapterContext - Context describing the adapter to open.
    
    fFirstOpen - On first time opening the adapter, need to configure some
                 ADAPTER_CONTEXT data members.

 Return Value:

    NDIS_STATUS_SUCCESS - Successfully opened the adapter and configured.
    
    

--*/

{
    NDIS_STATUS NdisStatus;
    NTSTATUS    NtStatus;
    UINT        MediumIndex;
    LONG        BindState;

    LLC_NDIS_REQUEST Request;

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("OpenAdapter(%#x) %ws\n"), 
        pAdapterContext, 
        pAdapterContext->Name.Buffer)); // This buffer is null terminated.
    
    KeClearEvent(&pAdapterContext->Event);
    pAdapterContext->OpenErrorStatus = NDIS_STATUS_PENDING;

    // Initialize the event for the request.
    KeInitializeEvent(&Request.SyncEvent, NotificationEvent, FALSE);

    NdisOpenAdapter(
        &NdisStatus,
        &pAdapterContext->OpenErrorStatus,
        &pAdapterContext->NdisBindingHandle,
        &MediumIndex,
        (PNDIS_MEDIUM)&LlcMediumArray[0],
        sizeof(LlcMediumArray),
        (NDIS_HANDLE) LlcProtocolHandle,
        (NDIS_HANDLE) pAdapterContext,
        &pAdapterContext->Name,
        NDIS_OPEN_RECEIVE_NOT_REENTRANT,
        NULL);      // No addressing info.

    if (NdisStatus == NDIS_STATUS_PENDING)
    {
        ASSUME_IRQL(PASSIVE_LEVEL);

        DEBUGMSG(DBG_NDIS_BIND, (TEXT("OpenAdapter - NdisOpenAdapter pending.\n")));
        
        do
        {
            NtStatus = KeWaitForSingleObject(
                &pAdapterContext->Event,
                Executive,
                KernelMode,
                TRUE, // Alertable.
                (PLARGE_INTEGER) NULL);
        } 
        while (NtStatus == STATUS_ALERTED);

        //
        // Get the open return status.
        //

        NdisStatus = pAdapterContext->AsyncOpenStatus;

        KeResetEvent(&pAdapterContext->Event);
    }

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - NdisOpenAdapter failure.\n")));
        pAdapterContext->NdisBindingHandle = NULL;
        goto done;
    }

    //
    // Reference count the NDIS binding handle.
    //

    REFADD(&pAdapterContext->AdapterRefCnt, 'dniB');

    //
    // On the first time opening adapter, we need to initialize some members
    // of the ADAPTER_CONTEXT.
    //

    if (fFirstOpen == TRUE)
    {
        pAdapterContext->NdisMedium = LlcMediumArray[MediumIndex];
    
        DEBUGMSG(DBG_NDIS_BIND,
            (TEXT("OpenAdapter - adapter %ws open, medium = %s (%d)\n"),
            pAdapterContext->Name.Buffer, 
            pAdapterContext->NdisMedium == NdisMedium802_5 ? TEXT("802_5") :
            pAdapterContext->NdisMedium == NdisMedium802_3 ? TEXT("802_3") :
            pAdapterContext->NdisMedium == NdisMediumFddi ? TEXT("Fddi")   : 
                TEXT("Unknown!!"),
            pAdapterContext->NdisMedium));
    
        //
        // fill-in some medium-specific fields
        //
    
        switch (pAdapterContext->NdisMedium)
        {
            case NdisMedium802_5:
                pAdapterContext->cbMaxFrameHeader = 32;  // 6 + 6 + 2 + 18
    
                //
                // the top bit of the destination address signifies a broadcast
                // frame. On Token Ring, the top bit is bit 7
                //
    
                pAdapterContext->IsBroadcast = 0x80;
    
                //
                // functional address starts C0-00-... The top 2 bytes are compared
                // as a USHORT = 0x00C0
                //
    
                pAdapterContext->usHighFunctionalBits = 0x00C0;
                pAdapterContext->AddressTranslationMode = LLC_SEND_802_5_TO_802_5;
                break;
    
            case NdisMedium802_3:
                pAdapterContext->cbMaxFrameHeader = 14;  // 6 + 6 + 2
    
                //
                // the top bit of the destination address signifies a broadcast
                // frame. On Ethernet, the top bit is bit 0
                //
    
                pAdapterContext->IsBroadcast = 0x01;
    
                //
                // functional address starts 03-00-... The top 2 bytes are compared as
                // a USHORT = 0x0003
                //
    
                pAdapterContext->usHighFunctionalBits = 0x0003;
                pAdapterContext->AddressTranslationMode = LLC_SEND_802_3_TO_802_3;
                break;
    
            case NdisMediumFddi:
                pAdapterContext->cbMaxFrameHeader = 13;  // 1 + 6 + 6
    
                //
                // bits are in same order as for ethernet
                //
    
                pAdapterContext->IsBroadcast = 0x01;
                pAdapterContext->usHighFunctionalBits = 0x0003;
                pAdapterContext->AddressTranslationMode = LLC_SEND_FDDI_TO_FDDI;
                break;
        }
    
        //
        // allocate the ndis packets. The NDIS packet must have space
        // for the maximum number frame header and the maximum LLC response
        // and its information field (quite small)
        //
    
        NdisAllocatePacketPool(
            &NdisStatus,
            &pAdapterContext->hNdisPacketPool,
            MAX_NDIS_PACKETS + 1,
            sizeof(LLC_NDIS_PACKET) - sizeof(NDIS_MAC_PACKET));
    
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - NdisAllocatePacketPool failure.\n")));
            goto done;
        }
    
        NdisStatus = InitNdisPackets(
            &pAdapterContext->pNdisPacketPool,
            pAdapterContext->hNdisPacketPool);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - InitNdisPackets failure.\n")));
            goto done;
        }
    
        //
        // Initialize the LLC packet pool
        //
    
        pAdapterContext->hPacketPool = CREATE_PACKET_POOL_ADAPTER(
            LlcPacketPoolObject,
            sizeof(UNITED_PACKETS),
            8);
    
        if (pAdapterContext->hPacketPool == NULL) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - CREATE_PACKET_POOL_ADAPTER hPacketPool failure.\n")));
            NdisStatus = NDIS_STATUS_RESOURCES;
            goto done;
        }
    
        pAdapterContext->hLinkPool = CREATE_PACKET_POOL_ADAPTER(
            LlcLinkPoolObject,
            pAdapterContext->cbMaxFrameHeader + sizeof(DATA_LINK),
            2);
    
        if (pAdapterContext->hLinkPool == NULL) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - CREATE_PACKET_POOL_ADAPTER hLinkPool failure.\n")));
            NdisStatus = NDIS_STATUS_RESOURCES;
            goto done;
        }
    
        //
        // Read the current node address and maximum frame size
        //
    
        // Can't use GetNdisParameter since it checks to see if adapter is bound,
        // which is isn't since we don't want anyone to use it until we are done
        // initialization.
    
    
        Request.Ndis.RequestType = NdisRequestQueryInformation;
        Request.Ndis.DATA.QUERY_INFORMATION.Oid =         
            (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_CURRENT_ADDRESS  : 
            (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_CURRENT_ADDR : 
            OID_802_5_CURRENT_ADDRESS;
    
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = pAdapterContext->NodeAddress;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->NodeAddress);;
    
        Request.AsyncStatus = NDIS_STATUS_PENDING;
        NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
    
        NdisStatus = WaitAsyncOperation(
            &Request.SyncEvent,
            &Request.AsyncStatus,
            NdisStatus);
    
    //  NdisStatus = GetNdisParameter(
    //      pAdapterContext,
    //      (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_CURRENT_ADDRESS  : 
    //      (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_CURRENT_ADDR : 
    //       OID_802_5_CURRENT_ADDRESS,
    //      pAdapterContext->NodeAddress,
    //      sizeof(pAdapterContext->NodeAddress));
        
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - GetNdisParm CURR_ADDRESS failure %#x.\n"),
                NdisStatus));
            goto done;
        }
    
        Request.Ndis.RequestType = NdisRequestQueryInformation;
        Request.Ndis.DATA.QUERY_INFORMATION.Oid =         
            (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_PERMANENT_ADDRESS  : 
            (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_PERMANENT_ADDR : 
            OID_802_5_PERMANENT_ADDRESS;
    
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = pAdapterContext->PermanentAddress;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->PermanentAddress);;
    
        Request.AsyncStatus = NDIS_STATUS_PENDING;
        NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
    
        NdisStatus = WaitAsyncOperation(
            &Request.SyncEvent,
            &Request.AsyncStatus,
            NdisStatus);
    
    //  NdisStatus = GetNdisParameter(
    //      pAdapterContext,
    //      (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_PERMANENT_ADDRESS  : 
        //      (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_PERMANENT_ADDR : 
    //       OID_802_5_PERMANENT_ADDRESS,
    //      pAdapterContext->PermanentAddress,
    //      sizeof(pAdapterContext->PermanentAddress));
    
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - GetNdisParm PERM_ADDRESS failure.\n")));
            goto done;
        }
    
        {
            //
            // Mod RLF 07/10/92
            //
            // apparently, TR adapter does not support NDIS_PACKET_TYPE_MULTICAST
            // as a filter. Up to now, it seems to have been reasonably happy
            // with this type. However, we're not going to include it from now on
            //
    
            //
            // Mod RLF 01/13/93
            //
            // Similarly, Ethernet doesn't support FUNCTIONAL addresses (Token
            // Ring's functional address is equivalent to Ethernet's multicast
            // address)
            //
    
            ULONG PacketFilter = 
                NDIS_PACKET_TYPE_DIRECTED  | 
                NDIS_PACKET_TYPE_BROADCAST | 
                (((pAdapterContext->NdisMedium == NdisMedium802_3) || (pAdapterContext->NdisMedium == NdisMediumFddi))
                                  ? NDIS_PACKET_TYPE_MULTICAST
                                  : NDIS_PACKET_TYPE_FUNCTIONAL);
    
            //
            // EndMod
            //
    
            Request.Ndis.RequestType                                  = NdisRequestSetInformation;
            Request.Ndis.DATA.SET_INFORMATION.Oid                     = OID_GEN_CURRENT_PACKET_FILTER;
            Request.Ndis.DATA.SET_INFORMATION.InformationBuffer       = &PacketFilter;
            Request.Ndis.DATA.SET_INFORMATION.InformationBufferLength = sizeof(PacketFilter);
        
            Request.AsyncStatus = NDIS_STATUS_PENDING;
            NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
        
            NdisStatus = WaitAsyncOperation(
                &Request.SyncEvent,
                &Request.AsyncStatus,
                NdisStatus);
        
    //      NdisStatus = SetNdisParameter(
    //          pAdapterContext,
    //          OID_GEN_CURRENT_PACKET_FILTER,
    //          &PacketFilter,
    //          sizeof(PacketFilter));
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - SetNdisParm PACKET_FILTER failure.\n")));
                ASSERT(FALSE);
                goto done;
            }
        }
    
        LlcMemCpy(
            pAdapterContext->Adapter.Node.auchAddress,
            pAdapterContext->NodeAddress,
            6);
    
        Request.Ndis.RequestType                                    = NdisRequestQueryInformation;
        Request.Ndis.DATA.QUERY_INFORMATION.Oid                     = OID_GEN_MAXIMUM_TOTAL_SIZE;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = &pAdapterContext->MaxFrameSize;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->MaxFrameSize);
    
        Request.AsyncStatus = NDIS_STATUS_PENDING;
        NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
    
        NdisStatus = WaitAsyncOperation(
            &Request.SyncEvent,
            &Request.AsyncStatus,
            NdisStatus);
    
    //  NdisStatus = GetNdisParameter(
    //      pAdapterContext,
    //      OID_GEN_MAXIMUM_TOTAL_SIZE,
    //      &pAdapterContext->MaxFrameSize,
    //      sizeof(pAdapterContext->MaxFrameSize));
    
        if (NdisStatus == STATUS_SUCCESS) 
        {
            Request.Ndis.RequestType                                    = NdisRequestQueryInformation;
            Request.Ndis.DATA.QUERY_INFORMATION.Oid                     = OID_GEN_LINK_SPEED;
            Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = &pAdapterContext->LinkSpeed;
            Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->LinkSpeed);
        
            Request.AsyncStatus = NDIS_STATUS_PENDING;
            NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
        
            NdisStatus = WaitAsyncOperation(
                &Request.SyncEvent,
                &Request.AsyncStatus,
                NdisStatus);
        
    //      NdisStatus = GetNdisParameter(
    //          pAdapterContext,
    //          OID_GEN_LINK_SPEED,
    //          &pAdapterContext->LinkSpeed,
    //          sizeof(pAdapterContext->LinkSpeed));
        }
    
        if (NdisStatus != STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - GetNdisParm MAX_SIZE/LINK_SPEED failure.\n")));
            goto done;
        }
    
        //
        // RLF 04/12/93
        //
        // Here we used to load the LLC_TICKS array from TimerTicks - a global
        // array of timer tick values.
        // Instead, we get any per-adapter configuration information stored in
        // the registry
        //
    
        LoadAdapterConfiguration(
            &pAdapterContext->Name,
            &pAdapterContext->ConfigInfo);
    
    
        //
        // RLF 04/02/94
        //
        // if this is not a Token Ring card then check the MaxFrameSize retrieved
        // above. If the UseEthernetFrameSize parameter was set in the registry
        // then we use the smaller of the ethernet size (1514) and the value
        // reported by the MAC. If the parameter was not set then we just use
        // the value already retrieved. If the card is Token Ring then we use
        // the value already retrieved
        //
    
        if (pAdapterContext->NdisMedium != NdisMedium802_5   && 
            pAdapterContext->ConfigInfo.UseEthernetFrameSize && 
            pAdapterContext->MaxFrameSize > MAX_ETHERNET_FRAME_LENGTH) 
        {
            pAdapterContext->MaxFrameSize = MAX_ETHERNET_FRAME_LENGTH;
        }
        
        pAdapterContext->QueueI.pObject = (PVOID)GetI_Packet;
    
        InitializeListHead(&pAdapterContext->QueueI.ListHead);
    
        pAdapterContext->QueueDirAndU.pObject = (PVOID)BuildDirOrU_Packet;
    
        InitializeListHead(&pAdapterContext->QueueDirAndU.ListHead);
    
        pAdapterContext->QueueExpidited.pObject = (PVOID)GetLlcCommandPacket;
    
        InitializeListHead(&pAdapterContext->QueueExpidited.ListHead);
    
        pAdapterContext->OpenCompleteStatus = STATUS_SUCCESS;
    }
    else
    {
        //
        // Re-opening adapter. Don't really need to do much configuration.
        // Need to set packet filter.
        //

        // Still should be same medium for the adapter.
        ASSERT(pAdapterContext->NdisMedium == LlcMediumArray[MediumIndex]);
        
        {
            //
            // Mod RLF 07/10/92
            //
            // apparently, TR adapter does not support NDIS_PACKET_TYPE_MULTICAST
            // as a filter. Up to now, it seems to have been reasonably happy
            // with this type. However, we're not going to include it from now on
            //
    
            //
            // Mod RLF 01/13/93
            //
            // Similarly, Ethernet doesn't support FUNCTIONAL addresses (Token
            // Ring's functional address is equivalent to Ethernet's multicast
            // address)
            //
    
            ULONG PacketFilter = 
                NDIS_PACKET_TYPE_DIRECTED  | 
                NDIS_PACKET_TYPE_BROADCAST | 
                (((pAdapterContext->NdisMedium == NdisMedium802_3) || (pAdapterContext->NdisMedium == NdisMediumFddi))
                                  ? NDIS_PACKET_TYPE_MULTICAST
                                  : NDIS_PACKET_TYPE_FUNCTIONAL);
    
            //
            // EndMod
            //
    
            Request.Ndis.RequestType                                  = NdisRequestSetInformation;
            Request.Ndis.DATA.SET_INFORMATION.Oid                     = OID_GEN_CURRENT_PACKET_FILTER;
            Request.Ndis.DATA.SET_INFORMATION.InformationBuffer       = &PacketFilter;
            Request.Ndis.DATA.SET_INFORMATION.InformationBufferLength = sizeof(PacketFilter);
        
            Request.AsyncStatus = NDIS_STATUS_PENDING;
            NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
        
            NdisStatus = WaitAsyncOperation(
                &Request.SyncEvent,
                &Request.AsyncStatus,
                NdisStatus);
        
    //      NdisStatus = SetNdisParameter(
    //          pAdapterContext,
    //          OID_GEN_CURRENT_PACKET_FILTER,
    //          &PacketFilter,
    //          sizeof(PacketFilter));
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - SetNdisParm PACKET_FILTER failure.\n")));
                ASSERT(FALSE);
                goto done;
            }
        }
    
    }

    //
    // Adapter can now be used, so put state to bound. Sends and requests
    // will fail if the state is not BIND_STATE_BOUND.
    //

    BindState = InterlockedExchange(&pAdapterContext->BindState, BIND_STATE_BOUND);
    ASSERT(BindState == BIND_STATE_UNBOUND);

done:

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (pAdapterContext->NdisBindingHandle != NULL)
        {
            NDIS_STATUS CloseNdisStatus;

            pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;

            NdisCloseAdapter(
                &CloseNdisStatus,
                pAdapterContext->NdisBindingHandle);

            WaitAsyncOperation(
                &pAdapterContext->Event,
                &pAdapterContext->AsyncCloseResetStatus,
                CloseNdisStatus);

            pAdapterContext->NdisBindingHandle = NULL;
            
            REFDEL(&pAdapterContext->AdapterRefCnt, 'dniB');
        }
    }

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-OpenAdapter - Adapter %#x [%#x]\n"), 
        pAdapterContext, NdisStatus));
    
    return (NdisStatus);
}


VOID
CloseAdapter(
    PVOID pv_pAdapterContext
    )

/*++

 Routine Description:

    This function is called when the reference count on the NdisBindingHandle
    for the AdapterContext goes to zero. The CloseAdapterEvent is set to
    indicate to the unbind handler that all references to the adapter are 
    removed and it can complete the unbind/close adapter.

 Arguments:

    pv_pAdapterContext - Context describing open adapter.

 Return Value:

    None.

    
--*/

{
    PADAPTER_CONTEXT pAdapterContext = (PADAPTER_CONTEXT) pv_pAdapterContext;
    KeSetEvent(&pAdapterContext->CloseAdapterEvent, 0L, FALSE); 
}


VOID
LlcBindAdapterHandler(
    OUT PNDIS_STATUS  pStatus,
    IN  NDIS_HANDLE   BindContext,
    IN  PNDIS_STRING  pDeviceName,
    IN  PVOID         SystemSpecific1,
    IN  PVOID         SystemSpecific2
    )

/*++

 Routine Description:

    Protocol bind adapter handler. This is called by NDIS to bind
    to an adapter.

 Arguments:

    pStatus - The status to returned by this bind adapter call.

    BindContext - Handle used when indicating completion using
                  NdisCompleteBindAdapter.

    pDeviceName - Zero-terminated Unicode string  with the name of the
                  underlying NIC to bind to.

    SystemSpecific1 - Registry path used by NdisOpenProtocolConfiguration.

    SystemSpecific2 - Reserved.

 Return Value:

    None.

 Notes:

    Runs at IRQL_PASSIVE_LEVEL.
    
    This function creates an ADAPTER_CONTEXT, initializes it and opens the
    adapter. This adapter is stored in a global adapter list so that DLC
    can find and use the adapter context.

--*/
{
    PADAPTER_CONTEXT    pAdapterContext = NULL;
    NDIS_STATUS         NdisStatus      = NDIS_STATUS_SUCCESS;
    BOOLEAN             fNewAdapter     = FALSE;

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("+LlcBindAdapterHandler(%#x, %#x, %#x, %#x %#x)\n"),
        pStatus, BindContext, pDeviceName, 
        SystemSpecific1, SystemSpecific2));
    
    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    //
    // Check for re-bind case.
    //

    for (pAdapterContext = pAdapters; 
         pAdapterContext != NULL; 
         pAdapterContext = pAdapterContext->pNext)
    {
        if (UnicodeStringCompare(pDeviceName, &pAdapterContext->Name))
        {
            // Found the adapter.
            break;
        }
    }

    if (pAdapterContext == NULL)
    {
        pAdapterContext = AllocateAdapterContext(pDeviceName);

        if (pAdapterContext == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            goto done;
        }

        fNewAdapter = TRUE;
    }
    else
    {
        // 
        // ADAPTER_CONTEXT already exists. This must be the re-bind scenario.
        //

        ASSERT(pAdapterContext->BindState == BIND_STATE_UNBOUND);
    }

    //
    // Open the NDIS adapter. OpenAdapter should not return pending.
    //

    NdisStatus = OpenAdapter(pAdapterContext, fNewAdapter);
    ASSERT(NdisStatus != NDIS_STATUS_PENDING);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("LlcBindAdapterHandler - OpenAdapter failure.\n")));
        goto done;
    }

    //
    // If we just created this adapter context, then put in global adapter
    // list.
    //

    if (fNewAdapter == TRUE)
    {
        pAdapterContext->pNext = pAdapters;
        pAdapters              = pAdapterContext;
    }
                    
done:

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);
    
    // All above requests were serialized.
    ASSERT(NdisStatus != NDIS_STATUS_PENDING);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (pAdapterContext && fNewAdapter == TRUE)
        {
            ASSERT(pAdapterContext->pNext == NULL);
            FreeAdapterContext(pAdapterContext);
        }
    }

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-LlcBindAdapter [%#x]\n"), NdisStatus));
    
    *pStatus = NdisStatus;
    return;
}


VOID
LlcUnbindAdapterHandler(
    OUT PNDIS_STATUS pStatus,
    IN  NDIS_HANDLE  ProtocolBindingContext,
    IN  NDIS_HANDLE  UnbindContext
    )

/*++

 Routine Description:

    This is called by NDIS to unbind an adapter.

 Arguments:

    pStatus - The status to be returned by this unbind adapter call.

    ProtocolBindingContext - Protocol allocated binding context to the adapter
                             to unbind to.

    UnbindContext - Handle used when indicating completion using
                    NdisCompleteUnbindAdapter.

 Return Value:

    None.

 Notes:

    Runs at IRQL_PASSIVE_LEVEL.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = (PADAPTER_CONTEXT) ProtocolBindingContext;
    LONG             BindState;
    NDIS_STATUS      NdisStatus;

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("+LlcUnbindAdapterHandler(%#x, %#x, %#x)\n"), 
        pStatus, ProtocolBindingContext, UnbindContext));
    
    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    //
    // Update bind state.
    // 

    BindState = InterlockedExchange(
        &pAdapterContext->BindState,
        BIND_STATE_UNBINDING);

    ASSERT(BindState == BIND_STATE_BOUND);

    //
    // Remove the reference count that NDIS has on the adapter handle since we 
    // will close the adapter.
    //

    KeResetEvent(&pAdapterContext->CloseAdapterEvent);
    REFDEL(&pAdapterContext->AdapterRefCnt, 'dniB');

    //
    // Wait until the reference goes to zero, then we are signalled. The above
    // REFDEL would have signalled the event if this is the last reference.
    //

    KeWaitForSingleObject(
        &pAdapterContext->CloseAdapterEvent,
        Executive,
        KernelMode,
        FALSE,
        NULL);
    
    //
    // Now we can safely close the NdisBindingHandle.
    //

    pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;
    ASSERT(pAdapterContext->NdisBindingHandle);

    NdisCloseAdapter(
        &NdisStatus,
        pAdapterContext->NdisBindingHandle);

    NdisStatus = WaitAsyncOperation(
        &pAdapterContext->Event,
        &(pAdapterContext->AsyncCloseResetStatus),
        NdisStatus);

    ASSERT(NdisStatus != NDIS_STATUS_PENDING);
    pAdapterContext->NdisBindingHandle = NULL;

    //
    // Update state.
    //

    BindState = InterlockedExchange(
        &pAdapterContext->BindState, 
        BIND_STATE_UNBOUND);

    ASSERT(BindState == BIND_STATE_UNBINDING);

    //
    // Clean up and save status before completing.
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

    *pStatus = NdisStatus;

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-LlcUnbindAdapterHandler [%#x]\n"), NdisStatus));
    
    return;
}


NDIS_STATUS
LlcPnPEventHandler(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          pNetPnPEvent
    )

/*++

 Routine Description:

    PnP events indicated to the protocol. Currently, we are only interested
    in the binds complete event.

 Arguments:

    ProtocolBindingContext - Protocol allocated binding context to the adapter.
                             This can be NULL for some events.

    pNetPnPEvent - Describes PnP event.

 Return Value:

    NDIS_STATUS_SUCCESS     - Always return success, even for those PnP events
                              which are not supported.

--*/

{
    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventBindsComplete:

            //
            // Block all LlcOpenAdapter requests until we are sure all adapters
            // have been indicated to the protocol.
            //

            NdisSetEvent(&PnPBindsComplete);
            break;
    }

    return (NDIS_STATUS_SUCCESS);
}


VOID
CloseAllAdapters(
    )

/*++

 Routine Description:
       
    Closes all adapters. This should only be called from the unload 
    routine.

 Arguments:
 
    None.

 Return Value:
 
    None.

--*/

{

    PADAPTER_CONTEXT pAdapterContext;
    PADAPTER_CONTEXT pNextAdapter;
    LONG             BindState;
    NDIS_STATUS      NdisStatus;

    DEBUGMSG(DBG_NDIS_OPEN, (TEXT("+CloseAllAdapters()\n")));

    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    pAdapterContext = pAdapters;
    
    while (pAdapterContext)
    {
        // Save next adapter since we are going to free memory.
        pNextAdapter = pAdapterContext->pNext;

        //
        // Update bind state.
        // 
    
        BindState = InterlockedExchange(
            &pAdapterContext->BindState,
            BIND_STATE_UNBINDING);
    
        if (BindState == BIND_STATE_BOUND)
        {
            //
            // Poll to see if any objects are still attached to adapter.
            //
    
            DEBUGMSG(DBG_WARN && pAdapterContext,
                (TEXT("CloseAllAdapters - waiting for adapter LLC objects to close...\n")));
            
            while (pAdapterContext->ObjectCount)
            {
                DEBUGMSG(DBG_WARN && DBG_VERBOSE,
                    (TEXT("CloseAllAdapters - still waiting...\n")));
                
                LlcSleep(1000L); // 1ms
            }
    
            //
            // Remove the reference count that NDIS has on the adapter handle since we 
            // will close the adapter.
            //
        
            KeResetEvent(&pAdapterContext->CloseAdapterEvent);
            REFDEL(&pAdapterContext->AdapterRefCnt, 'dniB');
        
            //
            // Wait until the reference goes to zero, then we are signalled. The above
            // REFDEL would have signalled the event if this is the last reference.
            //
        
            KeWaitForSingleObject(
                &pAdapterContext->CloseAdapterEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
            
            //
            // Now we can safely close the NdisBindingHandle.
            //
        
            pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;
            ASSERT(pAdapterContext->NdisBindingHandle);
        
            NdisCloseAdapter(
                &NdisStatus,
                pAdapterContext->NdisBindingHandle);
        
            NdisStatus = WaitAsyncOperation(
                &pAdapterContext->Event,
                &(pAdapterContext->AsyncCloseResetStatus),
                NdisStatus);
        
            ASSERT(NdisStatus != NDIS_STATUS_PENDING);
            pAdapterContext->NdisBindingHandle = NULL;
        
            //
            // Update state.
            //
        
            BindState = InterlockedExchange(
                &pAdapterContext->BindState, 
                BIND_STATE_UNBOUND);
        
            ASSERT(BindState == BIND_STATE_UNBINDING);
        }

        // Remove adapter from the list.
        RemoveFromLinkList((PVOID *)&pAdapters, pAdapterContext);

        FreeAdapterContext(pAdapterContext);

        // Adjust pointer.
        pAdapterContext = pNextAdapter;
    }
    
    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

    DEBUGMSG(DBG_NDIS_OPEN, (TEXT("-CloseAllAdapters\n")));
    
    return;
}

#endif // NDIS40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcmem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcmem.c

Abstract:

    Functions for allocating & freeing memory. Split out from llclib.c. The
    reasons this module created are to isolate the memory allocators and to
    convert from using the Zone package to just using non-paged pool for all
    of DLC's memory requirements.

    Functions in this module are used by both DLC & LLC. These functions must
    go into a statically-linked library if DLC is ever divorced from LLC

    We use pools to avoid the overhead of calling the system allocation & free
    functions (although in practice, we end up allocating additional memory
    because the packet count in the pool is usually insufficient). The downside
    is that we may allocate memory that in the majority of situations is not
    used, but the packets in pools tend to be small and few in number

    To aid in tracking memory resources, DLC/LLC now defines the following
    memory categories:

        Memory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...)

        ZeroMemory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...) and initialized to zeroes

        Pool
            - small sets of (relatively) small packets are allocated in one
              block from Memory or ZeroMemory as a Pool and then subdivided
              into packets (CreatePacketPool, DeletePacketPool, AllocatePacket,
              DeallocatePacket)

        Object
            - structures which may be packets allocated from Pool which have
              a known size and initialization values. Pseudo-category mainly
              for debugging purposes

    Contents:
        InitializeMemoryPackage (DEBUG)
        PullEntryList           (DEBUG)
        LinkMemoryUsage         (DEBUG)
        UnlinkMemoryUsage       (DEBUG)
        ChargeNonPagedPoolUsage (DEBUG)
        RefundNonPagedPoolUsage (DEBUG)
        AllocateMemory          (DEBUG)
        AllocateZeroMemory
        DeallocateMemory        (DEBUG)
        AllocateObject          (DEBUG)
        FreeObject              (DEBUG)
        ValidateObject          (DEBUG)
        GetObjectSignature      (DEBUG)
        GetObjectBaseSize       (DEBUG)
        CreatePacketPool
        DeletePacketPool
        AllocatePacket
        DeallocatePacket
        CreateObjectPool        (DEBUG)
        AllocatePoolObject      (DEBUG)
        DeallocatePoolObject    (DEBUG)
        DeleteObjectPool        (DEBUG)
        CheckMemoryReturned     (DEBUG)
        CheckDriverMemoryUsage  (DEBUG)
        MemoryAllocationError   (DEBUG)
        UpdateCounter           (DEBUG)
        MemoryCounterOverflow   (DEBUG)
        DumpMemoryMetrics       (DEBUG)
        DumpPoolStats           (DEBUG)
        MapObjectId             (DEBUG)
        DumpPool                (DEBUG)
        DumpPoolList            (DEBUG)
        DumpPacketHead          (DEBUG)
        DumpMemoryUsageList     (DEBUG)
        DumpMemoryUsage         (DEBUG)
        x86SleazeCallersAddress (DEBUG)
        CollectReturnAddresses  (DEBUG)
        GetLastReturnAddress    (DEBUG)
        VerifyElementOnList     (DEBUG)
        CheckList               (DEBUG)
        CheckEntryOnList        (DEBUG)
        DumpPrivateMemoryHeader (DEBUG)
        ReportSwitchSettings    (DEBUG)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    kernel mode only.

Notes:

    In non-debug version, DeallocateMemory is replaced with a macro which calls
    ExFreePool(...) and AllocateMemory is replaced by a macro which calls
    ExAllocatePool(NonPagedPool, ...)

Revision History:

    09-Mar-1993 RFirth
        Created

--*/

#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif

#include <ntddk.h>
#include <ndis.h>
#define APIENTRY
#include <dlcapi.h>
#include <dlcio.h>
#include "llcapi.h"
#include "dlcdef.h"
#include "dlcreg.h"
#include "dlctyp.h"
#include "llcdef.h"
#include "llcmem.h"
#include "llctyp.h"

#define DWORD_ROUNDUP(d)    (((d) + 3) & ~3)

#define YES_NO(thing)       ((thing) ? "Yes" : "No")


#if DBG

//
// some variables to keep track of memory allocations from non-paged pool. These
// are the cumulative totals for all of DLC's non-paged pool memory usage
//

KSPIN_LOCK MemoryCountersLock;
KIRQL MemoryCountersIrql;

ULONG GoodNonPagedPoolAllocs = 0;
ULONG BadNonPagedPoolAllocs = 0;
ULONG GoodNonPagedPoolFrees = 0;
ULONG BadNonPagedPoolFrees = 0;
ULONG NonPagedPoolRequested = 0;
ULONG NonPagedPoolAllocated = 0;
ULONG TotalNonPagedPoolRequested = 0;
ULONG TotalNonPagedPoolAllocated = 0;
ULONG TotalNonPagedPoolFreed = 0;

KSPIN_LOCK MemoryAllocatorLock;
ULONG InMemoryAllocator = 0;

KSPIN_LOCK PoolCreatorLock;
ULONG InPoolCreator = 0;

//
// MemoryUsageList - linked list of all MEMORY_USAGE structures in driver. If we
// allocate something that has a MEMORY_USAGE structure (& what doesn't?) then
// don't delete it, we can later scan this list to find out what is still allocated
//

PMEMORY_USAGE MemoryUsageList = NULL;
KSPIN_LOCK MemoryUsageLock;

//
// flags to aid in debugging - change states via debugger
//

//BOOLEAN DebugDump = TRUE;
BOOLEAN DebugDump = FALSE;

//BOOLEAN DeleteBusyListAnyway = TRUE;
BOOLEAN DeleteBusyListAnyway = FALSE;

BOOLEAN MemoryCheckNotify = TRUE;
//BOOLEAN MemoryCheckNotify = FALSE;

BOOLEAN MemoryCheckStop = TRUE;
//BOOLEAN MemoryCheckStop = FALSE;

BOOLEAN MaintainPrivateLists = TRUE;
//BOOLEAN MaintainPrivateLists = FALSE;

BOOLEAN MaintainGlobalLists = TRUE;
//BOOLEAN MaintainGlobalLists = FALSE;

BOOLEAN ZapDeallocatedPackets = TRUE;
//BOOLEAN ZapDeallocatedPackets = FALSE;

BOOLEAN ZapFreedMemory = TRUE;
//BOOLEAN ZapFreedMemory = FALSE;

//
// DlcGlobalMemoryList - every block that is allocated is linked to this list
// and removed when deleted. Helps us keep track of who allocated which block
//

KSPIN_LOCK DlcGlobalMemoryListLock;
LIST_ENTRY DlcGlobalMemoryList;
ULONG DlcGlobalMemoryListCount = 0;

//
// local function prototypes
//

VOID MemoryAllocationError(PCHAR, PVOID);
VOID UpdateCounter(PULONG, LONG);
VOID MemoryCounterOverflow(PULONG, LONG);
VOID DumpMemoryMetrics(VOID);
VOID DumpPoolStats(PCHAR, PPACKET_POOL);
PCHAR MapObjectId(DLC_OBJECT_TYPE);
VOID DumpPool(PPACKET_POOL);
VOID DumpPoolList(PCHAR, PSINGLE_LIST_ENTRY);
VOID DumpPacketHead(PPACKET_HEAD, ULONG);
VOID DumpMemoryUsageList(VOID);
VOID DumpMemoryUsage(PMEMORY_USAGE, BOOLEAN);
VOID CollectReturnAddresses(PVOID*, ULONG, ULONG);
PVOID* GetLastReturnAddress(PVOID**);
VOID x86SleazeCallersAddress(PVOID*, PVOID*);
BOOLEAN VerifyElementOnList(PSINGLE_LIST_ENTRY, PSINGLE_LIST_ENTRY);
VOID CheckList(PSINGLE_LIST_ENTRY, ULONG);
VOID CheckEntryOnList(PLIST_ENTRY, PLIST_ENTRY, BOOLEAN);
VOID DumpPrivateMemoryHeader(PPRIVATE_NON_PAGED_POOL_HEAD);
VOID ReportSwitchSettings(PSTR);

#define GRAB_SPINLOCK() KeAcquireSpinLock(&MemoryCountersLock, &MemoryCountersIrql)
#define FREE_SPINLOCK() KeReleaseSpinLock(&MemoryCountersLock, MemoryCountersIrql)

#ifdef i386
#define GET_CALLERS_ADDRESS x86SleazeCallersAddress
#else
#define GET_CALLERS_ADDRESS RtlGetCallersAddress
#endif

//
// private prototypes
//

ULONG
GetObjectSignature(
    IN DLC_OBJECT_TYPE ObjectType
    );

ULONG
GetObjectBaseSize(
    IN DLC_OBJECT_TYPE ObjectType
    );

#else

#define GRAB_SPINLOCK()
#define FREE_SPINLOCK()

#endif

//
// functions
//



#if DBG

VOID
InitializeMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Performs initialization for memory allocation functions

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeInitializeSpinLock(&MemoryCountersLock);
    KeInitializeSpinLock(&MemoryAllocatorLock);
    KeInitializeSpinLock(&PoolCreatorLock);
    KeInitializeSpinLock(&MemoryUsageLock);
    KeInitializeSpinLock(&DlcGlobalMemoryListLock);
    DriverMemoryUsage.OwnerObjectId = DlcDriverObject;
    DriverMemoryUsage.OwnerInstance = 0x4D454D; // 'MEM'
    InitializeListHead(&DriverMemoryUsage.PrivateList);
    LinkMemoryUsage(&DriverMemoryUsage);
    DriverStringUsage.OwnerObjectId = DlcDriverObject;
    DriverStringUsage.OwnerInstance = 0x535452; // 'STR'
    InitializeListHead(&DriverStringUsage.PrivateList);
    LinkMemoryUsage(&DriverStringUsage);
    InitializeListHead(&DlcGlobalMemoryList);
    ReportSwitchSettings("DLC.InitializeMemoryPackage (DEBUG version only)");
}


PSINGLE_LIST_ENTRY
PullEntryList(
    IN PSINGLE_LIST_ENTRY List,
    IN PSINGLE_LIST_ENTRY Element
    )

/*++

Routine Description:

    The missing SINGLE_LIST_ENTRY function. Removes an entry from a single-linked
    list. The entry can be anywhere on the list. Reduces size of list elements
    by one pointer, at expense of increased time to traverse list.

    This function SHOULD NOT return NULL: if it does then the code is broken
    since it assumes that an element is on a list, when it ain't

Arguments:

    List    - pointer to singly-linked list anchor. This MUST be the address of
              the pointer to the list, not the first element in the list
    Element - pointer to element to remove from List

Return Value:

    PSINGLE_LIST_ENTRY
        Success - Element
        Failure - NULL

--*/

{
    PSINGLE_LIST_ENTRY prev = List;

    ASSERT(List);
    ASSERT(Element);

    while (List = List->Next) {
        if (List == Element) {
            prev->Next = Element->Next;
            return Element;
        }
        prev = List;
    }
    return NULL;
}


VOID
LinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    )

/*++

Routine Description:

    Add pMemoryUsage to linked list of MEMORY_USAGE structures

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure to add

Return Value:

    None.

--*/

{
    KIRQL irql;

    KeAcquireSpinLock(&MemoryUsageLock, &irql);
    PushEntryList((PSINGLE_LIST_ENTRY)&MemoryUsageList, (PSINGLE_LIST_ENTRY)pMemoryUsage);
    KeReleaseSpinLock(&MemoryUsageLock, irql);
}


VOID
UnlinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    )

/*++

Routine Description:

    Remove pMemoryUsage from linked list of MEMORY_USAGE structures

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure to remove

Return Value:

    None.

--*/

{
    KIRQL irql;

    ASSERT(pMemoryUsage);
    CheckMemoryReturned(pMemoryUsage);
    KeAcquireSpinLock(&MemoryUsageLock, &irql);
    ASSERT(PullEntryList((PSINGLE_LIST_ENTRY)&MemoryUsageList, (PSINGLE_LIST_ENTRY)pMemoryUsage));
    KeReleaseSpinLock(&MemoryUsageLock, irql);
}


VOID
ChargeNonPagedPoolUsage(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size,
    IN PPRIVATE_NON_PAGED_POOL_HEAD Block
    )

/*++

Routine Description:

    Charges this non-paged pool allocation to a specific memory user

Arguments:

    pMemoryUsage    - pointer to structure recording memory usage
    Size            - size of block allocated
    Block           - pointer to private header of allocated block

Return Value:

    None.

--*/

{
    KIRQL irql;

    KeAcquireSpinLock(&pMemoryUsage->SpinLock, &irql);
    if (pMemoryUsage->NonPagedPoolAllocated + Size < pMemoryUsage->NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            DbgPrint("DLC.ChargeNonPagedPoolUsage: Overcharged? Usage @ %08x\n", pMemoryUsage);
        }
        if (MemoryCheckStop) {
            DumpMemoryUsage(pMemoryUsage, TRUE);
            DbgBreakPoint();
        }
    }
    pMemoryUsage->NonPagedPoolAllocated += Size;
    ++pMemoryUsage->AllocateCount;

    //
    // link this block to the memory usage private list
    //

    if (MaintainPrivateLists) {
        if (pMemoryUsage->PrivateList.Flink == NULL) {

            //
            // slight hack to make initializing MEMORY_USAGEs easier...
            //

            InitializeListHead(&pMemoryUsage->PrivateList);
        }
        InsertTailList(&pMemoryUsage->PrivateList, &Block->PrivateList);
    }
    KeReleaseSpinLock(&pMemoryUsage->SpinLock, irql);
}


VOID
RefundNonPagedPoolUsage(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size,
    IN PPRIVATE_NON_PAGED_POOL_HEAD Block
    )

/*++

Routine Description:

    Refunds a non-paged pool allocation to a specific memory user

Arguments:

    pMemoryUsage    - pointer to structure recording memory usage
    Size            - size of block allocated
    Block           - pointer to private header of allocated block

Return Value:

    None.

--*/

{
    KIRQL irql;

    KeAcquireSpinLock(&pMemoryUsage->SpinLock, &irql);
    if (pMemoryUsage->NonPagedPoolAllocated - Size > pMemoryUsage->NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            DbgPrint("DLC.RefundNonPagedPoolUsage: Error: Freeing unallocated memory? Usage @ %08x, %d\n",
                     pMemoryUsage,
                     Size
                     );
        }
        if (MemoryCheckStop) {
            DumpMemoryUsage(pMemoryUsage, TRUE);
            DbgBreakPoint();
        }
    }

    //
    // unlink this block from the memory usage private list
    //

    if (MaintainPrivateLists) {
        CheckEntryOnList(&Block->PrivateList, &pMemoryUsage->PrivateList, TRUE);
        RemoveEntryList(&Block->PrivateList);
    }
    pMemoryUsage->NonPagedPoolAllocated -= Size;
    ++pMemoryUsage->FreeCount;
    KeReleaseSpinLock(&pMemoryUsage->SpinLock, irql);
}


PVOID
AllocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory out of non-paged pool. For the debug version, we round up
    the requested size to the next 4-byte boundary and we add header and tail
    sections which contain a signature to check for over-write, and in-use and
    size information

    In the non-debug version, this function is replaced by a call to
    ExAllocatePool(NonPagedPool, ...)

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    Size            - number of bytes to allocate

Return Value:

    PVOID
        Success - pointer to allocated memory
        Failure - NULL

--*/

{
    PVOID pMem;
    ULONG OriginalSize = Size;
    PUCHAR pMemEnd;

/*
    KIRQL irql;

    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateMemory: Error: Memory allocator clash on entry. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    ++InMemoryAllocator;
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    Size = DWORD_ROUNDUP(Size)
         + sizeof(PRIVATE_NON_PAGED_POOL_HEAD)
         + sizeof(PRIVATE_NON_PAGED_POOL_TAIL);

    pMem = ExAllocatePoolWithTag(NonPagedPool, (ULONG)Size, DLC_POOL_TAG);
    if (pMem) {
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->OriginalSize = OriginalSize;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Flags = MEM_FLAGS_IN_USE;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Signature = SIGNATURE1;

        pMemEnd = (PUCHAR)pMem
                + DWORD_ROUNDUP(OriginalSize)
                + sizeof(PRIVATE_NON_PAGED_POOL_HEAD);

        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Signature = SIGNATURE2;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern1 = PATTERN1;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern2 = PATTERN2;

        GRAB_SPINLOCK();
        UpdateCounter(&GoodNonPagedPoolAllocs, 1);
        UpdateCounter(&NonPagedPoolAllocated, (LONG)Size);
        UpdateCounter(&NonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolAllocated, (LONG)Size);
        FREE_SPINLOCK();

        if (MaintainGlobalLists) {

            KIRQL irql;

            //
            // record the caller and add this block to the global list
            //

            GET_CALLERS_ADDRESS(&((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[0],
                                &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[1]
                                );
            KeAcquireSpinLock(&DlcGlobalMemoryListLock, &irql);
            InsertTailList(&DlcGlobalMemoryList,
                           &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->GlobalList
                           );
            ++DlcGlobalMemoryListCount;
            KeReleaseSpinLock(&DlcGlobalMemoryListLock, irql);
        }
        ChargeNonPagedPoolUsage(pMemoryUsage, Size, (PPRIVATE_NON_PAGED_POOL_HEAD)pMem);
        pMem = (PVOID)((PUCHAR)pMem + sizeof(PRIVATE_NON_PAGED_POOL_HEAD));
    } else {
        GRAB_SPINLOCK();
        UpdateCounter(&BadNonPagedPoolAllocs, 1);
        FREE_SPINLOCK();
    }

/*
    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    --InMemoryAllocator;
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateMemory: Error: Memory allocator clash on exit. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    return pMem;
}


VOID
DeallocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID Pointer
    )

/*++

Routine Description:

    frees memory to non-paged pool

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    Pointer         - pointer to previously allocated non-paged pool memory

Return Value:

    None.

--*/

{
    PPRIVATE_NON_PAGED_POOL_HEAD pHead;
    PPRIVATE_NON_PAGED_POOL_TAIL pTail;

/*
    KIRQL irql;

    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    if (InMemoryAllocator) {
        DbgPrint("DLC.DeallocateMemory: Error: Memory allocator clash on entry. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    ++InMemoryAllocator;
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    pHead = (PPRIVATE_NON_PAGED_POOL_HEAD)((PUCHAR)Pointer - sizeof(PRIVATE_NON_PAGED_POOL_HEAD));
    pTail = (PPRIVATE_NON_PAGED_POOL_TAIL)((PUCHAR)pHead + pHead->Size - sizeof(PRIVATE_NON_PAGED_POOL_TAIL));

    if (MaintainGlobalLists) {
        CheckEntryOnList(&pHead->GlobalList, &DlcGlobalMemoryList, TRUE);

        if (pHead->GlobalList.Flink == NULL
        || pHead->GlobalList.Blink == NULL) {
            if (MemoryCheckNotify) {
                DbgPrint("DLC.DeallocateMemory: Error: Block already globally freed: %08x\n", pHead);
            }
            if (MemoryCheckStop) {
                DbgBreakPoint();
            }
        }
    }

    if (pHead->Signature != SIGNATURE1
    || !(pHead->Flags & MEM_FLAGS_IN_USE)
    || pTail->Size != pHead->Size
    || pTail->Signature != SIGNATURE2
    || pTail->Pattern1 != PATTERN1
    || pTail->Pattern2 != PATTERN2) {
        if (MemoryCheckNotify || MemoryCheckStop) {
            MemoryAllocationError("DeallocateMemory", (PVOID)pHead);
        }
        GRAB_SPINLOCK();
        UpdateCounter(&BadNonPagedPoolFrees, 1);
        FREE_SPINLOCK();
    } else {
        GRAB_SPINLOCK();
        UpdateCounter(&GoodNonPagedPoolFrees, 1);
        FREE_SPINLOCK();
    }
    GRAB_SPINLOCK();
    UpdateCounter(&NonPagedPoolRequested, -(LONG)pHead->OriginalSize);
    UpdateCounter(&NonPagedPoolAllocated, -(LONG)pHead->Size);
    UpdateCounter(&TotalNonPagedPoolFreed, (LONG)pHead->Size);
    FREE_SPINLOCK();

    //
    // access Size field before ExFreePool zaps it/somebody else allocates memory
    //

    RefundNonPagedPoolUsage(pMemoryUsage, pHead->Size, pHead);

    if (MaintainGlobalLists) {

        //
        // remove this block from the global list
        //

        RemoveEntryList(&pHead->GlobalList);
        --DlcGlobalMemoryListCount;
        pHead->GlobalList.Flink = pHead->GlobalList.Flink = NULL;
    }

    if (ZapFreedMemory) {
        RtlFillMemory(pHead + 1,
                           DWORD_ROUNDUP(pHead->OriginalSize),
                           ZAP_EX_FREE_VALUE
                           );
    }

    ExFreePool((PVOID)pHead);

/*
    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    --InMemoryAllocator;
    if (InMemoryAllocator) {
        DbgPrint("DLC.DeallocateMemory: Error: Memory allocator clash on exit. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/
}


PVOID
AllocateObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG ObjectSize
    )

/*++

Routine Description:

    Allocates a pseudo-object

Arguments:

    ObjectType      - type of object to allocate
    ObjectSize      - size of object; mainly because some objects have variable size
    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage

Return Value:

    PVOID
        Success - pointer to object allocated from non-paged pool
        Failure - NULL

--*/

{
    POBJECT_ID pObject;
    ULONG signature;
    ULONG baseSize;

    signature = GetObjectSignature(ObjectType);
    baseSize = GetObjectBaseSize(ObjectType);
    if (baseSize < ObjectSize) {
        DbgPrint("DLC.AllocateObject: Error: Invalid size %d for ObjectType %08x (should be >= %d)\n",
                ObjectSize,
                ObjectType,
                baseSize
                );
        DbgBreakPoint();
    }
    pObject = (POBJECT_ID)AllocateZeroMemory(pMemoryUsage, ObjectSize);
    if (pObject) {
        pObject->Signature = signature;
        pObject->Type = ObjectType;
        pObject->Size = baseSize;
        pObject->Extra = ObjectSize - baseSize;
    }
    return (PVOID)pObject;
}


VOID
FreeObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    Deallocates a pseudo-object

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    pObject         - pointer to object allocated with AllocateObject
    ObjectType      - type of object pObject supposed to be

Return Value:

    None.

--*/

{
    ValidateObject(pObject, ObjectType);
    DeallocateMemory(pMemoryUsage, pObject);
}


VOID
ValidateObject(
    IN POBJECT_ID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    Checks that an object is what its supposed to be

Arguments:

    pObject     - pointer to object to check
    ObjectType  - type of object pObject supposed to point to

Return Value:

    None.

--*/

{
    ULONG signature = GetObjectSignature(ObjectType);
    ULONG baseSize = GetObjectBaseSize(ObjectType);

    if (pObject->Signature != signature
    || pObject->Type != ObjectType
    || pObject->Size != baseSize) {
        DbgPrint("DLC.ValidateObject: Error: InvalidObject %08x, Type=%08x\n",
                pObject,
                ObjectType
                );
        DbgBreakPoint();
    }
}


ULONG
GetObjectSignature(
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    returns the signature for an object type

Arguments:

    ObjectType  - type of object to return signature for

Return Value:

    ULONG

--*/

{
    switch (ObjectType) {
    case FileContextObject:
        return SIGNATURE_FILE;

    case AdapterContextObject:
        return SIGNATURE_ADAPTER;

    case BindingContextObject:
        return SIGNATURE_BINDING;

    case DlcSapObject:
    case DlcGroupSapObject:
        return SIGNATURE_DLC_SAP;

    case DlcLinkObject:
        return SIGNATURE_DLC_LINK;

    case DlcDixObject:
        return SIGNATURE_DIX;

    case LlcDataLinkObject:
        return SIGNATURE_LLC_LINK;

    case LlcSapObject:
    case LlcGroupSapObject:
        return SIGNATURE_LLC_SAP;

    default:
        DbgPrint("DLC.GetObjectSignature: Error: unknown object type %08x\n", ObjectType);
        DbgBreakPoint();
        return 0;
    }

}


ULONG
GetObjectBaseSize(
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    returns the base size for an object

Arguments:

    ObjectType  - type of object to return base size for

Return Value:

    ULONG

--*/

{
    switch (ObjectType) {
    case FileContextObject:
        return sizeof(DLC_FILE_CONTEXT);

    case AdapterContextObject:
        return sizeof(ADAPTER_CONTEXT);

    case BindingContextObject:
        return sizeof(BINDING_CONTEXT);

    case DlcSapObject:
    case DlcGroupSapObject:
        return sizeof(DLC_OBJECT);

    case DlcLinkObject:
        return sizeof(DLC_OBJECT);

    case DlcDixObject:
        return sizeof(DLC_OBJECT);

    case LlcDataLinkObject:
        return sizeof(DATA_LINK);

    case LlcSapObject:
    case LlcGroupSapObject:
        return sizeof(LLC_OBJECT);

    default:
        DbgPrint("DLC.GetObjectBaseSize: Error: unknown object type %08x\n", ObjectType);
        DbgBreakPoint();
        return 0;
    }
}

#endif


PVOID
AllocateZeroMemory(
#if DBG
    IN PMEMORY_USAGE pMemoryUsage,
#endif
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory out of non-paged pool. For the debug version, we round up
    the requested size to the next 4-byte boundary and we add header and tail
    sections which contain a signature to check for over-write, and in-use and
    size information

    The memory is zeroed before being returned to the caller

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    Size            - number of bytes to allocate

Return Value:

    PVOID
        Success - pointer to allocated memory
        Failure - NULL

--*/

{
    PVOID pMem;

#if DBG

    ULONG OriginalSize = Size;
    PUCHAR pMemEnd;

/*
    KIRQL irql;

    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateZeroMemory: Error: Memory allocator clash on entry. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    ++InMemoryAllocator;
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    Size = DWORD_ROUNDUP(Size)
         + sizeof(PRIVATE_NON_PAGED_POOL_HEAD)
         + sizeof(PRIVATE_NON_PAGED_POOL_TAIL);

#endif

    pMem = ExAllocatePoolWithTag(NonPagedPool, (ULONG)Size, DLC_POOL_TAG);
    if (pMem) {
        LlcZeroMem(pMem, Size);

#if DBG

        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->OriginalSize = OriginalSize;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Flags = MEM_FLAGS_IN_USE;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Signature = SIGNATURE1;

        pMemEnd = (PUCHAR)pMem
                + DWORD_ROUNDUP(OriginalSize)
                + sizeof(PRIVATE_NON_PAGED_POOL_HEAD);

        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Signature = SIGNATURE2;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern1 = PATTERN1;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern2 = PATTERN2;

        GRAB_SPINLOCK();
        UpdateCounter(&GoodNonPagedPoolAllocs, 1);
        UpdateCounter(&NonPagedPoolAllocated, (LONG)Size);
        UpdateCounter(&NonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolAllocated, (LONG)Size);
        FREE_SPINLOCK();

        if (MaintainGlobalLists) {

            KIRQL irql;

            //
            // record the caller and add this block to the global list
            //

            GET_CALLERS_ADDRESS(&((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[0],
                                &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[1]
                                );

            KeAcquireSpinLock(&DlcGlobalMemoryListLock, &irql);
            InsertTailList(&DlcGlobalMemoryList,
                           &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->GlobalList
                           );
            ++DlcGlobalMemoryListCount;
            KeReleaseSpinLock(&DlcGlobalMemoryListLock, irql);
        }
        ChargeNonPagedPoolUsage(pMemoryUsage, Size, (PPRIVATE_NON_PAGED_POOL_HEAD)pMem);
        pMem = (PVOID)((PUCHAR)pMem + sizeof(PRIVATE_NON_PAGED_POOL_HEAD));
    } else {
        GRAB_SPINLOCK();
        UpdateCounter(&BadNonPagedPoolAllocs, 1);
        FREE_SPINLOCK();
    }

/*
    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    --InMemoryAllocator;
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateZeroMemory: Error: Memory allocator clash on exit. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

#else

    }

#endif

    return pMem;
}


PPACKET_POOL
CreatePacketPool(
#if DBG
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pOwner,
    IN DLC_OBJECT_TYPE ObjectType,
#endif
    IN ULONG PacketSize,
    IN ULONG NumberOfPackets
    )

/*++

Routine Description:

    creates a packet pool. A packet pool is a collection of same-sized packets

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    pOwner          - pointer to owner object
    ObjectType      - type of object for owner
    PacketSize      - size of packet in bytes
    NumberOfPackets - initial number of packets in pool

Return Value:

    PPACKET_POOL
        Success - pointer to PACKET_POOL structure allocated from non-paged pool
        Failure - NULL

--*/

{
    PPACKET_POOL pPacketPool;
    PPACKET_HEAD pPacketHead;

#if DBG
/*
//    DbgPrint("DLC.CreatePacketPool(%d, %d)\n", PacketSize, NumberOfPackets);
    if (InPoolCreator) {
        DbgPrint("DLC.CreatePacketPool: Error: Pool Creator clash on entry. Count = %d\n",
                InPoolCreator
                );
//        DbgBreakPoint();
    }
    ++InPoolCreator;
*/

    pPacketPool = AllocateZeroMemory(pMemoryUsage, sizeof(PACKET_POOL));
#else
    pPacketPool = AllocateZeroMemory(sizeof(PACKET_POOL));
#endif

    if (pPacketPool) {

#if DBG
        pPacketPool->OriginalPacketCount = NumberOfPackets;
        pPacketPool->MemoryUsage.Owner = pPacketPool;
        pPacketPool->MemoryUsage.OwnerObjectId = ObjectType;
#endif

        while (NumberOfPackets--) {

#if DBG

            //
            // charge memory for individual packets to the pool
            //

            pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(&pPacketPool->MemoryUsage,
                                                           sizeof(PACKET_HEAD) + PacketSize
                                                           );
#else
            pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(sizeof(PACKET_HEAD) + PacketSize);
#endif

            if (pPacketHead) {
#if DBG
                pPacketHead->Signature = PACKET_HEAD_SIGNATURE;
                pPacketHead->pPacketPool = pPacketPool;
                ++pPacketPool->FreeCount;
#endif

                pPacketHead->Flags = PACKET_FLAGS_FREE;
                PushEntryList(&pPacketPool->FreeList, (PSINGLE_LIST_ENTRY)pPacketHead);
            } else {
                while (pPacketPool->FreeList.Next) {

                    PVOID ptr = (PVOID)PopEntryList(&pPacketPool->FreeList);

#if DBG
                    DeallocateMemory(&pPacketPool->MemoryUsage, ptr);
#else
                    DeallocateMemory(ptr);
#endif
                }

#if DBG
                DbgPrint("DLC.CreatePacketPool: Error: couldn't allocate %d packets\n",
                         pPacketPool->OriginalPacketCount
                         );
                DeallocateMemory(pMemoryUsage, pPacketPool);
/*
                --InPoolCreator;
                if (InPoolCreator) {
                    DbgPrint("DLC.CreatePacketPool: Error: Pool Creator clash on exit. Count = %d\n",
                            InPoolCreator
                            );
//                    DbgBreakPoint();
                }
*/

#else
                DeallocateMemory(pPacketPool);
#endif

                return NULL;
            }
        }
        KeInitializeSpinLock(&pPacketPool->PoolLock);
        pPacketPool->PacketSize = PacketSize;

#if DBG
        pPacketPool->Signature = PACKET_POOL_SIGNATURE;
        pPacketPool->Viable = TRUE;
        pPacketPool->CurrentPacketCount = pPacketPool->OriginalPacketCount;
        pPacketPool->Flags = POOL_FLAGS_IN_USE;
        pPacketPool->pMemoryUsage = pMemoryUsage;

        //
        // add the memory usage structure for this pool to the memory usage
        // list
        //

        LinkMemoryUsage(&pPacketPool->MemoryUsage);

        if (DebugDump) {
            DbgPrint("DLC.CreatePacketPool: %08x\n", pPacketPool);
            DumpPool(pPacketPool);
        }
    } else {
        DbgPrint("DLC.CreatePacketPool: Error: couldn't allocate memory for PACKET_POOL\n");
    }

    //
    // debug counters in PACKET_POOL structure are already zero thanks to
    // AllocateZeroMemory automatically zeroing all memory allocated from
    // non-paged pool
    //

/*
    --InPoolCreator;
    if (InPoolCreator) {
        DbgPrint("DLC.CreatePacketPool: Error: Pool Creator clash on exit. Count = %d\n",
                InPoolCreator
                );
//        DbgBreakPoint();
    }
*/

#else

    }

#endif

    return pPacketPool;
}


VOID
DeletePacketPool(
#if DBG
    IN PMEMORY_USAGE pMemoryUsage,
#endif
    IN PPACKET_POOL* ppPacketPool
    )

/*++

Routine Description:

    frees a previously created packet pool

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    ppPacketPool    - pointer to pointer to PACKET_POOL structure. Zero on return

Return Value:

    None.

--*/

{
    KIRQL irql;
    PPACKET_HEAD pPacketHead;
    PPACKET_POOL pPacketPool = *ppPacketPool;

#if DBG
    ULONG packetCount;
#endif

    //
    // for various reasons, we can receive a NULL pointer. No action in this case
    //

    if (pPacketPool == NULL) {

#if DBG
        PVOID callerAddress, callersCaller;

        GET_CALLERS_ADDRESS(&callerAddress, &callersCaller);
        DbgPrint("DLC.DeletePacketPool: NULL pointer. Caller = %x (caller's caller = %x)\n",
                callerAddress,
                callersCaller
                );
#endif

        return;
    }

#if DBG
//    DbgPrint("DLC.DeletePacketPool(%08x)\n", pPacketPool);
//    DumpPool(pPacketPool);
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.DeletePacketPool: Error: Memory allocator clash on entry: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    ++pPacketPool->ClashCount;

    if (pPacketPool->Signature != PACKET_POOL_SIGNATURE) {
        DbgPrint("DLC.DeletePacketPool: Error: Invalid Pool Handle %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (!pPacketPool->Viable) {
        DbgPrint("DLC.DeletePacketPool: Error: Unviable Packet Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

    KeAcquireSpinLock(&pPacketPool->PoolLock, &irql);

#if DBG

    //
    // mark the packet pool structure as unviable: if anybody tries to allocate
    // or deallocate while we are destroying the pool, we will break into debugger
    //

    pPacketPool->Viable = FALSE;
    pPacketPool->Signature = 0xFFFFFFFF;

    //
    // assert that the busy list is empty
    //

    if (pPacketPool->BusyList.Next != NULL) {
        DbgPrint("DLC.DeletePacketPool: Error: %d packets busy. Pool = %08x\n",
                 pPacketPool->BusyCount,
                 pPacketPool
                 );
        if (!DeleteBusyListAnyway) {
            DumpPool(pPacketPool);
            DbgBreakPoint();
        } else {
            DbgPrint("DLC.DeletePacketPool: Deleting BusyList anyway\n");
        }
    }

    packetCount = 0;

#endif

    while (pPacketPool->FreeList.Next != NULL) {
        pPacketHead = (PPACKET_HEAD)PopEntryList(&pPacketPool->FreeList);

#if DBG
        if (pPacketHead->Signature != PACKET_HEAD_SIGNATURE
        || pPacketHead->pPacketPool != pPacketPool
        || (pPacketHead->Flags & PACKET_FLAGS_BUSY)
        || !(pPacketHead->Flags & PACKET_FLAGS_FREE)) {
            DbgPrint("DLC.DeletePacketPool: Error: Bad packet %08x. Pool = %08x\n",
                    pPacketHead,
                    pPacketPool
                    );
            DbgBreakPoint();
        }
        ++packetCount;
        DeallocateMemory(&pPacketPool->MemoryUsage, pPacketHead);
#else
        DeallocateMemory(pPacketHead);
#endif

    }

#if DBG

    if (DeleteBusyListAnyway) {
        while (pPacketPool->BusyList.Next != NULL) {
            pPacketHead = (PPACKET_HEAD)PopEntryList(&pPacketPool->BusyList);

            if (pPacketHead->Signature != PACKET_HEAD_SIGNATURE
            || pPacketHead->pPacketPool != pPacketPool
            || (pPacketHead->Flags & PACKET_FLAGS_FREE)
            || !(pPacketHead->Flags & PACKET_FLAGS_BUSY)) {
                DbgPrint("DLC.DeletePacketPool: Error: Bad packet %08x. Pool = %08x\n",
                        pPacketHead,
                        pPacketPool
                        );
                DbgBreakPoint();
            }
            ++packetCount;
            DeallocateMemory(&pPacketPool->MemoryUsage, pPacketHead);
        }
    }

    //
    // did any packets get unwittingly added or removed?
    //

    if (packetCount != pPacketPool->CurrentPacketCount) {
        DbgPrint("DLC.DeletePacketPool: Error: PacketCount (%d) != PoolCount (%d)\n",
                packetCount,
                pPacketPool->CurrentPacketCount
                );
        DumpPool(pPacketPool);
        DbgBreakPoint();
    }

    //
    // ensure we returned all the memory allocated to this pool
    //

    CheckMemoryReturned(&pPacketPool->MemoryUsage);

    //
    // dump the counters every time we delete a pool
    //

//    DumpPoolStats("DeletePacketPool", pPacketPool);

    //
    // remove the pool's memory usage structure - all memory allocated has been
    // freed, so we're in the clear for this one
    //

    UnlinkMemoryUsage(&pPacketPool->MemoryUsage);

#endif

    KeReleaseSpinLock(&pPacketPool->PoolLock, irql);

#if DBG
    DeallocateMemory(pMemoryUsage, pPacketPool);
#else
    DeallocateMemory(pPacketPool);
#endif

    *ppPacketPool = NULL;
}


PVOID
AllocatePacket(
    IN PPACKET_POOL pPacketPool
    )

/*++

Routine Description:

    allocates a packet from a packet pool. We expect that we can always get a
    packet from the previously allocated pool. However, if all packets are
    currently in use, allocate another from non-paged pool

Arguments:

    pPacketPool - pointer to PACKET_POOL structure

Return Value:

    PVOID
        Success - pointer to allocated packet
        Failure - NULL

--*/

{
    KIRQL irql;
    PPACKET_HEAD pPacketHead;

#if DBG
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.AllocatePacket: Error: Memory allocator clash on entry: Pool %08x, Count %d\n",
                pPacketPool,
                pPacketPool->ClashCount
                );
//        DbgBreakPoint();
    }
    ++pPacketPool->ClashCount;
#endif

    KeAcquireSpinLock(&pPacketPool->PoolLock, &irql);

#if DBG
    if (pPacketPool->Signature != PACKET_POOL_SIGNATURE) {
        DbgPrint("DLC.AllocatePacket: Error: Invalid Pool Handle %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (!pPacketPool->Viable) {
        DbgPrint("DLC.AllocatePacket: Error: Unviable Packet Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

    if (pPacketPool->FreeList.Next != NULL) {
        pPacketHead = (PPACKET_HEAD)PopEntryList(&pPacketPool->FreeList);

#if DBG
        --pPacketPool->FreeCount;
        if (pPacketHead->Flags & PACKET_FLAGS_BUSY
        || !(pPacketHead->Flags & PACKET_FLAGS_FREE)) {
            DbgPrint("DLC.AllocatePacket: Error: BUSY packet %08x on FreeList; Pool=%08x\n",
                    pPacketHead,
                    pPacketPool
                    );
            DumpPacketHead(pPacketHead, 0);
            DbgBreakPoint();
        }
#endif

    } else {

        //
        // Miscalculated pool usage
        //

#if DBG
        pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(&pPacketPool->MemoryUsage,
                                                       sizeof(PACKET_HEAD) + pPacketPool->PacketSize
                                                       );
#else
        pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(sizeof(PACKET_HEAD) + pPacketPool->PacketSize);
#endif

        if (pPacketHead) {

            //
            // mark this packet as allocated after the pool was created - this
            // means our initial estimation of packet requirement for this
            // pool was inadequate
            //

            pPacketHead->Flags = PACKET_FLAGS_POST_ALLOC | PACKET_FLAGS_FREE;
        }

#if DBG
        ++pPacketPool->NoneFreeCount;
        if (pPacketHead) {

            PVOID caller;
            PVOID callersCaller;

            GET_CALLERS_ADDRESS(&caller, &callersCaller);
            if (DebugDump) {
                DbgPrint("DLC.AllocatePacket: Adding new packet %08x to pool %08x. ret=%08x,%08x\n",
                        pPacketHead,
                        pPacketPool,
                        caller,
                        callersCaller
                        );
            }
            pPacketHead->Signature = PACKET_HEAD_SIGNATURE;
            pPacketHead->pPacketPool = pPacketPool;

            ++pPacketPool->CurrentPacketCount;
            DumpPoolStats("AllocatePacket", pPacketPool);
        } else {
            DbgPrint("DLC.AllocatePacket: Error: couldn't allocate packet for Pool %08x\n",
                     pPacketPool
                     );
        }
#endif

    }
    if (pPacketHead) {

        //
        // turn on BUSY flag, turn off FREE flag
        //

        pPacketHead->Flags ^= (PACKET_FLAGS_FREE | PACKET_FLAGS_BUSY);

        //
        // zero the contents of the packet!
        //

        LlcZeroMem((PVOID)(pPacketHead + 1), pPacketPool->PacketSize);
        PushEntryList(&pPacketPool->BusyList, (PSINGLE_LIST_ENTRY)pPacketHead);

#if DBG
        GET_CALLERS_ADDRESS(&pPacketHead->CallersAddress_A,
                            &pPacketHead->CallersCaller_A
                            );
        ++pPacketPool->BusyCount;
        ++pPacketPool->Allocations;
        ++pPacketPool->MaxInUse;
#endif

    }

    KeReleaseSpinLock(&pPacketPool->PoolLock, irql);

#if DBG
    --pPacketPool->ClashCount;
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.AllocatePacket: Error: Memory allocator clash on exit: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

    //
    // return pointer to packet body, not packet header
    //

    return pPacketHead ? (PVOID)(pPacketHead + 1) : (PVOID)pPacketHead;
}


VOID
DeallocatePacket(
    IN PPACKET_POOL pPacketPool,
    IN PVOID pPacket
    )

/*++

Routine Description:

    Returns a packet to its pool

Arguments:

    pPacketPool - pointer to PACKET_POOL structure describing this pool
    pPacket     - pointer to previously allocated packet

Return Value:

    None.

--*/

{
    KIRQL irql;
    PPACKET_HEAD pPacketHead = ((PPACKET_HEAD)pPacket) - 1;
    PSINGLE_LIST_ENTRY p;
    PSINGLE_LIST_ENTRY prev;

#if DBG
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.DeallocatePacket: Error: Memory allocator clash on entry: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    ++pPacketPool->ClashCount;
#endif

    KeAcquireSpinLock(&pPacketPool->PoolLock, &irql);

#if DBG
    if (pPacketPool->Signature != PACKET_POOL_SIGNATURE) {
        DbgPrint("DLC.DeallocatePacket: Error: Invalid Pool Handle %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (!pPacketPool->Viable) {
        DbgPrint("DLC.DeallocatePacket: Error: Unviable Packet Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (pPacketHead->Signature != PACKET_HEAD_SIGNATURE
    || pPacketHead->pPacketPool != pPacketPool
    || !(pPacketHead->Flags & PACKET_FLAGS_BUSY)
    || pPacketHead->Flags & PACKET_FLAGS_FREE) {
        DbgPrint("DLC.DeallocatePacket: Error: Invalid Packet Header %08x, Pool = %08x\n",
                pPacketHead,
                pPacketPool
                );
        DbgBreakPoint();
    }
#endif

    //
    // remove this packet from single linked list on BusyList
    //

    prev = (PSINGLE_LIST_ENTRY)&pPacketPool->BusyList;
    for (p = prev->Next; p; p = p->Next) {
        if (p == (PSINGLE_LIST_ENTRY)pPacketHead) {
            break;
        } else {
            prev = p;
        }
    }

#if DBG
    if (!p) {
        DbgPrint("DLC.DeallocatePacket: Error: packet %08x not on BusyList of pool %08x\n",
                pPacketHead,
                pPacketPool
                );
        DumpPool(pPacketPool);
        DbgBreakPoint();
    }
#endif

    prev->Next = pPacketHead->List.Next;

#if DBG
    if (ZapDeallocatedPackets) {

        //
        // fill the deallocated packet with 'Z's. This will quickly tell us if
        // the packet is still being used after it is deallocated
        //

        RtlFillMemory(pPacketHead + 1, pPacketPool->PacketSize, ZAP_DEALLOC_VALUE);
    }
#endif

    PushEntryList(&pPacketPool->FreeList, (PSINGLE_LIST_ENTRY)pPacketHead);

    //
    // turn off BUSY flag, turn on FREE flag
    //

    pPacketHead->Flags ^= (PACKET_FLAGS_BUSY | PACKET_FLAGS_FREE);

#if DBG
    ++pPacketPool->FreeCount;
    --pPacketPool->BusyCount;
    ++pPacketPool->Frees;
    --pPacketPool->MaxInUse;
//    pPacketHead->CallersAddress_A = (PVOID)-1;
//    pPacketHead->CallersCaller_A = (PVOID)-1;
    GET_CALLERS_ADDRESS(&pPacketHead->CallersAddress_D,
                        &pPacketHead->CallersCaller_D
                        );
#endif

    KeReleaseSpinLock(&pPacketPool->PoolLock, irql);

#if DBG
    --pPacketPool->ClashCount;
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.DeallocatePacket: Error: Memory allocator clash on exit: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

}


#if DBG

#ifdef TRACK_DLC_OBJECTS

POBJECT_POOL
CreateObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG SizeOfObject,
    IN ULONG NumberOfObjects
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pMemoryUsage    -
    ObjectType      -
    SizeOfObject    -
    NumberOfObjects -

Return Value:

    POBJECT_POOL

--*/

{
}


VOID
DeleteObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN POBJECT_POOL pObjectPool
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pMemoryUsage    -
    ObjectType      -
    pObjectPool     -

Return Value:

    None.

--*/

{
}


POBJECT_HEAD
AllocatePoolObject(
    IN POBJECT_POOL pObjectPool
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pObjectPool -

Return Value:

    POBJECT_HEAD

--*/

{
}


POBJECT_POOL
FreePoolObject(
    IN DLC_OBJECT_TYPE ObjectType,
    IN POBJECT_HEAD pObjectHead
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    ObjectType  -
    pObjectHead -

Return Value:

    POBJECT_POOL

--*/

{
}

#endif // TRACK_DLC_OBJECTS


VOID
CheckMemoryReturned(
    IN PMEMORY_USAGE pMemoryUsage
    )

/*++

Routine Description:

    Called when a 'handle' which owns a MEMORY_USAGE structure is being closed.
    Checks that all memory has been returned and that number of allocations is
    the same as number of frees

Arguments:

    pMemoryUsage    -  pointer to MEMORY_USAGE structure to check

Return Value:

    None.

--*/

{
    if (pMemoryUsage->AllocateCount != pMemoryUsage->FreeCount || pMemoryUsage->NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            if (pMemoryUsage->AllocateCount != pMemoryUsage->FreeCount) {
                DbgPrint("DLC.CheckMemoryReturned: Error: AllocateCount != FreeCount. Usage @ %08x\n",
                         pMemoryUsage
                         );
            } else {
                DbgPrint("DLC.CheckMemoryReturned: Error: NonPagedPoolAllocated != 0. Usage @ %08x\n",
                         pMemoryUsage
                         );
            }
        }
        if (MemoryCheckStop) {
            DumpMemoryUsage(pMemoryUsage, TRUE);
            DbgBreakPoint();
        }
    }
}


VOID
CheckDriverMemoryUsage(
    IN BOOLEAN Break
    )

/*++

Routine Description:

    Checks if the driver has allocated memory & dumps usage to debugger

Arguments:

    Break   - if true && driver has memory, breaks into debugger

Return Value:

    None.

--*/

{
    DbgPrint("DLC.CheckDriverMemoryUsage\n");
    DumpMemoryMetrics();
    if (Break && NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            DbgPrint("DLC.CheckDriverMemoryUsage: Error: Driver still has memory allocated\n");
        }
        if (MemoryCheckStop) {
            DbgBreakPoint();
        }
    }
}


VOID MemoryAllocationError(PCHAR Routine, PVOID Address) {
    DbgPrint("DLC.%s: Error: Memory Allocation error in block @ %08x\n", Routine, Address);
    DumpMemoryMetrics();
    DbgBreakPoint();
}

VOID UpdateCounter(PULONG pCounter, LONG Value) {
    if (Value > 0) {
        if (*pCounter + Value < *pCounter) {
            MemoryCounterOverflow(pCounter, Value);
        }
    } else {
        if (*pCounter + Value > *pCounter) {
            MemoryCounterOverflow(pCounter, Value);
        }
    }
    *pCounter += Value;
}

VOID MemoryCounterOverflow(PULONG pCounter, LONG Value) {
    DbgPrint("DLC: Memory Counter Overflow: &Counter=%08x, Count=%d, Value=%d\n",
            pCounter,
            *pCounter,
            Value
            );
    DumpMemoryMetrics();
}

VOID DumpMemoryMetrics() {
    DbgPrint("DLC Device Driver Non-Paged Pool Usage:\n"
             "\tNumber Of Good Non-Paged Pool Allocations. : %d\n"
             "\tNumber Of Bad  Non-Paged Pool Allocations. : %d\n"
             "\tNumber Of Good Non-Paged Pool Frees. . . . : %d\n"
             "\tNumber Of Bad  Non-Paged Pool Frees. . . . : %d\n",
             GoodNonPagedPoolAllocs,
             BadNonPagedPoolAllocs,
             GoodNonPagedPoolFrees,
             BadNonPagedPoolFrees
             );
    DbgPrint("\tTotal Non-Paged Pool Currently Requested . : %d\n"
             "\tTotal Non-Paged Pool Currently Allocated . : %d\n"
             "\tCumulative Total Non-Paged Pool Requested. : %d\n"
             "\tCumulative Total Non-Paged Pool Allocated. : %d\n"
             "\tCumulative Total Non-Paged Pool Freed. . . : %d\n"
             "\n",
             NonPagedPoolRequested,
             NonPagedPoolAllocated,
             TotalNonPagedPoolRequested,
             TotalNonPagedPoolAllocated,
             TotalNonPagedPoolFreed
             );
     DumpMemoryUsageList();
}

VOID DumpPoolStats(PCHAR Routine, PPACKET_POOL pPacketPool) {
    if (!DebugDump) {
        return;
    }
    DbgPrint("DLC.%s: Stats For Pool %08x:\n"
             "\tPool Owner . . . . . . . . . . . . . . . . . . . : %08x\n"
             "\tPool Owner Object ID . . . . . . . . . . . . . . : %08x [%s]\n",
             Routine,
             pPacketPool,
             pPacketPool->pMemoryUsage->Owner,
             pPacketPool->pMemoryUsage->OwnerObjectId,
             MapObjectId(pPacketPool->pMemoryUsage->OwnerObjectId)
             );
    DbgPrint("\tFree List. . . . . . . . . . . . . . . . . . . . : %08x\n"
             "\tBusy List. . . . . . . . . . . . . . . . . . . . : %08x\n",
             pPacketPool->FreeList,
             pPacketPool->BusyList
             );
    DbgPrint("\tPacket Size. . . . . . . . . . . . . . . . . . . : %d\n"
             "\tOriginal Number Of Packets In Pool . . . . . . . : %d\n"
             "\tCurrent Number Of Packets In Pool. . . . . . . . : %d\n"
             "\tNumber Of Allocations From Pool. . . . . . . . . : %d\n"
             "\tNumber Of Deallocations To Pool. . . . . . . . . : %d\n"
             "\tNumber Of Times No Available Packets On Allocate : %d\n"
             "\tMax. Number Of Packets Allocated At Any One Time : %d\n"
             "\tNumber Of Packets On Free List . . . . . . . . . : %d\n"
             "\tNumber Of Packets On Busy List . . . . . . . . . : %d\n"
             "\n",
             pPacketPool->PacketSize,
             pPacketPool->OriginalPacketCount,
             pPacketPool->CurrentPacketCount,
             pPacketPool->Allocations,
             pPacketPool->Frees,
             pPacketPool->NoneFreeCount,
             pPacketPool->MaxInUse,
             pPacketPool->FreeCount,
             pPacketPool->BusyCount
             );
    DumpMemoryUsage(&pPacketPool->MemoryUsage, FALSE);
}

PCHAR MapObjectId(DLC_OBJECT_TYPE ObjectType) {
    switch (ObjectType) {
    case DlcDriverObject:
        return "DlcDriverObject";

    case FileContextObject:
        return "FileContextObject";

    case AdapterContextObject:
        return "AdapterContextObject";

    case BindingContextObject:
        return "BindingContextObject";

    case DlcSapObject:
        return "DlcSapObject";

    case DlcGroupSapObject:
        return "DlcGroupSapObject";

    case DlcLinkObject:
        return "DlcLinkObject";

    case DlcDixObject:
        return "DlcDixObject";

    case LlcDataLinkObject:
        return "LlcDataLinkObject";

    case LLcDirectObject:
        return "LLcDirectObject";

    case LlcSapObject:
        return "LlcSapObject";

    case LlcGroupSapObject:
        return "LlcGroupSapObject";

    case DlcBufferPoolObject:
        return "DlcBufferPoolObject";

    case DlcLinkPoolObject:
        return "DlcLinkPoolObject";

    case DlcPacketPoolObject:
        return "DlcPacketPoolObject";

    case LlcLinkPoolObject:
        return "LlcLinkPoolObject";

    case LlcPacketPoolObject:
        return "LlcPacketPoolObject";

    default:
        return "*** UNKNOWN OBJECT TYPE ***";
    }
}

VOID DumpPool(PPACKET_POOL pPacketPool) {
    if (!DebugDump) {
        return;
    }
    DumpPoolStats("DumpPool", pPacketPool);
    DumpPoolList("Free", &pPacketPool->FreeList);
    DumpPoolList("Busy", &pPacketPool->BusyList);
}

VOID DumpPoolList(PCHAR Name, PSINGLE_LIST_ENTRY List) {

    ULONG count = 0;

    if (List->Next) {
        DbgPrint("\n%s List @ %08x:\n", Name,  List);
        while (List->Next) {
            List = List->Next;
            DumpPacketHead((PPACKET_HEAD)List, ++count);
        }
    } else {
        DbgPrint("%s List is EMPTY\n\n", Name);
    }
}

VOID DumpPacketHead(PPACKET_HEAD pPacketHead, ULONG Number) {

    CHAR numbuf[5];

    if (!DebugDump) {
        return;
    }
    if (Number) {

        int i;
        ULONG div = 1000;   // 1000 packets in a pool?

        while (!(Number / div)) {
            div /= 10;
        }
        for (i = 0; Number; ++i) {
            numbuf[i] = (CHAR)('0' + Number / div);
            Number %= div;
            div /= 10;
        }
        numbuf[i] = 0;
        Number = 1; // flag
    }
    DbgPrint("%s\tPACKET_HEAD @ %08x:\n"
             "\tList . . . . . . . . : %08x\n"
             "\tFlags. . . . . . . . : %08x\n"
             "\tSignature. . . . . . : %08x\n"
             "\tpPacketPool. . . . . : %08x\n"
             "\tCallers Address (A). : %08x\n"
             "\tCallers Caller (A) . : %08x\n"
             "\tCallers Address (D). : %08x\n"
             "\tCallers Caller (D) . : %08x\n"
             "\n",
             Number ? numbuf : "",
             pPacketHead,
             pPacketHead->List,
             pPacketHead->Flags,
             pPacketHead->Signature,
             pPacketHead->pPacketPool,
             pPacketHead->CallersAddress_A,
             pPacketHead->CallersCaller_A,
             pPacketHead->CallersAddress_D,
             pPacketHead->CallersCaller_D
             );
}

VOID DumpMemoryUsageList() {

    PMEMORY_USAGE pMemoryUsage;
    KIRQL irql;
    BOOLEAN allocatedMemoryFound = FALSE;

    KeAcquireSpinLock(&MemoryUsageLock, &irql);
    for (pMemoryUsage = MemoryUsageList; pMemoryUsage; pMemoryUsage = pMemoryUsage->List) {
        if (pMemoryUsage->NonPagedPoolAllocated) {
            allocatedMemoryFound = TRUE;
            DbgPrint("DLC.DumpMemoryUsageList: %08x: %d bytes memory allocated\n",
                    pMemoryUsage,
                    pMemoryUsage->NonPagedPoolAllocated
                    );
            DumpMemoryUsage(pMemoryUsage, FALSE);
        }
    }
    KeReleaseSpinLock(&MemoryUsageLock, irql);
    if (!allocatedMemoryFound) {
        DbgPrint("DLC.DumpMemoryUsageList: No allocated memory found\n");
    }
}

VOID DumpMemoryUsage(PMEMORY_USAGE pMemoryUsage, BOOLEAN Override) {
    if (!DebugDump && !Override) {
        return;
    }
    DbgPrint("MEMORY_USAGE @ %08x:\n"
             "\tOwner. . . . . . . . . . . . . : %08x\n"
             "\tOwner Object ID. . . . . . . . : %08x [%s]\n"
             "\tOwner Instance . . . . . . . . : %x\n",
             pMemoryUsage,
             pMemoryUsage->Owner,
             pMemoryUsage->OwnerObjectId,
             MapObjectId(pMemoryUsage->OwnerObjectId),
             pMemoryUsage->OwnerInstance
             );
    DbgPrint("\tNon Paged Pool Allocated . . . : %d\n"
             "\tNumber Of Allocations. . . . . : %d\n"
             "\tNumber Of Frees. . . . . . . . : %d\n"
             "\tPrivate Allocation List Flink. : %08x\n"
             "\tPrivate Allocation List Blink. : %08x\n"
             "\n",
             pMemoryUsage->NonPagedPoolAllocated,
             pMemoryUsage->AllocateCount,
             pMemoryUsage->FreeCount,
             pMemoryUsage->PrivateList.Flink,
             pMemoryUsage->PrivateList.Blink
             );
}

VOID
CollectReturnAddresses(
    OUT PVOID* ReturnAddresses,
    IN ULONG AddressesToCollect,
    IN ULONG AddressesToSkip
    )
{
    PVOID* ebp = (PVOID*)*(PVOID**)&ReturnAddresses - 2;

    while (AddressesToSkip--) {
        GetLastReturnAddress(&ebp);
    }
    while (AddressesToCollect--) {
        *ReturnAddresses++ = GetLastReturnAddress(&ebp);
    }
}

PVOID* GetLastReturnAddress(PVOID** pEbp) {

    PVOID* returnAddress = *(*pEbp + 1);

    *pEbp = **pEbp;
    return returnAddress;
}

#ifdef i386
VOID x86SleazeCallersAddress(PVOID* pCaller, PVOID* pCallerCaller) {

    //
    // this only works on x86 and only if not fpo functions!
    //

    PVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallerCaller = *(ebp + 1);
}
#endif

BOOLEAN VerifyElementOnList(PSINGLE_LIST_ENTRY List, PSINGLE_LIST_ENTRY Element) {
    while (List) {
        if (List == Element) {
            return TRUE;
        }
        List = List->Next;
    }
    return FALSE;
}

VOID CheckList(PSINGLE_LIST_ENTRY List, ULONG NumberOfElements) {

    PSINGLE_LIST_ENTRY originalList = List;

    while (NumberOfElements--) {
        if (List->Next == NULL) {
            DbgPrint("DLC.CheckList: Error: too few entries on list %08x\n", originalList);
            DbgBreakPoint();
        } else {
            List = List->Next;
        }
    }
    if (List->Next != NULL) {
        DbgPrint("DLC.CheckList: Error: too many entries on list %08x\n", originalList);
        DbgBreakPoint();
    }
}

VOID CheckEntryOnList(PLIST_ENTRY Entry, PLIST_ENTRY List, BOOLEAN Sense) {

    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != Sense) {
        if (found) {
            DbgPrint("DLC.CheckEntryOnList: Error: Entry %08x found on list %08x. Not supposed to be there\n",
                     Entry,
                     List
                     );
        } else {
            DbgPrint("DLC.CheckEntryOnList: Error: Entry %08x not found on list %08x\n",
                     Entry,
                     List
                     );
        }
        if (MemoryCheckStop) {
            DbgBreakPoint();
        }
    }
}

VOID DumpPrivateMemoryHeader(PPRIVATE_NON_PAGED_POOL_HEAD pHead) {
    DbgPrint("Private Non Paged Pool Header @ %08x:\n"
             "\tSize . . . . . . . : %d\n"
             "\tOriginal Size. . . : %d\n"
             "\tFlags. . . . . . . : %08x\n"
             "\tSignature. . . . . : %08x\n"
             "\tGlobalList.Flink . : %08x\n"
             "\tGlobalList.Blink . : %08x\n"
             "\tPrivateList.Flink. : %08x\n"
             "\tPrivateList.Blink. : %08x\n"
             "\tStack[0] . . . . . : %08x\n"
             "\tStack[1] . . . . . : %08x\n"
             "\tStack[2] . . . . . : %08x\n"
             "\tStack[3] . . . . . : %08x\n"
             "\n",
             pHead->Size,
             pHead->OriginalSize,
             pHead->Flags,
             pHead->Signature,
             pHead->GlobalList.Flink,
             pHead->GlobalList.Blink,
             pHead->PrivateList.Flink,
             pHead->PrivateList.Blink,
             pHead->Stack[0],
             pHead->Stack[1],
             pHead->Stack[2],
             pHead->Stack[3]
             );
}

VOID ReportSwitchSettings(PSTR str) {
    DbgPrint("%s: LLCMEM Switches:\n"
             "\tDebugDump . . . . . . : %s\n"
             "\tDeleteBusyListAnyway. : %s\n"
             "\tMemoryCheckNotify . . : %s\n"
             "\tMemoryCheckStop . . . : %s\n"
             "\tMaintainGlobalLists . : %s\n"
             "\tMaintainPrivateLists. : %s\n"
             "\tZapDeallocatedPackets : %s\n"
             "\tZapFreedMemory. . . . : %s\n"
             "\n",
             str,
             YES_NO(DebugDump),
             YES_NO(DeleteBusyListAnyway),
             YES_NO(MemoryCheckNotify),
             YES_NO(MemoryCheckStop),
             YES_NO(MaintainGlobalLists),
             YES_NO(MaintainPrivateLists),
             YES_NO(ZapDeallocatedPackets),
             YES_NO(ZapFreedMemory)
             );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcobj.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems Ab

Module Name:

    llcobj.c

Abstract:

    The module implements the open and close primitives
    for all data link driver objects.

    Contents:
        LlcOpenStation
        LlcCloseStation
        CompleteClose
        CancelTransmitCommands
        CancelTransmitsInQueue
        LlcSetDirectOpenOptions
        CompleteObjectDelete
        CompletePendingLlcCommand
        LlcDereferenceObject
        LlcReferenceObject
        LlcGetReceivedLanHeaderLength
        LlcGetEthernetType
        LlcGetCommittedSpace

Author:

    Antti Saarenheimo (o-anttis) 29-MAY-1991

Revision History:

--*/

#if DBG
#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include "dlc.h"    // need DLC_FILE_CONTEXT for memory charged to file handle
#endif

#include <llc.h>

static USHORT ObjectSizes[] = {
    sizeof(LLC_STATION_OBJECT), // direct station
    sizeof(LLC_SAP ),           // SAP station
    sizeof(LLC_STATION_OBJECT), // group SAP
    (USHORT)(-1),               // link station
    sizeof(LLC_STATION_OBJECT)  // DIX station
};


DLC_STATUS
LlcOpenStation(
    IN PBINDING_CONTEXT pBindingContext,
    IN PVOID hClientHandle,
    IN USHORT ObjectAddress,
    IN UCHAR ObjectType,
    IN USHORT OpenOptions,
    OUT PVOID* phStation
    )

/*++

Routine Description:

    The primitive opens a LLC SAP exclusively for the upper protocol
    driver. The upper protocol must provide the storage for the
    SAP object. The correct size of the object has been defined in the
    characteristics table of the LLC driver.

    The first call to a new adapter initializes also the NDIS interface
    and allocates internal data structures for the new adapter.

Arguments:

    pBindingContext - binding context of the llc client
    hClientHandle   - The client protocol gets this handle in all indications
                      of the SAP
    ObjectAddress   - LLC SAP number or dix
    ObjectType      - type of the created object
    OpenOptions     - various open options set for the new object
    phStation       - returned opaque handle

Special:  Must be called IRQL < DPC (at least when direct station opened)

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                  DLC_STATUS_INVALID_SAP_VALUE
                  DLC_STATUS_INVALID_OPTION
                  DLC_STATUS_INVALID_STATION_ID

--*/

{
    PADAPTER_CONTEXT pAdapterContext;
    PLLC_OBJECT pStation;
    DLC_STATUS LlcStatus = STATUS_SUCCESS;
    PVOID* ppListBase;
    ULONG PacketFilter;

#if DBG
    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)(pBindingContext->hClientContext);
#endif

    pAdapterContext = pBindingContext->pAdapterContext;

    //
    // Allocate and initialize the SAP, but do not yet connect
    // it to the adapter
    //

    ASSERT(ObjectSizes[ObjectType] != (USHORT)(-1));

    pStation = (PLLC_OBJECT)ALLOCATE_ZEROMEMORY_FILE(ObjectSizes[ObjectType]);

    if (pStation == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }
    if (ObjectType == LLC_SAP_OBJECT && (ObjectAddress & 1)) {
        ObjectType = LLC_GROUP_SAP_OBJECT;
        ASSERT(phStation);
    }

    pStation->Gen.hClientHandle = hClientHandle;
    pStation->Gen.pLlcBinding = pBindingContext;
    pStation->Gen.pAdapterContext = pAdapterContext;
    pStation->Gen.ObjectType = (UCHAR)ObjectType;

    //
    // The LLC objects must be referenced whenever they should be kept alive
    // over a long operation, that opens the spin locks (especially async
    // operations)
    // The first reference is for open/close
    //

    ReferenceObject(pStation);

    //
    // These values are common for SAP, direct (and DIX objects)
    //

    pStation->Sap.OpenOptions = OpenOptions;
    pStation->Dix.ObjectAddress = ObjectAddress;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    switch (pStation->Gen.ObjectType) {
    case LLC_SAP_OBJECT:

        //
        // RLF 05/13/93
        //
        // don't allow multiple applications to open the same SAP. This is
        // incompatible with OS/2 DLC
        //

        if (pAdapterContext->apSapBindings[ObjectAddress] == NULL) {
            ppListBase = (PVOID*)&(pAdapterContext->apSapBindings[ObjectAddress]);
            LlcMemCpy(&pStation->Sap.DefaultParameters,
                      &DefaultParameters,
                      sizeof(DefaultParameters)
                      );

            ALLOCATE_SPIN_LOCK(&pStation->Sap.FlowControlLock);

        } else {

            FREE_MEMORY_FILE(pStation);

            RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            return DLC_STATUS_INVALID_SAP_VALUE;
        }
        break;

    case LLC_GROUP_SAP_OBJECT:
        ppListBase = (PVOID*)&(pAdapterContext->apSapBindings[ObjectAddress]);

        //
        // All members of the same group/individual SAP muust have set
        // the same XID handling option
        //

        if (pAdapterContext->apSapBindings[ObjectAddress] != NULL) {
            if ((OpenOptions & LLC_EXCLUSIVE_ACCESS)
            || (pAdapterContext->apSapBindings[ObjectAddress]->OpenOptions
                  & LLC_EXCLUSIVE_ACCESS)) {
                LlcStatus = DLC_STATUS_INVALID_SAP_VALUE;
            } else if ((pAdapterContext->apSapBindings[ObjectAddress]->OpenOptions &
                  LLC_HANDLE_XID_COMMANDS) != (OpenOptions & LLC_HANDLE_XID_COMMANDS)) {
                LlcStatus = DLC_STATUS_INVALID_OPTION;
            }
        }

        ALLOCATE_SPIN_LOCK(&pStation->Sap.FlowControlLock);

        break;

    case LLC_DIRECT_OBJECT:
        ppListBase = (PVOID*)&pAdapterContext->pDirectStation;
        break;

    case LLC_DIX_OBJECT:
        if (pAdapterContext->NdisMedium != NdisMedium802_3) {
            LlcStatus = DLC_STATUS_INVALID_STATION_ID;
        } else {
            ppListBase = (PVOID*)&(pAdapterContext->aDixStations[ObjectAddress % MAX_DIX_TABLE]);
        }
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    }

    if (LlcStatus == STATUS_SUCCESS) {
        pStation->Gen.pNext = *ppListBase;
        *phStation = *ppListBase = pStation;

        pAdapterContext->ObjectCount++;
    } else {

        FREE_MEMORY_FILE(pStation);

    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    if (LlcStatus == STATUS_SUCCESS
    && pStation->Gen.ObjectType == LLC_DIRECT_OBJECT
    && OpenOptions & DLC_RCV_MAC_FRAMES
    && !(pAdapterContext->OpenOptions & DLC_RCV_MAC_FRAMES)) {

        //
        // We enable the MAC frames, if they have once been enabled,
        // but they will never be disabled again.  The receiving
        // of MAC frames is quite exceptional case, and it is
        // not really worth of it to maintain local and global
        // Ndis flag states just because of it
        //

        PacketFilter = NDIS_PACKET_TYPE_DIRECTED
                     | NDIS_PACKET_TYPE_MULTICAST
                     | NDIS_PACKET_TYPE_FUNCTIONAL
                     | NDIS_PACKET_TYPE_MAC_FRAME;

        pAdapterContext->OpenOptions |= DLC_RCV_MAC_FRAMES;
        LlcStatus = SetNdisParameter(pAdapterContext,
                                     OID_GEN_CURRENT_PACKET_FILTER,
                                     &PacketFilter,
                                     sizeof(PacketFilter)
                                     );
    }
    return LlcStatus;
}


DLC_STATUS
LlcCloseStation(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pCompletionPacket
    )

/*++

Routine Description:

    The primitive closes a direct, sap or link station object.
    All pending transmit commands are terminated.
    This primitive does not support graceful termination, but
    the upper level must wait the pending transmit commands, if
    it want to make a clean close (without deleting the transmit queue).

    For a link station this  primitive releases a disconnected link
    station or discards a remote connection request.

Arguments:

    pStation            - handle of a link, sap or direct station
    pCompletionPacket   - returned context, when the command is complete

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_INVALID_PARAMETERS
                    the SAP has still active link stations. All active link
                    stations must be closed before sap can be closed.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;
    PBINDING_CONTEXT pOldBinding;
    PDATA_LINK* ppLink;
    PVOID* ppLinkListBase;
    PEVENT_PACKET pEvent;

    if (pStation->Gen.ObjectType == LLC_LINK_OBJECT) {

        //
        // The remote connection requests are routed through all
        // SAP station reqistered on a SAP until someone accepts
        // the connection request or it has been routed to all
        // clients having opened the sap station.
        //

        if (pStation->Link.Flags & DLC_ACTIVE_REMOTE_CONNECT_REQUEST) {

            ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            pOldBinding = pStation->Gen.pLlcBinding;
            if (pStation->Link.pSap->Gen.pNext != NULL) {
                pStation->Gen.pLlcBinding = pStation->Link.pSap->Gen.pNext->Gen.pLlcBinding;
            }

            RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            //
            // Complete the close command immediately, if
            // the connect request was redirected to another
            // SAP station
            //

            if (pStation->Gen.pLlcBinding != pOldBinding) {

                ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                pEvent = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

                if (pEvent != NULL) {
                    LlcInsertTailList(&pAdapterContext->QueueEvents, pEvent);
                    pEvent->pBinding = pStation->Gen.pLlcBinding;
                    pEvent->hClientHandle = pStation->Link.pSap->Gen.hClientHandle;
                    pEvent->Event = LLC_STATUS_CHANGE_ON_SAP;
                    pEvent->pEventInformation = &pStation->Link.DlcStatus;
                    pEvent->SecondaryInfo = INDICATE_CONNECT_REQUEST;
                }

                RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                if (pEvent != NULL) {
                    return STATUS_SUCCESS;
                }
            } else {

                //
                // Nobody accepted this connect request, we must discard it.
                //

                RunInterlockedStateMachineCommand((PDATA_LINK)pStation, SET_ADM);
            }
        }
    }
    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);
    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    DLC_TRACE('C');

    switch (pStation->Gen.ObjectType) {
    case LLC_DIRECT_OBJECT:

        //
        // This Direct must be in the linked list of Directs (having
        // the same source Direct).
        //

        ppLinkListBase = (PVOID*)&pAdapterContext->pDirectStation;

        DLC_TRACE('b');
        break;

    case LLC_DIX_OBJECT:

        //
        // This Direct must be in the linked list of Directs (having
        // the same source Direct).
        //

        ppLinkListBase = (PVOID*)&pAdapterContext->aDixStations[pStation->Dix.ObjectAddress % MAX_DIX_TABLE];
        DLC_TRACE('a');
        break;

    case LLC_SAP_OBJECT:

#if LLC_DBG
        if (pStation->Sap.pActiveLinks != NULL) {
            DbgPrint("Closing SAP before link stations!!!\n");
            DbgBreakPoint();

            //
            // Open the spin locks and return thge error status
            //

            RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
            RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            return DLC_STATUS_LINK_STATIONS_OPEN;
        }
#endif

        DLC_TRACE('d');

    case LLC_GROUP_SAP_OBJECT:

        //
        // This SAP must be in the linked list of SAPs (having
        // the same source SAP).
        //

        ppLinkListBase = (PVOID*)&pAdapterContext->apSapBindings[pStation->Sap.SourceSap];

        DEALLOCATE_SPIN_LOCK(&pStation->Sap.FlowControlLock);

        break;

    case LLC_LINK_OBJECT:

        //
        // Only a disconnected link station can be deactivated.
        // If this fails, then we must disconnect the link station,
        // if it is not already disconnected.
        //

        if (RunStateMachineCommand((PDATA_LINK)pStation, DEACTIVATE_LS) != STATUS_SUCCESS
        && pStation->Link.State != DISCONNECTING) {

            //
            // We must disconnect the link station immediately.
            // We don't care if we are at the moment in
            // a checkpoint state, that would delay the disconnection
            // until the other side has acknowledged it.
            // The link station must be killed now!
            //

            SendLlcFrame((PDATA_LINK)pStation, DLC_DISC_TOKEN | 1);
            DisableSendProcess((PDATA_LINK)pStation);
        }
        pStation->Link.State = LINK_CLOSED;
        ppLinkListBase = (PVOID *)&pStation->Link.pSap->pActiveLinks;
        ppLink =  SearchLinkAddress(pAdapterContext, pStation->Link.LinkAddr);
        *ppLink = pStation->Link.pNextNode;

        TerminateTimer(pAdapterContext, &pStation->Link.T1);
        TerminateTimer(pAdapterContext, &pStation->Link.T2);
        TerminateTimer(pAdapterContext, &pStation->Link.Ti);
        DLC_TRACE('c');
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    }
    RemoveFromLinkList(ppLinkListBase, pStation);

    //
    // Queue the asynchronous close command. Group sap and
    // disabling of non-existing link station may use
    // a null packet, because those commands are executed
    // synchronously (they cannot have pending packets)
    //

    if (pCompletionPacket != NULL) {
        AllocateCompletionPacket(pStation, LLC_CLOSE_COMPLETION, pCompletionPacket);
    }

    //
    // OK. Everything has been processed =>
    // now we can decrement the object counter.
    //

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // Delete the object NOW, if this was the last reference to it
    //

    LlcDereferenceObject(pStation);

    return STATUS_PENDING;
}


VOID
CompleteClose(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CancelStatus
    )

/*++

Routine Description:

    Procedure cancel all pending commands of llc object and
    deletes the object.
    The procedure returns a pending status as far the object
    has pending  transmits in NDIS.

Arguments:

    pLlcObject      - LLC object
    CancelStatus    - the status returned in the cancelled (completed) commands

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLlcObject->Gen.pAdapterContext;
    UINT Status;

#if DBG
    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)(pLlcObject->Gen.pLlcBinding->hClientContext);
#endif

    if (pLlcObject->Gen.ReferenceCount != 0) {
        return;
    }

    //
    // Cancel the queue transmit commands
    //

    CancelTransmitCommands(pLlcObject, CancelStatus);

    //
    // Queue also all commands queued in the link stations
    // (actually only LlcConnect and LlcDisconnect),
    // Note: the queue command eats the list of completion packets.
    //

    while (pLlcObject->Gen.pCompletionPackets != NULL) {
        Status = CancelStatus;
        if (pLlcObject->Gen.pCompletionPackets->Data.Completion.CompletedCommand == LLC_CLOSE_COMPLETION) {
            Status = STATUS_SUCCESS;
        }
        QueueCommandCompletion(pLlcObject,
                               (UINT)pLlcObject->Gen.pCompletionPackets->Data.Completion.CompletedCommand,
                               Status
                               );
    }

    //
    // release link station specific resources
    //

    if (pLlcObject->Gen.ObjectType == LLC_LINK_OBJECT) {

        //
        // The link may have been closed because of an error
        // or timeout (eg. somebody has turned the power off in the
        // other side). We must complete all pending transmits with
        // an error. We assume, that the link has not any more
        // any packets in NDIS queues, but is does not matter,
        // because NDIS packets of a link station will never be
        // directly indicated to the user (they may not exist any
        // more). Thus nothing fatal can happen, if we simply
        // complete all packets and return them to the main
        // packet storage.
        //

        DEALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool, pLlcObject);

    } else {

        FREE_MEMORY_FILE(pLlcObject);

    }
    pAdapterContext->ObjectCount--;
}


VOID
CancelTransmitCommands(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status
    )

/*++

Routine Description:

    Procedure removes the transmit commands of the given LLC client
    from the transmit queue.  This cannot cancel those dir/sap transmit
    already queued in NDIS, but the caller must first wait that the
    object has no commands in the NDIS queue.

Arguments:

    pLlcObject  - LLC object
    Status      - status to set in cancelled transmit commands

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLlcObject->Gen.pAdapterContext;

    //
    // We can (and must) cancel all pending transmits on a link
    // without any global locks, when the station has first
    // been removed from all global data structures,
    //

    if (pLlcObject->Gen.ObjectType == LLC_LINK_OBJECT) {
        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &((PDATA_LINK)pLlcObject)->SendQueue.ListHead,
                               NULL
                               );
        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &((PDATA_LINK)pLlcObject)->SentQueue,
                               NULL
                               );
        StopSendProcess(pAdapterContext, (PDATA_LINK)pLlcObject);

        //
        // We cannot leave any S- commands with a reference to the
        // link lan header.
        //

        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &pAdapterContext->QueueExpidited.ListHead,
                               &pAdapterContext->QueueExpidited
                               );
    } else {
        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &pAdapterContext->QueueDirAndU.ListHead,
                               &pAdapterContext->QueueDirAndU
                               );
    }
}


VOID
CancelTransmitsInQueue(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status,
    IN PLIST_ENTRY pQueue,
    IN PLLC_QUEUE pLlcQueue OPTIONAL
    )

/*++

Routine Description:

    Procedure removes the transmit commands of the given LLC client
    from the transmit queue.  This cannot cancel those dir/sap transmit
    already queued in NDIS, but the caller must first wait that the
    object has no commands in the NDIS queue.

Arguments:

    pLlcObject  - LLC object
    Status      - the status returned by the completed transmit commands
    pQueue      - a data links transmit queue
    pLlcQueue   - an optional LLC queue, that is disconnected from the send
                  task if the subqueue becomes empty.

Return Value:

    None.

--*/

{
    PLLC_PACKET pPacket;
    PLLC_PACKET pNextPacket;
    PADAPTER_CONTEXT pAdapterContext = pLlcObject->Gen.pAdapterContext;

    //
    // Cancel all pending transmit commands in LLC queues,
    // check first, if the transmit queue is empty.
    //

    if (IsListEmpty(pQueue)) {
        return;
    }

    for (pPacket = (PLLC_PACKET)pQueue->Flink; pPacket != (PLLC_PACKET)pQueue; pPacket = pNextPacket) {
        pNextPacket = pPacket->pNext;

        //
        // Complete the packet only if it has a correct binding handle
        // and it belongs the given client object.  Note: if binding
        // handle is null, then client object handle may be garbage!
        //

        if (pPacket->CompletionType > LLC_MAX_RESPONSE_PACKET
        && pPacket->Data.Xmit.pLlcObject == pLlcObject) {
            LlcRemoveEntryList(pPacket);

            //
            // We MUST NOT cancel those transmit commands, that are
            // still in the NDIS queue!!!!  The command completion would
            // make the MDLs in NDIS packet invalid => system would crash.
            //

            if (((pPacket->CompletionType) & LLC_I_PACKET_PENDING_NDIS) == 0) {
                if (pPacket->pBinding != NULL) {
                    LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
                    pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
                    pPacket->Data.Completion.Status = Status;
                    pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle;
                } else {

                    DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                }
            } else {

                //
                // The I-frames must be discarded by the link protocol, because
                // the link is now dead, and we will complete them immediately
                // when NdisSend the completes.
                //

                pPacket->CompletionType &= ~LLC_I_PACKET_UNACKNOWLEDGED;
                pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
                pPacket->Data.Completion.Status = Status;
                pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle;
            }
        }
    }

    //
    // Disconnect the list from the send task, if is now empty,
    // We don't use this check with the I- frame queues
    // (StopSendProcess does the same thing for them).
    //

    if (pLlcQueue != NULL
    && IsListEmpty(&pLlcQueue->ListHead)
    && pLlcQueue->ListEntry.Flink != NULL) {
        LlcRemoveEntryList(&pLlcQueue->ListEntry);
        pLlcQueue->ListEntry.Flink = NULL;
    }
}


//
//  Procedure sets new open options (receive mask) for a direct station.
//  The MAC frames must have been enabled, when the direct
//  object was opened on data link.
//  This is called whenever DLC receive command is issued for direct station.
//
VOID
LlcSetDirectOpenOptions(
    IN PLLC_OBJECT pDirect,
    IN USHORT OpenOptions
    )
{
    pDirect->Dir.OpenOptions = OpenOptions;
}


VOID
CompleteObjectDelete(
    IN PLLC_OBJECT pStation
    )

/*++

Routine Description:

    The function completes the delete operation for a llc object.

Arguments:

    pStation - link, sap or direct station handle

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    if (pStation->Gen.ReferenceCount == 0) {
        CompletePendingLlcCommand(pStation);
        BackgroundProcessAndUnlock(pAdapterContext);
    } else {
        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    }
}


VOID
CompletePendingLlcCommand(
    PLLC_OBJECT pLlcObject
    )

/*++

Routine Description:

    The routines cleans up all commands and event of a llc object
    from the the data link driver.

Arguments:

    pLlObject   - a data link object handle (opeque pointer)

Return Value:

    None.

--*/

{
    //
    // The reference count is zero only if the object is deleted,
    // otherwise this is just a reset for a link station.
    //

    if (pLlcObject->Gen.ReferenceCount == 0) {
        CompleteClose(pLlcObject, DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION);
    } else {
        CancelTransmitCommands(pLlcObject, DLC_STATUS_LINK_NOT_TRANSMITTING);
    }
}


VOID
LlcDereferenceObject(
    IN PVOID pStation
    )

/*++

Routine Description:

    The function dereferences any LLC object.
    THIS ROUTINE MUST BE CALLED ALL SPIN LOCKS UNLOCKED,
    BECAUSE IT MAY CALL BACK !!!!

Arguments:

    pStation - link, sap or direct station handle

Return Value:

    None.

--*/

{
    DLC_TRACE('L');
    DLC_TRACE((UCHAR)((PLLC_OBJECT)pStation)->Gen.ReferenceCount - 1);

    if (InterlockedDecrement((PLONG)&(((PLLC_OBJECT)(pStation))->Gen.ReferenceCount)) == 0) {
        CompleteObjectDelete(pStation);
    }

    /* pStation might have been freed by now
    DLC_TRACE('L');
    DLC_TRACE((UCHAR)((PLLC_OBJECT)pStation)->Gen.ReferenceCount); */
}


VOID
LlcReferenceObject(
    IN PVOID pStation
    )

/*++

Routine Description:

    The function references any LLC object.  The non-zero
    reference counter keeps LLC objects alive.

Arguments:

    pStation - link, sap or direct station handle

Return Value:

    None.

--*/

{
    InterlockedIncrement((PLONG)&(((PLLC_OBJECT)pStation)->Gen.ReferenceCount));
    DLC_TRACE('M');
    DLC_TRACE((UCHAR)((PLLC_OBJECT)pStation)->Gen.ReferenceCount);
}


#if !DLC_AND_LLC

//
// the following routines can be used as macros if DLC and LLC live in the same
// driver and the one knows about the other's structures
//

UINT
LlcGetReceivedLanHeaderLength(
    IN PVOID pBinding
    )

/*++

Routine Description:

    Returns the length of the LAN header of the frame last received from NDIS.
    The size is 14 for all Ethernet types except direct Ethernet frames, and
    whatever we stored in the RcvLanHeaderLength field of the ADAPTER_CONTEXT
    for Token Ring (can contain source routing)

Arguments:

    pBinding    - pointer to BINDING_CONTEXT structure describing adapter
                  on which frame of interest was received

Return Value:

    UINT

--*/

{
    return (((PBINDING_CONTEXT)pBinding)->pAdapterContext->NdisMedium == NdisMedium802_3)
        ? (((PBINDING_CONTEXT)pBinding)->pAdapterContext->FrameType == LLC_DIRECT_ETHERNET_TYPE)
            ? 12
            : 14
        : ((PBINDING_CONTEXT)pBinding)->pAdapterContext->RcvLanHeaderLength;
}


USHORT
LlcGetEthernetType(
    IN PVOID hContext
    )

/*++

Routine Description:

    Returns the Ethernet type set in the adapter context

Arguments:

    hContext    - handle of/pointer to BINDING_CONTEXT structure

Return Value:

    USHORT

--*/

{
    return ((PBINDING_CONTEXT)hContext)->pAdapterContext->EthernetType;
}


UINT
LlcGetCommittedSpace(
    IN PVOID hLink
    )

/*++

Routine Description:

    Returns the amount of committed buffer space

Arguments:

    hLink   -

Return Value:

    UINT

--*/

{
    return ((PDATA_LINK)hLink)->BufferCommitment;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcsend.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcsend.c

Abstract:

    The module implements all sending functions and the main
    send process. There three different send queues:
        - I_Queue
        - DirU_Queue
        - ExpiditedQueue (for LLC commands)

    Each queue has the pointer of a packet building primitive, that
    takes an NDIS packet of an queue element.

    Contents:
        RunSendTaskAndUnlock
        BackgroundProcessAndUnlock
        BackgroundProcess
        LlcNdisSendComplete
        GetI_Packet
        StartSendProcess
        EnableSendProcess
        StopSendProcess
        DisableSendProcess
        BuildDirOrU_Packet
        SendLlcFrame
        GetLlcCommandPacket
        SendNdisPacket
        CompleteSendAndLock
        RespondTestOrXid
        LlcSendU
        LlcSendI
        QueuePacket
        CheckAndDuplicatePacket
        BackgroundProcessWithinLock

Author:

    Antti Saarenheimo (o-anttis) 23-MAY-1991

Revision History:

--*/

#include <llc.h>

//
// The IEEE XID frame is constant data: (id, support Class II, maxin = 127};
//

LLC_XID_INFORMATION Ieee802Xid = {IEEE_802_XID_ID, LLC_CLASS_II, (127 << 1)};
PMDL pXidMdl = NULL;


//
// Because normally LAN networks are error free, we added this option
// to test the error recovery of DLC protocol.  It seems to work now
// quite well (but first we had to fix a fundamental bug in the sending
// of REJ-r0).
//

//
// Enable this to test REJECT states (after a major changes in
// the state machine).
//

//#define LLC_LOSE_I_PACKETS

#ifdef LLC_LOSE_I_PACKETS

#define DBG_ERROR_PERCENT(a)  (((a) * 0x8000) / 100)


//
// Pseudo random table to lose packets
//

static USHORT aRandom[1000] = {
        41, 18467,  6334, 26500, 19169, 15724, 11478, 29358, 26962, 24464,
      5705, 28145, 23281, 16827,  9961,   491,  2995, 11942,  4827,  5436,
     32391, 14604,  3902,   153,   292, 12382, 17421, 18716, 19718, 19895,
      5447, 21726, 14771, 11538,  1869, 19912, 25667, 26299, 17035,  9894,
     28703, 23811, 31322, 30333, 17673,  4664, 15141,  7711, 28253,  6868,
     25547, 27644, 32662, 32757, 20037, 12859,  8723,  9741, 27529,   778,
     12316,  3035, 22190,  1842,   288, 30106,  9040,  8942, 19264, 22648,
     27446, 23805, 15890,  6729, 24370, 15350, 15006, 31101, 24393,  3548,
     19629, 12623, 24084, 19954, 18756, 11840,  4966,  7376, 13931, 26308,
     16944, 32439, 24626, 11323,  5537, 21538, 16118,  2082, 22929, 16541,
      4833, 31115,  4639, 29658, 22704,  9930, 13977,  2306, 31673, 22386,
      5021, 28745, 26924, 19072,  6270,  5829, 26777, 15573,  5097, 16512,
     23986, 13290,  9161, 18636, 22355, 24767, 23655, 15574,  4031, 12052,
     27350,  1150, 16941, 21724, 13966,  3430, 31107, 30191, 18007, 11337,
     15457, 12287, 27753, 10383, 14945,  8909, 32209,  9758, 24221, 18588,
      6422, 24946, 27506, 13030, 16413, 29168,   900, 32591, 18762,  1655,
     17410,  6359, 27624, 20537, 21548,  6483, 27595,  4041,  3602, 24350,
     10291, 30836,  9374, 11020,  4596, 24021, 27348, 23199, 19668, 24484,
      8281,  4734,    53,  1999, 26418, 27938,  6900,  3788, 18127,   467,
      3728, 14893, 24648, 22483, 17807,  2421, 14310,  6617, 22813,  9514,
     14309,  7616, 18935, 17451, 20600,  5249, 16519, 31556, 22798, 30303,
      6224, 11008,  5844, 32609, 14989, 32702,  3195, 20485,  3093, 14343,
     30523,  1587, 29314,  9503,  7448, 25200, 13458,  6618, 20580, 19796,
     14798, 15281, 19589, 20798, 28009, 27157, 20472, 23622, 18538, 12292,
      6038, 24179, 18190, 29657,  7958,  6191, 19815, 22888, 19156, 11511,
     16202,  2634, 24272, 20055, 20328, 22646, 26362,  4886, 18875, 28433,
     29869, 20142, 23844,  1416, 21881, 31998, 10322, 18651, 10021,  5699,
      3557, 28476, 27892, 24389,  5075, 10712,  2600,  2510, 21003, 26869,
     17861, 14688, 13401,  9789, 15255, 16423,  5002, 10585, 24182, 10285,
     27088, 31426, 28617, 23757,  9832, 30932,  4169,  2154, 25721, 17189,
     19976, 31329,  2368, 28692, 21425, 10555,  3434, 16549,  7441,  9512,
     30145, 18060, 21718,  3753, 16139, 12423, 16279, 25996, 16687, 12529,
     22549, 17437, 19866, 12949,   193, 23195,  3297, 20416, 28286, 16105,
     24488, 16282, 12455, 25734, 18114, 11701, 31316, 20671,  5786, 12263,
      4313, 24355, 31185, 20053,   912, 10808,  1832, 20945,  4313, 27756,
     28321, 19558, 23646, 27982,   481,  4144, 23196, 20222,  7129,  2161,
      5535, 20450, 11173, 10466, 12044, 21659, 26292, 26439, 17253, 20024,
     26154, 29510,  4745, 20649, 13186,  8313,  4474, 28022,  2168, 14018,
     18787,  9905, 17958,  7391, 10202,  3625, 26477,  4414,  9314, 25824,
     29334, 25874, 24372, 20159, 11833, 28070,  7487, 28297,  7518,  8177,
     17773, 32270,  1763,  2668, 17192, 13985,  3102,  8480, 29213,  7627,
      4802,  4099, 30527,  2625,  1543,  1924, 11023, 29972, 13061, 14181,
     31003, 27432, 17505, 27593, 22725, 13031,  8492,   142, 17222, 31286,
     13064,  7900, 19187,  8360, 22413, 30974, 14270, 29170,   235, 30833,
     19711, 25760, 18896,  4667,  7285, 12550,   140, 13694,  2695, 21624,
     28019,  2125, 26576, 21694, 22658, 26302, 17371, 22466,  4678, 22593,
     23851, 25484,  1018, 28464, 21119, 23152,  2800, 18087, 31060,  1926,
      9010,  4757, 32170, 20315,  9576, 30227, 12043, 22758,  7164,  5109,
      7882, 17086, 29565,  3487, 29577, 14474,  2625, 25627,  5629, 31928,
     25423, 28520,  6902, 14962,   123, 24596,  3737, 13261, 10195, 32525,
      1264,  8260,  6202,  8116,  5030, 20326, 29011, 30771,  6411, 25547,
     21153, 21520, 29790, 14924, 30188, 21763,  4940, 20851, 18662, 13829,
     30900, 17713, 18958, 17578,  8365, 13007, 11477,  1200, 26058,  6439,
      2303, 12760, 19357,  2324,  6477,  5108, 21113, 14887, 19801, 22850,
     14460, 22428, 12993, 27384, 19405,  6540, 31111, 28704, 12835, 32356,
      6072, 29350, 18823, 14485, 20556, 23216,  1626,  9357,  8526, 13357,
     29337, 23271, 23869, 29361, 12896, 13022, 29617, 10112, 12717, 18696,
     11585, 24041, 24423, 24129, 24229,  4565,  6559,  8932, 22296, 29855,
     12053, 16962,  3584, 29734,  6654, 16972, 21457, 14369, 22532,  2963,
      2607,  2483,   911, 11635, 10067, 22848,  4675, 12938,  2223, 22142,
     23754,  6511, 22741, 20175, 21459, 17825,  3221, 17870,  1626, 31934,
     15205, 31783, 23850, 17398, 22279, 22701, 12193, 12734,  1637, 26534,
      5556,  1993, 10176, 25705,  6962, 10548, 15881,   300, 14413, 16641,
     19855, 24855, 13142, 11462, 27611, 30877, 20424, 32678,  1752, 18443,
     28296, 12673, 10040,  9313,   875, 20072, 12818,   610,  1017, 14932,
     28112, 30695, 13169, 23831, 20040, 26488, 28685, 19090, 19497,  2589,
     25990, 15145, 19353, 19314, 18651, 26740, 22044, 11258,   335,  8759,
     11192,  7605, 25264, 12181, 28503,  3829, 23775, 20608, 29292,  5997,
     17549, 29556, 25561, 31627,  6467, 29541, 26129, 31240, 27813, 29174,
     20601,  6077, 20215,  8683,  8213, 23992, 25824,  5601, 23392, 15759,
      2670, 26428, 28027,  4084, 10075, 18786, 15498, 24970,  6287, 23847,
     32604,   503, 21221, 22663,  5706,  2363,  9010, 22171, 27489, 18240,
     12164, 25542,  7619, 20913,  7591,  6704, 31818,  9232,   750, 25205,
      4975,  1539,   303, 11422, 21098, 11247, 13584, 13648,  2971, 17864,
     22913, 11075, 21545, 28712, 17546, 18678,  1769, 15262,  8519, 13985,
     28289, 15944,  2865, 18540, 23245, 25508, 28318, 27870,  9601, 28323,
     21132, 24472, 27152, 25087, 28570, 29763, 29901, 17103, 14423,  3527,
     11600, 26969, 14015,  5565,    28, 21543, 25347,  2088,  2943, 12637,
     22409, 26463,  5049,  4681,  1588, 11342,   608, 32060, 21221,  1758,
     29954, 20888, 14146,   690,  7949, 12843, 21430, 25620,   748, 27067,
      4536, 20783, 18035, 32226, 15185,  7038,  9853, 25629, 11224, 15748,
     19923,  3359, 32257, 24766,  4944, 14955, 23318, 32726, 25411, 21025,
     20355, 31001, 22549,  9496, 18584,  9515, 17964, 23342,  8075, 17913,
     16142, 31196, 21948, 25072, 20426, 14606, 26173, 24429, 32404,  6705,
     20626, 29812, 19375, 30093, 16565, 16036, 14736, 29141, 30814,  5994,
      8256,  6652, 23936, 30838, 20482,  1355, 21015,  1131, 18230, 17841,
     14625,  2011, 32637,  4186, 19690,  1650,  5662, 21634, 10893, 10353,
     21416, 13452, 14008,  7262, 22233,  5454, 16303, 16634, 26303, 14256,
       148, 11124, 12317,  4213, 27109, 24028, 29200, 21080, 21318, 16858,
     24050, 24155, 31361, 15264, 11903,  3676, 29643, 26909, 14902,  3561,
     28489, 24948,  1282, 13653, 30674,  2220,  5402,  6923,  3831, 19369,
      3878, 20259, 19008, 22619, 23971, 30003, 21945,  9781, 26504, 12392,
     32685, 25313,  6698,  5589, 12722,  5938, 19037,  6410, 31461,  6234,
     12508,  9961,  3959,  6493,  1515, 25269, 24937, 28869,    58, 14700,
     13971, 26264, 15117, 16215, 24555,  7815, 18330,  3039, 30212, 29288,
     28082,  1954, 16085, 20710, 24484, 24774,  8380, 29815, 25951,  6541,
     18115,  1679, 17110, 25898, 23073,   788, 23977, 18132, 29956, 28689,
     26113, 10008, 12941, 15790,  1723, 21363,    28, 25184, 24778,  7200,
      5071,  1885, 21974,  1071, 11333, 22867, 26153, 14295, 32168, 20825,
      9676, 15629, 28650,  2598,  3309,  4693,  4686, 30080, 10116, 12249,
};

#endif



VOID
RunSendTaskAndUnlock(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function is the send engine of the data link driver
    and the background task.
    It sends the queue objects as far as there is
    free NDIS packets in a small packet queue.
    The number of NDIS packets are limited because
    too deep send queues are bad for the connection based protocols.

    This is called from NdisIndicateReceiveComplete,
    NdisSendComplete and almost all LLC commands.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We must serialize the sending.  802.2 protocol
    // will simply die if two sequential packets are sent in a wrong
    // order.  The receiving and DLC level transmit processing can still
    // work even if the sending is syncronous in the data link level.
    //

    if (pAdapterContext->SendProcessIsActive == FALSE) {

        pAdapterContext->SendProcessIsActive = TRUE;

        while (!IsListEmpty(&pAdapterContext->NextSendTask)
        && pAdapterContext->pNdisPacketPool != NULL
        && !pAdapterContext->ResetInProgress) {

            //
            // executed the next send task in the send queue,
            // expidited data (if any) is always the first and
            // it is executed as far as there is any expidited packets.
            // The rest (I, UI, DIR) are executed in a round robin
            //

            SendNdisPacket(pAdapterContext,

                //
                // this next generates a pointer to a function which returns a
                // packet to send (eg. GetI_Packet)
                //

                ((PF_GET_PACKET)((PLLC_QUEUE)pAdapterContext->NextSendTask.Flink)->pObject)(pAdapterContext)
                );
        }

        pAdapterContext->SendProcessIsActive = FALSE;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}


VOID
BackgroundProcessAndUnlock(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function is both the send engine of the data link driver
    and the background task.
    It executes the queue objects as far as there is
    free NDIS packets in a small packet queue.
    The number of NDIS packets are limited because
    too deep send queues are bad for the connection based protocols.

    This is called from NdisIndicateReceiveComplete,
    NdisSendComplete and almost all LLC commands.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Prevent recursive background process calls, we don't need to start
    // new loop, if there is already one instance running somewhere
    // up in the stack.  Still we must do everything again,
    // if there was another backgroun process request, because
    // it may have been saved before the current position.
    //

    pAdapterContext->BackgroundProcessRequests++;

    if (pAdapterContext->BackgroundProcessRequests == 1) {

        //
        //  repeat this as far as there are new tasks
        //

        do {

            USHORT InitialRequestCount;

            InitialRequestCount = pAdapterContext->BackgroundProcessRequests;

            //
            // This actually completes only link transmit, connect and
            // disconnect commands.  The connectionless frames
            // are completed immediately when NDIS send completes.
            // Usually several frames are acknowledged in the same time.
            // Thus we create a local command list and execute
            // its all completions with a single spin locking.
            //

            while (!IsListEmpty(&pAdapterContext->QueueCommands)) {

                PLLC_PACKET pCommand;

                pCommand = LlcRemoveHeadList(&pAdapterContext->QueueCommands);

                RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                pCommand->pBinding->pfCommandComplete(pCommand->pBinding->hClientContext,
                                                      pCommand->Data.Completion.hClientHandle,
                                                      pCommand
                                                      );

                ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
            }

            //
            // indicate the queued events
            //

            while (!IsListEmpty(&pAdapterContext->QueueEvents)) {

                PEVENT_PACKET pEvent;

                pEvent = LlcRemoveHeadList(&pAdapterContext->QueueEvents);

                RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                pEvent->pBinding->pfEventIndication(pEvent->pBinding->hClientContext,
                                                    pEvent->hClientHandle,
                                                    pEvent->Event,
                                                    pEvent->pEventInformation,
                                                    pEvent->SecondaryInfo
                                                    );

                ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pEvent);

            }
            pAdapterContext->BackgroundProcessRequests -= InitialRequestCount;

        } while (pAdapterContext->BackgroundProcessRequests > 0);
    }

    //
    // also execute the send task if the send queue is not empty
    //

    pAdapterContext->LlcPacketInSendQueue = FALSE;
    RunSendTaskAndUnlock(pAdapterContext);
}


//
//  Background process entry for those, that don't
//  want to play with SendSpinLock.
//  We will execute the DPC taks on DPC level (hLockHandle = NULL),
//  that's perfectly OK as far as the major send operations by
//  LlcSendI and LlcSendU lower the IRQL level while they are sending
//  (to allow the DPC processing when we doing a long string io or
//  memory move to a slow ISA adapter)
//

VOID
BackgroundProcess(
    IN PADAPTER_CONTEXT pAdapterContext
    )
{
    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    BackgroundProcessAndUnlock(pAdapterContext);
}


VOID
LlcNdisSendComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    The routine handles NdisCompleteSend indication, it makes send
    completed indication to upper protocol drivers if necessary and
    executes the background process to find if there is any other
    frames in the send queue.
    This is usually called below the DPC level.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    //
    // this function may be called from NDIS wrapper at DPC level or from
    // SendNdisPacket() at passive level
    //

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    CompleteSendAndLock(pAdapterContext,
                        (PLLC_NDIS_PACKET)pNdisPacket,
                        NdisStatus
                        );

    //
    // Send command completion should not queue any command
    // completions or events.  The send queue is the only possiblity.
    //

    if (!IsListEmpty(&pAdapterContext->NextSendTask)) {
        RunSendTaskAndUnlock(pAdapterContext);
    } else {

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    }

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'dneS');
#endif // NDIS40
}


PLLC_PACKET
GetI_Packet(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function does:
        - selects the current link station in the queue and schedules
          (round robin) the queues for the next send
        - executes its send procedure
        - initializes the data link packet for the I frame

Arguments:

    pAdapterContext - adapter context

Return Value:

    PLLC_PACKET

--*/

{
    PDATA_LINK pLink;
    PLLC_PACKET pPacket;

    //
    // search the link (three LLC queues linked together!)
    //

    pLink = (((PLLC_QUEUE)pAdapterContext->QueueI.ListHead.Flink)->pObject);

/*
    This is probably just wasting of CPU cycles.  Remove the comments,
    if somebody has troubles because of this.  Stop send process will
    reschedule the queues in any way.

    //
    // We have a round robin scheduling for all main queues (U, I
    // and expidited) and for all sending links within the I- queue.
    // Select the next main task and the next sending link, if
    // there is any. (Usually we have only one sending object)
    //

    ScheduleQueue(&pAdapterContext->NextSendTask);
    ScheduleQueue(&pAdapterContext->QueueI.ListHead);
*/

    //
    // A resent packet may still not be completed by NDIS,
    // a very, very bad things begin to happen, if we try
    // to send packet again before it has been completed
    // by NDIS (we may complete the same packet twice).
    // The flag indicates, that the send process should be
    // restarted.
    //

    if (((PLLC_PACKET)pLink->SendQueue.ListHead.Flink)->CompletionType & LLC_I_PACKET_PENDING_NDIS) {
        ((PLLC_PACKET)pLink->SendQueue.ListHead.Flink)->CompletionType |= LLC_I_PACKET_WAITING_NDIS;
        StopSendProcess(pAdapterContext, pLink);
        return NULL;
    }

    //
    // move the next element in the send list to the list of unacknowledged packets
    //

    pPacket = LlcRemoveHeadList(&pLink->SendQueue.ListHead);
    LlcInsertTailList(&pLink->SentQueue, pPacket);

    if (IsListEmpty(&pLink->SendQueue.ListHead)) {
        StopSendProcess(pAdapterContext, pLink);
    }

    //
    // Copy SSAP and DSAP, reset the default stuff.
    // Set the POLL bit if this is the last frame of the send window.
    //

    pPacket->Data.Xmit.LlcHeader.I.Dsap = pLink->Dsap;
    pPacket->Data.Xmit.LlcHeader.I.Ssap = pLink->Ssap;
    pPacket->Data.Xmit.LlcHeader.I.Ns = pLink->Vs;
    pPacket->Data.Xmit.LlcHeader.I.Nr = pLink->Vr;
    pPacket->CompletionType = LLC_I_PACKET;

    //
    // We should actually lock the link, but we cannot do it,
    // because it is against the spin lock rules:  SendSpinLock has already
    // been acquired. But nothing terrible can happen: in the worst case
    // pLink->Ir_Ct update is lost and we send an extra ack.  All Vs updates
    // are done behind SendSpinLock in any way and the timers are
    // protected by the timer spin lock.
    //

    pLink->Vs += 2; // modulo 128 increment for 7 highest bit

    // Update VsMax only if this is a new send.
    // .... pLink->VsMax = pLink->Vs;

    if( pLink->Va <= pLink->VsMax ){
        if( pLink->VsMax < pLink->Vs ){
            pLink->VsMax = pLink->Vs;
        }else if( pLink->Vs < pLink->Va ){
            pLink->VsMax = pLink->Vs;
        }else{
            // Don't change, we are resending.
        }
    }else{
        if( pLink->Va < pLink->Vs ){
            // Don't change, wrapping.
        }else if( pLink->VsMax < pLink->Vs ){
            pLink->VsMax = pLink->Vs;
        }else{
            // Don't change, we are resending.
        }
    }



    //
    // We are now sending the acknowledge, we can stop the ack timer
    // if it has been running.  T1 timer must be started or reinitialized
    // and Ti must be stopped (as always when T1 is started).
    //

    if (pLink->T2.pNext != NULL) {
        StopTimer(&pLink->T2);
    }
    if (pLink->Ti.pNext != NULL) {
        StopTimer(&pLink->Ti);
    }

    //
    // Normally send an I- frame as Command-0 (without the poll bit),
    // but Command-Poll when the send window is full.
    // BUT! we cannot resend the packets with the poll bit (what?)
    //

    if (pLink->Vs == (UCHAR)(pLink->Va + pLink->Ww)) {

        //
        // The send process must be stopped until we have got
        // a response for this poll.  THE SEND PROCESS MUST BE
        // STOPPED BEFORE SendSpinLock IS OPENED.  Otherwise
        // simultaneous execution could send two polls, corrupt
        // the send queues, etc.
        //

        pLink->Flags |= DLC_SEND_DISABLED;
        StopSendProcess(pAdapterContext, pLink);

        //
        // IBM TR network architecture reference gives some hints how
        // to prevent the looping between check and sending states,
        // if link can send small S- frames, but not bigger data frames.
        // Unfortunately they do not provide any working solution.
        // They have described the problem on page 11-22 and in the
        // T1 expiration handler of all sending states (different T1
        // for sending and poll states in state machine).  All Is_Ct stuff
        // in the state machine is garbage, because the link sets the
        // transmit window to 1 immediately after a failed xmit and enters
        // to a check state after every retransmit => T1 timeout happens
        // in the current check state, but P_Ct never expires, because
        // the other side sends always S acknowledge and link returns
        // to open state until the nexting retransmit (which action
        // resets the P_Ct counter).
        // I added this check to send process and the decrement of
        // Is_Ct counter to all SEND_I_POLL actions => The link times out,
        // when it cannot send I-frames even if S- exchange works.
        //

        if (pLink->Vp == pLink->Vs && pLink->Is_Ct == 0) {

            //
            // The same I- frame has been retransmitted too many times.
            // We must shut down this link.  This happen now, when
            // we give T1 expired indication and and Is_Ct == 0.
            //

            RunStateMachineCommand(pLink, T1_Expired);

            //
            // We must (NDIS) complete the last packet now, because
            // the data link protocol may have already cancelled it.
            //

            pPacket->CompletionType &= ~LLC_I_PACKET_PENDING_NDIS;
            if (pPacket->CompletionType == LLC_I_PACKET_COMPLETE) {
                LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
            }

            //
            // We must execute the background process from here,
            // because the background process is not called from
            // the send task
            //

            BackgroundProcessAndUnlock(pAdapterContext);

            ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

            return NULL;
        } else {

            //
            // This is a Command-Poll, set the flag and the current
            // time stamp, whenever a new command poll was queued.
            //

            pLink->LastTimeWhenCmdPollWasSent = (USHORT)AbsoluteTime;
            pLink->Flags |= DLC_WAITING_RESPONSE_TO_POLL;

            pPacket->Data.Xmit.LlcHeader.I.Nr |= (UCHAR)LLC_I_S_POLL_FINAL;
            RunStateMachineCommand(pLink, SEND_I_POLL);
        }
    } else {
        pLink->Ir_Ct = pLink->N3;
        if (pLink->T1.pNext == NULL) {
            StartTimer(&pLink->T1);
        }
    }
    return pPacket;
}


VOID
StartSendProcess(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PDATA_LINK pLink
    )

/*++

Routine Description:

    The routine starts the send process of a data link station.
    It links the data link send queue to the send
    queue of all link stations and again that queue
    to the main send queue.
    THE QUEUES MUST BE SPIN LOCKED WHEN THIS IS CALLED!

Arguments:

    pAdapterContext - adapter context

    pLink -

Return Value:

    None

--*/

{
    //
    // This procedure can be called when there is nothing to send,
    // or when the send process is already running or when
    // the link is not in a active state for send.
    //

    if (pLink->SendQueue.ListEntry.Flink == NULL
    && !(pLink->Flags & DLC_SEND_DISABLED)
    && !IsListEmpty(&pLink->SendQueue.ListHead)) {

        //
        // Link the queue to the active I send tasks of all links
        //

        LlcInsertTailList(&pAdapterContext->QueueI.ListHead,
                          &pLink->SendQueue.ListEntry
                          );

        //
        // Link first the queue of I send tasks to the generic main
        // send task queue, if it has not yet been linked
        //

        if (pAdapterContext->QueueI.ListEntry.Flink == NULL) {
            LlcInsertTailList(&pAdapterContext->NextSendTask,
                              &pAdapterContext->QueueI.ListEntry
                              );
        }
    }
}


//
// Procedure is a space saving version of the send process enabling
// for the state machine. It also reset any bits disabling the send.
// CALL THIS ONLY FROM THE STATE MACHINE!!!!
//

VOID
EnableSendProcess(
    IN PDATA_LINK pLink
    )
{
    //
    // reset the disabled send state
    //

    pLink->Flags &= ~DLC_SEND_DISABLED;
    pLink->Gen.pAdapterContext->LlcPacketInSendQueue = TRUE;
    StartSendProcess(pLink->Gen.pAdapterContext, pLink);
}


VOID
StopSendProcess(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PDATA_LINK pLink
    )

/*++

Routine Description:


    The routine stops the send process of a data link station.
    It unlinks the data link send queue from the send
    queue of all link stations and again that queue
    from the main send queue.
    THE QUEUES MUST BE SPIN LOCKED WHEN THIS IS CALLED!

Arguments:

    pAdapterContext - adapter context

    pLink - data link object

Return Value:

    None

--*/

{
    //
    // Do all this only if the send process is really running.
    // The NULL pointer marks a list element as a disconnected,
    // A non-empty I- queue of a link may be disconencted from
    // the link station send queue of the adapter, if the link is
    // not in a sending state.  The same thing is true also on
    // the next level.
    //

    if (pLink->SendQueue.ListEntry.Flink != NULL) {

        //
        // unlink the queue from the active I send tasks of all links
        //

        LlcRemoveEntryList(&pLink->SendQueue.ListEntry);
        pLink->SendQueue.ListEntry.Flink = NULL;

        //
        // Unlink first the queue of all I send tasks from the
        // generic main send task queue, if it is now empty.
        //

        if (IsListEmpty(&pAdapterContext->QueueI.ListHead)) {
            LlcRemoveEntryList(&pAdapterContext->QueueI.ListEntry);
            pAdapterContext->QueueI.ListEntry.Flink = NULL;
        }
    }
}


//
// Procedure is a space saving version of the send process disabling
// for the state machine.
//

VOID
DisableSendProcess(
    IN PDATA_LINK pLink
    )
{
    //
    // set the send state variable disabled
    //

    pLink->Flags |= DLC_SEND_DISABLED;
    StopSendProcess(pLink->Gen.pAdapterContext, pLink);
}


PLLC_PACKET
BuildDirOrU_Packet(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function selects the next packet from the queue of connectionless
    frames (U, TEST, XID, DIX and Direct),
    initilizes the LLC packet for the send.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
    PLLC_PACKET pPacket;

    //
    // Take next element, select the next send queue and
    // unlink the current queue, if this was the only packet left.
    //

    pPacket = LlcRemoveHeadList(&pAdapterContext->QueueDirAndU.ListHead);

/*
    This is probably just wasting of CPU cycles.  Remove the comments,
    if somebody has troubles because of this.

    ScheduleQueue(&pAdapterContext->NextSendTask);
*/

    if (IsListEmpty(&pAdapterContext->QueueDirAndU.ListHead)) {
        LlcRemoveEntryList(&pAdapterContext->QueueDirAndU.ListEntry);
        pAdapterContext->QueueDirAndU.ListEntry.Flink = NULL;
    }
    return pPacket;
}


DLC_STATUS
SendLlcFrame(
    IN PDATA_LINK pLink,
    IN UCHAR LlcCommandId
    )

/*++

Routine Description:

    Function queues a Type 2 LLC S or U command frame.
    The LLC command code includes also the command/response and
    poll/final bits. That saves quite a lot space in the state machine,
    because this function is called from very many places.
    The code execution may also be faster because of this packing.

Arguments:

    pLink       - current data link station
    LlcCommand  - Packed LLC command (bit 0 is the Poll-Final bit,
                  bit 1 is the command/response and higher bits inlcude
                  the enumerated LLC command code.

Return Value:

    DLC_STATUS

--*/

{
    PLLC_PACKET pPacket;
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pPacket = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

    if (pPacket == NULL) {

        //
        // The non paged pool is empty, we must drop this
        // frame and hope that the protocol can recover (or disconnect)
        //

        return DLC_STATUS_NO_MEMORY;
    }
    pPacket->InformationLength = 0;
    pPacket->pBinding = NULL;

    //
    // Supervisory S commands (RR, RNR, REJ) consists 4 bytes and poll/final
    // bit is in a different place. The unnumbered U commands are only 3
    // bytes, but FRMR has some special data in the info field, that will be
    // added also to the 'extended LLC header'. We must reserve some
    // extra space for the FRMR data in the few NDIS packets!!!!!
    //

    if ((auchLlcCommands[LlcCommandId >> 2] & LLC_S_U_TYPE_MASK) == LLC_S_TYPE) {

        //
        // Build S frame
        //

        pPacket->Data.Xmit.LlcHeader.S.Command = auchLlcCommands[LlcCommandId >> 2];

#if(0)
        if(pPacket->Data.Xmit.LlcHeader.S.Command == LLC_REJ)
		{
			DbgPrint("SendLlcFrame: REJ\n");
		}
#endif
        pPacket->Data.Xmit.pLlcObject = (PLLC_OBJECT)pLink;
        pPacket->Data.Xmit.pLanHeader = pLink->auchLanHeader;
        pPacket->Data.Xmit.LlcHeader.S.Dsap  = pLink->Dsap;
        pPacket->Data.Xmit.LlcHeader.S.Ssap = pLink->Ssap;
        pPacket->CompletionType = LLC_I_PACKET_UNACKNOWLEDGED;
        pPacket->cbLlcHeader = sizeof(LLC_S_HEADER);       // 4
        pPacket->Data.Xmit.LlcHeader.S.Nr = pLink->Vr | (LlcCommandId & (UCHAR)LLC_I_S_POLL_FINAL);

        //
        // Second bit is the LLC command flag, set it to the source SAP
        //

        if (!(LlcCommandId & 2)) {
            pPacket->Data.Xmit.LlcHeader.S.Ssap |= LLC_SSAP_RESPONSE;

            //
            // We must have only one final response in LLC or NDIS
            // send queues in any time.  Thus we just discard any further
            // final responses until the previous one is sent.
            // This is a partial solution to the problem, when the
            // the Elnkii send queue is totally hung because of overflowing
            // packets.
            //

            if ((LlcCommandId & (UCHAR)LLC_I_S_POLL_FINAL)) {
// >>> SNA bug #9517 (NT bug #12907)
#if(0)
                if (pLink->Flags & DLC_FINAL_RESPONSE_PENDING_IN_NDIS) {

                    DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                    return STATUS_SUCCESS;
                }
#endif 

            // Changed the if statment to ignore the Poll only if the link
            // speed is 10MB (the unit of link speed measurement is 100 bps).
            //
            // Ignoring the Poll kills the DLC performance on 100MB ethernet 
            // (particularly on MP machines). The other end must time out (T1 timer) 
            // before it can send more data if we ignore the Poll here.

                if ((pLink->Flags & DLC_FINAL_RESPONSE_PENDING_IN_NDIS) &&
                     pAdapterContext->LinkSpeed <= 100000) {

                     DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                     return STATUS_SUCCESS;
                }

// >>> SNA bug #9517
                pLink->Flags |= DLC_FINAL_RESPONSE_PENDING_IN_NDIS;
            }
        } else if (LlcCommandId & (UCHAR)LLC_I_S_POLL_FINAL) {

            //
            // This is a Command-Poll, set the flag and the current
            // time stamp, whenever a new command poll was queued
            //

            pLink->LastTimeWhenCmdPollWasSent = (USHORT)AbsoluteTime;
            pLink->Flags |= DLC_WAITING_RESPONSE_TO_POLL;
        }

        //
        // The last sent command/response is included in the DLC statistics
        //

        pLink->LastCmdOrRespSent = pPacket->Data.Xmit.LlcHeader.S.Command;
    } else {
        pPacket->Data.XmitU.Command = auchLlcCommands[LlcCommandId >> 2];
        pPacket->Data.XmitU.Dsap  = pLink->Dsap;
        pPacket->Data.XmitU.Ssap = pLink->Ssap;

        //
        // Second bit is the LLC command flag, set it to the source SAP
        //

        if (!(LlcCommandId & 2)) {
            pPacket->Data.XmitU.Ssap |= LLC_SSAP_RESPONSE;
        }

        //
        // Build a U command frame (FRMR has some data!!!)
        //

        pPacket->cbLlcHeader = sizeof(LLC_U_HEADER);       // 3

        if (pPacket->Data.XmitU.Command == LLC_FRMR) {
            pPacket->cbLlcHeader += sizeof(LLC_FRMR_INFORMATION);
            pPacket->Data.Response.Info.Frmr = pLink->DlcStatus.FrmrData;
        }
        if (LlcCommandId & 1) {
            pPacket->Data.XmitU.Command |= LLC_U_POLL_FINAL;
        }

        //
        // U- commands (eg. UA response for DISC) may be sent after
        // the link object has been deleted.  This invalidates
        // the lan header pointer => we must change all U- commands
        // to response types.  Null object handle prevents the
        // the close process to cancel the packet, when the
        // station is closed.
        //

        //
        // RLF 05/09/94
        //
        // If the framing type stored in the link structure is unspecified then
        // either this is an AUTO configured binding and we haven't worked out
        // the type of framing to use, or this is not an AUTO configured binding.
        // In this case, defer to the address translation stored in the binding.
        // If the framing type is known, use it
        //

        if (pLink->FramingType == LLC_SEND_UNSPECIFIED) {
            pPacket->Data.XmitU.TranslationType = (UCHAR)pLink->Gen.pLlcBinding->InternalAddressTranslation;
        } else {
            pPacket->Data.XmitU.TranslationType = (UCHAR)pLink->FramingType;
        }
        pPacket->CompletionType = LLC_U_COMMAND_RESPONSE;

        pPacket->Data.XmitU.pLanHeader = (PUCHAR)ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

        if (pPacket->Data.XmitU.pLanHeader == NULL) {

            DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

            return DLC_STATUS_NO_MEMORY;
        }

        LlcMemCpy(pPacket->Data.XmitU.pLanHeader,
                  pLink->auchLanHeader,
                  pLink->cbLanHeaderLength
                  );

        //
        // In the AUTO mode in ethernet we duplicate all
        // TEST, XID and SABME packets and send them both in
        // 802.3 and DIX formats.
        //

        //
        // RLF 05/09/94
        //
        // Similarly, we duplicate DISC frames (since right now we don't
        // keep per-destination frame state information)
        //

        if (((pPacket->Data.XmitU.Command & ~LLC_U_POLL_FINAL) == LLC_SABME)
//        || ((pPacket->Data.XmitU.Command & ~LLC_U_POLL_FINAL) == LLC_DISC)
        ) {
            CheckAndDuplicatePacket(
#if DBG
                                    pAdapterContext,
#endif
                                    pLink->Gen.pLlcBinding,
                                    pPacket,
                                    &pAdapterContext->QueueExpidited
                                    );
        }

        //
        // The last sent command/response is included in the DLC statistics
        //

        pLink->LastCmdOrRespSent = pPacket->Data.XmitU.Command;
    }

    LlcInsertTailList(&pAdapterContext->QueueExpidited.ListHead, pPacket);

    //
    // The S- frames must be sent immediately before any I- frames,
    // because otherwise the sequential frames may have NRs in a
    // wrong order => FRMR  (that's why we insert the expidited
    // queue to the head instead of the tail.
    //

    pAdapterContext->LlcPacketInSendQueue = TRUE;
    if (pAdapterContext->QueueExpidited.ListEntry.Flink == NULL) {
        LlcInsertHeadList(&pAdapterContext->NextSendTask,
                          &pAdapterContext->QueueExpidited.ListEntry
                          );
    }

    return STATUS_SUCCESS;
}


PLLC_PACKET
GetLlcCommandPacket(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Function selects the next LLC command from the expidited queue.

Arguments:

    pAdapterContext - adapter context

Return Value:

    PLLC_PACKET

--*/

{
    PLLC_PACKET pPacket;

    //
    // Unlink the current task, if this was the only one left.
    // We will send the expidited packets as far as there is any
    //

    pPacket = LlcRemoveHeadList(&pAdapterContext->QueueExpidited.ListHead);
    if (pPacket->CompletionType == LLC_I_PACKET_UNACKNOWLEDGED) {
        pPacket->CompletionType = LLC_I_PACKET;
    }
    if (IsListEmpty(&pAdapterContext->QueueExpidited.ListHead)) {
        LlcRemoveEntryList(&pAdapterContext->QueueExpidited.ListEntry);
        pAdapterContext->QueueExpidited.ListEntry.Flink = NULL;
    }
    return pPacket;
}


VOID
SendNdisPacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    Function builds NDIS packet. LAN and LLC headers can be
    given separately to this routine. All NDIS packets
    include a fixed MDL descriptor and buffer for the headers.
    The actual data is linked after that header.
    I would say, that this is a clever algorithm,
    in this way we avoid quite well the supid NDIS packet management.
    We have just a few (5) NDIS packets for each adapter.

    The direct frames includes only the LAN header and MDL pointer are
    linked directly to the packet

    Steps:

    1. Reset the NDIS packet
    2. Get the frame translation type and initialize the completion
       packet.
    3. Build the LAN header into a small buffer in NDIS packet.
    4. Copy optional LLC header behind it
    5. Initialize NDIS packet for the send
    6. Send the packet
    7. if command not pending
        - Complete the packet (if there was a non-null request handle)
        - Link the NDIS packet back to the send queue.

Arguments:

    pAdapterContext - NDIS adapter context
    pPacket         - generic LLC transmit packet used for all transmit types

Return Value:

    NDIS_STATUS  (status of NdisSend)

--*/

{
    UCHAR LlcOffset;
    PLLC_NDIS_PACKET pNdisPacket;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Sometimes we must discard I-frame in GetI_Packet routine and
    // return a NULL packet
    //

    if (pPacket == NULL) {
        return;
    }


    //
    // Allocate an NDIS packet from the pool and reset the private NDIS header!
    //

    pNdisPacket = PopFromList((PLLC_PACKET)pAdapterContext->pNdisPacketPool);
    ResetNdisPacket(pNdisPacket);

    //
    // The internal LAN headers always have the correct address format. Only
    // Dir and Type 1 LAN headers need to be swapped, because they are owned
    // by users. The internal address swapping is defined by binding basis
    // because some transports may want to use DIX\DLC Saps, and others just
    // the normal 802.3 DLC
    //

    if (pPacket->CompletionType == LLC_I_PACKET) {
        pNdisPacket->pMdl->Next = pPacket->Data.Xmit.pMdl;
        ReferenceObject(pPacket->Data.Xmit.pLlcObject);

        //
        // Type 2 packets use always the LAN header of the link station
        //

        LlcMemCpy(pNdisPacket->auchLanHeader,
                  pPacket->Data.Xmit.pLanHeader,
                  LlcOffset = pPacket->Data.Xmit.pLlcObject->Link.cbLanHeaderLength
                  );

        //
        // Copy the LLC header as it is, the case set its offset
        //

        LlcMemCpy(&pNdisPacket->auchLanHeader[LlcOffset],
                  &pPacket->Data.Xmit.LlcHeader,
                  4
                  );
    } else {

        //
        // We must increment the reference counter of an LLC object, when
        // we give its pointer to NDIS queue (and increment it, when the
        // command is complete)
        //-------
        // We need two references for each transmit, First caller (DLC module)
        // must reference and dereference the object to keep it alive over
        // the synchronous code path here we do it second time to keep the
        // object alive, when it has pointers queued on NDIS
        //

        if (pPacket->CompletionType > LLC_MAX_RESPONSE_PACKET) {
            pNdisPacket->pMdl->Next = pPacket->Data.Xmit.pMdl;
            ReferenceObject(pPacket->Data.Xmit.pLlcObject);
        } else if (pPacket->CompletionType > LLC_MIN_MDL_PACKET) {
            pNdisPacket->pMdl->Next = pPacket->Data.Xmit.pMdl;
        } else {
            pNdisPacket->pMdl->Next = NULL;
        }

        //
        // LLC_TYPE_1 packets have non-null binding, the internally
        // sent packets (ie. XID and TEST frames) use the current
        // internal default format (tr, ethernet or dix)
        //

        LlcOffset = CopyLanHeader(pPacket->Data.XmitU.TranslationType,
                                  pPacket->Data.XmitU.pLanHeader,
                                  pAdapterContext->NodeAddress,
                                  pNdisPacket->auchLanHeader,
                                  pAdapterContext->ConfigInfo.SwapAddressBits
                                  );
        LlcMemCpy(&pNdisPacket->auchLanHeader[LlcOffset],
                  &pPacket->Data.XmitU.Dsap,
                  pPacket->cbLlcHeader
                  );
    }
    pNdisPacket->pCompletionPacket = pPacket;
    MmGetMdlByteCount(pNdisPacket->pMdl) = LlcOffset + pPacket->cbLlcHeader;

    //
    // We must set the lenth field of all 802.2 or DIX DLC Ethernet frames,
    // BUT NOT FOR DIX ethernet types having 2 bytes long 'LLC header'
    //

    if ((pAdapterContext->NdisMedium == NdisMedium802_3) && (pPacket->cbLlcHeader != 2)) {

        UINT InformationLength;

        InformationLength = pPacket->cbLlcHeader + pPacket->InformationLength;

        //
        // The possible offets are 12 and 14 and LLC offsets are 14 and 17
        //

        pNdisPacket->auchLanHeader[(LlcOffset & 0xfe) - 2] = (UCHAR)(InformationLength >> 8);
        pNdisPacket->auchLanHeader[(LlcOffset & 0xfe) - 1] = (UCHAR)InformationLength;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    RELEASE_DRIVER_LOCK();

    NdisChainBufferAtFront((PNDIS_PACKET)pNdisPacket, pNdisPacket->pMdl);

#if LLC_DBG

    if (pNdisPacket->ReferenceCount != 0) {
        DbgBreakPoint();
    }
    pNdisPacket->ReferenceCount++;

#endif

#ifdef LLC_LOSE_I_PACKETS

    //
    // This code tests the error recoverability of the LLC protocol.
    // We randomly delete packets to check how the protocol recovers.
    // We use current timer tick, running static and a table of random
    // numbers.
    //

    if (pPacket->CompletionType == LLC_I_PACKET) {

        static UINT i = 0;

        //
        // 2 % is high enough.  With 20 percent its takes forever to
        // send the data.  We send all discarded packets to Richard =>
        // we can see in the net which one packets were lost.
        //

        i++;
        if (aRandom[(i % 1000)] <= (USHORT)DBG_ERROR_PERCENT(2)) {
            if (pAdapterContext->NdisMedium == NdisMedium802_3) {
                memcpy(pNdisPacket->auchLanHeader,
                       "\0FIRTH",
                       6
                       );
            } else {
                memcpy(&pNdisPacket->auchLanHeader[2],
                       "\0FIRTH",
                       6
                       );
            }
        }
    }

#endif

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'dneS');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) == BIND_STATE_BOUND)
    {                                           
        NdisSend(&Status,
                 pAdapterContext->NdisBindingHandle,
                 (PNDIS_PACKET)pNdisPacket
                 );
    }
    // Above reference is removed by LlcNdisSendComplete handler.
#endif // NDIS40
    

    //
    // Ndis may return a synchronous status!
    //

    if (Status != NDIS_STATUS_PENDING) {
        LlcNdisSendComplete(pAdapterContext,
                            (PNDIS_PACKET)pNdisPacket,
                            Status
                            );
    }

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

}


VOID
CompleteSendAndLock(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_PACKET pNdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    The routines completes the connectionless packets and also the
    I-frames if they have already acknowledged by the other side.
    We will leave the send spinlock locked.

Arguments:

    pAdapterContext - current adapter context
    pNdisPacket     - the NDIS packet used in teh send.
    NdisStatus      - the status of the send operation

Return Value:

    None

--*/

{
    PLLC_PACKET pPacket;
    PLLC_OBJECT pLlcObject;
    UCHAR CompletionType;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE( 'A' );

    //
    // Only the connectionless packets issued by user needs
    // a command completion.  I- frames are indicated when they
    // are acknowledged by the remote link station.
    //

    pPacket = pNdisPacket->pCompletionPacket;
    pLlcObject = pPacket->Data.Xmit.pLlcObject;
    if ((CompletionType = pPacket->CompletionType) == LLC_TYPE_1_PACKET) {

        DLC_TRACE( 'j' );

        pPacket->Data.Completion.Status = NdisStatus;
        pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
        pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                             pLlcObject->Gen.hClientHandle,
                                             pPacket
                                             );
    }

    //
    // !!! DON'T TOUCH PACKET AFTER THE PREVIOUS PROCEDURE CALL
    //     (unless the packet type is different from Type 1)
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

#if LLC_DBG

    pNdisPacket->ReferenceCount--;
    if (pNdisPacket->ReferenceCount != 0) {
        DbgBreakPoint();
    }

#endif

    PushToList((PLLC_PACKET)pAdapterContext->pNdisPacketPool, (PLLC_PACKET)pNdisPacket);

    //
    // We first complete the internal packets of the data link driver,
    // that has no connection to the link objects.
    //

    if (CompletionType <= LLC_MAX_RESPONSE_PACKET) {

        DLC_TRACE('l');

        //
        // XID and U- command reponses have allocated two packets.
        // TEST reponses have allocated a non paged pool buffer
        // and MDL for the echones frame (it might have been 17 kB)
        //

        switch(CompletionType) {
        case LLC_XID_RESPONSE:
            pAdapterContext->XidTestResponses--;

#if LLC_DBG

            ((PLLC_PACKET)pPacket->Data.Response.pLanHeader)->pNext = NULL;

#endif

            DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket->Data.Response.pLanHeader);

            break;

        case LLC_U_COMMAND_RESPONSE:

#if LLC_DBG

            //
            // Break immediately, when we have sent a FRMR packet
            //

            if (pPacket->Data.Xmit.LlcHeader.U.Command == LLC_FRMR) {
                DbgBreakPoint();
            }
            ((PLLC_PACKET)pPacket->Data.Response.pLanHeader)->pNext = NULL;

#endif

            DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket->Data.Response.pLanHeader);

            break;

        case LLC_TEST_RESPONSE:
            pAdapterContext->XidTestResponses--;

            //
            // RLF 03/30/93
            //
            // The TEST response packet may have had 0 information field length,
            // in which case the MDL will be NULL
            //

            if (pPacket->Data.Response.Info.Test.pMdl) {
                IoFreeMdl(pPacket->Data.Response.Info.Test.pMdl);
            }
            FREE_MEMORY_ADAPTER(pPacket->Data.Response.pLanHeader);
            break;

#if LLC_DBG

        case LLC_DIX_DUPLICATE:
            break;

        default:
            LlcInvalidObjectType();
            break;

#endif

        }

        DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

    } else {

        //
        // We use extra status bits to indicate, when I- packet has been both
        // completed by NDIS and acknowledged by the other side of link
        // connection. An I packet can be queued to the completion queue by
        // the second quy (either state machine or SendCompletion handler)
        // only when the first guy has completed its work.
        // An I packet could be acknowledged by the other side before
        // its completion is indicated by NDIS.  Dlc Driver deallocates
        // the packet immediately, when Llc driver completes the acknowledged
        // packet => possible data corruption (if packet is reused before
        // NDIS has completed it).  This is probably not possible in a
        // single processor  NT- system, but very possible in multiprocessor
        // NT or systems without a single level DPC queue (like OS/2 and DOS).
        //

        if (CompletionType != LLC_TYPE_1_PACKET) {

            DLC_TRACE( 'k' );

            //
            // All packets allocated for S-type frames have null
            // binding context.  All the rest of packets must
            // be I- completions.
            //

            if (pPacket->pBinding == NULL) {

                //
                // We cannot send a new final response before
                // the previous one has been complete by NDIS.
                //

                if ((pPacket->Data.Xmit.LlcHeader.S.Nr & LLC_I_S_POLL_FINAL)
                && (pPacket->Data.Xmit.LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)) {
                    pLlcObject->Link.Flags &= ~DLC_FINAL_RESPONSE_PENDING_IN_NDIS;
                }

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

            } else {
                pPacket->CompletionType &= ~LLC_I_PACKET_PENDING_NDIS;

                //
                // A packet cannot be resent before the previous send
                // has been completed by NDIS.  We have simply stopped
                // the send process until the NDIS is completed here.
                //

                if (pPacket->CompletionType & LLC_I_PACKET_WAITING_NDIS) {
                    pPacket->CompletionType &= ~LLC_I_PACKET_WAITING_NDIS;
                    StartSendProcess(pAdapterContext, (PDATA_LINK)pLlcObject);
                } else if (pPacket->CompletionType == LLC_I_PACKET_COMPLETE) {

                    //
                    // We don't care at all about the result of the
                    // NDIS send operation with the I-frames.
                    // If the other side has acknowledged the packet,
                    // it is OK.   In that case we had to wait the send
                    // to complete, because an too early ack and
                    // command completion would have invalidated
                    // the pointer on NDIS.
                    //

                    LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
                    BackgroundProcessWithinLock(pAdapterContext);
                }
            }
        }

        //
        // Pending close commands of LLC object must wait until all its
        // NDIS send commands have been completed.
        // We must also indicate the completed send command.
        // The same must be true, when we are cancelling transmit commands.
        // The system crashes, if we remove a transmit command, that is
        // not yet sent or it is just being sent by NDIS.
        // => Dereference LlcObject when the ndis packet is complete,
        // We must run the background process
        //

        pLlcObject->Gen.ReferenceCount--;
        if (pLlcObject->Gen.ReferenceCount == 0) {
            CompletePendingLlcCommand(pLlcObject);
            BackgroundProcessWithinLock(pAdapterContext);
        }
        DLC_TRACE((UCHAR)pLlcObject->Gen.ReferenceCount);
    }
}


VOID
RespondTestOrXid(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN LLC_HEADER LlcHeader,
    IN UINT SourceSap
    )

/*++

Routine Description:

    Function builds a response packet for the XID or TEST frame.
    All TEST Commands are echoed directy back as responses.
    802.2 XID header is the only supported XID command type.

Arguments:

    pAdapterContext - current adapter context
	MacReceiveContext - For NdisTransferData
    LlcHeader       - The received LLC header
    SourceSap       - current source SAP

Return Value:

    None

--*/

{
    PLLC_PACKET pPacket = NULL;
    USHORT InfoFieldLength;
    UINT BytesCopied;
    NDIS_STATUS Status;
    PMDL pTestMdl = NULL;
    PUCHAR pBuffer = NULL;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Respond to a 802.2 XIDs and TESTs, and discard everything else
    // Echo the TEST commands back with the same information field
    // (but that's limited by our buffer capasity).
    //

    if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_TEST) {

        //
        // Echo the TEST frames back to the sender, but only, we do:
        // 1. Allocate a buffer from the non-paged pool
        // 2. Allocate a MDL for it
        // 3. Transfer the data
        //

        if (pAdapterContext->cbPacketSize < (pAdapterContext->RcvLanHeaderLength + sizeof(LLC_U_HEADER)) ) {
          return;
        }


        InfoFieldLength = (USHORT)(pAdapterContext->cbPacketSize
                        - (pAdapterContext->RcvLanHeaderLength
                        + sizeof(LLC_U_HEADER)));
        pBuffer = ALLOCATE_ZEROMEMORY_ADAPTER(pAdapterContext->cbPacketSize);
        if (pBuffer == NULL) {
            return;
        }

        //
        // RLF 03/30/93
        //
        // There may be no data in the info field to transfer. In this case
        // don't allocate a MDL
        //

        if (InfoFieldLength) {
            pTestMdl = IoAllocateMdl(pBuffer
                                     + pAdapterContext->RcvLanHeaderLength
                                     + sizeof(LLC_U_HEADER),
                                     InfoFieldLength,
                                     FALSE,
                                     FALSE,
                                     NULL
                                     );
            if (pTestMdl == NULL) {
                goto ProcedureErrorExit;
            }
            MmBuildMdlForNonPagedPool(pTestMdl);

            //
            // Copy the TEST data from NDIS to our buffer
            //

            ResetNdisPacket(&pAdapterContext->TransferDataPacket);

            RELEASE_DRIVER_LOCK();

            NdisChainBufferAtFront((PNDIS_PACKET)&pAdapterContext->TransferDataPacket, pTestMdl);

            //
            // ADAMBA - Removed pAdapterContext->RcvLanHeaderLength
            // from ByteOffset (the fourth param).
            //

            NdisTransferData(&Status,
                             pAdapterContext->NdisBindingHandle,
                             MacReceiveContext,
                             sizeof(LLC_U_HEADER)

                             //
                             // RLF 05/09/94
                             //
                             // if we have received a DIX packet then the data
                             // starts 3 bytes from where NDIS thinks the start
                             // of non-header data is
                             //
                             // ASSUME: Only DIX frames have header length of
                             // 17 (i.e. on Ethernet)
                             //
                             // What about FDDI?
                             //

                             + ((pAdapterContext->RcvLanHeaderLength == 17) ? 3 : 0),
                             InfoFieldLength,
                             (PNDIS_PACKET)&pAdapterContext->TransferDataPacket,
                             &BytesCopied
                             );

            ACQUIRE_DRIVER_LOCK();

            //
            // We don't care if the transfer data is still pending,
            // If very, very unlikely, that the received dma would
            // write the data later, than a new transmit command
            // would read the same data. BUT we cannot continue,
            // if transfer data failed.
            //

            if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
                goto ProcedureErrorExit;
            }
        }
    } else if (((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) != LLC_XID)
    || (LlcHeader.auchRawBytes[3] != IEEE_802_XID_ID)) {

        //
        // This was not a IEEE 802.2 XID !!!
        //

        return;
    }

    //
    // We have only a limited number reponse packets available
    // for the XID and TEST responses. Thus we will
    // drop many packets in a broadcast storms created by token-ring
    // source routing bridges, that is
    // actually a good thing. On the other hand we may
    // also loose some packets that should have been reponsed,
    // but who cares (this is a connectionless thing).
    // (This is probably wasted effort, XID and TEST frames are not
    // usually sent with the broadcast bit set).
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    if ((pAdapterContext->XidTestResponses < MAX_XID_TEST_RESPONSES)
    && ((pPacket = (PLLC_PACKET)ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool)) != NULL)) {

        if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_XID) {

            pPacket->Data.Xmit.pLanHeader = (PUCHAR)ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

            if (pPacket->Data.Xmit.pLanHeader == NULL) {

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                pPacket = NULL;
                goto LockedErrorExit;
            } else {
                LlcMemCpy(&pPacket->Data.Response.Info,
                          &Ieee802Xid,
                          sizeof(Ieee802Xid)
                          );
                pPacket->InformationLength = 0;
                pPacket->cbLlcHeader = sizeof(Ieee802Xid) + sizeof(LLC_U_HEADER);
                pPacket->CompletionType = LLC_XID_RESPONSE;
            }
        } else {
            pPacket->Data.Xmit.pLanHeader = pBuffer;
            pPacket->cbLlcHeader = sizeof(LLC_U_HEADER);
            pPacket->CompletionType = LLC_TEST_RESPONSE;
            pPacket->Data.Response.Info.Test.pMdl = pTestMdl;
            pPacket->InformationLength = InfoFieldLength;
        }
        pAdapterContext->XidTestResponses++;

        //
        // The packet initialization is the same for XID and TEST
        //

        pPacket->Data.XmitU.Dsap = (UCHAR)(LlcHeader.U.Ssap & ~LLC_SSAP_RESPONSE);
        pPacket->Data.XmitU.Ssap = (UCHAR)(SourceSap | LLC_SSAP_RESPONSE);
        pPacket->Data.XmitU.Command = LlcHeader.U.Command;

        if (pAdapterContext->NdisMedium == NdisMedium802_5) {
            pPacket->Data.Response.TranslationType = LLC_SEND_802_5_TO_802_5;
        } else if (pAdapterContext->NdisMedium == NdisMediumFddi) {
            pPacket->Data.Response.TranslationType = LLC_SEND_FDDI_TO_FDDI;
        } else if (pAdapterContext->RcvLanHeaderLength == 17) {
            pPacket->Data.Response.TranslationType = LLC_SEND_802_3_TO_DIX;
        } else {
            pPacket->Data.Response.TranslationType = LLC_SEND_802_3_TO_802_3;
        }
        LlcBuildAddressFromLanHeader(pAdapterContext->NdisMedium,
                                     pAdapterContext->pHeadBuf,
                                     pPacket->Data.Xmit.pLanHeader
                                     );

        //
        // Connect the packet to the send queues, we can use a subprocedure
        // because this is not on the main code path
        //

        QueuePacket(pAdapterContext, &pAdapterContext->QueueDirAndU, pPacket);

        //
        // Request and send process execution from the receive indication
        //

        pAdapterContext->LlcPacketInSendQueue = TRUE;
    }

LockedErrorExit:

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

ProcedureErrorExit:

    if (pPacket == NULL) {
        if (pBuffer) {
            FREE_MEMORY_ADAPTER(pBuffer);
        }
        if (pTestMdl != NULL) {
            IoFreeMdl(pTestMdl);
        }
    }
}

//
// The table maps all SAP send commands to the actual LLC commands
//

static struct {
    UCHAR   ResponseFlag;
    UCHAR   Command;
} Type1_Commands[LLC_LAST_FRAME_TYPE / 2] = {
    {(UCHAR)-1, (UCHAR)-1},
    {(UCHAR)-1, (UCHAR)-1},
    {(UCHAR)-1, (UCHAR)-1},
    {0, LLC_UI},                                        // UI command
    {0, LLC_XID | LLC_U_POLL_FINAL},                    // XID_COMMAND_POLL
    {0, LLC_XID},                                       // XID_COMMAND_NOT_POLL
    {LLC_SSAP_RESPONSE, LLC_XID | LLC_U_POLL_FINAL},    // XID_RESPONSE_FINAL
    {LLC_SSAP_RESPONSE, LLC_XID},                       // XID_RESPONSE_NOT_FINAL
    {LLC_SSAP_RESPONSE, LLC_TEST | LLC_U_POLL_FINAL},   // TEST_RESPONSE_FINAL
    {LLC_SSAP_RESPONSE, LLC_TEST},                      // TEST_RESPONSE_NOT_FINAL
    {(UCHAR)-1, (UCHAR)-1},
    {0, LLC_TEST | LLC_U_POLL_FINAL}                    // TEST_RESPONSE_FINAL
};


VOID
LlcSendU(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pPacket,
    IN UINT eFrameType,
    IN UINT uDestinationSap
    )

/*++

Routine Description:

    Function sends the given network frame. and sets up
    The frame may be a direct frame or Type 1 connectionless
    frame (UI, XID or TEST).

    First we build LLC (or ethernet type) header for the frame
    and then we either send the packet directly or queue it
    on data link.

Arguments:

    pStation        - Link, SAP or Direct station handle
    pPacket         - data link packet, also the completion handle for
                      the upper protocol.
    eFrameType      - the sent frame type
    uDestinationSap - destination sap or dix ethernet type

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;
    UINT Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('U');

    pPacket->pBinding = pStation->Gen.pLlcBinding;
    pPacket->Data.Xmit.pLlcObject = pStation;
    pPacket->CompletionType = LLC_TYPE_1_PACKET;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // Build LLC header for SAP stations, the direct stations do not have any
    // LLC header
    //

    switch (pStation->Gen.ObjectType) {
    case LLC_SAP_OBJECT:
        pPacket->cbLlcHeader = sizeof(LLC_U_HEADER);
        pPacket->Data.XmitU.TranslationType = (UCHAR)pStation->Gen.pLlcBinding->AddressTranslation;
        pPacket->Data.XmitU.Dsap = (UCHAR)uDestinationSap;
        pPacket->Data.XmitU.Ssap = (UCHAR)pStation->Sap.SourceSap;
        pPacket->Data.XmitU.Ssap |= Type1_Commands[eFrameType >> 1].ResponseFlag;
        pPacket->Data.XmitU.Command = Type1_Commands[eFrameType >> 1].Command;

        //
        // Do the UI- code path ASAP, then check TEST and XID special cases
        //

        if (pPacket->Data.XmitU.Command != LLC_UI) {

            //
            // Data link driver must build the DLC headers if it handles XID
            // frames internally. In this case we use a constant XID info field
            //

            if ((pStation->Sap.OpenOptions & LLC_HANDLE_XID_COMMANDS)
            && ((eFrameType == LLC_XID_COMMAND_POLL)
            || (eFrameType == LLC_XID_COMMAND_NOT_POLL))) {

                pPacket->Data.XmitU.pMdl = pXidMdl;
            }

            //
            // duplicated TEST and XID frame responses are in a separate
            // function since they're off the main code path. The code is also
            // used in more than one place
            //

            Status = CheckAndDuplicatePacket(
#if DBG
                                             pAdapterContext,
#endif
                                             pStation->Gen.pLlcBinding,
                                             pPacket,
                                             &pAdapterContext->QueueDirAndU
                                             );
            if (Status != DLC_STATUS_SUCCESS) {
                goto ErrorExit;
            }
        }
        break;

    case LLC_DIRECT_OBJECT:

        //
        // We must not send MAC frames to an ethernet network!!!
        // Bit7 and bit6 in FC byte defines the frame type in token ring.
        // 00 => MAC frame (no LLC), 01 => LLC, 10,11 => reserved.
        // We send all other frames to direct except 01 (LLC)
        //

        if (pAdapterContext->NdisMedium != NdisMedium802_5
        && (pPacket->Data.XmitU.pLanHeader[1] & 0xC0) != 0x40) {
            goto ErrorExit;
        }
        pPacket->Data.XmitU.TranslationType = (UCHAR)pStation->Gen.pLlcBinding->AddressTranslation;
        pPacket->cbLlcHeader = 0;
        break;

    case LLC_DIX_OBJECT:

        //
        // Return error if we are sending DIX frames to a token-ring network.
        // The DIX lan header is always in an ethernet format.
        // (But lan headers for LLC and DIR frames are in token-ring
        // format)
        //

        if (pAdapterContext->NdisMedium != NdisMedium802_3) {
            Status = DLC_STATUS_UNAUTHORIZED_MAC;
            goto ErrorExit;
        }
        pPacket->cbLlcHeader = 2;
        pPacket->Data.XmitDix.TranslationType = LLC_SEND_DIX_TO_DIX;
        pPacket->Data.XmitDix.EthernetTypeLowByte = (UCHAR)uDestinationSap;
        pPacket->Data.XmitDix.EthernetTypeHighByte = (UCHAR)(uDestinationSap >> 8);
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    }

    //
    // Update the statistics, we may count the transmits as well here because
    // the failed transmissions are not counted. This should be moved to
    // SendComplete and be incremented only if STATUS_SUCCESS and if we counted
    // only the successful transmits. I don't really know which one should be
    // counted
    //

    pStation->Sap.Statistics.FramesTransmitted++;

    LlcInsertTailList(&pAdapterContext->QueueDirAndU.ListHead, pPacket);

    if (pAdapterContext->QueueDirAndU.ListEntry.Flink == NULL) {
        LlcInsertTailList(&pAdapterContext->NextSendTask,
                          &pAdapterContext->QueueDirAndU.ListEntry
                          );
    }

    RunSendTaskAndUnlock(pAdapterContext);
    return;

ErrorExit:

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    pPacket->Data.Completion.Status = Status;
    pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
    pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                         pStation->Gen.hClientHandle,
                                         pPacket
                                         );
}


VOID
LlcSendI(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The primitive implements a pure connection-oriented LLC Class II send.
    It sends frame to the remote link station and
    indicates the upper protocol when the data has been acknowledged.
    The link station provides all address information and LLC header.
    Function queues the given I packet to the queue and connects the
    I- packet queue to the main send queue, if it has not
    yet been connected.

Arguments:

    pStation    - link, sap or direct station handle
    pPacket     - data link packet, it is used also a request handle
                  to identify the command completion

Return Value:

    None.

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('I');

    pPacket->pBinding = pStation->Gen.pLlcBinding;
    pPacket->cbLlcHeader = sizeof(LLC_I_HEADER);

    //
    // We keep the acknowledge bit set, because it identifies that
    // the packet is not yet in the NDIS queue
    //

    pPacket->CompletionType = LLC_I_PACKET_UNACKNOWLEDGED;
    pPacket->Data.Xmit.pLlcObject = (PLLC_OBJECT)pStation;
    pPacket->Data.Xmit.pLanHeader = pStation->auchLanHeader;

    //
    // We check the info field length for I- frames.
    // All Type 1 frames are checked by the data link.
    // Actually it checks also the I-frames, but
    // data links do not care about the physical errors.
    // It would disconnect the link after the too
    // many retries.
    //

    if (pPacket->InformationLength > pStation->MaxIField) {
        pPacket->Data.Completion.Status = DLC_STATUS_INVALID_FRAME_LENGTH;
        pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
        pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                             pStation->Gen.hClientHandle,
                                             pPacket
                                             );
    } else {

        PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;

        //
        // We must do all queue handling inside the send spin lock. We also have
        // to enable the send process and run the background process only when
        // the send queue has been emptied
        //

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        if (!(PrimaryStates[pStation->State] & LLC_LINK_OPENED)) {

            RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

            //
            // The 802.2 state machine may discard the data send request.
            // It may also only queue the packet, but to keep the send process
            // disabled
            //

            pPacket->Data.Completion.Status = DLC_STATUS_LINK_NOT_TRANSMITTING;
            pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
            pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                                 pStation->Gen.hClientHandle,
                                                 pPacket
                                                 );
        } else {
            LlcInsertTailList(&pStation->SendQueue.ListHead, pPacket);

            if (pStation->SendQueue.ListEntry.Flink == NULL) {
                StartSendProcess(pAdapterContext, pStation);
            }
            RunSendTaskAndUnlock(pAdapterContext);
        }
    }
}


VOID
QueuePacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_QUEUE pQueue,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The routines queues a packet to a queue and connects the
    queue to the send tack list, if it was not connected.
    This procedure is called from the non-timecritical code paths
    just to save some extra code.

Arguments:

    pAdapterContext - context of the data link adapter
    pQueue          - a special send queue structure
    pPacket         - transmit packet

Return Value:

    None

--*/

{
    LlcInsertTailList(&pQueue->ListHead, pPacket);

    if (pQueue->ListEntry.Flink == NULL) {
        LlcInsertTailList(&pAdapterContext->NextSendTask, &pQueue->ListEntry);
    }
}


DLC_STATUS
CheckAndDuplicatePacket(
#if DBG
    IN PADAPTER_CONTEXT pAdapterContext,
#endif
    IN PBINDING_CONTEXT pBinding,
    IN PLLC_PACKET pPacket,
    IN PLLC_QUEUE pQueue
    )

/*++

Routine Description:

    If determining the ethernet type dynamically, create a duplicate DIX frame
    for a SABME or XID or TEST frame

Arguments:

    pBindingContext - current data link binding context
    pPacket         - transmit packet
    pQueue          - a special send queue structure

Return Value:

    DLC_STATUS
        Success - DLC_STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PLLC_PACKET pNewPacket;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pBinding->EthernetType == LLC_ETHERNET_TYPE_AUTO) {

        pNewPacket = ALLOCATE_PACKET_LLC_PKT(pBinding->pAdapterContext->hPacketPool);

        if (pNewPacket == NULL) {
            return DLC_STATUS_NO_MEMORY;
        } else {

            *pNewPacket = *pPacket;
            pNewPacket->pBinding = NULL;
            pNewPacket->CompletionType = LLC_DIX_DUPLICATE;

            //
            // We always send first the 802.3 packet and then the DIX one.
            // The new packet must be sent first, because it has no resources
            // associated with it. Therefore we must change the type of the
            // old packet
            //
            //

            if (pPacket->Data.XmitU.TranslationType == LLC_SEND_802_5_TO_802_3) {

                //
                //  token-ring -> dix
                //

                pPacket->Data.XmitU.TranslationType = LLC_SEND_802_5_TO_DIX;
            } else if (pPacket->Data.XmitU.TranslationType == LLC_SEND_802_3_TO_802_3) {

                //
                //  ethernet 802.3 -> dix
                //

                pPacket->Data.XmitU.TranslationType = LLC_SEND_802_3_TO_DIX;
            }
            QueuePacket(pBinding->pAdapterContext, pQueue, pNewPacket);
        }
    }
    return DLC_STATUS_SUCCESS;
}


VOID
BackgroundProcessWithinLock(
    IN PADAPTER_CONTEXT pAdapterContext
    )
{
    ASSUME_IRQL(DISPATCH_LEVEL);

    BackgroundProcessAndUnlock(pAdapterContext);

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcsm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  ICL Data /Personal Systems

Module Name:

    llcsm.c

Abstract:

    The module implements a IEEE 802.2 compatible state machine as
    defined in IBM Token-Ring Architectural reference.
    The most of the code in the module is compiled by the finite state
    machine compiler from the IBM state machine definition (llcsm.fsm).
    The compiler is build as a part of this product.

    DO NOT MODIFY ANY CODE INSIDE:
        - #ifdef    FSM_CONST
        - #ifdef    FSM_DATA
        - #ifdef    FSM_PREDICATE_CASES
        - #ifdef    FSM_ACTION_CASES

    That code is genereated from the definition file of the state machine.
    Any changes in the state machine must be done into 802-2.fsm definition
    file (or to the source files of finite state machine cross compiler, fsmx).


    To understand the backgroung of this state machine, you should read
    Chapters 11 and 12 in IBM Token-Ring Architecture Reference.

    The this module produces 2100H code and A00H data when compiled for 386.

    Contents:
        RunStateMachine

Author:

    Antti Saarenheimo (o-anttis) 23-MAY-1991

Revision History:

--*/

#include <llc.h>

//*********************************************************************
//
//  C- macros for LAN DLC state machine
//
enum StateMachineOperMode {
    LLC_NO_OPER = 0,
    LOCAL_INIT_PENDING = 1,
    REMOTE_INIT_PENDING = 2,
    OPER_MODE_PENDING = 4,
    IS_FRAME_PENDING = 8,
    STATE_LOCAL_BUSY = 0x10,
    STATE_REMOTE_BUSY = 0x20,
    STACKED_DISCp_CMD = 0x40
};

#define SEND_RNR_CMD( a )    SendLlcFrame( pLink, DLC_RNR_TOKEN | \
    DLC_TOKEN_COMMAND | a )
#define SEND_RR_CMD( a )     SendLlcFrame( pLink, DLC_RR_TOKEN | \
    DLC_TOKEN_COMMAND | a )
#define DLC_REJ_RESPONSE( a ) uchSendId = \
    (UCHAR)(DLC_REJ_TOKEN | DLC_TOKEN_RESPONSE) | (UCHAR)a
#if 0
#define DLC_REJ_COMMAND( a ) uchSendId = \
	 (UCHAR)(DLC_REJ_TOKEN | DLC_TOKEN_COMMAND) | (UCHAR)a
#endif	// 0
#define DLC_RNR_RESPONSE( a ) uchSendId = \
    (UCHAR)(DLC_RNR_TOKEN | DLC_TOKEN_RESPONSE) | (UCHAR)a
#define DLC_RNR_COMMAND( a )  uchSendId = \
    (UCHAR)(DLC_RNR_TOKEN | DLC_TOKEN_COMMAND) | (UCHAR)a
#define DLC_RR_RESPONSE( a )  uchSendId = \
    (UCHAR)(DLC_RR_TOKEN | DLC_TOKEN_RESPONSE) | (UCHAR)a
#define DLC_RR_COMMAND( a )   uchSendId = \
    (UCHAR)(DLC_RR_TOKEN | DLC_TOKEN_COMMAND) | (UCHAR)a
#define DLC_DISC(a)             uchSendId = (UCHAR)DLC_DISC_TOKEN | (UCHAR)a
#define DLC_DM(a)               uchSendId = (UCHAR)DLC_DM_TOKEN | (UCHAR)a
#define DLC_FRMR(a)             uchSendId = (UCHAR)DLC_FRMR_TOKEN | (UCHAR)a
#define DLC_SABME(a)            uchSendId = (UCHAR)DLC_SABME_TOKEN | (UCHAR)a
#define DLC_UA(a)               uchSendId = (UCHAR)DLC_UA_TOKEN | (UCHAR)a
#define TimerStartIf( a )       StartTimer( a )
#define TimerStart( a )         StartTimer( a )
#define TimerStop( a )          StopTimer( a )
#define EnableLinkStation( a )
#define DisableLinkStation( a )
#define SEND_ACK( a )           SendAck( a )

//
//  Stack all event indications, they must be made immediate after
//  the state machine has been run
//
#define EVENT_INDICATION( a )   pLink->DlcStatus.StatusCode |= a


UCHAR auchLlcCommands[] = {
    0,
    LLC_REJ,
    LLC_RNR,
    LLC_RR,
    LLC_DISC,
    LLC_DM,
    LLC_FRMR,
    LLC_SABME,
    LLC_UA
};


#ifdef    FSM_DATA
// Flag for the predicate switch
#define PC     0x8000
USHORT aLanLlcStateInput[21][44] = {
{     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     1,     2,     2,     2,     0,     2,
      2,     2,     2,     2},
{    13,    13,     3,     3,     3,     3,  9|PC,  9|PC,     3,     3,
      3,     3,     3,    15,     3,     3,     3,    15,     3,     3,
      3,    15,     3,     3,     3,    15,     3,     3,     3,    15,
      3,     3,     3,     3,     2,     4,     5,     6,     0,  1|PC,
   4|PC,    11,  7|PC,     2},
{    24,    24,    25,    25,     3,     3, 22|PC, 22|PC,     0, 25|PC,
  29|PC,     0, 29|PC, 32|PC, 35|PC,     0, 35|PC, 38|PC, 47|PC,     0,
  47|PC, 50|PC, 41|PC,     0, 41|PC, 44|PC, 47|PC,     0, 47|PC, 50|PC,
      3,     3,     3,     3,     2,     2,     5,     6,     0,     2,
  11|PC, 14|PC, 17|PC,     2},
{    47,    47,    48,    48,     3,     3,    49,    49,     0,    48,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     2,     2,     5,     6,     0,     2,
      2,     2, 53|PC,     2},
{    53,    53,    54,    54,    55,    55,    56,    56,     3,     3,
      3,     3,    57,    57,     3,     3,    57,    57,     3,     3,
     57,    57,     3,     3,    57,    57,     3,     3,    57,    57,
      3,     3,     3,     3,     2,     2,     5,     6,     0,    50,
     51,    52,     2,     2},
{    66,    66,    67,    67,    68,    68,    69,    69,    70,    70,
     71,    71,    71,    72,    73,    73,    73,    74, 59|PC, 59|PC,
  59|PC, 62|PC,    79,    79,    79,    80,    76,    76,    76,    81,
     59,    59,    59,    60,     2,     2,    58,     2,    61,     2,
     62,    63, 56|PC,    65},
{    89,    89,    90,    90,    91,    91,    92,    92,    93,    93,
     94,    94,    94,    95,    94,    94,    94,    95, 59|PC, 59|PC,
  59|PC, 68|PC,    97,    97,    97,    98,    76,    76,    76,    99,
     83,    83,    83,    84,     2,     2,     2,    82,    85,     2,
     86,    87, 65|PC,     2},
{    89,    89,    90,    90,    91,    91,    92,    92,   106,   106,
    107,   107,   107,   108,   109,   109,   109,   110, 59|PC, 59|PC,
  59|PC, 74|PC,   112,   112,   112,   113,    76,    76,    76,   114,
    101,   101,   101,   102,     2,     2,   100,     2,   103,     2,
     86,   104, 71|PC,     2},
{   121,   121,   122,   122,   123,   123,   124,   124, 83|PC, 83|PC,
  86|PC, 92|PC, 86|PC, 89|PC, 95|PC,101|PC, 95|PC, 98|PC,104|PC,109|PC,
 104|PC,106|PC,112|PC,118|PC,112|PC,115|PC,121|PC,109|PC,121|PC,124|PC,
    116,   116,   116,   117,     2,     2,   115,     2,     0,     2,
  77|PC,     2, 80|PC,    65},
{   156,   156,   157,   157,   158,   158,   159,   159,130|PC,130|PC,
 133|PC,139|PC,133|PC,136|PC,142|PC,145|PC,142|PC,136|PC,104|PC,151|PC,
 104|PC,148|PC,154|PC,160|PC,154|PC,157|PC,121|PC,151|PC,121|PC,163|PC,
    152,   152,   152,   153,     2,     2,     2,   151,     0,     2,
  77|PC,     2,127|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,   160,   160,
 169|PC,175|PC,169|PC,172|PC,142|PC,181|PC,142|PC,178|PC,104|PC,187|PC,
 104|PC,184|PC,112|PC,193|PC,112|PC,190|PC,196|PC,187|PC,196|PC,198|PC,
    152,   152,   152,   153,     2,     2,   180,     2,     0,     2,
  77|PC,     2,166|PC,     2},
{   198,   198,   199,   199,   200,   200,   201,   201,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     2,     2,     5,     6,     0,     8,
    197,    52,     2,     2},
{    66,    66,    67,    67,    68,    68,    69,    69,    70,    70,
     71,   204,    71,    72,   205,   207,   205,   206,204|PC,204|PC,
 204|PC,207|PC,    76,    76,    76,    81,213|PC,213|PC,213|PC,210|PC,
     59,    59,    59,    60,     2,     2,   202,     2,     0,     2,
     62,   203,201|PC,    65},
{    89,    89,    90,    90,    91,    91,    92,    92,   106,   106,
     94,    94,    94,    95,    94,    94,    94,    95,216|PC,216|PC,
 216|PC,219|PC,    76,    76,    76,    99,225|PC,225|PC,225|PC,222|PC,
     83,    83,    83,    84,     2,     2,     2,   215,     0,     2,
     86,   216,   216,     2},
{    89,    89,    90,    90,   226,   226,    92,    92,   106,   106,
    227,   227,   227,   228,   109,   109,   109,    95,   229,   229,
    229,   230,   231,   231,   231,   232,    76,    76,    76,    99,
     83,    83,    83,    84,     2,     2,     2,   223,   224,     2,
     86,   225,228|PC,     2},
{    89,    89,    90,    90,    91,    91,    92,    92,   106,   106,
    235,   235,   235,   236,   109,   109,   109,   110,234|PC,234|PC,
 234|PC,237|PC,    76,    76,    76,   114,243|PC,243|PC,243|PC,240|PC,
     83,    83,    83,    84,     2,     2,   233,     2,     0,     2,
     86,   234,231|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,   160,   160,
 249|PC,139|PC,249|PC,252|PC,142|PC,255|PC,142|PC,136|PC,258|PC,264|PC,
 258|PC,260|PC,154|PC,266|PC,154|PC,157|PC,269|PC,272|PC,269|PC,163|PC,
    152,   152,   152,   153,     2,     2,     2,246|PC,     0,     2,
  77|PC,     2,127|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,130|PC,130|PC,
 169|PC,275|PC,169|PC,172|PC,278|PC,284|PC,278|PC,281|PC,104|PC,287|PC,
 104|PC,184|PC,290|PC,296|PC,290|PC,293|PC,121|PC,296|PC,121|PC,198|PC,
    152,   152,   152,   153,     2,     2,   257,     2,     0,     2,
  77|PC,     2,166|PC,     2},
{   156,   156,   157,   157,   158,   158,   159,   159,   160,   160,
 169|PC,175|PC,169|PC,172|PC,299|PC,181|PC,299|PC,302|PC,104|PC,305|PC,
 104|PC,184|PC,290|PC,308|PC,290|PC,190|PC,121|PC,311|PC,121|PC,198|PC,
    152,   152,   152,   153,     2,     2,   267,     2,     0,     2,
  77|PC,     2,166|PC,     2},
{    89,    89,    90,    90,   226,   226,    92,    92,   106,   106,
    277,   277,   277,   278,   109,   109,   109,    95,   279,   279,
    279,   280,   281,   281,   281,   282,320|PC,320|PC,320|PC,317|PC,
     83,    83,    83,    84,     2,     2,     2,   275,     0,     2,
     86,   276,314|PC,     2},
{   289,   289,   290,   290,   291,   291,    56,    56,     0,     0,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
      3,     3,     3,     3,     2,     2,     5,     6,     0,    50,
     51,323|PC,     2,     2}};
USHORT aLanLlcCondJump[326] = {
    0,    1,    7,    8,    1,    9,   10,    2,   12,    3,   14,    4,
   16,   17,    5,   18,   19,    6,   20,   21,   22,   23,    7,   26,
   27,    8,   28,   29,    3,    9,   30,   31,    9,   32,   33,    9,
   30,   34,    9,   35,   36,    9,   37,   38,    9,   39,   40,    9,
   41,   42,    9,   43,   44,   10,   45,   46,   11,   64,   63,   12,
   75,   76,   12,   77,   78,   11,   88,   87,   12,   96,   78,   13,
  104,  105,   12,  111,   78,   14,    2,  118,   10,  119,  120,   15,
  125,    3,   16,  126,  127,   16,  128,  129,   17,  130,  131,   16,
  132,  133,   16,  134,  135,   17,  136,  137,   18,  138,   16,  139,
  140,   17,  141,  142,   16,  143,  144,   16,  145,  146,   17,  147,
  142,   16,  148,   12,   16,  149,  150,   10,  154,  155,   15,  160,
    3,   16,  161,  162,   16,  163,  164,   17,  165,  166,   16,  167,
  168,   17,  169,  166,   16,  170,  171,   17,  172,  173,   16,  174,
  175,   16,  176,  177,   17,  178,  173,   16,  179,  171,   10,  181,
  155,   16,  182,  183,   16,  184,  185,   17,  130,  186,   16,  187,
  188,   17,  189,  186,   16,  190,  191,   17,  192,  142,   16,  193,
  194,   17,  195,  142,   18,  148,   16,  196,  191,   11,   88,  203,
   12,  208,  209,   12,  210,  211,   12,  212,  213,   12,  214,  209,
   12,  217,   76,   12,  218,   78,   12,  219,  220,   12,  221,  222,
   11,   88,  225,   11,   88,  234,   12,  237,   76,   12,  238,   78,
   12,  239,  240,   12,  241,  242,   19,  243,  244,   16,  245,  246,
   16,  247,  248,   17,  249,  166,   18,  250,   20,  251,  171,  252,
   21,  173,   17,  253,  254,   16,  255,   12,   17,  256,  173,   17,
  130,  166,   16,  258,  259,   16,  260,  261,   17,  262,  166,   17,
  263,  142,   16,  143,  264,   16,  193,  265,   17,  266,  142,   16,
  268,  269,   16,  270,  271,   17,  272,  142,   17,  273,  142,   17,
  274,  142,   11,  105,  276,   12,  283,  284,   12,  285,  286,   10,
  287,  288};
#endif


#define     usState     pLink->State


UINT
RunStateMachine(
    IN OUT PDATA_LINK pLink,
    IN USHORT usInput,
    IN BOOLEAN boolPollFinal,
    IN BOOLEAN boolResponse
    )

/*++

Routine Description:

    The function impelements the complete HDLC ABM link station as
    it has been defined in IBM Token-Ring Architecture Reference.
    The excluding of XID and TEST handling in the link station level
    should be the the only difference. The code is compiled from
    the state machine definition file with the finite state machine
    compiler.

Special:

    This procededure must be called with SendSpinLock set

Arguments:

    pLink           - link station context
    usInput         - state machine input
    boolPollFinal   - boolean flag set when the received frame had poll/final
                      bit set
    boolResponse    - boolean flag set when the received frame was response

Return Value:

    STATUS_SUCCESS  - the state machine acknowledged the next operation,
        eg. the received data or the packet was queued

    DLC_STATUS_NO_ACTION - the command was accepted and executed.
        No further action is required from caller.

    DLC_LOGICAL_ERROR - the input is invalid within this state.
        This error is returned to the upper levels.

    DLC_IGNORE_FRAME - the received frame was ignored

    DLC_DISCARD_INFO_FIELD - the received data was discarded

--*/

{
    UINT usAction;
    UINT usActionIndex;
    UCHAR uchSendId = 0;
    UINT Status = DLC_STATUS_SUCCESS;


#if LLC_DBG

    //
    // We save all last state machine inputs to a global trace table
    //

    aLast[InputIndex % LLC_INPUT_TABLE_SIZE].Input = usInput;
    aLast[InputIndex % LLC_INPUT_TABLE_SIZE].Time = (USHORT)AbsoluteTime;
    aLast[InputIndex % LLC_INPUT_TABLE_SIZE].pLink = pLink;
    InputIndex++;
#endif

    //
    // FSM condition switch
    //

#ifdef    FSM_PREDICATE_CASES
    usAction = aLanLlcStateInput[usState][usInput];
    if (usAction & 0x8000) {
        usActionIndex = usAction & 0x7fff;
        usAction = aLanLlcCondJump[usActionIndex++];
        switch (usAction) {
        case 1:
            if (pLink->Vi==0)
                ;
            else if (pLink->Vi==REMOTE_INIT_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 2:
            if (pLink->P_Ct==0)
                ;
            else
                usActionIndex = 0;
            break;
        case 3:
            if (pLink->Vi==0)
                ;
            else
                usActionIndex = 0;
            break;
        case 4:
            if (pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==REMOTE_INIT_PENDING)
                ;
            else if (pLink->Vi==OPER_MODE_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 5:
            if ((pLink->Vb&STATE_LOCAL_BUSY)!=0)
                ;
            else if ((pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 6:
            if (pLink->P_Ct!=0&&pLink->Vi==LOCAL_INIT_PENDING)
                ;
            else if (pLink->P_Ct==0&&pLink->Vi==LOCAL_INIT_PENDING)
                usActionIndex += 1;
            else if (pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING)&&(pLink->Vb&STATE_LOCAL_BUSY)!=0)
                usActionIndex += 2;
            else if (pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING)&&(pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 3;
            else
                usActionIndex = 0;
            break;
        case 7:
            if (pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING))
                ;
            else if (pLink->Vi==OPER_MODE_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 8:
            if ((pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING))&&(pLink->Vb&STATE_LOCAL_BUSY)!=0)
                ;
            else if ((pLink->Vi==LOCAL_INIT_PENDING||pLink->Vi==(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING))&&(pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 1;
            else if ((pLink->Vi==OPER_MODE_PENDING))
                usActionIndex += 2;
            else
                usActionIndex = 0;
            break;
        case 9:
            if (pLink->Vi==OPER_MODE_PENDING&&pLink->Nr==0&&(pLink->Vb&STATE_LOCAL_BUSY)!=0)
                ;
            else if (pLink->Vi==OPER_MODE_PENDING&&pLink->Nr==0&&(pLink->Vb&STATE_LOCAL_BUSY)==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 10:
            if (pLink->P_Ct!=0)
                ;
            else if (pLink->P_Ct==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 11:
            if (pLink->Is_Ct<=0)
                ;
            else if (pLink->Is_Ct>0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 12:
            if (pLink->Nr!=pLink->Vs)
                ;
            else if (pLink->Nr==pLink->Vs)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 13:
            if (pLink->Is_Ct>0)
                ;
            else if (pLink->P_Ct<=0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 14:
            if (pLink->Vc!=0)
                ;
            else if (pLink->Vc==0)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 15:
            if (pLink->Vi!=IS_FRAME_PENDING)
                ;
            else if (pLink->Vi==IS_FRAME_PENDING)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 16:
            if (pLink->Va!=pLink->Nr)
                ;
            else if (pLink->Va==pLink->Nr)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 17:
            if (pLink->Vc==0)
                ;
            else if (pLink->Vc==STACKED_DISCp_CMD)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 18:
            if (pLink->Va!=pLink->Nr)
                ;
            else
                usActionIndex = 0;
            break;
        case 19:
            if (pLink->Vb==(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY))
                ;
            else if (pLink->Vb==STATE_LOCAL_BUSY)
                usActionIndex += 1;
            else
                usActionIndex = 0;
            break;
        case 20:
            if (pLink->Va!=pLink->Nr)
                ;
            else if (pLink->Va==pLink->Nr)
                usActionIndex += 1;
            else if (pLink->Vc==0)
                usActionIndex += 2;
            else
                usActionIndex = 0;
            break;
        case 21:
            if (pLink->Vc==STACKED_DISCp_CMD)
                ;
            else
                usActionIndex = 0;
            break;
        };
        usAction = aLanLlcCondJump[usActionIndex];
    }
#endif


#ifdef    FSM_ACTION_CASES
    switch (usAction) {
    case 0:
            Status=DLC_STATUS_NO_ACTION;
            break;
    case 1:
            EnableLinkStation(pLink);
            pLink->Vi=pLink->Vb=pLink->Vc=0;
        label_1_1:
            pLink->State=1;
    case 11:
        label_11_1:
            TimerStart(&pLink->Ti);
            break;
    case 2:
            Status=DLC_STATUS_LINK_PROTOCOL_ERROR;
            break;
    case 3:
            Status=DLC_STATUS_IGNORE_FRAME;
            break;
    case 4:
            DisableLinkStation(pLink);
            pLink->State=0;
            break;
    case 5:
        label_5_1:
            pLink->Vb=STATE_LOCAL_BUSY;
            break;
    case 6:
        label_6_1:
            pLink->Vb=0;
            break;
    case 7:
            TimerStartIf(&pLink->T1);
            pLink->Vi=LOCAL_INIT_PENDING;
            DLC_SABME(1);
            pLink->State=2;
            TimerStop(&pLink->Ti);
        label_7_1:
            pLink->P_Ct=pLink->N2;
        label_7_2:
            pLink->Is_Ct=pLink->N2;
            break;
    case 8:
            pLink->Vi=OPER_MODE_PENDING;
            DLC_UA(pLink->Pf);
            pLink->State=2;
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Ir_Ct=pLink->N3;
            TimerStart(&pLink->Ti);
            goto label_7_2;
    case 9:
            DLC_DM(0);
        label_9_1:
            EVENT_INDICATION(CONFIRM_DISCONNECT);
        label_9_2:
            TimerStart(&pLink->Ti);
            break;
    case 10:
            DLC_DM(pLink->Pf);
            pLink->Vi=0;
            goto label_9_1;
    case 12:
        label_12_1:
            ;
            break;
    case 13:
        label_13_1:
            DLC_DM(boolPollFinal);
            break;
    case 14:
            EVENT_INDICATION(INDICATE_CONNECT_REQUEST);
        label_14_1:
            pLink->Pf=boolPollFinal;
            pLink->Vi=REMOTE_INIT_PENDING;
            goto label_9_2;
    case 15:
            DLC_DM(1);
            break;
    case 16:
            DLC_DM(0);
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(CONFIRM_DISCONNECT);
            TimerStop(&pLink->T1);
        label_16_1:
            pLink->Vi=0;
            goto label_1_1;
    case 17:
            TimerStop(&pLink->Ti);
            pLink->Vi=0;
            pLink->State=3;
            DLC_DISC(1);
        label_17_1:
            pLink->P_Ct=pLink->N2;
        label_17_2:
            TimerStart(&pLink->T1);
            break;
    case 18:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
        label_18_1:
            pLink->Vi=IS_FRAME_PENDING;
            DLC_RNR_COMMAND(1);
            pLink->State=9;
        label_18_2:
            EVENT_INDICATION(CONFIRM_CONNECT);
            goto label_17_1;
    case 19:
            pLink->Vi=IS_FRAME_PENDING;
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
        label_19_1:
            pLink->State=8;
            DLC_RR_COMMAND(1);
            goto label_18_2;
    case 20:
            DLC_SABME(1);
        label_20_1:
            pLink->P_Ct--;
            goto label_17_2;
    case 21:
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(INDICATE_LINK_LOST);
            goto label_16_1;
    case 22:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Vc=0;
            pLink->Ir_Ct=pLink->N3;
            pLink->Is_Ct=pLink->N2;
            goto label_18_1;
    case 23:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0,pLink->Vi=IS_FRAME_PENDING,pLink->Vc=0;
            pLink->Ir_Ct=pLink->N3;
            pLink->Is_Ct=pLink->N2;
            goto label_19_1;
    case 24:
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            pLink->Vi=0;
            TimerStart(&pLink->Ti);
        label_24_1:
            TimerStop(&pLink->T1);
            goto label_13_1;
    case 25:
            EVENT_INDICATION(CONFIRM_CONNECT_FAILED);
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            TimerStop(&pLink->T1);
        label_25_1:
            pLink->Vi=0;
            goto label_9_2;
    case 26:
            pLink->Vi=(REMOTE_INIT_PENDING|LOCAL_INIT_PENDING);
    case 47:
        label_47_1:
            DLC_UA(boolPollFinal);
            break;
    case 27:
        label_27_1:
            TimerStart(&pLink->Ti);
            goto label_47_1;
    case 28:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Vi=IS_FRAME_PENDING;
            DLC_RNR_COMMAND(1);
            pLink->State=9;
        label_28_1:
            TimerStart(&pLink->T1);
            EVENT_INDICATION(CONFIRM_CONNECT);
            pLink->Vc=0;
            pLink->Ir_Ct=pLink->N3;
            goto label_7_1;
    case 29:
            pLink->Va=pLink->Vs=pLink->Vr=pLink->Vp=0;
            pLink->Vi=IS_FRAME_PENDING;
            pLink->State=8;
            DLC_RR_COMMAND(1);
            goto label_28_1;
    case 30:
            DLC_RNR_RESPONSE(0);
        label_30_1:
            pLink->State=6;
        label_30_2:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
        label_30_3:
            EnableSendProcess(pLink);
        label_30_4:
            EVENT_INDICATION(CONFIRM_CONNECT);
            goto label_25_1;
    case 31:
            SEND_ACK(pLink);
        label_31_1:
            Status=STATUS_SUCCESS;pLink->Vr+=2;
    case 42:
        label_42_1:
            pLink->State=5;
            goto label_30_3;
    case 32:
            DLC_RNR_RESPONSE(1);
            goto label_30_1;
    case 33:
            DLC_RR_RESPONSE(1);
            goto label_31_1;
    case 34:
            DLC_REJ_RESPONSE(0);
        label_34_1:
            pLink->State=7;
            goto label_30_2;
    case 35:
            pLink->State=6;
            EVENT_INDICATION(CONFIRM_CONNECT);
            pLink->Vi=0;
            EnableSendProcess(pLink);
            TimerStart(&pLink->Ti);
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_12_1;
    case 36:
            DLC_REJ_RESPONSE(1);
            goto label_34_1;
    case 37:
        label_37_1:
            pLink->State=13;
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_37_2:
            pLink->Is_Ct=pLink->N2;
            goto label_30_4;
    case 38:
        label_38_1:
            pLink->State=12;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_37_2;
    case 39:
            DLC_RNR_RESPONSE(1);
            goto label_37_1;
    case 40:
            DLC_RR_RESPONSE(1);
            goto label_38_1;
    case 41:
        label_41_1:
            pLink->State=6;
            goto label_30_3;
    case 43:
            DLC_RNR_RESPONSE(1);
            goto label_41_1;
    case 44:
            DLC_RR_RESPONSE(1);
            goto label_42_1;
    case 45:
            DLC_DISC(1);
            goto label_20_1;
    case 46:
        label_46_1:
            EVENT_INDICATION(CONFIRM_DISCONNECT);
            goto label_1_1;
    case 48:
            TimerStop(&pLink->T1);
            goto label_46_1;
    case 49:
            EVENT_INDICATION(CONFIRM_DISCONNECT);
            pLink->State=1;
            TimerStart(&pLink->Ti);
            goto label_24_1;
    case 50:
            pLink->Vi=LOCAL_INIT_PENDING;
            DLC_SABME(1);
            pLink->State=2;
        label_50_1:
            TimerStop(&pLink->Ti);
            goto label_17_1;
    case 51:
            pLink->State=3;
            DLC_DISC(1);
            goto label_50_1;
    case 52:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_11_1;
    case 53:
        label_53_1:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
        label_53_2:
            pLink->State=1;
            goto label_27_1;
    case 54:
        label_54_1:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
        label_54_2:
            pLink->State=1;
            goto label_9_2;
    case 55:
            pLink->P_Ct=pLink->N2;
        label_55_1:
            pLink->State=20;
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            goto label_9_2;
    case 56:
        label_56_1:
            pLink->State=11;
            EVENT_INDICATION(INDICATE_RESET);
            goto label_14_1;
    case 57:
            DLC_FRMR(boolPollFinal);
        label_57_1:
            EVENT_INDICATION(INDICATE_FRMR_SENT);
            goto label_9_2;
    case 58:
            pLink->State=6;
            DLC_RNR_RESPONSE(0);
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
            goto label_5_1;
    case 59:
            DLC_FRMR(0);
        label_59_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
        label_59_2:
            TimerStop(&pLink->T2);
        label_59_3:
            pLink->State=4;
            TimerStop(&pLink->T1);
            goto label_57_1;
    case 60:
            DLC_FRMR(1);
            goto label_59_1;
    case 61:
            TimerStart(&pLink->T1);
            pLink->Is_Ct--;
            pLink->Ir_Ct=pLink->N3;
        label_61_1:
            pLink->State=8;
        label_61_2:
            pLink->Vp=pLink->Vs;
        label_61_3:
            pLink->P_Ct=pLink->N2;
            break;
    case 62:
        label_62_3:
            TimerStop(&pLink->Ti);
            TimerStart(&pLink->T1);
        label_62_1:
            pLink->State=3;
            DLC_DISC(1);
        label_62_2:
            TimerStop(&pLink->T2);
            goto label_61_3;
    case 63:
            pLink->State=8;
            DisableSendProcess(pLink);
            DLC_RR_COMMAND(1);
            pLink->Vp=pLink->Vs;
            TimerStart(&pLink->T1);
            pLink->Ir_Ct=pLink->N3;
            goto label_62_2;
    case 64:
            EVENT_INDICATION(INDICATE_LINK_LOST);
            TimerStart(&pLink->T1);
            goto label_62_1;
    case 65:
            DLC_RR_RESPONSE(0);
        label_65_1:
            pLink->Ir_Ct=pLink->N3;
            break;
    case 66:
            TimerStop(&pLink->T2);
    case 89:
//		 label_89_1:
            TimerStop(&pLink->T1);
            goto label_53_1;
    case 67:
            TimerStop(&pLink->T2);
    case 90:
//		 label_90_1:
            TimerStop(&pLink->T1);
            goto label_54_1;
    case 68:
            pLink->State=20;
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            TimerStop(&pLink->T1);
            TimerStart(&pLink->Ti);
            goto label_62_2;
    case 69:
            TimerStop(&pLink->T2);
    case 92:
//		 label_92_1:
            TimerStop(&pLink->T1);
            goto label_56_1;
    case 70:
            DLC_FRMR(0);
            goto label_59_2;
    case 71:
        label_71_1:
            SEND_ACK(pLink);
        label_71_2:
            Status=STATUS_SUCCESS;pLink->Vr+=2;
    case 76:
        label_76_1:
            UpdateVa(pLink);
            break;
    case 72:
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
        label_72_1:
            DLC_RR_RESPONSE(1);
            goto label_71_2;
    case 73:
            DLC_REJ_RESPONSE(0);
        label_73_1:
            pLink->State=7;
            pLink->Ir_Ct=pLink->N3;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
        label_73_2:
            TimerStop(&pLink->T2);
            goto label_76_1;
    case 74:
            DLC_REJ_RESPONSE(1);
            goto label_73_1;
    case 75:
        label_75_1:
            ResendPackets(pLink),UpdateVa(pLink);
        label_75_2:
            pLink->Is_Ct--;
            break;
    case 77:
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
    case 111:
//		 label_111_1:
            DLC_RR_RESPONSE(1);
            goto label_75_1;
    case 78:
        label_78_1:
            DLC_RR_RESPONSE(1);
            goto label_73_2;
    case 79:
            pLink->Vb=STATE_REMOTE_BUSY,pLink->Is_Ct=pLink->N2;
        label_79_1:
            pLink->State=12;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
        label_79_2:
            DisableSendProcess(pLink);
            goto label_76_1;
    case 80:
            pLink->Vb=STATE_REMOTE_BUSY;
            pLink->Ir_Ct=pLink->N3;
            DLC_RR_RESPONSE(1);
            pLink->Is_Ct=pLink->N2;
            TimerStop(&pLink->T2);
            goto label_79_1;
    case 81:
            pLink->Ir_Ct=pLink->N3;
            goto label_78_1;
    case 82:
            TimerStop(&pLink->Ti);
            TimerStart(&pLink->T1);
            DisableSendProcess(pLink);
            pLink->Vb=0;
        label_82_1:
            DLC_RR_COMMAND(1);
            goto label_61_1;
    case 83:
            DLC_FRMR(0);
        label_83_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
            goto label_59_3;
    case 84:
            DLC_FRMR(1);
            goto label_83_1;
    case 85:
            pLink->State=9;
            pLink->Ir_Ct=pLink->N3;
        label_85_1:
            TimerStart(&pLink->T1);
            pLink->Vp=pLink->Vs;
            pLink->P_Ct=pLink->N2;
            goto label_75_2;
    case 86:
            TimerStart(&pLink->T1);
        label_86_1:
            TimerStop(&pLink->Ti);
        label_86_2:
            pLink->State=3;
            DLC_DISC(1);
            goto label_61_3;
    case 87:
            pLink->State=9;
        label_87_1:
            DLC_RNR_COMMAND(1);
        label_87_2:
            DisableSendProcess(pLink);
        label_87_3:
            TimerStart(&pLink->T1);
            goto label_61_2;
    case 88:
            TimerStop(&pLink->T2);
    case 105:
        label_105_1:
            TimerStart(&pLink->T1);
            goto label_86_2;
    case 91:
        label_91_1:
            TimerStart(&pLink->Ti);
        label_91_2:
            TimerStop(&pLink->T1);
        label_91_3:
            pLink->State=20;
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            goto label_61_3;
    case 93:
            pLink->DlcStatus.FrmrData.Reason=0x08;
    case 106:
        label_106_1:
            DLC_FRMR(0);
            goto label_59_3;
    case 94:
            DLC_RNR_RESPONSE(0);
    case 109:
        label_109_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_76_1;
    case 95:
            DLC_RNR_RESPONSE(1);
            goto label_109_1;
    case 96:
            DLC_RNR_RESPONSE(1);
            goto label_75_1;
    case 97:
        label_97_1:
            pLink->State=13;
        label_97_2:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_97_3:
            pLink->Is_Ct=pLink->N2;
            goto label_79_2;
    case 98:
            DLC_RNR_RESPONSE(1);
            goto label_97_1;
    case 99:
            DLC_RNR_RESPONSE(1);
            goto label_76_1;
    case 100:
            pLink->State=14;
            DLC_RNR_RESPONSE(0);
            goto label_5_1;
    case 101:
            pLink->DlcStatus.FrmrData.Reason=00001;
            goto label_106_1;
    case 102:
            pLink->DlcStatus.FrmrData.Reason=00001;
            DLC_FRMR(1);
            goto label_59_3;
    case 103:
            pLink->State=10;
            goto label_85_1;
    case 104:
        label_104_1:
            pLink->State=10;
            DLC_RR_COMMAND(1);
            goto label_87_2;
    case 107:
            pLink->State=5;
            goto label_71_1;
    case 108:
            pLink->State=5;
            goto label_72_1;
    case 110:
            DLC_RR_RESPONSE(1);
            goto label_109_1;
    case 112:
        label_112_1:
            pLink->State=15;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_97_3;
    case 113:
            DLC_RR_RESPONSE(1);
            goto label_112_1;
    case 114:
            DLC_RR_RESPONSE(1);
            goto label_76_1;
    case 115:
            pLink->State=9;
            pLink->Vb=STATE_LOCAL_BUSY;
        label_115_1:
            DLC_RNR_RESPONSE(0);
        label_115_2:
            TimerStop(&pLink->T2);
            goto label_65_1;
    case 116:
            DLC_FRMR(0);
        label_116_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
        label_116_2:
            pLink->State=4;
            EVENT_INDICATION(INDICATE_FRMR_SENT);
        label_116_3:
            TimerStop(&pLink->T1);
        label_116_4:
            TimerStop(&pLink->T2);
            goto label_11_1;
    case 117:
            DLC_FRMR(1);
            goto label_116_1;
    case 118:
            pLink->Vc=STACKED_DISCp_CMD;
            break;
    case 119:
            pLink->P_Ct--;
            DisableSendProcess(pLink);
        label_119_1:
            DLC_RR_COMMAND(1);
            pLink->Vp=pLink->Vs;
            TimerStart(&pLink->T1);
            goto label_115_2;
    case 120:
            if( pLink->Vc == STACKED_DISCp_CMD ) {
                goto label_62_3;
            } else {
                EVENT_INDICATION(INDICATE_LINK_LOST);
            }
        label_120_1:
            pLink->State=1;
            goto label_116_4;
    case 121:
            TimerStop(&pLink->T2);
    case 156:
//		 label_156_1:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            TimerStart(&pLink->Ti);
            TimerStop(&pLink->T1);
            goto label_47_1;
    case 122:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            TimerStop(&pLink->T1);
            goto label_120_1;
    case 123:
            pLink->Vc=0;
            TimerStop(&pLink->T2);
            goto label_91_1;
    case 124:
            pLink->State=11;
            EVENT_INDICATION(INDICATE_RESET);
            pLink->Vi=REMOTE_INIT_PENDING;
            pLink->Pf=boolPollFinal;
            goto label_116_3;
    case 125:
            DLC_FRMR(0);
            pLink->Vc=0;
            goto label_116_2;
    case 126:
            SEND_ACK(pLink);
            Status=STATUS_SUCCESS;pLink->Vr+=2;
    case 148:
        label_148_1:
            AdjustWw(pLink);
            goto label_7_2;
    case 127:
        label_127_1:
            SEND_ACK(pLink);
        label_127_2:
            Status=STATUS_SUCCESS;pLink->Vr+=2;
            break;
    case 128:
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
    case 129:
//		 label_129_1:
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
        label_128_2:
            DLC_RR_RESPONSE(1);
            goto label_127_2;
    case 130:
            pLink->State=5;
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_127_1;
    case 131:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            pLink->Vc=0;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            TimerStop(&pLink->T2);
            goto label_86_1;
    case 132:
            DLC_REJ_RESPONSE(0);
            pLink->State=10;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
        label_132_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_115_2;
    case 133:
            DLC_REJ_RESPONSE(0);
        label_133_1:
            pLink->State=10;
            goto label_132_1;
    case 134:
            DLC_REJ_RESPONSE(1);
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_133_1;
    case 135:
            DLC_REJ_RESPONSE(1);
            goto label_133_1;
    case 136:
            DLC_REJ_RESPONSE(0);
            pLink->State=7;
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_132_1;
    case 137:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            pLink->Vc=0;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            TimerStop(&pLink->T2);
            goto label_86_2;
    case 138:
        label_138_1:
            ResendPackets(pLink);
            goto label_7_2;
    case 139:
            ResendPackets(pLink);
            DLC_RR_RESPONSE(1);
            pLink->Is_Ct=pLink->N2;
            goto label_115_2;
    case 140:
        label_140_1:
            TimerStop(&pLink->T2);
    case 191:
        label_191_1:
            DLC_RR_RESPONSE(1);
            break;
    case 141:
            pLink->State=5;
        label_141_1:
            UpdateVaChkpt(pLink);
        label_141_2:
            EnableSendProcess(pLink);
            break;
    case 142:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
        label_142_1:
            pLink->Vc=0;
            goto label_86_2;
    case 143:
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_148_1;
    case 144:
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_7_2;
    case 145:
            AdjustWw(pLink);
    case 146:
//		 label_146_1:
            pLink->Vb=STATE_REMOTE_BUSY;
        label_145_2:
            pLink->Is_Ct=pLink->N2;
    case 150:
        label_150_1:
            pLink->Ir_Ct=pLink->N3;
            goto label_140_1;
    case 147:
            pLink->State=12;
        label_147_1:
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            UpdateVaChkpt(pLink);
            goto label_7_2;
    case 149:
            AdjustWw(pLink);
            goto label_145_2;
    case 151:
            pLink->State=17;
        label_151_1:
            DLC_RR_RESPONSE(0);
            goto label_6_1;
    case 152:
            DLC_FRMR(0);
        label_152_1:
            pLink->DlcStatus.FrmrData.Reason=0x01;
        label_152_2:
            pLink->State=4;
            EVENT_INDICATION(INDICATE_FRMR_SENT);
        label_152_3:
            TimerStop(&pLink->T1);
            goto label_11_1;
    case 153:
            DLC_FRMR(1);
            goto label_152_1;
    case 154:
            DLC_RNR_COMMAND(1);
        label_154_1:
            DisableSendProcess(pLink);
            pLink->Vp=pLink->Vs;
            goto label_20_1;
    case 155:
            EVENT_INDICATION(INDICATE_LINK_LOST);
            goto label_1_1;
    case 157:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            pLink->State=1;
            goto label_152_3;
    case 158:
            TimerStart(&pLink->Ti);
            goto label_91_2;
    case 159:
            pLink->State=11;
            EVENT_INDICATION(INDICATE_RESET);
            pLink->Vi=REMOTE_INIT_PENDING;
            pLink->Pf=boolPollFinal;
            goto label_152_3;
    case 160:
            DLC_FRMR(0);
            goto label_152_2;
    case 161:
            DLC_RNR_RESPONSE(0);
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_148_1;
    case 162:
        label_162_1:
            DLC_RNR_RESPONSE(0);
    case 168:
        label_168_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            break;
    case 163:
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
    case 164:
//		 label_164_1:
            DLC_RNR_RESPONSE(1);
            goto label_168_1;
    case 165:
            pLink->State=6;
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_162_1;
    case 166:
            UpdateVaChkpt(pLink),TimerStop(&pLink->Ti),TimerStart(&pLink->T1);
        label_166_1:
            pLink->Vc=0;
            pLink->State=3;
            DLC_DISC(1);
            pLink->P_Ct=pLink->N2;
            goto label_168_1;
    case 167:
        label_167_1:
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_168_1;
    case 169:
            pLink->State=6;
        label_169_1:
            UpdateVaChkpt(pLink);
            EnableSendProcess(pLink);
            goto label_168_1;
    case 170:
            DLC_RNR_RESPONSE(1);
            goto label_138_1;
    case 171:
        label_171_1:
            DLC_RNR_RESPONSE(1);
            break;
    case 172:
            pLink->State=6;
            goto label_141_1;
    case 173:
            UpdateVaChkpt(pLink),TimerStop(&pLink->Ti),TimerStart(&pLink->T1);
            goto label_142_1;
    case 174:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
            goto label_148_1;
    case 175:
        label_175_1:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
            goto label_7_2;
    case 176:
            AdjustWw(pLink);
    case 177:
        label_177_1:
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_176_2:
            pLink->Is_Ct=pLink->N2;
            goto label_171_1;
    case 178:
            pLink->State=13;
        label_178_1:
            UpdateVaChkpt(pLink);
            goto label_175_1;
    case 179:
            AdjustWw(pLink);
            goto label_176_2;
    case 180:
            pLink->State=16;
            goto label_5_1;
    case 181:
            DLC_RR_COMMAND(1);
            goto label_154_1;
    case 182:
            pLink->State=8;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_127_1;
    case 183:
            pLink->State=8;
            goto label_127_1;
    case 184:
            pLink->State=8;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_128_2;
    case 185:
            pLink->State=8;
            goto label_128_2;
    case 186:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            goto label_166_1;
    case 187:
            DLC_RR_RESPONSE(1);
            goto label_167_1;
    case 188:
            DLC_RR_RESPONSE(1);
            goto label_168_1;
    case 189:
        label_189_1:
            pLink->State=7;
            goto label_169_1;
    case 190:
            DLC_RR_RESPONSE(1);
            goto label_138_1;
    case 192:
            pLink->State=7;
            goto label_141_1;
    case 193:
            AdjustWw(pLink);
    case 194:
//		 label_194_1:
            pLink->Vb=STATE_REMOTE_BUSY;
        label_193_2:
            pLink->Is_Ct=pLink->N2;
            goto label_191_1;
    case 195:
            pLink->State=15;
            goto label_147_1;
    case 196:
            AdjustWw(pLink);
            goto label_193_2;
    case 197:
            DLC_DM(pLink->Pf);
            EVENT_INDICATION(CONFIRM_DISCONNECT);
        label_197_1:
            pLink->Vi=0;
            goto label_54_2;
    case 198:
            pLink->Vi=0;
            goto label_53_1;
    case 199:
            EVENT_INDICATION(INDICATE_DM_DISC_RECEIVED);
            goto label_197_1;
    case 200:
            pLink->Vi=0;
            TimerStart(&pLink->Ti);
            goto label_91_3;
    case 201:
            EVENT_INDICATION(INDICATE_RESET);
            goto label_9_2;
    case 202:
            pLink->State=13;
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
            goto label_115_1;
    case 203:
            pLink->State=8;
            pLink->P_Ct=pLink->N2;
            goto label_119_1;
    case 204:
            pLink->State=5;
            pLink->Vb=0;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
        label_204_1:
            UpdateVa(pLink);
            goto label_127_1;
    case 205:
            pLink->State=15;
            pLink->Ir_Ct=pLink->N3;
        label_205_1:
            DLC_REJ_RESPONSE(0);
            UpdateVa(pLink);
            TimerStop(&pLink->T2);
            goto label_168_1;
    case 206:
            pLink->State=15;
            pLink->Ir_Ct=pLink->N3;
            TimerStop(&pLink->T2);
        label_206_1:
            UpdateVa(pLink);
        label_206_2:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_171_1;
    case 207:
            pLink->State=7;
            pLink->Vb=0;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_205_1;
    case 208:
        label_208_1:
            ResendPackets(pLink),UpdateVa(pLink);
            pLink->Is_Ct--;
        label_208_2:
            pLink->State=5;
        label_208_3:
            pLink->Vb=0;
        label_208_4:
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_141_2;
    case 209:
        label_209_1:
            UpdateVa(pLink);
            goto label_208_2;
    case 210:
            pLink->Ir_Ct=pLink->N3;
            DLC_RR_RESPONSE(1);
            TimerStop(&pLink->T2);
            goto label_208_1;
    case 211:
        label_211_1:
            DLC_RR_RESPONSE(1);
            TimerStop(&pLink->T2);
            goto label_209_1;
    case 212:
            SEND_RR_CMD(1);
            TimerStart(&pLink->T1);
            pLink->State=8;
            pLink->Vb=0;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            UpdateVa(pLink);
            goto label_150_1;
    case 213:
            pLink->Ir_Ct=pLink->N3;
            goto label_211_1;
    case 214:
            pLink->State=8;
        label_214_1:
            TimerStart(&pLink->T1);
            pLink->Vb=0;
            DLC_RR_COMMAND(1);
        label_214_2:
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_76_1;
    case 215:
            TimerStop(&pLink->Ti);
            TimerStart(&pLink->T1);
            pLink->Vb=STATE_REMOTE_BUSY;
            goto label_82_1;
    case 216:
            pLink->State=9;
        label_216_1:
            DLC_RNR_COMMAND(1);
            goto label_87_3;
    case 217:
            ResendPackets(pLink),UpdateVa(pLink);
            pLink->Is_Ct--;
        label_217_1:
            pLink->State=6;
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_208_4;
    case 218:
            ResendPackets(pLink),UpdateVa(pLink);
            pLink->State=6;
            pLink->Is_Ct--;
            pLink->Vb=STATE_LOCAL_BUSY;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            EnableSendProcess(pLink);
            goto label_171_1;
    case 219:
            pLink->State=9;
        label_219_1:
            UpdateVa(pLink),SEND_RNR_CMD(1);
            TimerStart(&pLink->T1);
        label_219_2:
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_171_1;
    case 220:
            pLink->State=6;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            EnableSendProcess(pLink);
            UpdateVa(pLink);
            goto label_219_2;
    case 221:
            DLC_RNR_COMMAND(1);
            pLink->State=9;
            TimerStart(&pLink->T1);
        label_221_1:
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_214_2;
    case 222:
            UpdateVa(pLink);
            goto label_217_1;
    case 223:
            TimerStop(&pLink->Ti);
            pLink->Vb=0;
            goto label_104_1;
    case 224:
            pLink->State=16;
            goto label_85_1;
    case 225:
            pLink->State=16;
            goto label_87_1;
    case 226:
            TimerStop(&pLink->T1);
            goto label_55_1;
    case 227:
            pLink->State=6;
            UpdateVa(pLink);
            goto label_162_1;
    case 228:
            pLink->State=6;
            goto label_206_1;
    case 229:
        label_229_1:
            ResendPackets(pLink),UpdateVa(pLink);
            break;
    case 230:
            DLC_RNR_RESPONSE(1);
            goto label_229_1;
    case 231:
            pLink->State=19;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            goto label_97_2;
    case 232:
            pLink->State=19;
            EVENT_INDICATION(INDICATE_REMOTE_BUSY);
            DisableSendProcess(pLink);
            UpdateVa(pLink);
            goto label_177_1;
    case 233:
            pLink->State=19;
            pLink->Vb=(STATE_LOCAL_BUSY|STATE_REMOTE_BUSY);
        label_233_1:
            DLC_RNR_RESPONSE(0);
            break;
    case 234:
            DLC_RR_COMMAND(1);
            pLink->State=10;
            goto label_87_3;
    case 235:
            pLink->State=12;
            goto label_204_1;
    case 236:
            pLink->State=12;
            Status=STATUS_SUCCESS;pLink->Vr+=2;
            UpdateVa(pLink);
            goto label_191_1;
    case 237:
        label_237_1:
            pLink->State=7;
            pLink->Vb=0;
        label_237_2:
            pLink->Is_Ct--;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            EnableSendProcess(pLink);
            goto label_229_1;
    case 238:
            DLC_RR_RESPONSE(1);
            goto label_237_1;
    case 239:
            UpdateVa(pLink),SEND_RR_CMD(1);
            TimerStart(&pLink->T1);
            pLink->Vb=0;
            pLink->State=10;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_191_1;
    case 240:
            DLC_RR_RESPONSE(1);
    case 242:
//		 label_242_1:
            pLink->State=7;
            UpdateVa(pLink);
            goto label_208_3;
    case 241:
            pLink->State=10;
            goto label_214_1;
    case 243:
            pLink->State=18;
            DLC_RR_RESPONSE(0);
    case 264:
        label_264_1:
            pLink->Vb=STATE_REMOTE_BUSY;
            break;
    case 244:
            pLink->State=18;
            goto label_151_1;
    case 245:
            pLink->State=9;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
        label_245_1:
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            goto label_233_1;
    case 246:
            pLink->State=9;
            goto label_245_1;
    case 247:
            pLink->State=9;
            AdjustWw(pLink);
            pLink->Is_Ct=pLink->N2;
            goto label_206_2;
    case 248:
            pLink->State=9;
            goto label_206_2;
    case 249:
            pLink->State=14;
            goto label_169_1;
    case 250:
        label_250_1:
            ResendPackets(pLink);
            break;
    case 251:
            DLC_RNR_RESPONSE(1);
            goto label_250_1;
    case 252:
            pLink->Vs=pLink->Nr;
            pLink->State=14;
            goto label_141_1;
    case 253:
            pLink->State=19;
            goto label_178_1;
    case 254:
            UpdateVaChkpt(pLink),TimerStop(&pLink->Ti),TimerStart(&pLink->T1);
            pLink->Vc=0;
            pLink->State=3;
            DLC_DISC(1);
            pLink->P_Ct=pLink->N2;
            goto label_264_1;
    case 255:
        label_255_1:
            AdjustWw(pLink);
            break;
    case 256:
            pLink->State=14;
            UpdateVaChkpt(pLink);
            goto label_208_4;
    case 257:
            pLink->State=9;
        label_257_1:
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_233_1;
    case 258:
            DLC_REJ_RESPONSE(0);
    case 268:
        label_268_1:
            pLink->State=10;
            Status=DLC_STATUS_DISCARD_INFO_FIELD;
            pLink->Is_Ct=pLink->N2;
            goto label_255_1;
    case 259:
            DLC_REJ_RESPONSE(0);
    case 269:
        label_269_1:
            pLink->State=10;
            goto label_168_1;
    case 260:
            DLC_REJ_RESPONSE(1);
            goto label_268_1;
    case 261:
            DLC_REJ_RESPONSE(1);
            goto label_269_1;
    case 262:
            DLC_REJ_RESPONSE(0);
            goto label_189_1;
    case 263:
            pLink->Vp=pLink->Nr;
        label_263_1:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1);
            pLink->State=8;
        label_263_2:
            DLC_RR_COMMAND(1);
            break;
    case 265:
            DLC_RR_RESPONSE(1);
            goto label_264_1;
    case 266:
            pLink->Vp=pLink->Vs;
            goto label_263_1;
    case 267:
            pLink->State=16;
            goto label_257_1;
    case 270:
            DLC_RR_RESPONSE(1);
            goto label_268_1;
    case 271:
            DLC_RR_RESPONSE(1);
            goto label_269_1;
    case 272:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1),pLink->Vp=pLink->Nr;
            pLink->Is_Ct--;
        label_272_1:
            pLink->State=10;
            goto label_263_2;
    case 273:
            pLink->Is_Ct=pLink->N2;
    case 274:
//		 label_274_1:
            UpdateVaChkpt(pLink),TimerStart(&pLink->T1),pLink->Vp=pLink->Vs;
            goto label_272_1;
    case 275:
            TimerStop(&pLink->Ti);
            pLink->Vb=STATE_REMOTE_BUSY;
            pLink->Vp=pLink->Vs;
            TimerStart(&pLink->T1);
            pLink->P_Ct=pLink->N2;
            goto label_272_1;
    case 276:
            pLink->State=16;
            goto label_216_1;
    case 277:
            pLink->State=13;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            UpdateVa(pLink);
            goto label_245_1;
    case 278:
            pLink->State=13;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_206_1;
    case 279:
        label_279_1:
            pLink->State=14;
            pLink->Vb=STATE_LOCAL_BUSY;
            goto label_237_2;
    case 280:
            DLC_RNR_RESPONSE(1);
            goto label_279_1;
    case 281:
        label_281_1:
            pLink->State=14;
            goto label_76_1;
    case 282:
            pLink->State=19;
        label_282_1:
            UpdateVa(pLink);
            goto label_171_1;
    case 283:
            pLink->State=16;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_219_1;
    case 284:
            pLink->State=14;
            pLink->Vb=STATE_LOCAL_BUSY;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_282_1;
    case 285:
            pLink->State=16;
            DLC_RNR_COMMAND(1);
            goto label_221_1;
    case 286:
            pLink->Vb=STATE_LOCAL_BUSY;
            EVENT_INDICATION(INDICATE_REMOTE_READY);
            goto label_281_1;
    case 287:
            pLink->P_Ct--;
            goto label_11_1;
    case 288:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_105_1;
    case 289:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_53_2;
    case 290:
            EVENT_INDICATION(INDICATE_TI_TIMER_EXPIRED);
            goto label_54_2;
    case 291:
            EVENT_INDICATION(INDICATE_FRMR_RECEIVED);
            break;
    };
#endif

//#########################################################################

    //************************* CODE BEGINS ***************************
    //
    // Check first, if we have any events; FRMR data must be setup
    // before we can send or queue the FRMR response/command
    // frame (the status is OK whenever uchSendId != 0)
    //

    if (uchSendId != 0) {
        Status = SendLlcFrame(pLink, uchSendId);
    }

    //
    // Dynamic timer value: DLC maintains a dynamic value for the response
    // timer based on the average response times of the last poll commands.
    // This code calculates new timer values, if the last response time
    // is very different from the old values.
    // (By the way, is the reading of the absolute timer tick MP safe?,
    // it must be, otherwise you cannot implement a MP system).
    // And: 32000 * 40 ms = ~20 minutes, much longer than any sensible T1.
    //
    // What should actually happen:
    //
    //     Average Poll response time:     Response delay added to T1 and Ti:
    //
    //     40 ms                           0
    //     80 ms                           16 * 40 = 640 ms
    //     120 ms                          16 * 40 = 640 ms
    //     160 ms                          32 * 40 = 1280 ms
    //     200 ms                          32 * 40 = 1280 ms
    //     240 ms                          48 * 40 = 1920 ms
    //     ...
    //
    //     We use big jumps to avoid to the timer reinitialization
    //     after every checkpointing state.  The algorithm should react
    //     immediately, if the reponse time is raising very fast, but
    //     the lowering of reponse time is based on sliding average
    //     of the most recent response times.
    //     We have used local hardcoded number 8 and mask 0xfff0 to make
    //     this algorithm more readable (but more difficult to maintain).
    //

    if ((pLink->Flags & DLC_WAITING_RESPONSE_TO_POLL)
    && !(SecondaryStates[pLink->State] & LLC_CHECKPOINTING)) {

        SHORT LastResponseTime;
        USHORT NewAve;

        LastResponseTime = (SHORT)((USHORT)AbsoluteTime - pLink->LastTimeWhenCmdPollWasSent);

        if (LastResponseTime < 0) {
            LastResponseTime += (SHORT)0x8000;
        }
        LastResponseTime *= 8;          // Magic multiplier

        //
        // We use simple sliding average to lower the reponse time,
        // where the newest reponse values has the highest weigth (12,5%).
        // But we must also be able to raise immediately the response time,
        // when the reponse time starts to grow.  Thus the actual
        // response value is maximum of sliding average and last reponse
        // time.  The 40 ms resonse time is to notified, because it is
        // a statistical thing.
        //

        NewAve = (USHORT)((pLink->AverageResponseTime * 7 + LastResponseTime) / 8);
        NewAve = (NewAve > (USHORT)LastResponseTime ? NewAve : LastResponseTime);

        pLink->Flags &= ~DLC_WAITING_RESPONSE_TO_POLL;

        //
        // The first poll query overrides always the constant initial value.
        //

        if (pLink->Flags & DLC_FIRST_POLL) {
            pLink->Flags &= ~DLC_FIRST_POLL;
            NewAve = LastResponseTime;
        }

        //
        // We don't want to trigger too easily the reinitialization
        // of the timers, because it's quite costly operation to be
        // done in every poll.
        // Otherwise we would reinitialize timer after every time, when
        // a poll is sent just before the main timer tick expires.
        // (This is not actually a good solution, because
        // the timers are reinitialized whenever r/16 changes.
        // The same mask is used in the timer initialisation
        //

        if ((NewAve & 0xfff0) != (pLink->AverageResponseTime & 0xfff0)) {
            pLink->AverageResponseTime = NewAve;
            InitializeLinkTimers(pLink);
        } else {
            pLink->AverageResponseTime = NewAve;
        }
    }

    //
    // Now we must release the locks when we call the upper levels which may
    // call back to this data link. Note that we kept the link closed during
    // send, because the order of the sent packet must not be changed
    //

    if (pLink->DlcStatus.StatusCode != 0) {
//        if (Status == DLC_STATUS_SUCCESS) {
//
//            PADAPTER_CONTEXT pContext = pLink->Gen.pAdapterContext;

            SaveStatusChangeEvent(pLink,
                                  pLink->Gen.pAdapterContext->pLookBuf,
                                  boolResponse
                                  );
//        } else {
//            pLink->DlcStatus.StatusCode = 0;
//        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcmem.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcmem.h

Abstract:

    Contains type and structure definitions and routine prototypes and macros
    for llcmem.c. To aid in tracking memory resources, DLC/LLC now delineates
    the following memory categories:

        Memory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...)

        ZeroMemory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...) and initialized to zeroes

        Pool
            - small sets of (relatively) small packets are allocated in one
              block from Memory or ZeroMemory as a Pool and then subdivided
              into packets

        Object
            - structures which may be packets allocated from Pool which have
              a known size and initialization values. Pseudo-category mainly
              for debugging purposes

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    kernel mode only.

Revision History:

    09-Mar-1993 RFirth
        Created

--*/

#ifndef _LLCMEM_H_
#define _LLCMEM_H_

#define DLC_POOL_TAG    ' CLD'

//
// the following types and defines are for the debug version of the driver, but
// need to be defined for the non-debug version too (not used, just defined)
//

//
// In the DEBUG version of DLC, we treat various chunks of memory as 'objects'.
// This serves the following purposes:
//
//  1.  We use a signature DWORD, so that when looking at some DLC structure in
//      the debugger, we can quickly check if what we are looking at is what we
//      think it is. E.g., if you spot a block of memory with a "BIND" signature
//      where an "ADAPTER" signature should be, then there is a good chance a
//      list or pointer has gotten messed up. The idea is to try and reduce
//      the amount of time it can take to guess what you're looking at
//
//  2.  We use consistency checks: If a routine is handed a pointer to a structure
//      which is supposed to be a FILE_CONTEXT structure, we can check the
//      signature and quickly determine if something has gone wrong (like the
//      structure has already been freed and the signature contains 0xDAADF00D
//
//  3.  We maintain size, head and tail signature information to determine
//      whether we have overwritten any part of an object. This is part of the
//      consistency check
//
// The object definitions should occur in one place only, but DLC is such a mess
// that it would be a non-trivial amount of work to clean everything up. Do it
// if there's time... (he said, knowing full well there's never any 'time')
//

typedef enum {
    DlcDriverObject = 0xCC002001,   // start off with a relatively unique id
    FileContextObject,              // 0xCC002002
    AdapterContextObject,           // 0xCC002003
    BindingContextObject,           // 0xCC002004
    DlcSapObject,                   // 0xCC002005
    DlcGroupSapObject,              // 0xCC002006
    DlcLinkObject,                  // 0xCC002007
    DlcDixObject,                   // 0xCC002008
    LlcDataLinkObject,              // 0xCC002009
    LLcDirectObject,                // 0xCC00200A
    LlcSapObject,                   // 0xCC00200B
    LlcGroupSapObject,              // 0xCC00200C
    DlcBufferPoolObject,            // 0xCC00200D
    DlcLinkPoolObject,              // 0xCC00200E
    DlcPacketPoolObject,            // 0xCC00200F
    LlcLinkPoolObject,              // 0xCC002010
    LlcPacketPoolObject             // 0xCC002011
} DLC_OBJECT_TYPE;

typedef struct {
    ULONG Signature;                // human-sensible signature when DB'd
    DLC_OBJECT_TYPE Type;           // object identifier
    ULONG Size;                     // size of this object/structure in bytes
    ULONG Extra;                    // additional size over basic object size
} OBJECT_ID, *POBJECT_ID;

#define SIGNATURE_FILE      0x454C4946  // "FILE"
#define SIGNATURE_ADAPTER   0x50414441  // "ADAP"
#define SIGNATURE_BINDING   0x444E4942  // "BIND"
#define SIGNATURE_DLC_SAP   0x44504153  // "SAPD"
#define SIGNATURE_DLC_LINK  0x4B4E494C  // "LINK"
#define SIGNATURE_DIX       0x44584944  // "DIXD"
#define SIGNATURE_LLC_LINK  0x41544144  // "DATA"
#define SIGNATURE_LLC_SAP   0x4C504153  // "SAPL"

#define ZAP_DEALLOC_VALUE   0x5A        // "Z"
#define ZAP_EX_FREE_VALUE   0x58        // "X"

//
// we try to keep track of memory allocations by subdividing them into driver
// and handle categories. The first charges memory allocated to the driver -
// e.g. a file context 'object'. Once we have open file handles, then allocations
// are charged to them
//

typedef enum {
    ChargeToDriver,
    ChargeToHandle
} MEMORY_CHARGE;

//
// MEMORY_USAGE - collection of variables used for charging memory. Accessed
// within spinlock
//

typedef struct _MEMORY_USAGE {
    struct _MEMORY_USAGE* List;     // pointer to next MEMORY_USAGE structure
    KSPIN_LOCK SpinLock;            // stop alloc & free clashing?
    PVOID Owner;                    // pointer to owning structure/object
    DLC_OBJECT_TYPE OwnerObjectId;  // identifies who owns this charge
    ULONG OwnerInstance;            // instance of type of owner
    ULONG NonPagedPoolAllocated;    // actual amount of non-paged pool charged
    ULONG AllocateCount;            // number of calls to allocate non-paged pool
    ULONG FreeCount;                // number of calls to free non-paged pool
    LIST_ENTRY PrivateList;         // list of allocated blocks owned by this usage
    ULONG Unused[2];                // pad to 16-byte boundary
} MEMORY_USAGE, *PMEMORY_USAGE;

//
// PACKET_POOL - this structure describes a packet pool. A packet pool is a
// collection of same-sized packets. The pool starts off with an initial number
// of packets on the FreeList. As packets are allocated, they are put on the
// BusyList and the reverse happens when the packets are deallocated. If there
// are no packets on the FreeList when an allocation call is made, more memory
// is allocated
//

typedef struct {

    SINGLE_LIST_ENTRY FreeList; // list of available packets
    SINGLE_LIST_ENTRY BusyList; // list of in-use packets
    KSPIN_LOCK PoolLock;        // stops simultaneous accesses breaking list(s)
    ULONG PacketSize;           // size of individual packets

    //
    // the following 2 fields are here because DLC is a piece of garbage. It
    // keeps hold of allocated packets even after the pool as been deleted.
    // This leads to pool corruption. So if we determine packets are still
    // allocated when the pool is deleted, we remove the pool from whatever
    // 'object' it is currently stuck to, lamprey-like, and add it to the
    // ZombieList. When we next deallocate packets from this pool (assuming that
    // DLC at least bothers to do this), we check the zombie state. If ImAZombie
    // is TRUE (actually its true to say for the whole DLC device driver) AND
    // we are deallocating the last packet in the pool then we really delete
    // the pool
    //

//    SINGLE_LIST_ENTRY UndeadList;
//    BOOLEAN ImAZombie;

#if DBG

    //
    // keep some metrics in the debug version to let us know if the pool is
    // growing
    //

    ULONG Signature;            // 0x4C4F4F50 "POOL"
    ULONG Viable;               // !0 if this pool is valid
    ULONG OriginalPacketCount;  // number of packets requested
    ULONG CurrentPacketCount;   // total number in pool
    ULONG Allocations;          // number of calls to allocate from this pool
    ULONG Frees;                // number of calls to free to pool
    ULONG NoneFreeCount;        // number of times allocate call made when no packets free
    ULONG MaxInUse;             // maximum number allocated at any one time
    ULONG ClashCount;           // number of simultaneous accesses to pool
    ULONG Flags;                // type of pool etc.
    ULONG ObjectSignature;      // signature for checking contents if object pool
    PMEMORY_USAGE pMemoryUsage; // pointer to memory equivalent of Discover card
    MEMORY_USAGE MemoryUsage;   // pool's memory usage charge
    ULONG FreeCount;            // number of entries on FreeList
    ULONG BusyCount;            // number of entries on BusyList
    ULONG Pad1;
    ULONG Pad2;

#endif

} PACKET_POOL, *PPACKET_POOL;

//
// PACKET_POOL defines and flags
//

#define PACKET_POOL_SIGNATURE   0x4C4F4F50  // "POOL"

#define POOL_FLAGS_IN_USE       0x00000001
#define POOL_FLAGS_OBJECT       0x00000002

//
// OBJECT_POOL - synonym for PACKET_POOL. Used in debug version (named 'objects'
// in debug version have an object signature as an aide a debugoire and as
// consistency check)
//

#define OBJECT_POOL PACKET_POOL
#define POBJECT_POOL PPACKET_POOL

//
// PACKET_HEAD - each packet which exists in a PACKET_POOL has this header -
// it links the packet onto the Free or Busy lists and the Flags word contains
// the state of the packet
//

typedef struct {

    SINGLE_LIST_ENTRY List;     // standard single-linked list
    ULONG Flags;

#if DBG

    ULONG Signature;            // 0x44414548 "HEAD"
    PVOID pPacketPool;          // owning pool
    PVOID CallersAddress_A;     // caller - allocation
    PVOID CallersCaller_A;
    PVOID CallersAddress_D;     // caller - deallocation
    PVOID CallersCaller_D;

#endif

} PACKET_HEAD, *PPACKET_HEAD;

//
// PACKET_HEAD defines and flags
//

#define PACKET_HEAD_SIGNATURE   0x44414548  // "HEAD"

#define PACKET_FLAGS_BUSY       0x00000001  // packet should be on BusyList
#define PACKET_FLAGS_POST_ALLOC 0x00000002  // this packet was allocated because
                                            // the pool was full
#define PACKET_FLAGS_FREE       0x00000080  // packet should be on FreeList

//
// OBJECT_HEAD - synonym for PACKET_HEAD. Used in debug version (named 'objects'
// in debug version have an object signature as an aide a debugoire and as
// consistency check)
//

#define OBJECT_HEAD PACKET_HEAD
#define POBJECT_HEAD PPACKET_HEAD


#if DBG

//
// anything we allocate from non-paged pool gets the following header pre-pended
// to it
//

typedef struct {
    ULONG Size;                 // inclusive size of allocated block (inc head+tail)
    ULONG OriginalSize;         // requested size
    ULONG Flags;                // IN_USE flag
    ULONG Signature;            // for checking validity of header
    LIST_ENTRY GlobalList;      // all blocks allocated on one list
    LIST_ENTRY PrivateList;     // blocks owned by MemoryUsage
    PVOID Stack[4];             // stack of return addresses
} PRIVATE_NON_PAGED_POOL_HEAD, *PPRIVATE_NON_PAGED_POOL_HEAD;

#define MEM_FLAGS_IN_USE    0x00000001

#define SIGNATURE1  0x41434C44  // "DLCA" when viewed via db/dc
#define SIGNATURE2  0x434F4C4C  // "LLOC"  "      "    "  "

//
// anything we allocate from non-paged pool has the following tail appended to it
//

typedef struct {
    ULONG Size;                 // inclusive size; must be same as in header
    ULONG Signature;            // for checking validity of tail
    ULONG Pattern1;
    ULONG Pattern2;
} PRIVATE_NON_PAGED_POOL_TAIL, *PPRIVATE_NON_PAGED_POOL_TAIL;

#define PATTERN1    0x55AA6699
#define PATTERN2    0x11EECC33

//
// standard object identifier. Expands to nothing on free build
//

#define DBG_OBJECT_ID   OBJECT_ID ObjectId

//
// globally accessible memory
//

extern MEMORY_USAGE DriverMemoryUsage;
extern MEMORY_USAGE DriverStringUsage;

//
// debug prototypes
//

VOID
InitializeMemoryPackage(
    VOID
    );

PSINGLE_LIST_ENTRY
PullEntryList(
    IN PSINGLE_LIST_ENTRY List,
    IN PSINGLE_LIST_ENTRY Element
    );

VOID
LinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    );

VOID
UnlinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    );

//
// the following 2 functions expand to be ExAllocatePoolWithTag(NonPagedPool, ...)
// and ExFreePool(...) resp. in the retail/Free version of the driver
//

PVOID
AllocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size
    );

PVOID
AllocateZeroMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size
    );

VOID
DeallocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID Pointer
    );

PPACKET_POOL
CreatePacketPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pOwner,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG PacketSize,
    IN ULONG NumberOfPackets
    );

VOID
DeletePacketPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PPACKET_POOL* pPacketPool
    );

PVOID
AllocateObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG ObjectSize
    );

VOID
FreeObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    );

VOID
ValidateObject(
    IN POBJECT_ID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    );

POBJECT_POOL
CreateObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG ObjectSize,
    IN ULONG NumberOfObjects
    );

VOID
DeleteObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN POBJECT_POOL pObjectPool
    );

POBJECT_HEAD
AllocatePoolObject(
    IN POBJECT_POOL pObjectPool
    );

VOID
DeallocatePoolObject(
    IN POBJECT_POOL pObjectPool,
    IN POBJECT_HEAD pObjectHead
    );

VOID
CheckMemoryReturned(
    IN PMEMORY_USAGE pMemoryUsage
    );

VOID
CheckDriverMemoryUsage(
    IN BOOLEAN Break
    );

//
// CHECK_DRIVER_MEMORY_USAGE - if (b) breaks into debugger if there is still
// memory allocated to driver
//

#define CHECK_DRIVER_MEMORY_USAGE(b) \
    CheckDriverMemoryUsage(b)

//
// CHECK_MEMORY_RETURNED_DRIVER - checks if all charged memory allocation has been
// refunded to the driver
//

#define CHECK_MEMORY_RETURNED_DRIVER() \
    CheckMemoryReturned(&DriverMemoryUsage)

//
// CHECK_MEMORY_RETURNED_FILE - checks if all charged memory allocation has been
// refunded to the FILE_CONTEXT
//

#define CHECK_MEMORY_RETURNED_FILE() \
    CheckMemoryReturned(&pFileContext->MemoryUsage)

//
// CHECK_MEMORY_RETURNED_ADAPTER - checks if all charged memory allocation has been
// refunded to the ADAPTER_CONTEXT
//

#define CHECK_MEMORY_RETURNED_ADAPTER() \
    CheckMemoryReturned(&pAdapterContext->MemoryUsage)

//
// CHECK_STRING_RETURNED_DRIVER - checks if all charged string allocation has been
// refunded to the driver
//

#define CHECK_STRING_RETURNED_DRIVER() \
    CheckMemoryReturned(&DriverStringUsage)

//
// CHECK_STRING_RETURNED_ADAPTER - checks if all charged string allocation has been
// refunded to the ADAPTER_CONTEXT
//

#define CHECK_STRING_RETURNED_ADAPTER() \
    CheckMemoryReturned(&pAdapterContext->StringUsage)

//
// memory allocators which charge memory usage to the driver
//

//
// ALLOCATE_MEMORY_DRIVER - allocates (n) bytes of memory and charges it to the
// driver
//

#define ALLOCATE_MEMORY_DRIVER(n) \
    AllocateMemory(&DriverMemoryUsage, (ULONG)(n))

//
// ALLOCATE_ZEROMEMORY_DRIVER - allocates (n) bytes of ZeroMemory and charges
// it to the driver
//

#define ALLOCATE_ZEROMEMORY_DRIVER(n) \
    AllocateZeroMemory(&DriverMemoryUsage, (ULONG)(n))

//
// FREE_MEMORY_DRIVER - deallocates memory and refunds it to the driver
//

#define FREE_MEMORY_DRIVER(p) \
    DeallocateMemory(&DriverMemoryUsage, (PVOID)(p))

//
// ALLOCATE_STRING_DRIVER - allocate memory for string usage. Charge to
// DriverStringUsage
//

#define ALLOCATE_STRING_DRIVER(n) \
    AllocateZeroMemory(&DriverStringUsage, (ULONG)(n))

//
// FREE_STRING_DRIVER - deallocates memory and refunds it to driver string usage
//

#define FREE_STRING_DRIVER(p) \
    DeallocateMemory(&DriverStringUsage, (PVOID)(p))

//
// CREATE_PACKET_POOL_DRIVER - calls CreatePacketPool and charges the pool
// structure to the driver
//

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_DRIVER(t, s, n) \
    CreatePacketPool(&DriverMemoryUsage,\
                    NULL,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

//
// DELETE_PACKET_POOL_DRIVER - calls DeletePacketPool and refunds the pool
// structure to the driver
//

#define DELETE_PACKET_POOL_DRIVER(p) \
    DeletePacketPool(&DriverMemoryUsage, (PPACKET_POOL*)(p))

#endif  // NO_POOLS

//
// memory allocators which charge memory usage to an ADAPTER_CONTEXT
//

//
// ALLOCATE_MEMORY_ADAPTER - allocates (n) bytes of memory and charges it to the
// ADAPTER_CONTEXT
//

#define ALLOCATE_MEMORY_ADAPTER(n) \
    AllocateMemory(&pAdapterContext->MemoryUsage, (ULONG)(n))

//
// ALLOCATE_ZEROMEMORY_ADAPTER - allocates (n) bytes of ZeroMemory and charges
// it to the ADAPTER_CONTEXT
//

#define ALLOCATE_ZEROMEMORY_ADAPTER(n) \
    AllocateZeroMemory(&pAdapterContext->MemoryUsage, (ULONG)(n))

//
// FREE_MEMORY_ADAPTER - deallocates memory and refunds it to the ADAPTER_CONTEXT
//

#define FREE_MEMORY_ADAPTER(p) \
    DeallocateMemory(&pAdapterContext->MemoryUsage, (PVOID)(p))

//
// ALLOCATE_STRING_ADAPTER - allocate memory for string usage. Charge to
// pAdapterContext StringUsage
//

#define ALLOCATE_STRING_ADAPTER(n) \
    AllocateZeroMemory(&pAdapterContext->StringUsage, (ULONG)(n))

//
// CREATE_PACKET_POOL_ADAPTER - calls CreatePacketPool and charges the pool
// structure to the adapter structure
//

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_ADAPTER(t, s, n) \
    CreatePacketPool(&pAdapterContext->MemoryUsage,\
                    (PVOID)pAdapterContext,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

//
// DELETE_PACKET_POOL_ADAPTER - calls DeletePacketPool and refunds the pool
// structure to the adapter structure
//

#define DELETE_PACKET_POOL_ADAPTER(p) \
    DeletePacketPool(&pAdapterContext->MemoryUsage, (PPACKET_POOL*)(p))

#endif  // NO_POOLS

//
// memory allocators which charge memory usage to a FILE_CONTEXT
//

//
// ALLOCATE_MEMORY_FILE - allocates (n) bytes of memory and charges it to the file
// handle
//

#define ALLOCATE_MEMORY_FILE(n) \
    AllocateMemory(&pFileContext->MemoryUsage, (ULONG)(n))

//
// ALLOCATE_ZEROMEMORY_FILE - allocates (n) bytes ZeroMemory and charges it to the
// file handle
//

#define ALLOCATE_ZEROMEMORY_FILE(n) \
    AllocateZeroMemory(&pFileContext->MemoryUsage, (ULONG)(n))

//
// FREE_MEMORY_FILE - deallocates memory and refunds it to the file handle
//

#define FREE_MEMORY_FILE(p) \
    DeallocateMemory(&pFileContext->MemoryUsage, (PVOID)(p))

//
// CREATE_PACKET_POOL_FILE - calls CreatePacketPool and charges the pool structure
// to the file handle
//

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_FILE(t, s, n) \
    CreatePacketPool(&pFileContext->MemoryUsage,\
                    (PVOID)pFileContext,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

//
// DELETE_PACKET_POOL_FILE - calls DeletePacketPool and refunds the pool structure
// to the file handle
//

#define DELETE_PACKET_POOL_FILE(p) \
    DeletePacketPool(&pFileContext->MemoryUsage, (PPACKET_POOL*)(p))

#endif  // NO_POOLS

//
// VALIDATE_OBJECT - check that an 'object' is really what it supposed to be.
// Rudimentary check based on object signature and object type fields
//

#define VALIDATE_OBJECT(p, t)           ValidateObject(p, t)

#define LINK_MEMORY_USAGE(p)        LinkMemoryUsage(&(p)->MemoryUsage)
#define UNLINK_MEMORY_USAGE(p)      UnlinkMemoryUsage(&(p)->MemoryUsage)
#define UNLINK_STRING_USAGE(p)      UnlinkMemoryUsage(&(p)->StringUsage)

#else   // !DBG

//
// DBG_OBJECT_ID in retail version structures is non-existent
//

#define DBG_OBJECT_ID

//
// the non-zero-initialized memory allocator is just a call to ExAllocatePoolWithTag
//

#define AllocateMemory(n)           ExAllocatePoolWithTag(NonPagedPool, (n), DLC_POOL_TAG)

//
// AllocateZeroMemory doesn't count memory usage in non-debug version
//

PVOID
AllocateZeroMemory(
    IN ULONG Size
    );

//
// the memory deallocator is just a call to ExFreePool
//

#define DeallocateMemory(p)         ExFreePool(p)

//
// CreatePacketPool doesn't count memory usage in non-debug version
//

PPACKET_POOL
CreatePacketPool(
    IN ULONG PacketSize,
    IN ULONG NumberOfPackets
    );

VOID
DeletePacketPool(
    IN PPACKET_POOL* pPacketPool
    );

//
// solitary objects in debug version are non-paged pool in retail version
//

#define AllocateObject(n)           AllocateZeroMemory(n)
#define DeallocateObject(p)         DeallocateMemory(p)

//
// pooled objects in debug version are pooled packets in retail version
//

#define CreateObjectPool(o, s, n)   CreatePacketPool(s, n)
#define DeleteObjectPool(p)         DeletePacketPool(p)
#define AllocatePoolObject(p)       AllocatePacket(p)
#define DeallocatePoolObject(p, h)  DeallocatePacket(p)

//
// non-debug build no-op macros
//

#define CHECK_MEMORY_RETURNED_DRIVER()
#define CHECK_MEMORY_RETURNED_FILE()
#define CHECK_MEMORY_RETURNED_ADAPTER()
#define CHECK_STRING_RETURNED_DRIVER()
#define CHECK_STRING_RETURNED_ADAPTER()
#define CHECK_DRIVER_MEMORY_USAGE(b)

//
// non-memory-charging versions of allocation/free macros
//

#define ALLOCATE_MEMORY_DRIVER(n)           AllocateMemory((ULONG)(n))
#define ALLOCATE_ZEROMEMORY_DRIVER(n)       AllocateZeroMemory((ULONG)(n))
#define FREE_MEMORY_DRIVER(p)               DeallocateMemory((PVOID)(p))
#define ALLOCATE_STRING_DRIVER(n)           AllocateZeroMemory((ULONG)(n))
#define FREE_STRING_DRIVER(p)               DeallocateMemory((PVOID)(p))

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_DRIVER(t, s, n)  CreatePacketPool((ULONG)(s), (ULONG)(n))
#define DELETE_PACKET_POOL_DRIVER(p)        DeletePacketPool((PPACKET_POOL*)(p))

#endif  // NO_POOLS

#define ALLOCATE_MEMORY_ADAPTER(n)          AllocateMemory((ULONG)(n))
#define ALLOCATE_ZEROMEMORY_ADAPTER(n)      AllocateZeroMemory((ULONG)(n))
#define FREE_MEMORY_ADAPTER(p)              DeallocateMemory((PVOID)(p))
#define ALLOCATE_STRING_ADAPTER(n)          AllocateZeroMemory((ULONG)(n))

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_ADAPTER(t, s, n) CreatePacketPool((s), (n))
#define DELETE_PACKET_POOL_ADAPTER(p)       DeletePacketPool((PPACKET_POOL*)(p))

#endif  // NO_POOLS

#define ALLOCATE_MEMORY_FILE(n)             AllocateMemory((ULONG)(n))
#define ALLOCATE_ZEROMEMORY_FILE(n)         AllocateZeroMemory((ULONG)(n))
#define FREE_MEMORY_FILE(p)                 DeallocateMemory((PVOID)(p))

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_FILE(t, s, n)    CreatePacketPool((ULONG)(s), (ULONG)(n))
#define DELETE_PACKET_POOL_FILE(p)          DeletePacketPool((PPACKET_POOL*)(p))

#endif  // NO_POOLS

#define VALIDATE_OBJECT(p, t)

#define LINK_MEMORY_USAGE(p)
#define UNLINK_MEMORY_USAGE(p)
#define UNLINK_STRING_USAGE(p)

#endif  // DBG

//
// Prototypes for memory allocators and pool and object functions
//

PVOID
AllocatePacket(
    IN PPACKET_POOL pPacketPool
    );

VOID
DeallocatePacket(
    IN PPACKET_POOL pPacketPool,
    IN PVOID pPacket
    );

#if defined(NO_POOLS)

#define CREATE_PACKET_POOL_DRIVER(t, s, n)  (PVOID)0x12345678
#define CREATE_PACKET_POOL_ADAPTER(t, s, n) (PVOID)0x12345679
#define CREATE_PACKET_POOL_FILE(t, s, n)    (PVOID)0x1234567A

#define DELETE_PACKET_POOL_DRIVER(p)    *p = NULL
#define DELETE_PACKET_POOL_ADAPTER(p)   *p = NULL
#define DELETE_PACKET_POOL_FILE(p)      *p = NULL

#if defined(BUF_USES_POOL)

#if DBG

#define CREATE_BUFFER_POOL_FILE(t, s, n) \
    CreatePacketPool(&pFileContext->MemoryUsage,\
                    (PVOID)pFileContext,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

#define DELETE_BUFFER_POOL_FILE(p) \
    DeletePacketPool(&pFileContext->MemoryUsage, (PPACKET_POOL*)(p))

#define ALLOCATE_PACKET_DLC_BUF(p)  AllocatePacket(p)
#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocatePacket(pool, p)

#else   // !DBG

#define CREATE_BUFFER_POOL_FILE(t, s, n)    CreatePacketPool((ULONG)(s), (ULONG)(n))
#define DELETE_BUFFER_POOL_FILE(p)  DeletePacketPool((PPACKET_POOL*)(p))
#define ALLOCATE_PACKET_DLC_BUF(p)  ALLOCATE_ZEROMEMORY_FILE(sizeof(DLC_BUFFER_HEADER))
#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  FREE_MEMORY_FILE(p)

#endif  // DBG

#else   // !BUF_USES_POOL

#define CREATE_BUFFER_POOL_FILE(t, s, n)    (PVOID)0x1234567B
#define DELETE_BUFFER_POOL_FILE(p)          *p = NULL
#define ALLOCATE_PACKET_DLC_BUF(p)          AllocateZeroMemory(sizeof(DLC_BUFFER_HEADER))
#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocateMemory(p)

#endif  // BUF_USES_POOL

#if DBG

#define ALLOCATE_PACKET_DLC_PKT(p)  ALLOCATE_ZEROMEMORY_FILE(sizeof(DLC_PACKET))
#define ALLOCATE_PACKET_DLC_OBJ(p)  ALLOCATE_ZEROMEMORY_FILE(sizeof(DLC_OBJECT))
#define ALLOCATE_PACKET_LLC_PKT(p)  ALLOCATE_ZEROMEMORY_ADAPTER(sizeof(UNITED_PACKETS))
#define ALLOCATE_PACKET_LLC_LNK(p)  ALLOCATE_ZEROMEMORY_ADAPTER(sizeof(DATA_LINK) + 32)

#define DEALLOCATE_PACKET_DLC_PKT(pool, p)  FREE_MEMORY_FILE(p)
#define DEALLOCATE_PACKET_DLC_OBJ(pool, p)  FREE_MEMORY_FILE(p)
#define DEALLOCATE_PACKET_LLC_PKT(pool, p)  FREE_MEMORY_ADAPTER(p)
#define DEALLOCATE_PACKET_LLC_LNK(pool, p)  FREE_MEMORY_ADAPTER(p)

#else   // !DBG

#define CREATE_BUFFER_POOL_FILE(t, s, n)    CREATE_PACKET_POOL_FILE(t, s, n)
#define DELETE_BUFFER_POOL_FILE(p)  DELETE_PACKET_POOL_FILE(p)

#define ALLOCATE_PACKET_DLC_BUF(p)  AllocateZeroMemory(sizeof(DLC_BUFFER_HEADER))
#define ALLOCATE_PACKET_DLC_PKT(p)  AllocateZeroMemory(sizeof(DLC_PACKET))
#define ALLOCATE_PACKET_DLC_OBJ(p)  AllocateZeroMemory(sizeof(DLC_OBJECT))
#define ALLOCATE_PACKET_LLC_PKT(p)  AllocateZeroMemory(sizeof(UNITED_PACKETS))
#define ALLOCATE_PACKET_LLC_LNK(p)  AllocateZeroMemory(sizeof(DATA_LINK) + 32)

#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_DLC_PKT(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_DLC_OBJ(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_LLC_PKT(pool, p)  DeallocateMemory(p)
#define DEALLOCATE_PACKET_LLC_LNK(pool, p)  DeallocateMemory(p)

#endif  // DBG

#else   // !NO_POOLS

#define CREATE_BUFFER_POOL_FILE(t, s, n)    CREATE_PACKET_POOL_FILE(t, s, n)
#define DELETE_BUFFER_POOL_FILE(p)  DELETE_PACKET_POOL_FILE(p)

#define ALLOCATE_PACKET_DLC_BUF(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_DLC_PKT(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_DLC_OBJ(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_LLC_PKT(p)  AllocatePacket(p)
#define ALLOCATE_PACKET_LLC_LNK(p)  AllocatePacket(p)

#define DEALLOCATE_PACKET_DLC_BUF(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_DLC_PKT(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_DLC_OBJ(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_LLC_PKT(pool, p)  DeallocatePacket(pool, p)
#define DEALLOCATE_PACKET_LLC_LNK(pool, p)  DeallocatePacket(pool, p)

#endif  // NO_POOLS

#endif  // _LLCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcrcv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcrcv.c

Abstract:

    The module implements the NDIS receive indication handling and
    its routing to upper protocol modules or to link state machines.

    To understand the link related procedure of this module, you should read
    Chapters 11 and 12 in IBM Token-Ring Architecture Reference.

    Contents:
        LlcNdisReceiveIndication
        LlcNdisReceiveComplete
        ProcessType1_Frames
        MakeRcvIndication
        ProcessType2_Frames
        ProcessNewSabme
        LlcTransferData
        LlcNdisTransferDataComplete
        safe_memcpy
        FramingDiscoveryCacheHit

Author:

    Antti Saarenheimo (o-anttis) 18-MAY-1991

Revision History:

    19-Nov-1992 rfirth
        RtlMoveMemory on MIPS, copying from shared TR buffer fails (see rubric
        for safe_memcpy). Changed to private memory mover for this particular
        case

    02-May-1994 rfirth
        Added caching for auto-framing discovery (TEST/XID/SABME-UA)

--*/

#include <dlc.h>
#include <llc.h>

//
// private prototypes...
//

VOID
safe_memcpy(
    OUT PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Length
    );

BOOLEAN
FramingDiscoveryCacheHit(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PBINDING_CONTEXT pBindingContext
    );

#define MIN(a,b)    ((a) < (b) ? (a) : (b))

//
// Local lookup tables to receive the correct frames for a direct station
//

static USHORT ReceiveMasks[LLC_PACKET_MAX] = {
    DLC_RCV_8022_FRAMES,
    DLC_RCV_MAC_FRAMES,
    DLC_RCV_DIX_FRAMES,
    DLC_RCV_OTHER_DESTINATION
};

static UCHAR FrameTypes[LLC_PACKET_MAX] = {
    LLC_DIRECT_8022,
    LLC_DIRECT_MAC,
    LLC_DIRECT_ETHERNET_TYPE,
    (UCHAR)(-1)
};

//
// functions
//


NDIS_STATUS
LlcNdisReceiveIndication(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID pHeadBuf,
    IN UINT cbHeadBuf,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf,
    IN UINT cbPacketSize
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link
    endpoint (That was from SteveJ's NBF, the guy must have a degree in
    the english literature).  This routine is very time critical!

    We first check the frame type (token-ring, 802.3 ethernet or dix),
    then check its data link address (802.2 saps or ethernet type)
    and then we route it to the upper protocol that has opened the
    address, that the frame was sent to.  The link level frames
    are first run through the protocol state machine, and only
    the accepted I- frames are indicated to upper level.

Arguments:

    pAdapterContext     - The Adapter Binding specified at initialization time

    MacReceiveContext   - Note: different from binding handle, mac needs this
                          to support re-entrant receive indications

    pHeadBuf            - pointer to a buffer containing the packet header

    cbHeadBuf           - size of the header

    pLookBuf            - pointer to a buffer containing the negotiated minimum
                          amount of buffer I get to look at, not including header

    cbLookBuf           - the size of the above. May be less than asked for, if
                          that's all there is

    cbPacketSize        - Overall size of the packet, not including the header

Assumes:

    pHeadBuf contains all the header information:

        802.3   6 bytes destination address
                6 bytes source address
                2 bytes big-endian length or packet type (DIX frames)

        802.5   1 byte Access Control
                1 byte Frame Control
                6 bytes destination address
                6 bytes source address
                0-18 bytes source routing

        FDDI    1 byte Frame Control
                6 bytes destination address
                6 bytes source address

    From this we can assume for Token Ring that if cbHeadBuf is >14 (decimal)
    then there IS source routing information in the packet

Return Value:

    NDIS_STATUS:

        NDIS_STATUS_SUCCESS
            Packet accepted

        NDIS_STATUS_NOT_RECOGNIZED
            Packet not recognized by protocol

        NDIS_any_other_thing if I understand, but can't handle.

--*/

{
    LLC_HEADER llcHdr;
    LAN802_ADDRESS Source;
    LAN802_ADDRESS Destination;
    USHORT EthernetTypeOrLength;
    PDATA_LINK pLink;
    PLLC_SAP pSap;
    UCHAR PacketType = LLC_PACKET_8022;
    UCHAR cbLanHeader = 14;
    KIRQL OldIrql;
    UCHAR packet[36];   // enough space for 14-byte header, 18-byte source
                        // routing, 1-byte DSAP, 1-byte SSAP & 2-byte LPDU
    PLLC_OBJECT pObject;
    UINT cbCopy;

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'rvcR');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {                                           
        REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
        return (NDIS_STATUS_ADAPTER_NOT_OPEN);
    }
#endif // NDIS40
    
    UNREFERENCED_PARAMETER(OldIrql);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // we assume at least 13 bytes in the header for all media types. Also
    // assume that the header is no larger than the packet buffer
    //

    ASSERT(cbHeadBuf >= 13);
    ASSERT(cbHeadBuf <= sizeof(packet));

    if ( cbHeadBuf > LLC_MAX_LAN_HEADER ) {
#ifdef NDIS40
        REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
#endif // NDIS40
      return NDIS_STATUS_INVALID_PACKET;
    }
    
    if ( (cbHeadBuf < 13) || (cbHeadBuf > sizeof(packet)) ) {
#ifdef NDIS40
        REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
#endif // NDIS40
      return NDIS_STATUS_INVALID_PACKET;
    }

    LlcMemCpy(packet, pHeadBuf, cbHeadBuf);
    
    cbCopy = MIN(sizeof(packet) - cbHeadBuf, cbLookBuf);
    LlcMemCpy(packet+cbHeadBuf, pLookBuf, cbCopy);

    cbPacketSize += cbHeadBuf;

    //
    // First we do the inital checking for the frame and read
    // the destination and source address and LLC header to
    // DWORD aligned addresses. We avoid any bigendiand/
    // small endiand problematic by forgotting the second high
    // byte in the addresses. The lowest ULONG is used only as
    // an raw data. The bytes can be accesses in any way.
    // The macros read LLC header in a small endiand safe way.
    //

    switch (pAdapterContext->NdisMedium) {
    case NdisMedium802_3:
        LlcMemCpy(Destination.Node.auchAddress, packet, 6);
        LlcMemCpy(Source.Node.auchAddress, packet + 6, 6);

        //
        // The 802.3 LLC frames have always the length field!
        // A 802.3 MAC should discard all Ethernet frames
        // longer than 1500 bytes.
        //
        // X'80D5 is a special ethernet type used when 802.2 frame
        // is encapsulated inside a ethernet type header.
        // (Ethernet type/size is in a reverse order for
        // Intel architecture)
        //

        EthernetTypeOrLength = (USHORT)packet[12] * 256 + (USHORT)packet[13];

        if (EthernetTypeOrLength < 3) {
        #ifdef NDIS40
            REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
        #endif // NDIS40
            return NDIS_STATUS_INVALID_PACKET;
        }

        //
        // If the ethernet length/type field is more than 1500, the
        // frame is dix frame and the length field is a dix ethernet
        // address.  Otherwise the frame is a normal 802.3 frame,
        // that has always LLC header inside it.
        //

        if (EthernetTypeOrLength > 1500) {
            if (EthernetTypeOrLength == 0x80D5) {

                //
                // This is a special 'IBM SNA over ethernet' type,
                // that consists of the length field, 1 byte padding
                // and complete 802.2 LLC header (including the info field).
                //
              
                if ( cbLookBuf < 3 ) {
                #ifdef NDIS40
                    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
                #endif // NDIS40
                  return NDIS_STATUS_NOT_RECOGNIZED;
                }
	      
                cbLanHeader = 17;
                (PUCHAR)pLookBuf += 3;
                cbLookBuf -= 3;

                //
                // The DIX frame size is stored as a big-endian USHORT at offset
                // 15 in the LAN header. Add 17 for the DIX LAN header:
                //
                //      6 bytes destination address
                //      6 bytes source address
                //      2 bytes DIX identifier (0x80D5)
                //      2 byte big-endian information frame length
                //      1 byte pad
                //

                pAdapterContext->cbPacketSize = (USHORT)packet[14] * 256
                                              + (USHORT)packet[15]
                                              + 17;

                if ( pAdapterContext->cbPacketSize > cbPacketSize ) {
                #ifdef NDIS40
                    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
                #endif // NDIS40
                  return NDIS_STATUS_INVALID_PACKET;
                }

                //
                // we now keep an indicator which explicitly defines that this
                // frame has (SNA) DIX framing
                //

                pAdapterContext->IsSnaDixFrame = TRUE;
            } else {

                //
                // This is some other DIX format frame. We don't know what the
                // format of this is (app-specific). We hand the entire packet
                // to the app and let it sort out the format. The frame may be
                // padded in which case the app gets the padding too
                //

                //
                // This is still Ethernet, so cbHeadBuf is 14, even though
                // the actual LAN header is only 12
                //

                PacketType = LLC_PACKET_DIX;
                pAdapterContext->cbPacketSize = cbPacketSize;

                //
                // this frame is not SNA DIX, although it is generically a DIX
                // frame. It will be indicated via a specific DIX SAP, not as
                // a general ethernet frame
                //

                pAdapterContext->IsSnaDixFrame = FALSE;
            }
        } else {

            //
            // Ethernet packets include always the padding,
            // we use the actual size saved in 802.3 header.
            // Include also the header: 6 + 6 + 2
            //

            pAdapterContext->cbPacketSize = EthernetTypeOrLength + 14;

            //
            // this is an 802.3 frame - not DIX at all
            //

            pAdapterContext->IsSnaDixFrame = FALSE;
        }
        break;

    case NdisMedium802_5:
        LlcMemCpy(Destination.Node.auchAddress, packet + 2, 6);
        LlcMemCpy(Source.Node.auchAddress, packet + 8, 6);

        //
        // cbHeadBuf always has the correct LAN header length for Token Ring
        //

        cbLanHeader = (UCHAR)cbHeadBuf;

        pAdapterContext->cbPacketSize = cbPacketSize;

        //
        // bit7 and bit6 in FC byte defines the frame type in token ring.
        // 00 => MAC frame (no LLC), 01 => LLC, 10,11 => reserved.
        // We send all other frames to direct except 01 (LLC)
        //

        if ((packet[1] & 0xC0) == 0x40) {

            //
            // check if we have routing info?
            //

            if (Source.Node.auchAddress[0] & 0x80) {

                //
                // reset the source routing indicator in the
                // source address (it would mess up the link search)
                //

                Source.Node.auchAddress[0] &= 0x7f;

                //
                // Discard all invalid TR frames, they'd corrupt the memory
                //

                if (cbLanHeader > MAX_TR_LAN_HEADER_SIZE) {
                #ifdef NDIS40
                    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
                #endif // NDIS40
                    return NDIS_STATUS_NOT_RECOGNIZED;
                }
            }
        } else {

            //
            // this is a MAC frame destined to direct station
            //

            PacketType = LLC_PACKET_MAC;
        }
        break;

    case NdisMediumFddi:
        LlcMemCpy(Destination.Node.auchAddress, packet + 1, 6);
        LlcMemCpy(Source.Node.auchAddress, packet + 7, 6);

        //
        // cbHeadBuf always has the correct LAN header length for FDDI
        //

        cbLanHeader = (UCHAR)cbHeadBuf;

        pAdapterContext->cbPacketSize = cbPacketSize;

        //
        // bit5 and bit4 in FC byte define the FDDI frame type:
        //
        //      00 => MAC or SMT
        //      01 => LLC
        //      10 => implementer (?)
        //      11 => reserved
        //
        // do same as TR: LLC frames to link/SAP, everything else to direct
        // station
        //

        if ((packet[0] & 0x30) != 0x10) {
            PacketType = LLC_PACKET_MAC;
        }
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif

    }

    pAdapterContext->FrameType = FrameTypes[PacketType];

    //
    // Direct interface gets all non LLC frames and also all LLC frames
    // that were not sent to this station (ie. different destination
    // address field and having no broadcast bit (bit7) set in
    // destination address)).  Ie. promiscuous mode, this data link
    // version does not support promiscuous mode.
    //

    if (Destination.Node.auchAddress[0] & pAdapterContext->IsBroadcast) {
        pAdapterContext->ulBroadcastAddress = Destination.Address.ulLow;
        pAdapterContext->usBroadcastAddress = Destination.Address.usHigh;
    } else {
        pAdapterContext->ulBroadcastAddress = 0;

        //
        // We must also be able to handle the promiscuous packets
        //

        if (Destination.Address.ulLow != pAdapterContext->Adapter.Address.ulLow
        && Destination.Address.usHigh != pAdapterContext->Adapter.Address.usHigh) {
            PacketType = LLC_PACKET_OTHER_DESTINATION;
        }
    }

    //
    // Setup the current receive indication context,
    // there can be only one simultaneous receive indication from
    // a network adapter simultaneously.  We save the necessary
    // data into adapter context to save unnecessary stack operations
    //

    pAdapterContext->NdisRcvStatus = NDIS_STATUS_NOT_RECOGNIZED;
    pAdapterContext->LinkRcvStatus = STATUS_SUCCESS;
    pAdapterContext->pHeadBuf = (PUCHAR)pHeadBuf;
    pAdapterContext->cbHeadBuf = cbHeadBuf;
    pAdapterContext->pLookBuf = (PUCHAR)pLookBuf;
    pAdapterContext->cbLookBuf = cbLookBuf;
    pAdapterContext->RcvLanHeaderLength = (USHORT)cbLanHeader;

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    switch(PacketType) {
    case LLC_PACKET_8022:

        //
        // Read the whole LLC frame (a maybe an extra byte,
        // if this is a U frame).
        // Note: Source and destination saps are swapped in
        //       the received frames
        //

        Source.Address.SrcSap = llcHdr.S.Dsap = packet[cbLanHeader];
        llcHdr.S.Ssap = packet[cbLanHeader + 1];
        Source.Address.DestSap = llcHdr.S.Ssap & (UCHAR)0xfe;
        llcHdr.S.Command = packet[cbLanHeader + 2];
        llcHdr.S.Nr = packet[cbLanHeader + 3];

        if (pSap = pAdapterContext->apSapBindings[llcHdr.U.Dsap]) {

            //
            // The broadcast addresses cannot be destined to link stations
            //

            if (pAdapterContext->ulBroadcastAddress == 0) {
                SEARCH_LINK(pAdapterContext, Source, pLink);
                if (pLink) {

                    //
                    // Process all connection oriented frames, the procedure
                    // will call ProcessType1_Frames, if it finds that the
                    // frame is connectionless.
                    // (We should bring the whole subprocedure here,
                    // because it isn't called elsewhere).
                    //

                    ProcessType2_Frames(pAdapterContext, MacReceiveContext, pLink, llcHdr);
                } else {

                    //
                    // Process all connectionless frames and
                    // SABMEs (connection requests to create a
                    // new link station)
                    //

                    ProcessType1_Frames(pAdapterContext, MacReceiveContext, pSap, llcHdr);
                }
            } else {

                //
                // Process the broadcasts, this cannot have
                // nothing to do with the links
                //

                ProcessType1_Frames(pAdapterContext, MacReceiveContext, pSap, llcHdr);
            }
        } else {

            //
            // The SAP has not been defined, but we must still respond
            // to the TEST and XID commands sent to the NULL SAP.
            // They must be echoed back to the sender
            //

            if ((llcHdr.U.Dsap == LLC_SSAP_NULL)
            && !(llcHdr.U.Ssap & LLC_SSAP_RESPONSE)) {

                //
                // if the remote machine is already in the framing discovery
                // cache but is using the other framing type then discard this
                // TEST/XID command/response
                //

//                if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
//                    break;
//                }

                RespondTestOrXid(pAdapterContext, MacReceiveContext, llcHdr, LLC_SSAP_NULL);
            } else if (pAdapterContext->pDirectStation != NULL) {
                pAdapterContext->usRcvMask = ReceiveMasks[PacketType];
                MakeRcvIndication(pAdapterContext, MacReceiveContext, (PLLC_OBJECT)pAdapterContext->pDirectStation);
            }
        }
        break;

    case LLC_PACKET_DIX:

        //
        // Search the DIX packet from the database
        //

        pObject = (PLLC_OBJECT)pAdapterContext->aDixStations[EthernetTypeOrLength % MAX_DIX_TABLE];
        if (pObject) {
            pAdapterContext->EthernetType = EthernetTypeOrLength;
        } else {
            pObject = (PLLC_OBJECT)pAdapterContext->pDirectStation;
            if (pObject) {
                pAdapterContext->usRcvMask = ReceiveMasks[PacketType];
            }
        }
        if (pObject) {
            MakeRcvIndication(pAdapterContext, MacReceiveContext, pObject);
        }
        break;

    case LLC_PACKET_OTHER_DESTINATION:
    case LLC_PACKET_MAC:

        //
        // discard the return status of the direct stations!
        // The combining of the returns statuses would take too much time
        // NDIS 3.0 isn't actually any more intrested if frame is copied.
        //

        if (pObject = (PLLC_OBJECT)pAdapterContext->pDirectStation) {
            pAdapterContext->usRcvMask = ReceiveMasks[PacketType];
            MakeRcvIndication(pAdapterContext, MacReceiveContext, pObject);
        }
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif

    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'rvcR');
#endif // NDIS40
    
    return pAdapterContext->NdisRcvStatus;
}


VOID
LlcNdisReceiveComplete(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    The routine handles the receive complete indications.  The receive
    completion is made by NDIS when the network hardware have been
    enabled again for receive. In a UP Nt this does mean, that a
    new frame could be received, because we are still on DPC level and
    the receive indication is still in DPC queue to wait us to complete.
    Actually that is OK, because otherwise the stack would overflow,
    if there would be too many received packets.

Arguments:

    pAdapterContext - adapter context

Return Value:

    None

--*/

{
#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'pCxR');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {
        // 
        // Must be in the middle of an unbind, otherwise NDIS would have never
        // called the receive handler.
        //

        REFDEL(&pAdapterContext->AdapterRefCnt, 'pCxR');
        return;
    }
#endif // NDIS40

    //
    // seems that 3Com FDDI card is calling this at PASSIVE_LEVEL
    //

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    //
    // Skip the whole background process if there is nothing to do.
    // its the default case, when we are receiving I or UI data.
    //

    if (pAdapterContext->LlcPacketInSendQueue
    || !IsListEmpty(&pAdapterContext->QueueCommands)
    || !IsListEmpty(&pAdapterContext->QueueEvents)) {

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        BackgroundProcessAndUnlock(pAdapterContext);
    }

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'pCxR');
#endif // NDIS40
}


VOID
ProcessType1_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    )

/*++

Routine Description:

    Route UI, TEST or XID frames to the LLC client

Arguments:

    pAdapterContext - The Adapter Binding specified at initialization time.
    pSap            - pointer to the SAP object of data link driver
    LlcHeader       - 802.2 header is copied to stack to make its access fast

Return Value:

    None.

--*/

{
    UCHAR DlcCommand;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Update the counter, we must later check the lost frames
    // (no buffers available for the received UI- frames)
    //

    pSap->Statistics.FramesReceived++;

    //
    // We must use the link station state machine with any other
    // command except UI frames and broadcasts, if the link exists.
    //

    if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_UI) {
        pAdapterContext->FrameType = LLC_UI_FRAME;
        MakeRcvIndication(pAdapterContext, MacReceiveContext, (PLLC_OBJECT)pSap);
        return;

        //
        // Check next if the frame is a XID or TEST frame
        //

    } else if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_TEST) {

        //
        // if the remote machine is already in the framing discovery cache but
        // is using the other framing type then discard this TEST command/response
        //

        //
        // RLF 06/23/94
        //
        // If this is a Response from SAP 0 then don't check the cache. The
        // reason is that currently DLC will automatically generate responses
        // to TESTs and XIDs sent to SAP 0. It will generate 802.3 and DIX
        // irrespective of whether it is configured for DIX or not. The upshot
        // is that a DIX-only machine can currently send an 802.3 response
        // which when we run it through the cache, causes us to assume the other
        // machine is configured for 802.3, not DIX. In communicado.
        // For TEST and XIDs from SAP 0, we have to let the app receive the
        // duplicate and decide what to do with it
        //

        if (LlcHeader.U.Ssap != (LLC_SSAP_NULL | LLC_SSAP_RESPONSE)) {
            if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
                return;
            }
        }
        if (!(LlcHeader.U.Ssap & LLC_SSAP_RESPONSE)) {

            //
            // The Test commands are always echoed back
            // (the Command/Response bit was reset => this is command)
            //

            RespondTestOrXid(pAdapterContext, MacReceiveContext, LlcHeader, pSap->SourceSap);
            pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
            return;
        } else {
            DlcCommand = LLC_TEST_RESPONSE_NOT_FINAL;
        }
    } else if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_XID) {

        //
        // if the remote machine is already in the framing discovery cache but
        // is using the other framing type then discard this XID command/response
        //

        //
        // RLF 06/23/94
        //
        // If this is a Response from SAP 0 then don't check the cache. See above
        //

        if (LlcHeader.U.Ssap != (LLC_SSAP_NULL | LLC_SSAP_RESPONSE)) {
            if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
                return;
            }
        }

        //
        // The upper level protocol may ask data link driver to handle the XIDs
        //

        if (!(LlcHeader.U.Ssap & LLC_SSAP_RESPONSE)) {
            if (pSap->OpenOptions & LLC_HANDLE_XID_COMMANDS) {
                RespondTestOrXid(pAdapterContext, MacReceiveContext, LlcHeader, pSap->SourceSap);
                pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
                return;
            } else {
                DlcCommand = LLC_XID_COMMAND_NOT_POLL;
            }
        } else {
            DlcCommand = LLC_XID_RESPONSE_NOT_FINAL;
        }
    } else if ((LlcHeader.U.Command & ~LLC_U_POLL_FINAL) == LLC_SABME) {

        //
        // can't open a connection by broadcasting a SABME
        //

        if (pAdapterContext->ulBroadcastAddress != 0) {
            return;
        }

        //
        // if the remote machine is already in the framing discovery cache but
        // is using the other framing type then discard this SABME
        //

        if (FramingDiscoveryCacheHit(pAdapterContext, pSap->Gen.pLlcBinding)) {
            return;
        }

        //
        // This is a remote connection request
        //

        ProcessNewSabme(pAdapterContext, pSap, LlcHeader);
        pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
        return;
    } else {
        return;
    }

    if (LlcHeader.auchRawBytes[2] & LLC_U_POLL_FINAL) {
        DlcCommand -= 2;
    }

    pAdapterContext->FrameType = DlcCommand;
    MakeRcvIndication(pAdapterContext, MacReceiveContext, (PLLC_OBJECT)pSap);
}


VOID
MakeRcvIndication(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_OBJECT pStation
    )

/*++

Routine Description:

    Procedure makes a generic receive indication for all frames
    received by SAP or direct stations.

Arguments:

    pAdapterContext - adapter context of the received packet
    pStation        - SAP or DIRECT station

Return Value:

    None.

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // SAP and direct stations can be shared by several link clients
    // (if they have been opened in shared mode).  Route the packet
    // to all clints registered to this SAP or direct station
    // A link station may have only one owner.
    //

    for (; pStation; pStation = (PLLC_OBJECT)pStation->Gen.pNext) {

        //
        // Rotate the direct frames to all direct stations except if
        // the frame has already been captured by the current client.
        // We use 32-bit client context to identify the client,
        // that had already received the frame to its SAP or link station.
        //
        // Broadcasts are indicated only when they match with the
        // group or functional address defined for this binding.
        // The global broadcast is passed through, if it is enabled.
        //

        if (

            //
            // 1. Check is this is destinated frame (broadcast is null) or
            //    if the packet is a broadcast with a matching group address
            //

            ((pAdapterContext->ulBroadcastAddress == 0)
            || (pAdapterContext->ulBroadcastAddress == 0xFFFFFFFFL)
            || ((pAdapterContext->ulBroadcastAddress & pStation->Gen.pLlcBinding->Functional.ulAddress)
            && ((pAdapterContext->ulBroadcastAddress & pStation->Gen.pLlcBinding->ulFunctionalZeroBits) == 0)
            && (pAdapterContext->usBroadcastAddress == pAdapterContext->usHighFunctionalBits))
            || ((pAdapterContext->ulBroadcastAddress == pStation->Gen.pLlcBinding->ulBroadcastAddress)
            && (pAdapterContext->usBroadcastAddress == pStation->Gen.pLlcBinding->usBroadcastAddress)))

            //
            // 2. If the station type is DIX, then the ethernet type
            //    must be the same as the station's ethernet type

            && ((pStation->Gen.ObjectType != LLC_DIX_OBJECT)
            || (pStation->Dix.ObjectAddress == pAdapterContext->EthernetType))

            //
            // 3. If the packet is a direct frame, then its receive mask
            //    must match with the received frame.
            //

            && ((pStation->Gen.ObjectType != LLC_DIRECT_OBJECT)
            || (pStation->Dir.OpenOptions & pAdapterContext->usRcvMask))) {

            UINT Status;

            //
            // Update the counter, we must later check the lost frames
            // (if no buffers available for the received frames)
            //

            pStation->Sap.Statistics.FramesReceived++;
            pAdapterContext->NdisRcvStatus = NDIS_STATUS_SUCCESS;
            if (pAdapterContext->cbPacketSize < pAdapterContext->RcvLanHeaderLength) {
              return;
            }
            Status = pStation->Gen.pLlcBinding->pfReceiveIndication(
                pStation->Gen.pLlcBinding->hClientContext,
                pStation->Gen.hClientHandle,
                MacReceiveContext,
                pAdapterContext->FrameType,
                pAdapterContext->pLookBuf,
                pAdapterContext->cbPacketSize - pAdapterContext->RcvLanHeaderLength
                );

            //
            // Protocol may discard the packet and its indication.
            //

            if (Status != STATUS_SUCCESS) {
                pStation->Sap.Statistics.DataLostCounter++;
                if (Status == DLC_STATUS_NO_RECEIVE_COMMAND) {
                    pStation->Sap.Statistics.FramesDiscardedNoRcv++;
                }
            }
        }
    }
}



//
// Vs - we will be sending this next.
// Va - other side is expecting this next.
// was:
// if (pLink->Vs >= pLink->Va) {
//     if (pLink->Nr < pLink->Va || pLink->Nr > pLink->Vs) {
//         uchInput = LPDU_INVALID_r0;
//     }
// } else {
//     if (pLink->Nr > pLink->Vs && pLink->Nr < pLink->Va) {
//         uchInput = LPDU_INVALID_r0;
//     }
// }
//

int
verify_pack(
    IN      UCHAR  VsMax,        // pLink->VsMax
    IN      UCHAR  Vs,           // pLink->Vs,
    IN      UCHAR  Va,           // pLink->Va,
    IN      UCHAR  Nr,           // pLink->Nr,
    IN OUT  UCHAR *uchInput      // &uchInput
)
{
    if( Va <= VsMax ){           // Not Wrapped around 127?

        if( Nr < Va ){

            // this frame is saying it is expecting
            // Nr which is less than what it was expecting (Va)

            *uchInput = LPDU_INVALID_r0;

        }else if ( VsMax < Nr ){

            // He can't expect (Nr) beyond what we sent (Vs).

            *uchInput = LPDU_INVALID_r0;
        }
    }else{    // Vs sent is less < Acked Va, ie. wrapped. And

        if( VsMax < Nr   &&   Nr < Va ) {

            //  Eg. expecting between Va=126..0=Vs, (wrap range).
            //  and 0 ... Nr .. 126, is invalid.

            *uchInput = LPDU_INVALID_r0;
        }
    }
    return 0;
}


VOID
ProcessType2_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN OUT PDATA_LINK pLink,
    IN LLC_HEADER LlcHeader
    )

/*++

Routine Description:

    Procedure preprocess LLC Type2 frames for the actual state machine.
    Type 2 LLC frames are: I, RR, RNR, REJ, SABME, DISC, UA, DM, FRMR.
    The data is indicated to the upper protocol module, if it sequence
    number of the I- frame is valid, but the receive may still fail,
    if the data packet is discarded by the 802.2 state machine.
    The data is first indicated to the client, because we must set
    first the state machine to the local busy state, if the upper
    protocol module has not enough buffers to receive the data.

Arguments:

    pAdapterContext - The Adapter Binding specified at initialization time.
    pLink           - link station data
    LlcHeader       - LLC header

Return Value:

    None.

--*/

{
    UCHAR uchInput;
    BOOLEAN boolPollFinal;
    BOOLEAN boolInitialLocalBusyUser;
    UINT status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // The last received command is included in the DLC statistics
    //

    pLink->LastCmdOrRespReceived = LlcHeader.U.Command;

    //
    // Handle first I frames, they are the most common!
    //

    if (!(LlcHeader.U.Command & LLC_NOT_I_FRAME)) {

        //
        // Check first the sync of the I- frame: The send sequence
        // number should be what we are expected or some packets sare lost.
        //

        uchInput = IS_I_r0;     // In Sequence Information frame by default

        //
        // we discard all I-frames, that are bigger than the
        // maximum defined for this link station.
        // This must be the best way to solve wrong packet size.
        // FRMR disconnects the packets and the invalid transmit
        // command should fail in the sending side.
        //

        pLink->Nr = LlcHeader.I.Nr & (UCHAR)0xfe;
        if (pLink->MaxIField + pAdapterContext->RcvLanHeaderLength
        + sizeof(LLC_HEADER) < pAdapterContext->cbPacketSize) {
            uchInput = LPDU_INVALID_r0;
        } else if ((LlcHeader.I.Ns & (UCHAR)0xfe) != pLink->Vr) {

            //
            // Out of Sequence Information frame (we didn't expect this!)
            //

            uchInput = OS_I_r0;

            //
            // When we are out of receive buffers, we want to know
            // the buffer space required by all expected frames.
            // There may be several coming I-frames in the send queues,
            // bridges and in the receive buffers of the adapter when a
            // link enters a local busy state.  We save the size of
            // all received sequential I-frames during a local busy state
            // to know how much buffer space we must commit before we
            // can clear the local busy state.
            //

            if ((pLink->Flags & DLC_LOCAL_BUSY_BUFFER)
            && (LlcHeader.I.Ns & (UCHAR)0xfe) == pLink->VrDuringLocalBusy){
                pLink->VrDuringLocalBusy += 2;
                pLink->BufferCommitment  += BufGetPacketSize(pAdapterContext->cbPacketSize);
            }

            //
            // The valid frames has modulo: Va <= Nr <= Vs,
            // Ie. the Receive sequence number should belong to
            // a frame that has been sent but not acknowledged.
            // The extra check in the beginning makes the most common
            // code path faster: usually the other is waiting the next frame.
            //
            
        } else if (pLink->Nr != pLink->Vs) {
          
            //
            // There may by something wrong with the receive sequence number
            //

            verify_pack( pLink->VsMax,
                         pLink->Vs,
                         pLink->Va,
                         pLink->Nr,
                         &uchInput    );

        }

        //
        // We must first indcate the frame to the upper protocol and
        // then check, if it was accepted by the state machine.
        // If a I- frame cannot be received by the upper protocol
        // driver, then it must be dropped to the floor and be not
        // indicated to the state machine (=> the frame will be lost
        // for the LLC protocol)
        //

        //
        // RLF 04/13/93
        //
        // if the link is in local busy (user) state then don't indicate the
        // frame, but RNR it
        //

        // bug #193762
        //
        // AK 06/20/98
        //
        // Save the current user local busy flag. The receive indication
        // may release the driver lock (the ACQUIRE_SPIN_LOCK is a no-op because
        // the DLC_UNILOCK=1 in the sources file) it is possible that the link
        // state is different after the indication returns.
        //
        boolInitialLocalBusyUser = (pLink->Flags & DLC_LOCAL_BUSY_USER);

        if ((uchInput == IS_I_r0) && !(pLink->Flags & DLC_LOCAL_BUSY_USER)) {

            DLC_STATUS Status;

            pAdapterContext->LinkRcvStatus = STATUS_PENDING;

            if (pAdapterContext->cbPacketSize < pAdapterContext->RcvLanHeaderLength) {
              return;
            }

            Status = pLink->Gen.pLlcBinding->pfReceiveIndication(
                pLink->Gen.pLlcBinding->hClientContext,
                pLink->Gen.hClientHandle,
                MacReceiveContext,
                LLC_I_FRAME,
                pAdapterContext->pLookBuf,
                pAdapterContext->cbPacketSize - pAdapterContext->RcvLanHeaderLength
                );

            //
            // We use local busy to stop the send to the link.
            // IBM link station flow control management supports
            // local busy state enabling because of "out of receive buffers"
            // or "no outstanding receive".
            //

            if (Status != STATUS_SUCCESS) {
                if (Status == DLC_STATUS_NO_RECEIVE_COMMAND
                || Status == DLC_STATUS_OUT_OF_RCV_BUFFERS) {

                    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                    //
                    // We will enter to a local busy state because of
                    // out of buffers. Save the buffer size required
                    // to receive this data.
                    //

                    pLink->VrDuringLocalBusy = pLink->Vr;
                    pLink->BufferCommitment = BufGetPacketSize(pAdapterContext->cbPacketSize);

                    //
                    // We do not need to care, if the local busy state
                    // is already set or not.  The state machine just
                    // returns an error status, but we do not care
                    // about it.  The dlc status code trigger indication
                    // to the upper levels, if the state machine accepted
                    // the command.
                    //

                    pLink->Flags |= DLC_LOCAL_BUSY_BUFFER;
                    pLink->DlcStatus.StatusCode |= INDICATE_LOCAL_STATION_BUSY;
                    RunStateMachineCommand(pLink, ENTER_LCL_Busy);

                    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
                }
            }
        }

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        //
        // The most common case is handled as a special case.
        // We can save maybe 30 instrunctions.
        //

        if (uchInput == IS_I_r0 && pLink->State == LINK_OPENED) {
            UpdateVa(pLink);
            pLink->Vr += 2;
            pAdapterContext->LinkRcvStatus = STATUS_SUCCESS;

            //
            // IS_I_c1 = Update_Va; Rcv_BTU; [Send_ACK]
            // IS_I_r|IS_I_c0 = Update_Va; Rcv_BTU; TT2; Ir_Ct=N3; [RR_r](1)
            //

            if ((LlcHeader.I.Nr & LLC_I_S_POLL_FINAL)
            && !(LlcHeader.I.Ssap & LLC_SSAP_RESPONSE)) {
                StopTimer(&pLink->T2);
                pLink->Ir_Ct = pLink->N3;
                SendLlcFrame(pLink, (UCHAR)(DLC_RR_TOKEN | DLC_TOKEN_RESPONSE | 1));
            } else {
                SendAck(pLink);
            }
        } else {

            // bug #193762
            //
            // AK 06/20/98
            //
            // If the link was not busy (user) when this function was entered but
            // it is busy (user) now but not busy (system) then the frame must have
            // been accepted by the upper layer and we must adjust Acknowledge state
            // variable (Va) and Receive state variable (Vr). Otherwise we'll send
            // wrong N(r) in the RNR frame and we'll receive this same frame again when
            // we clear the local busy.
            //
            if(uchInput == IS_I_r0 &&
               !boolInitialLocalBusyUser &&
               !(pLink->Flags & DLC_LOCAL_BUSY_BUFFER) &&
               (pLink->Flags & DLC_LOCAL_BUSY_USER))
            {
                UpdateVa(pLink);
                pLink->Vr += 2;
                pAdapterContext->LinkRcvStatus = STATUS_SUCCESS;
            }

            uchInput += (UINT)(LlcHeader.I.Nr & LLC_I_S_POLL_FINAL);

            if (!(LlcHeader.I.Ssap & LLC_SSAP_RESPONSE)) {
                uchInput += DLC_TOKEN_COMMAND;
            }

            //
            // Nr will be some garbage in the case of U commands,
            // but the Poll/Final flag is not used when the U- commands
            // are processed.
            // ----
            // If the state machine returns an error to link receive status,
            // then the receive command completion cancels the received
            // frame.
            //

            pAdapterContext->LinkRcvStatus = RunStateMachine(
                pLink,
                (USHORT)uchInput,
                (BOOLEAN)((LlcHeader.S.Nr & LLC_I_S_POLL_FINAL) ? 1 : 0),
                (BOOLEAN)(LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)
                );
        }

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        //
        // Update the error counters if something went wrong with
        // the receive.
        //

        if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {

            //
            // We will count all I frames not actually acknowledged
            // as errors (this could be counted also other way).
            //

            pLink->Statistics.I_FrameReceiveErrors++;
            if (pLink->Statistics.I_FrameReceiveErrors == 0x80) {
                pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
            }
        } else {

            //
            // update statistics: in-sequency frames OK, all others
            // must be  errors.
            // This may not be the best place to count successful I-frames,
            // because the state machine has not yet acknowledged this frame,
            // We may be in a wrong state to receive any data (eg. local busy)
            //

            pLink->Statistics.I_FramesReceived++;
            if (pLink->Statistics.I_FramesReceived == 0x8000) {
                pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
            }
            pLink->pSap->Statistics.FramesReceived++;
        }

        //
        // We may complete this only if the transfer data has
        // already completed (and there is a receive completion
        // packet built up in).
        //

        if (pLink->Gen.pLlcBinding->TransferDataPacket.pPacket != NULL
        && pLink->Gen.pLlcBinding->TransferDataPacket.pPacket->Data.Completion.Status != NDIS_STATUS_PENDING) {

            //
            // The NDIS status is saved in the completion status, we
            // will use state machine status instead, if the state
            // machine returned an error.
            //

            if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {
                pLink->Gen.pLlcBinding->TransferDataPacket.pPacket->Data.Completion.Status = pAdapterContext->LinkRcvStatus;
            }
            pLink->Gen.pLlcBinding->pfCommandComplete(
                pLink->Gen.pLlcBinding->hClientContext,
                pLink->Gen.pLlcBinding->TransferDataPacket.pPacket->Data.Completion.hClientHandle,
                pLink->Gen.pLlcBinding->TransferDataPacket.pPacket
                );
            pLink->Gen.pLlcBinding->TransferDataPacket.pPacket = NULL;
        }

        //
        // ******** EXIT ***********
        //

        return;
    } else if (!(LlcHeader.S.Command & LLC_U_TYPE_BIT)) {

        //
        // Handle S (Supervisory) commands (RR, REJ, RNR)
        //

        switch (LlcHeader.S.Command) {
        case LLC_RR:
            uchInput = RR_r0;
            break;

        case LLC_RNR:
            uchInput = RNR_r0;
            break;

        case LLC_REJ:
            uchInput = REJ_r0;
            break;

        default:
            uchInput = LPDU_INVALID_r0;
            break;
        }

        //
        // The valid frames has modulo: Va <= Nr <= Vs,
        // Ie. the Receive sequence number should belong to
        // a frame that has been sent but not acknowledged.
        // The extra check in the beginning makes the most common
        // code path faster: usually the other is waiting the next frame.
        // (keep the rest code the same as in I path, even a very
        // primitive optimizer will puts these code paths together)
        //

        pLink->Nr = LlcHeader.I.Nr & (UCHAR)0xfe;
        if (pLink->Nr != pLink->Vs) {

            //
            // Check the received sequence number
            //

            verify_pack( pLink->VsMax,
                         pLink->Vs,
                         pLink->Va,
                         pLink->Nr,
                         &uchInput    );


        }
        uchInput += (UINT)(LlcHeader.S.Nr & LLC_I_S_POLL_FINAL);
        boolPollFinal = (BOOLEAN)(LlcHeader.S.Nr & LLC_I_S_POLL_FINAL);

        if (!(LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)) {
            uchInput += DLC_TOKEN_COMMAND;
        }
    } else {

        //
        // Handle U (Unnumbered) command frames
        // (FRMR, DM, UA, DISC, SABME, XID, TEST)
        //

        switch (LlcHeader.U.Command & ~LLC_U_POLL_FINAL) {
        case LLC_DISC:
            uchInput = DISC0;
            break;

        case LLC_SABME:
            uchInput = SABME0;
            break;

        case LLC_DM:
            uchInput = DM0;
            break;

        case LLC_UA:
            uchInput = UA0;
            break;

        case LLC_FRMR:
            uchInput =  FRMR0;
            break;

        default:

            //
            // we don't handle XID and TEST frames here!
            //

            ProcessType1_Frames(pAdapterContext, MacReceiveContext, pLink->pSap, LlcHeader);
            return;
            break;
        };

        //
        // We set an uniform poll/final bit for procedure call
        //

        boolPollFinal = FALSE;
        if (LlcHeader.U.Command & LLC_U_POLL_FINAL) {
            uchInput += 1;
            boolPollFinal = TRUE;
        }
    }

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // Note: the 3rd parameter must be 0 or 1, fortunately the
    // the poll/final bit is bit0 in S and I frames.
    //

    status = RunStateMachine(pLink,
                             (USHORT)uchInput,
                             boolPollFinal,
                             (BOOLEAN)(LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)
                             );

    //
    // if this frame is a UA AND it was accepted by the FSM AND the framing type
    // is currently unspecified then set it to the type in the UA frame received.
    // If this is not an ethernet adapter or we are not in AUTO mode then the
    // framing type for this link is set to the framing type in the binding
    // context (as it was before)
    //

    if ((status == STATUS_SUCCESS)
    && ((uchInput == UA0) || (uchInput == SABME0) || (uchInput == SABME1))
    && (pLink->FramingType == LLC_SEND_UNSPECIFIED)) {

        //
        // RLF 05/09/94
        //
        // If we received a UA in response to a SABME that we sent out as DIX
        // and 802.3, then record the framing type. This will be used for all
        // subsequent frames sent on this link
        //

        pLink->FramingType = (IS_SNA_DIX_FRAME(pAdapterContext)
                           && IS_AUTO_BINDING(pLink->Gen.pLlcBinding))
                           ? LLC_SEND_802_3_TO_DIX
                           : pLink->Gen.pLlcBinding->InternalAddressTranslation
                           ;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}


VOID
ProcessNewSabme(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    )

/*++

Routine Description:

    Procedure processes the remote connection requtest: SABME.
    It allocates a new link from the pool of closed links in
    the SAP and runs the state machine.

Arguments:

    pAdapterContext - The Adapter Binding specified at initialization time.
    pSap            - the current SAP handle
    LlcHeader       - LLC header

Return Value:

    None.

--*/

{
    PDATA_LINK pLink;
    DLC_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // The destination sap cannot be a group SAP any more,
    // thus we don't need to mask the lowest bit aways
    //

    Status = LlcOpenLinkStation(
                pSap,
                (UCHAR)(LlcHeader.auchRawBytes[DLC_SSAP_OFFSET] & 0xfe),
                NULL,
                pAdapterContext->pHeadBuf,
                NULL,        // no client handle => DLC driver must create it
                (PVOID*)&pLink
                );

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // We can do nothing, if we are out of resources
    //

    if (Status != STATUS_SUCCESS) {
        return;
    }

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // RLF 05/09/94
    //
    // We need to keep a per-connection indication of the framing type if the
    // adapter was opened in AUTO mode (else we generate 802.3 UA to DIX SABME)
    // Only do this for Ethernet adapters (we only set the SNA DIX frame
    // indicator in that case)
    //

    pLink->FramingType = (IS_SNA_DIX_FRAME(pAdapterContext)
                       && IS_AUTO_BINDING(pLink->Gen.pLlcBinding))
                       ? LLC_SEND_802_3_TO_DIX
                       : pLink->Gen.pLlcBinding->InternalAddressTranslation
                       ;

    //
    // now create the Link Station by running the FSM with ACTIVATE_LS as input.
    // This just initializes the link station 'object'. Then run the FSM again,
    // this time with the SABME command as input
    //

    RunStateMachineCommand(pLink, ACTIVATE_LS);
    RunStateMachine(
        pLink,
        (USHORT)((LlcHeader.U.Command & LLC_U_POLL_FINAL) ? SABME1 : SABME0),
        (BOOLEAN)((LlcHeader.U.Command & LLC_U_POLL_FINAL) ? 1 : 0),
        (BOOLEAN)TRUE
        );

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
}


VOID
LlcTransferData(
    IN PBINDING_CONTEXT pBindingContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_PACKET pPacket,
    IN PMDL pMdl,
    IN UINT uiCopyOffset,
    IN UINT cbCopyLength
    )

/*++

Routine Description:

    This function copies only the data part of the received frame - that is
    the area after the LLC and DLC headers. If NDIS handed us all the data
    in the lookahead buffer, then WE can copy it out. Otherwise we have to
    call NDIS to get the data.

    If this is a DIX format frame, then NDIS thinks that the LAN header is
    14 bytes, but we know it is 17. We have to tell NDIS to copy from 3 bytes
    further into the data part of the received frame than we would normally
    have to

Arguments:

    pBindingContext - binding handle
	MacReceiveContext - For NdisTransferData
    pPacket         - receive context packet
    pMdl            - pointer to MDL describing data to copy
    uiCopyOffset    - offset from start of mapped buffer to copy from
    cbCopyLength    - length to copy

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pBindingContext->pAdapterContext;

    pPacket->Data.Completion.CompletedCommand = LLC_RECEIVE_COMPLETION;

    //
    // if the amount of data to copy is contained within the lookahead buffer
    // then we can copy the data.
    //
    // Remember: pAdapterContext->cbLookBuf and pLookBuf have been correctly
    // adjusted in the case of a DIX format frame
    //

    if (pAdapterContext->cbLookBuf - uiCopyOffset >= cbCopyLength) {

        PUCHAR pSrcBuffer;
        UINT BufferLength;

        pSrcBuffer = pAdapterContext->pLookBuf + uiCopyOffset;

        do {
            if (cbCopyLength > MmGetMdlByteCount(pMdl)) {
                BufferLength = MmGetMdlByteCount(pMdl);
            } else {
                BufferLength = cbCopyLength;
            }

            //
            // In 386 memcpy is faster than RtlMoveMemory, it also
            // makes the full register optimization much easier, because
            // all registers are available (no proc calls within loop)
            //

            //
            // !!!! Can't use LlcMemCpy here: On mips expands to RtlMoveMemory
            //      which uses FP registers. This won't work with shared memory
            //      on TR card
            //

            safe_memcpy(MmGetSystemAddressForMdl(pMdl), pSrcBuffer, BufferLength);
            pMdl = pMdl->Next;
            pSrcBuffer += BufferLength;
            cbCopyLength -= BufferLength;
        } while (cbCopyLength);
        pPacket->Data.Completion.Status = STATUS_SUCCESS;
        pBindingContext->TransferDataPacket.pPacket = pPacket;

    } else {

        //
        // too bad: there is more data to copy than is available in the look
        // ahead buffer. We have to call NDIS to perform the copy
        //

        UINT BytesCopied;

        //
        // if this is an Ethernet adapter and the received LAN header length is
        // more than 14 bytes then this is a DIX frame. We need to let NDIS know
        // that we want to copy data from 3 bytes in from where it thinks the
        // DLC header starts
        //

        UINT additionalOffset = (pAdapterContext->NdisMedium == NdisMedium802_3)
                                    ? (pAdapterContext->RcvLanHeaderLength > 14)
                                        ? 3
                                        : 0
                                    : 0;

#if DBG
        if (additionalOffset) {
            ASSERT(pAdapterContext->RcvLanHeaderLength == 17);
        }
#endif

        //
        // Theoretically NdisTransferData may not complete
        // immediately, and we cannot add to the completion
        // list, because the command is not really complete.
        // We may save it to adapter context to wait the
        // NdisTransferData to complete.
        //

        if (pBindingContext->TransferDataPacket.pPacket != NULL) {

            //
            // BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG
            //
            // If the same LLC client tries to receive the same buffer
            // many times (eg. when receive a packet to a group sap) and
            // if NDIS would complete those commands asynchronously, then
            // we cannot receive the frame with NdisTransferData.
            // Fortunately all NDIS implemnetations completes NdisTransferData
            // synchronously.
            // Solution: We could chain new packets to the existing data transfer
            //     packet, and copy the data, when the first data transfer request
            //     completes.  This would mean a lot of code, that would never
            //     used by anyone.  We would also need MDL to MDL copy function.
            //     The first data transfer could also be a smaller that another
            //     after it => would not work in a very general case, but
            //     would work with the group saps (all receives would be the same
            //     => direct MDL -> MDL copy would be OK.
            //
            // BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG-BUG
            //

            pPacket->Data.Completion.Status = DLC_STATUS_ASYNC_DATA_TRANSFER_FAILED;

            pBindingContext->pfCommandComplete(pBindingContext->hClientContext,
                                               pPacket->Data.Completion.hClientHandle,
                                               pPacket
                                               );
        }

        pBindingContext->TransferDataPacket.pPacket = pPacket;
        pPacket->pBinding = pBindingContext;
        ResetNdisPacket(&pBindingContext->TransferDataPacket);
        NdisChainBufferAtFront((PNDIS_PACKET)&pBindingContext->TransferDataPacket, pMdl);

        //
        // ADAMBA - Removed pAdapterContext->RcvLanHeaderLength
        // from ByteOffset (the fourth param).
        //

        NdisTransferData((PNDIS_STATUS)&pPacket->Data.Completion.Status,
                         pAdapterContext->NdisBindingHandle,
                         MacReceiveContext,

                         //
                         // if this is a DIX frame we have to move the data
                         // pointer ahead by the amount in additionalOffset
                         // (should always be 3 in this case) and reduce the
                         // amount of data to copy by the same number
                         //

                         uiCopyOffset + additionalOffset,

                         //
                         // we DON'T need to account for the additionalOffset
                         // in the length to be copied though
                         //

                         cbCopyLength,
                         (PNDIS_PACKET)&pBindingContext->TransferDataPacket,
                         &BytesCopied
                         );
    }

    //
    // We must queue a packet for the final receive completion,
    // But we cannot do it until TransferData is completed
    // (it is actually always completed, but this code is just
    // for sure).
    //

    if (pPacket->Data.Completion.Status != NDIS_STATUS_PENDING
    && pAdapterContext->LinkRcvStatus != STATUS_PENDING) {

        //
        // We receive the data before it is checked by the link station.
        // The upper protocol must just setup asynchronous receive
        // and later in LLC_RECEIVE_COMPLETION handling to
        // discard the receive, if it failed or accept if
        // it was OK for NDIS and link station.
        //

        if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {
            pPacket->Data.Completion.Status = pAdapterContext->LinkRcvStatus;
        }

        ACQUIRE_DRIVER_LOCK();

        pBindingContext->pfCommandComplete(pBindingContext->hClientContext,
                                           pPacket->Data.Completion.hClientHandle,
                                           pPacket
                                           );

        RELEASE_DRIVER_LOCK();

        pBindingContext->TransferDataPacket.pPacket = NULL;
    }
}


VOID
LlcNdisTransferDataComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT uiBytesTransferred
    )

/*++

Routine Description:

    The routine handles NdisCompleteDataTransfer indication and
    queues the indication of the completed receive operation.

Arguments:

    pAdapterContext     - adapter context
    pPacket             - NDIS packet used in the data transfer
    NdisStatus          - status of the completed data transfer
    uiBytesTransferred  - who needs this, I am not interested in
                          the partially succeeded data transfers,

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(uiBytesTransferred);
    UNREFERENCED_PARAMETER(OldIrql);

    ASSUME_IRQL(DISPATCH_LEVEL);

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'xefX');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {
        REFDEL(&pAdapterContext->AdapterRefCnt, 'xefX');
        return;
    }
#endif // NDIS40
    
    ACQUIRE_DRIVER_LOCK();

    if (((PLLC_TRANSFER_PACKET)pPacket)->pPacket != NULL) {
        ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->Data.Completion.Status = NdisStatus;

        //
        // I- frames have two statuses.  The link state machine is executed
        // after the NdisDataTransfer and thus its returned status may still
        // cancel the command. There are no spin locks around the return status
        // handling, but this should still work fine. It actually does not
        // matter if we return NDIS or state machine error code
        //

        if (pAdapterContext->LinkRcvStatus != STATUS_PENDING) {
            if (pAdapterContext->LinkRcvStatus != STATUS_SUCCESS) {
                ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->Data.Completion.Status = pAdapterContext->LinkRcvStatus;
            }
            ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->pBinding->pfCommandComplete(
                    ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->pBinding->hClientContext,
                    ((PLLC_TRANSFER_PACKET)pPacket)->pPacket->Data.Completion.hClientHandle,
                    ((PLLC_TRANSFER_PACKET)pPacket)->pPacket
                    );
            ((PLLC_TRANSFER_PACKET)pPacket)->pPacket = NULL;
        }
    }

    RELEASE_DRIVER_LOCK();

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'xefX');
#endif // NDIS40
}


VOID
safe_memcpy(
    OUT PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This is here because on a MIPS machine, LlcMemCpy expands to RtlMoveMemory
    which wants to use 64-bit floating point (CP1) registers for memory moves
    where both source and destination are aligned on 8-byte boundaries and
    where the length is a multiple of 32 bytes. If the source or destination
    buffer is actually the shared memory of a TR card, then the 64-bit moves
    (saw it on read, presume same for write) can only access memory in 32-bit
    chunks and 01 02 03 04 05 06 07 08 gets converted to 01 02 03 04 01 02 03 04.
    So this function attempts to do basically the same, without all the smarts
    as the original, but doesn't employ coprocessor registers to achieve the
    move. Hence slower, but safer

Arguments:

    Destination - where we're copying to
    Source      - where we're copying from
    Length      - how many bytes to move

Return Value:

    None.

--*/

{
    ULONG difference = (ULONG)((ULONG_PTR)Destination - (ULONG_PTR)Source);
    INT i;

    if (!(difference && Length)) {
        return;
    }

    //
    // if the destination overlaps the source then do reverse copy. Add a little
    // optimization - a la RtlMoveMemory - try to copy as many bytes as DWORDS.
    // However, on MIPS, both source and destination must be DWORD aligned to
    // do this. If both aren't then fall-back to BYTE copy
    //

    if (difference < Length) {
        if (!(((ULONG_PTR)Destination & 3) || ((ULONG_PTR)Source & 3))) {
            Destination += Length;
            Source += Length;

            for (i = Length % 4; i; --i) {
                *--Destination = *--Source;
            }
            for (i = Length / 4; i; --i) {
                *--((PULONG)Destination) = *--((PULONG)Source);
            }
        } else {
            Destination += Length;
            Source += Length;

            while (Length--) {
                *--Destination = *--Source;
            }
        }
    } else {
        if (!(((ULONG_PTR)Destination & 3) || ((ULONG_PTR)Source & 3))) {
            for (i = Length / 4; i; --i) {
                *((PULONG)Destination)++ = *((PULONG)Source)++;
            }
            for (i = Length % 4; i; --i) {
                *Destination++ = *Source++;
            }
        } else {
            while (Length--) {
                *Destination++ = *Source++;
            }
        }
    }
}


BOOLEAN
FramingDiscoveryCacheHit(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    This function is called when we receive a TEST/XID/SABME frame AND the
    adapter binding was created with LLC_ETHERNET_TYPE_AUTO AND we opened an
    ethernet adapter.

    The frame has either 802.3 or DIX framing. For all command and response TEST
    and XID frames and all SABME frames received, we keep note of the MAC address
    where the frame originated and its framing type.

    The first time we receive one of the above frames from a particular MAC
    address, the info will not be in the cache. So we add it. Subsequent frames
    of the above type (all others are passed through) with the same framing type
    as that in the cache will be indicated to the higher layers. If one of the
    above frame types arrives with THE OPPOSITE framing type (i.e. DIX instead
    of 802.3) then when we look in the cache for the MAC address we will find
    that it is already there, but with a different framing type (i.e. 802.3
    instead of DIX). In this case, we assume that the frame is an automatic
    duplicate and we discard it

    NOTE: We don't have to worry about UA because we only expect one SABME to
    be accepted: either we're sending the duplicate SABME and the target machine
    is configured for 802.3 or DIX, BUT NOT BOTH, or the receiving machine is
    another NT box running this DLC (with caching enabled!) and it will filter
    out the duplicate. Hence, in both situations, only one UA response should be
    generated per the SABME 'event'

    ASSUMES: The tick count returned from the system never wraps (! 2^63/10^7
    == 29,247+ years)

Arguments:

    pAdapterContext - pointer to ADAPTER_CONTEXT which has been filled in with
                      pHeadBuf pointing to - at least - the first 14 bytes in
                      the frame header
    pBindingContext - pointer to BINDING_CONTEXT containing the EthernetType
                      and if LLC_ETHERNET_TYPE_AUTO, the address of the framing
                      discovery cache

Return Value:

    BOOLEAN
        TRUE    - the MAC address was found in the cache WITH THE OTHER FRAMING
                  TYPE. Therefore the current frame should be discarded
        FALSE   - the MAC address/framing type combination was not found. The
                  frame should be indicated to the higher layer. If caching is
                  enabled, the frame has been added to the cache

--*/

{
    ULONG i;
    ULONG lruIndex;
    LARGE_INTEGER timeStamp;
    NODE_ADDRESS nodeAddress;
    PFRAMING_DISCOVERY_CACHE_ENTRY pCache;
    UCHAR framingType;

    //
    // if the binding context was not created with LLC_ETHERNET_TYPE_AUTO (and
    // therefore by implication, adapter is not ethernet) OR framing discovery
    // caching is disabled (the value read from the registry was zero) then bail
    // out with a not-found indication
    //

    if ((pBindingContext->EthernetType != LLC_ETHERNET_TYPE_AUTO)
    || (pBindingContext->FramingDiscoveryCacheEntries == 0)) {

#if defined(DEBUG_DISCOVERY)

        DbgPrint("FramingDiscoveryCacheHit: Not AUTO or 0 cache: returning FALSE\n");

#endif

        return FALSE;
    }

#if defined(DEBUG_DISCOVERY)

    {
        //
        // even though this is debug code, we shouldn't really be
        // indexing so far into pHeadBuf. Its only guaranteed to be
        // 14 bytes long. Should be looking in pLookBuf[5] and [2]
        //

        UCHAR frame = (pAdapterContext->pHeadBuf[12] == 0x80)
                    ? pAdapterContext->pHeadBuf[19]
                    : pAdapterContext->pHeadBuf[16];

        frame &= ~0x10; // knock off Poll/Final bit

        DbgPrint("FramingDiscoveryCacheHit: Received: %02x-%02x-%02x-%02x-%02x-%02x %s %s (%02x)\n",
                 pAdapterContext->pHeadBuf[6],
                 pAdapterContext->pHeadBuf[7],
                 pAdapterContext->pHeadBuf[8],
                 pAdapterContext->pHeadBuf[9],
                 pAdapterContext->pHeadBuf[10],
                 pAdapterContext->pHeadBuf[11],
                 (pAdapterContext->pHeadBuf[12] == 0x80)
                    ? "DIX"
                    : "802.3",
                 (frame == 0xE3)
                    ? "TEST"
                    : (frame == 0xAF)
                        ? "XID"
                        : (frame == 0x6F)
                            ? "SABME"
                            : (frame == 0x63)
                                ? "UA"
                                : "???",
                 frame
                 );
    }

#endif

    //
    // set up and perform a linear search of the cache (it should be reasonably
    // small and the comparisons are ULONG & USHORT, so not time critical
    //

    lruIndex = 0;

    //
    // better make sure we don't get data misalignment on MIPS
    //

    nodeAddress.Words.Top4 = *(ULONG UNALIGNED *)&pAdapterContext->pHeadBuf[6];
    nodeAddress.Words.Bottom2 = *(USHORT UNALIGNED *)&pAdapterContext->pHeadBuf[10];
    pCache = pBindingContext->FramingDiscoveryCache;

    //
    // framingType is the type we are looking for in the cache, not the type
    // in the frame
    //

    framingType = ((pAdapterContext->pHeadBuf[12] == 0x80)
                && (pAdapterContext->pHeadBuf[13] == 0xD5))
                ? FRAMING_TYPE_802_3
                : FRAMING_TYPE_DIX
                ;

    //
    // get the current tick count for comparison of time stamps
    //

    KeQueryTickCount(&timeStamp);

    //
    // linear search the cache
    //

    for (i = 0; i < pBindingContext->FramingDiscoveryCacheEntries; ++i) {
        if (pCache[i].InUse) {
            if ((pCache[i].NodeAddress.Words.Top4 == nodeAddress.Words.Top4)
            && (pCache[i].NodeAddress.Words.Bottom2 == nodeAddress.Words.Bottom2)) {

                //
                // we found the destination MAC address. If it has the opposite
                // framing type to that in the frame just received, return TRUE
                // else FALSE. In both cases refresh the time stamp
                //

                pCache[i].TimeStamp = timeStamp;

#if defined(DEBUG_DISCOVERY)

                DbgPrint("FramingDiscoveryCacheHit: Returning %s. Index = %d\n\n",
                         (pCache[i].FramingType == framingType) ? "TRUE" : "FALSE",
                         i
                         );

#endif

                return (pCache[i].FramingType == framingType);
            } else if (pCache[i].TimeStamp.QuadPart < timeStamp.QuadPart) {

                //
                // if we need to throw out a cache entry, we throw out the one
                // with the oldest time stamp
                //

                timeStamp = pCache[i].TimeStamp;
                lruIndex = i;
            }
        } else {

            //
            // we have hit an unused entry. The destination address/framing type
            // cannot be in the cache: add the received address/framing type at
            // this unused location
            //

            lruIndex = i;
            break;
        }
    }

    //
    // the destination address/framing type combination are not in the cache.
    // Add them. Throw out an entry if necessary
    //

#if defined(DEBUG_DISCOVERY)

    DbgPrint("FramingDiscoveryCacheHit: Adding/Throwing out %d (time stamp %08x.%08x\n",
             lruIndex,
             pCache[lruIndex].TimeStamp.HighPart,
             pCache[lruIndex].TimeStamp.LowPart
             );

#endif

    pCache[lruIndex].NodeAddress.Words.Top4 = nodeAddress.Words.Top4;
    pCache[lruIndex].NodeAddress.Words.Bottom2 = nodeAddress.Words.Bottom2;
    pCache[lruIndex].InUse = TRUE;
    pCache[lruIndex].FramingType = (framingType == FRAMING_TYPE_DIX)
                                 ? FRAMING_TYPE_802_3
                                 : FRAMING_TYPE_DIX
                                 ;
    pCache[lruIndex].TimeStamp = timeStamp;

    //
    // return FALSE meaning the destination address/framing type just received
    // was not in the cache (but it is now)
    //

#if defined(DEBUG_DISCOVERY)

    DbgPrint("FramingDiscoveryCacheHit: Returning FALSE\n\n");

#endif

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcmain.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcmain.c

Abstract:

    This module implements data link object for NDIS 3.0.
    Data link driver provides 802.2 LLC Class I and II services
    and also interface to send and receive direct network data.
    This module may later be used as general packet router
    for the protocol modules => smaller system overhead, when
    the NDIS packet header is checked only once.  LLC interface
    is also much easier to use than NDIS.

    Its main tasks are:
        - implement simple and realiable LLC Class II
          connection-oriented services for the other drivers
    - provide network independent interface 802.2 interface
    - remove the system overhead of the packet and indication
      routing to all protocol modules
        - provide transmit packet queueing for the protocol drivers
        - provide 802.2 compatible connect, disconnect and close
          services, that calls back, when the transmit queue is
          empty.

    The services provides the module are somewhat extended
    802.2 services, because the protocol engine is a IBM version
    of ISO-HDLC ABM.  LlcDisconnet and LlcConnect primitives
    implements both Request and Confirm  of Connect/Disconnect

    Data link driver does not make any buffering for the data.
    All data buffer except the LLC header and lan header with the
    I-frames must be provided by the calling protocol driver.


    *********************** SPINLOCK RULES *************************

    DataLink driver uses extensively several spin locks to make it
    as re-entrant as possible with multiple processors and to
    minimize unnecessary spin locking calls.
    The main problem with multiple spin locks are the dead locks.
    The spin locks must always be acquired the same order (and
    released in a reverse order):

    This is the order used with DataLink spin locks:

    1. Adapter->ObjectDataBase
        Protects objects from close/delete. This is always locked in
        the receive indication routine.

    2. Link->SpinLock
        Protects the link.  This lock is needed to prevent to upper
        protocol to call the link station, when we are changing it state.
        SendSpinLock cannot protect it, because it must be switched off,
        when the pending commands are executed.  (But could we keep
        SendSpinLock locked, when the transmit commands are completed).
        There will occure a dead lock in any way, if the upper protocol
        is waiting the last transmit to complete before it disconnects
        a link  station.


    3. Adapter->SendSpinLock            // protects queues and packet pools

    ---
    Timer spin locks is used only by timer servives:
    4. TimerSpinLock                    // protects the timer queues

    ****************************************************************

    Contents:
        LlcInitialize
        LlcTerminate

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

//
// This define enables the private DLC function prototypes
// We don't want to export our data types to the dlc layer.
// MIPS compiler doesn't accept hiding of the internal data
// structures by a PVOID in the function prototype.
// i386 will check the type defines
//

#ifndef i386

#define LLC_PUBLIC_NDIS_PROTOTYPES

#endif

#include <llc.h>
#include "dbgmsg.h"

//
// These are the defaults defined in the IBM LAN Architecture reference,
// this may be set by a DLC application, if it want to change the defaults.
//

DLC_LINK_PARAMETERS DefaultParameters = {
    3,      // T1 600 milliseconds (3 * 5 * 40)
    2,      // T2  80 milliseconds (2 * 1 * 40)
    10,     // Ti 25 seconds  ((10 - 5) * 125 * 4)
    127,    // TW: maximum transmit window size
    127,    // RW: The maximum receive window size
    20,     // Nw: number of LPDUs acknowledged, before Ww is incr.)
    5,      // N2: Number of retires allowed (both Polls and I LPDSs)
    0,      // lowest proirity by default
    600     // default for info field length by default
};

KMUTEX NdisAccessMutex;
KSEMAPHORE OpenAdapterSemaphore;

#define LLC_PROTOCOL_NAME   L"DLC"

#ifdef NDIS40
extern ULONG gWaitForAdapter;
#endif // NDIS40


DLC_STATUS
LlcInitialize(
    VOID
    )

/*++

Routine Description:

    The routines initializes the protocol module and
    does the minimal stuff, that must be done in the
    serialized initialization routine.

Arguments:

    None.

Return Value:

    NDIS_STATUS

--*/

{
    NDIS_STATUS Status;
	NDIS_PROTOCOL_CHARACTERISTICS LlcChars;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // We must build a MDL for the XID information used
    // when the link level takes care of XID handling.
    //

    pXidMdl = IoAllocateMdl(&Ieee802Xid,
                            sizeof(Ieee802Xid),
                            FALSE,
                            FALSE,
                            NULL
                            );
    if (pXidMdl == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

#ifdef NDIS40
    //
    // Event to signal all adapters have been bound - OK for LlcOpenAdapter
    // to bind.
    //

    NdisInitializeEvent(&PnPBindsComplete);
    NdisResetEvent(&PnPBindsComplete);
#endif // NDIS40

#if LLC_DBG

    ALLOCATE_SPIN_LOCK(&MemCheckLock);

#endif

    MmBuildMdlForNonPagedPool(pXidMdl);
    LlcInitializeTimerSystem();

    NdisZeroMemory(&LlcChars, sizeof(LlcChars));
	NdisInitUnicodeString(&LlcChars.Name, LLC_PROTOCOL_NAME);

#ifdef NDIS40
	LlcChars.MajorNdisVersion               = 4;
	LlcChars.MinorNdisVersion               = 0;
	LlcChars.OpenAdapterCompleteHandler     = LlcNdisOpenAdapterComplete;
	LlcChars.CloseAdapterCompleteHandler    = LlcNdisCloseComplete;
	LlcChars.SendCompleteHandler            = LlcNdisSendComplete;
	LlcChars.TransferDataCompleteHandler    = LlcNdisTransferDataComplete;
	LlcChars.ResetCompleteHandler           = LlcNdisResetComplete;
	LlcChars.RequestCompleteHandler         = LlcNdisRequestComplete;
	LlcChars.ReceiveHandler                 = LlcNdisReceiveIndication;
	LlcChars.ReceiveCompleteHandler         = LlcNdisReceiveComplete;
	LlcChars.StatusHandler                  = NdisStatusHandler;
	LlcChars.StatusCompleteHandler          = LlcNdisReceiveComplete;
    // DLC supports bind/unbind/pnp, but not unload.
    LlcChars.UnloadHandler                  = NULL;
    LlcChars.PnPEventHandler                = LlcPnPEventHandler;
    LlcChars.BindAdapterHandler             = LlcBindAdapterHandler;
    LlcChars.UnbindAdapterHandler           = LlcUnbindAdapterHandler;

    //
    // Need to get value for waiting on uninitialized adapters.
    //

    if (!NT_SUCCESS(GetAdapterWaitTimeout(&gWaitForAdapter)))
    {
        ASSERT(FALSE);
        gWaitForAdapter = 15; // Default.
    }

    DEBUGMSG(DBG_WARN, (TEXT("WaitForAdapter delay = %d sec\n"), gWaitForAdapter));
    
#else // NDIS40
	LlcChars.MajorNdisVersion = 3;
	LlcChars.MinorNdisVersion = 0;
	LlcChars.OpenAdapterCompleteHandler = LlcNdisOpenAdapterComplete;
	LlcChars.CloseAdapterCompleteHandler = LlcNdisCloseComplete;
	LlcChars.SendCompleteHandler = LlcNdisSendComplete;
	LlcChars.TransferDataCompleteHandler = LlcNdisTransferDataComplete;
	LlcChars.ResetCompleteHandler = LlcNdisResetComplete;
	LlcChars.RequestCompleteHandler = LlcNdisRequestComplete;
	LlcChars.ReceiveHandler = LlcNdisReceiveIndication;
	LlcChars.ReceiveCompleteHandler = LlcNdisReceiveComplete;
	LlcChars.StatusHandler = NdisStatusHandler;
	LlcChars.StatusCompleteHandler = LlcNdisReceiveComplete;
#endif // !NDIS40

	NdisRegisterProtocol(&Status,
                         &LlcProtocolHandle,
                         &LlcChars,
                         sizeof(LlcChars));

    KeInitializeSpinLock(&LlcSpinLock);

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeInitializeMutex(&NdisAccessMutex, 1);

    //
    // We use the OpenAdapterSemaphore in the LlcOpenAdapter function. We really
    // want a mutex, but a mutex causes us problems on a checked build if we
    // make a call into NTOS. In either case, we just need a mechanism to ensure
    // only one thread is creating the ADAPTER_CONTEXT & opening the adapter at
    // NDIS level
    //

    KeInitializeSemaphore(&OpenAdapterSemaphore, 1, 1);

    if (Status != STATUS_SUCCESS) {
        IoFreeMdl(pXidMdl);
    }
    return Status;
}


VOID
LlcTerminate(
    VOID
    )

/*++

Routine Description:

    The routines terminates the LLC protocol module and frees its global
    resources. This assumes all adapter bindings to be closed.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NDIS_STATUS Status;

    ASSUME_IRQL(PASSIVE_LEVEL);

    DEBUGMSG(DBG_INIT, (TEXT("+LlcTerminate()\n")));
    
    LlcTerminateTimerSystem();
#ifdef NDIS40
    CloseAllAdapters();
#endif // NDIS40
    NdisDeregisterProtocol(&Status, LlcProtocolHandle);
    IoFreeMdl(pXidMdl);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llcsmsb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcsmsb.c

Abstract:

    The module implements the subroutines used by a IEEE 802.2
    compatible state machine.

    To understand the procedure of this module, you should read
    Chapters 11 and 12 in IBM Token-Ring Architecture Reference.

    The procedures in this module can be called only when
    SendSpinLock is set.

    Contents:
        SaveStatusChangeEvent
        ResendPackets
        UpdateVa
        UpdateVaChkpt
        AdjustWw
        SendAck
        QueueCommandCompletion
        (DynamicWindowAlgorithm)

Author:

    Antti Saarenheimo (o-anttis) 23-MAY-1991

Revision History:

--*/

#include <llc.h>

//
// private prototypes
//

VOID
DynamicWindowAlgorithm(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    );


//
// functions
//

VOID
SaveStatusChangeEvent(
    IN PDATA_LINK pLink,
    IN PUCHAR puchLlcHdr,
    IN BOOLEAN boolResponse
    )

/*++

Routine Description:

    Procedure saves Status Change event of the link to the event queue.
    to be indicated later to upper protocol.

Arguments:

    pLink - LLC link station object

    puchLlcHdr - the received LLC header

    boolResponse - flag set if the received frame was response

Return Value:

    None

--*/

{
    UINT Event;
    PEVENT_PACKET pEvent;
    PVOID hClientHandle;
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Set the ethernet header length (== type) the same as
    // in the current receive frame, that was either the first SABME or
    // any response to it, that opened the link connection.
    //

    if ((pLink->DlcStatus.StatusCode & (CONFIRM_CONNECT | LLC_INDICATE_CONNECT_REQUEST))
    && pAdapterContext->RcvLanHeaderLength != pLink->cbLanHeaderLength
    && pLink->Gen.pLlcBinding->EthernetType == LLC_ETHERNET_TYPE_AUTO) {
        pLink->cbLanHeaderLength = (UCHAR)pLink->Gen.pAdapterContext->RcvLanHeaderLength;
    }

    //
    // Handle first the disconnect/connect complete
    //

    if (pLink->DlcStatus.StatusCode & (CONFIRM_CONNECT | CONFIRM_DISCONNECT | CONFIRM_CONNECT_FAILED)) {

        //
        // We cannot indicate any events to non-existing stations
        //

        if (pLink->Gen.hClientHandle != NULL) {
            if (pLink->DlcStatus.StatusCode & CONFIRM_DISCONNECT) {
                 QueueCommandCompletion((PLLC_OBJECT)pLink,
                                        LLC_DISCONNECT_COMPLETION,
                                        STATUS_SUCCESS
                                        );
            }
            if (pLink->DlcStatus.StatusCode & (CONFIRM_CONNECT | CONFIRM_CONNECT_FAILED)) {

                UINT Status;

                if (pLink->DlcStatus.StatusCode & CONFIRM_CONNECT) {

                    //
                    // Set the T1 timeout for the first checkpointing state.
                    // This value will be changed when we have got the response
                    // to the first poll, but the initial value is big to
                    // be able to run DLC over a WAN connection
                    //

                    pLink->AverageResponseTime = 100;  // 100 * 40 = 4 seconds
                    pLink->Flags |= DLC_FIRST_POLL;
                    InitializeLinkTimers(pLink);
                    Status = STATUS_SUCCESS;
                } else {
                    Status = DLC_STATUS_CONNECT_FAILED;
                }
                QueueCommandCompletion((PLLC_OBJECT)pLink,
                                        LLC_CONNECT_COMPLETION,
                                        Status
                                        );
            }
        }
        pLink->DlcStatus.StatusCode &= ~(CONFIRM_CONNECT | CONFIRM_DISCONNECT | CONFIRM_CONNECT_FAILED);
    }

    if (pLink->DlcStatus.StatusCode != 0) {
        if (pLink->DlcStatus.StatusCode & INDICATE_FRMR_SENT) {

#if LLC_DBG
            PrintLastInputs("FRMR SENT!\n", pLink);
#endif

            pLink->DlcStatus.FrmrData.Command = puchLlcHdr[2];
            pLink->DlcStatus.FrmrData.Ctrl = puchLlcHdr[3];
            if ((pLink->DlcStatus.FrmrData.Command & LLC_S_U_TYPE_MASK) == LLC_U_TYPE) {
                pLink->DlcStatus.FrmrData.Ctrl = 0;
            }
            pLink->DlcStatus.FrmrData.Vs = pLink->Vs;
            pLink->DlcStatus.FrmrData.Vr = pLink->Vr | boolResponse;
        } else if (pLink->DlcStatus.StatusCode & INDICATE_FRMR_RECEIVED) {

#if LLC_DBG
            PrintLastInputs("FRMR RECEIVED!\n", pLink);
            DbgBreakPoint();
#endif

            LlcMemCpy(&pLink->DlcStatus.FrmrData,
                      &puchLlcHdr[3],
                      sizeof(LLC_FRMR_INFORMATION)
                      );
        }

        //
        // A remote connect request may have created a link station
        // in link driver.  The upper protocol must be able to separate
        // sap handle from the data link
        //

        if (pLink->Gen.hClientHandle == NULL) {

            //
            // Indicate the event on the sap, because the upper protocol
            // has not yet any link station create for this link, because
            // it has been created remotely.
            //

            hClientHandle = pLink->pSap->Gen.hClientHandle,
            Event = LLC_STATUS_CHANGE_ON_SAP;
        } else {

            //
            // Indicate the event on the link station
            //

            hClientHandle = pLink->Gen.hClientHandle,
            Event = LLC_STATUS_CHANGE;
        }

        //
        // The indications of the received SABMEs must be queued,
        // but all other events are indicated directy to
        // the upper protocol, because those indications must never
        // be lost because of an out of memory condition.
        //

        if (pLink->DlcStatus.StatusCode & INDICATE_CONNECT_REQUEST) {

            pEvent = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

            if (pEvent != NULL) {
                LlcInsertTailList(&pAdapterContext->QueueEvents, pEvent);
                pEvent->pBinding = pLink->Gen.pLlcBinding;
                pEvent->hClientHandle = hClientHandle;
                pEvent->Event = Event;
                pEvent->pEventInformation = (PVOID)&pLink->DlcStatus;

                //
                // RLF 11/18/92
                //
                // INDICATE_CONNECT_REQUEST is generated when we receive a
                // SABME for a station in the DISCONNECTED state. However,
                // we need to generate either INDICATE_CONNECT_REQUEST (0x0400)
                // or INDICATE_RESET (0x0800) depending on whether the SABME
                // created the link station or whether it was created by a
                // DLC.OPEN.STATION at this end. pLink->RemoteOpen is TRUE if
                // the link was created due to receipt of the SABME
                // This routine is only called by RunStateMachine and
                // INDICATE_CONNECT_REQUEST is never combined with any other
                // status codes
                //

                //pEvent->SecondaryInfo = pLink->DlcStatus.StatusCode;
                pEvent->SecondaryInfo = pLink->RemoteOpen
                                            ? INDICATE_CONNECT_REQUEST
                                            : INDICATE_RESET;
            }
        } else {

            //
            // We must do this with a locked SendSpinLock, because
            // otherwise somebody might delete the link, while
            // we are still using it.
            // THIS IS ACTAULLY QUITE DIRTY (callback with locked
            // spinlocks), BUT WE CANNOT USE THE PACKET POOLS WHEN
            // WE INDICATE AN EVENT, THAT MUST NOT BE LOST!
            //

            pLink->Gen.pLlcBinding->pfEventIndication(
                pLink->Gen.pLlcBinding->hClientContext,
                hClientHandle,
                Event,
                (PVOID)&pLink->DlcStatus,
                pLink->DlcStatus.StatusCode
                );
        }

        //
        // We must cancel all queued transmit commands, if the link
        // is lost, disconnected or reset.
        //

        if (pLink->DlcStatus.StatusCode
            & (INDICATE_LINK_LOST
            | INDICATE_DM_DISC_RECEIVED
            | INDICATE_FRMR_RECEIVED
            | INDICATE_FRMR_SENT
            | INDICATE_RESET)) {

            CancelTransmitCommands((PLLC_OBJECT)pLink, DLC_STATUS_LINK_NOT_TRANSMITTING);
        }

        //
        // Reset the status code!
        //

        pLink->DlcStatus.StatusCode = 0;
    }
}


VOID
ResendPackets(
    IN OUT PDATA_LINK pLink     // data link strcuture
    )

/*++

Routine Description:

    Function initializes the send process to resend the rejected
    packets and resets the adaptive working window variables.
    The operations defined in IBM state machine are:
    Vs=Nr, Ww=1, Ia_Ct=0, but this also resorts the packet queue.


Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;


    //
    // Complete all frames, that were acknowledged by the reject (if any)
    //

    if (pLink->Nr != pLink->Va) {
        DynamicWindowAlgorithm(pLink);
    }

    if ( (pLink->Vs != pLink->VsMax) &&
         (((pLink->Vs < pLink->VsMax) && (pLink->Nr >= pLink->Vs) && 
           (pLink->Nr <= pLink->VsMax)
          ) ||
          (!((pLink->Vs > pLink->VsMax) && (pLink->Nr > pLink->VsMax) &&
            (pLink->Nr < pLink->Vs))
          )
         )
       )
    {
        return;
    }

    //
    // Move all rejected packets from the queue sent packets back
    // to the send queue.  We have already completed all acknowledged
    // packets => we can take the packet from the tail and put them
    // to the head of the send queue.
    // We can trust, that the reject window is correct, because
    // Nr has been checked before the state machine was called.
    // (note: the counters are a modulo 256, but we use bytes).
    //

    for (;pLink->Vs != pLink->Nr; pLink->Vs -= 2) {

        PLLC_PACKET pPacket;

        if (!IsListEmpty(&pLink->SentQueue) ){

            pLink->Statistics.I_FrameTransmissionErrors++;
            if (pLink->Statistics.I_FrameTransmissionErrors == 0x80) {
                pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
            }

            pPacket = (PLLC_PACKET)LlcRemoveTailList(&pLink->SentQueue);

            LlcInsertHeadList(&pLink->SendQueue.ListHead, pPacket);

        }
    }

    //
    // The procedure starts the send process only if it has been
    // enabled by the state machine. Only StartSendProcessLocked
    // may start the process, if it has been locked by
    // StopSendProcess
    //

    StartSendProcess(pAdapterContext, pLink);

    //
    // Reset the current window (Vs=Nr, Ww=1, Ia_Ct=0)
    //

    pLink->Ww = 2;
    pLink->Ia_Ct = 0;
}


VOID
UpdateVa(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    )

/*++

Routine Description:

   Function updates Va (last valid Nr received) and
   makes also some other actions needed in the normal
   receive operations.

Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    //
    // Reset the initilization state variable
    //

    pLink->Vi = 0;

    //
    // Update the receive state variable Va (the last valid received
    // frame), but update some Ww variables before that.
    //

    if (pLink->Nr != pLink->Va) {
        DynamicWindowAlgorithm(pLink);

        //
        // T1 reply timer must be running as far as there are
        // out (or sent) any unacknowledged frames.
        // Ti timer must be stopped whenever T1 is running and vice versa
        //

        if (pLink->Nr != pLink->Vs) {

            //
            // There still are some unacknowledged frames,
            // start or restart the reply timer.
            //

            StartTimer(&pLink->T1);     // reply timer
            StopTimer(&pLink->Ti);
        } else {

            //
            // All sent frames have been acknowledged,
            // => We may stop the reply timer.
            //

            StopTimer(&pLink->T1);     // reply timer
            StartTimer(&pLink->Ti);
        }

        //
        // Reset the I- frame retry counter whenever we do
        // any kind of progress
        //

        pLink->Is_Ct = pLink->N2;
    }
}


VOID
UpdateVaChkpt(
    IN OUT PDATA_LINK pLink     // data link station strcuture
    )

/*++

Routine Description:

   Function updates Va (last valid Nr received) and
   makes also some other actions needed in the check
   point receive operations.

Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    UCHAR OrginalWw = pLink->Ww;

    //
    // Reset the initilization state variable
    //

    pLink->Vi = 0;

    //
    // Update the receive state variable Va (the last valid received
    // frame), but update the acknowledged frames counter before that.
    // That counter is used by the Adaptive window algorithm.
    //

    if (pLink->Nr != pLink->Va) {

        //
        // Run adaptive transmit window (TW/T1) algorithm.
        //

        if (pLink->Ww == pLink->TW) {

            //
            // Update the counters of adaptive transmit window algorithm,
            // We need (LLC_MAX_T1_TO_I_RATIO/2) successful transmit using
            // the full window size, before we again try increase the
            // maximum transmit window size.
            //

            pLink->FullWindowTransmits += pLink->Ww;
            if ((UINT)pLink->FullWindowTransmits >= LLC_MAX_T1_TO_I_RATIO) {
                pLink->FullWindowTransmits = 2;
                if (pLink->TW < pLink->MaxOut) {
                    pLink->TW += 2;
                }
            }
        }
        DynamicWindowAlgorithm(pLink);

        //
        // Reset the I- frame and Poll retry counters whenever
        // we do any kind of progress with the acknowledged I-frames.
        //

        pLink->P_Ct = pLink->N2;
        pLink->Is_Ct = pLink->N2;
    }

    //
    // Stop the reply timer, if we are not waiting
    // anything else from the other side.
    //

    if (pLink->Nr != pLink->Vs) {

        //
        // There still are some unacknowledged frames,
        // start or restart the reply timer.
        //

        StartTimer(&pLink->T1);     // reply timer
        StopTimer(&pLink->Ti);
    } else {

        //
        // All sent frames have been acknowledged,
        // => We may stop the reply timer.
        //

        StopTimer(&pLink->T1);     // reply timer
        StartTimer(&pLink->Ti);
    }

    //
    // Bugfix in 3-3-1992, Vp (!= pLInk->Vp) seems to be wrong here,
    // because in many cases it is not set when a checkpointing state is
    // entered.  In the chekpointing state Vs=Vp, because the
    // send process is always stopped in our implementation,
    // when a checkpointing state is entered.
    // Why do we actually need the Vp? A: It's needed to prevent
    // forever looping between chekpointing and open states.
    //

    if (pLink->Nr != pLink->Vs) {

        //
        // We use a very simple adaptive transmit window (TW/T1) algorithm:
        //
        //     TW is set the same as the last successful Working window
        //     size (Ww), whenever T1 has been lost.  We increase TW after
        //     a constant number of full window transmits.
        //
        // The more complicated TW/T1 algorithms usually work worse
        // produce more code and decrease the performace, but this algorithm
        // is quite vulnerable to unreliable media (=> TW=1, a lot of T1
        // timeouts).  A better algorithm could also try to increase TW,
        // if the ratio of T1 timeouts to transferred I- frames increases
        // when the TW is decreased.  I will leave this matter to my
        // successors (AS 19-MAR-1992).
        //
        // Another problem in this algorithm is the too fast increasing
        // of big working windows (Ww).  In that case Ww is incremented by
        // more than 1 => the other side may lose I-frames before I-c1.
        // This is not very serious situation, we reset working window to 1
        // and start it again.
        //

        //
        // Update the transmit window always after a T1 timeout.
        //

        if (pLink->P_Ct < pLink->N2) {

            //
            // Reset the maximum transmit window size whenever
            // we have lost the last I-C1 (poll).
            // In the first time the current windows size
            // becomes the maximum windows size (we never hit
            // the maximum tranmit window size, if the other
            // size have receive problems).  This algorithm assumes,
            // that we have otherwise very reliable network.
            //

            if (OrginalWw > 2) {
                pLink->TW = (UCHAR)(OrginalWw - 2);
            } else if (pLink->TW > 2) {

                //
                // We may have already reset Ww because of REJ of a
                // I-c0 before the actual poll, that was lost also.
                // In that case we don't have any idea of the actual
                // window size, but we decrement TW in any case.
                //

                pLink->TW -= 2;
            }
            pLink->FullWindowTransmits = 2;
        }
        ResendPackets(pLink);
    }
}


VOID
AdjustWw(
    IN OUT PDATA_LINK pLink    // data link strcuture
    )

/*++

Routine Description:

    Procedure adjust the working window of a data link station.

Arguments:

    pLink - LLC link station object

    Nr - NR of the received LLC LDPU

Return Value:

    None

--*/

{
    //
    // Update the receive state variable Va (the last valid received
    // frame), but update some Ww variables before that.
    //

    if (pLink->Nr != pLink->Va) {
        DynamicWindowAlgorithm(pLink);

        //
        // Reset the I- frame and Poll retry counters whenever
        // we do any kind of progress with the acknowledged I-frames.
        //

        pLink->P_Ct = pLink->N2;
        pLink->Is_Ct = pLink->N2;
    }
}


VOID
SendAck(
    IN OUT PDATA_LINK pLink
    )

/*++

Routine Description:

    Procedure sends the ack, if the received unacknowledged frames
    counter expires and stops the acknowledge delay timer (T2).
    Otherwise it start (or restarts) the acknowledge delay timer.

Arguments:

    pLink - LLC link station object

Return Value:

    Returns the token of the next sent command frame.

--*/

{
    pLink->Ir_Ct--;
    if (pLink->Ir_Ct == 0) {
        pLink->Ir_Ct = pLink->N3;      // MaxIn
        StopTimer(&pLink->T2);

        //
        // Send RR-r0 to acknowledge the response
        //

        SendLlcFrame(pLink, (UCHAR)DLC_RR_TOKEN);
    } else {
        StartTimer(&pLink->T2);
    }
}


VOID
QueueCommandCompletion(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN UINT Status
    )

/*++

Routine Description:

    The function queues a command completion (if there was an allcoated
    packet in the completion queue).

Arguments:

    pLlcObject      - LLC object (link, sap or direct)
    CompletionCode  - command completion code returned to upper protocol
    Status          - returned status

Return Value:

    None -

--*/

{
    PLLC_PACKET *ppPacket;

    //
    // Search the command from the completion list.
    // (use the "address of address" scanning to take the
    // searched element from the middle of one way linked list)
    //

    ppPacket = &pLlcObject->Gen.pCompletionPackets;
    while (*ppPacket != NULL
    && (*ppPacket)->Data.Completion.CompletedCommand != CompletionCode) {
        ppPacket = &(*ppPacket)->pNext;
    }
    if (*ppPacket != NULL) {

        PLLC_PACKET pPacket = *ppPacket;

        *ppPacket = pPacket->pNext;

        pPacket->pBinding = pLlcObject->Gen.pLlcBinding;
        pPacket->Data.Completion.Status = Status;
        pPacket->Data.Completion.CompletedCommand = CompletionCode;
        pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle;

#if LLC_DBG
        pPacket->pNext = NULL;
#endif
        LlcInsertTailList(&pLlcObject->Gen.pAdapterContext->QueueCommands, pPacket);
    }
}


VOID
DynamicWindowAlgorithm(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    )

/*++

Routine Description:

   The function runs the dynamic window algorithm and updates
   the dynamic window size of used by the link's send process.
   This routine also completes the acknowledged transmissions.

Arguments:

    pLink - LLC link station object

Return Value:

    None

--*/

{
    PADAPTER_CONTEXT pAdapterContext;

    //
    // Run Dynamic Window algorithm of IBM TR Architecture Ref:
    //
    // if (Working window less that the maximum window)
    // then
    //     The Acknowledged frame count += The acknowledged frames
    //
    //     if (The Acknowledged frame count >
    //         packets to be aknowledged before next increment)
    //     then
    //         Increment the working window
    //     endif
    // endif
    //

    if (pLink->Ww < pLink->TW) {

        //
        // The Acknowledged frame count += The acknowledged frames
        // (handle the wrap around of UCHAR counters)
        //

        if (pLink->Va > pLink->Nr) {
            pLink->Ia_Ct += (256 + pLink->Nr) - pLink->Va;
        } else {
            pLink->Ia_Ct += pLink->Nr - pLink->Va;
        }

        //
        // if (The Acknowledged frame count
        //     > packets to be aknowledged before next increment)
        // then
        //     Increment the working window
        // endif
        //

        if (pLink->Ia_Ct > pLink->Nw) {

            USHORT usWw;

            usWw = (USHORT)(pLink->Ww + (pLink->Ia_Ct / pLink->Nw) * 2);
            pLink->Ia_Ct = pLink->Ia_Ct % pLink->Nw;
            if (usWw > pLink->TW) {
                pLink->Ww = pLink->TW;
            } else {
                pLink->Ww = (UCHAR)usWw;
            }
        }
    }

    //
    // Complete all acknowledged I-frame packets
    //

    pAdapterContext = pLink->Gen.pAdapterContext;
    for (; pLink->Va != pLink->Nr; pLink->Va += 2) {

        PLLC_PACKET pPacket;

        MY_ASSERT(!IsListEmpty(&pLink->SentQueue));

        if (IsListEmpty(&pLink->SentQueue)) {
           return;
        }

        pPacket = LlcRemoveHeadList(&pLink->SentQueue);

        pPacket->Data.Completion.Status = STATUS_SUCCESS;
        pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
        pPacket->Data.Completion.hClientHandle = pPacket->Data.Xmit.pLlcObject->Gen.hClientHandle;

        //
        // We use extra status bits to indicate, when I- packet has been both
        // completed by NDIS and acknowledged by the other side of the link
        // connection. An I- packet can be queued to the completion queue by
        // the second quy (either state machine or SendCompletion handler)
        // only when the first guy has set completed its work.
        // An I packet could be acknowledged by the other side before
        // its completion is indicated by NDIS.  Dlc Driver deallocates
        // the packet immediately, when Llc driver completes the acknowledged
        // packet => possible data corruption (if packet is reused before
        // NDIS has completed it).  This is probably not possible in a
        // single processor  NT- system, but very possible in multiprocessor
        // NT or systems without a single level DPC queue (like OS/2 and DOS).
        //

        pPacket->CompletionType &= ~LLC_I_PACKET_UNACKNOWLEDGED;
        if (pPacket->CompletionType == LLC_I_PACKET_COMPLETE) {
            LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
        }

        //
        // Increment counter, when the I- frame has
        // succesfully received and acknowledged by the other side.
        // We must also send status changes indication, when
        // the USHORT counter hits the half way.
        //

        pLink->Statistics.I_FramesTransmitted++;
        if (pLink->Statistics.I_FramesTransmitted == 0x8000) {
            pLink->DlcStatus.StatusCode |= INDICATE_DLC_COUNTER_OVERFLOW;
        }
        pLink->pSap->Statistics.FramesTransmitted++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llctimr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    llctimr.c

Abstract:

    This module contains code that implements a lightweight timer system
    for the data link driver.

    This module gets control once in 40 ms when a DPC timer expires.
    The routine scans the device context's link database, looking for timers
    that have expired, and for those that have expired, their expiration
    routines are executed.

    This is how timers work in DLC:

        Each adapter has a singly-linked list of timer ticks (terminated by NULL).
        A tick just specifies work to be done at a certain time in the future.
        Ticks are ordered by increasing time (multiples of 40 mSec). The work
        list that has to be performed when a tick comes due is described by a
        doubly-linked list of timers (LLC_TIMER) that the tick structure points
        at through the pFront field. For each timer added to a tick's list, the
        tick reference count is incremented; it is decremented when a timer is
        removed. When the reference count is decremented to zero, the timer
        tick is unlinked and deallocated

        Every 40 mSec a kernel timer fires and executes our DPC routine
        (ScanTimersDpc). This grabs the requisite spinlocks and searches through
        all timer ticks on all adapter context structures looking for work to
        do

    Pictorially:

              +---------+ --> other adapter contexts
     +--------| Adapter |
     |        +---------+
     |
     +-> +------+---> +------+---> 0 (end of singly-linked list)
         | Tick |     | Tick |
         |      |     |      |
         +------+     +------+
            | ^
            | +------------+-------------+
            v |            |             |
    +--> +-------+---> +-------+---> +-------+-----+
    | +--| Timer | <---| Timer | <---| Timer | <-+ |
    | |  +-------+     +-------+     +-------+   | |
    | |                                          | |
    | +------------------------------------------+ |
    +----------------------------------------------+

    The procedures in this module can be called only when SendSpinLock is set.

    Contents:
        ScanTimersDpc
        LlcInitializeTimerSystem
        LlcTerminateTimerSystem
        TerminateTimer
        InitializeLinkTimers
        InitializeTimer
        StartTimer
        StopTimer

Author:

    Antti Saarenheimo (o-anttis) 30-MAY-1991

Environment:

    Kernel mode

Revision History:

    28-Apr-1994 rfirth

        * Changed to use single driver-level spinlock

        * Added useful picture & description above to aid any other poor saps -
          er - programmers - who get tricked into - er - who are lucky enough
          to work on DLC

--*/

#include <llc.h>

//
// DLC timer tick is 40 ms !!!
//

#define TIMER_DELTA 400000L

//
// global data
//

ULONG AbsoluteTime = 0;
BOOLEAN DlcIsTerminating = FALSE;
BOOLEAN DlcTerminated = FALSE;

//
// private data
//

static LARGE_INTEGER DueTime = { (ULONG) -TIMER_DELTA, (ULONG) -1 };
static KTIMER SystemTimer;
static KDPC TimerSystemDpc;


VOID
ScanTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at regular
    intervals to determine if any link-level timers have expired, and
    if they have, to execute their expiration routines.

Arguments:

    Dpc             - Ignored
    DeferredContext - Ignored
    SystemArgument1 - Ignored
    SystemArgument2 - Ignored

Return Value:

    None.

--*/

{
    PLLC_TIMER pTimer;
    PADAPTER_CONTEXT pAdapterContext;
    PLLC_TIMER pNextTimer;
    PTIMER_TICK pTick;
    PTIMER_TICK pNextTick;
    BOOLEAN boolRunBackgroundProcess;
    KIRQL irql;

    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    ASSUME_IRQL(DISPATCH_LEVEL);

    AbsoluteTime++;

    //
    // The global spinlock keeps the adapters alive over this
    //

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

    //
    // scan timer queues for all adapters
    //

    for (pAdapterContext = pAdapters; pAdapterContext; pAdapterContext = pAdapterContext->pNext) {

        boolRunBackgroundProcess = FALSE;

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        //
        // The timer ticks are protected by a reference counter
        //

        for (pTick = pAdapterContext->pTimerTicks; pTick; pTick = pNextTick) {

            if (pTick->pFront) {

                //
                // This keeps the tick alive, we cannot use spin lock,
                // because the timers are called and deleted within
                // SendSpinLock.  (=> deadlock)
                //

                pTick->ReferenceCount++;

                //
                // Send spin lock prevents anybody to remove a timer
                // when we are processing it.
                //

                for (pTimer = pTick->pFront;
                     pTimer && pTimer->ExpirationTime <= AbsoluteTime;
                     pTimer = pNextTimer) {

                    if ( (pNextTimer = pTimer->pNext) == pTick->pFront) {
                        pNextTimer = NULL;
                    }

                    //
                    // DLC driver needs a timer tick every 0.5 second to
                    // implement timer services defined by the API
                    //

                    if (pTick->Input == LLC_TIMER_TICK_EVENT) {

                        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                        ((PBINDING_CONTEXT)pTimer->hContext)->pfEventIndication(
                            ((PBINDING_CONTEXT)pTimer->hContext)->hClientContext,
                            NULL,
                            LLC_TIMER_TICK_EVENT,
                            NULL,
                            0
                            );

                        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                        StartTimer(pTimer);

                    } else {
                        StopTimer(pTimer);
                        RunStateMachineCommand(
                            pTimer->hContext,
                            pTick->Input
                            );
                        boolRunBackgroundProcess = TRUE;
                    }
                }

                pNextTick = pTick->pNext;

                //
                // Delete the timer tick, if there are no references to it.
                //

                if ((--pTick->ReferenceCount) == 0) {

                    //
                    // The timers are in a single entry list!
                    //

                    RemoveFromLinkList((PVOID*)&pAdapterContext->pTimerTicks, pTick);

                    FREE_MEMORY_ADAPTER(pTick);
                }
            } else {
                pNextTick = pTick->pNext;
            }
        }

        if (boolRunBackgroundProcess) {
            BackgroundProcessAndUnlock(pAdapterContext);
        } else {
            RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
        }
    }

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();

    //
    // Start up the timer again.  Note that because we start the timer
    // after doing work (above), the timer values will slip somewhat,
    // depending on the load on the protocol.  This is entirely acceptable
    // and will prevent us from using the timer DPC in two different
    // threads of execution.
    //

    if (!DlcIsTerminating) {

        ASSUME_IRQL(ANY_IRQL);

        KeSetTimer(&SystemTimer, DueTime, &TimerSystemDpc);
    } else {
        DlcTerminated = TRUE;
    }
}


VOID
LlcInitializeTimerSystem(
    VOID
    )

/*++

Routine Description:

    This routine initializes the lightweight timer system for the
    data link driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    KeInitializeDpc(&TimerSystemDpc, ScanTimersDpc, NULL);
    KeInitializeTimer(&SystemTimer);
    KeSetTimer(&SystemTimer, DueTime, &TimerSystemDpc);
}


VOID
LlcTerminateTimerSystem(
    VOID
    )

/*++

Routine Description:

    This routine terminates the timer system of the data link driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    DlcIsTerminating = TRUE;

    //
    // if KeCancelTimer returns FALSE then the timer was not set. Assume the DPC
    // is either waiting to be scheduled or is already in progress
    //

    if (!KeCancelTimer(&SystemTimer)) {

        //
        // if timer is not set, wait for DPC to complete
        //

        while (!DlcTerminated) {

            //
            // wait 40 milliseconds - period of DLC's tick
            //

            LlcSleep(40000);
        }
    }
}


BOOLEAN
TerminateTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_TIMER pTimer
    )

/*++

Routine Description:

    Terminate a timer tick by stopping pTimer (remove it from the tick's active
    timer list). If pTimer was the last timer on the tick's list then unlink and
    deallocate the timer tick.

    This routine assumes that if a timer (LLC_TIMER) has a non-NULL pointer to
    a tick (TIMER_TICK) then the timer tick owns the timer (i.e. the timer is
    started) and this ownership is reflected in the reference count. Even if a
    timer is stopped, if its pointer to the timer tick 'object' is valid then
    the timer tick still owns the timer

Arguments:

    pAdapterContext - adapter context which owns ticks/timers
    pTimer          - timer tick object of a link station

Return Value:

    None

--*/

{
    BOOLEAN timerActive;
    PTIMER_TICK pTick;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Timer may not always be initialized, when this is called
    // from the cleanup processing of a failed OpenAdapter call.
    //

    if (!pTimer->pTimerTick) {
        return FALSE;
    }

    pTick = pTimer->pTimerTick;
    timerActive = StopTimer(pTimer);

    //
    // if that was the last timer on the list for this tick then remove the
    // tick from the list and deallocate it
    //

    if (!--pTick->ReferenceCount) {

        RemoveFromLinkList((PVOID*)&pAdapterContext->pTimerTicks, pTick);

        FREE_MEMORY_ADAPTER(pTick);

    }
    return timerActive;
}


DLC_STATUS
InitializeLinkTimers(
    IN OUT PDATA_LINK pLink
    )

/*++

Routine Description:

    This routine initializes a timer tick objects of a link station.

Arguments:

    pAdapterContext - the device context
    pLink           - the link context

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                    out of system memory

--*/

{
    DLC_STATUS LlcStatus;

    PADAPTER_CONTEXT pAdapterContext = pLink->Gen.pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    LlcStatus = InitializeTimer(pAdapterContext,
                                &pLink->T1,
                                pLink->TimerT1,
                                pAdapterContext->ConfigInfo.TimerTicks.T1TickOne,
                                pAdapterContext->ConfigInfo.TimerTicks.T1TickTwo,
                                T1_Expired,
                                pLink,
                                pLink->AverageResponseTime,
                                FALSE
                                );
    if (LlcStatus != STATUS_SUCCESS) {
        return LlcStatus;
    }

    LlcStatus = InitializeTimer(pAdapterContext,
                                &pLink->T2,
                                pLink->TimerT2,
                                pAdapterContext->ConfigInfo.TimerTicks.T2TickOne,
                                pAdapterContext->ConfigInfo.TimerTicks.T2TickTwo,
                                T2_Expired,
                                pLink,
                                0,  // T2 is not based on the response time
                                FALSE
                                );
    if (LlcStatus != STATUS_SUCCESS) {
        return LlcStatus;
    }

    LlcStatus = InitializeTimer(pAdapterContext,
                                &pLink->Ti,
                                pLink->TimerTi,
                                pAdapterContext->ConfigInfo.TimerTicks.TiTickOne,
                                pAdapterContext->ConfigInfo.TimerTicks.TiTickTwo,
                                Ti_Expired,
                                pLink,
                                pLink->AverageResponseTime,
                                TRUE
                                );
    return LlcStatus;
}


DLC_STATUS
InitializeTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN OUT PLLC_TIMER pTimer,
    IN UCHAR TickCount,
    IN UCHAR TickOne,
    IN UCHAR TickTwo,
    IN UINT Input,
    IN PVOID hContextHandle,
    IN UINT ResponseDelay,
    IN BOOLEAN StartNewTimer
    )

/*++

Routine Description:

    This routine initializes a timer tick objects of a link station.

Arguments:

    pTimer          - timer tick object of a link station
    TickCount       - DLC ticks, see DLC documentation (or code)
    TickOne         - see DLC documentation
    TickTwo         - see DLC documentation
    Input           - the used state machine input, when the timer expires
    hContextHandle  - context handle when the state machine is called
    StartNewTimer   - set if the timer must be started when it is initialized
                      for the first time. Subsequent times, the timer keeps its
                      old state
    ResponseDelay   - an optional base value that is added to the timer value

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                    out of system memory

--*/

{
    UINT DeltaTime;
    PTIMER_TICK pTick;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // All times are multiples of 40 milliseconds
    // (I am not sure how portable is this design)
    // See LAN Manager Network Device Driver Guide
    // ('Remoteboot protocol') for further details
    // about TickOne and TickTwo
    // We have already checked, that the
    // timer tick count is less than 11.
    //

    DeltaTime = (TickCount > 5 ? (UINT)(TickCount - 5) * (UINT)TickTwo
                               : (UINT)TickCount * (UINT)TickOne);

    //
    // We discard the low bits in the reponse delay.
    //

    DeltaTime += (ResponseDelay & 0xfff0);

    //
    // Return immediately, if the old value is the
    // same as the new one (T2 link station is reinitialized
    // unnecessary, when the T1 and Ti timers are retuned
    // for changed response time.
    //

    if (pTimer->pTimerTick && (pTimer->pTimerTick->DeltaTime == DeltaTime)) {
        return STATUS_SUCCESS;
    }

    //
    // Try to find a timer tick object having the same delta time and input
    //

    for (pTick = pAdapterContext->pTimerTicks; pTick; pTick = pTick->pNext) {
        if ((pTick->DeltaTime == DeltaTime) && (pTick->Input == (USHORT)Input)) {
            break;
        }
    }
    if (!pTick) {
        pTick = ALLOCATE_ZEROMEMORY_ADAPTER(sizeof(TIMER_TICK));
        if (!pTick) {
            return DLC_STATUS_NO_MEMORY;
        }
        pTick->DeltaTime = DeltaTime;
        pTick->Input = (USHORT)Input;
        pTick->pNext = pAdapterContext->pTimerTicks;
        pAdapterContext->pTimerTicks = pTick;
    }
    pTick->ReferenceCount++;

    //
    // We must delete the previous timer reference
    // when we know if the memory allocation operation
    // was successfull or not. Otherwise the setting of
    // the link parameters might delete old timer tick,
    // but it would not be able to allocate the new one.
    // The link must be protected, when this routine is called.
    //

    if (pTimer->pTimerTick) {
        StartNewTimer = TerminateTimer(pAdapterContext, pTimer);
    }
    pTimer->pTimerTick = pTick;
    pTimer->hContext = hContextHandle;

    if (StartNewTimer) {
        StartTimer(pTimer);
    }
    return STATUS_SUCCESS;
}


VOID
StartTimer(
    IN OUT PLLC_TIMER pTimer
    )

/*++

Routine Description:

    This starts the given timer within spin locks

Arguments:

    pTimer  - timer tick object of a link station

Return Value:

    None.

--*/

{
    PLLC_TIMER pFront;
    PTIMER_TICK pTimerTick = pTimer->pTimerTick;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We always reset the pNext pointer, when a item is
    // removed from a link list => the timer element cannot be
    // in the link list of a timer tick object if its next pointer is null
    //

    if (pTimer->pNext) {

        //
        // We don't need to change the timer's position, if the new timer
        // would be the same as the old time.
        //

        if (pTimer->ExpirationTime != AbsoluteTime + pTimerTick->DeltaTime) {

            //
            // The timer has already been started, move it to the top of
            // the link list.
            //

            if (pTimer != (pFront = pTimerTick->pFront)) {
                pTimer->pPrev->pNext = pTimer->pNext;
                pTimer->pNext->pPrev = pTimer->pPrev;
                pTimer->pNext = pFront;
                pTimer->pPrev = pFront->pPrev;
                pFront->pPrev->pNext = pTimer;
                pFront->pPrev = pTimer;
            }
        }
    } else {
        if (!(pFront = pTimerTick->pFront)) {
            pTimerTick->pFront = pTimer->pNext = pTimer->pPrev = pTimer;
        } else {
            pTimer->pNext = pFront;
            pTimer->pPrev = pFront->pPrev;
            pFront->pPrev->pNext = pTimer;
            pFront->pPrev = pTimer;
        }
    }
    pTimer->ExpirationTime = AbsoluteTime + pTimerTick->DeltaTime;
}


BOOLEAN
StopTimer(
    IN PLLC_TIMER pTimer
    )

/*++

Routine Description:

    This stops the given timer within spin locks

Arguments:

    pTimer  - timer tick object of a link station

Return Value:

    BOOLEAN
        TRUE    - timer was running
        FALSE   - timer was not running

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pTimer->pNext) {

        PTIMER_TICK pTimerTick = pTimer->pTimerTick;

        //
        // if the timer points to itself then its the only thing on the list:
        // zap the link in the timer tick structure (no more timers for this
        // tick) and zap the next field in the timer structure to indicate
        // the timer has been removed from the tick list. If the timer points
        // to another timer, then remove this timer from the doubly-linked list
        // of timers
        //

        if (pTimer != pTimer->pNext) {
            if (pTimer == pTimerTick->pFront) {
                pTimerTick->pFront = pTimer->pNext;
            }
            pTimer->pPrev->pNext = pTimer->pNext;
            pTimer->pNext->pPrev = pTimer->pPrev;
            pTimer->pNext = NULL;
        } else {
            pTimerTick->pFront = pTimer->pNext = NULL;
        }
        return TRUE;
    } else {

        //
        // this timer was not on a timer tick list
        //

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llctrace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  ICL Data

Module Name:

    llctrace.c

Abstract:

    Module implements simple trace buffer management.
    The application must povides a trace buffer and
    read it by polling.
    
    THIS MODULE HAS BEEN IMPLEMENTED ONLY FOR THE DATA LINK 
    EMULATION ENVIRONMENT ON USER LEVEL.
    

Author:

    Antti Saarenheimo (o-anttis) 10-OCT-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <llc.h>
#ifndef max
#include <stdlib.h>
#endif

#ifdef  TRACE_ENABLED

BOOLEAN                     TraceEnabled;
static PLLC_TRACE_HEADER    pTraceBufferBase;
static PLLC_TRACE_HEADER    pTraceBufferTop;
static PLLC_TRACE_HEADER    pTraceBufferHead;
static NDIS_SPIN_LOCK       TraceLock;
static ULONG                TraceFlags;


UCHAR GetHexDigit( 
    UINT   Ch
    );
PUCHAR
GetHexString( 
    PUCHAR pDest, 
    UINT Length,
    PUCHAR Buffer 
    );
DLC_STATUS
LlcTraceInitialize(
    IN PVOID pUserTraceBuffer,
    IN ULONG UserTraceBufferSize,
    IN ULONG UserTraceFlags
    )
{
    //
    //  This small piece of code is not multiprocessors safe,
    //  but nobody will ever find it ...
    //
    if (TraceEnabled)
    {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }
    if (UserTraceBufferSize < LLC_MIN_TRACE_BUFFER)
    {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
    RtlZeroMemory( pUserTraceBuffer, (UINT)UserTraceBufferSize );
    ALLOCATE_SPIN_LOCK( &TraceLock );
    pTraceBufferBase = pTraceBufferHead = (PLLC_TRACE_HEADER)pUserTraceBuffer;
    pTraceBufferHead->Event = LLC_TRACE_END_OF_DATA;
    pTraceBufferTop = 
        &pTraceBufferBase[ UserTraceBufferSize / sizeof(LLC_TRACE_HEADER) ];
    TraceFlags = UserTraceFlags;
    TraceEnabled = TRUE;
    return STATUS_SUCCESS;
}


VOID
LlcTraceClose(
    VOID
    )
{
    if (TraceEnabled)
    {
        TraceEnabled = FALSE;
        DEALLOCATE_SPIN_LOCK( &TraceLock );
    }
}

VOID
LlcTraceWrite( 
    IN UINT Event, 
    IN UCHAR AdapterNumber,
    IN UINT DataBufferSize,
    IN PVOID pDataBuffer
    )
{

//if ((AdapterNumber & 0x7f) != 0)
//    return;

    if (TraceEnabled)
    {
        ACQUIRE_SPIN_LOCK( &TraceLock );
        if ((ULONG)(&pTraceBufferHead[1]) >= (ULONG)pTraceBufferTop)
        {
            pTraceBufferHead = (PLLC_TRACE_HEADER)pTraceBufferBase;
        }
        pTraceBufferHead->Event = (USHORT)Event;
        pTraceBufferHead->AdapterNumber = AdapterNumber;
        pTraceBufferHead->TimerTick = AbsoluteTime;
        pTraceBufferHead->DataLength = (UCHAR)
#ifdef min 
            min( TRACE_DATA_LENGTH, DataBufferSize );
#else
            __min( TRACE_DATA_LENGTH, DataBufferSize );
#endif
        memcpy( 
            pTraceBufferHead->Buffer,
            pDataBuffer,
            pTraceBufferHead->DataLength
            );
        pTraceBufferHead++;
        pTraceBufferHead->Event = LLC_TRACE_END_OF_DATA;
        RELEASE_SPIN_LOCK( &TraceLock );
    }
}

#ifdef  OS2_EMU_DLC
//
//  Procedure makes the post mortem dump of the given number of last frames.
//  The output should look very much like in Sniffer.
//  This routine doesn't supprot source routing info, but its implementatin
//  should not be a very big thing.
//
VOID
LlcTraceDump( 
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    )
{
    PUCHAR      pDest, pSrc, pCommand, pDlcHeader, pDirection, pTmp;
    UINT        i;
    UCHAR       Buffer1[13], Buffer2[13];
    UCHAR       CmdResp, PollFinal;
    LLC_HEADER  LlcHeader;
    BOOLEAN     IsEthernet;
    PLLC_TRACE_HEADER pTrace;
    UCHAR       DataBuffer[18];
    USHORT      EthernetType;

RtlZeroMemory( DataBuffer, sizeof( DataBuffer ));
LlcTraceWrite( 
    LLC_TRACE_RECEIVE_FRAME, AdapterNumber, sizeof(DataBuffer), DataBuffer );
 
    if (!TraceEnabled)
        return;
    ACQUIRE_SPIN_LOCK( &TraceLock );
    
    printf( 
 "#    Time      Adpt Local Node      Remote Node  Dsp Ssp   Cmd    Nr  Ns\n");
//0---------1---------2---------3---------4---------5---------6---------7-----
//5    10        5    13              13           4   4   9        4   4
    for (
        pTrace = pTraceBufferHead, i = 0;
        i < LastEvents;
        i++)
    {
        EthernetType = 0;
        if (pTrace != pTraceBufferBase)
        {
            pTrace--;
        }
        else
        {
	    pTrace = pTraceBufferTop - 2;
        }

        if (pTrace->Event == LLC_TRACE_END_OF_DATA)
        {
            break;
        }
        //
        //  The highest bit is set in the adapter number, if
        //  it's a token-ring adapter.
        //
        if (pTrace->AdapterNumber & 0x80)
        {
            IsEthernet = FALSE;
        }
        else
            IsEthernet = TRUE;
    
        pDlcHeader = &pTrace->Buffer[14];
        if (IsEthernet)
        {
            pSrc = &pTrace->Buffer[6];
            pDest = pTrace->Buffer;

            //
            //  Discard all non ieee 802.2 frames, but support
            //  the SNA dix headers.
            //
            if (pTrace->Buffer[12] == 0x80 &&
                pTrace->Buffer[13] == 0xd5)
            {
                pDlcHeader = &pTrace->Buffer[17];
            }
            else if (pTrace->Buffer[12] >= 64)
            {
                EthernetType = (USHORT)
                    (((USHORT)pTrace->Buffer[12] << 8) + 
                     pTrace->Buffer[13]
                     );
            }
        }
        else
        {
            pSrc = &pTrace->Buffer[8];
            pDest = &pTrace->Buffer[2];

            //
            //  Skip the source souting info
            //
            if (pTrace->Buffer[8] & 0x80)
                pDlcHeader += pTrace->Buffer[14] & 0x1f;

                //
                //  Discard all non ieee 802.2 frames
                //
            if (pTrace->Buffer[1] != 0x40)
                continue;
        }
        memcpy( (PUCHAR)&LlcHeader, pDlcHeader, 4 );
    
        if (AdapterNumber != -1 && 
            AdapterNumber != ((UINT)pTrace->AdapterNumber & 0x7f))
            continue;

        if (pTrace->Event == LLC_TRACE_SEND_FRAME)
        {
            if (pRemoteNode != NULL && memcmp( pDest, pRemoteNode, 6))
                continue;
            pTmp = pDest;
            pDest = pSrc;
            pSrc = pTmp;
            pDirection = "->";
        }
        else if (pTrace->Event == LLC_TRACE_RECEIVE_FRAME)
        {
            if (pRemoteNode != NULL && memcmp( pSrc, pRemoteNode, 6))
                continue;
            pDirection = "<-";
        }
        else
        {
            continue;
        }
        if (EthernetType != 0)
        {
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  DIX type %x\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                EthernetType
                );

        }
        //
        //  Handle first I frames, they are the most common!
        //
        else if (!(LlcHeader.U.Command & LLC_NOT_I_FRAME))
        {
            PollFinal = ' ';
            if (LlcHeader.I.Ssap & LLC_SSAP_RESPONSE)
            {
                CmdResp = 'r';
                if (LlcHeader.I.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'f';
                }
            }
            else
            {
                CmdResp = 'c';
                if (LlcHeader.I.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'p';
                }
            }
            pCommand =  "I";
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  %-2x  %-2x %5s-%c%c %-3u %-3u\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                LlcHeader.U.Dsap,
                LlcHeader.U.Ssap & 0xfe,
                pCommand,
                CmdResp,
                PollFinal,
                LlcHeader.I.Nr >> 1,
                LlcHeader.I.Ns >> 1
                ); 
        }
        else if (!(LlcHeader.S.Command & LLC_U_TYPE_BIT))
        {
            //
            // Handle S (Supervisory) commands (RR, REJ, RNR)
            //
            switch (LlcHeader.S.Command)
            {
            case LLC_RR:
                pCommand = "RR";
                break;
            case LLC_RNR:
                pCommand = "RNR";
                break;
            case LLC_REJ:
                pCommand = "REJ";
                break;
            default:
                pCommand = "INV";
                break;
            };
            //
            //  The valid frames has modulo: Va <= Nr <= Vs,
            //  Ie. the Receive sequence number should belong to
            //  a frame that has been sent but not acknowledged.
            //  The extra check in the beginning makes the most common
            //  code path faster: usually the other is waiting the next frame.
            //  (keep the rest code the same as in I path, even a very
            //  primitive optimizer will puts these code paths together)
            //
            PollFinal = ' ';
            if (LlcHeader.S.Ssap & LLC_SSAP_RESPONSE)
            {
                CmdResp = 'r';
                if (LlcHeader.S.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'f';
                }
            }
            else
            {
                CmdResp = 'c';
                if (LlcHeader.S.Nr & LLC_I_S_POLL_FINAL)
                {
                    PollFinal = 'p';
                }
            }
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  %-2x  %-2x %5s-%c%c %-3u\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                LlcHeader.U.Dsap,
                LlcHeader.U.Ssap & 0xfe,
                pCommand,
                CmdResp,
                PollFinal,
                LlcHeader.I.Nr >> 1
                ); 
        }
        else
        {
            //
            // Handle U (Unnumbered) command frames
            // (FRMR, DM, UA, DISC, SABME, XID, TEST)
            switch (LlcHeader.U.Command & ~LLC_U_POLL_FINAL)
            {
            case LLC_UI:
                pCommand = "UI";
                break;
            case LLC_DISC:
                pCommand = "DISC";
                break;
            case LLC_SABME:
                pCommand = "SABME";
                break;
            case LLC_DM:
                pCommand = "DM";
                break;
            case LLC_UA:
                pCommand = "UA";
                break;
            case LLC_FRMR:
                 pCommand =  "FRMR";
                break;
            case LLC_TEST:
                pCommand =  "TEST";
                break;
            case LLC_XID:
                pCommand =  "XID";
                break;
            default:
                pCommand =  "INV";
                break;
            };
            //
            //  We set an uniform poll/final bit for procedure call
            //
            PollFinal = ' ';
            if (LlcHeader.U.Command & LLC_U_POLL_FINAL)
            {
                if (LlcHeader.U.Ssap & 1)
                {
                    PollFinal = 'f';
                }
                else
                {
                    PollFinal = 'p';
                }
            }
            if (LlcHeader.U.Ssap & 1)
            {
                CmdResp = 'r';
            }
            else
            {
                CmdResp = 'c';
            }
            printf(
                "%-4u %-9lu %3u  %12s %2s %12s  %-2x  %-2x %5s-%c%c\n",
                i,
                pTrace->TimerTick,
                pTrace->AdapterNumber & 0x7f,
                GetHexString( pDest, 6, Buffer1 ),
                pDirection,
                GetHexString( pSrc, 6, Buffer2 ),
                LlcHeader.U.Dsap,
                LlcHeader.U.Ssap & 0xfe,
                pCommand,
                CmdResp,
                PollFinal
                ); 
        } 
    }
    RELEASE_SPIN_LOCK( &TraceLock );
}


UCHAR GetHexDigit( 
    UINT   Ch
    )
{
    if (Ch <= 9)
        return (UCHAR)('0' + (UCHAR)Ch);
    else
        return (UCHAR)('A' + (UCHAR)Ch - 10);
}

PUCHAR
GetHexString( 
    PUCHAR pDest, 
    UINT Length,
    PUCHAR Buffer 
    )
{
    UINT i;
    
    for (i = 0; i < (Length * 2); i += 2)
    {
        Buffer[i] = GetHexDigit( *pDest >> 4 );
        Buffer[i+1] = GetHexDigit( *pDest & 0x0f );
        pDest++;
    }
    Buffer[i] = 0;
    return Buffer;
}


VOID
LlcTraceDumpAndReset( 
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    )
{
    LlcTraceDump( LastEvents, AdapterNumber, pRemoteNode );
    ACQUIRE_SPIN_LOCK( &TraceLock );
    if ((ULONG)(&pTraceBufferHead[1]) >= (ULONG)pTraceBufferTop)
    {
        pTraceBufferHead = (PLLC_TRACE_HEADER)pTraceBufferBase;
    }
    else
        pTraceBufferHead++;
    RELEASE_SPIN_LOCK( &TraceLock );
}
#endif
#endif  // TRACE_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\llctyp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dltyp.h

Abstract:

    This module includes all internal typedefs and constats
    of data link driver.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

#include "refcnt.h"

//
// Design notes:
//     All data structures are designed at first for
//     multiple clients to make the interface very clean.
//     This implements also a simple kernel level interface
//     of data link layer to be used by somebody that needs it.
//


struct _LLC_NDIS_PACKET;
typedef struct _LLC_NDIS_PACKET LLC_NDIS_PACKET, *PLLC_NDIS_PACKET;

struct _LLC_SAP;
typedef struct _LLC_SAP LLC_SAP, *PLLC_SAP;

struct _DATA_LINK;
typedef struct _DATA_LINK DATA_LINK, *PDATA_LINK;

struct _ADAPTER_CONTEXT;
typedef struct _ADAPTER_CONTEXT ADAPTER_CONTEXT, *PADAPTER_CONTEXT;

//
// LLC_GENERIC_OBJECT - these fields are common in all LLC objects
//

struct _LLC_GENERIC_OBJECT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // pointer to singly-linked list of same-type structures
    //

    PLLC_OBJECT pNext;

    //
    // ObjectType - SAP, DIRECT or LINK
    //

    UCHAR ObjectType;

    //
    // EthernetType - if we have opened the adapter binding in AUTO mode then
    // for SAPs and Link Stations we need to determine whether to talk 802.3
    // or DIX
    //

    UCHAR EthernetType;

    //
    // usReserved - just aligns to DWORD (not necessary)
    //

    USHORT usReserved;
    PADAPTER_CONTEXT pAdapterContext;
    PBINDING_CONTEXT pLlcBinding;

    //
    // hClientHandle - handle to LINK object in upper layer
    //

    PVOID hClientHandle;
    PLLC_PACKET pCompletionPackets;
    ULONG ReferenceCount;
};

typedef struct _LLC_GENERIC_OBJECT LLC_GENERIC_OBJECT, *PLLC_GENERIC_OBJECT;

//
// LLC_U_RESPONSE - LLC header for U-type response frame
//

typedef struct _LLC_U_RESPONSE {
    UCHAR Dsap;     // Destination Service Access Point.
    UCHAR Ssap;     // Source Service Access Point.
    UCHAR Command;  // command code.
    UCHAR Info[1];  // respomse table
} LLC_U_RESPONSE, *PLLC_U_RESPONSE;

//
// QUEUE_PACKET - generic doubly-linked list header
//

typedef struct _QUEUE_PACKET {
    struct _QUEUE_PACKET* pNext;
    struct _QUEUE_PACKET* pPrev;
} QUEUE_PACKET, *PQUEUE_PACKET;

//
// LLC_QUEUE -
//

typedef struct _LLC_QUEUE {
    LIST_ENTRY ListEntry;
    LIST_ENTRY ListHead;    // the list head
    PVOID pObject;          // owner handle (used if element is linked)
} LLC_QUEUE, *PLLC_QUEUE;


//
// This information is a part of the DLC.STATISTICS
// information for a link station. The whole
// strcuture can be reseted.
//

typedef struct _LINK_STATION_STATISTICS {
    USHORT I_FramesTransmitted;
    USHORT I_FramesReceived;
    UCHAR I_FrameReceiveErrors;
    UCHAR I_FrameTransmissionErrors;
    USHORT T1_ExpirationCount;  // not in data xfer mode
} LINK_STATION_STATISTICS, *PLINK_STATION_STATISTICS;

typedef struct _SAP_STATISTICS {
    ULONG FramesTransmitted;
    ULONG FramesReceived;
    ULONG FramesDiscardedNoRcv;
    ULONG DataLostCounter;
} SAP_STATISTICS, *PSAP_STATISTICS;

struct _LLC_SAP {
    LLC_GENERIC_OBJECT Gen;
    USHORT SourceSap;           // THIS MUST OVERLAY ObjectAddress
    USHORT OpenOptions;
    SAP_STATISTICS Statistics;

    //
    // KEEP THIS SAME IN SAP STATION AND GENERIC OBJECT
    //

    DLC_LINK_PARAMETERS DefaultParameters;
    NDIS_SPIN_LOCK FlowControlLock;
    PDATA_LINK pActiveLinks;    // all link stations of this sap
};

struct _TIMER_TICK;
typedef struct _TIMER_TICK TIMER_TICK, *PTIMER_TICK;

typedef struct _LLC_TIMER {
    struct _LLC_TIMER* pNext;
    struct _LLC_TIMER* pPrev;
    PTIMER_TICK pTimerTick;
    ULONG ExpirationTime;
    PVOID hContext;

#if defined(LOCK_CHECK)

    ULONG Disabled;

#endif

} LLC_TIMER, *PLLC_TIMER;

struct _TIMER_TICK {
    struct _TIMER_TICK* pNext;
//    struct _TIMER_TICK* pPrev;
    PLLC_TIMER pFront;
    UINT DeltaTime;
    USHORT Input;
    USHORT ReferenceCount;
};

//
// DATA_LINK - these 'objects' are from a two level data storage. The hash table
// provides a very fast access to links, when there are less than 100 links
// (about 99 % of the cases). The binary tree keeps the search times still quite
// small, when there are very many connections from/to the same server.
//

struct _DATA_LINK {
    LLC_GENERIC_OBJECT Gen;

    //
    // Data link station state machine variables, *2 means the value
    // to be used as 2 increments, because modulo 256 is much easier
    // to handle than modulo 128. UCHAR wraps around automatically.
    //

    SHORT Is_Ct;        // Max number of I retries (Update_Va & xxx_Chkpt)
    USHORT Ia_Ct;       // Number of LPDU acknowledgements since Ww was incr.

    UCHAR State;        // current state of the finite state machine
    UCHAR Ir_Ct;        // LPDUs possible to send before next acknowledgement
    UCHAR Vs;           // *2, Send state variable (Ns of next sent LPDU)
    UCHAR VsMax;        // *2, Max Send state variable (Ns of next sent LPDU)
    UCHAR Vr;           // *2, Receive state variable( Nr of next sent LPDU)

    UCHAR Pf;           // value of PollFinal bit in last command
    UCHAR Va;           // *2, Last valid Nr received (ack state variable)
    UCHAR Vp;           // *2, Poll state var. (Ns of last sent cmd with P-bit)
    UCHAR Vb;           // Busy state (Vl, Vb, Vlb)

    UCHAR Vc;           // Stacked command variable (only DISC is possible)
    UCHAR Vi;           // initialization state variable

    //
    // BEGIN OF DLC_LINK_PARAMETERS (same as llc_params struct)
    // DON'T TOUCH !!!!
    //

    UCHAR TimerT1;      // Timer T1 value
    UCHAR TimerT2;      // Timer T2 value

    UCHAR TimerTi;      // Timer Ti value
    UCHAR MaxOut;       // *2, maximum transmit window size (MaxOut)
    UCHAR RW;           // maximum receive window size (MaxIn)
    UCHAR Nw;           // number of LPDUs acknowledged, before Ww is incr.)

    UCHAR N2;           // Number of retires allowed (both Polls and I LPDSs)
    UCHAR AccessPrty;   // access priority
    USHORT MaxIField;   // maximum received info field (not used in LLC)

    //
    // End of DLC_LINK_PARAMETERS
    //

    UCHAR Ww;           // *2, working window size
    UCHAR N3;           // number of I format LPDUs between acks (with Ir_Ct)
    UCHAR P_Ct;         // Poll retry count
    UCHAR Nr;           // last Nr of the received frame

    //
    // Variables needed to maintain dynamic response base time for timers.
    //

    USHORT LastTimeWhenCmdPollWasSent;
    USHORT AverageResponseTime;

    UCHAR cbLanHeaderLength;
    UCHAR VrDuringLocalBusy;
    UCHAR Flags;
    UCHAR TW;           // dynamic MaxOut value

    USHORT FullWindowTransmits; // succeeded Polls of full window xmits
    UCHAR T1_Timeouts;          // T1 timeouts after I-c1
    UCHAR RemoteOpen;

    //
    //  The link status flags contains these status bits:
    //
    //      DLC_WAITING_RESPONSE_TO_POLL
    //      DLC_FIRST_POLL
    //      DLC_ACTIVE_REMOTE_CONECT_REQUEST
    //      DLC_COMMAND_POLL_PENDING_IN_NDIS;
    //      DLC_SEND_DISABLED
    //      DLC_SEND_ACTIVE
    //      DLC_LOCAL_BUSY_BUFFER
    //      DLC_LOCAL_BUSY_USER
    //

    //
    // the timer objects
    //

    LLC_TIMER T1;
    LLC_TIMER T2;
    LLC_TIMER Ti;

    LLC_QUEUE SendQueue;    // untransmitted queue for the I frames
    LIST_ENTRY SentQueue;   // the sent but not acknowledged I- frames

    PDATA_LINK pNextNode;   // for the hash table
    LAN802_ADDRESS LinkAddr;// 64 bit lan address of the link

    PLLC_SAP pSap;          // link to the SAP object of this link

    DLC_STATUS_TABLE DlcStatus;

    //
    // Resetable link station statistics counters
    //

    LINK_STATION_STATISTICS Statistics;

    UCHAR LastCmdOrRespSent;
    UCHAR LastCmdOrRespReceived;
    UCHAR Dsap;             // Destination SAP
    UCHAR Ssap;             // Source SAP

    //
    // some link statistics (don't reset this)
    //

    ULONG BufferCommitment;

    //
    // FramingType - type of framing (802.3/DIX/don't care) that we should use
    // for this connection. Required because in AUTO mode, the actual framing
    // type may be different than that in the BINDING_CONTEXT, and since the
    // BINDING_CONTEXT is per-adapter, we cannot rely on it (this whole thing
    // is messed up)
    //

    ULONG FramingType;

    //
    // Network frame header (includes the full address information)
    //

    UCHAR auchLanHeader[1];

    //
    // LAN HEADER OVERFLOWS HERE !!!!
    //
};

typedef struct _LLC_STATION_OBJECT {
    LLC_GENERIC_OBJECT Gen;
    USHORT ObjectAddress;
    USHORT OpenOptions;
    SAP_STATISTICS Statistics;
} LLC_STATION_OBJECT, *PLLC_STATION_OBJECT;

union _LLC_OBJECT {

    //
    // KEEP THIS SAME AS DIRECT AND SAP STATIONS
    //

    LLC_GENERIC_OBJECT Gen;
    DATA_LINK Link;
    LLC_SAP Sap;
    LLC_STATION_OBJECT Group;
    LLC_STATION_OBJECT Dix;
    LLC_STATION_OBJECT Dir;
};

//*****************************************************************

typedef struct _NDIS_MAC_PACKET {
    NDIS_PACKET_PRIVATE private;
    UCHAR auchMacReserved[16];
} NDIS_MAC_PACKET;

struct _LLC_NDIS_PACKET {
    NDIS_PACKET_PRIVATE private;    // we accesss this also directly
    UCHAR auchMacReserved[16];
    PMDL pMdl;                      // MDL for LAN and LLC headers

    //
    // request handle and command completion handler are saved to
    // the packet until NDIS has completed the command
    //

    PLLC_PACKET pCompletionPacket;

#if LLC_DBG
    ULONG ReferenceCount;
#endif

    UCHAR auchLanHeader[LLC_MAX_LAN_HEADER + sizeof(LLC_U_HEADER) + sizeof(LLC_RESPONSE_INFO)];
};

typedef struct _LLC_TRANSFER_PACKET {
    NDIS_PACKET_PRIVATE private;
    UCHAR auchMacReserved[16];
    PLLC_PACKET pPacket;
} LLC_TRANSFER_PACKET, *PLLC_TRANSFER_PACKET;

typedef struct _EVENT_PACKET {
    struct _EVENT_PACKET* pNext;
    struct _EVENT_PACKET* pPrev;
    PBINDING_CONTEXT pBinding;
    PVOID hClientHandle;
    PVOID pEventInformation;
    UINT Event;
    UINT SecondaryInfo;
} EVENT_PACKET, *PEVENT_PACKET;

//
// The next structure is used only in the allocating packets to the pool
//

typedef union _UNITED_PACKETS {
    QUEUE_PACKET queue;
    EVENT_PACKET event;
    LLC_PACKET XmitPacket;
    UCHAR auchLanHeader[LLC_MAX_LAN_HEADER];
} UNITED_PACKETS, *PUNITED_PACKETS;

//
// NODE_ADDRESS - 6 byte MAC address expressed as bytes or ULONG & USHORT for
// minimal comparisons/moves on 32-bit architecture
//

typedef union {
    UCHAR Bytes[6];
    struct {
        ULONG Top4;
        USHORT Bottom2;
    } Words;
} NODE_ADDRESS, *PNODE_ADDRESS;

//
// FRAMING_DISCOVERY_CACHE_ENTRY - the solution to the LLC_ETHERNET_TYPE_AUTO
// problem (where we can end up proliferating TEST/XIDs and SABME/UAs) is to
// keep a cache of destinations we have 'ping'ed with TEST/XID/SABME. We send
// both frame types - DIX and 802.3. We indicate the first received response
// and create a cache entry, recording the remote MAC address and the framing
// type. If another response frame arrives from the cached MAC address with
// the other framing type, it is discarded
//

typedef struct {
    NODE_ADDRESS NodeAddress;   // the remote MAC address
    BOOLEAN InUse;              // TRUE if in use (could use TimeStamp == 0)
    UCHAR FramingType;          // DIX or 802.3
    LARGE_INTEGER TimeStamp;    // used for LRU throw-out
} FRAMING_DISCOVERY_CACHE_ENTRY, *PFRAMING_DISCOVERY_CACHE_ENTRY;

#define FRAMING_TYPE_DIX    0x1d    // arbitrary value
#define FRAMING_TYPE_802_3  0x83    //     "       "

//
// BINDING_CONTEXT - one of these created for each client (app/open driver
// handle instance) opening the adapter. We only perform an open adapter at
// NDIS level once, which creates the ADAPTER_CONTEXT for the NDIS open
// adapter instance. Subsequent open adapter requests from processes cause
// a BINDING_CONTEXT to be created and linked to the ADAPTER_CONTEXT
//

struct _BINDING_CONTEXT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // pointer to singly-linked list of BINDING_CONTEXT structures for this
    // ADAPTER_CONTEXT
    //

    struct _BINDING_CONTEXT* pNext;

    //
    // pointer to ADAPTER_CONTEXT structure for this BINDING_CONTEXT
    //

    PADAPTER_CONTEXT pAdapterContext;

    //
    // handle of/pointer to FILE_CONTEXT structure
    //

    PVOID hClientContext;

    //
    // pointers to command completion, receive and event indication functions
    //

    PFLLC_COMMAND_COMPLETE pfCommandComplete;
    PFLLC_RECEIVE_INDICATION pfReceiveIndication;
    PFLLC_EVENT_INDICATION pfEventIndication;

    //
    // Functional - functional address applied to this binding by the app
    //

    TR_BROADCAST_ADDRESS Functional;

    //
    // ulFunctionalZeroBits - mask of bits which should be off for functional
    // address/multicast address
    //

    ULONG ulFunctionalZeroBits;

    //
    // 0.5 second timer used for DIR.TIMER functions
    //

    LLC_TIMER DlcTimer;

    //
    // NdisMedium - the actual medium that the adapter to which we are bound talks
    //

    UINT NdisMedium;

    //
    // AddressTranslation - how the bits in addresses should be represented at
    // the top and bottom edges of LLC
    //

    USHORT AddressTranslation;

    //
    // BroadCastAddress - 6 byte broadcast address treated as USHORT and ULONG
    // entities. Used for checking promiscuous packets
    //

    USHORT usBroadcastAddress;
    ULONG ulBroadcastAddress;

    //
    // InternalAddressTranslation -
    //

    USHORT InternalAddressTranslation;

    //
    // EthernetType - value which determines the format of an Ethernet frame.
    // Different for 802.3 vs. DIX vs. ...
    //

    USHORT EthernetType;

    //
    // SwapCopiedLanAddresses - TRUE if we bit-swap LAN addresses when copying
    // up or down the layers
    //

    BOOLEAN SwapCopiedLanAddresses;

    //
    // The big substructures should be in the end
    // to produce optimal code for x86
    //

    LLC_TRANSFER_PACKET TransferDataPacket;

    //
    // FramingDiscoveryCacheEntries - maximum number of elements that can be
    // in DiscoveryFramingCache. Will be zero if the adapter is not ethernet and
    // LLC_ETHERNET_TYPE_AUTO was not requested, else number determined from
    // registry or default value. Number from registry may also be 0, indicating
    // caching is not to be used (old semantics)
    //

    ULONG FramingDiscoveryCacheEntries;

    //
    // FramingDiscoveryCache - if this EthernetType == LLC_ETHERNET_TYPE_AUTO,
    // we create a cache of destination MAC addresses and the DIX/802.3 framing
    // type they use. This array is FramingDiscoveryCacheEntries long
    //

    FRAMING_DISCOVERY_CACHE_ENTRY FramingDiscoveryCache[];
};

//
// ADAPTER_CONTEXT - the device context of an NDIS driver. It includes links to
// all dynamic data structures of the data link driver.
//
// This version does not support the group SAPs
//

#define LINK_HASH_SIZE  128

struct _ADAPTER_CONTEXT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // pointer to singly-linked list of ADAPTER_CONTEXT structures opened by
    // all clients of this driver
    //

    struct _ADAPTER_CONTEXT* pNext;

#if !defined(DLC_UNILOCK)

    NDIS_SPIN_LOCK SendSpinLock;        // locked when accessing send queues
    NDIS_SPIN_LOCK ObjectDataBase;      // used also with sap/direct create

#endif

    PLLC_STATION_OBJECT pDirectStation; // link list of direct stations
    PBINDING_CONTEXT pBindings;         // link list of all bindings
    NDIS_HANDLE NdisBindingHandle;
    PVOID hLinkPool;                    // pool for link station structs
    PVOID hPacketPool;                  // pool for usr/small LLC packets

    //
    // circular link list is free NDIS packets for send (initially maybe 5)
    //

    PLLC_NDIS_PACKET pNdisPacketPool;
    NDIS_HANDLE hNdisPacketPool;

    //
    // Some stuff for asynchronous receive indications
    //

    PVOID hReceiveCompletionRequest;
    PLLC_PACKET pResetPackets;

    //
    // pHeadBuf - pointer to the MAC header buffer, containing:
    //
    //  FDDI:
    //      1 Byte Frame Control (FDDI)
    //      6 Bytes Destination MAC Address (ALL)
    //      6 Bytes Source MAC Address (ALL)
    //
    //  Token Ring:
    //      1 Byte Access Control (Token Ring)
    //      1 Byte Frame Control (Token Ring)
    //      6 Bytes Destination MAC Address (ALL)
    //      6 Bytes Source MAC Address (ALL)
    //      0-18 Bytes Source Routing
    //
    //  Ethernet:
    //      6 Bytes Destination MAC Address (ALL)
    //      6 Bytes Source MAC Address (ALL)
    //      2 Bytes Length or DIX Type
    //

    PUCHAR pHeadBuf;

    //
    // cbHeadBuf - number of bytes in pHeadBuf
    //

    UINT cbHeadBuf;

    //
    // pLookBuf - pointer to the MAC look-ahead buffer which contains the rest
    // of the data for this frame or as much as the MAC could fit into the look
    // ahead buffer (in which case NdisTransferData must be used to get the
    // rest)
    //

    PUCHAR pLookBuf;

    //
    // cbLookBuf - number of bytes in pLookBuf
    //

    UINT cbLookBuf;

    //
    // cbPacketSize - actual size of the whole frame. Calculated from information
    // in the header or supplied by the MAC, depending on the medium
    //

    UINT cbPacketSize;

    //
    // IsSnaDixFrame - true if the frame just received (on ethernet) is a DIX
    // frame and the DIX identifier is 0x80D5 (big-endian)
    //

    UINT IsSnaDixFrame;
    LAN802_ADDRESS Adapter;
    ULONG MaxFrameSize;
    ULONG LinkSpeed;

    //
    // We use UINTs, because (Move mem, ULONG) may not be an
    // atomic operation (in theory)
    //

    UINT NdisMedium;
    UINT XidTestResponses;
    ULONG ObjectCount;                  // must be zero, when adapter closed

    //
    // ConfigInfo - holds the SwapAddressBits and UseDixOverEthernet flags and
    // the timer tick values
    //

    ADAPTER_CONFIGURATION_INFO ConfigInfo;

    //
    // the original node addresses
    //

    ULONG ulBroadcastAddress;

    USHORT usBroadcastAddress;
    USHORT BackgroundProcessRequests;

    UCHAR NodeAddress[6];               // Current network format
    USHORT cbMaxFrameHeader;

    UCHAR PermanentAddress[6];
    USHORT OpenOptions;

    USHORT AddressTranslationMode;
    USHORT FrameType;

    USHORT usRcvMask;
    USHORT EthernetType;

    USHORT RcvLanHeaderLength;
    USHORT BindingCount;

    USHORT usHighFunctionalBits;

    //
    // Keep UCHAR alignment
    //

    BOOLEAN boolTranferDataNotComplete;
    BOOLEAN IsDirty;
    BOOLEAN ResetInProgress;
    UCHAR Unused1;

#ifndef NDIS40
    // Not used.
    UCHAR AdapterNumber;
#endif // NDIS40
    UCHAR IsBroadcast;
    BOOLEAN SendProcessIsActive;
    BOOLEAN LlcPacketInSendQueue;

    //
    // We keep the big structures and tables in the end,
    // that makes most x86 offsets 1 byte instead of 4.
    // The compiler aligns the fields naturally, whenever
    // it is necessary.
    //

    //
    // the next elements will be linked to circular
    // end process link list, if there are any frames to send
    //

    LIST_ENTRY NextSendTask;            // pointer to active sends
    LIST_ENTRY QueueEvents;
    LIST_ENTRY QueueCommands;
    LLC_QUEUE QueueI;
    LLC_QUEUE QueueDirAndU;
    LLC_QUEUE QueueExpidited;
    UNICODE_STRING Name;                // current adapter name
    PTIMER_TICK pTimerTicks;

    NDIS_STATUS AsyncOpenStatus;        // used to wait async open
    NDIS_STATUS AsyncCloseResetStatus;  // used to wait async close
    NDIS_STATUS OpenCompleteStatus;     // used to wait the first open
    NDIS_STATUS LinkRcvStatus;          // link state machine ret status
    NDIS_STATUS NdisRcvStatus;          // NdisRcvIndication ret status
    NDIS_STATUS OpenErrorStatus;        // special adapter open status

    //
    // NDIS calls back when adapter open completes. Use a Kernel Event to
    // synchronize LLC with NDIS
    //

    KEVENT Event;

    //
    // the following are reasonably large arrays (like 256 pointers to SAP
    // objects...)
    //

    PLLC_SAP apSapBindings[256];        // the clients bound to the SAPs
    PDATA_LINK aLinkHash[LINK_HASH_SIZE];   // hash table to links
    PLLC_STATION_OBJECT aDixStations[MAX_DIX_TABLE];
    LLC_TRANSFER_PACKET TransferDataPacket;

#if DBG

    //
    // memory usage counters for memory owned by this ADAPTER_CONTEXT
    //

    MEMORY_USAGE MemoryUsage;
    MEMORY_USAGE StringUsage;

#endif

#ifdef NDIS40
        
    #define BIND_STATE_UNBOUND      1
    #define BIND_STATE_UNBINDING    2
    #define BIND_STATE_BOUND        3
    
    LONG     BindState;
    REF_CNT  AdapterRefCnt;
    KEVENT   CloseAdapterEvent;
#endif // NDIS40
};

typedef PLLC_PACKET (*PF_GET_PACKET)(IN PADAPTER_CONTEXT pAdapterContext);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\refcnt.h ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
       refcnt.h

 Abstract:       
       
       Reference counting for an object.
       
 Author:
 
       Scott Holden (sholden)  12/29/1998 Borrowed from IrDA.
       
 Revision History:

--*/

#ifndef _REFCNT_H_
#define _REFCNT_H_

#ifdef NDIS40 // Only used for NDIS40 code now.

#define TAG_CNT 8
#define REF_SIG 0x7841eeee

#if DBG
typedef struct _REF_TAG
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    
#endif 

typedef struct _REF_CNT
{
    LONG       	Count;
    PVOID       Instance;
    VOID        (*DeleteHandler)(PVOID pvContext);
#if DBG    
    int         Sig;
    REF_TAG     Tags[TAG_CNT];
    KSPIN_LOCK  Lock;
    ULONG       TypeTag;
#endif // DBG    
}
REF_CNT, *PREF_CNT;

//
// ReferenceInit - Initialize the reference control block.
//

_inline VOID    
ReferenceInit( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)(PVOID pvContext)
    )
{
    pRefCnt->Count          = 0;
    pRefCnt->Instance       = InstanceHandle;
    pRefCnt->DeleteHandler  = DeleteHandler;
}

//
// ReferenceAdd - Add a reference.
//

_inline VOID
ReferenceAdd(
    IN 	PREF_CNT  pRefCnt
    )
{
    InterlockedIncrement(&pRefCnt->Count);
}

//
// ReferenceRemove - Del a reference. If the reference is zero, and a 
//                   delete handler has been specified, then call the
//                   handler.
//

_inline VOID
ReferenceRemove(
    IN PREF_CNT  pRefCnt
    )
{
    if (InterlockedDecrement(&pRefCnt->Count) <= 0 &&
        pRefCnt->DeleteHandler)
    {
        (pRefCnt->DeleteHandler)(pRefCnt->Instance);
    }
}

#if DBG

//
// For checked builds, we will do some verification with tags, etc to ensure
// that the ref counting is done correctly.
//

VOID    
ReferenceInitDbg( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)(PVOID pvContext),
    ULONG       TypeTag
    );

VOID 
ReferenceAddDbg(
    PREF_CNT pRefCnt, 
    ULONG Tag, 
    int cLine
    );

VOID 
ReferenceRemoveDbg(
    PREF_CNT pRefCnt, 
    ULONG Tag, 
    int cLine
    );

#define REFINIT(Rc, Inst, DelHandler, Tag) ReferenceInitDbg(Rc, Inst, DelHandler, Tag)
#define REFADD(Rc, Tag)                    ReferenceAddDbg(Rc, Tag, __LINE__)
#define REFDEL(Rc, Tag)                    ReferenceRemoveDbg(Rc, Tag, __LINE__)

#else // DBG

#define REFINIT(Rc, Inst, DelHandler, Tag) ReferenceInit(Rc, Inst, DelHandler)
#define REFADD(Rc, Tag)                    ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)                    ReferenceRemove(Rc);

#endif // !DBG

#endif // NDIS40
#endif // _REFCNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\refcnt.c ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
    refcnt.c

 Abstract:       
    
    This module contains checked reference counting support functions.
    The free versions are inline.   
       
 Author:
 
       Scott Holden (sholden)  12/29/1998 Borrowed from IrDA.
       
 Revision History:

--*/

#ifdef NDIS40 // Only used for NDIS40 code now.
#if DBG

//
// Include Files
//

#include "dlc.h"
#include "llc.h"
#include "dbgmsg.h"


#define EXPAND_TAG(_Tag) ((CHAR *)(&_Tag))[0], \
                         ((CHAR *)(&_Tag))[1], \
                         ((CHAR *)(&_Tag))[2], \
                         ((CHAR *)(&_Tag))[3]

VOID
ReferenceInitDbg(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)(PVOID pvContext),
    ULONG       TypeTag
    )

/*++

Routine Description:

    Initializes the reference control block. Reference count is initialized
    to zero.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    
    InstanceHandle - handle to the managed instance.
    
    DeleteHandler - pointer to delete function, NULL is OK.
    
    TypeTag - Identifies initialization.

Return Value:

    The function's value is VOID.

--*/

{
    DEBUGMSG(DBG_REF, (TEXT("ReferenceInit(%#x, %#x, %#x, %c%c%c%c)\n"), 
        pRefCnt, InstanceHandle, DeleteHandler, EXPAND_TAG(TypeTag)));

    ASSERT(pRefCnt);

    //
    // Set the reference to 0 and save the instance 
    // handle and the delete handler.
    //

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;

    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);

    pRefCnt->Tags[0].Tag = 'LTOT';

    KeInitializeSpinLock(&pRefCnt->Lock);

    pRefCnt->TypeTag = TypeTag;

    return;
}

VOID
ReferenceAddDbg(
    PREF_CNT    pRefCnt, 
    ULONG       Tag,
    int         cLine
    )
{
    int             i;
    int             TotalPerArray = 0;
    KIRQL           OldIrql;

    ASSERT(pRefCnt->Sig == REF_SIG);

    DEBUGMSG(DBG_REF && DBG_VERBOSE, (TEXT("REFADD %#x [%c%c%c%c:%c%c%c%c] %d [l:%d]\n"),
        pRefCnt, EXPAND_TAG(pRefCnt->TypeTag), EXPAND_TAG(Tag), 
        pRefCnt->Count, cLine));    

    KeAcquireSpinLock(&pRefCnt->Lock, &OldIrql);

    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }

    ASSERT(i < TAG_CNT);

    InterlockedIncrement(&pRefCnt->Tags[0].Count);

    InterlockedIncrement(&pRefCnt->Count);

    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);    

#ifdef REFCNT_SANITY_CHECK    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
#endif // REFCNT_SANITY_CHECK

    KeReleaseSpinLock(&pRefCnt->Lock, OldIrql);
}

VOID
ReferenceRemoveDbg(
    PREF_CNT pRefCnt, 
    ULONG    Tag,
    int      cLine)
{
    int             i;
    KIRQL           OldIrql;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;

    ASSERT(pRefCnt->Sig == REF_SIG);

    KeAcquireSpinLock(&pRefCnt->Lock, &OldIrql);

    DEBUGMSG(DBG_REF && DBG_VERBOSE, (TEXT("REFDEL %#x [%c%c%c%c:%c%c%c%c] %d [l:%d]\n"),
        pRefCnt, EXPAND_TAG(pRefCnt->TypeTag), EXPAND_TAG(Tag), 
        pRefCnt->Count, cLine));

    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;

            ASSERT(pRefCnt->Tags[i].Count > 0);

            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
            {
                pRefCnt->Tags[i].Tag = Tag;
            }
            break;
        }
    }

    ASSERT(FoundIt);
    ASSERT(pRefCnt->Tags[0].Count > 0);
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    InterlockedDecrement(&pRefCnt->Tags[0].Count);

    //
    // If the decremented count is non zero return the instance handle.
    //

    //
    // If reference is zero and delete handler is available, then call
    // handler.
    //

    if (InterlockedDecrement(&pRefCnt->Count) <= 0 &&
        pRefCnt->DeleteHandler)
    {
        DEBUGMSG(DBG_REF,(TEXT("REFDEL %#x [%c%c%c%c:%c%c%c%c] calling delete handler [l:%d].\n"),
            pRefCnt, EXPAND_TAG(pRefCnt->TypeTag), EXPAND_TAG(Tag), cLine));
        KeReleaseSpinLock(&pRefCnt->Lock, OldIrql);


        (pRefCnt->DeleteHandler)(pRefCnt->Instance);
    }
    else
    {
        KeReleaseSpinLock(&pRefCnt->Lock, OldIrql);
    }

#ifdef REFCNT_SANITY_CHECK    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint(TEXT("Tag %X, RefCnt %X, perArray %d, total %d\n"), Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
#endif // REFCNT_SANITY_CHECK
}
#endif // DBG
#endif // NDIS40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\alg_ftp.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// ALG_FTP.cpp : Implementation of DLL Exports.
//
// JPDup
// Sanjiv
//


#include "PreComp.h"

#include <initguid.h>
#include "MyALG.h"
//#include "MyAdapterNotify.h"



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_AlgFTP,                       CAlgFTP)
//    OBJECT_ENTRY(CLSID_MyAdapterNotificationSink,   CMyAdapterNotify)
END_OBJECT_MAP()






MYTRACE_ENABLE;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MYTRACE_START(L"ALG_FTP");
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MYTRACE_STOP;
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object from the Object Map
    return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\buffer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains code for buffer-management.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "precomp.h"
#include "list.h"

#pragma hdrstop

#define NH_ALLOCATE(s)          HeapAlloc(GetProcessHeap(), 0, (s))
#define NH_FREE(p)              HeapFree(GetProcessHeap(), 0, (p))



LIST_ENTRY          MyHelperpBufferQueue;
LONG                MyHelperpBufferQueueLength;
CRITICAL_SECTION    MyHelperpBufferQueueLock;

PNH_BUFFER
MyHelperAcquireFixedLengthBuffer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer.
    If no buffer is available on the buffer queue, a new one is obtained.

Arguments:

    none.

Return Value:

    PNH_BUFFER - the buffer allocated

--*/

{
    MYTRACE_ENTER_NOSHOWEXIT("MyHelperAcquireFixedLengthBuffer");
    PNH_BUFFER Buffer;
    PLIST_ENTRY Link;
    EnterCriticalSection(&MyHelperpBufferQueueLock);
    if ( !IsListEmpty(&MyHelperpBufferQueue) ) 
    {
        Link = RemoveHeadList(&MyHelperpBufferQueue);
        LeaveCriticalSection(&MyHelperpBufferQueueLock);
        InterlockedDecrement(&MyHelperpBufferQueueLength);
        Buffer = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        Buffer->Type = MyHelperFixedLengthBufferType;
        return Buffer;
    }
    LeaveCriticalSection(&MyHelperpBufferQueueLock);
    
    Buffer = NH_ALLOCATE_BUFFER();
    if (Buffer) {
        Buffer->Type = MyHelperFixedLengthBufferType;
    }
    return Buffer;
} // MyHelperAcquireFixedLengthBuffer


PNH_BUFFER
MyHelperAcquireVariableLengthBuffer(
    ULONG Length
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer of non-standard size.
    If the length requested is less than or equal to 'NH_BUFFER_SIZE',
    a buffer from the shared buffer-queue is returned.
    Otherwise, a buffer is especially allocated for the caller.

Arguments:

    Length - the length of the buffer required.

Return Value:

    PNH_BUFFER - the buffer allocated.

--*/

{
    MYTRACE_ENTER_NOSHOWEXIT(">>>MyHelperAcquireVariableLengthBuffer");

    PNH_BUFFER Buffer;
    if (Length <= NH_BUFFER_SIZE) {
        return MyHelperAcquireFixedLengthBuffer();
    }

    Buffer = reinterpret_cast<PNH_BUFFER>(
                NH_ALLOCATE(FIELD_OFFSET(NH_BUFFER, Buffer[Length]))
                );
                
    if (Buffer) { Buffer->Type = MyHelperVariableLengthBufferType; }
    return Buffer;
} // MyHelperAcquireVariableLengthBuffer


PNH_BUFFER
MyHelperDuplicateBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine creates a duplicate of the given buffer,
    including both its data and its control information.

    N.B. Variable-length buffers cannot be duplicated by this routine.

Arguments:

    Bufferp - the buffer to be duplicated

Return Value:

    PNH_BUFFER - a pointer to the duplicate

--*/

{
    PNH_BUFFER Duplicatep;
    _ASSERT(Bufferp->Type == MyHelperFixedLengthBufferType);
    if (!(Duplicatep = MyHelperAcquireBuffer())) 
    { 
        return NULL; 
    }

    *Duplicatep = *Bufferp;
    return Duplicatep;
} // MyHelperDuplicateBuffer



ULONG
MyHelperInitializeBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine readies the buffer-management for operation.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    InitializeListHead(&MyHelperpBufferQueue);
    MyHelperpBufferQueueLength = 0;
    __try 
    {
        InitializeCriticalSection(&MyHelperpBufferQueueLock);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        //MyHelperTrace(
        //TRACE_FLAG_BUFFER,
        //"MyHelperInitializeBufferManagement: exception %d creating lock",
        //Error = GetExceptionCode()
        //);
    }

    return Error;

} // MyHelperInitializeBufferManagement


VOID
MyHelperReleaseBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to release a buffer to the buffer queue.
    It attempts to place the buffer on the queue for re-use, unless
    the queue is full in which case the buffer is immediately freed.

Arguments:

    Bufferp - the buffer to be released

Return Value:

    none.

--*/

{
    MYTRACE_ENTER_NOSHOWEXIT("<<<MyHelperReleaseBuffer");

    if (MyHelperpBufferQueueLength > NH_MAX_BUFFER_QUEUE_LENGTH || Bufferp->Type != MyHelperFixedLengthBufferType) 
    {
        NH_FREE_BUFFER(Bufferp);
    } 
    else 
    {
        EnterCriticalSection(&MyHelperpBufferQueueLock);
        InsertHeadList(&MyHelperpBufferQueue, &Bufferp->Link);
        LeaveCriticalSection(&MyHelperpBufferQueueLock);
        InterlockedIncrement(&MyHelperpBufferQueueLength);
    }
} // MyHelperReleaseBuffer



VOID
MyHelperShutdownBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine cleans up resources used by the buffer-management module.
    It assumes the list will not be accessed while the clean up is in progress.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNH_BUFFER Bufferp;

    while (!IsListEmpty(&MyHelperpBufferQueue)) 
    {
        Link = RemoveHeadList(&MyHelperpBufferQueue);
        Bufferp = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        NH_FREE_BUFFER(Bufferp);
    }

    DeleteCriticalSection(&MyHelperpBufferQueueLock);
    MyHelperpBufferQueueLength = 0;

} // MyHelperShutdownBufferManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\buffer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    This module contains declarations for buffer-management.

    All network I/O in this component occurs via completion packets.
    The buffer routines below are used to acquire and release the buffers
    used for sending and receiving data.

    In addition to holding the data transferred, the buffers contain fields
    to facilitate their use with completion ports. See below for details
    on the use of the fields.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_BUFFER_H_
#define _NATHLP_BUFFER_H_

#define NH_BUFFER_SIZE              576
#define NH_MAX_BUFFER_QUEUE_LENGTH  32

struct _NH_BUFFER;

//
// Typedef:     PNH_COMPLETION_ROUTINE
//

typedef
VOID
(*PNH_COMPLETION_ROUTINE)(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    struct _NH_BUFFER* Bufferp
    );


//
// Structure:   NH_BUFFER
//
// This structure holds a buffer used for network I/O on a socket.
//

typedef enum _NH_BUFFER_TYPE {
    MyHelperFixedLengthBufferType,
    MyHelperVariableLengthBufferType
} NH_BUFFER_TYPE;

typedef struct _NH_BUFFER {
    union {
        LIST_ENTRY Link;
        NH_BUFFER_TYPE Type;
    };
    //
    // The socket associated with the buffer's most recent I/O request
    //
    SOCKET Socket;
    //
    // Completion routine and contexts for the buffer's most recent I/O request
    //
    PNH_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Context2;
    //
    // Passed as the system context area for any I/O using the buffer
    //
    OVERLAPPED Overlapped;
    //
    // Upon completion of a receive, the receive-flags and source-address
    // length for the message read
    //
    ULONG ReceiveFlags;
    ULONG AddressLength;
    union {
        //
        // Holds the source address when a datagram-read completes
        //
        SOCKADDR_IN ReadAddress;
        //
        // Holds the destination address while a datagram-send is in progress
        //
        SOCKADDR_IN WriteAddress;
        //
        // Holds the remote address while a connect is in progress
        //
        SOCKADDR_IN ConnectAddress;
        //
        // Holds the state of a multi-request read or write
        //
        struct {
            ULONG UserFlags;
            ULONG BytesToTransfer;
            ULONG TransferOffset;
        };
    };
    //
    // Upon completion of an I/O request, the error-code, byte-count,
    // and data-bytes for the request
    //
    ULONG ErrorCode;
    ULONG BytesTransferred;
    UCHAR Buffer[NH_BUFFER_SIZE];
} NH_BUFFER, *PNH_BUFFER;

#define NH_ALLOCATE_BUFFER() \
    reinterpret_cast<PNH_BUFFER>(NH_ALLOCATE(sizeof(NH_BUFFER)))
    
#define NH_FREE_BUFFER(b)       NH_FREE(b)


//
// BUFFER-MANAGEMENT ROUTINES (alphabetically)
//

#define MyHelperAcquireBuffer() MyHelperAcquireFixedLengthBuffer()
PNH_BUFFER
MyHelperAcquireFixedLengthBuffer(
    VOID
    );

PNH_BUFFER
MyHelperAcquireVariableLengthBuffer(
    ULONG Length
    );

PNH_BUFFER
MyHelperDuplicateBuffer(
    PNH_BUFFER Bufferp
    );

ULONG
MyHelperInitializeBufferManagement(
    VOID
    );

VOID
MyHelperReleaseBuffer(
    PNH_BUFFER Bufferp
    );

VOID
MyHelperShutdownBufferManagement(
    VOID
    );

#endif // _NATHLP_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\ftpcontrol.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// FtpControl.cpp : Implementation
//
// JPDup
// Sanjiv
//
#include "precomp.h"

#include "MyAlg.h"


//
// Default constructor
//
CFtpControlConnection::CFtpControlConnection()
{
    MYTRACE_ENTER_NOSHOWEXIT("CFtpControlConnection::CFtpControlConnection()");
    m_ClientConnectedSocket = INVALID_SOCKET;
    m_AlgConnectedSocket = INVALID_SOCKET;
    m_ControlState.m_nAddressNew = 0;
    m_ControlState.m_nPortNew = 0;
    m_nSourcePortReplacement = 0;
    m_RefCount = 0;
    m_pPendingProxy = NULL;
}




//
// Destructor
//
CFtpControlConnection::~CFtpControlConnection()
{
    MYTRACE_ENTER_NOSHOWEXIT("CFtpControlConnection::~CFtpControlConnection()");
}



//
// Find a unique source port for the public client address given
// 
USHORT
PickNewSourcePort(
    ULONG  nPublicSourceAddress,
    USHORT nPublicSourcePort
    )
{
    MYTRACE_ENTER("CFtpControlConnection::PickNewSourcePort()");

    USHORT nNewSourcePort = 45000-nPublicSourcePort; // example 45000 - 3000

    bool    bPortAvailable;

    do
    {
        nNewSourcePort--;
        bPortAvailable = g_ControlObjectList.IsSourcePortAvailable(nPublicSourceAddress, nNewSourcePort);
        MYTRACE("Port %d is %s", nNewSourcePort, bPortAvailable ? "Available" : "Inuse" );

    } while ( (false == bPortAvailable) && (nNewSourcePort > 6001) );

    return nNewSourcePort;
}


//
// Initialize
//
HRESULT
CFtpControlConnection::Init(
    SOCKET                          AcceptedSocket,
    ULONG                           nToAddr,
    USHORT                          nToPort,
    CONNECTION_TYPE                 ConnType
    )
{
    MYTRACE_ENTER("CFtpControlConnection::Init");


    //
    // Figure what address to use
    //
    ULONG BestAddress;

    HRESULT hr = g_pIAlgServicesAlgFTP->GetBestSourceAddressForDestinationAddress(
        nToAddr,
        TRUE,
        &BestAddress
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Could not get best source address", hr);
        return hr;
    }


    ULONG Err = 0;

    m_ClientConnectedSocket = AcceptedSocket;
    m_ConnectionType = ConnType;

    IncReference();

    m_AlgConnectedSocket = INVALID_SOCKET;




    Err = MyHelperCreateStreamSocket(BestAddress,0,&m_AlgConnectedSocket);


    if ( Err == 0 )
    {
        if ( m_ConnectionType == OUTGOING )
        {
            MYTRACE("OUTGOING FTP");

            ULONG   icsAddr;
            USHORT  icsPort;

            Err = MyHelperQueryLocalEndpointSocket(m_AlgConnectedSocket,&icsAddr,&icsPort);
            MYTRACE("AlgConnectedSocket Local %s:%d",MYTRACE_IP(icsAddr), ntohs(icsPort) );

            if ( Err == 0 )
            {
                hr = g_pIAlgServicesAlgFTP->PrepareProxyConnection(
                    eALG_TCP,
                    icsAddr,
                    icsPort,
                    nToAddr,
                    nToPort,
                    FALSE,
                    &m_pPendingProxy
                    );
            }
        }
        else if (m_ConnectionType == INCOMING)
        {
            MYTRACE("INCOMING FTP");

            ULONG   icsAddr,pubAddr;
            USHORT  icsPort,pubPort;

            Err = MyHelperQueryLocalEndpointSocket(m_AlgConnectedSocket,&icsAddr,&icsPort);
            MYTRACE("AlgConnectedSocket Local %s:%d",MYTRACE_IP(icsAddr), ntohs(icsPort) );

            if (Err == 0)
            {
                Err = MyHelperQueryRemoteEndpointSocket(m_ClientConnectedSocket,&pubAddr,&pubPort);

                if ( Err == 0 )
                {
                    if ( icsAddr == nToAddr )
                    {
                        //
                        // Special case it the FTP server is hosted on the EDGE box
                        // we would create a loop the incoming public client address/port
                        // this new modified connection would look exacly like 
                        // the original one example:
                        //
                        // 1.1.1.2:3000 connects to 1.1.1.1:21
                        // we accept this connection
                        // and in return we connect to the FTP server destination 1.1.1.1:21
                        // asking the NAT to source mofify and replace the source with 1.1.1.2:3000
                        // that does not work
                        // in order to go arround this we pick another source port example 45000
                        //

                        // Cache this info in order to pick a unique one next time
                        m_nSourcePortReplacement = PickNewSourcePort(pubAddr, pubPort);

                        pubPort = m_nSourcePortReplacement;   // This is the new bogus port to use now
                    }

                    hr = g_pIAlgServicesAlgFTP->PrepareSourceModifiedProxyConnection(
                        eALG_TCP,
                        icsAddr,
                        icsPort,
                        nToAddr,
                        nToPort,
                        pubAddr,
                        pubPort,
                        &m_pPendingProxy
                        );
                    if ( FAILED(hr) )
                    {
                        MYTRACE_ERROR("PrepareSourceModifiedProxyConnection",hr);
                    }
                }
                else
                {
                    MYTRACE_ERROR("MyHelperQueryRemoteEndpointSocket",Err);
                }

            }
            else
            {
                MYTRACE_ERROR("LocalEndpointSocket", Err);
            }

        }
    }
    else
    {
        MYTRACE_ERROR("MyHelperCreateStreamSocket",Err);
    }

    if ( SUCCEEDED(hr) && Err == 0 )
    {

        Err = MyHelperConnectStreamSocket(
            NULL,
            m_AlgConnectedSocket,
            nToAddr,
            nToPort,
            NULL,
            MyConnectCompletion,
            (void *)this,
            NULL
            );

        if ( Err != 0 )
        {
            MYTRACE_ERROR("From MyHelperConnectStreamSocket", Err);

            m_pPendingProxy->Cancel();
        }
    }

    if ( FAILED(hr) || Err )
    {
        MYTRACE_ERROR("We can't init this Connection", hr);

        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 0);

        if ( SUCCEEDED(hr) )
            hr = HRESULT_FROM_WIN32(Err);
    }

    return hr;
}


#define MAKE_ADDRESS(a,b,c,d)       ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))
#define MAKE_PORT(a,b)              ((a) | ((b) << 8))



//
//
//
ULONG
GetNumFromString(UCHAR *String,ULONG *pNum)
{
    ULONG retval = 0;
    int i = 0;
    while (String[i] != ',')
    {
        retval = retval*10 + (String[i]-'0');
        i++;
    }
    *pNum = i;
    return retval;
}


//
// Needs to return in Network address order
//
USHORT
GetUSHORTFromString(UCHAR *String,ULONG *pNum)
{
    MYTRACE_ENTER("GetUSHORTFromString");



    ULONG Num;
    UCHAR Numbers[2];
    *pNum = 0;

    Numbers[0] = (UCHAR)GetNumFromString(String,&Num);
    *pNum += Num+1;


    Numbers[1] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num;


    USHORT retval = (USHORT)MAKE_PORT((USHORT)Numbers[0], (USHORT)Numbers[1]);

    return retval;
}

//
// return the String IP Address as 192,168,0,0, in a ULONG in HOST format
//
ULONG
GetULONGFromString(
    UCHAR*  String,
    ULONG*  pNum
    )
{
    UCHAR Numbers[4];

    ULONG retval = 0;
    ULONG Num;

    *pNum = 0;
    Numbers[0] = (UCHAR)GetNumFromString(String,&Num);
    *pNum += Num+1;

    Numbers[1] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num+1;

    Numbers[2] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num+1;

    Numbers[3] = (UCHAR)GetNumFromString(String+*pNum,&Num);
    *pNum += Num;

    retval = MAKE_ADDRESS(Numbers[0], Numbers[1], Numbers[2], Numbers[3]);

    return retval;
}





//
//
//
void
CFtpControlConnection::ConnectCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred
    )
{
    MYTRACE_ENTER("CFtpControlConnection::ConnectCompletionRoutine");

    

    ULONG Err;


    if ( ErrCode )
    {
        MYTRACE_ERROR("ConnectCompletionRoutine", ErrCode);

        if ( m_pPendingProxy )
        {
            MYTRACE("PendingProxy still active CANCEL");
            m_pPendingProxy->Cancel();
        }

        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 0);

        return;
    }

    Err = MyHelperReadStreamSocket(
        NULL,
        m_ClientConnectedSocket,
        NULL,
        FTP_MAX_MSG_SIZE,
        0,
        MyReadCompletion,
        (void *)this,
        (void *)CLIENT_READ
        );


    if ( Err )
    {
        MYTRACE_ERROR("From MyHelperReadStreamSocket CLIENT_READ",Err);
        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 0);

        return;
    }

    IncReference();
    Err = MyHelperReadStreamSocket(
        NULL,
        m_AlgConnectedSocket,
        NULL,
        FTP_MAX_MSG_SIZE,0,
        MyReadCompletion,
        (void *)this,
        (void *)SERVER_READ
        );

    if ( Err )
    {
        MYTRACE("MyHelperReadStreamSocket SERVER_READ",Err);
        ULONG ref;
        ref = DecReference();
        _ASSERT(ref == 1);

        if (ref)
            Shutdown();

        return;
    }
    
    return;
}




//
//
//
ULONG
CFtpControlConnection::IncReference(void)
{
    MYTRACE_ENTER("CFtpControlConnection::IncReference()");
    ULONG nRef = InterlockedIncrement((LPLONG)&m_RefCount);

    MYTRACE("REFCOUNT for 0x%X is now %d", this, nRef);
    return nRef;
}



//
//
//
ULONG
CFtpControlConnection::DecReference(void)
{
    MYTRACE_ENTER("CFtpControlConnection::DecReference()");
    
    ULONG tmp = InterlockedDecrement((LPLONG)&m_RefCount);
    MYTRACE("REFCOUNT for 0x%X is now %d", this, tmp);

    if ( tmp > 0 )
        return tmp;

    MYTRACE("HIT ZERO refcount cleanup the CFtpControlConnection");


    if ( m_AlgConnectedSocket == INVALID_SOCKET )
    {
        MYTRACE("SOCKET SERVER ALREADY CLOSED!");
    }
    else
    {
        MYTRACE("CLOSING SOCKET ALGCONNECTED!");
        shutdown(m_AlgConnectedSocket, SD_BOTH);
        closesocket(m_AlgConnectedSocket);
        m_AlgConnectedSocket = INVALID_SOCKET;
    }

    if ( m_ClientConnectedSocket == INVALID_SOCKET )
    {
        MYTRACE("SOCKET CLIENT ALREADY CLOSED!");
    }
    else
    {
        MYTRACE("CLOSING SOCKET CLIENT CONNECTED!");
        shutdown(m_ClientConnectedSocket, SD_BOTH);
        closesocket(m_ClientConnectedSocket);
        m_ClientConnectedSocket = INVALID_SOCKET;
    }

    if ( m_pPendingProxy )
    {
//
// At this point NAT already cancel this redirect, so no need to call cancel
//        m_pPendingProxy->Cancel(); 
// this was causing a ERROR on a multi-client scenario
//
        m_pPendingProxy->Release();
        m_pPendingProxy = NULL;
    }

    if ( m_ControlState.m_nPortNew )
    {
        MYTRACE("ReleaseReservedPort-A %d", ntohs(m_ControlState.m_nPortNew));
        g_pIAlgServicesAlgFTP->ReleaseReservedPort(m_ControlState.m_nPortNew,1);
        m_ControlState.m_nPortNew = 0;
    }


    //
    // CleanUp the collection of DataChannel
    //
    IDataChannel*   pData;
    USHORT          Port;
    HANDLE          CreationHandle,DeletionHandle;

    MYTRACE("Empty CDataChannelList");

    while ( m_DataChannelList.Remove(&pData,&Port,&CreationHandle,&DeletionHandle) )
    {
        //
        // Creation and Deletion events are not used for now
        // NhUnRegisterEvent(CreationHandle); // Hopefully nothing bad will happen ! May have been called before
        // NhUnRegisterEvent(DeletionHandle); // if delete has been called it would mean that Remove has been called.
        //

        pData->Cancel();
        pData->Release();
        MYTRACE("ReleaseReservedPort-B %d", ntohs(Port));
        g_pIAlgServicesAlgFTP->ReleaseReservedPort(Port,1);
    }


    if ( g_ControlObjectList.Remove(this) )
    {
        // happens when this was called from within ChannelDeletion or some DecReferece after that.
    }
    else
    {
        // would happen if this was called from shutdown. not otherwise.
    }

    delete this;

    return 0;
}




//
// The last one to call DecReference would take it off control list.
// The first one to call DecReference because of fatal error would call Shutdown to start off
// the DecReference for all the connected stuff.
//
void
CFtpControlConnection::Shutdown()
{
    MYTRACE_ENTER("CFtpControlConnection::Shutdown()");

    if ( m_AlgConnectedSocket != INVALID_SOCKET )
    {
        MYTRACE("CLOSING SOCKET ALG CONNECTED! %d", m_AlgConnectedSocket);
        shutdown(m_AlgConnectedSocket, SD_BOTH);
        closesocket(m_AlgConnectedSocket);
        m_AlgConnectedSocket = INVALID_SOCKET;
    }


    if ( m_ClientConnectedSocket != INVALID_SOCKET )
    {
        MYTRACE("CLOSING SOCKET CLIENT CONNECTED! %d", m_ClientConnectedSocket);
        shutdown(m_ClientConnectedSocket, SD_BOTH);
        closesocket(m_ClientConnectedSocket);
        m_ClientConnectedSocket = INVALID_SOCKET;
    }

    return;
}








//
//
//
void
CFtpControlConnection::ReadCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    MYTRACE_ENTER( "CFtpControlConnection::ReadCompletionRoutine" );

    if ( ErrCode || BytesTransferred == 0 )
    {

        if ( ErrCode )
        {
            MYTRACE("Shutdown because of read ERROR 0x%x", ErrCode);
        }
        else
        {
            MYTRACE("Shutdown because of read 0 bytes");
        }

        MyHelperReleaseBuffer(Bufferp);
        if (DecReference())
            Shutdown();

        return;
    }

    ULONG_PTR ReadType = (ULONG_PTR)Bufferp->Context2;

    ULONG_PTR WriteType;

    SOCKET    ReadSocket;
    SOCKET    WriteSocket;

    ULONG Err;

    if ( ReadType == CLIENT_READ )
    {
        WriteType = SERVER_READ;
        ReadSocket = m_ClientConnectedSocket;
        WriteSocket = m_AlgConnectedSocket;
    }
    else
    {
        WriteType = CLIENT_READ;
        ReadSocket = m_AlgConnectedSocket;
        WriteSocket = m_ClientConnectedSocket;

    }

#if defined(DBG) || defined(_DEBUG)
    ULONG   TraceAddr = 0;
    USHORT  TracePort = 0;

    if ( ReadSocket != INVALID_SOCKET )
        Err = MyHelperQueryRemoteEndpointSocket(ReadSocket ,&TraceAddr,&TracePort);

    MYTRACE("from %s (%s:%d)", 
       ReadType == CLIENT_READ ? "CLIENT":"SERVER", 
	   MYTRACE_IP(TraceAddr),
       ntohs(TracePort)
	   );
    MYTRACE("EC(0x%x)   Buffer size(%d)='%s'", ErrCode, BytesTransferred, MYTRACE_BUFFER2STR((char*)Bufferp->Buffer, BytesTransferred));
#endif
    if ( (ReadType == CLIENT_READ && m_ConnectionType == OUTGOING) || (ReadType == SERVER_READ && m_ConnectionType == INCOMING) )
    {
        // the number of bytes transferred can change.
        // because the ProcessFtpMessage may have to
        // buffer the Address,Port string from PORT or PASV response command.
        ProcessFtpMessage(Bufferp->Buffer,&BytesTransferred);

    }


    if ( BytesTransferred != 0 && WriteSocket != INVALID_SOCKET )
    {
        IncReference();

        MYTRACE(
            "Write to %s size(%d)='%s'",
            WriteType == SERVER_READ ? "SERVER" : "CLIENT",
            BytesTransferred,
            MYTRACE_BUFFER2STR((char*)Bufferp->Buffer, BytesTransferred)
            );

        Err = MyHelperWriteStreamSocket(
            NULL,
            WriteSocket,
            Bufferp,BytesTransferred,
            0,
            MyWriteCompletion,
            (void *)this,(PVOID)WriteType
            );

        if (Err)
        {
            MYTRACE_ERROR("from MyHelperWriteStreamSocket", Err);

            DecReference();
            if (DecReference())
                Shutdown();    // I am not going to call the Read again so one more DecReference is needed.
            MyHelperReleaseBuffer(Bufferp);
            return;
        }
    }

    if ( INVALID_SOCKET == ReadSocket )
    {
        if (DecReference())
            Shutdown();
    }
    else
    {
        Err = MyHelperReadStreamSocket(
            NULL,
            ReadSocket,
            NULL,
            FTP_MAX_MSG_SIZE,
            0,
            MyReadCompletion,
            (void *)this,
            (void *)ReadType
            );
    
    
        if (Err)
        {
            MYTRACE_ERROR("from MyHelperReadStreamSocket",Err);
    
            if (DecReference())
                Shutdown();
        }
    }
    
    return;
}




//
//
//
void
CFtpControlConnection::WriteCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    MYTRACE_ENTER("CFtpControlConnection::WriteCompletionRoutine");

    if (BytesTransferred == 0)
        ErrCode = ERROR_IO_CANCELLED;

    if (ErrCode)
    {
        if (MyHelperIsFatalSocketError(ErrCode) || ErrCode == ERROR_IO_CANCELLED)
        {
            MYTRACE_ERROR("FATAL ERROR", ErrCode);
            MyHelperReleaseBuffer(Bufferp);

            if (DecReference())
                Shutdown();
        }
        else
        {
            MYTRACE_ERROR("ANOTHER MyHelperWriteStreamSocket", ErrCode);

            ULONG_PTR Type = (ULONG_PTR)Bufferp->Context2;
            ULONG Err = MyHelperWriteStreamSocket(
                NULL,
                Bufferp->Socket,
                Bufferp,Bufferp->BytesToTransfer,
                0,
                MyWriteCompletion,
                (void *)this,
                (PVOID)Type
                );

            if (Err)
            {
                MYTRACE_ERROR("From MyHelperWriteStreamSocket", Err);

                MyHelperReleaseBuffer(Bufferp);
                if (DecReference())
                    Shutdown();
            }
        }
    }
    else
    {
        ULONG_PTR Type = (ULONG_PTR)Bufferp->Context2;

        MYTRACE(Type == CLIENT_READ ? "to CLIENT" : "to SERVER" );
        MYTRACE("EC(0x%x) Buffer size(%d)='%s'", ErrCode, BytesTransferred, MYTRACE_BUFFER2STR((char*)Bufferp->Buffer, BytesTransferred));
        MYTRACE("Write Succeeded now cleanup");
        MyHelperReleaseBuffer(Bufferp);
        DecReference();
    }

    return;
}



bool
FtpExtractOctet(
    UCHAR** Buffer,
    UCHAR*  BufferEnd,
    UCHAR*  Octet
    )

/*++

Routine Description:

    This routine is called to extract an octet from a string.

Arguments:

    Buffer - points to a pointer to a string where conversion starts; on
        return it points to the pointer to the string where conversion ends
    BufferEnd - points to the end of the string
    Octet - points to a caller-suplied storage to store converted octet

Return Value:

    BOOLEAN - TRUE if successfuly converted, FALSE otherwise.

--*/

{
    bool    bSuccess;
    ULONG   nDigitFound = 0;
    ULONG   Value = 0;

    while ( 
            *Buffer <= BufferEnd 
        &&  nDigitFound < 3                   
        &&  **Buffer >= '0' 
        &&  **Buffer <= '9'
        ) 
    {
        Value *= 10;
        Value += **Buffer - '0';
        (*Buffer)++;
        nDigitFound++;
    }

    bSuccess = nDigitFound > 0 && Value < 256;

    if ( bSuccess ) 
    {
        *Octet = (UCHAR)Value;
    }

    return bSuccess;
}


//
// Extract host and port numbers.
// example 192,168,0,2,100,200
//
bool
ExtractAddressAndPortCommandValue(
    UCHAR*  pCommandBuffer,
    UCHAR*  pEndOfBuffer,
    UCHAR*  Numbers,
    ULONG*  nTotalLen
    )
{
    UCHAR*  pStartingPosition = pCommandBuffer;

    
    bool bSuccess = FtpExtractOctet(
        &pCommandBuffer,
        pEndOfBuffer,
        &Numbers[0]
        );

    int i = 1;

    while ( i < 6 && bSuccess && *pCommandBuffer == ',' ) 
    {
        pCommandBuffer++;
        bSuccess = FtpExtractOctet(
            &pCommandBuffer,
            pEndOfBuffer,
            &Numbers[i]
            );
        i++;
    }

    if ( bSuccess && i == 6 ) 
    {
        *nTotalLen = (ULONG)(pCommandBuffer - pStartingPosition);
        return true;
    }
    
    return false;
}


#define TOUPPER(c)      ((c) > 'z' ? (c) : ((c) < 'a' ? (c) : (c) ^ 0x20))

//
// Look for the "PORT" or "227" command and remap the private address associated with these command
// to a public address
//
void
CFtpControlConnection::ProcessFtpMessage(
    UCHAR*  Buffer,
    ULONG*  pBytes
    )
{
    MYTRACE_ENTER("CFtpControlConnection::ProcessFtpMessage");
    MYTRACE("Buffer size(%d)='%s'", *pBytes, MYTRACE_BUFFER2STR((char*)Buffer, *pBytes));

    ULONG Bytes = *pBytes;
    UCHAR* pCommandBuffer = reinterpret_cast<UCHAR*>(Buffer);
    UCHAR* EndOfBufferp   = reinterpret_cast<UCHAR*>(Buffer + *pBytes);

    HRESULT hr;
    char *String;

    UCHAR* pBeginAddressAndPortOld=NULL;
    UCHAR* pEndAddressAndPortOld=NULL;


    ULONG nOldAddressLen=0;

    CONST CHAR *pCommandToFind;

    // for now lets keep the OUTGOING and INCOMING seperate.
    // can be put together since most of the code is the same.
    // differences in the first few bytes to scan for.
    if ( m_ConnectionType == OUTGOING )
    {
        MYTRACE("OUTGOING - Look for 'PORT ' command");
        pCommandToFind = (PCHAR)"PORT ";
    }
    else
    {
        MYTRACE("INCOMING - Look for '227 ' command ");
        pCommandToFind = (PCHAR)"227 ";
    }
       
    while ( *pCommandToFind != '\0' && *pCommandToFind == TOUPPER(*pCommandBuffer)) 
    {
        pCommandToFind++;
        pCommandBuffer++;
    }

    if ( *pCommandToFind == '\0' ) 
    {
        MYTRACE("COMMAND found");

        //
        // Skip non digit char
        //
        if ( m_ConnectionType == OUTGOING )
        {
            //
            // Skip white space.  example ->  PORT    10,12,13,14,1,2 
            //
            while (*pCommandBuffer == ' ')
                pCommandBuffer++;
        }
        else
        {
            //
            // Skip non digit char example 227 Entering passive mode (10,12,13,14,1,2)
            //
            while ( pCommandBuffer < EndOfBufferp && !isdigit(*pCommandBuffer) )
                pCommandBuffer++;
        }
        

        //
        // so next stuff should be the addr,port combination.
        //
        UCHAR Numbers[6];


        
        if ( ExtractAddressAndPortCommandValue(pCommandBuffer, EndOfBufferp, Numbers, &nOldAddressLen) )
        {
            pBeginAddressAndPortOld = pCommandBuffer;
            pEndAddressAndPortOld   = pCommandBuffer + nOldAddressLen;

            m_ControlState.m_nAddressOld    = MAKE_ADDRESS(Numbers[0], Numbers[1], Numbers[2], Numbers[3]);
            m_ControlState.m_nPortOld       = MAKE_PORT(Numbers[4], Numbers[5]);

            MYTRACE("***** PRIVATE PORT is %d %d", m_ControlState.m_nPortOld, ntohs(m_ControlState.m_nPortOld));

            if ( ntohs(m_ControlState.m_nPortOld) <= 1025 )
            {
                //
                // For security reason we will disallow any redirection to ports lower then 1025
                // this port range is reserver for standard port Like 139/Netbios 
                // if this port range was requested it probably is the source of hacker attacking this FTP proxy
                //
                MYTRACE("***** Port to redirect is lower then 1025 so rejected");
                m_ControlState.m_nAddressNew    = htonl(0);
                m_ControlState.m_nPortNew       = htons(0);
                m_ControlState.m_nAddressLenNew = 11;
                strcpy((char*)m_ControlState.m_szAddressPortNew, "0,0,0,0,0,0");

                // pretend that a Redirection got created
                // This way we send out a PORT command with the Public addapter address and a new reserver PORT
                // but when the public hacker comes back it wil not be redirect but simply droped
            }
            else
            {
                //
                // Get best public address to use and reserver a port 
                // This will be the Address/Port expose on the public side.
                //
                hr = CreateNewAddress();

                if ( FAILED(hr) )
                {
                    MYTRACE_ERROR("CreateNewAddress failed",hr);
                    // We screwed up. cant make redirects now. so for now lets just act
                    // as if nothing happened and carry on with the stuff.
                }
            }
        }
        else
        {
            MYTRACE_ERROR("NOT a valid PORT command syntax", E_INVALIDARG);
        }
    }

    //
    // Rebuild the string command with the new address port 
    //
    if ( pBeginAddressAndPortOld )
    {
        if ( ntohs(m_ControlState.m_nPortOld) <= 1025 )
        {
            // No need to setup a redirection
            hr = S_OK;
        }
        else
        {
            hr = SetupDataRedirect();
        }

        if ( FAILED(hr) )
        {
            // we got screwed badly here. we wont set up redirect and act as if nothing happened.
            MYTRACE_ERROR("Could not setup a redirect", hr);
        }
        else
        {
            //
            // Move trailing buffer 
            //  Left if new address is smaller then old address
            //  Right if new address is bigger then old address
            //
            

            // This is the right side reminder of the buffer just after the last digit of the ascii port value
            int nReminerSize = (int)(Bytes - (pEndAddressAndPortOld - Buffer));

            if ( *pBytes + nReminerSize < FTP_MAX_MSG_SIZE )
            {
                int nOffset = m_ControlState.m_nAddressLenNew - nOldAddressLen; // What is the delta size between the old and new address

                MoveMemory(
                    pEndAddressAndPortOld + nOffset,    // Destination
                    pEndAddressAndPortOld,              // Source
                    nReminerSize                        // Size
                    );
    
                //
                // Insert the new address and port
                //
                memcpy(
                    pBeginAddressAndPortOld,            // Destination
                    m_ControlState.m_szAddressPortNew,  // Source
                    m_ControlState.m_nAddressLenNew     // Size
                    );
    
                MYTRACE("OLD Address size(%d) %s:%d", nOldAddressLen,                  MYTRACE_IP(m_ControlState.m_nAddressOld), ntohs(m_ControlState.m_nPortOld));
                MYTRACE("New Address size(%d) %s:%d", m_ControlState.m_nAddressLenNew, MYTRACE_IP(m_ControlState.m_nAddressNew), ntohs(m_ControlState.m_nPortNew));
                
                *pBytes = Bytes - nOldAddressLen + m_ControlState.m_nAddressLenNew;
                MYTRACE("Edited COMMAND is '%s' size(%d)", MYTRACE_BUFFER2STR((char*)Buffer, *pBytes), *pBytes);

                // Now we are sure to have a DataChannel created and in the list of DataChanel
                // on the last DecRefer the ResertPort was deleted twice
                // now by setting m_nPortNew to zero only the DataChannel code will release the port
                //
                m_ControlState.m_nPortNew = 0;
            }
            else
            {
                MYTRACE_ERROR("Could not alter the command the new address size does not fit in the the current buffer ", E_ABORT);
            }
        }
    }

    return;
}



//
//
//
int
CreateStringFromNumber(UCHAR *String,ULONG Num)
{
    int retval = 0;
    UCHAR ch1,ch2,ch3;

    ch3 = (UCHAR)(Num%10) + '0';
    Num = Num/10;
    ch2 = (UCHAR)(Num%10) + '0';
    Num = Num/10;
    ch1 = (UCHAR)(Num%10) + '0';
    _ASSERT(Num == 0);
    if (ch1 != '0') {
        String[retval++] = ch1;
        String[retval++] = ch2;
        String[retval++] = ch3;
    }
    else if (ch2 != '0') {
        String[retval++] = ch2;
        String[retval++] = ch3;
    }
    else {
        String[retval++] = ch3;
    }

    return retval;
}


//
//
//
int
CreateULONGString(UCHAR *String,ULONG Num)
{
    int retval = 0;
    retval += CreateStringFromNumber(String,Num&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>8)&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>16)&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>24)&0xff);
    return retval;
}


//
//
//
int
CreateUSHORTString(UCHAR *String,USHORT Num)
{
    int retval = 0;
    retval += CreateStringFromNumber(String,Num&0xff);
    String[retval++] = ',';
    retval += CreateStringFromNumber(String+retval,(Num>>8)&0xff);
    return retval;
}


//
//
//
HRESULT
CFtpControlConnection::CreateNewAddress(void)
{
    MYTRACE_ENTER("CFtpControlConnection::CreateNewAddress");

    SOCKET  sd;
    HRESULT hr = S_OK;
    ULONG   Err = 0;

    sd = (m_ConnectionType == OUTGOING ? m_AlgConnectedSocket : m_ClientConnectedSocket);

    ULONG OtherAddr,PublicAddr;
    USHORT OtherPort,PublicPort;

    Err = MyHelperQueryRemoteEndpointSocket(sd,&OtherAddr,&OtherPort);

    if (Err == 0)
    {
        hr = g_pIAlgServicesAlgFTP->GetBestSourceAddressForDestinationAddress(OtherAddr,FALSE,&PublicAddr);

        if ( SUCCEEDED(hr) )
        {
            hr = g_pIAlgServicesAlgFTP->ReservePort(1,&PublicPort);
        }
        else
        {
            MYTRACE_ERROR("Could not GetBestSourceAddressForDestinationAddress", hr);
            PublicAddr = 0; // Try with this
        }

        MYTRACE("ICS Reserved Address   %s:%d", MYTRACE_IP(PublicAddr), ntohs(PublicPort));
        m_ControlState.m_nAddressNew = PublicAddr;
        m_ControlState.m_nPortNew = PublicPort;

        
        ULONG StrLen = CreateULONGString(m_ControlState.m_szAddressPortNew,PublicAddr);

        m_ControlState.m_szAddressPortNew[StrLen++] = ',';
        StrLen += CreateUSHORTString(m_ControlState.m_szAddressPortNew+StrLen,PublicPort);
        m_ControlState.m_nAddressLenNew = StrLen;
        MYTRACE("NEW AddressPort String %s Len(%d)", MYTRACE_BUFFER2STR((char*)m_ControlState.m_szAddressPortNew, StrLen), StrLen);

    }

    return hr;
}



//
//
//
HRESULT
CFtpControlConnection::SetupDataRedirect(void)
{
    MYTRACE_ENTER("CFtpControlConnection::SetupDataRedirect");

    ULONG   pubAddr,prvAddr,icsAddr;
    USHORT  pubPort,prvPort,icsPort;
    ULONG   Err = 0;



    switch ( m_ConnectionType )
    {
    case OUTGOING:
        MYTRACE("OUTGOING");

        Err = MyHelperQueryRemoteEndpointSocket(m_AlgConnectedSocket,&pubAddr,&pubPort);
        pubPort = 0;

        icsAddr = m_ControlState.m_nAddressNew;
        icsPort = m_ControlState.m_nPortNew;

        prvAddr = m_ControlState.m_nAddressOld;
        prvPort = m_ControlState.m_nPortOld;
        break;

    case INCOMING:
        MYTRACE("INCOMING");
        Err = MyHelperQueryRemoteEndpointSocket(m_ClientConnectedSocket,&pubAddr,&pubPort);
        pubPort = 0;
        pubAddr = 0;
        icsAddr = m_ControlState.m_nAddressNew;
        icsPort = m_ControlState.m_nPortNew;

        prvAddr = m_ControlState.m_nAddressOld;
        prvPort = m_ControlState.m_nPortOld;
        break;

    default:
        // m_ConnectionType is corrupt
        _ASSERT( FALSE );
        break;
    }


    if ( Err != 0 )
    {
        MYTRACE_ERROR("MyHelperQueryRemoteEndpointSocket", Err);
        return E_FAIL;
    }


    HRESULT         hr = S_OK;
    IDataChannel*   pDataChannel = NULL;

    hr = g_pIAlgServicesAlgFTP->CreateDataChannel(
        eALG_TCP,
        prvAddr,
        prvPort,
        icsAddr,
        icsPort,
        pubAddr,
        pubPort,
        eALG_INBOUND,   //| eALG_OUTBOUND, not needed i suppose since we
                        // are not bothered if client tries to open connection.
        (ALG_NOTIFICATION)0,// (eALG_SESSION_CREATION | eALG_SESSION_DELETION),
        FALSE,
        &pDataChannel
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("g_pIAlgServicesAlgFTP->CreateDataChannel", hr);
        return hr;
    }


    m_DataChannelList.Insert(
        pDataChannel,
        icsPort,
        0,
        0
        );

    return S_OK;


    //
    // Don't use creation and deletion events for now
    //
#if 0
    HANDLE          HandleDataChannelCreation = NULL;
    HANDLE          HandleDataChannelDeletion = NULL;

    HANDLE          MyHandleRegisteredCreation = NULL;
    HANDLE          MyHandleRegisteredDeletion = NULL;

    //
    // Get the CREATION handle
    //

    hr = pDataChannel->GetSessionCreationEventHandle((HANDLE_PTR *)&HandleDataChannelCreation);

    if ( SUCCEEDED(hr) )
    {
        MYTRACE("Creation Handle is %d", HandleDataChannelCreation);

        MyHandleRegisteredCreation = NhRegisterEvent(
            HandleDataChannelCreation,
            DataChannelCreationCallback,
            (PVOID)this,
            (PVOID)pDataChannel,
            DATA_CREATION_TIMEO
            );

        if ( MyHandleRegisteredCreation )
        {

            //
            // Get the DELETION handle
            //
            hr = pDataChannel->GetSessionDeletionEventHandle((HANDLE_PTR *)&HandleDataChannelDeletion);

            if ( SUCCEEDED(hr) )
            {
                MYTRACE("Deletion Handle is %d", HandleDataChannelDeletion);

                MyHandleRegisteredDeletion = NhRegisterEvent(
                    HandleDataChannelDeletion,
                    DataChannelDeletionCallback,
                    (PVOID)this,
                    (PVOID)pDataChannel,
                    INFINITE
                    );


                if ( MyHandleRegisteredDeletion )
                {
                    //
                    // We have a valid DataChannel
                    //
                    MYTRACE ("Inserting into DataChannelList");

                    m_DataChannelList.Insert(
                        pDataChannel,
                        icsPort,
                        MyHandleRegisteredCreation,
                        MyHandleRegisteredDeletion
                        );

                    return S_OK;
                }
                else
                {
                    MYTRACE_ERROR("NhRegisterEven(HandleDataChannelDeletion)", 0);
                }
            }
            else
            {
                MYTRACE_ERROR("GetSessionDeletionEventHandle",hr);
            }

        }
        else
        {
            MYTRACE_ERROR("NhRegisterEvent(HandleDataChannelCreation)", 0);
        }
    }
    else
    {
        MYTRACE_ERROR("GetSessionCreationEventHandle",hr);
    }

    //
    // ERROR if we got here, rollback
    //

    pDataChannel->Cancel();
    pDataChannel->Release();

    if ( MyHandleRegisteredCreation )
        NhUnRegisterEvent(MyHandleRegisteredCreation);

    if ( MyHandleRegisteredDeletion )
        NhUnRegisterEvent(MyHandleRegisteredDeletion);

    return hr; // return the last error
#endif
}


//
//
//
void
CFtpControlConnection::DataChannelDeletion(
    BOOLEAN TimerOrWait,
    PVOID   Context
    )
{
    MYTRACE_ENTER("CFtpControlConnection::DataChannelDeletion");

    USHORT port;
    IDataChannel *pDataChannel = (IDataChannel *)Context;
/*
    if (m_DataChannelList.Remove(pDataChannel,&port))
    {
        MYTRACE("Releasing Port");
        pDataChannel->Release();
        g_pIAlgServicesAlgFTP->ReleaseReservedPort(port,1);
        ULONG ref;
        ref = DecReference();
    }
*/
    return;
}




//
//
//
void
CFtpControlConnection::DataChannelCreation(
    BOOLEAN TimerOrWait,
    PVOID   Context
    )
{
    MYTRACE_ENTER("CFtpControlConnection::DataChannelCreation");
    MYTRACE("TimerOrWait: %d", TimerOrWait);

    USHORT port;
    if (TimerOrWait==0)
    {
/*
        IDataChannel *pDataChannel = (IDataChannel *)Context;
        HANDLE DeletionHandle;

        if ( m_DataChannelList.Remove(pDataChannel,&port,&DeletionHandle))
        {
            MYTRACE("Cancelling DataChannel");
            pDataChannel->Cancel();
            pDataChannel->Release();

            MYTRACE("Releasing Port");
            g_pIAlgServicesAlgFTP->ReleaseReservedPort(port,1);
            NhUnRegisterEvent(DeletionHandle);
            DecReference();
        }
*/
    }

    return;
}



CComAutoCriticalSection         m_AutoCS_FtpIO;



//
//
//
void
DataChannelCreationCallback(
    BOOLEAN TimerOrWait,
    PVOID   Context,
    PVOID   Context2
    )
{
    MYTRACE_ENTER("DataChannelCreationCallback");

    CFtpControlConnection *pFtpControl = (CFtpControlConnection *)Context;
    pFtpControl->DataChannelCreation(TimerOrWait,Context2);
}




//
//
//
void
DataChannelDeletionCallback(
    BOOLEAN TimerOrWait,
    PVOID   Context,
    PVOID   Context2
    )
{
    MYTRACE_ENTER("DataChannelDeletionCallback");

    CFtpControlConnection *pFtpControl = (CFtpControlConnection *)Context;
    pFtpControl->DataChannelDeletion(TimerOrWait,Context2);
}




//
//
//
void
MyAcceptCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    m_AutoCS_FtpIO.Lock();

    MYTRACE_ENTER("MyAcceptCompletion");

    CAlgFTP* pMainObj = (CAlgFTP*)Bufferp->Context;
    if ( pMainObj )
        pMainObj->AcceptCompletionRoutine(ErrCode,BytesTransferred,Bufferp);

    m_AutoCS_FtpIO.Unlock();

}




//
//
//
void
MyConnectCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  pContext
    )
{
    m_AutoCS_FtpIO.Lock();

    MYTRACE_ENTER("MyConnectCompletion");
   

    CFtpControlConnection* pControl = (CFtpControlConnection *)pContext;  // Special case here see socket.cpp MyHelperpConnectOrCloseCallbackRoutine

    if ( pControl )
        pControl->ConnectCompletionRoutine(ErrCode,BytesTransferred);

    m_AutoCS_FtpIO.Unlock();

}







//
//
//
void
MyReadCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    m_AutoCS_FtpIO.Lock();

    MYTRACE_ENTER("");
    
    CFtpControlConnection *pControl = (CFtpControlConnection *)Bufferp->Context;

    if ( pControl )
        pControl->ReadCompletionRoutine(ErrCode,BytesTransferred,Bufferp);
    else
    {
        MYTRACE_ENTER("ERROR ERROR ERROR MyReadCompletion");
    }

    m_AutoCS_FtpIO.Unlock();

}




//
//
//
void
MyWriteCompletion(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    m_AutoCS_FtpIO.Lock();    

    MYTRACE_ENTER("");

    CFtpControlConnection *pControl = (CFtpControlConnection *)Bufferp->Context;
    if ( pControl )
        pControl->WriteCompletionRoutine(ErrCode,BytesTransferred,Bufferp);
    else
    {
        MYTRACE_ENTER("ERROR ERROR ERROR MyWriteCompletion");
    }

    m_AutoCS_FtpIO.Unlock();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\myadapternotify.h ===
//
// MyAdapterNotify.h : Declaration of the CMyAdapterNotify
//

#pragma once



// {6E590D42-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_MyAdapterNotificationSink, 0x6e590d42, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);


/////////////////////////////////////////////////////////////////////////////
//
// CMyAdapterNotify
//
class ATL_NO_VTABLE CMyAdapterNotify : 
    public CComObjectRoot,
    public CComCoClass<CMyAdapterNotify, &CLSID_MyAdapterNotificationSink>,
    public IAdapterNotificationSink
{
public:
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CMyAdapterNotify)

BEGIN_COM_MAP(CMyAdapterNotify)
	COM_INTERFACE_ENTRY(IAdapterNotificationSink)
END_COM_MAP()


//
// IAdapterNotificationSink
//
public:
	STDMETHODIMP    AdapterAdded     (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterRemoved   (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterModified  (IAdapterInfo*   pAdapter);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\ftpcontrol.h ===
//
// Copyright (C) 2001 Microsoft Corp
//
// FtpControl.cpp 
//
// Sanjiv
// JPDup
//

#pragma once

class CFtpControlConnection;

//#include "PreComp.h"  // Theis FtpControl.h file get included by MyAlg.h that is used in the ALG.exe build
// so we can't use this precompile file
#include "buffer.h"
#include "list.h"


#define FTP_MAX_MSG_SIZE 1024

typedef enum _READ_TYPE 
{
    CLIENT_READ = 0x1,
    SERVER_READ = 0x2

} READ_TYPE;


typedef enum _CONNECTION_TYPE 
{
    INCOMING = 0x1,
    OUTGOING = 0x2

}CONNECTION_TYPE;

extern CControlObjectList g_ControlObjectList;




#define ERROR_IO_CANCELLED  0xC0000120
#define DATA_CREATION_TIMEO 1000
#define ADD_STR_SIZE        23




class CControlState 
{

public:
    ULONG   m_nAddressNew;
    ULONG   m_nAddressOld;

    USHORT  m_nPortNew;
    USHORT  m_nPortOld;
    
    UCHAR   m_szAddressPortNew[ADD_STR_SIZE];
    ULONG   m_nAddressLenNew;    
};



//
//
// Main class that controls the FTP
//
//
class CFtpControlConnection
{
public:
    // Constructor(s)
    CFtpControlConnection();

    // Destruction
    ~CFtpControlConnection();

//
// Properties
//
    SOCKET                          m_ClientConnectedSocket;
    SOCKET                          m_AlgConnectedSocket;
    USHORT                          m_nSourcePortReplacement;
private:

    IPendingProxyConnection*        m_pPendingProxy;

    CONNECTION_TYPE                 m_ConnectionType;    
    CControlState                   m_ControlState;  

    volatile LONG                   m_RefCount;

    CDataChannelList                m_DataChannelList;

//
// Methods
//
private:

    //
    void 
        ProcessFtpMessage(
            UCHAR*  Buffer,
            ULONG*   pBytes
            );

    //
    HRESULT 
        CreateNewAddress(void);

    //
    HRESULT 
        SetupDataRedirect(void);


public:  

    //
    ULONG 
        IncReference();

    //
    ULONG 
        DecReference();

    //
    void 
        Shutdown();


    //
    HRESULT 
        Init(
            SOCKET                          AcceptedSocket,
            ULONG                           ToAddr,
            USHORT                          ToPort,
            CONNECTION_TYPE                 ConnType
            );

    //
    void 
        DataChannelDeletion(
            BOOLEAN TimerOrWait,
            PVOID   Context
            );

    //
    void 
        DataChannelCreation(
            BOOLEAN TimerOrWait,
            PVOID   Context
            );

    //
    void 
        ConnectCompletionRoutine(
            ULONG       ErrCode,
            ULONG       BytesTransferred
            );

    //
    void 
        ReadCompletionRoutine(
            ULONG       ErrCode,
            ULONG       BytesTransferred,
            PNH_BUFFER  Bufferp
            );

    //
    void 
        WriteCompletionRoutine(
            ULONG       ErrCode,
            ULONG       BytesTransferred,
            PNH_BUFFER  Bufferp
            );
};



void 
DataChannelCreationCallback(
    BOOLEAN TimerOrWait,PVOID Context,PVOID Context2
    );

void 
DataChannelDeletionCallback(
    BOOLEAN TimerOrWait,PVOID Context,PVOID Context2
    );

void 
MyAcceptCompletion(
    ULONG ErrCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp);



void 
MyConnectCompletion(ULONG ErrCode,
                    ULONG BytesTransferred,
                    PNH_BUFFER Bufferp);
void 
MyReadCompletion(ULONG ErrCode,
                 ULONG BytesTransferred,
                 PNH_BUFFER Bufferp);
void 
MyWriteCompletion(ULONG ErrCode,
                  ULONG BytesTransferred,
                  PNH_BUFFER Bufferp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\list.h ===
//
// Collections(list) class
//

#pragma once

#include "regevent.h"


//
//
//
class CNode
{

public:
    CNode(
        VOID* pKey, 
        VOID* pKey2, 
        VOID* pContext, 
        VOID* pContext2, 
        VOID* pContext3
        )
    {
        m_pKey      = pKey;
        m_pKey2     = pKey2;
        m_pContext  = pContext;
        m_pContext2 = pContext2;
        m_pContext3 = pContext3;
    };

    VOID*   m_pKey;
    VOID*   m_pKey2;
    VOID*   m_pContext;
    VOID*   m_pContext2;
    VOID*   m_pContext3;
    CNode*  m_pNext;
};



//
//
//
class CGenericList
{
   
public:
    CRITICAL_SECTION    m_ObjectListCritical;

    CNode*              m_Head;

    CGenericList() 
    {
        m_Head = NULL;
        InitializeCriticalSection(&m_ObjectListCritical);
    };

    ~CGenericList()
    {
        DeleteCriticalSection(&m_ObjectListCritical);
    };

    BOOL Insert(VOID *key, VOID *key2, VOID *context, VOID *context2, VOID *context3);
    
    // removal based on first key
    BOOL RemoveKey(VOID *key, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3);
    
    // removal based on second key
    BOOL RemoveKey2(VOID **pkey, VOID *key2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3);

    // removal from list.
    BOOL Remove(VOID **pkey, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3);
};



//
//
//
class CControlObjectList
{
private:
    CGenericList     m_ControlObjectList;
    
public:

    ULONG            m_NumElements;

    CControlObjectList() 
    { 
        m_NumElements = 0; 
    };
    
    BOOL Insert(CFtpControlConnection *pControlConnection);
    
    BOOL Remove(CFtpControlConnection *pControlConnection);
    
    bool
    IsSourcePortAvailable(
        ULONG   nPublicSourceAddress,
        USHORT  nPublicSourcePortToVerify
        );

    void ShutdownAll();

    
};


//
//
//
class CDataChannelList
{
private:
    CGenericList    m_DataChannelObjectList;
    ULONG           m_NumElements;

public:
    CDataChannelList() 
    { 
        m_NumElements = 0; 
    };

    BOOL Insert(IDataChannel *pDataChannel,USHORT icsPort,HANDLE CreationHandle,HANDLE DeletionHandle);

    BOOL Remove(IDataChannel **pDataChannel,USHORT *icsPort,HANDLE *CreationHandle,HANDLE *DeletionHandle);

    BOOL Remove(IDataChannel *pDataChannel,USHORT *icsPort);
    
    BOOL Remove(IDataChannel *pDataChannel,USHORT *icsPort,HANDLE *DeletionHandle);

};


//
//
//
class CRegisteredEventList
{    
private:
    CGenericList    m_RegEventObjectList;
    ULONG           m_NumElements;

public:
    CRegisteredEventList() { m_NumElements = 0; };

    BOOL Insert(HANDLE WaitHandle, HANDLE hEvent,EVENT_CALLBACK CallBack, void *Context, void *Context2);
    
    BOOL Remove(HANDLE WaitHandle, HANDLE *hEvent);
    
    BOOL Remove(HANDLE *WaitHandle, HANDLE hEvent,EVENT_CALLBACK *CallBack,void **context,void **context2);
};

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\list.cpp ===
#include "precomp.h"
#include "myalg.h"

//
//
//
BOOL 
CGenericList::Insert(VOID *key, VOID *key2, VOID *context, VOID *context2, VOID *context3)
{
    CNode* pNode = new CNode(key,key2,context,context2,context3);

    if (pNode == NULL)
        return FALSE;

    EnterCriticalSection(&m_ObjectListCritical);
    pNode->m_pNext = m_Head;
    m_Head = pNode;
    LeaveCriticalSection(&m_ObjectListCritical);

    return TRUE;
}


//
//
//
BOOL 
CGenericList::RemoveKey(VOID *key, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3)
{
    BOOL retval = TRUE;
    EnterCriticalSection(&m_ObjectListCritical);
    if (m_Head) 
    {
        CNode* pNode = m_Head;
        if ((ULONG_PTR)key == (ULONG_PTR)pNode->m_pKey) 
        {
            m_Head = m_Head->m_pNext;
        }
        else 
        {
            CNode* pNodepre;
            while (pNode && (ULONG_PTR)pNode->m_pKey != (ULONG_PTR)key) 
            {
                pNodepre = pNode;
                pNode = pNode->m_pNext;
            }

            if ( pNode ) 
            {
                pNodepre->m_pNext = pNode->m_pNext;
            }
        }

        LeaveCriticalSection(&m_ObjectListCritical);

        if ( pNode ) 
        {
            if (pkey2)
                *pkey2 = pNode->m_pKey2;

            if (pcontext)
                *pcontext = pNode->m_pContext;

            if (pcontext2)
                *pcontext2 = pNode->m_pContext2;

            if (pcontext3)
                *pcontext3 = pNode->m_pContext3;

            delete pNode;
        }
        else
        {
            retval = FALSE;
        }
    }
    else 
    {
        LeaveCriticalSection(&m_ObjectListCritical);
        retval = FALSE;
    }
    return retval;
}



//
// removal based on second key
//
BOOL 
CGenericList::RemoveKey2(VOID **pkey, VOID *key2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3)
{
    BOOL retval = TRUE;
    EnterCriticalSection(&m_ObjectListCritical);
    if (m_Head) 
    {
        CNode* pNode = m_Head;
        if ( (ULONG_PTR)key2 == (ULONG_PTR)pNode->m_pKey2 ) 
        {
            m_Head = m_Head->m_pNext;
        }
        else 
        {
            CNode* pNodepre;
            while (pNode && (ULONG_PTR)pNode->m_pKey2 != (ULONG_PTR)key2) 
            {
                pNodepre = pNode;
                pNode = pNode->m_pNext;
            }

            if (pNode) 
            {
                pNodepre->m_pNext = pNode->m_pNext;
            }
        }

        LeaveCriticalSection(&m_ObjectListCritical);

        if (pNode) 
        {
            if (pkey)
                *pkey       = pNode->m_pKey;
            if (pcontext)
                *pcontext   = pNode->m_pContext;

            if (pcontext2)
                *pcontext2  = pNode->m_pContext2;

            if (pcontext3)
                *pcontext3  = pNode->m_pContext3;

            delete pNode;
        }
        else
            retval = FALSE;
    }
    else 
    {
        LeaveCriticalSection(&m_ObjectListCritical);
        retval = FALSE;
    }
    return retval;
}



//
// removal from beginning of list
//
BOOL 
CGenericList::Remove(VOID **pkey, VOID **pkey2, VOID **pcontext, VOID **pcontext2, VOID **pcontext3)
{
    BOOL retval = TRUE;
    EnterCriticalSection(&m_ObjectListCritical);
    CNode* pNode = m_Head;

    if (pNode) 
    {
        m_Head = pNode->m_pNext;
    }

    LeaveCriticalSection(&m_ObjectListCritical);

    if (pNode) 
    {
        if (pkey)
            *pkey       = pNode->m_pKey;
        if (pkey2)
            *pkey2      = pNode->m_pKey2;
        if (pcontext)
            *pcontext   = pNode->m_pContext;
        if (pcontext2)
            *pcontext2  = pNode->m_pContext2;
        if (pcontext3)
            *pcontext3  = pNode->m_pContext3;

        delete pNode;
    }
    else 
    {
        retval = FALSE;
    }
    return retval;
}



//
//
//
BOOL 
CControlObjectList::Insert(CFtpControlConnection *pControlConnection)
{
    MYTRACE_ENTER("CControlObjectList::Insert");
    BOOL retval = m_ControlObjectList.Insert(pControlConnection,NULL,NULL,NULL,NULL);
    if (retval) {
        ++m_NumElements;
        MYTRACE("Inserting %x Number of Elements %d",pControlConnection,m_NumElements);
    }
    else {
        MYTRACE("Error Inserting into list");
    }

    return retval;
}


extern HANDLE g_hNoMorePendingConnection; // see MyAlg.cpp

//
//
//
BOOL 
CControlObjectList::Remove(CFtpControlConnection *pControlConnection)
{
    MYTRACE_ENTER("CControlObjectList::Remove");   
    BOOL retval = m_ControlObjectList.RemoveKey(pControlConnection,NULL,NULL,NULL,NULL);
    if (retval) {
        --m_NumElements;
        MYTRACE("Number of elements remaining %d",m_NumElements);
    }
    else {
        MYTRACE("Not found");
    }

    
    if ( m_NumElements == 0 )
    {

        MYTRACE("No more connection");

        if ( g_hNoMorePendingConnection )
        {
            MYTRACE("Must be in stop so signal g_hNoMorePendingConnection");
            SetEvent(g_hNoMorePendingConnection);
        }
    }

    return retval;
}



//
//
//
void
CControlObjectList::ShutdownAll()
{
    MYTRACE_ENTER("CControlObjectList::ShutdownAll");

    EnterCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));
    MYTRACE("List contains %d CFTPcontrolConnection", m_NumElements);
    if ( m_ControlObjectList.m_Head )
    {
        CNode* pNode = (CNode*)m_ControlObjectList.m_Head;

        while ( pNode )
        {
            CFtpControlConnection* pFtpCtrl = (CFtpControlConnection*)pNode->m_pKey;

            closesocket(pFtpCtrl->m_AlgConnectedSocket);
            pFtpCtrl->m_AlgConnectedSocket = INVALID_SOCKET;


            closesocket(pFtpCtrl->m_ClientConnectedSocket);
            pFtpCtrl->m_ClientConnectedSocket=INVALID_SOCKET;

            pNode = pNode->m_pNext;
        }
    }

    LeaveCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));
}




//
// Return false if the given port is currently in use for the give address
// else return it's available and return true
//
bool
CControlObjectList::IsSourcePortAvailable(
    ULONG   nPublicSourceAddress,
    USHORT  nPublicSourcePortToVerify
    )
{
    MYTRACE_ENTER("CControlObjectList::IsSourcePortAvailable");

    EnterCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));

    MYTRACE("List contains %d CFTPcontrolConnection", m_NumElements);

    if ( m_ControlObjectList.m_Head )
    {
        CNode* pNode = (CNode*)m_ControlObjectList.m_Head;

        while ( pNode )
        {
            CFtpControlConnection* pFtpCtrl = (CFtpControlConnection*)pNode->m_pKey;

            ULONG  nClientSourceAddress;
            USHORT nClientSourcePort;

            ULONG Err = MyHelperQueryRemoteEndpointSocket(
                pFtpCtrl->m_ClientConnectedSocket,
                &nClientSourceAddress,
                &nClientSourcePort
                );

            if ( 0 == Err )
            {

                if ( nClientSourceAddress == nPublicSourceAddress )
                {
                    MYTRACE("Source Address %s:%d substitude %d", 
                        MYTRACE_IP(nClientSourceAddress), 
                        ntohs(nClientSourcePort), 
                        pFtpCtrl ->m_nSourcePortReplacement
                        );

                    if ( nPublicSourcePortToVerify == nClientSourcePort ||
                         nPublicSourcePortToVerify == pFtpCtrl->m_nSourcePortReplacement
                        )
                    {
                        MYTRACE("Already in use");
                        LeaveCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));
                        return false;
                    }
                }
            }
            else
            {
                MYTRACE_ERROR("From MyHelperQueryRemoteEndpointSocket", Err);
            }

            pNode = pNode->m_pNext;
        }
    }

    LeaveCriticalSection(&(m_ControlObjectList.m_ObjectListCritical));

    return true;
}



//
//
//
BOOL 
CDataChannelList::Insert(IDataChannel *pDataChannel,USHORT icsPort,HANDLE CreationHandle,HANDLE DeletionHandle)
{
    MYTRACE_ENTER("CDataChannelList::Insert");
    MYTRACE("Inserting %x",pDataChannel);
    BOOL retval = m_DataChannelObjectList.Insert(pDataChannel,(VOID *)icsPort,CreationHandle,DeletionHandle,NULL);
    if (retval) {
        MYTRACE("Number of elements %d",++m_NumElements);
    }
    else {
        MYTRACE("Unable to insert");
    }
    return retval;
}


//
//
//
BOOL 
CDataChannelList::Remove(IDataChannel **pDataChannel,USHORT *picsPort,HANDLE *pCreationHandle,HANDLE *pDeletionHandle)
{
    MYTRACE_ENTER("CDataChannelList::Remove");
    BOOL retval;
    retval = m_DataChannelObjectList.Remove((VOID **)pDataChannel,(VOID **)picsPort,pCreationHandle,pDeletionHandle,NULL);
    if (retval) {
        MYTRACE("Number of elements remaining %d",--m_NumElements);
    }
    else {
        MYTRACE("No more elements to remove");
    }

    return retval;
}


//
//
//
BOOL 
CDataChannelList::Remove(IDataChannel *pDataChannel,USHORT *picsPort)
{
    MYTRACE_ENTER("CDataChannelList::Remove");
    BOOL retval = m_DataChannelObjectList.RemoveKey(pDataChannel,(VOID **)picsPort,NULL,NULL,NULL);
    if (retval) {
        MYTRACE("Number of elements remaining %d",--m_NumElements);
    }
    else {
        MYTRACE("Element not found");
    }

    return retval;
}


//
//
//
BOOL 
CDataChannelList::Remove(IDataChannel *pDataChannel,USHORT *picsPort,HANDLE *pDeletionHandle)
{
    MYTRACE_ENTER("CDataChannelList::Remove");    
    BOOL retval = m_DataChannelObjectList.RemoveKey(pDataChannel,(VOID **)picsPort,NULL,pDeletionHandle,NULL);
    if (retval) {
        MYTRACE("Number of elements remaining %d",--m_NumElements);
    }
    else {
        MYTRACE("Element not found");
    }
    return retval;
}


//
//
//
BOOL 
CRegisteredEventList::Insert(HANDLE WaitHandle, HANDLE hEvent,EVENT_CALLBACK CallBack, void *Context, void *Context2)
{
    MYTRACE_ENTER("CRegisteredEventList::Insert");
    BOOL retval = m_RegEventObjectList.Insert(WaitHandle,hEvent,CallBack,Context,Context2);
    if (retval) {
        MYTRACE("Number of elements %d",++m_NumElements);
    }
    else {
        MYTRACE("Error Inserting");
    }
    return retval;
}

//
//
//
BOOL 
CRegisteredEventList::Remove(HANDLE WaitHandle, HANDLE *phEvent)
{
    MYTRACE_ENTER("CRegisteredEventList::Remove");
    BOOL retval = m_RegEventObjectList.RemoveKey(WaitHandle,phEvent,NULL,NULL,NULL);
    if (retval) {
        MYTRACE("Removal on WaitHandle Number of elements %d",--m_NumElements);
    }
    else {
        MYTRACE("Element WaitHandle on not found");
    }
    return retval;
}


//
//
//
BOOL 
CRegisteredEventList::Remove(HANDLE *pWaitHandle, HANDLE hEvent,EVENT_CALLBACK *pCallBack,void **pcontext,void **pcontext2)
{
    MYTRACE_ENTER("CRegisteredEventList::Remove");
    BOOL retval = m_RegEventObjectList.RemoveKey2(pWaitHandle,hEvent,(VOID **)pCallBack,pcontext,pcontext2);
    if (retval) {
        MYTRACE("Removal on EventHandle Number of elements %d",--m_NumElements);
    }
    else {
        MYTRACE("Element EventHandle not found");
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\myalg.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// MyAlg.cpp : Implementation of DLL Exports.
//
// Sanjiv
// JPDup
//

#include "PreComp.h"

#include "MyAlg.h"


CControlObjectList              g_ControlObjectList;
IApplicationGatewayServices*    g_pIAlgServicesAlgFTP = NULL;
USHORT                          g_nFtpPort=0;
HANDLE                          g_hNoMorePendingConnection=NULL;
bool                            g_bStoping = false;

//
//  got to move WSAStartup to Initialize
//
CAlgFTP::CAlgFTP ()
{
    MYTRACE_ENTER("CAlgFTP::CAlgFTP ");

    m_ListenAddress = 0;
    m_ListenPort = 0;
    m_ListenSocket = INVALID_SOCKET;
    m_pPrimaryControlChannel = NULL;
    m_hNoMoreAccept = NULL;
    g_bStoping = false;
    

    WSADATA wsaData;
    DWORD Err;
    Err = WSAStartup(MAKEWORD(2,2),&wsaData);
    _ASSERT(Err == 0);

    MyHelperInitializeBufferManagement();
}



//
// Destructor
//
CAlgFTP ::~CAlgFTP ()
{
    MYTRACE_ENTER("CAlgFTP::~CAlgFTP ");


    if ( g_pIAlgServicesAlgFTP ) 
    {
        MYTRACE("Releasing AlgServices");
        g_pIAlgServicesAlgFTP->Release();
        g_pIAlgServicesAlgFTP = NULL;
    }


    if ( g_hNoMorePendingConnection )
    {
        CloseHandle(g_hNoMorePendingConnection);
        g_hNoMorePendingConnection = NULL;
    }

    if ( m_hNoMoreAccept )
    {
        CloseHandle(m_hNoMoreAccept);
        m_hNoMoreAccept = NULL;
    }

   

    WSACleanup();
    MyHelperShutdownBufferManagement();
}


//
//  Initialize can be called in two cases
//  1. From the main IApplicationGateway::Initialize
//  2. From AcceptCompletionRoutine when some FatalSocket Error has occured, which forced the
//     closure of the m_ListenSocket and all the control connections/data connections etc.
//     (This call to ShutDown will terminate all current ControlSessions. Might not be necessary.
//     But if AcceptCompletion returned error we do it anyway.)
//
STDMETHODIMP  
CAlgFTP ::Initialize(
    IApplicationGatewayServices * pAlgServices
    )
{
    MYTRACE_ENTER("CAlgFTP::Initialize");
   
    pAlgServices->AddRef();
    g_pIAlgServicesAlgFTP = pAlgServices;
    
    if ( FAILED(GetFtpPortToUse(g_nFtpPort)) )
        g_nFtpPort = 21;    // Use the standard ftp port 21

    MYTRACE("USING FTP PORT %d", g_nFtpPort);


    HRESULT hr = RedirectToMyPort();

    if ( FAILED(hr) )
        CleanUp();

    return hr;
}




//
//  ALG.exe will call this interface to terminat
//  this ALG FTP PlugIn
//      
STDMETHODIMP
CAlgFTP::Stop()
{
    MYTRACE_ENTER("CAlgFTP::Stop");
    
    CleanUp();

    return S_OK;
}


#define REG_KEY_ALG_FTP     TEXT("SOFTWARE\\Microsoft\\ALG\\ISV\\{6E590D61-F6BC-4dad-AC21-7DC40D304059}")
#define REG_VALUE_FTP_PORT  TEXT("UsePort")

HRESULT
CAlgFTP::GetFtpPortToUse(
    USHORT& usPort
    )
{
    MYTRACE_ENTER("CAlgFTP:GetFtpPortToUse");

    DWORD dwPort = 0;

    //
    // Did you modify the default FTP Port
    //
    LONG lRet;
    CRegKey RegKeyAlgFTP;

    MYTRACE("Looking in RegKey \"%S\"", REG_KEY_ALG_FTP);

    lRet = RegKeyAlgFTP.Open(HKEY_LOCAL_MACHINE, REG_KEY_ALG_FTP, KEY_READ);
    if ( ERROR_SUCCESS == lRet )
    {
        LONG lRet = RegKeyAlgFTP.QueryValue(dwPort, REG_VALUE_FTP_PORT);

        if ( ERROR_SUCCESS == lRet )
        {   
            MYTRACE("Found the \"%S\" value %d", REG_VALUE_FTP_PORT, dwPort);
            usPort = (USHORT) dwPort;
        }
        else
        {
            MYTRACE("\"%S\" Value not set", REG_VALUE_FTP_PORT);
            return E_FAIL;
        }
    }
    else
    {
        MYTRACE("Could not open regkey", lRet);
        return E_FAIL;
    }   

    return S_OK;
}


extern CComAutoCriticalSection         m_AutoCS_FtpIO;  // See FtpControl.cpp


//
//
//
void
CAlgFTP::CleanUp()
{
    MYTRACE_ENTER("CAlgFTP::CleanUp()");

    g_bStoping = true;

    //
    // Free socket
    //
    if ( INVALID_SOCKET != m_ListenSocket ) 
    {
        MYTRACE("CAlgFTP::STOP ACCEPTING NEW CONNECTION !!");

        m_AutoCS_FtpIO.Lock();

        m_hNoMoreAccept = CreateEvent(NULL, false, false, NULL);

        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;


        m_AutoCS_FtpIO.Unlock();

        if ( m_hNoMoreAccept )
        {
            WaitForSingleObject(
                m_hNoMoreAccept,
                INFINITE
                );
        }
    }	



    if ( m_pPrimaryControlChannel ) 
    {
        MYTRACE("Cancelling PrimaryControl");
        HRESULT hr = m_pPrimaryControlChannel->Cancel();
        
        MYTRACE("Releasing Primary");
        m_pPrimaryControlChannel->Release();
        m_pPrimaryControlChannel = NULL;
    }

    m_AutoCS_FtpIO.Lock();
  
    if ( g_ControlObjectList.m_NumElements == 0 )
    {
        MYTRACE("List for FTPconnections is empty");
        m_AutoCS_FtpIO.Unlock();
    }   
    else
    {
        //
        // Pending connection are still active
        // shut them down a wait till the last one is free
        //

        MYTRACE("Empty the list of FTPconnections (%d)", g_ControlObjectList.m_NumElements);
        g_hNoMorePendingConnection = CreateEvent(NULL, false, false, NULL);

        MYTRACE("Closing all connections");
        g_ControlObjectList.ShutdownAll();  



        m_AutoCS_FtpIO.Unlock();
    
        MYTRACE("Waiting for last connection to notify us");
        WaitForSingleObject(
            g_hNoMorePendingConnection,
            2000    // Will give them 2 second max to close  vs using INFINITE
            );

        MYTRACE("Got signal no more pending connection");
    }

}



/*
  We have this private function to get the OriginalDestionationInfo  
  and to get the type of connection it is. Whether it is INCOMING or OUTGOING.
*/
HRESULT 
CAlgFTP::MyGetOriginalDestinationInfo(
    PUCHAR              AcceptBuffer,
    ULONG*              pAddr,
    USHORT*             pPort,
    CONNECTION_TYPE*    pConnType
    )
{
    MYTRACE_ENTER("CAlgFTP::MyGetOriginalDestinationInfo");

    IAdapterInfo *pAdapterInfo = NULL;
    HRESULT hr = S_OK;
    ULONG RemoteAddr = 0;
    USHORT RemotePort = 0;
    ALG_ADAPTER_TYPE Type;

    
    MyHelperQueryAcceptEndpoints(
        AcceptBuffer,
        0,
        0,
        &RemoteAddr,
        &RemotePort
        );

    MYTRACE("Source Address %s:%d", MYTRACE_IP(RemoteAddr), ntohs(RemotePort));

    hr = m_pPrimaryControlChannel->GetOriginalDestinationInformation(
        RemoteAddr,
        RemotePort,
        pAddr,
        pPort,
        &pAdapterInfo
        );


    if ( SUCCEEDED(hr) ) 
    {
        hr = pAdapterInfo->GetAdapterType(&Type);

        if (SUCCEEDED(hr) ) 
        {
            ULONG   ulAddressCount;
            ULONG*  arAddresses;
        
            hr = pAdapterInfo->GetAdapterAddresses(&ulAddressCount, &arAddresses);

            if ( SUCCEEDED(hr) )
            {
                if ( ulAddressCount > 0 )
                {
                    bool bFromIcsBox = FALSE;
                    while (ulAddressCount && !bFromIcsBox) {
                       if (arAddresses[--ulAddressCount] == RemoteAddr)
                           bFromIcsBox = TRUE;
                    }
                    
                    MYTRACE("Address count %d  address[0] %s", ulAddressCount, MYTRACE_IP(arAddresses[0]));
                    
                    switch (Type) 
                    {
                    case eALG_PRIVATE:
                        MYTRACE("Adapter is Private");
                        if ( bFromIcsBox )
                        {
                            *pConnType = INCOMING;
                            MYTRACE("InComing");
                        }
                        else
                        {
                            *pConnType = OUTGOING;
                            MYTRACE("OutGoing");
                        }
                        break;
                        
                    
                    case eALG_BOUNDARY:
                    case eALG_FIREWALLED:
                    case eALG_BOUNDARY|eALG_FIREWALLED:

                        MYTRACE("Adapter is Public or/and Firewalled");
    
                        if ( bFromIcsBox )
                        {
                            *pConnType = OUTGOING;
                            MYTRACE("OutGoing");
                        }
                        else
                        {
                            *pConnType = INCOMING;
                            MYTRACE("InComing");
                        }
                        break;
                        
                       
                        
                    default:     
                        MYTRACE("Adapter is ????");
                        _ASSERT(FALSE);
                        hr = E_FAIL;
                        break;
                    }
                }
            }
            CoTaskMemFree(arAddresses);
        }

        pAdapterInfo->Release();

    }
	else
	{
		MYTRACE_ERROR("from GetOriginalDestinationInformation", hr);
	}
	




    return hr;
}








/*
  Can be called in 2 cases.
  1. AcceptEx has actually succeeded or failed
     If Succeeded we make a new CFtpControlConnection giving it the AcceptedSocket
       And reissue the Accept
     If Failed and not fatal failure we just reissue the Accept
     If Failed and Fatal Failure we ShutDown gracefully. Restart the a new listen

  2. Because we closed the listening socket in STOP => ErrCode = ERROR_IO_CANCELLED
      in which case we just return
*/

void 
CAlgFTP::AcceptCompletionRoutine(
    ULONG       ErrCode,
    ULONG       BytesTransferred,
    PNH_BUFFER  Bufferp
    )
{
    MYTRACE_ENTER("CAlgFTP::AcceptCompletionRoutine");


#if defined(DBG) || defined(_DEBUG)
    if ( 0 != ErrCode )
    {
        MYTRACE("ErrCode : %x", ErrCode);
        MYTRACE("MyHelperIsFatalSocketError(ErrCode) is %d", MyHelperIsFatalSocketError(ErrCode));
    }
#endif

    ULONG           OriginalAddress = 0;
    USHORT          OriginalPort = 0;
    CONNECTION_TYPE ConnType;  
    HRESULT         hr;
    ULONG           Err;


    if ( ERROR_IO_CANCELLED == ErrCode  || g_bStoping ) 
    {
        MYTRACE("CAlgFTP::AcceptCompletionRoutine-ERROR_IO_CANCELLED");

        //
        // Ok we are closing here MyAlg->Stop got called
        // no need to attemp a new Listen/Accept incoming
        //
        MYTRACE("------NORMAL TERMINATION (not creating a new listen/accept)-----");

        MyHelperReleaseBuffer(Bufferp);

        if ( m_hNoMoreAccept )
            SetEvent(m_hNoMoreAccept);

        return; // Normal termination
    }


    SOCKET AcceptedSocket = Bufferp->Socket;

    if ( ErrCode && MyHelperIsFatalSocketError(ErrCode) ) 
    {
        MYTRACE_ERROR("CAlgFTP::AcceptCompletionRoutine-FATAL ERROR", ErrCode);


        //
        // Socket Routines says that we have a problem
        // so clean up and try a new redirection
        //

        
        if ( AcceptedSocket != INVALID_SOCKET ) 
        {
            MYTRACE("CLOSING ACCEPTED SOCKET!!");
            closesocket(AcceptedSocket);      
        }

        hr = RedirectToMyPort();

        MyHelperReleaseBuffer(Bufferp);
        return;
    }



    if ( 0 == ErrCode ) 
    {    

        //
        // Everything is good lets accept the connection
        //
        hr = MyGetOriginalDestinationInfo(Bufferp->Buffer,&OriginalAddress,&OriginalPort,&ConnType);
 
        if ( SUCCEEDED(hr) ) 
        {  
            Err = setsockopt(
                AcceptedSocket,
                SOL_SOCKET,
                SO_UPDATE_ACCEPT_CONTEXT,
                (char *)&m_ListenSocket,
                sizeof(m_ListenSocket)
                );
 
            MYTRACE("setsockopt SO_UPDATE_ACCEPT_CONTEXT %x", Err);
            CFtpControlConnection *pFtpControlConnection = new CFtpControlConnection;

            if ( pFtpControlConnection )
            {
                hr = pFtpControlConnection->Init(
                    AcceptedSocket,
                    OriginalAddress,
                    OriginalPort,
                    ConnType
                    );
  
                if ( SUCCEEDED(hr) )
                {
                    g_ControlObjectList.Insert(pFtpControlConnection);
                }
                else
                {
                    MYTRACE_ERROR("pFtpControlConnection->Init failed", hr);
        
                    // No need to close at this time the closesocket(AcceptedSocket);
                    // when the Init fails it will deref the newly created CFtpControlConnection 
                    // and will hit ZERO ref count and close the socket
                }
            }
            else
            {
                MYTRACE_ERROR("memory low, new pFtpControlConnection failed - CLOSING ACCEPTED SOCKET!!", 0);
            
                if ( AcceptedSocket != INVALID_SOCKET ) 
                    closesocket(AcceptedSocket);
            }
        }
        else 
        {
            MYTRACE_ERROR("MyGetOriginalDestinationInfo failed - CLOSING ACCEPTED SOCKET!!", hr);
    
            if ( AcceptedSocket != INVALID_SOCKET ) 
                closesocket(AcceptedSocket);
        }

        AcceptedSocket = INVALID_SOCKET;      

   }


    Err = MyHelperAcceptStreamSocket(
        NULL,
        m_ListenSocket,
        AcceptedSocket,
        Bufferp,
        MyAcceptCompletion,
        (void *)this,
        NULL
        );  

    if ( Err )  
    {
        MYTRACE_ERROR("From MyHelperAcceptStreamSocket", Err);


        if ( AcceptedSocket != INVALID_SOCKET ) 
        {
            MYTRACE("CLOSING ACCEPTED SOCKET!!");
            closesocket(AcceptedSocket);      
            AcceptedSocket = INVALID_SOCKET;
        }
        

        RedirectToMyPort();
        MyHelperReleaseBuffer(Bufferp);

    }


    return;
}






//
//  called From InitCAlgFTP
//  Will just create a socket bound to LOOP BACK adapter.
//
ULONG 
CAlgFTP::MakeListenerSocket()
{
    MYTRACE_ENTER("CAlgFTP::MakeListenerSocket");


    if ( INVALID_SOCKET != m_ListenSocket )
    {
        //
        // Since this function is call on the starting point (See Initialize)
        // and also when a Accept error occured and needs a new redirect
        // we may already have a Socket created so let's free it 
        //
        MYTRACE ("Remove current ListenSocket");
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
    }

    ULONG Err;

    ULONG Addr = inet_addr("127.0.0.1");
    Err = MyHelperCreateStreamSocket(Addr,0,&m_ListenSocket);

    if ( ERROR_SUCCESS == Err ) 
    {
        Err = MyHelperQueryLocalEndpointSocket(m_ListenSocket,&m_ListenAddress,&m_ListenPort);
        MYTRACE ("Listen on %s:%d", MYTRACE_IP(m_ListenAddress), ntohs(m_ListenPort));
    }
    else
    {
        MYTRACE_ERROR("MyHelperCreateStreamSocket", Err);
    }

    _ASSERT(Err == 0);

    return Err;
}



//
// Redirect trafic destinated for PORT FTP_CONTROL_PORT(21) 
// to our listening socket (127.0.0.1) port (Allocated by MakeListenerSocket())
//
ULONG 
CAlgFTP::RedirectToMyPort()
{
    MYTRACE_ENTER("CAlgFTP::RedirectToMyPort()");


    if ( ERROR_SUCCESS == MakeListenerSocket() ) 
    {
        if ( m_pPrimaryControlChannel )
        {
            //
            // Since this function is call on the starting point (See Initialize)
            // and also when a Accept error occured and needs a new redirect
            // we may already have a PrimaryControlChannel created so let's free it 
            //
            MYTRACE("Releasing PrimaryControl");
            m_pPrimaryControlChannel->Cancel();
            m_pPrimaryControlChannel->Release();
            m_pPrimaryControlChannel = NULL;
        }

        //
        // ask for a redirection
        //
        HRESULT hr = g_pIAlgServicesAlgFTP->CreatePrimaryControlChannel(
            eALG_TCP,
            htons(g_nFtpPort),    // 21 is the most common one
            eALG_DESTINATION_CAPTURE,
            TRUE,
            m_ListenAddress,
            m_ListenPort,
            &m_pPrimaryControlChannel
            );

        if ( SUCCEEDED(hr) )
        {

            //
            // Start listening
            //
            int nRetCode = listen( m_ListenSocket, 5);

            if ( SOCKET_ERROR != nRetCode )
            {

                ULONG Err = MyHelperAcceptStreamSocket(
                    NULL,
                    m_ListenSocket,
                    INVALID_SOCKET,
                    NULL,
                    MyAcceptCompletion,
                    (void *)this,NULL
                    );    

                if ( ERROR_SUCCESS == Err )
                {
                    return S_OK;
                }
                else
                {
                    MYTRACE_ERROR("FAILED TO START ACCEPT on 127.0.0.1:", Err);
                }
            }
            else
            {
                MYTRACE_ERROR("listen() failed ", nRetCode);
            }
        }
        else
        {
            MYTRACE_ERROR("from CreatePrimaryControlChannel", hr);

        }

    }


    //
    // if we got here that mean that one of the step above faild
    // 
    MYTRACE_ERROR("Failed to RedirectToPort",E_FAIL)
    CleanUp();

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\myalg.h ===
//
// AlgFTP.h : Declaration of the CAlgFTP
//
#pragma once

#include "FtpControl.h"

// {6E590D61-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_AlgFTP, 0x6e590d61, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);


extern IApplicationGatewayServices*  g_pIAlgServicesAlgFTP;
extern USHORT                        g_nFtpPort;           // By Default this will be 21 band can be overwritten by
                                                           // a RegKey see MyAlg.cpp->Initialize




/////////////////////////////////////////////////////////////////////////////
//
// CAlgFTP
//
class ATL_NO_VTABLE CAlgFTP: 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAlgFTP, &CLSID_AlgFTP>,
    public IApplicationGateway
{
public:
    CAlgFTP();
    ~CAlgFTP();


public:
//    DECLARE_REGISTRY(CAlgFTP, TEXT("ALG_FTP.MyALG.1"), TEXT("ALG_FTP.MyALG"), -1, THREADFLAGS_BOTH)
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CAlgFTP)

BEGIN_COM_MAP(CAlgFTP)
	COM_INTERFACE_ENTRY(IApplicationGateway) 
END_COM_MAP()

//
// IApplicationGateway
//
public:
	STDMETHODIMP Initialize(
        IApplicationGatewayServices* pIAlgServices
        );

	STDMETHODIMP Stop(
        void
        );
        

//
// Properties
//
private:
    HANDLE                        m_hNoMoreAccept;

public:

    IPrimaryControlChannel*       m_pPrimaryControlChannel;

    ULONG                         m_ListenAddress;
    USHORT                        m_ListenPort;
    SOCKET                        m_ListenSocket;



//
// Methods
//
public:

    //
    HRESULT
    GetFtpPortToUse(
        USHORT& usPort
        );

    //
    void
    CleanUp();

    //
    HRESULT 
    MyGetOriginalDestinationInfo(
        PUCHAR              Buffer,
        ULONG*              pAddr,
        USHORT*             pPort,
        CONNECTION_TYPE*    pConnType
        );
	
    //
    ULONG 
    MakeListenerSocket();

    //
    ULONG 
    RedirectToMyPort();

    //
    void 
    AcceptCompletionRoutine(
        ULONG       ErrCode,
        ULONG       BytesTransferred,
        PNH_BUFFER  Bufferp
        );



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\regevent.h ===
#ifndef __REGEVENT_H
#define __REGEVENT_H

typedef VOID (*EVENT_CALLBACK)(BOOLEAN TimerOrWait,VOID *Context,VOID *Context2);
HANDLE
NhRegisterEvent(HANDLE hEvent,EVENT_CALLBACK CallBack,VOID *Context,VOID *Context2,ULONG TimeOut);
/*
  VOID
  NhInitializeCallBack(VOID);
  
  VOID
  NhShutdownCallBack(VOID);
*/

VOID
NhUnRegisterEvent(HANDLE WaitHandle);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\regevent.cpp ===
#include "precomp.h"
#include "list.h"


CRegisteredEventList g_RegisteredEventList;

VOID
NhInitializeCallBack(VOID) 
{
    return;
}

//
//
//
VOID
NhUnRegisterEvent(HANDLE WaitHandle)
{
  HANDLE hEvent;
  UnregisterWaitEx(WaitHandle,INVALID_HANDLE_VALUE);
  g_RegisteredEventList.Remove(WaitHandle,&hEvent);
  CloseHandle(hEvent);
  return;
}


//
//
//
VOID
NhEventCallBackFunction(
    PVOID   Context,
	BOOLEAN TimerOrWait
    )
{
  HANDLE hEvent = (HANDLE)Context;
  HANDLE WaitHandle;
  VOID *Context1;
  VOID *Context2;
  EVENT_CALLBACK CallBack;
  g_RegisteredEventList.Remove(&WaitHandle,hEvent,&CallBack,&Context1,&Context2);
  CloseHandle(hEvent);
  (*CallBack)(TimerOrWait,Context1,Context2);
  return;
}


//
//
//
HANDLE
NhRegisterEvent(
    HANDLE          hEvent,
    EVENT_CALLBACK  CallBack,
    VOID*           Context,
    VOID*           Context2,
    ULONG           TimeOut
    )
{
  VOID *nContext;
  HANDLE WaitHandle = NULL;
  BOOL Err;
  Err = RegisterWaitForSingleObject(&WaitHandle,hEvent,NhEventCallBackFunction,(PVOID)hEvent,TimeOut,
				    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE);
  if (Err)
      g_RegisteredEventList.Insert(WaitHandle,hEvent,CallBack,Context,Context2);  
  else
      WaitHandle = NULL;

  return WaitHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\precomp.h ===
//
// Precom.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//

#pragma once


#define _ATL_FREE_THREADED


#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "resource.h"

#include <Winsock2.h>
#include <MsWSock.h>
#include <mstcpip.h>

#include <ALG.h>

#include "MyTrace.h"

#include "buffer.h"
#include "socket.h"
#include "regevent.h"

#include "FtpControl.h"
#include "list.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ALG_TEST.rc
//
#define IDS_PROJNAME                    100
#define IDR_MYALG                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\socket.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains code for socket-management.
    The routines provided generally follow the same asynchronous model
    using a completion routine that is invoked in the context of
    a callback thread.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

--*/

#include "precomp.h"
#pragma hdrstop


#include <stdio.h>

extern bool g_bStoping;

#if DBG
ULONG MyHelperpReadCount = 0;
#endif



ULONG UnusedBytesTransferred;

typedef struct _NH_CONNECT_BUFFER {
    HANDLE Event;
    HANDLE WaitHandle;
} NH_CONNECT_BUFFER, *PNH_CONNECT_BUFFER;

//
// FORWARD DECLARATIONS
//


VOID NTAPI
MyHelperpConnectCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

VOID WINAPI
MyHelperpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    );

VOID APIENTRY
MyHelperpIoWorkerRoutine(
    PVOID Context
    );


ULONG
MyHelperAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to accept an incoming connection-request
    on a listening stream socket using 'AcceptEx'. The I/O system invokes
    the provided 'CompletionRoutine' upon completion of the read.

    It is the completion-routine's responsibility to use 'setsockopt' to
    set the SO_UPDATE_ACCEPT_CONTEXT option on the accepted socket before
    the accepted socket can be used with Winsock2 routines.

    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    ListeningSocket - the endpoint that is listening for connection-requests

    AcceptedSocket - the endpoint to be assigned a connection-request,
        or INVALID_SOCKET to create a new endpoint

    Bufferp - the buffer to be used for asynchronous completion
        or NULL to acquire a new buffer

    AcceptCompletionRoutine - the routine to be invoked upon completion

    Context - the context to be associated with the accept-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the accept-completion routine
    will be invoked.
    Conversely, a failure code is a guarantee that the routine will not
    be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    SOCKET LocalSocket = INVALID_SOCKET;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = MyHelperAcquireBuffer();
        if (!Bufferp) {
            //MyHelperTrace(TRACE_FLAG_SOCKET, "error allocating buffer for accept");
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    
    if (AcceptedSocket == INVALID_SOCKET) {
        Error = MyHelperCreateStreamSocket(INADDR_NONE, 0, &LocalSocket);
        if (Error) {
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET, "error %d creating socket for accept", Error
            //);
            if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        AcceptedSocket = LocalSocket;
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = AcceptedSocket;
    Bufferp->CompletionRoutine = AcceptCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;


    if ( !g_bStoping && 
        AcceptEx(
            ListeningSocket,
            AcceptedSocket,
            Bufferp->Buffer,
            0,
            sizeof(SOCKADDR_IN) + 16,
            sizeof(SOCKADDR_IN) + 16,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            )) 
    {
        Error = NO_ERROR;
    } 
    else 
    {
        if ((Error = WSAGetLastError()) == ERROR_IO_PENDING) {
            Error = NO_ERROR;
        } else if (Error) {
            if (LocalSocket != INVALID_SOCKET) {
                MyHelperDeleteStreamSocket(LocalSocket);
            }
            if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET, "error %d returned by 'AcceptEx'", Error
            //);
        }
    }

    return Error;

} // MyHelperAcceptStreamSocket


ULONG
MyHelperConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to establish a connection using a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

    Since Windows Sockets does not deliver connect-notifications to
    I/O completion ports, we need to make some special arrangements in order
    to notify the caller's completion routine the way we do for send-requests
    and receive-requests. Specifically, we create an event-handle and
    request connect-notification on it by calling 'WSAEventSelect'.
    We then register a wait on the event-handle, specifying a private
    completion routine. (See 'MyHelperpConnectCallbackRoutine'.)
    When this completion routine runs, it extracts the status code of the
    connection-attempt using 'WSAEnumNetworkEvents'. It then passes the status
    along with the usual parameters to the caller's completion routine.


    N.B. The buffer supplied to this routine may not be released by 
    the connect-completion routine.
    (See 'MyHelperpConnectCallbackRoutine' for more information.)

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket with which to establish a connection

    Address - the IP address of the remote endpoint

    Port - the port number of the remote endpoint

    Bufferp - optionally supplies the buffer to be used to hold context
        during the connection-attempt

    ConnectCompletionRoutine - a routine to be invoked upon completion 
        of the connect-attempt

    Context - passed to the 'ConnectCompletionRoutine'

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code

    A success code is a guarantee that the connect-completion routine, 
    if supplied, will be invoked.
    Conversely, a failure code is a guarantee that the neither routine will
    be invoked.

--*/

{
    MYTRACE_ENTER("ALGFTP:MyHelperConnectStreamSocket");

    ULONG   nSourceAddress;
    USHORT  nSourcePort;
        
    MyHelperQueryLocalEndpointSocket(ConnectingSocket,&nSourceAddress,&nSourcePort);

    MYTRACE("From Source    %s:%d", MYTRACE_IP(nSourceAddress), ntohs(nSourcePort) );
    MYTRACE("To Destination %s:%d", MYTRACE_IP(Address), ntohs(Port) );
    



    PNH_CONNECT_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = MyHelperAcquireBuffer();
        if (!Bufferp) {
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET,
            //"MyHelperConnectStreamSocket: error allocating buffer for connect"
            //);
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socket = ConnectingSocket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = ConnectCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->ConnectAddress.sin_family = AF_INET;
    Bufferp->ConnectAddress.sin_addr.s_addr = Address;
    Bufferp->ConnectAddress.sin_port = Port;

    Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            MyHelperpConnectCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) {
        Error = GetLastError();
    } else {
        ULONG EventsSelected = FD_CONNECT;
        Error =
            WSAEventSelect(
                ConnectingSocket, Contextp->Event, EventsSelected
                );
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
        } else {
            Error =
                WSAConnect(
                    ConnectingSocket,
                    (PSOCKADDR)&Bufferp->ConnectAddress,
                    sizeof(Bufferp->ConnectAddress),
                    NULL,
                    NULL,
                    NULL,
                    NULL    
                    );
        }
    }

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSAEWOULDBLOCK) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }
        if (Contextp->Event) { CloseHandle(Contextp->Event); }
        if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // MyHelperConnectStreamSocket



ULONG
MyHelperCreateStreamSocket(
    ULONG Address OPTIONAL,
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is invoked to create and initialize a stream socket.
    The socket will also be bound to a local IP address and port,
    unless none is specified.

Arguments:

    Address - the local IP address to which the new socket should be bound,
        or INADDR_ANY to allow the system to leave the IP address unspecified,
        or INADDR_NONE if the socket should not be bound at all.

    Port - the port number to which the new socket should be bound,
        or 0 if to allow the system to select a port number.

    Socketp - receives initialized socket

Return Value:

    ULONG - Win32/Winsock2 status code.

--*/

{
    MYTRACE_ENTER("AlgFTP:MyHelperCreateStreamSocket");
    MYTRACE("Address %s:%d", MYTRACE_IP(Address), ntohs(Port));

    ULONG Error;
    ULONG Option;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new stream socket.
        //

        Socket =
            WSASocket(
                AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) 
        {
            Error = WSAGetLastError();
            MYTRACE_ERROR("from WSASocket", Error);
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        BindIoCompletionCallback((HANDLE)Socket, MyHelperpIoCompletionRoutine, 0);

        //
        // Disable send and receive buffering in AFD,
        // since we will be operating asynchronously with a receive-buffer
        // (almost) always outstanding, and since in any case we want
        // TCP/IP's flow-control to limit the sender's sending rate properly.
        //
	
        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );
        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );
	
        //
        // If the caller has requested that the socket be bound by specifying
        // a local IP address, bind the socket now.
        //
	
        if (Address != INADDR_NONE) {
            SocketAddress.sin_family = AF_INET;
            SocketAddress.sin_port = Port;
            SocketAddress.sin_addr.s_addr = Address;
            Error =
                bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));
            if (Error == SOCKET_ERROR) 
            {
                Error = WSAGetLastError();
                MYTRACE_ERROR("from BIND", Error);
                break;
            }
        }

        //
        // Store the new socket in the caller's output-parameter, and return.
        //

        *Socketp = Socket;
        return NO_ERROR;

    } while(FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;
} // MyHelperCreateStreamSocket


VOID
MyHelperDeleteSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine releases network resources for a socket.

Arguments:

    Socket - the socket to be deleted

Return Value:

    none.

--*/

{
    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
} // MyHelperDeleteSocket





VOID NTAPI
MyHelperpConnectCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked by upon completion of a connect-operation
    or upon closure of the connection by the remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when a connection-attempt is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CONNECT_BUFFER Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;
    
    
    
    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CONNECT', we unregister the wait if an error
    // occurred. 
    //
    // In essence, our goal is to guarantee that whatever the success
    // or failure or sequence of events on the socket, the connect-completion
    // routines will be called for the socket,
    //
    // N.B. routine is not allowed to release the connect-buffer,
    // since we will free it 
    //
    //

    Bufferp->BytesTransferred = 0;
    NetworkEvents.lNetworkEvents = 0;


    PNH_COMPLETION_ROUTINE CallbackConnectCompletion = Bufferp->CompletionRoutine;

    if ( CallbackConnectCompletion )
    {
        Bufferp->CompletionRoutine = NULL;


        if ( g_bStoping )
        {   
            Error = ERROR_OPERATION_ABORTED;
        }
        else
        {
            Error = WSAEnumNetworkEvents(Bufferp->Socket, Contextp->Event, &NetworkEvents);

            if ( Error ) 
            {
                //
                // We couldn't determine which events occurred on the socket,
                // so call the routines with errors, and fall through
                // to the cleanup code below.
                //
                Error = ERROR_OPERATION_ABORTED;
            } 
            else 
            {
                if ( NetworkEvents.lNetworkEvents & FD_CONNECT ) 
                {
                    Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];
                }
                else
                {

                    //
                    // Not sure what even was sent to US we only requested FD_CONNECT so treat this as an error
                    //
                    Error = ERROR_OPERATION_ABORTED;
                }
            }
        }

        //
        // We are about to call the User Completion routine
        // but to insure that the buffer is freed and that any event the 
        // CompletionRoutine generates (Shutdown the process) and we did not have time to free
        // we will free now and call
        //


        PNH_BUFFER pUserContext = (PNH_BUFFER)Bufferp->Context;

        UnregisterWait(Contextp->WaitHandle);
        CloseHandle(Contextp->Event);
        MyHelperReleaseBuffer(Bufferp);


        //
        // Now call the UserCallback routine
        //
        if ( CallbackConnectCompletion ) 
        {
            CallbackConnectCompletion(Error, 0, pUserContext);
        }

        
    }
    else
    {
        //
        // The completion routine was call and resource freed previously
        // and now we are getting a EVENT that we never solicitated.
        // 
    }
    

} // MyHelperpConnectCallbackRoutine


VOID
MyHelperpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    )

/*++

Routine Description:

    This routine is invoked by the I/O system upon completion of an operation.

Arguments:

    ErrorCode - system-supplied error code

    BytesTransferred - system-supplied byte-count

    Overlapped - caller-supplied context area

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread.

--*/

{
    PNH_BUFFER Bufferp = CONTAINING_RECORD(Overlapped, NH_BUFFER, Overlapped);
    
    Bufferp->ErrorCode = ErrorCode;
    Bufferp->BytesTransferred = BytesTransferred;
    Bufferp->CompletionRoutine(
        Bufferp->ErrorCode,
        Bufferp->BytesTransferred,
        Bufferp
        );  

} // MyHelperpIoCompletionRoutine


VOID APIENTRY
MyHelperpIoWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to continue processing of completed I/O
    in the context of an alertably waiting thread which does not exit idly.

Arguments:

    Context - holds the buffer associated with the completed I/O operation.

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL alertable worker thread.

--*/

{
    ((PNH_BUFFER)Context)->CompletionRoutine(
        ((PNH_BUFFER)Context)->ErrorCode,
        ((PNH_BUFFER)Context)->BytesTransferred,
        ((PNH_BUFFER)Context)
        );

} // MyHelperpIoWorkerRoutine


VOID
MyHelperQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    )
{
    PSOCKADDR_IN LocalSockAddr = NULL;
    ULONG LocalLength = sizeof(LocalSockAddr);
    PSOCKADDR_IN RemoteSockAddr = NULL;
    ULONG RemoteLength = sizeof(RemoteSockAddr);
    GetAcceptExSockaddrs(
        AcceptBuffer,
        0,
        sizeof(SOCKADDR_IN) + 16,
        sizeof(SOCKADDR_IN) + 16,
        (PSOCKADDR*)&LocalSockAddr,
        reinterpret_cast<LPINT>(&LocalLength),
        (PSOCKADDR*)&RemoteSockAddr,
        (LPINT)&RemoteLength
        );

    if (LocalAddress && LocalSockAddr) {
        *LocalAddress = LocalSockAddr->sin_addr.s_addr; 
    }
    if (LocalPort && LocalSockAddr) { 
        *LocalPort = LocalSockAddr->sin_port; 
    }
    if (RemoteAddress && RemoteSockAddr) { 
        *RemoteAddress = RemoteSockAddr->sin_addr.s_addr; 
    }
    if (RemotePort && RemoteSockAddr) { 
        *RemotePort = RemoteSockAddr->sin_port; 
    }

} // MyHelperQueryAcceptEndpoints


ULONG
MyHelperQueryAddressSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to retrieve the IP address associated with
    a socket.

Arguments:

    Socket - the socket to be queried

Return Value:

    ULONG - the IP address retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_addr.s_addr;
} // MyHelperQueryAddressSocket


ULONG
MyHelperQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getsockname(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // MyHelperQueryEndpointSocket


USHORT
MyHelperQueryPortSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine retrieves the port number to which a socket is bound.

Arguments:

    Socket - the socket to be queried

Return Value:

    USHORT - the port number retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_port;
} // MyHelperQueryPortSocket


ULONG
MyHelperQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getpeername(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // MyHelperQueryRemoteEndpointSocket



ULONG
MyHelperReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a stream socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer

    Length - the maximum number of bytes to be read

    Offset - the offset into the buffer at which the read should begin,
        valid only if 'Bufferp' is provided.

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }
    
    if (!Bufferp) {
        Offset = 0;
        Bufferp = LocalBufferp = MyHelperAcquireVariableLengthBuffer(Length);
        if (!Bufferp) {
            //MyHelperTrace(
            //TRACE_FLAG_SOCKET,
            //"MyHelperReadStreamSocket: error allocating buffer for receive"
            //);
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (ReadFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperReadStreamSocket: error %d returned by 'ReadFile'", Error
        //);
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSARecv(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            &Bufferp->ReceiveFlags,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { MyHelperReleaseBuffer(LocalBufferp); }
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperReadStreamSocket: error %d returned by 'WSARecv'", Error
        //);
    }
#endif

    return Error;

} // MyHelperReadStreamSocket



ULONG
MyHelperWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    Offset - the offset into the buffer at which the data to be sent begins

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (WriteFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperWriteStreamSocket: error %d returned by 'WriteFile'", Error
        //);
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSASend(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            0,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        //MyHelperTrace(
        //TRACE_FLAG_SOCKET,
        //"MyHelperWriteStreamSocket: error %d returned by 'WSASend'", Error
        //);
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#endif

    return Error;

} // MyHelperWriteStreamSocket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "ALG FTP proxy"
#define VER_INTERNALNAME_STR            "ALG_FTP.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_ftp\socket.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations for socket-management.
    The routines declared here operate asynchronously on sockets
    associated with an I/O completion port. They are also integrated
    with the component-reference object, which may optionally be used
    by callers to control the number of outstanding entries into a component's
    address-space. 

    This module contains declarations for maintaining reference-count
    on a component. It provides an asynchronous thread-safe means of
    handling cleanup in a module.

    The mechanism defined uses a locked reference count and cleanup-routine
    to manage the lifetime of the component. When the reference-count
    is dropped to zero, the associated cleanup-routine is invoked.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

--*/


#pragma once


typedef VOID (*PCOMPONENT_CLEANUP_ROUTINE)(VOID);



//
// Structure:   COMPONENT_REFERENCE
//
// This structure must reside in memory for the lifetime of the component
// to which it refers. It is used to synchronize the component's execution.
//

typedef struct _COMPONENT_REFERENCE 
{
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    BOOLEAN Deleted;
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine;
#if COMPREF_TRACKING
    struct _COMPREF_RECORD* RecordArray;
    ULONG RecordIndex;
#endif

} COMPONENT_REFERENCE, *PCOMPONENT_REFERENCE;



#if COMPREF_TRACKING
#define COMPREF_RECORD_COUNT    (1024)

typedef struct _COMPREF_RECORD 
{
    PCHAR File;
    USHORT Line;
    UCHAR ReferenceCount;
    enum 
    {
        ComprefAcquireRecord,
        ComprefReleaseRecord
    } Type;

} COMPREF_RECORD, *PCOMPREF_RECORD;

#endif


//
// FUNCTION DECLARATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    );

#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    );
#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

//
// MACRO DECLARATIONS
//

#define RETURN_VOID

#if COMPREF_TRACKING

#define REFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)

#define DEREFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord); \
    return retcode

#else

#define REFERENCE_COMPONENT(c) \
    AcquireComponentReference(c)

#define DEREFERENCE_COMPONENT(c) \
    ReleaseComponentReference(c)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!AcquireComponentReference(c)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    ReleaseComponentReference(c); return retcode

#endif


//
// INLINE ROUTINE IMPLEMENTATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    ++ComponentReference->ReferenceCount;
    LeaveCriticalSection(&ComponentReference->Lock);
    return TRUE;

} // AcquireComponentReference


VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the last reference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/

{
    DeleteCriticalSection(&ComponentReference->Lock);
#if COMPREF_TRACKING
    HeapFree(GetProcessHeap(), 0, ComponentReference->RecordArray);
#endif

} // DeleteComponentReference


ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    )

/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/

{
    __try {
        InitializeCriticalSection(&ComponentReference->Lock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    ComponentReference->Deleted = FALSE;
    ComponentReference->ReferenceCount = 1;
    ComponentReference->CleanupRoutine = CleanupRoutine;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ComponentReference->RecordArray =
        HeapAlloc(
            GetProcessHeap(), 0, sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
            );
#endif
    return NO_ERROR;

} // InitializeComponentReference



#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    )
{
    BOOLEAN Success;
    ULONG i = InterlockedIncrement(&ComponentReference->RecordIndex);
    i %= COMPREF_RECORD_COUNT;
    ComponentReference->RecordArray[i].File = File;
    ComponentReference->RecordArray[i].Line = (USHORT)Line;
    ComponentReference->RecordArray[i].Type = Type;
    if (Type == ComprefAcquireRecord) {
        Success = AcquireComponentReference(ComponentReference);
    } else {
        Success = ReleaseComponentReference(ComponentReference);
    }
    ComponentReference->RecordArray[i].ReferenceCount =
        (UCHAR)ComponentReference->ReferenceCount;
    return Success;
}

#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseComponentReference


__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return TRUE;
    }
    ComponentReference->Deleted = TRUE;
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseInitialComponentReference




__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    ComponentReference->ReferenceCount = 1;
    ComponentReference->Deleted = FALSE;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ZeroMemory(
        ComponentReference->RecordArray,
        sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
        );
#endif
    LeaveCriticalSection(&ComponentReference->Lock);
} // ReleaseComponentReference





#ifndef _NATHLP_SOCKET_H_
#define _NATHLP_SOCKET_H_






ULONG
MyHelperAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
MyHelperConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PVOID Context,
    PVOID Context2
    );


ULONG
MyHelperCreateStreamSocket(
    ULONG Address OPTIONAL, // may be INADDR_NONE
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    );


#define MyHelperDeleteStreamSocket(s) MyHelperDeleteSocket(s)

VOID
MyHelperDeleteSocket(
    SOCKET Socket
    );

//
// BOOLEAN
// MyHelperIsFatalSocketError(
//     ULONG Error
//     );
//
// Determines whether a request may be reissued on a socket,
// given the error-code from the previous issuance of the request.
// This macro is arranged to branch on the most common error-codes first.
//

#define \
MyHelperIsFatalSocketError( \
    _Error \
    ) \
    ((_Error) != ERROR_OPERATION_ABORTED && \
    ((_Error) == WSAEDISCON || \
     (_Error) == WSAECONNRESET || \
     (_Error) == WSAETIMEDOUT || \
     (_Error) == WSAENETDOWN || \
     (_Error) == WSAENOTSOCK || \
     (_Error) == WSAESHUTDOWN || \
     (_Error) == WSAECONNABORTED))


VOID
MyHelperQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    );

ULONG
MyHelperQueryAddressSocket(
    SOCKET Socket
    );

ULONG
MyHelperQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );

USHORT
MyHelperQueryPortSocket(
    SOCKET Socket
    );

ULONG
MyHelperQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );


ULONG
MyHelperReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );


ULONG
MyHelperWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

#endif // _NATHLP_SOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\alg_icq.cpp ===
// ALG_ICQ.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ALG_ICQps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include <initguid.h>
#include "MyAlg.h"
#include "MyAdapterNotify.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MyALG, CMyALG)
    OBJECT_ENTRY(CLSID_MyAdapterNotificationSink,   CMyAdapterNotify)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\bufferc.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    bufferc.h

Abstract:

    This module contains declarations for buffer-management.

    All network I/O in this component occurs via completion packets.
    The buffer routines below are used to acquire and release the buffers
    used for sending and receiving data.

    In addition to holding the data transferred, the buffers contain fields
    to facilitate their use with completion ports. See below for details
    on the use of the fields.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998
	Savas Guven		    (savasg)	20-Oct-2000

Revision History:

--*/
#if 0

#ifndef _NATHLP_BUFFER_H_
#define _NATHLP_BUFFER_H_

#define NH_BUFFER_SIZE              576
#define NH_MAX_BUFFER_QUEUE_LENGTH  32


//
// Structure:   NH_BUFFER
//
// This structure holds a buffer used for network I/O on a socket.
//

typedef enum _NH_BUFFER_TYPE {
    NhFixedLengthBufferType,
    NhVariableLengthBufferType
} NH_BUFFER_TYPE;


class NH_BUFFER : public GENERIC_NODE
{

	class _CNhSock * Socketp;
    //
    // Completion routine and contexts for the buffer's most recent I/O request
    //
    PNH_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Context2;
    //
    // Passed as the system context area for any I/O using the buffer
    //
    OVERLAPPED Overlapped;
    //
    // Upon completion of a receive, the receive-flags and source-address
    // length for the message read
    //
    ULONG ReceiveFlags;
    ULONG AddressLength;
    union {
        //
        // Holds the source address when a datagram-read completes
        //
        SOCKADDR_IN ReadAddress;
        //
        // Holds the destination address while a datagram-send is in progress
        //
        SOCKADDR_IN WriteAddress;
        //
        // Holds the remote address while a connect is in progress
        //
        SOCKADDR_IN ConnectAddress;
        //
        // Holds the state of a multi-request read or write
        //
        struct {
            ULONG UserFlags;
            ULONG BytesToTransfer;
            ULONG TransferOffset;
        };
    };
    //
    // Upon completion of an I/O request, the error-code, byte-count,
    // and data-bytes for the request
    //
    ULONG ErrorCode;
    ULONG BytesTransferred;
    UCHAR Buffer[NH_BUFFER_SIZE];
	

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\buffer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    This module contains declarations for buffer-management.

    All network I/O in this component occurs via completion packets.
    The buffer routines below are used to acquire and release the buffers
    used for sending and receiving data.

    In addition to holding the data transferred, the buffers contain fields
    to facilitate their use with completion ports. See below for details
    on the use of the fields.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_BUFFER_H_
#define _NATHLP_BUFFER_H_

#define NH_BUFFER_SIZE              576
#define NH_MAX_BUFFER_QUEUE_LENGTH  32

struct _NH_BUFFER;

//
// Typedef:     PNH_COMPLETION_ROUTINE
//

typedef
VOID
(*PNH_COMPLETION_ROUTINE)(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    struct _NH_BUFFER* Bufferp
    );


//
// Structure:   NH_BUFFER
//
// This structure holds a buffer used for network I/O on a socket.
//

typedef enum _NH_BUFFER_TYPE {
    NhFixedLengthBufferType,
    NhVariableLengthBufferType
} NH_BUFFER_TYPE;

class _CNhSock;

typedef struct _NH_BUFFER {
    union {
        LIST_ENTRY Link;
        NH_BUFFER_TYPE Type;
    };
    //
    // The socket associated with the buffer's most recent I/O request
    //
    class _CNhSock * Socketp;
    //
    // Completion routine and contexts for the buffer's most recent I/O request
    //
    PNH_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Context2;
    //
    // Passed as the system context area for any I/O using the buffer
    //
    OVERLAPPED Overlapped;
    //
    // Upon completion of a receive, the receive-flags and source-address
    // length for the message read
    //
    ULONG ReceiveFlags;
    ULONG AddressLength;
    union {
        //
        // Holds the source address when a datagram-read completes
        //
        SOCKADDR_IN ReadAddress;
        //
        // Holds the destination address while a datagram-send is in progress
        //
        SOCKADDR_IN WriteAddress;
        //
        // Holds the remote address while a connect is in progress
        //
        SOCKADDR_IN ConnectAddress;
        //
        // Holds the state of a multi-request read or write
        //
        struct {
            ULONG UserFlags;
            ULONG BytesToTransfer;
            ULONG TransferOffset;
        };
    };
    //
    // Upon completion of an I/O request, the error-code, byte-count,
    // and data-bytes for the request
    //
    ULONG ErrorCode;
    ULONG BytesTransferred;
    UCHAR Buffer[NH_BUFFER_SIZE];
} NH_BUFFER, *PNH_BUFFER;

#define NH_ALLOCATE_BUFFER() \
    reinterpret_cast<PNH_BUFFER>(NH_ALLOCATE(sizeof(NH_BUFFER)))
    
#define NH_FREE_BUFFER(b)       NH_FREE(b)


//
// BUFFER-MANAGEMENT ROUTINES (alphabetically)
//

#define NhAcquireBuffer() NhAcquireFixedLengthBuffer()
PNH_BUFFER
NhAcquireFixedLengthBuffer(
    VOID
    );

PNH_BUFFER
NhAcquireVariableLengthBuffer(
    ULONG Length
    );

PNH_BUFFER
NhDuplicateBuffer(
    PNH_BUFFER Bufferp
    );

ULONG
NhInitializeBufferManagement(
    VOID
    );

VOID
NhReleaseBuffer(
    PNH_BUFFER Bufferp
    );

VOID
NhShutdownBufferManagement(
    VOID
    );

#endif // _NATHLP_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqcl.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    

Abstract:

    

Author:

    Savas Guven (savasg)   27-Nov-2000

Revision History:

--*/
#include "stdafx.h"





//
// STATIC MEMBER Initialization
//
const PCHAR _ICQ_CLIENT::ObjectNamep = "ICQ_CLIENT";

const PCHAR _ICQ_PEER::ObjectNamep = "ICQ_PEER";



_ICQ_PEER::_ICQ_PEER()
:ToClientSocketp(NULL),
 ToPeerSocketp(NULL),
 PeerUIN(0),
 PeerVer(0),
 PeerIp(0),
 PeerPort(0),
 bActivated(FALSE),
 bShadowMappingExists(FALSE),
 MappingDirection(IcqFlagNeutral),
 ShadowRedirectp(NULL),
 OutgoingPeerControlRedirectp(NULL),
 IncomingDataRedirectp(NULL)
{
}


_ICQ_PEER::~_ICQ_PEER()
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	if(this->bCleanupCalled is FALSE)
	{
		_ICQ_PEER::ComponentCleanUpRoutine();
	}

	this->bCleanupCalled = FALSE;
}



void
_ICQ_PEER::ComponentCleanUpRoutine()
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
    DispatchRequest DReq;

    PROFILER(TM_IO, TL_INFO, ("PEER COMPONENT_CLEANING %u", this->PeerUIN));

    // Cancel the Shadow Mapping if there is any
	if(this->ShadowRedirectp)
	{
        this->ShadowRedirectp->Cancel();

        this->ShadowRedirectp->Release();

        this->ShadowRedirectp = NULL;

        this->MappingDirection = IcqFlagNeutral;
	}

    if(this->IncomingDataRedirectp != NULL)
    {
        this->IncomingDataRedirectp->Cancel();

        this->IncomingDataRedirectp->Release();

        this->IncomingDataRedirectp = NULL;
    }

    if(this->OutgoingPeerControlRedirectp)
    {
        this->OutgoingPeerControlRedirectp->Cancel();

        this->OutgoingPeerControlRedirectp->Release();

        this->OutgoingPeerControlRedirectp = NULL;
    }

    //
    // NOTE: Delete the Dispatcher entries
    //
    DReq.dstIp  = this->PeerIp;
    DReq.dstPort= this->PeerPort;
    DReq.srcIp  = 0;   
    DReq.srcPort= 0;
    
    // g_IcqPeerDispatcherp->DeleteDispatchRequest(

    //
	// Close and Dereference the local sockets if there is any.
    //
	if ( ToPeerSocketp != NULL )
	{
		STOP_COMPONENT( ToPeerSocketp );

		DEREF_COMPONENT( ToPeerSocketp, eRefInitialization );

        ToPeerSocketp = NULL;
	}

	if ( ToClientSocketp != NULL )
	{
		STOP_COMPONENT( ToClientSocketp );

		DEREF_COMPONENT( ToClientSocketp, eRefInitialization );

        ToClientSocketp = NULL;
	}

	this->bCleanupCalled = TRUE;
}




void
_ICQ_PEER::StopSync(void)
/*++

Routine Description:

    Stop the sockets if there are any...
    
Arguments:

    none.

Return Value:

    

--*/
{
    if(this->ToClientSocketp != NULL)
    {
        STOP_COMPONENT(this->ToClientSocketp);
    }

    if(this->ToPeerSocketp != NULL)
    {
        STOP_COMPONENT(this->ToPeerSocketp);
    }

    this->Deleted = TRUE;
}



ULONG
_ICQ_PEER::EndPeerSessionForClient(PCNhSock ClosedSocketp)
{

    PROFILER(TM_MSG, TL_INFO, ("> EndPeerSessionForClient"));

    //
    // Find the proper Socket and Dereference it.
    //
    if ( ClosedSocketp is this->ToClientSocketp )
    {
        DEREF_COMPONENT( this->ToClientSocketp, eRefInitialization );

        this->ToClientSocketp = NULL;

        if ( this->ToPeerSocketp != NULL )
        {
            STOP_COMPONENT( this->ToPeerSocketp );
        }
    }
    else if ( ClosedSocketp is this->ToPeerSocketp )
    {
        DEREF_COMPONENT( this->ToPeerSocketp, eRefInitialization );

        this->ToPeerSocketp = NULL;

        if( this->ToPeerSocketp != NULL )
        {
            STOP_COMPONENT( this->ToPeerSocketp );
        }
    } 
    else
    {
        ASSERT(FALSE);
    }

    //
    // The Data Redirects Should be cleaned here.
    //
    if(this->IncomingDataRedirectp != NULL)
    {
        this->IncomingDataRedirectp->Cancel();

        this->IncomingDataRedirectp->Release();

        this->IncomingDataRedirectp = NULL;
    }

    if(this->ShadowRedirectp)
    {
        this->ShadowRedirectp->Cancel();
        
        this->ShadowRedirectp->Release();
        
        this->ShadowRedirectp       = NULL;

        this->bActivated            = FALSE;

        this->MappingDirection      = IcqFlagNeutral;
    }
    
    return NO_ERROR;

}



// ************************************************
// ICQ_CLIENT MEMBER FUNCTION
// ************************************************




//
//
//
_ICQ_CLIENT::_ICQ_CLIENT()
:ServerSocketp(NULL),
 ShadowRedirectp(NULL),
 IncomingPeerControlRedirectionp(NULL),
 ClientSocketp(NULL),
 ClientIp(0),
 ClientToServerPort(0),
 ClientToPeerPort(0),
 ImitatedPeerPort(0),
 UIN(0),
 ClientVer(0),
 ServerIp(0),
 ServerPort(0),
 TimerContextp(NULL)
{

}





_ICQ_CLIENT::~_ICQ_CLIENT()
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/

{
	if(this->bCleanupCalled is FALSE)
	{
		_ICQ_CLIENT::ComponentCleanUpRoutine();
	}

	this->bCleanupCalled = FALSE;
}




void
_ICQ_CLIENT::ComponentCleanUpRoutine(void)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
    ULONG Error = NO_ERROR;
    DispatchRequest DReq;
	PICQ_PEER IcqPeerp = NULL;

    PROFILER(TM_MSG, TL_INFO, ("CLIENT COMPONENT_CLEANING %u", this->UIN));

	//
	// We need to DELETE the Dispatcher Requests made for the
    // Peer, tracerse the List of the Peers and Request the Removal 
    // of these (OUTGOING PEER SESSION - REDIRECT) deletion.
    //
    for(IcqPeerp = dynamic_cast<PICQ_PEER> (this->IcqPeerList.SearchNodeKeys(0, 0));
        IcqPeerp != NULL;
        IcqPeerp = dynamic_cast<PICQ_PEER>(IcqPeerp->Nextp))
    {
        DReq.dstIp   = IcqPeerp->PeerIp;
        DReq.dstPort = IcqPeerp->PeerPort;

        DReq.srcIp   = this->ClientIp;
        DReq.srcPort = 0;

        //
        // A Remove operation STOPs and DEREFs a Node.
        //
        this->IcqPeerList.RemoveNodeFromList(IcqPeerp);
        
        Error = g_IcqPeerDispatcherp->DeleteDispatchRequest(&DReq);

        if(Error)
        {
            ICQ_TRC(TM_MSG, TL_ERROR, 
                    ("** !!Can't delete Peer Redirection Dispatch Req !! **"));
        }
    }


    //
    // Delete the Dispatcher Requests for the Incoming 
    // Peer Sessions Redirect Request
    // 
    DReq.dstIp   = g_MyPublicIp;
    DReq.dstPort = this->ImitatedPeerPort;

    DReq.srcIp   = 0;
    DReq.srcPort = 0;

    Error = g_IcqPeerDispatcherp->DeleteDispatchRequest(&DReq);

    if(Error)
    {
        ICQ_TRC(TM_MSG, TL_ERROR, 
                ("** !! Can't delete CLIENT Incoming Dispatch Req !! **"));
    }

    if ( FAILED( g_IcqPeerDispatcherp->RemoveDispatchee(this) ) )
    {
        ICQ_TRC(TM_MSG, TL_ERROR, ("** !! Can't remove Dispatchee "));

        ASSERT( FALSE);
    }

	//
	// Dereference the the Shared ClientSocketp

    if(ClientSocketp != NULL)
    {
        DEREF_COMPONENT( this->ClientSocketp, eRefInitialization );
    
        this->ClientSocketp = NULL;
    }

	//
	// delete and/or Dereference the ServerSocketp
    if(ServerSocketp != NULL)
    {
        STOP_COMPONENT(ServerSocketp);

        DEREF_COMPONENT( this->ServerSocketp, eRefInitialization );

        this->ServerSocketp;
    }

    //
    //  Clear the Shadow Mappings if therer are any.
    //
    if(this->ShadowRedirectp != NULL)
    {
        this->ShadowRedirectp->Cancel();

        this->ShadowRedirectp->Release();

        this->ShadowRedirectp = NULL;
    }

    if ( IncomingPeerControlRedirectionp != NULL)
    {
        IncomingPeerControlRedirectionp->Cancel();

        IncomingPeerControlRedirectionp->Release();

        IncomingPeerControlRedirectionp = NULL;

        this->IncomingRedirectForPeerToClientp = NULL;
    }



	this->bCleanupCalled = TRUE;
} // _ICQ_CLIENT::ComponentCleanUpRoutine




void
_ICQ_CLIENT::StopSync(void)
/*++

Routine Description:

    We have to delete the ASYNC elements in the Peers or within the 
    current Sockets. The Reads that are issued will have references to 
    this components which needs to be removed for a complete Garbage 
    collection. This component has to be declared deleted so that no body
    tries to reference it anymore.
    
    It also needs to travers the Peer structures and call the related StopSyncs
    approptiately.
    
    Then set this component as deleted.
    
Arguments:

    none.

Return Value:

    
--*/
{
    PICQ_PEER IcqPeerp = NULL;

    ICQ_TRC(TM_MSG, TL_TRACE, 
            ("%s> Stopping the COMPONENT", this->GetObjectName()));

    //
    // Stop the ServerSocketp
    STOP_COMPONENT(this->ServerSocketp);


    //
    // for each peer Element Call the STOP_COMPONENT.
    // It is important that the Peer Elements are not deleted here.
    //
    for(IcqPeerp = dynamic_cast<PICQ_PEER>(this->IcqPeerList.SearchNodeKeys(0,0));
        IcqPeerp != NULL;
        IcqPeerp = dynamic_cast<PICQ_PEER>(this->IcqPeerList.SearchNodeKeys(0,0))
       )
    {
        STOP_COMPONENT(IcqPeerp);
    }

    this->Deleted = TRUE;
} // _ICQ_CLIENT::StopSync






ULONG
_ICQ_CLIENT::DispatchCompletionRoutine(PDispatchReply DispatchReplyp)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	PICQ_PEER IcqPeerp = NULL;
	PCNhSock * cupHolder = NULL;
	ULONG Error = NO_ERROR;

	// if(DispatchReplyp is NULL) return 0;	 ASSERT on it?
	
	ICQ_TRC(TM_MSG, TL_TRACE, (" Dispatch Completion Routine of ICQcl "));

	//
	// Find the Appropriate Peer entry which has caused this completion routine
	// Note that all the peer entries have the UIN as the search Key.
	// thus if this Reply has the IcqFlagOutgoing as the flag we should just
	// Look at this list to see which or where we're sending..
	// Otherwise we should look at the src addresses and either way we have to 
	// scan the whole List to find the appropriate entry.
	//
	for(IcqPeerp = dynamic_cast<PICQ_PEER> (this->IcqPeerList.SearchNodeKeys(0, 0));
		IcqPeerp != NULL;
		IcqPeerp = dynamic_cast<PICQ_PEER>(IcqPeerp->Nextp))
	{
		if(DispatchReplyp->dispatch.DirectionContext is IcqFlagOutgoing)
		{
			if(IcqPeerp->PeerIp   is DispatchReplyp->dispatch.dstIp &&
			   IcqPeerp->PeerPort is DispatchReplyp->dispatch.dstPort)
			{
				ICQ_TRC(TM_MSG, TL_TRACE, 
						("connection from inside to UIN %lu", IcqPeerp->PeerUIN));

				IcqPeerp->ToClientSocketp = DispatchReplyp->Socketp;

				cupHolder = &IcqPeerp->ToClientSocketp ;

				IcqPeerp->MappingDirection = IcqFlagOutgoing;

				break;
			}
       	}
		else // Incoming. BUG BUG:  add feature #14 from -The- TEXT
		{
			//DispatchReplyp->dispatch.srcPort;
			if(IcqPeerp->PeerIp is DispatchReplyp->dispatch.srcIp)
			{
				ICQ_TRC(TM_MSG, TL_TRACE, 
						("connection -from- UIN %lu", IcqPeerp->PeerUIN));

				IcqPeerp->ToPeerSocketp = DispatchReplyp->Socketp;

				cupHolder = &IcqPeerp->ToPeerSocketp ;

                DispatchReplyp->dispatch.dstIp      = this->ClientIp;
                
                DispatchReplyp->dispatch.dstPort    = this->ClientToPeerPort;

				IcqPeerp->MappingDirection = IcqFlagIncoming;
				
				break;
			}
		} // if-else
	} // for


	if(IcqPeerp is NULL)
	{
		ICQ_TRC(TM_MSG, TL_ERROR, 
                ("NO IcqPeer has been found DELETING THE ACCEPTED SOCKET"));

        ReportExistingPeers();

		DEREF_COMPONENT( DispatchReplyp->Socketp, eRefInitialization );

		delete DispatchReplyp;

		return 0;
	}

	if(Error = 	IcqPeerp->InitiatePeerConnection(DispatchReplyp))
	{
		ICQ_TRC(TM_MSG, TL_ERROR, ("Error -  Initiation Peer connection has failed "));

        STOP_COMPONENT(DispatchReplyp->Socketp);

		DEREF_COMPONENT( DispatchReplyp->Socketp, eRefInitialization );
		
		*cupHolder = NULL;
	}

	delete DispatchReplyp;

	return Error;
}





ULONG 
_ICQ_CLIENT::Initialize(
    					PNH_BUFFER Bufferp,
    					ULONG	   clientIp,
    					USHORT	   clientPort,
    					ULONG      serverIp,
    					USHORT     serverPort,
                        PCNhSock   localClientSocketp
    				   ) 
/*++

Routine Description:

    If there are existing set of informations then it should be noted that,
    We need to make a consistency check or pass on them.
    A new client ~ server session may effect the ongoing TCP streams.. Thus 
    the decisions should be made wisely as it would mean of scavenging a lot 
    of resources and cycles.
    - Initialy we don't have any data so, we store them.
    - Here we get the local TCP port information and need to create mappings 
       for them. (defered)
    

Arguments:

    none.

Return Value:

    

--*/
{
    ULONG hr = S_OK;

    
    ASSERT(Bufferp != NULL);
    ASSERT(localClientSocketp != NULL);


    do
    {
        if(this->ClientIp != 0)
        {
            ICQ_TRC(TM_MSG, TL_ERROR, 
    			    ("** !! ERROR - RE-INITING of client %s", 
                     INET_NTOA(ClientIp)));
    
            ASSERT( FALSE );
        }
        else // first time init
        {
    		ULONG InterfaceIp;
    
            this->ClientIp			    = clientIp;
            this->ClientToServerPort    = clientPort;
    
            this->ServerIp			    = serverIp;
            this->ServerPort			= serverPort;
            
    		// 
    		// Since we're sharing the socket back to the client
    		// it should be properly referenced so that it is not deleted randomly
    		//
            ClientSocketp = localClientSocketp;
    		
    		REF_COMPONENT( localClientSocketp, eRefIoSharing );
    
            //
            // Create a new UDP socket;
            //
            NEW_OBJECT( ServerSocketp, CNhSock );
            
            if( ServerSocketp is NULL ) 
    		{
    			ICQ_TRC(TM_MSG, TL_ERROR, ("** !! Socket Creation hr"));
    
                hr = E_OUTOFMEMORY;

                break;
    		}
    
    		InterfaceIp = InterfaceForDestination(ServerIp);
    
    		ICQ_TRC(TM_MSG, TL_TRACE, 
    				("The InterfaceIP for the PRoxy ~ Server is %s", 
    				INET_NTOA(InterfaceIp)));
    
            hr = ServerSocketp->NhCreateDatagramSocket(InterfaceIp,
                                                       0,
                                                       NULL);
    
            if ( hr )
    		{
    			ICQ_TRC(TM_MSG, TL_ERROR, ("CLI !!> Socket Creation hr"));
    
                hr = HRESULT_FROM_WIN32( hr );
    
                break;
    		}
    
            PICQ_CLIENT tempClientp = this;
    
            REF_COMPONENT( tempClientp, eRefIoRead );
    
    		// issue a Read operation on the Server Socket here.
    		hr = ServerSocketp->NhReadDatagramSocket(g_IcqComponentReferencep,
    				        							NULL,
    						        					ReadServerCompletionRoutine,
    								        			this,
    										        	NULL);
            if ( hr )
            {
                ICQ_TRC(TM_MSG, TL_ERROR, ("Read hr "));
    
                DEREF_COMPONENT( tempClientp, eRefIoRead );
    
                hr = HRESULT_FROM_WIN32( hr );
    
                break;
            }
    
    		//
    		// Initialize Once.
            //
    		hr = g_IcqPeerDispatcherp->InitDispatchee(this);
    
            if ( hr )
            {
                ASSERT( FALSE );  // handle this case later
            }
    
    
            //
            // Now we can pass the Buffer and the destination address to
            // the generic ServerRead
    		//
    		hr = this->ClientRead(Bufferp, serverIp, serverPort);
    
            if(hr)
            {
                ASSERT(FALSE);
            }
        }

    } while ( FALSE );

    if ( FAILED(hr) )
    {

    }

	//
	// The Search Key for this 
	//
	this->iKey1 = clientIp;

	this->iKey2 = 0;

	return hr;
}


//
//
//
ULONG 
_ICQ_CLIENT::ServerRead(
							PNH_BUFFER Bufferp,
							ULONG  serverIp,
							USHORT serverPort
   					   )
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{

	ULONG Error = NO_ERROR;

	if(Bufferp is NULL) 
	{
		return E_INVALIDARG;
	}

	ICQ_TRC(TM_MSG, TL_DUMP, 
			("UDP - Server is Sending TO Client %s", INET_NTOA(ClientIp)));


	
	Error = IcqServerToClientUdp(Bufferp->Buffer,
			        			 Bufferp->BytesTransferred);


    //
	// Write to Destination of the Processed packet
    //
	Error = ClientSocketp->NhWriteDatagramSocket(g_IcqComponentReferencep,
										 	     this->ClientIp,
												 this->ClientToServerPort,
												 Bufferp,
												 Bufferp->BytesTransferred,
												 IcqWriteCompletionRoutine,
												 NULL,
												 NULL);

	if(Error)
	{
		ICQ_TRC(TM_MSG, TL_ERROR, 
                ("** !! SRead> problem at writing to client %s",
                 INET_NTOA(this->ClientIp)));

        NhReleaseBuffer(Bufferp);

		ErrorOut();
	}

	return Error;
}


//
//
//
ULONG 
_ICQ_CLIENT::ClientRead(
							PNH_BUFFER Bufferp,
							ULONG  serverIp,
							USHORT serverPort
   					   )
/*++

Routine Description:

      Reads the data coming from a client, going to the server
      We're checking this UDP packet so that:
      * the client Address, and port numbers so that they are valid and up-to-date
      * the server address/port is also checked for verification
      * the packets are sent to processing function
      * and then UDP packets are forwarded to Server
    
    
Arguments:

    none.

Return Value:

    

--*/
{

	ULONG  srcIp, dstIp     = this->ServerIp, Error;
	USHORT srcPort, dstPort = this->ServerPort;

	ULONG  LocalIp   = 0;
	USHORT LocalPort = 0;


	//
	// Decide = Where is the data coming from    or ASSERT(Bufferp);
	//
    ASSERT(Bufferp != NULL);


    //
    // Outgoing packet reset the Timeout for this.
    //
    this->ResetTimer();


	srcIp		= Bufferp->ReadAddress.sin_addr.S_un.S_addr;

	srcPort	    = Bufferp->ReadAddress.sin_port;

	ICQ_TRC(TM_MSG, TL_DUMP, ("ICQ_CL->ClientRead> Sending TO Server %s", 
                              INET_NTOA(serverIp)));

	ASSERT(srcIp is ClientIp); 

    //
	// ClientPort has changed.
	//
	if(srcPort != ClientToServerPort)
	{
		ICQ_TRC(TM_MSG, TL_INFO, 
			    ("CLIENT PORT HAS CHANGED !!!!!! new %hu: old %hu ",
                 htons(srcPort), htons(ClientToServerPort)));

		ClientToServerPort = srcPort;
	}


	// 
	// Decide wether shadow mapping is necessary or not.
	// if the destination is changed than we need another shadow mapping - delete the old one.
	//
	
	
	//
	// decide the Destination Address
	// if we have an existing  mapping and the address has changed than
	// delete the OLD SHADOW mapping.. and re-init a new one.
	//
	if( (this->ServerIp   != serverIp)  || 
	    (this->ServerPort != serverPort) )
	{
		ICQ_TRC(TM_MSG, TL_ERROR, 
			    ("!! A NEW SERVER IS SELECTED !! %s ", INET_NTOA(serverIp)));

        //
		// DELETE the existing shadow mapping if there is one.
        //
		if(this->ShadowRedirectp != NULL) 
		{

            ICQ_TRC(TM_MSG, TL_TRACE, 
                    ("Cancelling the Shadow Redirect i.e. CreateProxyConnect"));

            Error = ShadowRedirectp->Cancel();

            if( FAILED(Error) )
            {
                ICQ_TRC(TM_MSG, TL_ERROR,
                        ("** !! - Problemo with Cancelling ShadowRedirect- !! **"));
            }

            ShadowRedirectp->Release();

            this->ShadowRedirectp = NULL;
		}

        //
		// store the new informaiton
        //
		this->ServerIp   = serverIp;

		this->ServerPort = serverPort;
	}

    dstIp   = this->ServerIp;

    dstPort = this->ServerPort;



	//
	// NOTE: Check for the Error value here..
    // Process the Message
    //
	Error = IcqClientToServerUdp(Bufferp->Buffer, 
			        			 Bufferp->BytesTransferred);

    if(Error)
    {
        ICQ_TRC(TM_MSG, TL_ERROR,
                ("Can't Allocate enough resource for Login Packet"));

        NhReleaseBuffer(Bufferp);

        return Error;
    }

	// 
	// Check the shadow-mapping to the destination from this port.
	// This should have been created in the Initialization phase.
    //
	if ( this->ShadowRedirectp is NULL )
	{
		ICQ_TRC(TM_MSG, TL_TRACE, ("!! CREATING SHADOW redirect - !!"));

		//
		// Get the local endpoint?! for src address
		//
		ServerSocketp->NhQueryLocalEndpointSocket(&LocalIp,
                                                  &LocalPort);

        Error =  g_IAlgServicesp->GetBestSourceAddressForDestinationAddress(dstIp,
                                                                            TRUE,
                                                                            &LocalIp);
        if( FAILED(Error) )
        {
            ICQ_TRC(TM_MSG, TL_ERROR, 
                    ("** !! - Best Source Address for Dest Failed !! **"));

            ASSERT ( FALSE );
        }

        ICQ_TRC(TM_MSG, TL_TRACE, ("Best Source address is decided as %s", INET_NTOA(LocalIp)));

        Error = g_IAlgServicesp->PrepareProxyConnection(eALG_UDP,
                                                        LocalIp,
                                                        LocalPort,
                                                        dstIp,
                                                        dstPort,
                                                        TRUE,
                                                        &ShadowRedirectp);

        //
        // If the Shadow Redirect fails don't go further. 
        // Release the Buffer and exit, 
        // this may be a transitory behaviour.
        //
        if( FAILED(Error) )
        {
            ICQ_TRC(TM_MSG, TL_ERROR,
                    (" ** !! - ShadowRedirect has Failed - proxy connection !! **"));

            NhReleaseBuffer(Bufferp);

            this->ShadowRedirectp = NULL;

            return E_FAIL;
        }

	}

    //
	// Write to Destination of the Processed packet
    //
	Error = ServerSocketp->NhWriteDatagramSocket(g_IcqComponentReferencep,
                                                 dstIp,
                                                 dstPort,
                                                 Bufferp,
                                                 Bufferp->BytesTransferred,
                                                 IcqWriteCompletionRoutine,
                                                 NULL,
                                                 NULL);

	if(Error) 
	{ 
		ICQ_TRC(TM_MSG, TL_ERROR, ("** !! WRITE ERROR !!! **")); 

        NhReleaseBuffer(Bufferp);
	}
	
	return Error;
}






//
//
//
ISecondaryControlChannel *
_ICQ_CLIENT::PeerRedirection(
                				ULONG dstIp,
                				USHORT dstPort,
                				ULONG srcIp OPTIONAL,
                				USHORT srcPort OPTIONAL,
                				ICQ_DIRECTION_FLAGS DirectionContext
                			)
/*++

Routine Description:

      The Advertised PEER-CONTROL connection port is the dstPort here. This 
      function creates the Redirection for this connection as a 
      SecondaryControl Channel connection.
      
      Then indicates that a incoming TCP connection is going to be dispatched 
      by the Dispatcher Class to us. So it request a Dispatch Service.
    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ULONG Error  = NO_ERROR;

	ISecondaryControlChannel* SecondaryControlRedirectionp = NULL;
	
    PDispatchRequest DRp = NULL;

    ULONG  PrivateAddr = 0, PublicAddr = 0, RemoteAddr = 0, ListenAddr = 0;
    USHORT PrivatePort = 0, PublicPort = 0, RemotePort = 0, ListenPort = 0;


	do
	{
		//
		// step 2 - create a redirection for the TCP packets destined to this port
		// NOTE: should we change this to a FULL redirect one?
        //
		g_IcqPeerDispatcherp->GetDispatchInfo( &ListenAddr, &ListenPort );

        ICQ_TRC(TM_MSG, TL_DUMP, ("Listen addr of Dispatcher %s(%hu)", 
                                  INET_NTOA(ListenAddr), ListenPort));

        ASSERT ( ListenAddr != 0 );
        ASSERT ( ListenPort != 0 );

        if ( DirectionContext is eALG_INBOUND )
        {
            PrivateAddr = 0;
            PrivatePort = 0;
            PublicAddr  = dstIp;
            PublicPort  = dstPort;
            RemoteAddr  = 0;
            RemotePort  = 0;

            ICQ_TRC(TM_MSG, TL_INFO,
                    ("CLIENT_CONTROL_CHANNEL> Inbound %s:%hu -> Local:%hu",
                     INET_NTOA(dstIp), htons(dstPort), htons(ListenPort)));
        }
        else if ( DirectionContext is eALG_OUTBOUND )
        {
            PrivateAddr = srcIp;
            PrivatePort = srcPort;
            PublicAddr  = 0;
            PublicPort  = 0;
            RemoteAddr  = dstIp;
            RemotePort  = dstPort;

            ICQ_TRC(TM_MSG, TL_INFO,
                    ("CLIENT_CONTROL_CHANNEL> Outbound %s:%hu <- Local:%hu",
                     INET_NTOA(dstIp), htons(dstPort), htons(ListenPort)));
            
            ICQ_TRC(TM_MSG, TL_INFO,
                    ("PEER_CONTROL_CHANNEL> Restrict SRC to %s:%u",
                     INET_NTOA(PrivateAddr), htons(PrivatePort)));

        } 
        else { ASSERT(FALSE); }

        Error = 
            g_IAlgServicesp->CreateSecondaryControlChannel(eALG_TCP,
                                                           PrivateAddr,
                                                           PrivatePort,
                                                           PublicAddr,
                                                           PublicPort,
                                                           RemoteAddr,
                                                           RemotePort,
                                                           ListenAddr,
                                                           ListenPort,
                                                           (ALG_DIRECTION)DirectionContext,
                                                           FALSE,
                                                           &SecondaryControlRedirectionp);

        if( FAILED(Error) || (SecondaryControlRedirectionp is NULL) )
        {
            ICQ_TRC(TM_MSG, TL_ERROR, ("Can't create the secondary ctrl redirect"));

            ASSERT(FALSE);

            break;
        }

        //
		// step 3 - Request a Dispatch for this TCP redirection 
        //

        NEW_OBJECT( DRp, DispatchRequest );
		
		if ( DRp is NULL )
		{
			Error = E_OUTOFMEMORY;
			
            //
			// clear redirect 
            //
			SecondaryControlRedirectionp->Cancel();

            SecondaryControlRedirectionp->Release();

			SecondaryControlRedirectionp = NULL;

			ICQ_TRC(TM_MSG, TL_ERROR, 
				    ("Error - Out of memory to create a new DispatchRequest"));

			break;
		}

		DRp->dstIp              = dstIp;	  // *
		DRp->dstPort            = dstPort;	  //*
		DRp->srcIp              = srcIp;
		DRp->srcPort            = srcPort;
		DRp->DirectionContext   = DirectionContext;

		//
		// set the search Keys.	
        //
		DRp->iKey1 = dstIp;
		DRp->iKey2 = dstPort;

		g_IcqPeerDispatcherp->AddDispatchRequest ( this, DRp );

        //
        // Store the redirect, to be used in Searches.
        //
        if ( DirectionContext is eALG_INBOUND )
        {
            this->IncomingRedirectForPeerToClientp = SecondaryControlRedirectionp;
        }

        //
        // Relinquish the ownwership of the request
        //
        DEREF_COMPONENT( DRp, eRefInitialization );

	} while (FALSE);

	return SecondaryControlRedirectionp;
} // _ICQ_CLIENT::PeerRedirection


							

// scan the list to get the peers
//CLIST g_IcqClientList; 
PICQ_CLIENT
ScanTheListForLocalPeer
    (
    	PULONG PeerIp, 
    	PUSHORT PeerPort,
    	ULONG IcqUIN
    )
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	PICQ_CLIENT IcqClientp = NULL;

	for(IcqClientp = dynamic_cast<PICQ_CLIENT>(g_IcqClientList.SearchNodeKeys(0, 0));
		IcqClientp != NULL;
		IcqClientp = dynamic_cast<PICQ_CLIENT>(IcqClientp->Nextp)
       )
	{
		//
		// IF we have a hit return TRUE otherwise don't change anything
		//
		if(IcqClientp->UIN is IcqUIN)
		{
			if(PeerIp != NULL)
            {
                if(IcqClientp->ClientIp is g_MyPublicIp)
                {
                    *PeerIp = g_MyPrivateIp;
                }
                else
                {
                    *PeerIp = IcqClientp->ClientIp;
                }
            }

			if(PeerPort != NULL)
            {
                *PeerPort = IcqClientp->ClientToPeerPort;
            }

			return IcqClientp;
		}
	}

	return NULL;
}





//
// Debugging utilities.
// 
VOID
_ICQ_CLIENT::ReportExistingPeers(VOID)
/*++

Routine Description:

    Report Informations about the All the Peers existing for this client.
    
Arguments:

    none.

Return Value:

    none.    

--*/
{
	PICQ_PEER IcqPeerp = NULL;

    for(IcqPeerp = dynamic_cast<PICQ_PEER> (this->IcqPeerList.SearchNodeKeys(0, 0));
        IcqPeerp != NULL;
        IcqPeerp = dynamic_cast<PICQ_PEER>(IcqPeerp->Nextp))
    {
        ICQ_TRC(TM_MSG, TL_INFO, 
                ("PeerIP(PORT) is %s(%hu)", 
                 INET_NTOA(IcqPeerp->PeerIp), htons(IcqPeerp->PeerPort)));

        ICQ_TRC(TM_MSG, TL_TRACE,
                ("IncomingDataRedirect %s, OutgoingRedirect %s, MappingDirection %s, "\
                 "ShadowRedirect %s, ToClientSocketp %s, ToPeerSocketp %s",
                  (IcqPeerp->IncomingDataRedirectp is NULL)?"FALSE":"TRUE",
                  (IcqPeerp->OutgoingPeerControlRedirectp is NULL)?"FALSE":"TRUE",
                  (IcqPeerp->MappingDirection is eALG_OUTBOUND)?"OUT":"IN",
                  (IcqPeerp->ShadowRedirectp is NULL)?"FALSE":"TRUE",
                  (IcqPeerp->ToClientSocketp is NULL)?"FALSE":"TRUE",
                  (IcqPeerp->ToPeerSocketp is NULL)?"FALSE":"TRUE"));
    }
}





ULONG
_ICQ_CLIENT::DeleteTimer(TIMER_DELETION bHow)
{
    if(this->TimerContextp != NULL)
    {
        if(bHow is eTIMER_DELETION_SYNC)
        {
            DeleteTimerQueueTimer(g_TimerQueueHandle,
                                  this->TimerContextp->TimerHandle,
                                  INVALID_HANDLE_VALUE);
        }
        else if(bHow is eTIMER_DELETION_ASYNC)
        {
            DeleteTimerQueueTimer(g_TimerQueueHandle,
                                  this->TimerContextp->TimerHandle,
                                  NULL);
        }

        NH_FREE(this->TimerContextp);

        this->TimerContextp = NULL;
    }

    return NO_ERROR;
}



ULONG
_ICQ_CLIENT::ResetTimer(VOID)
{
    
    this->DeleteTimer(eTIMER_DELETION_SYNC);

    this->TimerContextp = AllocateAndSetTimer(this->UIN,
                                              ICQ_CLIENT_TIMEOUT,
                                              IcqClientTimeoutHandler);

    if(TimerContextp != NULL)
    {
        return S_OK;
    }
    
    return E_FAIL;
}



// typedef VOID (NTAPI * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );   // winnt

VOID NTAPI IcqClientTimeoutHandler( 
                                    PVOID Parameterp,
                                    BOOLEAN TimerOrWaitFired
                                  )
{
    PTIMER_CONTEXT TimerContextp = (PTIMER_CONTEXT)Parameterp;
    
    PICQ_CLIENT    IcqClientp    = NULL;


    if(TimerContextp is NULL)
    {
        return;
    }

    PROFILER(TM_TIMER, TL_INFO, ("TIME-OUT for Client (%u)", 
                                 TimerContextp->uContext));

    IcqClientp = ScanTheListForLocalPeer(NULL,
                                         NULL,
                                         TimerContextp->uContext);

    //
    // Delete the Client Here
    //
    if(IcqClientp != NULL)
    {
        IcqClientp->DeleteTimer(eTIMER_DELETION_ASYNC);

        g_IcqClientList.RemoveNodeFromList(IcqClientp); // stops and derefs
    }
    else
    {
        ASSERT(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\buffer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains code for buffer-management.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "stdafx.h"



#include "nathlpp.h"
#include "list.h"
//#include "socket.h"

LIST_ENTRY NhpBufferQueue;
LONG NhpBufferQueueLength;
CRITICAL_SECTION NhpBufferQueueLock;

PNH_BUFFER
NhAcquireFixedLengthBuffer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer.
    If no buffer is available on the buffer queue, a new one is obtained.

Arguments:

    none.

Return Value:

    PNH_BUFFER - the buffer allocated

--*/

{
    PNH_BUFFER Buffer;
    PLIST_ENTRY Link;
    EnterCriticalSection(&NhpBufferQueueLock);
    if (!IsListEmpty(&NhpBufferQueue)) {
        Link = RemoveHeadList(&NhpBufferQueue);
        LeaveCriticalSection(&NhpBufferQueueLock);
        InterlockedDecrement(&NhpBufferQueueLength);
        Buffer = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        Buffer->Type = NhFixedLengthBufferType;
        return Buffer;
    }
    LeaveCriticalSection(&NhpBufferQueueLock);
    Buffer = NH_ALLOCATE_BUFFER();
    if (Buffer) {
        Buffer->Type = NhFixedLengthBufferType;
    }
    return Buffer;
} // NhAcquireFixedLengthBuffer


PNH_BUFFER
NhAcquireVariableLengthBuffer(
    ULONG Length
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer of non-standard size.
    If the length requested is less than or equal to 'NH_BUFFER_SIZE',
    a buffer from the shared buffer-queue is returned.
    Otherwise, a buffer is especially allocated for the caller.

Arguments:

    Length - the length of the buffer required.

Return Value:

    PNH_BUFFER - the buffer allocated.

--*/

{
    PNH_BUFFER Buffer;
    if (Length <= NH_BUFFER_SIZE) {
        return NhAcquireFixedLengthBuffer();
    }
    Buffer = reinterpret_cast<PNH_BUFFER>(
                NH_ALLOCATE(FIELD_OFFSET(NH_BUFFER, Buffer[Length]))
                );
                
    if (Buffer) { Buffer->Type = NhVariableLengthBufferType; }
    return Buffer;
} // NhAcquireVariableLengthBuffer


PNH_BUFFER
NhDuplicateBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine creates a duplicate of the given buffer,
    including both its data and its control information.

    N.B. Variable-length buffers cannot be duplicated by this routine.

Arguments:

    Bufferp - the buffer to be duplicated

Return Value:

    PNH_BUFFER - a pointer to the duplicate

--*/

{
    PNH_BUFFER Duplicatep;
    //ASSERT(Bufferp->Type == NhFixedLengthBufferType);
    if (!(Duplicatep = NhAcquireBuffer())) { return NULL; }
    *Duplicatep = *Bufferp;
    return Duplicatep;
} // NhDuplicateBuffer


ULONG
NhInitializeBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine readies the buffer-management for operation.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    InitializeListHead(&NhpBufferQueue);
    NhpBufferQueueLength = 0;
    __try {
        InitializeCriticalSection(&NhpBufferQueueLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
/*
        NhTrace(
            TRACE_FLAG_BUFFER,
            "NhInitializeBufferManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );*/
    }

    return Error;

} // NhInitializeBufferManagement


VOID
NhReleaseBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to release a buffer to the buffer queue.
    It attempts to place the buffer on the queue for re-use, unless
    the queue is full in which case the buffer is immediately freed.

Arguments:

    Bufferp - the buffer to be released

Return Value:

    none.

--*/

{
    if (NhpBufferQueueLength > NH_MAX_BUFFER_QUEUE_LENGTH ||
        Bufferp->Type != NhFixedLengthBufferType) {
        NH_FREE_BUFFER(Bufferp);
    } else {
        EnterCriticalSection(&NhpBufferQueueLock);
        InsertHeadList(&NhpBufferQueue, &Bufferp->Link);
        LeaveCriticalSection(&NhpBufferQueueLock);
        InterlockedIncrement(&NhpBufferQueueLength);
    }
} // NhReleaseBuffer



VOID
NhShutdownBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine cleans up resources used by the buffer-management module.
    It assumes the list will not be accessed while the clean up is in progress.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNH_BUFFER Bufferp;

    while (!IsListEmpty(&NhpBufferQueue)) {
        Link = RemoveHeadList(&NhpBufferQueue);
        Bufferp = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        NH_FREE_BUFFER(Bufferp);
    }

    DeleteCriticalSection(&NhpBufferQueueLock);
    NhpBufferQueueLength = 0;

} // NhShutdownBufferManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\compref.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    compref.h

Abstract:

    This module contains declarations for maintaining reference-count
    on a component. It provides an asynchronous thread-safe means of
    handling cleanup in a module.

    The mechanism defined uses a locked reference count and cleanup-routine
    to manage the lifetime of the component. When the reference-count
    is dropped to zero, the associated cleanup-routine is invoked.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_COMPREF_H_
#define _NATHLP_COMPREF_H_


#if 0
typedef
VOID
(*PCOMPONENT_CLEANUP_ROUTINE)(
    VOID
    );

//
// Structure:   COMPONENT_REFERENCE
//
// This structure must reside in memory for the lifetime of the component
// to which it refers. It is used to synchronize the component's execution.
//

typedef struct _COMPONENT_REFERENCE {
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    BOOLEAN Deleted;
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine;
#if COMPREF_TRACKING
    struct _COMPREF_RECORD* RecordArray;
    ULONG RecordIndex;
#endif
} COMPONENT_REFERENCE, *PCOMPONENT_REFERENCE;

#if COMPREF_TRACKING
#define COMPREF_RECORD_COUNT    (1024)
typedef struct _COMPREF_RECORD {
    PCHAR File;
    USHORT Line;
    UCHAR ReferenceCount;
    enum {
        ComprefAcquireRecord,
        ComprefReleaseRecord
    } Type;
} COMPREF_RECORD, *PCOMPREF_RECORD;
#endif


//
// FUNCTION DECLARATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    );

#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    );
#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

//
// MACRO DECLARATIONS
//

#define RETURN_VOID

#if COMPREF_TRACKING

#define REFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)

#define DEREFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord); \
    return retcode

#else

#define REFERENCE_COMPONENT(c) \
    AcquireComponentReference(c)

#define DEREFERENCE_COMPONENT(c) \
    ReleaseComponentReference(c)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!AcquireComponentReference(c)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    ReleaseComponentReference(c); return retcode

#endif


//
// INLINE ROUTINE IMPLEMENTATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    ++ComponentReference->ReferenceCount;
    LeaveCriticalSection(&ComponentReference->Lock);
    return TRUE;

} // AcquireComponentReference


VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the last reference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/

{
    DeleteCriticalSection(&ComponentReference->Lock);
#if COMPREF_TRACKING
    HeapFree(GetProcessHeap(), 0, ComponentReference->RecordArray);
#endif

} // DeleteComponentReference


ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    )

/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/

{
    __try {
        InitializeCriticalSection(&ComponentReference->Lock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    ComponentReference->Deleted = FALSE;
    ComponentReference->ReferenceCount = 1;
    ComponentReference->CleanupRoutine = CleanupRoutine;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ComponentReference->RecordArray =
        HeapAlloc(
            GetProcessHeap(), 0, sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
            );
#endif
    return NO_ERROR;

} // InitializeComponentReference



#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    )
{
    BOOLEAN Success;
    ULONG i = InterlockedIncrement(&ComponentReference->RecordIndex);
    i %= COMPREF_RECORD_COUNT;
    ComponentReference->RecordArray[i].File = File;
    ComponentReference->RecordArray[i].Line = (USHORT)Line;
    ComponentReference->RecordArray[i].Type = Type;
    if (Type == ComprefAcquireRecord) {
        Success = AcquireComponentReference(ComponentReference);
    } else {
        Success = ReleaseComponentReference(ComponentReference);
    }
    ComponentReference->RecordArray[i].ReferenceCount =
        (UCHAR)ComponentReference->ReferenceCount;
    return Success;
}

#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseComponentReference


__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return TRUE;
    }
    ComponentReference->Deleted = TRUE;
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseInitialComponentReference


__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    ComponentReference->ReferenceCount = 1;
    ComponentReference->Deleted = FALSE;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ZeroMemory(
        ComponentReference->RecordArray,
        sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
        );
#endif
    LeaveCriticalSection(&ComponentReference->Lock);
} // ReleaseComponentReference

#endif

#endif // _NATHLP_COMPREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\dispatcher.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    

Abstract:

    

Author:

    Savas Guven (savasg)   27-Nov-2000

Revision History:

--*/

#include "stdafx.h"


//
// Initialize the static member 
//
ULONG CSockDispatcher::UniqueId = 0;

const PCHAR CSockDispatcher::ObjectNamep = "CSockDispatcher";

const PCHAR DispatcheeNode::ObjectNamep = "DispatcheeNode";

const PCHAR _Dispatchee::ObjectNamep = "DISPATCHEE";




//
// Anythin to initialize?
//
CSockDispatcher::CSockDispatcher()
{
	ICQ_TRC(TM_DISP, TL_DUMP, (" CSockDispatcher - Default Constructor "));	
}



//
// 
CSockDispatcher::CSockDispatcher
							(
								ULONG IpAddress,
								USHORT port
							)
/*++

Routine Description:

    This function Should simplY call the InitDispatcher with the appropriate
    parameters passed here.

Arguments:

    none.

Return Value:

    

--*/
{
	ICQ_TRC(TM_DISP, TL_DUMP, (" CSockDispatcher - CNSTR with IP and PORT %hu ", htons(port)));	

	this->InitDispatcher(IpAddress, port);
}

//
// What needs to be deleted. ?
// All the DispatcheeNodes needs to be deleted.
//
CSockDispatcher::~CSockDispatcher()
{
	ICQ_TRC(TM_DISP, TL_DUMP, ("CSockDispatcher - ~ DESTRUCTOR "));	

	if(this->bCleanupCalled is FALSE)
	{
		CSockDispatcher::ComponentCleanUpRoutine();
	}

	//
	// This will cause the Destructors of inherited classes to 
	// be called which will call their respective Cleanups
	//
	this->bCleanupCalled = FALSE;
}


//
//
ULONG
CSockDispatcher::InitDispatcher
							(
								ULONG IpAddress,
								USHORT port
							)
/*++

Routine Description:

    InitDispatcher initializes the socket and issues an Accept
    Furthermore It needs to  Reference for the Accept call 
    (which should be dereferenced at at the AcceptCompletion

Arguments:

    ULONG IpAddress - IP on which the TCP socket (for accept) should wait on.
    USHORT port - Port on which the TCP socket (for accept) should wait on.
    

Return Value:
    
    Returns the ULONG Win32/Winsock2 Error code
    

--*/
{
	ULONG Error = NO_ERROR;

	ICQ_TRC(TM_DISP, TL_DUMP, ("CSockDispatcher - InitDispatcher "));	

    //
	// Create a stream scoket on the given IP and PORT
    //
	Error = this->NhCreateStreamSocket(IpAddress, port, NULL);

    if(Error)
    {
        ErrorOut();

        ICQ_TRC(TM_DISP, TL_ERROR, 
                ("CSockDispatcher - Init> can't create the SOCKET"));

        return Error;
    }


	Error = listen(this->Socket, SOMAXCONN);

    if(Error)
    {
        ICQ_TRC(TM_DISP, TL_ERROR, 
                ("CSockDispatcher - Init>  Can' Listen the Created socket"));

        ErrorOut();

        return Error;
    }

	//
	// Since the Socket inheritance guarantees that
	// the REFERENCING of the self-object will be done
	// we should not reference ourselves again  here.
	//
	Error = this->NhAcceptStreamSocket(g_IcqComponentReferencep,
									   NULL,
									   NULL,
									   DispatcherAcceptCompletionRoutine,
									   this,
									   NULL);
    if(Error)
    {
        ICQ_TRC(TM_DISP, TL_ERROR, 
                ("CSockDispatch - Init>  Accept call has failed"));

        ErrorOut();
    }

	return Error;
}	


void
CSockDispatcher::ComponentCleanUpRoutine(void)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	DispatcheeNode * DNp = NULL;

	ICQ_TRC(TM_DISP, TL_DUMP, (" CSockDispatcher - ComponentCleanUpRoutine "));	
	
    this->bCleanupCalled = TRUE;
}


void
CSockDispatcher::StopSync(void)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
    this->NhDeleteSocket();

    this->Deleted = TRUE;
}


//
//
ULONG 
CSockDispatcher::InitDispatchee(PDISPATCHEE Dispatchp)
/*++

Routine Description:

    Gives a unique ID to the Dispatchee and then 
    creates a Dispatchee node to put the dispatchee into a List.. 
    (If it is not there already) the counter of the dispatcher 
    should be incremented.
    
    
Arguments:

    none.

Return Value:

    

--*/
{
	DispatcheeNode * DNp = NULL;

	ICQ_TRC(TM_DISP, TL_DUMP, ("CSockDispatcher - InitDispatchee "));	

	if(Dispatchp is NULL) return 0; // Unknown Parameter

	if(Dispatchp->GetID() != 0) return 0; // " "

	this->AcquireLock();
	
	Dispatchp->SetID(++UniqueId);
	
	this->ReleaseLock();

    NEW_OBJECT(DNp, DispatcheeNode);
	
    //DNp = new DispatcheeNode();
	
	if(DNp is NULL) 
	{
		Dispatchp->SetID(0);

		return FALSE;
	}

    DNp->InitDispatcheeNode( Dispatchp );
	
	this->listDispNodes.InsertSorted( DNp );

	//
	// We dereference the DispatcheeNode so that its life time ends, 
	// when it is removed from the list.
    //
	DEREF_COMPONENT( DNp, eRefInitialization );	
	
	return S_OK;
}

//
//
ULONG
CSockDispatcher::RemoveDispatchee(PDISPATCHEE Dispatchp)
{
    DispatcheeNode* DNp = NULL;

    ICQ_TRC(TM_DISP, TL_INFO, ("CSockDispatcher - InitDispatchee "));

    if ( Dispatchp is NULL ) { ASSERT( FALSE ); return E_INVALIDARG;}

    if ( Dispatchp->GetID() == 0) { ASSERT(FALSE); return E_INVALIDARG;}

    
    DNp = dynamic_cast<DispatcheeNode*>(this->listDispNodes.SearchNodeKeys(Dispatchp->GetID(), 0));

    if ( DNp is NULL)  { ASSERT( FALSE ); return E_INVALIDARG; }

    this->listDispNodes.RemoveNodeFromList(DNp);

    return S_OK;
}


//
//
ULONG
CSockDispatcher::GetDispatchInfo
							(
								PULONG IPp, 
								PUSHORT Portp
							)
/*++

Routine Description:

    Should Return the IP and Port on which this Dispatcher is operating.    
    
Arguments:

    PULONG IPp - The IP on which the Dispatcher is operating  .
    PUSHORT Portp - The 

Return Value:

    

--*/
{
	if(IPp is NULL || Portp is NULL)
		return 0; // Fail

	this->NhQueryLocalEndpointSocket(IPp, Portp);

	return 1;
}


//
//
ULONG
CSockDispatcher::AddDispatchRequest
							(
								PDISPATCHEE Dispatchp,
								PDispatchRequest DispatchRequestp
							)
/*++

Routine Description:

    This will add a Dispatch Request to the related Dispatch Node's request list.    
    
Arguments:

    none.

Return Value:

    

--*/
{
	DispatcheeNode * DNp = NULL;

	if(Dispatchp is NULL || DispatchRequestp is NULL)
    {
		return E_INVALIDARG; // FAIL.
    }
	
    //
	// Is there such an entry?
    //
	DNp = dynamic_cast<DispatcheeNode*>
							(this->listDispNodes.SearchNodeKeys(Dispatchp->GetID(), 0));


	if(DNp is NULL) 
	{
		ASSERT ( FALSE );

		return E_INVALIDARG; // FAIL
	}

	DNp->AddDispatchRequest(DispatchRequestp);

	return 1;
}


//
// This will Delete a DispatchRequest. Note that  Dispatched Requests are removed
// from the list 
//
ULONG
CSockDispatcher::DeleteDispatchRequest
							(
								PDispatchRequest DispatchRequestp
							)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	DispatcheeNode * DNp = NULL;
    DispatchReply DR;



	if(DispatchRequestp is NULL)
		return E_FAIL; // FAIL

    ZeroMemory(&DR, sizeof(DispatchReply));

    DR.dispatch.dstIp   = DispatchRequestp->dstIp;
    DR.dispatch.dstPort = DispatchRequestp->dstPort;
    DR.dispatch.srcIp   = DispatchRequestp->srcIp;
    DR.dispatch.srcPort = DispatchRequestp->srcPort;

	this->AcquireLock();

    for (DNp = dynamic_cast<DispatcheeNode*>(this->listDispNodes.SearchNodeKeys(0,0));
         DNp != NULL;
         DNp = dynamic_cast<DispatcheeNode*>(DNp->Nextp))
    {
        if(DNp->isDispatchYours(&DR))
        {
            DNp->DeleteDispatchRequest(DispatchRequestp);     

            this->ReleaseLock();

            return NO_ERROR;
        }
    }
	

    this->ReleaseLock();

	return  NO_ERROR;
}








// 
// DispatcherNode MEMBER functions.
//

//
//
//
DispatcheeNode::~DispatcheeNode()
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/

{
	ICQ_TRC(TM_DISP, TL_DUMP, (" DispatcheeNode - Destructor"));	

	if(this->bCleanupCalled is FALSE)
	{
		DispatcheeNode::ComponentCleanUpRoutine();
	}

	this->bCleanupCalled = FALSE;
}


//
//
//
void
DispatcheeNode::ComponentCleanUpRoutine(void)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ICQ_TRC(TM_DISP, TL_DUMP, (" DispatcheeNode - CLEAN UP"));
	// PDispatchRequest DRp = NULL;


	// Dereference the Dispatchee.
	DEREF_COMPONENT( DispatchTop, eRefInitialization );

    DispatchTop = NULL;

	// Remove the List elements.
	// Destructor of the List class will handle this 
	this->bCleanupCalled = TRUE;
}


VOID
DispatcheeNode::InitDispatcheeNode(PDISPATCHEE Dispatchp)
/*++

Routine Description:

    Note that a This Dispatching is intended to work on redirected TCP connections
    Thus the search Key is working on Destinations pairs 

Arguments:

    none.

Return Value:


NOTE:

    It references the Dispatchee Pointer. and the dereferencing will be done only
    When this OBJECT is dereferenced to NULL,
    
    Which happens only if this Node is deleted from the Dispatchee Node List 
    within the CSockDispatcher. (At the time of destruction.)
    
--*/

{
	DispatchTop = Dispatchp;

    //ASSERT(Dispatchp);
    
	REF_COMPONENT( Dispatchp, eRefSecondLevel );

	if(DispatchTop != NULL)
	{
		this->iKey1 = Dispatchp->GetID();
		this->iKey2 = 0;
	}
	else
	{
		this->iKey1 = 0;
		this->iKey2 = 0;
	}
}



ULONG
DispatcheeNode::isDispatchYours(PDispatchReply DispatchReplyp)
/*++

Routine Description:

    From the Reply structure we search for the existing Dispatch Requests
    This will reveal us wether such a query exists or not.
    Note that the Search Keys just contain the destination
    metric (IP:PORT)

Arguments:

    none.

Return Value:

    

--*/
{
	PDispatchRequest DRp = NULL;
	// DispatchReplyp->dispatch
	if(DispatchReplyp is NULL) return 0; //FAIL

	DRp = dynamic_cast<PDispatchRequest>
							(listRequests.SearchNodeKeys(DispatchReplyp->dispatch.dstIp, 
														 DispatchReplyp->dispatch.dstPort
														)
							);
	if(DRp != NULL)
	{
		//
		// So that we know where the data came from.. 
		// NOTE: that along with the interfaces this schema may change.
		//
		DispatchReplyp->dispatch.DirectionContext = DRp->DirectionContext;

		// check the source addresses as well. Unless they are zero
		if((DRp->srcIp != 0) && 
           (DispatchReplyp->dispatch.srcIp != NULL))
		{
			if(DispatchReplyp->dispatch.srcIp is DRp->srcIp )
			{
				return TRUE;
			}

			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}


//
// Add a Request for Dispatch to the existing list of items - if it is not existing
//
ULONG
DispatcheeNode::AddDispatchRequest(PDispatchRequest DispatchRequestp)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/                          
{
	PDispatchRequest DRp = NULL;

	if(DispatchRequestp is NULL) return 0; // FAIL

	//
	// Is there such an entry already? IF there is one than ignore !?!?
	DRp = dynamic_cast<PDispatchRequest> 
							(listRequests.SearchNodeKeys(DispatchRequestp->dstIp,
                                                         DispatchRequestp->dstPort));
	if(DRp is NULL)
	{
		listRequests.InsertSorted(DispatchRequestp);
	}
	
	return TRUE;
}

//
//
//
ULONG
DispatcheeNode::DeleteDispatchRequest(PDispatchRequest DispatchRequestp)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	PDispatchRequest DRp = NULL;

	if(DispatchRequestp is NULL) return 0; // FAIL

	DRp = dynamic_cast<PDispatchRequest>
							(listRequests.SearchNodeKeys(DispatchRequestp->dstIp,
                                                         DispatchRequestp->dstPort));
	if(DRp is NULL)
	{
		return  TRUE;
	}
	else
	{
		listRequests.RemoveNodeFromList(DRp);
	}

	return NO_ERROR; // SUCCESS
}


ULONG
CSockDispatcher::GetOriginalDestination(
                                        PNH_BUFFER Bufferp,
                                        PULONG     OriginalDestinationAddressp,
                                        PUSHORT    OriginalDestinationPortp
                                       )
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
    PCNhSock AcceptedSocketp = NULL;

    ULONG           Error = 0, LocalAddress = 0, ActualClientAddress = 0;
    USHORT          LocalPort = 0, ActualClientPort = 0;
    DispatcheeNode* DispatcheeNodep = NULL;

    ICQ_TRC(TM_DISP, TL_TRACE, (" Dispatcher - GetOrigDest"));

    do
    {
        AcceptedSocketp = Bufferp->Socketp;

        ASSERT(AcceptedSocketp != NULL);

		AcceptedSocketp->NhQueryRemoteEndpointSocket(&ActualClientAddress,
                                                     &ActualClientPort);

		ICQ_TRC(TM_DISP, TL_INFO, 
                (" Dispatcher> Accept Completion SRC IP %s, PORT %hu",
			    INET_NTOA(ActualClientAddress), htons(ActualClientPort)));

        // 
        // Get a Sample Dispatchee Node which has a SecondaryControlChannel
        // to ask the Destinations.
        //

        DispatcheeNodep = dynamic_cast<DispatcheeNode*>
                                (this->listDispNodes.SearchNodeKeys(0,0));

        ASSERT(DispatcheeNodep != NULL);

        Error = DispatcheeNodep->GetOriginalDestination(ActualClientAddress,
                                                        ActualClientPort,
                                                        OriginalDestinationAddressp,
                                                        OriginalDestinationPortp);

        if( FAILED(Error) )
        {
            ICQ_TRC(TM_DISP, TL_ERROR,
                    ("** !! Getting the ORIGINAL destination has failed "));

            ASSERT( FALSE );

            break;
        }

        ICQ_TRC(TM_DISP, TL_INFO,
                ("Original Destionation IP:(PORT) is %s:(%hu)",
                 INET_NTOA(*OriginalDestinationAddressp), 
                 htons(*OriginalDestinationPortp)));

    } while(FALSE);

    return Error;
}

ULONG 
DispatcheeNode::GetOriginalDestination(ULONG   SrcAddress,
                                       USHORT  SrcPort,
                                       PULONG  DestAddrp,
                                       PUSHORT DestPortp)
{
    return
    DispatchTop->IncomingRedirectForPeerToClientp->GetOriginalDestinationInformation(SrcAddress,
                                                                                     SrcPort,
                                                                                     DestAddrp,
                                                                                     DestPortp,
                                                                                     NULL);

}


VOID
DispatcherAcceptCompletionRoutine
							(
								ULONG ErrorCode,
								ULONG BytesTransferred,
								PNH_BUFFER Bufferp
							 )
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	CSockDispatcher * SDp			= NULL;
	PCNhSock AcceptedSocketp  = NULL;
	ULONG Error = 0, ErrorLevel = 0;
	DispatcheeNode * DNp;
	
	
    ULONG  ActualClientAddress = 0, ActualDestinationAddress = 0;
	USHORT ActualClientPort = 0, ActualDestinationPort = 0;

    //	NAT_KEY_SESSION_MAPPING_EX_INFORMATION natKey;
	ULONG keyLength;
	PDispatchReply DRp = NULL;
	
	ICQ_TRC(TM_DISP, TL_TRACE, (" Dispatcher - AcceptCompletionRoutine"));

	do 
	{
		SDp				 = reinterpret_cast<CSockDispatcher *> (Bufferp->Context);

		AcceptedSocketp  = Bufferp->Socketp;

		ErrorLevel = 1;

		//
		// Process the accept-completion.
		// first look for an error code. If an error occurred
		// and the interface is no longer active, end the completion-handling.
		// Otherwise, attempt to reissue the accept-request.
		//
        if(ErrorCode)
		{
			ICQ_TRC(TM_DISP, TL_DUMP, (" Dispatcher - AcceptCompletion> Error !!"));
			//
			// Critical Error.. how to notify ?

			//
			// Delete the AcceptedSocketp - as it is a resource allocated previously.

			break;
		}
		
		//
		// Re issue the accept call, 
        REF_COMPONENT( SDp, eRefIoAccept );

		Error = SDp->NhAcceptStreamSocket(NULL,
								          NULL,
                                          NULL,
                                          DispatcherAcceptCompletionRoutine,
                                          SDp,
                                          NULL);

		if(Error) 
		{ 
			// NOTE: Defer the Acceptance of the socket.
            DEREF_COMPONENT( SDp, eRefIoAccept );
			
			ICQ_TRC(TM_DISP, TL_ERROR, 
                    (" Error - Reissuing the Accept has failed on the Dispatcher"));

			break;
		}


		//
		//  MAJOR HANDLING SECTION - Dispatching  the Accept
		//
		// Let the Accepted Socket inherit the same attributes as the Listening socket
		SOCKET tempSock = SDp->GetSock();

		Error = setsockopt(AcceptedSocketp->GetSock(),
						   SOL_SOCKET,
						   SO_UPDATE_ACCEPT_CONTEXT,
						   (PCHAR)&tempSock,
						   sizeof(tempSock));

		if(Error is SOCKET_ERROR)
		{
			ErrorOut();

			Error = WSAGetLastError();

			ICQ_TRC(TM_DISP, TL_ERROR, 
                    ("ERROR - Major Socket Error in Accept Completion %d", Error));

			break;
		}
		//
		// - Create a DispatchReply structure : find out the original addresses.
		AcceptedSocketp->NhQueryRemoteEndpointSocket(&ActualClientAddress,
                                                     &ActualClientPort);

        Error = SDp->GetOriginalDestination(Bufferp,
                                            &ActualDestinationAddress,
                                            &ActualDestinationPort);

        if( FAILED(Error) )
        {
            ICQ_TRC(TM_DISP, TL_ERROR, ("Can't get the Destination Information"));

            ASSERT( FALSE );

            break;
        }


		// createDispatchReply
		DRp = new DispatchReply;
		
		if(DRp is NULL)
		{
			Error  = E_OUTOFMEMORY;

			ICQ_TRC(TM_DISP, TL_ERROR, (" Can't create a Reply structure - out of memory"));
			
			break;
		}
		
		// Store the original header informations of the packet.
		DRp->dispatch.dstIp   = ActualDestinationAddress;
		DRp->dispatch.dstPort = ActualDestinationPort;
		DRp->dispatch.srcIp   = ActualClientAddress;
		DRp->dispatch.srcPort = ActualClientPort;
		DRp->Socketp		  = AcceptedSocketp;

		
		//
		// - Ask each DispatcheeNode in the List wether this DispatchReply is its or not.
		
		// How to traverse the List ??
		for (DNp = dynamic_cast<DispatcheeNode*>(SDp->listDispNodes.SearchNodeKeys(0,0));
			 DNp != NULL;
			 DNp = dynamic_cast<DispatcheeNode*>(DNp->Nextp))
		{
			if(DNp->isDispatchYours(DRp))
			{
				 PDISPATCHEE Disp = NULL;

				 //
				 // - if there is a hit  Dispatch the Accepted socket.
                 //
				 Disp = DNp->GetDispatchee();

				 // ASSERT (Disp);

                 //
				 // This completion routine will clear the socket up
				 // if it is not using it.
                 //
				 Error = Disp->DispatchCompletionRoutine(DRp);

                 //
				 // Should we keep asking until finished? NOPE
                 //
				 DEREF_COMPONENT( SDp,  eRefIoAccept );

                 DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoAccept );

				 return;
			}
		}

 		//
		// - if there is NO hit close the connection and delete every resource.

		Error = 1;
		ErrorLevel = 2;

	} while(FALSE);

	if( Error != NO_ERROR )
	{
		//
		// Each errorlevel contains the one level below.
		switch( ErrorLevel )
		{
		case 2: // delete the allocated reply
			delete DRp;

		case 1:  // close the socket
			
			DEREF_COMPONENT( AcceptedSocketp, eRefInitialization );

			break;
			
		default:
			// ASSERT(FALSE);
			break;
		}
	}

	// De-Reference Local Accept
	DEREF_COMPONENT( SDp, eRefIoAccept );

	DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoAccept );
}





ULONG
_Dispatchee::DispatchCompletionRoutine(PDispatchReply DispatchReplyp)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ICQ_TRC(TM_DISP, TL_DUMP, ("> Dispatchee - DispatchCompletionRoutine"));		

	if(DispatchReplyp is NULL) return -1; // FAIL

	this->AcquireLock();

	ICQ_TRC(TM_DISP, TL_TRACE, ("Dispatch Reply is as follows ORG dst %s - port %hu",
					INET_NTOA(DispatchReplyp->dispatch.dstIp), 
					htons(DispatchReplyp->dispatch.dstPort)));

	DEREF_COMPONENT( DispatchReplyp->Socketp, eRefInitialization );

	ICQ_TRC(TM_DISP, TL_DUMP, ("> Dispatchee - DispatchCompletionRoutine"));		
	
	this->ReleaseLock();
	
	return 0;
}




_Dispatchee::_Dispatchee()
:DispatchUniqueId(0),
 IncomingRedirectForPeerToClientp(NULL)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ICQ_TRC(TM_DISP, TL_DUMP, ("DISPATCHEE - DEFAULT CONSTRUCTOR"));
}




_Dispatchee::~_Dispatchee()
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ICQ_TRC(TM_DISP, TL_DUMP, ("DISPATCHEE - DESTRUCTOR"));
}



void
_Dispatchee::ComponentCleanUpRoutine(void)
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ICQ_TRC(TM_DISP, TL_DUMP, ("DISPATCHEE - Component Clean Up Routine"));
}



//=-=-=-=-=-
PCHAR _Dispatchee::GetObjectName() { return ObjectNamep; }
PCHAR DispatcheeNode::GetObjectName() { return ObjectNamep;}
PCHAR CSockDispatcher::GetObjectName() { return ObjectNamep;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\dispatcher.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dispatcher.h

Abstract:

	This derivation from the base Socket class is to Create Accept dispatcher.
	Customers will register to this Dispatcher Giving it a struct which explains 
	what type of connections are expected to be dispatched to them.

	Source specific or original destination specific dispatches can be requested. 
	
Author:

    Savas Guven (savasg)   25-Oct-2000

Revision History:

    Savas Guven (savasg)   25-Oct-2000
--*/
#ifndef _DISPATCHER_HEADER_
#define _DISPATCHER_HEADER_

// 
// Forward definition
//
class  CSockDispatcher;
class  DispatcheeNode;

VOID
DispatcherAcceptCompletionRoutine
					(
						ULONG ErrorCode,
						ULONG BytesTransferred,
						PNH_BUFFER Bufferp
					 );

typedef enum _ICQ_DIRECTION_FLAGS
{
    IcqFlagNeutral  = 0x00,
	IcqFlagOutgoing = eALG_OUTBOUND,
	IcqFlagIncoming = eALG_INBOUND

}  ICQ_DIRECTION_FLAGS, *PICQ_DIRECTION_FLAGS;

typedef ICQ_DIRECTION_FLAGS DISPATCHER_DIRECTION_FLAGS, \
* PDISPATCHER_DIRECTION_FLAGS;

//
//
typedef class  _DispatchRequest : public virtual GENERIC_NODE
{
public:
	ULONG		srcIp;
	USHORT	  srcPort;
	ULONG		dstIp;
	USHORT	   dstPort;
	DISPATCHER_DIRECTION_FLAGS DirectionContext;

} DispatchRequest, *PDispatchRequest;

//
//
//
typedef struct _DispatchReply
{
	DispatchRequest dispatch;
	PCNhSock	Socketp;

} DispatchReply, *PDispatchReply;



//
// D I S P A T C H E E
//
typedef class _Dispatchee : public virtual GENERIC_NODE
{
	//friend CSockDispatcher;
    friend DispatcheeNode;

public:

	_Dispatchee();
	
	virtual ~_Dispatchee() ;

//#if DBG
	virtual void ComponentCleanUpRoutine(void);

	virtual void StopSync(void) {};

	virtual PCHAR GetObjectName();
//#endif
	

	virtual ULONG DispatchCompletionRoutine
								(
									PDispatchReply  DispatchReplyp
								);

	virtual SetID(ULONG ID) { DispatchUniqueId = ID;}

	virtual ULONG GetID(void) {return DispatchUniqueId; }

protected:

    ISecondaryControlChannel* IncomingRedirectForPeerToClientp;

	ULONG DispatchUniqueId;

	static const PCHAR ObjectNamep; 

} DISPATCHEE, *PDISPATCHEE;



//
// D I S P A T C H E E _ N O D E 
//
class DispatcheeNode: public virtual GENERIC_NODE
{
public:

	// also sets the Node search Keys appropriately.
	// DispatcheeNode(PDISPATCHEE);

    VOID InitDispatcheeNode(PDISPATCHEE);

	virtual ~DispatcheeNode();

	void ComponentCleanUpRoutine(void);

	PCHAR GetObjectName(void);
	

	// searches the list of Request made by this DispatchTo client
	ULONG isDispatchYours(PDispatchReply  DispatchReplyp); 

	ULONG AddDispatchRequest(PDispatchRequest DispatchRequestp);

	ULONG DeleteDispatchRequest(PDispatchRequest DispatchRequestp);

	PDISPATCHEE GetDispatchee() { return DispatchTop; }

    ULONG GetOriginalDestination(ULONG   SrcAddress,
                                 USHORT  SrcPort,
                                 PULONG  DestAddrp,
                                 PUSHORT DestPortp);


protected:
	static const PCHAR ObjectNamep; 

	PDISPATCHEE	  DispatchTop;

	CLIST		  listRequests;				// Node of Requests
};




//
//
//
class  CSockDispatcher: public virtual _CNhSock
{
	public:
		friend VOID DispatcherAcceptCompletionRoutine
							(
								ULONG ErrorCode,
								ULONG BytesTransferred,
								PNH_BUFFER Bufferp
							 );

		CSockDispatcher();

		CSockDispatcher(ULONG IpAddress, USHORT port);

		~CSockDispatcher();

		//
		// Initializes the socket portion of the Dispatcher.
		//
		ULONG InitDispatcher(
						     ULONG IpAddress,
						     USHORT port
						    );

		//
		// The inherited ComponentCleanupRoutine ala SYNC object
		// 
		virtual void ComponentCleanUpRoutine(void);

		virtual void  StopSync(void);

		PCHAR GetObjectName();

		//
		// A Dispatchee registers itself and gets a Unique ID
		//
		ULONG InitDispatchee(PDISPATCHEE Dispatchp);

        ULONG RemoveDispatchee(PDISPATCHEE Dispatchp);

		//
		// Get the port on which the Dispatch is occuring 
		//
		ULONG GetDispatchInfo(
							  PULONG IPp OPTIONAL, 
							  PUSHORT Portp OPTIONAL
							 );

		//
		// Add a Dispatch request - searches for the correct node 
		// and then calls the nodes AddDispatchReq to add the req to the List of existing reqs.
		//
		ULONG AddDispatchRequest(
								 PDISPATCHEE Dispatchp, 
								 PDispatchRequest DispatchRequestp
								);
											

		//
		// Delete a Dispatch request - searches the correct node and 
		// then calls the nodes own DeleteDispatchReq to delete the req from the List
		//
		ULONG DeleteDispatchRequest(
									PDispatchRequest DispatchRequestp
									);

        //
        // Get Original Destination for Accepted Socket
        //
        ULONG GetOriginalDestination(
                                     PNH_BUFFER Bufferp,
                                     PULONG OrigDestAddrp,
                                     PUSHORT OrigDestPortp
                                    );

	private:
		CLIST listDispNodes; // and their requests.

		static ULONG UniqueId;

		static const PCHAR ObjectNamep;
};

#endif //_DISPATCHER_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqconn.cpp ===
#include "stdafx.h"



ULONG
_ICQ_PEER::CreateShadowMappingPriorToConnection(PDispatchReply DispatchReplyp)
/*++

Routine Description:

   Creates the ShadowMapping According to the given values 
    
Arguments:

    none.

Return Value:

    

--*/
{
	ULONG Error = NO_ERROR;
	ULONG DstIp = 0, NewDstIp = 0, SrcIp = 0, NewSrcIp = 0;
	USHORT DstPort = 0, NewDstPort = 0, SrcPort = 0, NewSrcPort = 0;
	
	ICQ_TRC(TM_MSG, TL_TRACE, (" Creating Shadow mapping "));

	//
	// Create Shadow mapping

    DstIp   = NewDstIp   = DispatchReplyp->dispatch.dstIp;

    DstPort = NewDstPort = DispatchReplyp->dispatch.dstPort;

    Error = g_IAlgServicesp->GetBestSourceAddressForDestinationAddress(DstIp,
                                                                       TRUE,
                                                                       &SrcIp);

    if( FAILED(Error) )
    {
        ASSERT(FALSE);
    }


	if(this->MappingDirection is IcqFlagIncoming)
	{
		this->ToClientSocketp->NhQueryLocalEndpointSocket
													(
														NULL,
														&SrcPort
													);

		this->ToPeerSocketp->NhQueryRemoteEndpointSocket
													(
														&NewSrcIp,
														&NewSrcPort
													);

        Error = g_IAlgServicesp->PrepareSourceModifiedProxyConnection(eALG_TCP,
                                                                      SrcIp,
                                                                      SrcPort,
                                                                      DstIp,
                                                                      DstPort,
                                                                      NewSrcIp,
                                                                      NewSrcPort,
                                                                      &ShadowRedirectp);
	}
	else // if outgoing
	{
		this->ToPeerSocketp ->NhQueryLocalEndpointSocket(NULL, &SrcPort);

		NewSrcPort = SrcPort;

        Error = g_IAlgServicesp->PrepareProxyConnection(eALG_TCP,
                                                        SrcIp,
                                                        SrcPort,
                                                        DstIp,
                                                        DstPort,
                                                        FALSE,
                                                        &ShadowRedirectp);
	}
    
    if( FAILED(Error) )
    {
         ICQ_TRC(TM_MSG, TL_ERROR,
                 ("** !! ShadowRedirect has Failed"));
    }
    else
    {
    	ICQ_TRC(TM_MSG, TL_INFO, ("** Peer Shadow - Mapping Report **"));

    	ICQ_TRC(TM_MSG, TL_INFO, (" DstIp-DstPort %s:%hu", 
                                   INET_NTOA(DstIp), htons(DstPort)));
    	ICQ_TRC(TM_MSG, TL_INFO, (" SrcIp-SrcPort %s:%hu", 
                                   INET_NTOA(SrcIp), htons(SrcPort)));
    	ICQ_TRC(TM_MSG, TL_INFO, (" NewDstIp-NewDstPort %s:%hu", 
                                   INET_NTOA(NewDstIp), htons(NewDstPort)));
    	ICQ_TRC(TM_MSG, TL_INFO, (" NewSrcIp-NewSrcPort %s:%hu", 
                                   INET_NTOA(NewSrcIp), htons(NewSrcPort)));
    }
	
    return Error;
}



ULONG
_ICQ_PEER::InitiatePeerConnection(PDispatchReply DispatchReplyp)
/*++

Routine Description:

    Should create the Shadow mapping and then try to fire the 
    connection Request stuff.

Arguments:

    none.

Return Value:

    

--*/
{
	PCNhSock tempSocketp = NULL;
	PCNhSock * sockHolder;
	ULONG Error = NO_ERROR;
	ULONG DstIp=0;
	USHORT DstPort = 0;
	PICQ_PEER IcqPeerp = this;

	ICQ_TRC(TM_MSG, TL_TRACE, (" > Initiate Peer CONNECTION"));

    NEW_OBJECT(tempSocketp, CNhSock);
	//tempSocketp = new CNhSock();

	if(tempSocketp is NULL)
	{
		return E_FAIL;
	}

	
	//
	// Create Socket but first get the best IP address for this.
    Error = 
        g_IAlgServicesp->GetBestSourceAddressForDestinationAddress(DispatchReplyp->dispatch.dstIp,
                                                                   FALSE,
                                                                   &DstIp);
    if ( FAILED(DstIp) )
    {
        ICQ_TRC(TM_MSG, TL_ERROR, ("Error Can't get the best source addr"));

        DstIp = g_MyPublicIp;
    }


	Error = tempSocketp->NhCreateStreamSocket(DstIp,
                                              0,
                                              NULL);

	if ( Error )
	{
		ICQ_TRC(TM_MSG, TL_ERROR, ("Error - Connection Socket can't be created"));

		DEREF_COMPONENT( tempSocketp, eRefInitialization );

		return E_INVALIDARG;
	}

	//
	//
    //
	if ( this->MappingDirection is IcqFlagOutgoing )
	{
		this->ToPeerSocketp = tempSocketp;
		
		sockHolder = &this->ToPeerSocketp ;
	}
	else
	{
		this->ToClientSocketp = tempSocketp;
		
		sockHolder = & this->ToClientSocketp ;
	}

    DstIp   = DispatchReplyp->dispatch.dstIp;

    DstPort = DispatchReplyp->dispatch.dstPort;

	if( CreateShadowMappingPriorToConnection(DispatchReplyp) )
	{
		ICQ_TRC(TM_MSG, TL_ERROR, ("Error - Shadow Mapping Creation Error"));

		*sockHolder = NULL;

		DEREF_COMPONENT( tempSocketp, eRefInitialization );

		return E_INVALIDARG;
	}

	ICQ_TRC(TM_MSG, TL_TRACE, (" ISSUE CONNECTion to %s:%hu",
		    INET_NTOA(DstIp), htons(DstPort)));


	//
	// Reference  "this"  due to the CONNECT
    //
	REF_COMPONENT( IcqPeerp, eRefIoConnect ); //this

	//
	// Call the Connection Request
    //
    Error = tempSocketp->NhConnectStreamSocket
								(
									g_IcqComponentReferencep,
									DstIp,
									DstPort,
									NULL,
									IcqPeerConnectionCompletionRoutine,
									NULL,
									IcqPeerp, //this
									NULL
								);

	if(Error)
	{
		ICQ_TRC(TM_MSG, TL_ERROR, 
                ("** !! Error - Connect to Peer/Client has failed"));

        ErrorOut();

		this->ShadowRedirectp->Cancel();

        this->ShadowRedirectp->Release();

        this->ShadowRedirectp = NULL;

        DEREF_COMPONENT( IcqPeerp, eRefIoConnect ); //this

        STOP_COMPONENT( tempSocketp );

		DEREF_COMPONENT( tempSocketp, eRefInitialization );

		*sockHolder = NULL;

		return Error;
	}

	return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqcl.h ===
#ifndef __ICQ_CLIENT_HEADER_
#define __ICQ_CLIENT_HEADER_


#define ICQ99_SERVER_PORT  0xA00F
#define ICQ99_HACK_PORT    0xA00F

#define ICQ2K_SERVER_PORT  0x0000
#define ICQ2K_HACK_PORT	   0x0001

#define ICQ_BUFFER_SIZE     576


#define ICQ_CLIENT_TIMEOUT  360 









//
// SERVER MESSAGES are PortRedirect'ed to port 
// Here it is dispatched accordingly.. It serves as just an envoy.

typedef class _ICQ_PEER : public GENERIC_NODE
{
    friend 
    VOID
    IcqPeerConnectionCompletionRoutine
    							(
    								 ULONG ErrorCode,
    								 ULONG BytesTransferred,
    								 PNH_BUFFER Bufferp
    							 );
    
    friend 
    VOID
    IcqPeerReadCompletionRoutine
    							(
    								 ULONG ErrorCode,
    								 ULONG BytesTransferred,
    								 PNH_BUFFER Bufferp
    							 );

// friend class _ICQ_PEER;

public:
	_ICQ_PEER();

	~_ICQ_PEER();

	virtual void  ComponentCleanUpRoutine(void);

	virtual void  StopSync(void);

	virtual PCHAR GetObjectName() { return ObjectNamep; }

	virtual ULONG ProcessOutgoingPeerMessage(PUCHAR buf, ULONG len);

	virtual ULONG InitiatePeerConnection(PDispatchReply DispatchReplyp);

    virtual ULONG EndPeerSessionForClient(PCNhSock ClosedSocketp);

	virtual ULONG CreateShadowMappingPriorToConnection(PDispatchReply DispatchReplyp);

	

	// member variables section
    PCNhSock                  ToClientSocketp;

    PCNhSock                  ToPeerSocketp;

    ULONG                     PeerUIN;

    ULONG                     PeerVer;

    ULONG                     PeerIp;

    USHORT                    PeerPort;

	BOOLEAN                   bActivated;

	BOOLEAN                   bShadowMappingExists;

	ICQ_DIRECTION_FLAGS       MappingDirection; 

    IPendingProxyConnection*  ShadowRedirectp;

	ISecondaryControlChannel* OutgoingPeerControlRedirectp;

    IDataChannel *            IncomingDataRedirectp;
	
	// HANDLE hIncomingDataRedirectHandle;

	static const PCHAR ObjectNamep; 

} ICQ_PEER, * PICQ_PEER;














//
//
//
typedef class _ICQ_CLIENT : public virtual DISPATCHEE
{
	friend _ICQ_CLIENT* ScanTheListForLocalPeer(
                                                PULONG PeerIp, 
                                                PUSHORT PeerPort,
                                                ULONG IcqUIN
                                               );

public:

	_ICQ_CLIENT();

	~_ICQ_CLIENT();

	virtual void ComponentCleanUpRoutine(void);

	virtual void  StopSync(void);

	virtual PCHAR GetObjectName() { return ObjectNamep;}

	ULONG DispatchCompletionRoutine
								(
									PDispatchReply  DispatchReplyp
								);


	// ** Initialize **
	// The first packet to any server is initialized here..
	// This creates a new UDP Server socket (if there isn't one.)
	// Initializes the Server Address, creates a more specific
	// Redirection between the Client ~ Proxy
	// (if there is one already deletes that )
	// Modifies the packet if necessary and forwards it to 
	// the designated destination.
	// Creates secondary Mappings and such
	// NOTE: This function is called from the Context Of 
	// IcqReadCompletion Routine which dispatches the inits.
	// 
	ULONG Initialize(
					PNH_BUFFER Bufferp,
					ULONG	   clientIp,
					USHORT	   clientPort,
					ULONG      serverIp,
					USHORT     serverPort,
                    PCNhSock   localClientSocketp
				   );

	// ** ServerRead **
	// This will keep track of Peer Online Messages and such..
	// will create sockets for each peer that is online and will
	// create mappings which will redirect the outgoing packets
	// to the peers to the appropriate Handler.. Which in turn
	// will change the appropriate packets and then create 
	// Redirects if necessary.
	
	ULONG ServerRead(
						PNH_BUFFER Bufferp,
						ULONG  serverIp,
						USHORT serverPort
					);

	ULONG ClientRead(
						PNH_BUFFER Bufferp,
						ULONG  serverIp,
						USHORT serverPort
					);
	

	ISecondaryControlChannel*
         PeerRedirection(
                		ULONG dstIp,
                		USHORT dstPort,
                		ULONG srcIp OPTIONAL,
                		USHORT srcPort OPTIONAL,
                		ICQ_DIRECTION_FLAGS DirectionContext
                        );

	
    
    // Do we need this?
//	ServerWrite();

//	PeerWrite();

    VOID ReportExistingPeers(VOID);

//protected:

	ULONG IcqServerToClientUdp(
                                PUCHAR mcp, 
                                ULONG mcplen
                              );

	ULONG IcqClientToServerUdp(
                                PUCHAR buf,
                                ULONG size
                              );

    ULONG DeleteTimer(TIMER_DELETION bHow);

    ULONG ResetTimer(VOID);
	
	// member - ServerSocket
    PCNhSock ServerSocketp; // when writing and reading to server

	//
	// NAT ENGINE RELATED
    IPendingProxyConnection *   ShadowRedirectp;

	ISecondaryControlChannel*   IncomingPeerControlRedirectionp;

	// this socket is shared among all the clients
    PCNhSock                    ClientSocketp; // when writing to the client back +
    
    ULONG                       ClientIp;
    
	USHORT                      ClientToServerPort; // UDP
    
	USHORT                      ClientToPeerPort;   // TCP

	USHORT                      ImitatedPeerPort;
    
	ULONG                       UIN;
    
	ULONG                       ClientVer;

    ULONG                       ServerIp;
    
	USHORT                      ServerPort;

    CLIST                       IcqPeerList;

    PTIMER_CONTEXT              TimerContextp;

	static const PCHAR          ObjectNamep;
    
} ICQ_CLIENT, *PICQ_CLIENT;








//
// Function Definitions
//
VOID NTAPI IcqClientTimeoutHandler( 
                                    PVOID Parameterp,
                                    BOOLEAN TimerOrWaitFired
                                  );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqdbg.h ===
//****************************************************************************
//
//  Module:     ICSMGR.DLL
//  File:       debug.h
//  Content:    This file contains the debug definitions
//
//  Revision History:
//  
//  Date
//  -------- ---------- -------------------------------------------------------
//  03/24/97 bjohnson   Created
//
//****************************************************************************

#ifndef __ICQ_DBG_H_
#define __ICQ_DBG_H_
//
// Name of this overall binary
//

#define SZ_MODULE "ICQ: " 
#define TRACE_FLAG_ICQ         ((ULONG)0x08000000 | TRACE_USE_MASK)

//****************************************************************************
//  Typedef's
//****************************************************************************

typedef struct _DEBUG_MODULE_INFO {
    ULONG dwModule;    
    ULONG dwLevel;    
    TCHAR  szModuleName[80];    
    TCHAR  szDebugKey[80];    
} DEBUG_MODULE_INFO, *PDEBUG_MODULE_INFO;


//****************************************************************************
//  Extern
//****************************************************************************

extern char g_szComponent[];
extern DEBUG_MODULE_INFO gDebugInfo[];


//
// Trace Modules
//

#define TM_DEFAULT      0
#define TM_BUF			1 
#define TM_API			2 
#define TM_IO           3
#define TM_MSG          4
#define TM_REF          5
#define TM_TEST			6

#define TM_CON			7 
#define TM_IF			8
#define TM_PRX          9

#define TM_SYNC	        10
#define TM_DISP         11
#define TM_SOCK         12
#define TM_LIST         13
#define TM_PROF         14
#define TM_TIMER        15


//
// Trace Levels
//

#define TL_NONE         0
#define TL_CRIT         1
#define TL_ERROR        2
#define TL_INFO         3
#define TL_TRACE        4
#define TL_DUMP         5

#if DBG


#define DBG_TRACE(_mod_,_lev_,_msg_) if ((_lev_)<=gDebugInfo[_mod_].dwLevel)\
 { DbgPrintX _msg_ ; }

#define ICQ_TRC(_mod_,_lev_,_msg_) if ((_lev_)<=gDebugInfo[_mod_].dwLevel)\
 { DbgPrintX _msg_ ; }


#define PROFILER(_MOD_, _LEV_, _MSG_)          \
if( ((_LEV_) <= gDebugInfo[_MOD_].dwLevel) &&  \
    ((_LEV_) <= gDebugInfo[TM_PROF].dwLevel)   \
  )                                            \
{ DbgPrintX _MSG_; }


#define ASSERT(_X_)                                             \
if(!(_X_)) {                                                    \
    DbgPrintX("Line %s, File %s", __LINE__, __LINE__);          \
    ErrorOut();                                                 \
    DebugBreak();                                               \
}
 


#else // DBG


#define DBG_TRACE(_mod_, lev, _msg_)

#define ICQ_TRC(_mod_, lev, _msg_)

#define PROFILER(_MOD_, _LEV_, _MSG_)

#define ASSERT(_X_) if(!(_X_)) exit(1)


#endif

//****************************************************************************
//  Prototypes
//****************************************************************************

void DbgPrintX(LPCSTR pszMsg, ...);
void InitDebuger(void);
void DestroyDebuger(void);


#endif // __ICQ_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqio.h ===
#ifndef __ICQ_IO_H
#define __ICQ_IO_H



#endif // __ICQ_IO_H


//
// IoCompletion Routines
//


//
// Reading incoming UDP packets from the ICQ Server.
//
VOID
ReadServerCompletionRoutine
				(
				ULONG ErrorCode,
				ULONG BytesTransferred,
				PNH_BUFFER Bufferp
				);

//
// Write Completion Routine which frees Up the Buffer
//
VOID 
IcqWriteCompletionRoutine
				(
				ULONG ErrorCode,
				ULONG BytesTransferred,
				PNH_BUFFER Bufferp
				);
//
// Reading from the UDP packets from the Client
// (old ReadTestIcqCompletionRoutine)
//
VOID
IcqReadClientUdpCompletionRoutine
		(
			 ULONG ErrorCode,
			 ULONG BytesTransferred,
			 PNH_BUFFER Bufferp
		);

VOID
IcqPeerConnectionCompletionRoutine
							(
								 ULONG ErrorCode,
								 ULONG BytesTransferred,
								 PNH_BUFFER Bufferp
							);

VOID
IcqPeerReadCompletionRoutine
							(
								 ULONG ErrorCode,
								 ULONG BytesTransferred,
								 PNH_BUFFER Bufferp
							);

VOID
IcqPeerWriteCompletionRoutine
			(
			 ULONG ErrorCode,
			 ULONG BytesTransferred,
			 PNH_BUFFER Bufferp
			);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqdbg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pastdbg.c

Abstract:

    This module contains code for the PAST transparent proxy's DEBUG
    outputing code.

Author:

    Savas Guven  (savasg)        25-Jul-2000

Revision History:

--*/
#include "stdafx.h"



extern ULONG NhpTraceId;



//****************************************************************************
//  Global Parameters
//****************************************************************************
TCHAR g_tszDebugKey[] = _T("SOFTWARE\\Microsoft\\Tracing\\ICQPRX\\Debug");


DEBUG_MODULE_INFO gDebugInfo[] = {
    {TM_DEFAULT,  TL_DUMP, _T("<default>"),  _T("DebugLevel")},   // 0
    {TM_BUF,      TL_INFO, _T("BUF"),        _T("BufDebugLevel")}, // 1
    {TM_API,      TL_INFO, _T("API"),        _T("ApiDebugLevel")}, // 2
    {TM_IO,       TL_INFO, _T("IO"),         _T("IoDebugLevel")}, // 3
    {TM_MSG,      TL_INFO, _T("MSG"),        _T("MsgDebugLevel")},// 4
    {TM_REF,      TL_INFO, _T("REF"),        _T("RefDebugLevel")},// 5 
    {TM_TEST,     TL_INFO, _T("TEST"),       _T("TestDebugLevel")},// 6
    {TM_CON,      TL_INFO, _T("CON"),        _T("ConDebugLevel")}, // 7
    {TM_IF,       TL_INFO, _T("IF"),         _T("IfDebugLevel")}, //8
    {TM_PRX,      TL_INFO, _T("PRX"),        _T("PrxDebugLevel")}, //9
	{TM_SYNC,     TL_INFO, _T("SYNC"),       _T("SyncDebugLevel")}, // 10
	{TM_DISP,     TL_INFO, _T("DISP"),       _T("DispDebugLevel")},
	{TM_SOCK,     TL_INFO, _T("SOCK"),       _T("SockDebugLevel")},
	{TM_LIST,     TL_INFO, _T("LIST"),       _T("ListDebugLevel")}, // 13
    {TM_PROF,     TL_INFO, _T("PROFILE"),    _T("ProfileDebugLevel")}, // 14
    {TM_TIMER,    TL_INFO, _T("TIMER"),      _T("TimerDebugLevel")} // 15
};

char g_szModule[] = SZ_MODULE;

HANDLE g_EventLogHandle = NULL;
ULONG  g_TraceId		= INVALID_TRACEID;



void DestroyDebuger(VOID) {
    TraceDeregister(g_TraceId);
    g_TraceId = INVALID_TRACEID;

}

//****************************************************************************
// VOID GetDebugLevel()
//
// This function gets the current debug level from the registry
//
//****************************************************************************

void InitDebuger()
/*++

Routine Description:

    R

Arguments:

    A

Return Value:

    R

Notes:

    N

--*/

{
    HKEY        hkey;
    DWORD       dwType, cb;
    DWORD       dwLevel;
    int         iModule;         
    int         nModules;         

    
    // Init the Trace Manager
    g_TraceId = TraceRegisterA("ICQPRX");
    
    //
    // Open the registry key that contains the debug configuration info
    //
    if (RegOpenKeyEx((HKEY) HKEY_LOCAL_MACHINE,
                     g_tszDebugKey,
                     0,
                     KEY_READ,
                     &hkey) == ERROR_SUCCESS) 
	{

        cb = sizeof(dwLevel);

        //
        // Initialize all the modules to the base value or their custom value
        //
        nModules = (sizeof(gDebugInfo)/sizeof(DEBUG_MODULE_INFO));

        for (iModule = 0; iModule < nModules; iModule++) 
		{

            //
            // Open each custom debug level if present
            //
            if ((RegQueryValueEx(hkey, 
                                 gDebugInfo[iModule].szDebugKey,
                                 NULL, 
                                 &dwType, 
                                 (PUCHAR) 
                                 &dwLevel, 
                                 &cb) == ERROR_SUCCESS) && (dwType == REG_DWORD)) 
			{
                gDebugInfo[iModule].dwLevel = dwLevel; 
            } 
			else 
			{
                //gDebugInfo[iModule].dwLevel = gDebugInfo[TM_DEFAULT].dwLevel; 
            }
#ifndef _UNICODE
            DBG_TRACE(TM_IF, TL_INFO, ("ModuleKey: %s, DebugLevel: %d", 
                                       gDebugInfo[iModule].szModuleName,
                                       gDebugInfo[iModule].dwLevel));
#endif

        }

        RegCloseKey(hkey);
    } 
	else 
	{
       // NhTrace(TRACE_FLAG_PAST, "Couldn't open Reg\n");
		printf("DEBUG key doesn't exist\n");
    }

    return;
}



void  DbgPrintX(LPCSTR pszMsg, ...)
{
    va_list VaList;
    /*
	char temp[100];
    char msg[1024];
    int len = 0;

	len = sprintf(temp, "%s ", g_szModule);
    
    lstrcpy(msg, temp);
    wvsprintf(&msg[len], pszMsg, (va_list)(&pszMsg + 1));
    lstrcat(msg,"\r\n");
    OutputDebugString(msg);
    */
    if(g_TraceId is INVALID_TRACEID)
         InitDebuger();
    va_start(VaList, pszMsg);
    TraceVprintfExA(g_TraceId, 
                    TRACE_FLAG_ICQ,
                    pszMsg,
                    VaList); 
    va_end(VaList);

}

// DBG_TRACE(TM_MSG, TL_INFO, ("nvnat_control_one > xtcp_port\n"));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqio.cpp ===
#include "stdafx.h"



VOID
IcqWriteCompletionRoutine
				(
				ULONG ErrorCode,
				ULONG BytesTransferred,
				PNH_BUFFER Bufferp
				)
/*++

Routine Description:

    A generic Write Completion Routine.
    
Arguments:

    none.

Return Value:

    

--*/
{
	PCNhSock Socketp = Bufferp->Socketp;

	ICQ_TRC(TM_IO, TL_DUMP, ("-- WRITE COMPLETION ROUTINE --"));

	NhReleaseBuffer(Bufferp);

	//Dereference Interface;

	DEREF_COMPONENT( Socketp, eRefIoWrite);

	DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoWrite);
}









VOID
ReadServerCompletionRoutine
				(
				ULONG ErrorCode,
				ULONG BytesTransferred,
				PNH_BUFFER Bufferp
				)
/*++

Routine Description:

    Reads the Server Responses to Client packets
    and then multiplexes this responses to the approprate client
    which was given in the Context information
    
    
Arguments:

    none.

Return Value:

    

--*/
{
    PICQ_CLIENT IcqClientp       = NULL;
	PCNhSock	Socketp			 = NULL;
	ULONG		Error			 = NO_ERROR;

    ICQ_TRC(TM_IO, TL_ERROR, (" "));

	PROFILER(TM_IO, TL_TRACE, ("> UDP-SERVER - READ "));

	if(Bufferp is NULL) return;

	//
	// Get the Client Information 
	Socketp = Bufferp->Socketp;

	IcqClientp = (PICQ_CLIENT)Bufferp->Context;

    ASSERT(IcqClientp != NULL);

	if(ErrorCode)
	{
		// Re-issue a read operation if it is not critical Error.
		ICQ_TRC(TM_IO, TL_ERROR,
                ("**  !! READ ERROR in Server -> Client (UDP) !! **"));

		NhReleaseBuffer(Bufferp);

		//ErrorOut();

	}
	else  // we need the context information
	{
        //
		// reissue read first
        //
        REF_COMPONENT( IcqClientp, eRefIoRead );

		Error = Socketp->NhReadDatagramSocket(g_IcqComponentReferencep,
								              NULL,
								              ReadServerCompletionRoutine,
								              IcqClientp,
                                              NULL);
		if(Error)
		{
			ICQ_TRC(TM_IO, TL_ERROR, ("READ ERROR"));

            DEREF_COMPONENT( IcqClientp, eRefIoRead );
		}
		
		// multiplex the data
		Error = IcqClientp->ServerRead(Bufferp, 0, 0);

        if(Error)
        {
            NhReleaseBuffer( Bufferp );
        }
	}

	// DEREFERENCING
	DEREF_COMPONENT( Socketp, eRefIoRead );

	DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoRead );

	DEREF_COMPONENT( IcqClientp, eRefIoRead );
}






VOID
IcqReadClientUdpCompletionRoutine
                 (
				 ULONG ErrorCode,
				 ULONG BytesTransferred,
				 PNH_BUFFER Bufferp
				 )
/*++

Routine Description:

    This is the READ - DISPATCHER for the UDP 
    Clients sending packets to the server will be caught here..
    it will dispatch the packet to the appropriate ICQ client objects READER
    
    
Arguments:

    none.

Return Value:

    

--*/
{
	PCNhSock    Socketp			 = Bufferp->Socketp;
	ULONG		Error			 = NO_ERROR;
	// HANDLE DynamicRedirectHandle = (HANDLE) Bufferp->Context;

    ICQ_TRC(TM_IO, TL_ERROR, (" "));

	PROFILER(TM_IO, TL_TRACE,("UDP-CLIEN-READ DATA CAME from %s e(%hu)", 
		    INET_NTOA(Bufferp->ReadAddress.sin_addr.S_un.S_addr), ErrorCode));

    do
    {
        if(ErrorCode)
    	{
    		// Re-issue a read operation if it is not critical Error.
    		ICQ_TRC(TM_IO, TL_ERROR,
                    ("** !! CLIENT~SERVER READ ERROR - Deletin all the Client Entries"));

            Error = g_IcqPrxp->ReadFromClientCompletionRoutine(ErrorCode,
                                                               BytesTransferred,
                                                               Bufferp);
            break;
        }
    	else
    	{
    		// Re-issue a read operation.
    		Error = Socketp->NhReadDatagramSocket(g_IcqComponentReferencep,
    											  NULL,
    											  IcqReadClientUdpCompletionRoutine,
    											  NULL,// DynamicRedirectHandle,
    											  NULL);
    		if(Error) 
    		{
    			ICQ_TRC(TM_IO, TL_ERROR,("TREAD !!> REISsUE READ ERROR "));
    
    			break;
    		}

            g_IcqPrxp->ReadFromClientCompletionRoutine(ErrorCode,
                                                       BytesTransferred,
                                                       Bufferp);
    
    	} // else for  if (ErrorCode)

    } while ( FALSE );

	DEREF_COMPONENT( Socketp, eRefIoRead);

	DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoRead);
}






//
// CLIENT - RELATED  IO COMPLETION ROUTINES
//


VOID
IcqPeerConnectionCompletionRoutine
							(
								 ULONG ErrorCode,
								 ULONG BytesTransferred,
								 PNH_BUFFER Bufferp
							 )
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
	PCNhSock Socketp = NULL;
	PICQ_PEER IcqPeerp = NULL;
	ULONG Error;
	
	// ASSERT(Bufferp);

	Socketp = Bufferp->Socketp;

	IcqPeerp = reinterpret_cast<PICQ_PEER>(Bufferp->Context);
	//	IcqClientp = reinterpret_cast<PICQ_CLIENT>(Bufferp->Context2);

	ICQ_TRC(TM_IO, TL_TRACE, ("> IcqPeerConnectionCompletionRoutine"));

	// ASSERT on all of them.
	do
	{
		if(ErrorCode)
		{
			// Do - we need it?
			// Delete the Shadow mapping

			//
			// if can't connect then Delete the existing Socket to which we have 
			// established connection.
			//
			if(IcqPeerp->MappingDirection is IcqFlagOutgoing)
			{
                STOP_COMPONENT(IcqPeerp->ToClientSocketp);

				//DEREFERENCE_COMPONENT(IcqPeerp->ToClientSocketp);
			}
            else // incoming
			{
                STOP_COMPONENT(IcqPeerp->ToPeerSocketp);

				//DEREFERENCE_COMPONENT(IcqPeerp->ToClientSocketp);
			}

            break;
		}
		else
		{
			ULONG srcIp;
			USHORT srcPort;
			
			Socketp->NhQueryRemoteEndpointSocket(&srcIp, &srcPort);

			//
			//
			ICQ_TRC(TM_IO, TL_TRACE, 
					("Connected to - Remote end is at %s:%hu",
					INET_NTOA(srcIp), htons(srcPort)));
			
			//
			// Activate The Connection
			// Issue the Read Operations on both Sockets with the Peer as their 
			// Context 
            //
			if(IcqPeerp->MappingDirection is IcqFlagOutgoing)
			{
				IcqPeerp->ToPeerSocketp = Socketp;

				ICQ_TRC(TM_MSG, TL_DUMP, 
						 ("Mapping is outGoing.. this socket is to the peer"));
			}
			else
			{
				IcqPeerp->ToClientSocketp = Socketp;
			}

			ICQ_TRC(TM_IO, TL_TRACE, ("Issuing firstRead"));
			
			Socketp = IcqPeerp->ToClientSocketp;

            REF_COMPONENT( IcqPeerp, eRefIoRead );

			Error = Socketp->NhReadStreamSocket
										(
											g_IcqComponentReferencep,
											NULL,  
											ICQ_BUFFER_SIZE,     // we should give a size
											0,
											IcqPeerReadCompletionRoutine,
											IcqPeerp,
											NULL
										);

			if(Error)
			{
				ErrorOut();

				ICQ_TRC(TM_MSG, TL_ERROR, (" ERROR - Read failed on ToClient Sock"));

                DEREF_COMPONENT( IcqPeerp, eRefIoRead );
				
				break;
			}

			

			//
			// The other read operation
			//

			ICQ_TRC(TM_IO, TL_TRACE, ("Issuing second Read"));

			Socketp = IcqPeerp->ToPeerSocketp;

            REF_COMPONENT( IcqPeerp, eRefIoRead );
			
			Error = Socketp->NhReadStreamSocket
										(
											g_IcqComponentReferencep,
											NULL,
											ICQ_BUFFER_SIZE,
											0,
											IcqPeerReadCompletionRoutine,
											IcqPeerp,
											NULL
										);
			if(Error)
			{
				ErrorOut();

				ICQ_TRC(TM_MSG, TL_ERROR, (" ERROR - Read failed on ToPeer Sock"));

                STOP_COMPONENT(IcqPeerp->ToClientSocketp); // reference will be cleared later

				DEREF_COMPONENT( IcqPeerp, eRefIoRead);

                DEREF_COMPONENT( IcqPeerp, eRefIoRead );
				
				break;
			}
		
			//
			// Reference the ICQ_PEER twice due to two read issues

			IcqPeerp->bActivated = TRUE;
		}
	} while (FALSE);

	DEREF_COMPONENT( Bufferp->Socketp, eRefIoConnect );

	DEREF_COMPONENT( IcqPeerp, eRefIoConnect);

	DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoConnect );
}







VOID
IcqPeerReadCompletionRoutine
							(
								 ULONG ErrorCode,
								 ULONG BytesTransferred,
								 PNH_BUFFER Bufferp
							 )
/*++

Routine Description:

	Reads TCP data between the peers. Within these flows there will be 
    a place where the Data channel is negotiated.
    
Arguments:

    none.

Return Value:

    

--*/
{

	PICQ_PEER IcqPeerp = NULL;
	PCNhSock Socketp = NULL;
	PCNhSock  OtherSocketp = NULL;
	ULONG Error  = NO_ERROR; 

	// ASSeRT(Bufferp);

	Socketp = Bufferp->Socketp;

	IcqPeerp = reinterpret_cast<PICQ_PEER>(Bufferp->Context);


	ICQ_TRC(TM_IO, TL_TRACE, 
            ("> IcqPeerReadCompletionRoutine E:(%X) D:(%u)", 
             ErrorCode, BytesTransferred));

	do 
	{
		if( (ErrorCode != 0)  || 
            ((ErrorCode== 0) && (BytesTransferred == 0))
          )
		{

			ICQ_TRC(TM_IO, TL_ERROR, ("Stoppping the Peer SESSION"));
							
            IcqPeerp->EndPeerSessionForClient(Socketp);

			break;
		}
		else
		{
			if(BytesTransferred)
			{
				OtherSocketp = IcqPeerp->ToClientSocketp;

				ICQ_TRC(TM_IO, TL_TRACE, 
                        (" Regular Data from a Peer(%u)/Client(%s) Socket",
                         IcqPeerp->PeerUIN,            // Peer-UIN
                         INET_NTOA(IcqPeerp->iKey1))); // Client-IP

                //
				// Determine which direction this Socket is from..
                //
				if(OtherSocketp is Socketp)
				{
                    //
					// NOTE: if it is from the ToClientSocketp then Process it
					//
                    IcqPeerp->ProcessOutgoingPeerMessage(Bufferp->Buffer,
                                                         Bufferp->BytesTransferred);

					OtherSocketp = IcqPeerp->ToPeerSocketp;
				}
				
				// then forward it to the other side by simply writing it .
				Error = OtherSocketp->NhWriteStreamSocket(g_IcqComponentReferencep,
                                                          Bufferp,
                                                          BytesTransferred,
                                                          0,
                                                          IcqWriteCompletionRoutine,
                                                          NULL,
                                                          NULL);
                if(Error)
                {
                    ICQ_TRC(TM_MSG, TL_ERROR, 
                            ("Error - In writing to the other side"));
                }
			}

			//
			// Issue another Read operation
			// 
            REF_COMPONENT( IcqPeerp, eRefIoRead );

			Error = Socketp->NhReadStreamSocket(g_IcqComponentReferencep,
					        					NULL,
							        			ICQ_BUFFER_SIZE,
									        	0,
										        IcqPeerReadCompletionRoutine,
										        IcqPeerp,
										        NULL);
            if(Error)
            {
			    DEREF_COMPONENT( IcqPeerp, eRefIoRead);

                ICQ_TRC(TM_MSG, TL_ERROR, ("Peer connection no more??"));
            }
		}
	} while (FALSE);

	DEREF_COMPONENT( Socketp, eRefIoRead );

	DEREF_COMPONENT( IcqPeerp, eRefIoRead );

	DEREF_COMPONENT( g_IcqComponentReferencep, eRefIoRead );
} // End of *IcqPeerReadCompletionRoutine*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqprx.h ===
#ifndef __ICQ_PRX_H
#define __ICQ_PRX_H


class IcqPrx : virtual public COMPONENT_SYNC
{
public:
    IcqPrx();
    
    ~IcqPrx();

    void ComponentCleanUpRoutine(void);

    void StopSync(void);

    ULONG RunIcq99Proxy(ULONG BoundaryIp);

    ULONG ReadFromClientCompletionRoutine(
                            			  ULONG ErrorCode,
                            			  ULONG BytesTransferred,
                            			  PNH_BUFFER Bufferp
                                   	     );
protected:
    PCNhSock m_Socketp;

    IPrimaryControlChannel * m_ControlChannelp;
};





#endif //__ICQ_PRX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqprx.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    

Abstract:

    

Author:

    Savas Guven (savasg)   27-Nov-2000

Revision History:

*/

#include "stdafx.h"

CLIST g_IcqClientList;

CSockDispatcher * g_IcqPeerDispatcherp = NULL;






IcqPrx::IcqPrx()
:m_Socketp(NULL),
 m_ControlChannelp(NULL)
{
    ICQ_TRC(TM_IO, TL_DUMP, (" ICQPRX - Default - Constructor"));

    g_IcqComponentReferencep = dynamic_cast<PCOMPONENT_SYNC>(this);
}


IcqPrx::~IcqPrx()
{
    ICQ_TRC(TM_IO, TL_DUMP, ("ICQPRX - ~ DESTRUCTOR"));

    if(this->bCleanupCalled is FALSE)
    {
        IcqPrx::ComponentCleanUpRoutine();
    }

    this->bCleanupCalled = FALSE;
}


//
// The Local Socket is a resource which needs to be freed up.
// All the Clients needs to be deleted from the entries?
// The CSockDispatcher needs to be cleared up.
//
void
IcqPrx::ComponentCleanUpRoutine(void)
{


    if( m_Socketp ) 
    { 
        DELETE_COMPONENT( m_Socketp );

        m_Socketp = NULL;
    }

    if( g_IcqPeerDispatcherp ) 
    {
        DELETE_COMPONENT( g_IcqPeerDispatcherp );
    }

    if ( m_ControlChannelp )
    {
        m_ControlChannelp->Cancel();

        m_ControlChannelp->Release();

        m_ControlChannelp = NULL;
    }
    
    this->bCleanupCalled = TRUE;
}


void
IcqPrx::StopSync()
{
    ULONG hr = S_OK;

    if( m_Socketp )
    {
        STOP_COMPONENT( m_Socketp );
    }

    if( g_IcqPeerDispatcherp )
    {
        STOP_COMPONENT( g_IcqPeerDispatcherp );
    }

    if( m_ControlChannelp )
    {
        hr = m_ControlChannelp->Cancel();

        if( FAILED(hr) )
        {
            ICQ_TRC(TM_PRX, TL_ERROR, 
                    ("** !! Can't cancel the PRIMARY redirect e(%X)", hr));
        }
        else
        {
            m_ControlChannelp = NULL;
        }
    }
}


ULONG
IcqPrx::RunIcq99Proxy(
                        ULONG BoundaryIp
                     )
/*++

Routine Description:


    
Arguments:

    none.

Return Value:

    

--*/
{
    ULONG hr = S_OK;
    
    USHORT port;
    ULONG ip;


	ICQ_TRC(TM_PRX, TL_INFO, ("> ICQ 99 PRxY %lu", BoundaryIp));

    
    ASSERT(BoundaryIp != 0);

    NEW_OBJECT( m_Socketp, CNhSock );

	if( m_Socketp is NULL) return E_OUTOFMEMORY;


    //
    // Get the Public IP information
    ip = BoundaryIp;

    g_MyPublicIp = ip;


    // __asm int 3
	
	do 
	{

		// Init globals
        __try
        {
		    g_IcqPeerDispatcherp = new CSockDispatcher(ip, 0);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            delete g_IcqPeerDispatcherp;

            hr = E_OUTOFMEMORY;

            g_IcqPeerDispatcherp = NULL;
        }

        if ( g_IcqPeerDispatcherp is NULL )
        {
            ICQ_TRC(TM_PRX, TL_ERROR,("Dispatcher creation failed - mem alloc"));

            hr = E_OUTOFMEMORY;

            break;
        }
        
        //
		// Create UDP socket with the given IP:Port in the argv
        //
		hr = m_Socketp->NhCreateDatagramSocket(ip, 0, NULL);

        if ( hr )
        {
            hr = HRESULT_FROM_WIN32( hr );

            ICQ_TRC(TM_PRX, TL_ERROR, 
                    ("Can't Create the Primary UDP socket E(%X)", hr));

            break;
        }

		m_Socketp->NhQueryLocalEndpointSocket( NULL, &port );

        //
		// Create Dynamic SRC redirection to the IP and port
        //
        hr = g_IAlgServicesp->CreatePrimaryControlChannel(eALG_UDP,
                                                          ICQ99_SERVER_PORT,
                                                          eALG_DESTINATION_CAPTURE,
                                                          FALSE,
                                                          ip,
                                                          port,
                                                          &m_ControlChannelp);
		if( FAILED(hr) )
		{
			ICQ_TRC(TM_PRX, TL_ERROR, 
                    ("ERROR !!> DynamicPortRedirect Has Failed E(%X)", hr));

			break;
		}

		ICQ_TRC(TM_PRX, TL_INFO, 
                ("All Outgoing redirects will be sent to %s(%hu)",
				INET_NTOA(ip), htons(port)));

		// Issue a read operation on the UDP socket.
		hr = m_Socketp->NhReadDatagramSocket(g_IcqComponentReferencep,
                                             NULL,
                                             IcqReadClientUdpCompletionRoutine,
                                             NULL,
                                             NULL);
        if ( hr )
        {
            hr = HRESULT_FROM_WIN32( hr );
            
            ICQ_TRC(TM_PRX, TL_ERROR, ("hr Level E(%X)", hr));

            ASSERT( FALSE );
        }
	
    } while (0);

    //
    // Handle the error case
    //
    if ( FAILED(hr) )
    {
        //
        // Delete Dispatcher
        if ( g_IcqPeerDispatcherp  != NULL )
        {
            DELETE_COMPONENT( g_IcqPeerDispatcherp );

            g_IcqPeerDispatcherp = NULL;
        }

        //
        // Delete Socket
        if ( m_Socketp != NULL )
        {
            DELETE_COMPONENT( m_Socketp );

            m_Socketp = NULL;
        }

        //
        // Delete The Primary Control Channel
        if ( m_ControlChannelp )
        {
            m_ControlChannelp->Cancel();

            m_ControlChannelp->Release();

            m_ControlChannelp = NULL;
        }
    }
    
    return hr;
}




ULONG
IcqPrx::ReadFromClientCompletionRoutine
            (
                 ULONG ErrorCode,
                 ULONG BytesTransferred,
                 PNH_BUFFER Bufferp
            )
/*++

Routine Description:

    This is the READ - DISPATCHER for the UDP 
    Clients sending packets to the server will be caught here..
    it will dispatch the packet to the appropriate ICQ client objects READER
    
    
Arguments:

    none.

Return Value:

    

--*/
{
	PCNhSock    Socketp			 = Bufferp->Socketp;
    PICQ_CLIENT IcqClientp       = NULL;

    //	NAT_KEY_SESSION_MAPPING_EX_INFORMATION Key;

	// ULONG  Length = sizeof(NAT_KEY_SESSION_MAPPING_EX_INFORMATION);
	ULONG  hr = NO_ERROR;
	ULONG  LocalIp, ActualClientIp, ActualDestinationIp;
	USHORT LocalPort, ActualClientPort, ActualDestinationPort;


    if(ErrorCode)
    {
        //
        // Delete the List of the Clients here. 
        // Starts from the head of the List
        // Don't try to use a Removed Element unless you're damn sure
        // that its Ref Count hasn't reached zero yet.
        //
        ICQ_TRC(TM_PRX, TL_CRIT, ("STOPPING the MAIN READ Socket for UDP"));

        for(IcqClientp = dynamic_cast<PICQ_CLIENT>(g_IcqClientList.RemoveSortedKeys(0,0));
            IcqClientp != NULL;
            IcqClientp = dynamic_cast<PICQ_CLIENT>(g_IcqClientList.RemoveSortedKeys(0,0))
           )
        {
            // NOTE: decide what to do.
        }

        hr = E_FAIL;
    }
    else
    {
    
        //
        // Read about the local client..
        //
        
        //  Socketp->NhQueryLocalEndpointSocket(&LocalIp, &LocalPort);
    
        ActualClientIp   = Bufferp->ReadAddress.sin_addr.S_un.S_addr;
    
        ActualClientPort = Bufferp->ReadAddress.sin_port;
    
        //
        // Get Information about the actual destination
        // 

        hr = m_ControlChannelp->GetOriginalDestinationInformation(ActualClientIp,
                                                                  ActualClientPort,
                                                                  &ActualDestinationIp,
                                                                  &ActualDestinationPort,
                                                                  NULL);

        if( FAILED(hr) )
        {
            ICQ_TRC(TM_PRX, TL_ERROR, 
                    ("Can't use the GetOriginalDestination Information Interface E(%X)", hr ));
        }
        else
        {

            ICQ_TRC(TM_PRX, TL_TRACE,("DATA CAME from %s-%hu", 
                    INET_NTOA(ActualClientIp), htons(ActualClientPort)));
            
            ICQ_TRC(TM_PRX, TL_TRACE,("DATA WILL BE SEND TO %s-%hu", 
                    INET_NTOA(ActualDestinationIp), htons(ActualDestinationPort)));
        }
    
        //
        // Find the appropriate ICQ client entry for this 
        // ICQ CLIENT ~ ICQ SERVER UDP connection
        // Search the Created ICQ Client List to handle proper one.
        //
        // NOTE: Should we handle this with just IPs?
        // and the other Key might just be the server IP???
        //
        IcqClientp = dynamic_cast<PICQ_CLIENT>
                        (g_IcqClientList.SearchNodeKeys(ActualClientIp, 0));
    
        //
        // If there is no such entry than create one.
        //
        if(IcqClientp is NULL)
        {
            ICQ_TRC(TM_PRX, TL_INFO, ("PRX> NEW ICQ CLIENT DETECTED %s",
                                      INET_NTOA(ActualClientIp)));
    
            NEW_OBJECT(IcqClientp, ICQ_CLIENT);
            
            //
            // NOTE : ERROR CASE - proper handling pls.
            if(IcqClientp is NULL) 
            {
                ICQ_TRC(TM_PRX, TL_ERROR, ("PRX> MEMORY ALLOC ERROR"));
    
                hr = E_OUTOFMEMORY;
    
                return hr;
            }
    
            //
            // Write the IP-PORT information Here The client class
            // will collect rest of the information along the way
            //
    
            hr = IcqClientp->Initialize(Bufferp,
                                        ActualClientIp,
                                        ActualClientPort,
                                        ActualDestinationIp,
                                        ActualDestinationPort,
                                        Socketp);

            _ASSERT( SUCCEEDED(hr) );

            if( FAILED(hr) )
            {
                DELETE_COMPONENT( IcqClientp );
            }
            else // Add the client to the List
            {
                g_IcqClientList.InsertSorted(IcqClientp);
            }
        }
        else
        {
            ICQ_TRC(TM_PRX, TL_TRACE,
				    ("PRX> ICQ CLIENT EXISTS - READ-client will be called"));
    
            hr = IcqClientp->ClientRead( Bufferp,
                                         ActualDestinationIp,
                                         ActualDestinationPort );
        }
    }

    if ( FAILED(hr) )
    {

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\listc.h ===
#ifndef __LIST_CLASS_HEADER_
#define __LIST_CLASS_HEADER_



typedef class _GENERIC_NODE : public virtual COMPONENT_SYNC
{
	public:
		_GENERIC_NODE();
	
		virtual ~_GENERIC_NODE() {};

		virtual void ComponentCleanUpRoutine(void) {};

		virtual void  StopSync(void) {};
		
		virtual LONG CompareToMe(class _GENERIC_NODE *);

		virtual PCHAR GetObjectName() { return _GENERIC_NODE::ObjectNamep; }

		class _GENERIC_NODE * Nextp;
		class _GENERIC_NODE * Prevp;

		ULONG  iKey1;
		ULONG  iKey2;

		protected:
			static const  PCHAR ObjectNamep;

} GENERIC_NODE, * PGENERIC_NODE;




typedef class _CLIST : public virtual COMPONENT_SYNC
{

	public:

		_CLIST();

		~_CLIST();

		virtual void ComponentCleanUpRoutine(void);

		virtual PCHAR GetObjectNamep() { return ObjectNamep; }
			
		BOOLEAN isListEmpty(VOID);
		

		VOID InsertSorted(PGENERIC_NODE);

		PGENERIC_NODE SearchNodeKeys(
									 ULONG iKey1,
									 ULONG iKey2
									);

		PGENERIC_NODE RemoveSortedKeys(
									ULONG iKey1,
									ULONG iKey2
									);

		PGENERIC_NODE RemoveNodeFromList(PGENERIC_NODE);

		PGENERIC_NODE Pop();

		
	private:
		PGENERIC_NODE RemoveHead(VOID);

		PGENERIC_NODE RemoveTail(VOID);

		VOID InsertTail(PGENERIC_NODE);
		
		VOID InsertHead(PGENERIC_NODE);

		VOID FreeExistingNodes();

		PGENERIC_NODE listHeadp;

		PGENERIC_NODE listTailp;

		static const PCHAR ObjectNamep;

} CLIST, * PCLIST;

//
// MACROS
//
#define CLEAN_NODE(_X_)   \
	(_X_)->AcquireLock(); \
	(_X_)->Nextp = NULL;  \
	(_X_)->Prevp = NULL;  \
	(_X_)->ReleaseLock()

/*
#if 0
#define RemoveNodeFromList(Entry)                             \
{                                                             \
    PGENERIC_NODE _EX_Prev;                                   \
    PGENERIC_NODE _EX_Next;                                   \
    _EX_Next = (Entry)->Nextp;                                \
    _EX_Prev = (Entry)->Prevp;                                \
    if(_EX_Prev) _EX_Prev->Nextp = _EX_Next;                  \
    if(_EX_Next) _EX_Next->Prevp = _EX_Prev;                  \
}
#endif
//
// QUEUE Macros
//

#define QUEUE_ENTRY  listHeadp
#define PQUEUE_ENTRY listTailp

#define InitializeQueueHead()  InitializeListHead()
#define IsQueueEmpty()         IsListEmpty()
#define Enqueue(Entry)		   InsertTailList(Entry)
#define Dequeue()			   RemoveHeadList()
#define FreeQueue(FreeFunction)                    \
		FreeList(FreeFunction)

//
// STACK Macros
//

#define STACK_ENTRY                     listHeadp
#define PSTACK_ENTRY                    listTailp

#define InitializeStackHead()  InitializeListHead()
#define IsStackEmpty()         IsListEmpty()
#define Push(Entry)            InsertHeadList(Entry)
#define Pop()				   RemoveHeadList()
#define FreeStack(FreeFunction)                      \
		FreeList(FreeFunction)

*/







#endif //__LIST_CLASS_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\listc.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    

Abstract:

    

Author:

    Savas Guven (savasg)   27-Nov-2000

Revision History:

--*/
#include "stdafx.h"

//
// Initialize STATIC MEMBERS
//

const PCHAR _GENERIC_NODE::ObjectNamep = "GENERIC_NODE";

const PCHAR _CLIST::ObjectNamep = "CLIST";




_GENERIC_NODE::_GENERIC_NODE()
:Nextp(NULL), 
 Prevp(NULL),
 iKey1(0),
 iKey2(0)
{
	ICQ_TRC(TM_LIST, TL_DUMP, (" GENERIC_NODE - Default Constructor"));	
}


LONG
_GENERIC_NODE::CompareToMe(PGENERIC_NODE Nodep)
{
	LONG KeyOne = 0;
	LONG KeyTwo = 0;

	if(NULL is Nodep) return -1;

	if(Nodep->iKey1 is 0 && Nodep->iKey2 is 0) return 0;

	if(iKey1 > Nodep->iKey1)
	{
		KeyOne = 1;
	}
	else 
	{
		(iKey1 < Nodep->iKey1)?(KeyOne = -1):(KeyOne = 0);
	}

	if(this->iKey2 is 0 || Nodep->iKey2 is 0)
	{
		return KeyOne;
	}

	if(iKey2 > Nodep->iKey2)
	{
		KeyTwo = 1;
	}
	else
	{
		(iKey2 < Nodep->iKey2)?(KeyTwo = -1):(KeyTwo = 0);
	}


	if (KeyOne < 0) return -1;

	if(KeyOne is 0)
	{
		if(KeyTwo < 0) 
			return -1;
		else if(KeyTwo > 0)
			return 1;
	}

	if (KeyOne > 0) return 1;

	// this is the case of KeyOne == 0 and KeyTwo == 0
	return 0;
}




//
//
//
_CLIST::_CLIST()
:listHeadp(NULL), 
 listTailp(NULL) 
{
	ICQ_TRC(TM_LIST, TL_DUMP, ("CLIST - DEFAULT CONSTRUCTOR"));	
}


//
//
//
_CLIST::~_CLIST()
{
	ICQ_TRC(TM_LIST, TL_DUMP, ("CLIST - DESTRUCTOR"));	

	if(this->bCleanupCalled is FALSE)
	{
		_CLIST::ComponentCleanUpRoutine();
	}

	this->bCleanupCalled = FALSE;
}



//
// This function is inherited from the COMPONENT_REFERENCE
// Upon Deletion of this List.. it should dereference all the 
// elements still within the List.
//
void
_CLIST::ComponentCleanUpRoutine(void) 
{
	ICQ_TRC(TM_LIST, TL_DUMP, ("CLIST - ComponentCleanUpRoutine"));	

	FreeExistingNodes();
	
	this->bCleanupCalled = TRUE;
}

BOOLEAN 
_CLIST::isListEmpty(VOID)
{
   return (listHeadp is NULL);
}


//
// Remove the Head from the List and return - PRIVATE FUNC
//
PGENERIC_NODE
_CLIST::RemoveHead(VOID)
{
	PGENERIC_NODE Nodep = NULL;

	//Acquire the Lock
	// this->AcquireLock();
	do 
	{
		if(!isListEmpty())
		{
			Nodep = listHeadp;

			listHeadp = listHeadp->Nextp;

			if(listHeadp != NULL) 
			{
				listHeadp->Prevp = NULL;
			}

			break;
		}
	} while (FALSE);
	
	// Release the Lock
	// this->ReleaseLock();

	if(Nodep != NULL)
	{
		CLEAN_NODE(Nodep);
	}

	return Nodep;
}


//
// Remove the Last Element of the List. - PRIVATE FUNC
//
PGENERIC_NODE
_CLIST::RemoveTail(VOID)
{
	PGENERIC_NODE Nodep = NULL;

	// this->AcquireLock();

	do
	{
		if(!isListEmpty())
		{
			Nodep = listTailp;

			listTailp = listTailp->Prevp;

			if(listTailp != NULL) 
			{
				listTailp->Nextp = NULL;
			}
			else if(Nodep is listHeadp)
			{
				listHeadp = listTailp;
			}

			break;
		}
	} while (FALSE);
	
	// this->ReleaseLock();

	if(Nodep != NULL)
	{
		CLEAN_NODE(Nodep);
	}

	return Nodep;
}


//
// Inserts node into the tail without looking at the keys. - PRIVATE - FUNC
//
VOID
_CLIST::InsertTail(PGENERIC_NODE Nodep)
{

	// this->AcquireLock();

	do 
	{
		if(listTailp is NULL)
		{
			listHeadp = listTailp = Nodep;
			Nodep->Nextp = NULL;
			Nodep->Prevp = NULL;
			break;
		} 
		
		Nodep->Prevp = listTailp;

		listTailp->Nextp = Nodep;

		listTailp = Nodep;
	} while (FALSE);

	// this->ReleaseLock();

}


//
// Inserts a node in to the head without looking at the keys. - PRIVATE FUNC
//
VOID
_CLIST::InsertHead(PGENERIC_NODE Nodep)
{

	// this->AcquireLock();

	do
	{
		if(listHeadp is NULL)
		{
			listHeadp = listTailp = Nodep;

			Nodep->Prevp = NULL;

			Nodep->Nextp = NULL;

			break;
		}

		Nodep->Nextp = listHeadp;

		listHeadp->Prevp = Nodep;

		listHeadp = Nodep;

	} while (FALSE);

	// this->ReleaseLock();
}

//
// Inserts the Node as sorted. - PUBLIC
//
VOID
_CLIST::InsertSorted(
					 PGENERIC_NODE Nodep
					)
{
	PGENERIC_NODE NodePivotp = NULL;

	this->AcquireLock();

	do
	{

		if(!isListEmpty())
		{
			for(NodePivotp =  listHeadp; 
				NodePivotp != NULL;
				NodePivotp =  NodePivotp->Nextp)
				{
					if(NodePivotp->CompareToMe(Nodep) <= 0)
					{
						break;
					}
				}
		}
		else // No elements just bang it in.
		{
			listHeadp = listTailp = Nodep;
			break;
		}

		// then insert here.
		if(NodePivotp is listHeadp)
		{
			this->InsertHead(Nodep);
		}
		else if (NodePivotp is NULL)
		{
			this->InsertTail(Nodep);
		} 
		else // add prior to Pivot
		{
			Nodep->Prevp		= NodePivotp->Prevp;
			Nodep->Nextp		= NodePivotp;
			NodePivotp->Prevp	= Nodep;
		}
	} while(FALSE);

	REF_COMPONENT( Nodep, eRefList );

	this->ReleaseLock();
}


//
// Search a Node with the Given Keys.
// if there is no such node then return NULL - PUBLIC
//
PGENERIC_NODE
_CLIST::SearchNodeKeys
				  (
				   ULONG iKey1,
				   ULONG iKey2
				  )
{
	GENERIC_NODE TempNode;
	PGENERIC_NODE NodePivotp = NULL;

	TempNode.iKey1 = iKey1;
	TempNode.iKey2 = iKey2;

	this->AcquireLock();

	if(!isListEmpty())
	{
		for(NodePivotp =  listHeadp; 
			NodePivotp != NULL;
			NodePivotp =  NodePivotp->Nextp)
			{
				if(NodePivotp->CompareToMe(&TempNode) is 0)
				{
					this->ReleaseLock();

					return NodePivotp;
				}
			}
	}

	this->ReleaseLock();

	return NULL;
}

//
// Remove the node with the given Keys from the List.
//
// Note that SearchKey acquires and releases the Lock once
// we should never Acquire Lock s around functions which holds and 
// releases them.
// this will cause the release of the lock two times which is a wrong
// operation - PUBLIC
//
PGENERIC_NODE
_CLIST::RemoveSortedKeys
					(
						ULONG iKey1,
						ULONG iKey2
					)
{
	PGENERIC_NODE GNp = SearchNodeKeys(iKey1, iKey2);
	PGENERIC_NODE EX_Prevp = NULL;
	PGENERIC_NODE EX_Nextp = NULL;
	
	this->AcquireLock();
	do
	{

		if(GNp != NULL)
		{

			if(GNp is listHeadp)
			{
				RemoveHead();
			}
			else if(GNp is listTailp)
			{
				RemoveTail();
			}
			else if(!isListEmpty())
			{
				EX_Prevp = GNp->Prevp;
				EX_Nextp = GNp->Nextp;
				
				// ASSERT(EX_Prevp);
				EX_Prevp->Nextp = EX_Nextp;
				// ASSERT(EX_Nextp);
				EX_Nextp->Prevp = EX_Prevp;

			}

			CLEAN_NODE( GNp );

            STOP_COMPONENT( GNp );

			DEREF_COMPONENT( GNp, eRefList );
		}

	} while(FALSE);
	
	this->ReleaseLock();

	return GNp;
}

//
// PUBLIC
//
PGENERIC_NODE
_CLIST::RemoveNodeFromList(PGENERIC_NODE Pivotp)
{
	PGENERIC_NODE Nodep = NULL, EX_Prevp = NULL, EX_Nextp = NULL;

	if(Pivotp is NULL) return NULL;

	this->AcquireLock();

	do
	{

		for(Nodep = listHeadp;
			Nodep != NULL;
			Nodep = Nodep->Nextp)
		{
			if(Nodep is Pivotp)
			{
				if(Nodep is listHeadp)
				{
					RemoveHead();
				}
				else if(Nodep is listTailp)
				{
					RemoveTail();
				}
				else if(!isListEmpty())
				{
					EX_Prevp = Nodep->Prevp;
					EX_Nextp = Nodep->Nextp;
					
					// ASSERT(EX_Prevp);
					EX_Prevp->Nextp = EX_Nextp;
					// ASSERT(EX_Nextp);
					EX_Nextp->Prevp = EX_Prevp;

				}

				CLEAN_NODE( Nodep );

                STOP_COMPONENT( Nodep );

				DEREF_COMPONENT( Nodep, eRefList );

				break;
			}
		}
	} while (FALSE);

	this->ReleaseLock();

	return Nodep;
}

//
// POP is as the stack operation POP would be.. it returns the HEAD of the List
// PUBLIC FUNCTION
//
PGENERIC_NODE
_CLIST::Pop()
{
	PGENERIC_NODE Nodep = NULL;

	this->AcquireLock();

	Nodep = this->RemoveHead();

	if(Nodep != NULL)
	{
		DEREF_COMPONENT( Nodep, eRefList );
	}

	this->ReleaseLock();

	return Nodep;
}


//
// PRIVATE FUNC
//
VOID
_CLIST::FreeExistingNodes()
{
	PGENERIC_NODE Nodep;

	ICQ_TRC(TM_LIST, TL_TRACE, ("CLIST - FreeExistingNodes "));	

	for(Nodep = listHeadp;
		Nodep != NULL;
		Nodep = listHeadp)
	{
		// take Nodep out of List.
		listHeadp = Nodep->Nextp;

		if(listHeadp != NULL)
		{
			listHeadp->Prevp = Nodep->Prevp;
		}

		CLEAN_NODE(Nodep);

        STOP_COMPONENT(Nodep);

		DEREF_COMPONENT( Nodep, eRefList);
	}

	listHeadp = NULL;
	listTailp = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\icqmsg.cpp ===
#include "stdafx.h"


//
// V5 Mirabulus ICQ encryption
//
static CHAR M_ICQ_TABLE[]={
    0x59,0x60,0x37,0x6B,0x65,0x62,0x46,0x48,0x53,0x61,0x4C,0x59,0x60,0x57,0x5B,0x3D
    ,0x5E,0x34,0x6D,0x36,0x50,0x3F,0x6F,0x67,0x53,0x61,0x4C,0x59,0x40,0x47,0x63,0x39
    ,0x50,0x5F,0x5F,0x3F,0x6F,0x47,0x43,0x69,0x48,0x33,0x31,0x64,0x35,0x5A,0x4A,0x42
    ,0x56,0x40,0x67,0x53,0x41,0x07,0x6C,0x49,0x58,0x3B,0x4D,0x46,0x68,0x43,0x69,0x48
    ,0x33,0x31,0x44,0x65,0x62,0x46,0x48,0x53,0x41,0x07,0x6C,0x69,0x48,0x33,0x51,0x54
    ,0x5D,0x4E,0x6C,0x49,0x38,0x4B,0x55,0x4A,0x62,0x46,0x48,0x33,0x51,0x34,0x6D,0x36
    ,0x50,0x5F,0x5F,0x5F,0x3F,0x6F,0x47,0x63,0x59,0x40,0x67,0x33,0x31,0x64,0x35,0x5A
    ,0x6A,0x52,0x6E,0x3C,0x51,0x34,0x6D,0x36,0x50,0x5F,0x5F,0x3F,0x4F,0x37,0x4B,0x35
    ,0x5A,0x4A,0x62,0x66,0x58,0x3B,0x4D,0x66,0x58,0x5B,0x5D,0x4E,0x6C,0x49,0x58,0x3B
    ,0x4D,0x66,0x58,0x3B,0x4D,0x46,0x48,0x53,0x61,0x4C,0x59,0x40,0x67,0x33,0x31,0x64
    ,0x55,0x6A,0x32,0x3E,0x44,0x45,0x52,0x6E,0x3C,0x31,0x64,0x55,0x6A,0x52,0x4E,0x6C
    ,0x69,0x48,0x53,0x61,0x4C,0x39,0x30,0x6F,0x47,0x63,0x59,0x60,0x57,0x5B,0x3D,0x3E
    ,0x64,0x35,0x3A,0x3A,0x5A,0x6A,0x52,0x4E,0x6C,0x69,0x48,0x53,0x61,0x6C,0x49,0x58
    ,0x3B,0x4D,0x46,0x68,0x63,0x39,0x50,0x5F,0x5F,0x3F,0x6F,0x67,0x53,0x41,0x25,0x41
    ,0x3C,0x51,0x54,0x3D,0x5E,0x54,0x5D,0x4E,0x4C,0x39,0x50,0x5F,0x5F,0x5F,0x3F,0x6F
    ,0x47,0x43,0x69,0x48,0x33,0x51,0x54,0x5D,0x6E,0x3C,0x31,0x64,0x35,0x5A,0x00,0x00
};



int icq5_crypt(UCHAR *p,
			   int len,
			   int decrypt) 
/*++

Routine Description:

	
    
Arguments:

    none.

Return Value:

--*/
{
    ULONG REALCHECKCODE,A1,A2,A3,A4,A5,DATA;
    ULONG CODE1,CODE2,CODE3,CHECKCODE,POS,N,PL,T;
    ULONG NUMBER1,NUMBER2,R1,R2;

    if (decrypt) 
	{
        CHECKCODE = *(PULONG)(p+20);
        /*CHECKCODE = 0x89EC34FE;/**/

        A1 = CHECKCODE & 0x0001F000;
        A2 = CHECKCODE & 0x07C007C0;
        A3 = CHECKCODE & 0x003E0001;
        A4 = CHECKCODE & 0xF8000000;
        A5 = CHECKCODE & 0x0000083E;

        A1 = A1 >> 0x0C; // 12 Right
        A2 = A2 >> 0x01; //  1 Right
        A3 = A3 << 0x0A; // 10 Left
        A4 = A4 >> 0x10; // 16 Right
        A5 = A5 << 0x0F; // 15 Left

        REALCHECKCODE = A1 + A2 + A3 + A4 + A5;

        /*ICQ_TRC(TM_MSG, TL_TRACE,(" %x -> %x ", CHECKCODE, REALCHECKCODE);/**/

        CHECKCODE = REALCHECKCODE;

    }
	else 
	{

        *(PULONG)(p+20) = 0L;

        NUMBER1 = (p[8]<<24) + (p[4]<<16) + (p[2]<<8) + p[6];

        PL = len;

        R1 = 24%(PL - 18); /* PL - 24 */

        R2 = 24%0x0100;

        NUMBER2 = ((R1<<24)&0xFF000000L) + (((~p[R1])<<16)&0x00FF0000L) + ((R2<<8)&0x0000FF00L) + ((~M_ICQ_TABLE[R2])&0x000000FFL);

        CHECKCODE = NUMBER1^NUMBER2;
    }

    PL = len;

    CODE1 = PL * 0x68656C6CL;

    CODE2 = CODE1 + CHECKCODE;

    N = PL + 0x03;

    POS = 0x0A;

    while (POS < N) 
	{
        T = POS%0x0100;

        CODE3 = CODE2 + M_ICQ_TABLE[T];

        DATA = (*(PULONG)(p + POS));

        DATA ^= CODE3;

        *(PULONG)(p + POS) = (DATA);

        POS = POS + 4;
    }

    if (decrypt == 0) 
	{
        A1 = CHECKCODE & 0x0000001F;
        A2 = CHECKCODE & 0x03E003E0;
        A3 = CHECKCODE & 0xF8000400;
        A4 = CHECKCODE & 0x0000F800;
        A5 = CHECKCODE & 0x041F0000;

        A1 = A1 << 0x0C;
        A2 = A2 << 0x01;
        A3 = A3 >> 0x0A;
        A4 = A4 << 0x10;
        A5 = A5 >> 0x0F;

        REALCHECKCODE = A1 + A2 + A3 + A4 + A5;

        /*ICQ_TRC(TM_MSG, TL_TRACE,(" %x -> %x ", CHECKCODE, REALCHECKCODE);/**/

        *(PULONG)(p+20) = REALCHECKCODE;
    }

    return 0;
}



ULONG 
_ICQ_CLIENT::IcqClientToServerUdp(
    								PUCHAR buf,
    								ULONG size
								 )
/*++

Routine Description:

    Processes MEssages going from the CLient to the SErver.
    Especially the data where the Login Data is sent.
    This packet will contain the advertised port to which
    Peers will contact.
    
    
Arguments:

    none.

Return Value:

    

--*/
{
	ULONG Error =  NO_ERROR;
	UCHAR bbuf[1024];
	PUCHAR tbuf = bbuf;
	USHORT port, NewExternalPort;
	ULONG  clientUIN;

    ULONG BestSrcAdrr = 0L;

	//
	// version 5.0... written in the first two bytes.
	//
	if(buf[0] is 0x05 && buf[1] is 0x00) 
	{
        //
        // STORE the original buffer in another place.
        //
		memcpy(tbuf, buf, size);

		icq5_crypt(buf, size, 1);

        //
		// ICQ login cmd
		//
		if(*(PUSHORT)(buf+14) is 0x03E8)
		{
			//
			// *(PUSHORT)(buf+28)
			//
			port = htons(*(PUSHORT)(buf+28));

			clientUIN   = *(PULONG)(buf+6);

			ICQ_TRC(TM_MSG, TL_INFO,(" ICQ UIN is %lu", clientUIN));

			ICQ_TRC(TM_MSG, TL_INFO,(" ICQ TCP (client port is at) %hu", htons(port)));

			ICQ_TRC(TM_MSG, TL_INFO,(" ICQ password %s ", (buf +34)));


			//
			// IF we had enrolled previously then delete the old one and note
            // this new DETECT previous enrollment if we have redirection AND
            // an imitation port AND the client Peer port is different
            //
			if(this->IncomingPeerControlRedirectionp && 
               this->ImitatedPeerPort)
			{
				NewExternalPort = this->ImitatedPeerPort;
			} 
            else
            {
    			//
    			// step 1 - reserve a port to be used for the redirection
    			//
                Error = g_IAlgServicesp->ReservePort(1, &NewExternalPort);
    
    			if( FAILED(Error) )
    			{
    				ICQ_TRC(TM_MSG, TL_ERROR, 
    					    ("** !! ERROR - PORT RESERVATION HAS FAILED"));

                    return E_FAIL;
    			}
    
    			//
    			// Step 2 - Instantiate the Redirection
                // NOTE: RRAS problem here..
                //
                // Create on each Interface the Redirects that we see here.
    			//
                BestSrcAdrr = g_MyPublicIp;

    			this->IncomingPeerControlRedirectionp = 
                                            PeerRedirection(BestSrcAdrr,
                                                            NewExternalPort, 
                                                            0, 
                                                            0,
                                                            (ICQ_DIRECTION_FLAGS)eALG_INBOUND);

                if(this->IncomingPeerControlRedirectionp is NULL)
                {
                    g_IAlgServicesp->ReleaseReservedPort(NewExternalPort, 1);

                    ICQ_TRC(TM_MSG, TL_ERROR,
                            (" ERROR - Port Redirection for the Incoming packets - CRITICAL for this client"));

                    return E_FAIL;
                } 
                
                this->ImitatedPeerPort = NewExternalPort;

                ICQ_TRC(TM_MSG, TL_INFO, ("New ICQ Advertised PEER port is %hu",
                        htons(NewExternalPort)));
            }
			
			//
			// IF success then commit the changes to the PORT section of this 
            // message - IF we have error above it doesn't matter how we commit 
            // the changes here.
            //
            *(PUSHORT)(buf+28)     = htons(NewExternalPort);
    
            this->ClientToPeerPort = port;

    		this->UIN			   = clientUIN;
            
            //
            // Encrypt the packet again.
            //
			icq5_crypt(buf,size,0);
		}
		else
		{
            //
            // Restore the buffer.
            //
			memcpy(buf, tbuf, size);
		}
	}

	return Error;
} // End of _ICQ_CLIENT::IcqClientToServerUdp





//
//
//
ULONG 
_ICQ_CLIENT::IcqServerToClientUdp(
                                    PUCHAR  mcp,
                                    ULONG	mcplen
                                )
/*++

Routine Description:

    
    
Arguments:

    none.

Return Value:

    

--*/
{
    ULONG cmd_len, Error = NO_ERROR;
    USHORT mcmd;
    ULONG changed;
	PICQ_PEER IcqPeerp = NULL;


	ULONG curPeerIp;
	USHORT curPeerPort;
	ULONG IcqUIN;

    changed = 0;
    cmd_len = 0;
    
	while (*(PUSHORT)mcp is 0x0005) 
	{
        mcmd = *(PUSHORT)(mcp+7);

        switch (mcmd) 
		{
        case 0x0212:
            cmd_len = 22;
            break;

        case 0x021C:
            cmd_len = 25;
            break;

        case 0x000A: /* ACK */
            cmd_len = 21;
            break;

        case 0x005A:
            cmd_len = 53;
            break;

        case 0x01A4:
            cmd_len = 29;
            break;

        case 0x0078:
            cmd_len = 25;
            break;

            /*case 0x024E: USER_FOUND */
        case 0x006E: /* USER_ONLINE */
            cmd_len = 70; // this is 62 in ME

            //
            // Not encrypted in this direction BUG BUG: alignment for ia64
            //
			IcqUIN = *(PULONG)(mcp+21);

			curPeerIp = *(PULONG)(mcp+25);

			curPeerPort = htons(*(PUSHORT)(mcp+29));

			ICQ_TRC(TM_TEST, TL_ERROR,
							 (" USER_ONLINE: UIN %ul %s:%hu",  
							 IcqUIN,
							 INET_NTOA(curPeerIp), // IP
							 htons(curPeerPort)));		  // PORT
            
			//
            // For us ?
            //

			//
			// Determine the existence of any Internal ICQ Peer here.
			// scan the "g_IcqClientList" for UINs given here.
			// IF the Peer is internal change the IP : PORT information to the original
			// IP and PORT information and do not create any redirections
            // Note that we can't give the ICS-Local clients IP as the interface might be 
            // Firewalled...
			// 
			if(ScanTheListForLocalPeer(&curPeerIp, &curPeerPort, IcqUIN))
			{
				//
				// Change the appropriate fields in the buffer
                //
				*(PULONG)(mcp+25)  = curPeerIp;

				*(PUSHORT)(mcp+29) = htons(curPeerPort);

				ICQ_TRC(TM_MSG, TL_INFO, 
                        ("Local ICQ Peer Online !! The original ADDR is %s:%hu UIN(%lu)",
						INET_NTOA(curPeerIp), htons(curPeerPort), IcqUIN));

				break; // break from the switch-case loop
			}

			// DO we have alredy the client in the List?
			IcqPeerp = dynamic_cast<PICQ_PEER>\
                                   (this->IcqPeerList.SearchNodeKeys(IcqUIN, 0));

			// check if IP:PORT information has changed or not.
			if(IcqPeerp != NULL)
			{
				if(IcqPeerp->PeerIp   != curPeerIp  || 
                   IcqPeerp->PeerPort != curPeerPort)
				{
					ICQ_TRC(TM_MSG, TL_INFO, 
						("IP:PORT change of existing Client - Changing values"));

					this->IcqPeerList.RemoveNodeFromList(IcqPeerp);

					IcqPeerp = NULL;
				} 
				else // if there is no change don't go further
				{
					ICQ_TRC(TM_MSG, TL_TRACE, ("Already such an entry - skipping"));

					break;
				}
			}
			

			// IF Peer is outside the Local NET DO:
			//      - Create a Redirection from our ICQ(IP) -> Peer(IP:PORT) to the 
			// Dispatch IP:PORT
			do
			{ 
                NEW_OBJECT(IcqPeerp, ICQ_PEER);
				//IcqPeerp = new ICQ_PEER();

				if(IcqPeerp is NULL)
				{
					Error = E_OUTOFMEMORY;
					
					ICQ_TRC(TM_MSG, TL_ERROR, 
                            ("Error - can't create Peer object"));

					break;
				}

				IcqPeerp->PeerUIN  = IcqUIN;

				IcqPeerp->PeerIp   = curPeerIp;

				IcqPeerp->PeerPort = curPeerPort;

                //
				// set the research 
                //
				IcqPeerp->iKey1 = IcqUIN;

				IcqPeerp->iKey2 = 0;

				//		- Request a Dispatch for this destination IP.. but also add the source IP
				// information as it is important too. THESE CONNECTIONS are from the 
				// Internal guy.. so add the appropriate flag or context to the Requests
				IcqPeerp->OutgoingPeerControlRedirectp 
							= this->PeerRedirection(IcqPeerp->PeerIp,   // search Key 1
												    IcqPeerp->PeerPort, // search Key 2
												    this->ClientIp,
												    0,
												    (ICQ_DIRECTION_FLAGS)eALG_OUTBOUND);

				if(IcqPeerp->OutgoingPeerControlRedirectp is NULL)
				{
                    STOP_COMPONENT( IcqPeerp );

					DEREF_COMPONENT( IcqPeerp, eRefInitialization );

					break;
				}

				//
				// put this into the list of Peers
                //
				this->IcqPeerList.InsertSorted(IcqPeerp);

				// 
				// relinquish the ownership - removal from the list should
                // cause deletion
                //
				DEREF_COMPONENT( IcqPeerp, eRefList );

			} while(FALSE);

            break;

        default:
            break;
        }


        if (cmd_len is 0)  // cannot decode, so skip out 
		{
            break; // got to recognize the first one at least 
        }

        mcp    += cmd_len;
        mcplen -= cmd_len;

        if (mcplen > 1) 
		{
            cmd_len = *(PUSHORT)mcp;
            mcp += 2;

            if (mcplen < cmd_len) // not enough bytes to satisfy
			{
                break;
            }
        } 
		else 
		{
            break;
        }

    }

    return changed;
} // End of IcqServerToClientUdp
















//
//
//
ULONG 
_ICQ_PEER::ProcessOutgoingPeerMessage(PUCHAR Bufp, ULONG mesgLen)
/*++

Routine Description:

    Upon detection of an outgoing Peer TCP packet this Function is called. 
    We are supposed to just create a DATA redirection should the need arise.
    
    Missing parts: do we need multiple redirections? If so how do we tear 'em
    down          ???? test this out.
    
Arguments:

    none.

Return Value:

    

--*/
{
	USHORT port1, port2;
	PUSHORT FirstPortp = NULL;
	PUSHORT SecondPortp = NULL;

	ULONG Error = NO_ERROR;
	USHORT portAllocated = 0, portClient = 0;
	ULONG ipClient = 0L;

	

	if(mesgLen  is 0x37 || mesgLen is (0x37 +2))
	{
		FirstPortp = (PUSHORT)&Bufp[0x20 + 11];
		SecondPortp = (PUSHORT)&Bufp[0x20 + 15];
	}
	else if(mesgLen  is 0x3B || mesgLen is (0x3B +2))
	{
		FirstPortp  = (PUSHORT)&Bufp[0x28];
		SecondPortp = (PUSHORT)&Bufp[0x33];
	}
	else if(mesgLen  is 0x2A)
	{
		FirstPortp  = (PUSHORT)&Bufp[0x22];
		SecondPortp = (PUSHORT)&Bufp[0x26];
	}
	else if(mesgLen  is 0x2E)
	{
		FirstPortp  = (PUSHORT)&Bufp[0x1F];
		SecondPortp = (PUSHORT)&Bufp[0x2A];
	}

	if(FirstPortp && SecondPortp)
	{
		port1 = htons(*FirstPortp);
		port2 = *SecondPortp;

		if(port1 && port2 && port1 is port2)
		{
			ICQ_TRC(TM_MSG, TL_TRACE, 
					("Data Session will be handled on port 1 %hu - port 2 %hu",  
					*FirstPortp,	// in NET format
					*SecondPortp)   // in x86 format
				   );

			//
			// Reserve A port for this operation !?
            Error = g_IAlgServicesp->ReservePort(1, &portAllocated);

            if ( FAILED(Error) )
			{
				ICQ_TRC(TM_MSG, TL_ERROR, ("Error !! - CAN't ALLOCATE PORT"));

				ErrorOut();

				return Error;
			}

			this->ToClientSocketp->NhQueryRemoteEndpointSocket(&ipClient, 
															   NULL);

			//
			// Create A redirect and save the handle - NOTE:
            // we can add the peer's IP as an additional security feature.
            //
            Error = g_IAlgServicesp->CreateDataChannel(eALG_TCP,
                                                       ipClient,
                                                       *FirstPortp,
                                                       g_MyPublicIp,
                                                       portAllocated,
                                                       0,
                                                       0,
                                                       eALG_INBOUND,
                                                       eALG_NONE,
                                                       FALSE,
                                                       &IncomingDataRedirectp);
			if( FAILED(Error) || (IncomingDataRedirectp is NULL))
			{
                g_IAlgServicesp->ReleaseReservedPort(portAllocated, 1);

				ICQ_TRC(TM_MSG, TL_ERROR, 
						("** !! ERROR - Can't create Redirect for DATA !! **"));

                ICQ_TRC(TM_MSG, TL_ERROR, 
                        ("** !! ERROR FAILED PARAM - ipClient public:%hu -> %s:%u",
                         htons(portAllocated),
                         INET_NTOA(ipClient), 
                         htons(*FirstPortp)));

				ErrorOut();

				return Error;
			}
			
            //
            // NOTE: possible hazard clarify with jonburs and jp
            // we actually do not care about this Release - if the ALG doesn't clean up
            // BUG BUG
            // IncomingDataRedirectp->Release();

			//
			// Save the new port information appropriately.
			*SecondPortp  = htons(portAllocated); // x86

			*FirstPortp   = portAllocated; // NET format

			ICQ_TRC(TM_MSG, TL_TRACE, 
					("DATA port Allocated is %hu", *SecondPortp));
		}
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\myadapternotify.h ===
//
// MyAdapterNotify.h : Declaration of the CMyAdapterNotify
//

#pragma once

// {6E590D52-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_MyAdapterNotificationSink, 0x6e590d52, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);



/////////////////////////////////////////////////////////////////////////////
//
// CMyAdapterNotify
//
class ATL_NO_VTABLE CMyAdapterNotify : 
    public CComObjectRoot,
    public CComCoClass<CMyAdapterNotify, &CLSID_MyAdapterNotificationSink>,
    public IAdapterNotificationSink
{
public:
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CMyAdapterNotify)     


BEGIN_COM_MAP(CMyAdapterNotify)
	COM_INTERFACE_ENTRY(IAdapterNotificationSink)
END_COM_MAP()


// IAdapterNotificationSink
public:
	STDMETHODIMP    AdapterAdded     (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterRemoved   (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterModified  (IAdapterInfo*   pAdapter);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\list.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\list.h

Abstract:

    The file contains a list implementation.

--*/

#ifndef _LIST_H_
#define _LIST_H_

/*++

The Following are already defined

(public\sdk\inc\winnt.h)

//
// Calculate the byte offset of a 'field' in a structure of type 'type'.
//
// #define FIELD_OFFSET(type, field)                                    \
//     ((LONG)(LONG_PTR)&(((type *)0)->field))
//

//
// Calculate the address of the base of the structure given its 'type',
// and an 'address' of a 'field' within the structure.
//
// #define CONTAINING_RECORD(address, type, field)                      \
//     ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))
//

//  Doubly linked list structure.
//
// typedef struct _LIST_ENTRY
// {
//     struct _LIST_ENTRY *Flink;
//     struct _LIST_ENTRY *Blink;
// } LIST_ENTRY, *PLIST_ENTRY;
//

--*/

//
//  Doubly-linked list manipulation routines.  Implemented as macros but
//  logically these are procedures.
//



//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead)                            \
    ((ListHead)->Flink = (ListHead)->Blink = (ListHead))


    
//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead)                                   \
    ((ListHead)->Flink == (ListHead))


    
//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead)                                \
    (ListHead)->Flink;                                          \
    {RemoveEntryList((ListHead)->Flink)}



//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead)                                \
    (ListHead)->Blink;                                          \
    {RemoveEntryList((ListHead)->Blink)}



//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry)                                  \
{                                                               \
    PLIST_ENTRY _EX_Blink;                                      \
    PLIST_ENTRY _EX_Flink;                                      \
    _EX_Flink = (Entry)->Flink;                                 \
    _EX_Blink = (Entry)->Blink;                                 \
    _EX_Blink->Flink = _EX_Flink;                               \
    _EX_Flink->Blink = _EX_Blink;                               \
}



//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry)                          \
{                                                               \
    PLIST_ENTRY _EX_Blink;                                      \
    PLIST_ENTRY _EX_ListHead;                                   \
    _EX_ListHead = (ListHead);                                  \
    _EX_Blink = _EX_ListHead->Blink;                            \
    (Entry)->Flink = _EX_ListHead;                              \
    (Entry)->Blink = _EX_Blink;                                 \
    _EX_Blink->Flink = (Entry);                                 \
    _EX_ListHead->Blink = (Entry);                              \
}



//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry)                          \
{                                                               \
    PLIST_ENTRY _EX_Flink;                                      \
    PLIST_ENTRY _EX_ListHead;                                   \
    _EX_ListHead = (ListHead);                                  \
    _EX_Flink = _EX_ListHead->Flink;                            \
    (Entry)->Flink = _EX_Flink;                                 \
    (Entry)->Blink = _EX_ListHead;                              \
    _EX_Flink->Blink = (Entry);                                 \
    _EX_ListHead->Flink = (Entry);                              \
}



//
//  VOID
//  InsertSortedList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry,
//      LONG(*CompareFunction)(PLIST_ENTRY, PLIST_ENTRY)
//      );
//

#define InsertSortedList(ListHead, Entry, CompareFunction)      \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    PLIST_ENTRY _EX_Blink;                                      \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        if ((*(CompareFunction))((Entry), _EX_Entry) <= 0)      \
            break;                                              \
    _EX_Blink = _EX_Entry->Blink;                               \
    _EX_Blink->Flink = (Entry);                                 \
    _EX_Entry->Blink = (Entry);                                 \
    (Entry)->Flink     = _EX_Entry;                             \
    (Entry)->Blink     = _EX_Blink;                             \
}



//
// Finds an 'Entry' equal to 'Key' in a 'List'
// 
//  VOID
//  FindList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Key,
//      PLIST_ENTRY *Entry,
//      LONG (*CompareFunction)(PLIST_ENTRY, PLIST_ENTRY)
//      );
//

#define FindList(ListHead, Key, Entry, CompareFunction)         \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    *(Entry) = NULL;                                            \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        if ((*(CompareFunction))((Key), _EX_Entry) is 0)        \
        {                                                       \
            *(Entry) = _EX_Entry;                               \
            break;                                              \
        }                                                       \
}



//
// Finds an 'Entry' equal to or greater than 'Key' in a sorted 'List'
// 
//  VOID
//  FindSortedList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Key,
//      PLIST_ENTRY *Entry,
//      LONG (*CompareFunction)(PLIST_ENTRY, PLIST_ENTRY)
//      );
//

#define FindSortedList(ListHead, Key, Entry, CompareFunction)   \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    *(Entry) = NULL;                                            \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        if ((*(CompareFunction))((Key), _EX_Entry) <= 0)        \
        {                                                       \
            *(Entry) = _EX_Entry;                               \
            break;                                              \
        }                                                       \
}



//
// Applies a 'Function' to all entries in a list.
// 
//  VOID
//  MapCarList(
//      PLIST_ENTRY ListHead,
//      VOID(*VoidFunction)(PLIST_ENTRY)
//      );
//

#define MapCarList(ListHead, VoidFunction)                      \
{                                                               \
    PLIST_ENTRY _EX_Entry;                                      \
    for (_EX_Entry = (ListHead)->Flink;                         \
         _EX_Entry != (ListHead);                               \
         _EX_Entry = _EX_Entry->Flink)                          \
        (*(VoidFunction))(_EX_Entry);                           \
}



//
// Frees a list.
// 
//  VOID
//  FreeList(
//      PLIST_ENTRY ListHead,
//      VOID(*FreeFunction)(PLIST_ENTRY)
//      );
//

#define FreeList(ListHead, FreeFunction)                        \
{                                                               \
    PLIST_ENTRY _EX_Head;                                       \
    while (!IsListEmpty(ListHead))                              \
    {                                                           \
        _EX_Head = RemoveHeadList(ListHead);                    \
        (*(FreeFunction))(_EX_Head);                            \
    }                                                           \
}
    

/*
#define QUEUE_ENTRY                     LIST_ENTRY
#define PQUEUE_ENTRY                    PLIST_ENTRY

//
//  VOID
//  InitializeQueueHead(
//      PQUEUE_ENTRY QueueHead
//      );
//

#define InitializeQueueHead(QueueHead)  InitializeListHead(QueueHead)

//
//  BOOLEAN
//  IsQueueEmpty(
//      PQUEUE_ENTRY QueueHead
//      );
//

#define IsQueueEmpty(QueueHead)         IsListEmpty(QueueHead)

//
//  VOID
//  Enqueue(
//      PQUEUE_ENTRY QueueHead,
//      PQUEUE_ENTRY Entry
//      );
//

#define Enqueue(QueueHead, Entry)       InsertTailList(QueueHead, Entry)

//
//  PQUEUE_ENTRY
//  Dequeue(
//      PQUEUE_ENTRY QueueHead,
//      );
//

#define Dequeue(QueueHead)              RemoveHeadList(QueueHead)

// 
//  VOID
//  FreeQueue(
//      PQUEUE_ENTRY QueueHead,
//      VOID(*FreeFunction)(PQUEUE_ENTRY)
//      );
//

#define FreeQueue(QueueHead, FreeFunction)                      \
    FreeList(QueueHead, FreeFunction)

//
//  VOID
//  MapCarQueue(
//      PQUEUE_ENTRY QueueHead,
//      VOID(*VoidFunction)(PQUEUE_ENTRY)
//      );
//

#define MapCarQueue(QueueHead, VoidFunction)                    \
    MapCarList(QueueHead, VoidFunction)



#define STACK_ENTRY                     LIST_ENTRY
#define PSTACK_ENTRY                    PLIST_ENTRY

//
//  VOID
//  InitializeStackHead(
//      PSTACK_ENTRY StackHead
//      );
//

#define InitializeStackHead(StackHead)  InitializeListHead(StackHead)

//
//  BOOLEAN
//  IsStackEmpty(
//      PSTACK_ENTRY StackHead
//      );
//

#define IsStackEmpty(StackHead)         IsListEmpty(StackHead)

//
//  VOID
//  Push(
//      PSTACK_ENTRY StackHead,
//      PSTACK_ENTRY Entry
//      );
//

#define Push(StackHead, Entry)          InsertHeadList(StackHead, Entry)

//
//  PSTACK_ENTRY
//  Pop(
//      PSTACK_ENTRY StackHead,
//      );
//

#define Pop(StackHead)                  RemoveHeadList(StackHead)

// 
//  VOID
//  FreeStack(
//      PSTACK_ENTRY StackHead,
//      VOID(*FreeFunction)(PSTACK_ENTRY)
//      );
//

#define FreeStack(StackHead, FreeFunction)                      \
    FreeList(StackHead, FreeFunction)

//
//  VOID
//  MapCarStack(
//      PSTACK_ENTRY StackHead,
//      VOID(*VoidFunction)(PSTACK_ENTRY)
//      );
//

#define MapCarStack(StackHead, VoidFunction)                    \
    MapCarList(StackHead, VoidFunction)
*/
#endif // _LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\myadapternotify.cpp ===
#include "stdafx.h"

#include "MyAdapterNotify.h"


/////////////////////////////////////////////////////////////////////////////
// CMyAdapterNotify
//

IcqPrx *			 g_IcqPrxp     = NULL;

ULONG                g_MyPublicIp  = 0L;

ULONG                g_MyPrivateIp = 0L;


//
// This function will be call when a new adapter is made active
//
STDMETHODIMP 
CMyAdapterNotify::AdapterAdded(
	IAdapterInfo*   pAdapter
	)
{
    ULONG               AdapterIndex  = 0;
    ALG_ADAPTER_TYPE    AdapterType      ;
    ULONG               AddressCount  = 0;
    PULONG              AddressArrayp = NULL;

    HRESULT             Result        = S_OK;      

    ICQ_TRC(TM_IF, TL_TRACE, ("CMyAdapterNotify::AdapterAdded"));

    return S_OK;
}


//
// This function will be call when a adapter is remove and/or disable
//
STDMETHODIMP 
CMyAdapterNotify::AdapterRemoved(
	IAdapterInfo*   pAdapter
	)
{
    ULONG               AdapterIndex  = 0;
    ALG_ADAPTER_TYPE    AdapterType      ;
    ULONG               AddressCount  = 0;
    PULONG              AddressArrayp = NULL;

    HRESULT             Result        = S_OK;      
    
    ICQ_TRC(TM_IF, TL_TRACE, ("CMyAdapterNotify::AdapterRemoved"));

    Result = pAdapter->GetAdapterIndex(&AdapterIndex);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("AdapterIndex has failed"));

        return S_FALSE;
    }

    Result = pAdapter->GetAdapterType(&AdapterType);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("Adapter Type has failed"));

        return S_FALSE;
    }

    Result = pAdapter->GetAdapterAddresses(&AddressCount,
                                           &AddressArrayp);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("Adapter Addresses has failed"));

        return S_FALSE;
    }

    //
    // Create a report on the gathered information
    //
    ICQ_TRC(TM_IF, TL_TRACE, 
            (" Interface FW %u: BD %u: PV %u ",
            ALG_IFC_FW(AdapterType),
            ALG_IFC_BOUNDARY(AdapterType),
            ALG_IFC_PRIVATE(AdapterType))
           );

    ICQ_TRC(TM_IF, TL_TRACE,
            ("Interface index: %u addr count %u", 
             AdapterIndex, AddressCount));

    for(ULONG i = 0; i < AddressCount; i++)
    {
        ICQ_TRC(TM_IF, TL_TRACE,
                ("Adapter Address[%u] is %s",
                 i, 
                 INET_NTOA(AddressArrayp[i]))
               );
    }

    // 
    //  Remove  ICQ PROXY HERE
    //
    if( (ALG_IFC_FW(AdapterType) || 
         ALG_IFC_BOUNDARY(AdapterType)) )
    {
        ASSERT( g_IcqPrxp != NULL );

        STOP_COMPONENT( g_IcqPrxp );
    
        DEREF_COMPONENT( g_IcqPrxp, eRefInitialization );
    }
    else
    {
        g_MyPrivateIp = 0;
    }

    return S_OK;
}


//
// This function will be call when a adapter is modified
//
STDMETHODIMP 
CMyAdapterNotify::AdapterModified(
	IAdapterInfo*   pAdapter
	)
{
    ULONG               AdapterIndex  = 0;
    ALG_ADAPTER_TYPE    AdapterType      ;
    ULONG               AddressCount  = 0;
    PULONG              AddressArrayp = NULL;

    HRESULT             Result        = S_OK;      
    
    ICQ_TRC(TM_IF, TL_TRACE, ("CMyAdapterNotify::AdapterModified"));

    Result = pAdapter->GetAdapterIndex(&AdapterIndex);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("AdapterIndex has failed"));

        return S_FALSE;
    }

    Result = pAdapter->GetAdapterType(&AdapterType);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("Adapter Type has failed"));

        return S_FALSE;
    }

    Result = pAdapter->GetAdapterAddresses(&AddressCount,
                                           &AddressArrayp);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("Adapter Addresses has failed"));

        return S_FALSE;
    }

    //
    // Create a report on the gathered information
    //
    ICQ_TRC(TM_IF, TL_TRACE, 
            (" Interface FW %u: BD %u: PV %u ",
            ALG_IFC_FW(AdapterType),
            ALG_IFC_BOUNDARY(AdapterType),
            ALG_IFC_PRIVATE(AdapterType))
           );

    ICQ_TRC(TM_IF, TL_TRACE,
            ("Interface index: %u addr count %u", 
             AdapterIndex, AddressCount));

    for(ULONG i = 0; i < AddressCount; i++)
    {
        ICQ_TRC(TM_IF, TL_TRACE,
                ("Adapter Address[%u] is %s",
                 i, 
                 INET_NTOA(AddressArrayp[i]))
               );
    }

    //
    // Initialize the ICQ Proxy here with the appropriate IP
    //
    if( (ALG_IFC_FW(AdapterType) || ALG_IFC_BOUNDARY(AdapterType)) &&
         (AddressCount > 0)                                        &&
         (AddressArrayp != NULL)
      )
    {
        ASSERT( g_IcqPrxp is NULL );

        NEW_OBJECT( g_IcqPrxp, IcqPrx );

        if(g_IcqPrxp is NULL)
        {
            ASSERT(FALSE);
        }
        else
        {
            //
            // Use the first IP on the List of IPs belonging to this
            // Interface
            //
            Result = g_IcqPrxp->RunIcq99Proxy(AddressArrayp[0]);

            if(Result)
            {
                ICQ_TRC(TM_IF, TL_ERROR, ("** !! ICQ PRX RUN FAILED !! **"));
            }
        }
    }
    else if( (AddressCount > 0) && (AddressArrayp != NULL) )
    {
        ICQ_TRC(TM_IF, TL_ERROR, ("** !! ICQ PRX WONT RUN !! **"));

        g_MyPrivateIp = AddressArrayp[0];
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\myalg.h ===
// MyALG.h : Declaration of the CAlgICQ

#pragma once

#include "resource.h"       // main symbols

// {6E590D51-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_AlgICQ, 0x6e590d51, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);



//////////////////////////////////////////////////////////////
// CAlgICQ
class ATL_NO_VTABLE CAlgICQ : 
    public CComObjectRoot,
    public CComCoClass<CAlgICQ, &CLSID_AlgICQ>,
    public IApplicationGateway
{
public:
    //DECLARE_REGISTRY(CAlgICQ, TEXT("ALG_ICQ.MyALG.1"),  TEXT("ALG_ICQ.MyALG"), -1, THREADFLAGS_BOTH)
    DECLARE_NO_REGISTRY();

public:
	CAlgICQ()
	{
	}


BEGIN_COM_MAP(CAlgICQ)
	COM_INTERFACE_ENTRY(IApplicationGateway) 
END_COM_MAP()

// IApplicationGateway
public:
	STDMETHOD(Initialize)(IApplicationGatewayServices* pIAlgServices);
	STDMETHOD(Stop)(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\myalg.cpp ===
// MyALG.cpp : Implementation of CAlgICQ

#include "stdafx.h"

#include "MyALG.h"
#include "MyAdapterNotify.h"



#pragma comment(lib, "wsock32.lib")





IApplicationGatewayServices* g_IAlgServicesp             = NULL;

IAdapterNotificationSink *   g_IAdapterNotificationSinkp = NULL;

DWORD                        g_AdapterSinkCookie         = 0;


//HANDLE   hTranslatorHandle;

// RedirectionInterface RI;

PCOMPONENT_SYNC g_IcqComponentReferencep = NULL;

CRITICAL_SECTION     GlobalIcqLock;





//
//
//
STDMETHODIMP 
CAlgICQ::Initialize(
	IApplicationGatewayServices* IAlgServicesp
	)
{
    WSADATA wd;

    CComObject<CMyAdapterNotify>*   IAdapterNotifyp;

    HRESULT Result;


    PROFILER(TM_MSG, TL_ERROR, ("> Initialize"));


    InitDebuger();


    ASSERT(IAlgServicesp);

    //
    // Get the Services Interface
    //
    IAlgServicesp->QueryInterface(IID_IApplicationGatewayServices,
                                  (void**)&g_IAlgServicesp);

    ASSERT(g_IAlgServicesp);



    //
    // Initialize the socket library.
    //
    if ( WSAStartup(MAKEWORD(2,2), &wd) != 0)
    {
        ICQ_TRC(TM_DEFAULT, TL_ERROR,
                ("WSAStartup Error %u", WSAGetLastError()));

        ErrorOut();
    }

    NhInitializeBufferManagement();

    


    __try
    {
        InitializeCriticalSection(&GlobalIcqLock);
    } 
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        ErrorOut();
    
        return S_FALSE;
    }


    //
    // NOTE: the ipnathlp.dll connection is severed.
    //
    // This is the Initialization for the Redirection Interface stolen
    // from the IPNATHLP.DLL hopefully if we just change the interfaces 
    // to something else at least this part should be reusable.
    //
    //  RI.Initialize();

    //
    // g_IcqPrxp = new IcqPrx;
    //

    // *
    // Get the Adapter Notify interface
    //
    CComObject<CMyAdapterNotify>::CreateInstance(&IAdapterNotifyp);

    if(IAdapterNotifyp is NULL)
    {
        ICQ_TRC(TM_DEFAULT, TL_ERROR, 
                ("Can't Instantiate the Adapter Notification Interface"));

        return S_FALSE;
    }

    //
    // Get the AdapterNotification Interface for further Use.
    //
    Result = IAdapterNotifyp->QueryInterface(
                                             IID_IAdapterNotificationSink,
                                             (void**)&g_IAdapterNotificationSinkp
                                            );

    if( FAILED(Result) )
    {
        ICQ_TRC(TM_DEFAULT, TL_ERROR, 
                (" Query Interface for the Interface Notification Sink has failed"));

        return S_FALSE;
    }


    //
    // Initialize the TimerQueue
    //
    g_TimerQueueHandle = CreateTimerQueue();

    if(g_TimerQueueHandle is NULL)
    {
        Result = GetLastError();

        ICQ_TRC(TM_DEFAULT, TL_ERROR, 
                ("Timer initialization has failed Error is %u", Result));

        return S_FALSE;

    }

    //
    // Start the Adapter Notifications.
    //
    Result =  g_IAlgServicesp->StartAdapterNotifications(g_IAdapterNotificationSinkp,
                                                         &g_AdapterSinkCookie);

    if ( FAILED(Result) )
    {
        ICQ_TRC(TM_DEFAULT, TL_ERROR,
                ("Start Adapter Notification has failed %u", Result));

        return Result;
    }
    // *

    return Result;
} // Initialize





STDMETHODIMP 
CAlgICQ::Stop(void)
{
    HRESULT Error = NO_ERROR;


    //
    // Stop Adapter Notification and Release the Interface
    //
    if(g_AdapterSinkCookie         && 
       g_IAdapterNotificationSinkp)
    {
        Error = g_IAlgServicesp->StopAdapterNotifications(g_AdapterSinkCookie);
    
        if( FAILED(Error) )
        {
    
        }
    
        g_IAdapterNotificationSinkp->Release();
    }
    
    //
    // Delete the Timer Queue
    //
    if(g_TimerQueueHandle != NULL)
    {
        DeleteTimerQueueEx(g_TimerQueueHandle, INVALID_HANDLE_VALUE);

        g_TimerQueueHandle = NULL;
    }

    DeleteCriticalSection(&GlobalIcqLock);

    WSACleanup();

    g_IAlgServicesp->Release();

    NhShutdownBufferManagement();

    DestroyDebuger();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ALG_ICQ.rc
//
#define IDS_PROJNAME                    100
#define IDR_MYALG                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\stdafx.h ===
#pragma once


#define _ATL_APARTMENT_THREADED


//#define ATL_TRACE_CATEGORY(0xFFFFFFFF)
#define   ATL_TRACE_LEVEL 4


#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <tchar.h>
#include <rtutils.h>

#include <Winsock2.h>

#include <ws2tcpip.h>
#include <mstcpip.h>
#include <mswsock.h>

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>

#include <Alg.h>

#include "util.h"

#include "sync.h"
#include "icqdbg.h"
#include "buffer.h"
#include "listc.h"
#include "list.h"
#include "socket.h"
#include "dispatcher.h"
#include "icqio.h"
#include "icqcl.h"
#include "icqprx.h"
#include "nathlpp.h"



#define is ==


//
// GLOBALS
//
extern CSockDispatcher * g_IcqPeerDispatcherp;

extern ULONG g_MyPublicIp;

extern ULONG g_MyPrivateIp;

extern CLIST g_IcqClientList;

extern PCOMPONENT_SYNC g_IcqComponentReferencep;

extern IcqPrx * g_IcqPrxp;

extern IApplicationGatewayServices* g_IAlgServicesp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\socket.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains code for socket-management.
    The routines provided generally follow the same asynchronous model
    using a completion routine that is invoked in the context of
    a callback thread.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998
    Savas Guven (savasg) 27-Nov-2000

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.
    
    Savas Guven (savasg) 27-Nov-2000
    Changed into a C++ class with synchronization abstracted

--*/

#include "stdafx.h"

//
// STATIC MEMBER INITIALIZATION
//
const PCHAR _CNhSock::ObjectNamep = "CNhSock";


#if DEBUG
ULONG NhpReadCount = 0;
#endif


ULONG UnusedBytesTransferred;

typedef struct _NH_CLOSE_BUFFER {
    HANDLE Event OPTIONAL;
    HANDLE WaitHandle OPTIONAL;
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine;
} NH_CLOSE_BUFFER, *PNH_CLOSE_BUFFER;

typedef struct _NH_CONNECT_BUFFER {
    HANDLE Event;
    HANDLE WaitHandle;
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL;
    BOOLEAN CloseNotificationReceived;
} NH_CONNECT_BUFFER, *PNH_CONNECT_BUFFER;









//
// CLASS MEMBER FUNCTIONS
//



_CNhSock::_CNhSock()
{
    ICQ_TRC(TM_SOCK, TL_DUMP, (" CNhSock  - Default Constructor"));    

    this->Socket = INVALID_SOCKET;

    //this->InitializeSync(NULL);
}


_CNhSock::_CNhSock(SOCKET iSocket)
{
    ICQ_TRC(TM_SOCK, TL_DUMP, (" CNhSock  - Constructor with a Socket"));    

    this->Socket = iSocket; 
}

_CNhSock::~_CNhSock()
{
    ICQ_TRC(TM_SOCK, TL_DUMP, (" CNhSock  ~ Destructor"));    

    if(this->bCleanupCalled is FALSE)
    {
        _CNhSock::ComponentCleanUpRoutine();
    }

    //
    // so whoever is the lower level should call its own 
    // component Cleanup Routine.
    // 
    this->bCleanupCalled = FALSE;
}


void
_CNhSock::ComponentCleanUpRoutine(void)
{

    ICQ_TRC(TM_SOCK, TL_DUMP, ("%s> CNhSock  - ComponentCleanUpRoutine",
        this->GetObjectName()));    

    //
    // just delete/close  the Socket
    //
    this->NhDeleteSocket();

    //
    // Set the cleanup up flag to true;
    this->bCleanupCalled = TRUE;
}


void
_CNhSock::StopSync(void)
{
    this->NhDeleteSocket();

    this->Deleted = TRUE;
}


ULONG
_CNhSock::NhAcceptStreamSocket
                        (
                            PCOMPONENT_SYNC Component,
                            class _CNhSock * AcceptedSocketp OPTIONAL,
                            PNH_BUFFER Bufferp,
                            PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
                            PVOID Context,
                            PVOID Context2
                        )

/*++

Routine Description:

    This routine is invoked to accept an incoming connection-request
    on a listening stream socket using 'AcceptEx'. The I/O system invokes
    the provided 'CompletionRoutine' upon completion of the read.

    It is the completion-routine's responsibility to use 'setsockopt' to
    set the SO_UPDATE_ACCEPT_CONTEXT option on the accepted socket before
    the accepted socket can be used with Winsock2 routines.

    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    ListeningSocket - the endpoint that is listening for connection-requests

    AcceptedSocket - the endpoint to be assigned a connection-request,
        or NULL to create a new endpoint

    Bufferp - the buffer to be used for asynchronous completion
        or NULL to acquire a new buffer

    AcceptCompletionRoutine - the routine to be invoked upon completion

    Context - the context to be associated with the accept-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the accept-completion routine
    will be invoked.
    Conversely, a failure code is a guarantee that the routine will not
    be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    class _CNhSock * LocalSocketp = NULL; 

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> CNhSock::ACCEPT"));

    // Reference the external Component
    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }
    
    // Reference the internal ReferenceCount -
    this->ReferenceSync();

    if (!Bufferp) 
    {
        Bufferp = LocalBufferp = NhAcquireBuffer();

        if (!Bufferp) 
        {
            //NhTrace(TRACE_FLAG_SOCKET, "error allocating buffer for accept");
            if (Component) 
            { 
                DEREF_COMPONENT( Component, eRefIoAccept ); 
            }
            this->DereferenceSync();

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // IF there is no AccetedSocket OR
    // even if there is  it should be something else than INVALID_SOCKET
    if (!(AcceptedSocketp != NULL && AcceptedSocketp->Socket != INVALID_SOCKET)) 
    {
        LocalSocketp = new _CNhSock(INVALID_SOCKET);

        if(LocalSocketp != NULL)
        {
            Error = LocalSocketp->NhCreateStreamSocket(INADDR_NONE,
                                                        0,
                                                        NULL);
        }
        
        if (Error || (LocalSocketp is NULL) )
        {
            if (LocalBufferp) 
            { 
                NhReleaseBuffer(LocalBufferp); 
            }

            if(LocalSocketp) 
            { 
                delete LocalSocketp; 
            }

            // Dereference the external one if necessary.
            if (Component) 
            { 
                DEREF_COMPONENT( Component, eRefIoAccept ); 
            }

            // dereference this component
            this->DereferenceSync();

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        LocalSocketp = AcceptedSocketp;
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socketp           = LocalSocketp;
    Bufferp->CompletionRoutine = AcceptCompletionRoutine;
    Bufferp->Context           = Context;
    Bufferp->Context2          = Context2;

    SOCKET thisSock = this->Socket;
    SOCKET localSock = LocalSocketp->Socket;

    if (AcceptEx(thisSock,
                 localSock,
                 Bufferp->Buffer,
                 0,
                 sizeof(SOCKADDR_IN) + 16,
                 sizeof(SOCKADDR_IN) + 16,
                 &UnusedBytesTransferred,
                 &Bufferp->Overlapped)) 
    {
        Error = NO_ERROR;
    } 
    else 
    {
        if ((Error = WSAGetLastError()) is ERROR_IO_PENDING) 
        {
            Error = NO_ERROR;
        } 
        else if (Error) 
        {
            ErrorOut();

            if (LocalSocketp) { DEREF_COMPONENT( LocalSocketp, eRefIoAccept); }
            
            if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
            
            if (Component) { DEREF_COMPONENT( Component, eRefIoAccept ); }

            this->DereferenceSync();
        }
    }

    

    return Error;

} // NhAcceptStreamSocket


ULONG
_CNhSock::NhConnectStreamSocket(
                                PCOMPONENT_SYNC Component,
                                ULONG Address,
                                USHORT Port,
                                PNH_BUFFER Bufferp OPTIONAL,
                                PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
                                PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL,
                                PVOID Context,
                                PVOID Context2
                               )

/*++

Routine Description:

    This routine is invoked to establish a connection using a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

    Since Windows Sockets does not deliver connect-notifications to
    I/O completion ports, we need to make some special arrangements in order
    to notify the caller's completion routine the way we do for send-requests
    and receive-requests. Specifically, we create an event-handle and
    request connect-notification on it by calling 'WSAEventSelect'.
    We then register a wait on the event-handle, specifying a private
    completion routine. (See 'NhpConnectOrCloseCallbackRoutine'.)
    When this completion routine runs, it extracts the status code of the
    connection-attempt using 'WSAEnumNetworkEvents'. It then passes the status
    along with the usual parameters to the caller's completion routine.

    The caller may optionally receive notification when the remote endpoint
    closes the socket after a successful connection. We use the same
    'WSAEventSelect' mechanism to detect that condition and invoke the
    caller's notification routine.

    N.B. The buffer supplied to this routine may not be released by either
    the connect-completion routine or the close-notification routine.
    (See 'NhpConnectOrCloseCallbackRoutine' for more information.)

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket with which to establish a connection

    Address - the IP address of the remote endpoint

    Port - the port number of the remote endpoint

    Bufferp - optionally supplies the buffer to be used to hold context
        during the connection-attempt

    ConnectCompletionRoutine - a routine to be invoked upon completion 
        of the connect-attempt

    CloseNotificationRoutine - optionally specifies a routine to be invoked
        upon notification of the resulting socket's closure by the remote
        endpoint

    Context - passed to the 'ConnectCompletionRoutine' and
        'CloseNotificationRoutine'

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code

    A success code is a guarantee that both the connect-completion routine
    and the close-notification routine, if any, will be invoked.
    Conversely, a failure code is a guarantee that the neither routine will
    be invoked.

--*/

{
    PNH_CONNECT_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhConnectStreamSocket"));

    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component,
                                      ERROR_CAN_NOT_COMPLETE);
    }

    this->ReferenceSync();

    if (!Bufferp) 
    {
        Bufferp = LocalBufferp = NhAcquireBuffer();

        if (!Bufferp) 
        {
            ICQ_TRC(TM_SOCK, TL_ERROR, ("Can't Allocate MEMory"));

            if (Component) { DEREF_COMPONENT(Component, eRefIoConnect ); }
            
            this->DereferenceSync();

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socketp = this;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = ConnectCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->ConnectAddress.sin_family = AF_INET;
    Bufferp->ConnectAddress.sin_addr.s_addr = Address;
    Bufferp->ConnectAddress.sin_port = Port;

    Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    Contextp->CloseNotificationReceived = FALSE;
    Contextp->CloseNotificationRoutine = CloseNotificationRoutine;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!Contextp->Event || !RegisterWaitForSingleObject(&Contextp->WaitHandle,
                                                         Contextp->Event,
                                                         _CNhSock::NhpConnectOrCloseCallbackRoutine,
                                                         Bufferp,
                                                         INFINITE,
                                                         WT_EXECUTEINIOTHREAD)) 
    {
        ICQ_TRC(TM_SOCK, TL_ERROR, ("Can't register for no event for Object"));

        Error = GetLastError();
    } 
    else 
    {
        ULONG EventsSelected = FD_CONNECT;

        if (CloseNotificationRoutine) { EventsSelected |= FD_CLOSE; }

        Error = WSAEventSelect(this->Socket,
                               Contextp->Event,
                               EventsSelected);

        if (Error is SOCKET_ERROR) 
        {
            Error = WSAGetLastError();
        } 
        else 
        {
            Error = WSAConnect(this->Socket,
                               (PSOCKADDR)&Bufferp->ConnectAddress,
                               sizeof(Bufferp->ConnectAddress),
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        }
    }

    if (Error is SOCKET_ERROR &&
        (Error = WSAGetLastError()) is WSAEWOULDBLOCK) 
    {
        Error = NO_ERROR;
    } 
    else if (Error) 
    {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }

        if (Contextp->Event) { CloseHandle(Contextp->Event); }

        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }

        if (Component) { DEREF_COMPONENT( Component, eRefIoConnect ); }

        this->DereferenceSync();
    }

    return Error;

} // NhConnectStreamSocket


ULONG
_CNhSock::NhCreateDatagramSocket(
    ULONG Address,
    USHORT Port,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is called to initialize a datagram socket.

Arguments:

    Address - the IP address to which the socket should be bound (network-order)

    Port - the UDP port to which the socket should be bound (network-order)

    Socketp - receives the created socket

Return Value:

    ULONG - Win32/Winsock2 error code

--*/

{
    ULONG Error;
    ULONG Option;
    ULONG OutputBufferLength;
    //SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> Create DATAGRAM Socket"));

    do {

        //
        // Create a new socket
        //
    
        Socket = WSASocket(AF_INET, 
                           SOCK_DGRAM,
                           IPPROTO_UDP,
                           NULL,
                           0,
                           WSA_FLAG_OVERLAPPED);

        if (Socket is INVALID_SOCKET) 
        {
            Error = WSAGetLastError();

            ICQ_TRC(TM_SOCK, TL_ERROR, 
                    ("CreateDGram socket: !! error creating socket: %u",
                     Error));
            
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //
        BindIoCompletionCallback((HANDLE)Socket,
                                 _CNhSock::NhpIoCompletionRoutine,
                                 0);

        //
        // Attempt to enable endpoint-reuse on the socket
        //
        Option = 1;
        Error = setsockopt(this->Socket,
                           SOL_SOCKET,
                           SO_REUSEADDR,
                           (PCHAR)&Option,
                           sizeof(Option));

        //
        // Attempt to enable broadcasting on the socket
        //

        Option = 1;
        Error = setsockopt(this->Socket,
                           SOL_SOCKET,
                           SO_BROADCAST,
                           (PCHAR)&Option,
                           sizeof(Option));

        //
        // Limit broadcasts to the outgoing network
        // (the default is to send broadcasts on all interfaces).
        //

        Option = 1;
        WSAIoctl(this->Socket,
                 SIO_LIMIT_BROADCASTS,
                 &Option,
                 sizeof(Option),
                 NULL,
                 0,
                 &OutputBufferLength,
                 NULL,
                 NULL);

        //
        // Bind the socket
        //

        SocketAddress.sin_family      = AF_INET;
        SocketAddress.sin_port        = Port;
        SocketAddress.sin_addr.s_addr = Address;

        Error = bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));

        if (Error is SOCKET_ERROR) 
        {
            Error = WSAGetLastError();

            ICQ_TRC(TM_SOCK, TL_ERROR, ("Binding error %u", Error));
            
            break;
        }

        //
        // Save the socket and return
        //
        if(Socketp) *Socketp = Socket;

        return NO_ERROR;

    } while (FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }

    return Error;
} // NhCreateDatagramSocket


ULONG
_CNhSock::NhCreateStreamSocket(
    ULONG Address OPTIONAL,
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is invoked to create and initialize a stream socket.
    The socket will also be bound to a local IP address and port,
    unless none is specified.

Arguments:

    Address - the local IP address to which the new socket should be bound,
        or INADDR_ANY to allow the system to leave the IP address unspecified,
        or INADDR_NONE if the socket should not be bound at all.

    Port - the port number to which the new socket should be bound,
        or 0 if to allow the system to select a port number.

    Socketp - receives initialized socket

Return Value:

    ULONG - Win32/Winsock2 status code.

--*/

{
    ULONG Error;
    ULONG Option;
    
    SOCKADDR_IN SocketAddress;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhCreateStreamSocket"));

    do {

        //
        // Create a new stream socket.
        //

        this->Socket = WSASocket(AF_INET, 
                                 SOCK_STREAM,
                                 IPPROTO_TCP,
                                 NULL,
                                 0,
                                 WSA_FLAG_OVERLAPPED);

        if (this->Socket is INVALID_SOCKET) 
        {
            Error = WSAGetLastError();

            ICQ_TRC(TM_SOCK, TL_ERROR, ("Error %u creating socket", Error));

            ErrorOut();

            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        BindIoCompletionCallback((HANDLE)this->Socket,
                                 _CNhSock::NhpIoCompletionRoutine,
                                 0);

        //
        // Disable send and receive buffering in AFD,
        // since we will be operating asynchronously with a receive-buffer
        // (almost) always outstanding, and since in any case we want
        // TCP/IP's flow-control to limit the sender's sending rate properly.
        //

        Option = 0;
        setsockopt(this->Socket, 
                   SOL_SOCKET, 
                   SO_SNDBUF,
                   (PCHAR)&Option,
                   sizeof(Option));

        Option = 0;
        setsockopt(this->Socket,
                   SOL_SOCKET,
                   SO_SNDBUF,
                   (PCHAR)&Option,
                   sizeof(Option));

        //
        // If the caller has requested that the socket be bound by specifying
        // a local IP address, bind the socket now.
        //

        if (Address != INADDR_NONE) 
        {
            SocketAddress.sin_family      = AF_INET;
            SocketAddress.sin_port        = Port;
            SocketAddress.sin_addr.s_addr = Address;

            Error = bind(this->Socket, 
                         (PSOCKADDR)&SocketAddress,
                         sizeof(SocketAddress));

            if (Error is SOCKET_ERROR) 
            {
                Error = WSAGetLastError();

                ICQ_TRC(TM_SOCK, TL_ERROR, 
                        ("binding error %u ", Error));

                ErrorOut();

                break;
            }
        }

        //
        // Store the new socket in the caller's output-parameter, and return.
        //
        if(Socketp)
        *Socketp = this->Socket;

#if _DEBUG
        ULONG ip;
        USHORT port;

        this->NhQueryLocalEndpointSocket(&ip, &port);

        ICQ_TRC(TM_SOCK, TL_DUMP, 
            (" NhCreateStreamSocket Local IP %s, port %hu succesfull", 
            INET_NTOA(ip), htons(port)));
#endif
        return NO_ERROR;

    } while(FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }

    return Error;
} // NhCreateStreamSocket



VOID
_CNhSock::NhDeleteSocket(
    SOCKET eSocket
    )

/*++

Routine Description:

    This routine releases network resources for a socket.

Arguments:

    Socket - the socket to be deleted

Return Value:

    none.

--*/

{
    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhDeleteSocket"));

    if (eSocket != INVALID_SOCKET) 
    { 
        closesocket(eSocket); 
    }

} // NhDeleteSocket





ULONG
_CNhSock::NhNotifyOnCloseStreamSocket(
    PCOMPONENT_SYNC Component,
    //SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to request notification of a socket's closure.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the notification routine runs.

Arguments:

    Component - the component to be referenced for the notification routine

    Socket - the endpoint for which close-notification is requested

    Bufferp - the buffer to be used to hold context-informatio for the request,
        or NULL to acquire a new buffer.

    CloseNotificationRoutine - the routine to be invoked upon closure of the
        socket

    Context - the context to be associated with the notification-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the notification routine will be invoked.
    Conversely, a failure code is a guarantee that the notification routine
    will not be invoked.

--*/

{
    PNH_CLOSE_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhNotifyOnCloseStreamSocket"));

    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    this->ReferenceSync();

    if (!Bufferp) 
    {
        Bufferp = LocalBufferp = NhAcquireBuffer();

        if (!Bufferp) 
        {
            if (Component) { DEREF_COMPONENT( Component, eRefIoClose ); }
            
            this->DereferenceSync();

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socketp = this;
    Bufferp->CompletionRoutine = NULL;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;

    Contextp = (PNH_CLOSE_BUFFER)Bufferp->Buffer;
    Contextp->CloseNotificationRoutine = CloseNotificationRoutine;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            _CNhSock::NhpCloseNotificationCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) 
    {
        Error = GetLastError();
    } 
    else 
    {
        Error = WSAEventSelect(Socket, Contextp->Event, FD_CLOSE);

        if (Error is SOCKET_ERROR) { Error = WSAGetLastError(); }
    }

    if (Error) 
    {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }

        if (Contextp->Event) { CloseHandle(Contextp->Event); }

        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }

        if (Component) { DEREF_COMPONENT( Component, eRefIoClose ); }
        
        this->DereferenceSync();
    }

    return Error;

} // NhNotifyOnCloseStreamSocket




VOID
_CNhSock::NhQueryAcceptEndpoints(
                                PUCHAR AcceptBuffer,
                                PULONG LocalAddress OPTIONAL,
                                PUSHORT LocalPort OPTIONAL,
                                PULONG RemoteAddress OPTIONAL,
                                PUSHORT RemotePort OPTIONAL
                                )
{
    PSOCKADDR_IN LocalSockAddr;
    ULONG LocalLength = sizeof(LocalSockAddr);
    PSOCKADDR_IN RemoteSockAddr;
    ULONG RemoteLength = sizeof(RemoteSockAddr);

    ICQ_TRC(TM_SOCK, TL_TRACE, (">NhQueryAcceptEndpoints"));

    GetAcceptExSockaddrs(AcceptBuffer,
                         0,
                         sizeof(SOCKADDR_IN) + 16,
                         sizeof(SOCKADDR_IN) + 16,
                         (PSOCKADDR*)&LocalSockAddr,
                         reinterpret_cast<LPINT>(&LocalLength),
                         (PSOCKADDR*)&RemoteSockAddr,
                         (LPINT)&RemoteLength);

    if (LocalAddress) { *LocalAddress = LocalSockAddr->sin_addr.s_addr; }

    if (LocalPort) { *LocalPort = LocalSockAddr->sin_port; }

    if (RemoteAddress) { *RemoteAddress = RemoteSockAddr->sin_addr.s_addr; }

    if (RemotePort) { *RemotePort = RemoteSockAddr->sin_port; }

} // NhQueryAcceptEndpoints


ULONG
_CNhSock::NhQueryAddressSocket(
    //SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to retrieve the IP address associated with
    a socket.

Arguments:

    Socket - the socket to be queried

Return Value:

    ULONG - the IP address retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("NhQueryAddressSocket"));

    AddressLength = sizeof(Address);

    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);

    return Address.sin_addr.s_addr;
} // NhQueryAddressSocket


ULONG
_CNhSock::NhQueryLocalEndpointSocket(
    //SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;

    Length = sizeof(SockAddr);

    ICQ_TRC(TM_SOCK, TL_TRACE, ("NhQueryLocalEndpointSocket"));

    if (getsockname(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) is SOCKET_ERROR) 
    {
        return WSAGetLastError();
    }

    if (Address) { *Address = SockAddr.sin_addr.s_addr; }

    if (Port) { *Port = SockAddr.sin_port; }

    return NO_ERROR;
} // NhQueryEndpointSocket


USHORT
_CNhSock::NhQueryPortSocket()

/*++

Routine Description:

    This routine retrieves the port number to which a socket is bound.

Arguments:

    Socket - the socket to be queried

Return Value:

    USHORT - the port number retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhQueryPortSocket"));

    AddressLength = sizeof(Address);

    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);

    return Address.sin_port;
} // NhQueryPortSocket


ULONG
_CNhSock::NhQueryRemoteEndpointSocket(
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhQueryRemoteEndpointSocket"));

    Length = sizeof(SockAddr);

    if (getpeername(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) is SOCKET_ERROR) 
    {
        return WSAGetLastError();
    }

    if (Address) { *Address = SockAddr.sin_addr.s_addr; }

    if (Port) { *Port = SockAddr.sin_port; }

    return NO_ERROR;
} // NhQueryRemoteEndpointSocket


ULONG
_CNhSock::NhReadDatagramSocket(
                                PCOMPONENT_SYNC Component,
                                //SOCKET Socket,
                                PNH_BUFFER Bufferp,
                                PNH_COMPLETION_ROUTINE CompletionRoutine,
                                PVOID Context,
                                PVOID Context2
                                )

/*++

Routine Description:

    This routine is invoked to read a message from a datagram socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer. If no buffer is supplied,
        the resulting message is assumed to fit inside a fixed-length buffer

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    ICQ_TRC(TM_SOCK, TL_DUMP, ("> NhReadDatagramSocket"));

    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component,
                                      ERROR_CAN_NOT_COMPLETE);
    }

    this->ReferenceSync();

    if (!Bufferp) 
    {
        Bufferp = LocalBufferp = NhAcquireBuffer();

        if (!Bufferp) 
        {
            /*NhTrace(
                TRACE_FLAG_SOCKET,
                "NhReadDatagramSocket: error allocating buffer for receive"
                );*/
            if (Component) { DEREF_COMPONENT( Component, eRefIoRead ); }

            this->DereferenceSync();

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socketp = this;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->AddressLength = sizeof(Bufferp->ReadAddress);
    WsaBuf.buf = reinterpret_cast<char*>(Bufferp->Buffer);
    WsaBuf.len = NH_BUFFER_SIZE;

    Error = WSARecvFrom(Socket,
                        &WsaBuf,
                        1,
                        &UnusedBytesTransferred,
                        &Bufferp->ReceiveFlags,
                        (PSOCKADDR)&Bufferp->ReadAddress,
                        (LPINT)&Bufferp->AddressLength,
                        &Bufferp->Overlapped,
                        NULL);


    if (Error is SOCKET_ERROR &&
        (Error = WSAGetLastError()) is WSA_IO_PENDING) 
    {
        Error = NO_ERROR;
    } 
    else if (Error) 
    {
        if (Component) { DEREF_COMPONENT( Component, eRefIoRead ); }

        this->DereferenceSync();

        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }

        /*NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadDatagramSocket: error %d returned by 'WSARecvFrom'", Error
            );*/
    }

    return Error;

} // NhReadDatagramSocket


ULONG
_CNhSock::NhReadStreamSocket(
    PCOMPONENT_SYNC Component,
    //SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a stream socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer

    Length - the maximum number of bytes to be read

    Offset - the offset into the buffer at which the read should begin,
        valid only if 'Bufferp' is provided.

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhReadStreamSocket"));

    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    this->ReferenceSync();

    if (!Bufferp) 
    {
        Offset = 0;

        Bufferp = LocalBufferp = NhAcquireVariableLengthBuffer(Length);

        if (!Bufferp) 
        {
            /*NhTrace(
                TRACE_FLAG_SOCKET,
                "NhReadStreamSocket: error allocating buffer for receive"
                );*/
            if (Component) { DEREF_COMPONENT( Component, eRefIoRead ); }

            this->DereferenceSync();

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socketp           = this;
    Bufferp->ReceiveFlags      = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context           = Context;
    Bufferp->Context2          = Context2;
#if 1
    if (ReadFile((HANDLE)(Bufferp->Socketp->Socket),
                 Bufferp->Buffer + Offset,
                 Length,
                 &UnusedBytesTransferred,
                 &Bufferp->Overlapped) || 
        (Error = GetLastError()) is ERROR_IO_PENDING) 
    {
        Error = NO_ERROR;
    } 
    else 
    {
        if (Component) { DEREF_COMPONENT( Component, eRefIoRead ); }

        this->DereferenceSync();

        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }

    }

#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error = WSARecv(Socket,
                    &WsaBuf,
                    1,
                    &UnusedBytesTransferred,
                    &Bufferp->ReceiveFlags,
                    &Bufferp->Overlapped,
                    NULL);


    if (Error is SOCKET_ERROR &&
        (Error = WSAGetLastError()) is WSA_IO_PENDING) 
    {
        Error = NO_ERROR;
    } 
    else if (Error) 
    {
        if (Component) { DEREF_COMPONENT( Component, eRefIoRead); }

        this->DereferenceSync();

        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }

        /*NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadStreamSocket: error %d returned by 'WSARecv'", Error
            );*/
    }
#endif

    return Error;

} // NhReadStreamSocket


ULONG
_CNhSock::NhWriteDatagramSocket(
    PCOMPONENT_SYNC Component,
    //SOCKET Socket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp,
    ULONG Length,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a datagram socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Address - the address of the message's destination

    Port - the port of the message's destination

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    LONG AddressLength;
    ULONG Error;
    WSABUF WsaBuf;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("NhWriteDATAGRAMSocket"));

    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    this->ReferenceSync();

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socketp = this;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->WriteAddress.sin_family = AF_INET;
    Bufferp->WriteAddress.sin_addr.s_addr = Address;
    Bufferp->WriteAddress.sin_port = Port;

    AddressLength = sizeof(Bufferp->WriteAddress);

    WsaBuf.buf = reinterpret_cast<char*>(Bufferp->Buffer);
    WsaBuf.len = Length;

    Error = WSASendTo(Socket,
                      &WsaBuf,
                      1,
                      &UnusedBytesTransferred,
                      0,
                      (PSOCKADDR)&Bufferp->WriteAddress,
                      AddressLength,
                      &Bufferp->Overlapped,
                      NULL);


    if (Error is SOCKET_ERROR &&
        (Error = WSAGetLastError()) is WSA_IO_PENDING) 
    {
        Error = NO_ERROR;
    } 
    else if (Error) 
    {
        /*NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteDatagramSocket: error %d returned by 'WSASendTo'", Error
            );*/
        if (Component) { DEREF_COMPONENT( Component, eRefIoWrite ); }

        this->DereferenceSync();
    }

    return Error;

} // NhWriteDatagramSocket


ULONG
_CNhSock::NhWriteStreamSocket(
    PCOMPONENT_SYNC Component,
    //SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    Offset - the offset into the buffer at which the data to be sent begins

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    WSABUF WsaBuf;

    ICQ_TRC(TM_SOCK, TL_TRACE, ("> NhWriteStreamSocket"));

    if (Component) 
    {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    this->ReferenceSync();

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socketp = this;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (WriteFile((HANDLE)(Socket),
                  Bufferp->Buffer + Offset,
                  Length,
                  &UnusedBytesTransferred,
                  &Bufferp->Overlapped) ||
        (Error = GetLastError()) is ERROR_IO_PENDING) 
    {
        Error = NO_ERROR;
    } 
    else 
    {
        /*NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteStreamSocket: error %d returned by 'WriteFile'", Error
            );*/
        if (Component) { DEREF_COMPONENT( Component, eRefIoWrite); }

        this->DereferenceSync();
    }

#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error = WSASend(Socket,
                    &WsaBuf,
                    1,
                    &UnusedBytesTransferred,
                    0,
                    &Bufferp->Overlapped,
                    NULL);


    if (Error is SOCKET_ERROR &&
        (Error = WSAGetLastError()) is WSA_IO_PENDING) 
    {
        Error = NO_ERROR;
    } 
    else if (Error) 
    {
        /*NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteStreamSocket: error %d returned by 'WSASend'", Error
            );*/
        if (Component) { DEREF_COMPONENT( Component, eRefIoWrite ); }

        this->DereferenceSync();
    }
#endif

    return Error;

} // NhWriteStreamSocket






//
//
VOID NTAPI
_CNhSock::NhpCloseNotificationCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked upon closure of an accepted connection by the
    remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when connection-acceptance is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CLOSE_BUFFER Contextp = (PNH_CLOSE_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;

    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CLOSE', we unregister the wait since there's
    // nothing left to wait for.
    //

    Bufferp->BytesTransferred = 0;

    NetworkEvents.lNetworkEvents = 0;

    Error = WSAEnumNetworkEvents(Bufferp->Socketp->GetSock(),
                                 Contextp->Event, 
                                 &NetworkEvents);

    if (Error || !(NetworkEvents.lNetworkEvents & FD_CLOSE)) 
    {
        //
        // We couldn't determine which events occurred on the socket,
        // so call the notification routine with an error, and fall through
        // to the cleanup code below.
        //

        if (Contextp->CloseNotificationRoutine) 
        {
            Contextp->CloseNotificationRoutine(ERROR_OPERATION_ABORTED,
                                               0,
                                               Bufferp);
        }

    } 
    else 
    {
        //
        // A close occurred on the socket, so retrieve the error code,
        // invoke the close-notification routine if any, and fall through
        // to the cleanup code below.
        //

        Error = NetworkEvents.iErrorCode[FD_CLOSE_BIT];

        if (Contextp->CloseNotificationRoutine) 
        {
            Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
        }
    }

    UnregisterWait(Contextp->WaitHandle);

    CloseHandle(Contextp->Event);

    NhReleaseBuffer(Bufferp);

} // _CNhSock::NhpCloseNotificationCallbackRoutine


VOID NTAPI
_CNhSock::NhpConnectOrCloseCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked by upon completion of a connect-operation
    or upon closure of the connection by the remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when a connection-attempt is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CONNECT_BUFFER Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;

    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CONNECT', we unregister the wait if an error
    // occurred. When invoked for 'FD_CLOSE', we unregister the wait
    // since there's nothing left to wait for.
    //
    // In essence, our goal is to guarantee that whatever the success
    // or failure or sequence of events on the socket, the connect-completion
    // and close-notification routines will both be called for the socket,
    // in that order.
    //
    // N.B. Neither routine is allowed to release the connect-buffer,
    // since we may need to preserve it on behalf of the close-notification
    // routine, if any.
    //
    // N.B. We may be invoked with both the 'FD_CONNECT' and 'FD_CLOSE' bits
    // set, for instance when the socket is closed. In that case we call
    // both routines here.
    //

    Bufferp->BytesTransferred = 0;

    NetworkEvents.lNetworkEvents = 0;

    Error = WSAEnumNetworkEvents(Bufferp->Socketp->GetSock(),
                                 Contextp->Event, 
                                 &NetworkEvents);

    if (Error) 
    {

        //
        // We couldn't determine which events occurred on the socket,
        // so call the routines with errors, and fall through
        // to the cleanup code below.
        //

        if (Bufferp->CompletionRoutine) 
        {
            Bufferp->CompletionRoutine(ERROR_OPERATION_ABORTED, 0, Bufferp);
            Bufferp->CompletionRoutine = NULL;
        }
        
        if (Contextp->CloseNotificationRoutine) 
        {
            Contextp->CloseNotificationRoutine(ERROR_OPERATION_ABORTED,
                                               0,
                                               Bufferp);
        }

        Contextp->CloseNotificationReceived = TRUE;

    }
    else 
    {
        if (NetworkEvents.lNetworkEvents & FD_CONNECT) 
        {
            //
            // The connect completed, so retrieve the error code and invoke
            // the connect-completion routine. If the connect failed,
            // we may never receive close-notification (unless the bit
            // is already set) so we need to simulate close-notification
            // here so that the cleanup code below executes.
            //
    
            Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];

            if (Bufferp->CompletionRoutine) 
            {
                Bufferp->CompletionRoutine(Error, 0, Bufferp);

                Bufferp->CompletionRoutine = NULL;
            }

            if (Error && !(NetworkEvents.lNetworkEvents & FD_CLOSE)) 
            {
                if (Contextp->CloseNotificationRoutine) 
                {
                    Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
                }

                Contextp->CloseNotificationReceived = TRUE;
            }
        }

        if (NetworkEvents.lNetworkEvents & FD_CLOSE) 
        {
    
            //
            // A close occurred on the socket, so retrieve the error code,
            // invoke the close-notification routine if any, and fall through
            // to the cleanup code below.
            //
    
            Error = NetworkEvents.iErrorCode[FD_CLOSE_BIT];

            if (Contextp->CloseNotificationRoutine) 
            {
                Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
            }

            Contextp->CloseNotificationReceived = TRUE;
        }
    }

    //
    // If both the connect-completion and close-notification routines have run,
    // we are done with this wait-handle and buffer.
    //

    if (!Bufferp->CompletionRoutine && Contextp->CloseNotificationReceived) 
    {
        UnregisterWait(Contextp->WaitHandle);

        CloseHandle(Contextp->Event);

        NhReleaseBuffer(Bufferp);
    }
} // CNhSock::NhpConnectOrCloseCallbackRoutine


VOID WINAPI
_CNhSock::NhpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    )

/*++

Routine Description:

    This routine is invoked by the I/O system upon completion of an operation.

Arguments:

    ErrorCode - system-supplied error code

    BytesTransferred - system-supplied byte-count

    Overlapped - caller-supplied context area

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread.

--*/

{
    PNH_BUFFER Bufferp = CONTAINING_RECORD(Overlapped, NH_BUFFER, Overlapped);
    //NTSTATUS status;

    Bufferp->ErrorCode = ErrorCode;

    Bufferp->BytesTransferred = BytesTransferred;

    Bufferp->CompletionRoutine(Bufferp->ErrorCode,
                               Bufferp->BytesTransferred,
                               Bufferp);

} // _CNhSock::NhpIoCompletionRoutine


VOID APIENTRY
_CNhSock::NhpIoWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to continue processing of completed I/O
    in the context of an alertably waiting thread which does not exit idly.

Arguments:

    Context - holds the buffer associated with the completed I/O operation.

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL alertable worker thread.

--*/

{
    ((PNH_BUFFER)Context)->CompletionRoutine(
        ((PNH_BUFFER)Context)->ErrorCode,
        ((PNH_BUFFER)Context)->BytesTransferred,
        ((PNH_BUFFER)Context)
        );

} // _CNhSock::NhpIoWorkerRoutine


ULONG
InterfaceForDestination(ULONG DestIp)
{
    SOCKET        UdpSocket;
    SOCKADDR_IN SockAddr;
    ULONG        Length, Error;



    SockAddr.sin_family = AF_INET;
    SockAddr.sin_port = htons(4000);
    SockAddr.sin_addr.s_addr = DestIp;


    Length = sizeof(SockAddr);

    

    if ((UdpSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP))      is INVALID_SOCKET ||
        connect(UdpSocket, (PSOCKADDR)&SockAddr, sizeof(SockAddr))  is SOCKET_ERROR   ||
        getsockname(UdpSocket, (PSOCKADDR)&SockAddr, (int*)&Length) is SOCKET_ERROR     ) 
    {
        Error = WSAGetLastError();

        //ErrorOut();

        if (Error is WSAEHOSTUNREACH) 
        {
            // Error = RasAutoDialSharedConnection();
            printf("WSAEHOSTUNREACH\n");

            if (Error != ERROR_SUCCESS) 
            {
                if (UdpSocket != INVALID_SOCKET) { closesocket(UdpSocket); }
            }
        } 
        else 
        {
            if (UdpSocket != INVALID_SOCKET) { closesocket(UdpSocket); }

        }
    }
    else 
    {
        closesocket(UdpSocket); 

        // printf("   SOCKET> Destination for %s is", INET_NTOA(DestIp));
        // printf("%s \n", INET_NTOA(SockAddr.sin_addr.s_addr));

        return SockAddr.sin_addr.s_addr;

        
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\socket.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations for socket-management.
    The routines declared here operate asynchronously on sockets
    associated with an I/O completion port. They are also integrated
    with the component-reference object, which may optionally be used
    by callers to control the number of outstanding entries into a component's
    address-space. (See 'COMPREF.H'.)

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

--*/


#ifndef _NATHLP_SOCKET_H_
#define _NATHLP_SOCKET_H_

#define INET_NTOA(x)    inet_ntoa(*(struct in_addr*)&(x))

//
// BOOLEAN
// NhIsFatalSocketError(
//     ULONG Error
//     );
//
// Determines whether a request may be reissued on a socket,
// given the error-code from the previous issuance of the request.
// This macro is arranged to branch on the most common error-codes first.
//

#define \
NhIsFatalSocketError( \
    _Error \
    ) \
    ((_Error) != ERROR_OPERATION_ABORTED && \
    ((_Error) == WSAEDISCON || \
     (_Error) == WSAECONNRESET || \
     (_Error) == WSAETIMEDOUT || \
     (_Error) == WSAENETDOWN || \
     (_Error) == WSAENOTSOCK || \
     (_Error) == WSAESHUTDOWN || \
     (_Error) == WSAECONNABORTED))


typedef class _CNhSock : public virtual GENERIC_NODE
{

    public:


        _CNhSock();

        _CNhSock(SOCKET iSocket);

        ~_CNhSock();

        void ComponentCleanUpRoutine(void);

        virtual void  StopSync(void);

        virtual PCHAR GetObjectName() { return ObjectNamep;}

        SOCKET GetSock() { return Socket;};

        VOID SetSock(SOCKET inSock) { Socket = inSock;};

        ULONG
        NhAcceptStreamSocket(
                             PCOMPONENT_SYNC Component,
                             class _CNhSock * AcceptedSocketp OPTIONAL,
                             PNH_BUFFER Bufferp OPTIONAL,
                             PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
                             PVOID Context,
                             PVOID Context2
                            );

        ULONG
        NhConnectStreamSocket(
                              PCOMPONENT_SYNC Component,
                              ULONG Address,
                              USHORT Port,
                              PNH_BUFFER Bufferp OPTIONAL,
                              PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
                              PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL,
                              PVOID Context,
                              PVOID Context2
                             );

        ULONG
        NhCreateDatagramSocket(
                               ULONG Address,
                               USHORT Port,
                               OUT SOCKET* Socketp
                              );

        ULONG
        NhCreateStreamSocket(
                             ULONG Address OPTIONAL, // may be INADDR_NONE
                             USHORT Port OPTIONAL,
                             OUT SOCKET* Socketp
                            );

#define NhDeleteDatagramSocket(s) NhDeleteSocket(s)
#define NhDeleteStreamSocket(s) NhDeleteSocket(s)

        VOID
        NhDeleteSocket(
                       SOCKET Socket
                      );

        VOID NhDeleteSocket() \
        {if (this->Socket != INVALID_SOCKET) {closesocket(this->Socket);};}

        ULONG
        NhNotifyOnCloseStreamSocket(
                                    PCOMPONENT_SYNC Component,
                                    PNH_BUFFER Bufferp OPTIONAL,
                                    PNH_COMPLETION_ROUTINE CloseNotificationRoutine,
                                    PVOID Context,
                                    PVOID Context2
                                   );

        VOID
        NhQueryAcceptEndpoints(
                               PUCHAR AcceptBuffer,
                               PULONG LocalAddress OPTIONAL,
                               PUSHORT LocalPort OPTIONAL,
                               PULONG RemoteAddress OPTIONAL,
                               PUSHORT RemotePort OPTIONAL
                              );

        ULONG
        NhQueryAddressSocket();

        ULONG
        NhQueryLocalEndpointSocket(
                                   PULONG Address OPTIONAL,
                                   PUSHORT Port OPTIONAL
                                  );

        USHORT
        NhQueryPortSocket();

        ULONG
        NhQueryRemoteEndpointSocket(
                                    PULONG Address OPTIONAL,
                                    PUSHORT Port OPTIONAL
                                   );

        ULONG
        NhReadDatagramSocket(
                             PCOMPONENT_SYNC Component,
                             PNH_BUFFER Bufferp OPTIONAL,
                             PNH_COMPLETION_ROUTINE CompletionRoutine,
                             PVOID Context,
                             PVOID Context2
                            );

        ULONG
        NhReadStreamSocket(
                           PCOMPONENT_SYNC Component,
                           PNH_BUFFER Bufferp OPTIONAL,
                           ULONG Length,
                           ULONG Offset,
                           PNH_COMPLETION_ROUTINE CompletionRoutine,
                           PVOID Context,
                           PVOID Context2
                          );

        ULONG
        NhWriteDatagramSocket(
                              PCOMPONENT_SYNC Component,
                              ULONG Address,
                              USHORT Port,
                              PNH_BUFFER Bufferp,
                              ULONG Length,
                              PNH_COMPLETION_ROUTINE CompletionRoutine,
                              PVOID Context,
                              PVOID Context2
                             );

        ULONG
        NhWriteStreamSocket(
                            PCOMPONENT_SYNC Component,
                            PNH_BUFFER Bufferp,
                            ULONG Length,
                            ULONG Offset,
                            PNH_COMPLETION_ROUTINE CompletionRoutine,
                            PVOID Context,
                            PVOID Context2
                           );


        static VOID NTAPI
        NhpConnectOrCloseCallbackRoutine(
                                         PVOID Context,
                                         BOOLEAN WaitCompleted
                                        );

        static VOID NTAPI
        NhpCloseNotificationCallbackRoutine(
                                            PVOID Context,
                                            BOOLEAN WaitCompleted
                                           );


        static VOID WINAPI
        NhpIoCompletionRoutine(
                               ULONG ErrorCode,
                               ULONG BytesTransferred,
                               LPOVERLAPPED Overlapped
                              );

        static VOID APIENTRY
        NhpIoWorkerRoutine(
                           PVOID Context
                          );

    protected:
        SOCKET  Socket;

        static const PCHAR ObjectNamep;
        
        // For Shared Sockets we should have ShareCounter

} CNhSock, *PCNhSock;


//
// Utility functions
// 
ULONG InterfaceForDestination(ULONG DestIp);



#endif // _NATHLP_SOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\nathlpp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    nathlpp.h

Abstract:

    This module contains declarations common to the user-mode components
    of home-networking.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATHLPP_H_
#define _NATHLP_NATHLPP_H_


//
// Object synchronization macros
//

#define ACQUIRE_LOCK(x)         EnterCriticalSection(&(x)->Lock)
#define RELEASE_LOCK(x)         LeaveCriticalSection(&(x)->Lock)

#define REFERENCE_OBJECT(x,deleted) \
    (deleted(x) \
        ? FALSE \
        : (InterlockedIncrement( \
            reinterpret_cast<LPLONG>(&(x)->ReferenceCount) \
            ), TRUE))
/*
#define DEREFERENCE_OBJECT(x,cleanup) \
    (InterlockedDecrement(reinterpret_cast<LPLONG>(&(x)->ReferenceCount)) \
        ? TRUE \
        : (cleanup(x), FALSE))
*/
//
// Memory management macros
//

#define NH_ALLOCATE(s)          HeapAlloc(GetProcessHeap(), 0, (s))
#define NH_FREE(p)              HeapFree(GetProcessHeap(), 0, (p))


#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_TCP        0x06


#endif // _NATHLP_NATHLPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\sync.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:



Abstract:



Author:

    Savas Guven (savasg)   27-Nov-2000

Revision History:

--*/
#include "stdafx.h"
//#include "sync.h"


#define ERROR_CREATING_SYNC_OBJECT 0x0001

//
// STATIC MEMBER INITIALIZATIONS
//
const  PCHAR COMPONENT_SYNC::ObjectNamep = "COMPONENT_SYNC";



COMPONENT_SYNC::COMPONENT_SYNC()
/*++

Routine Description:

    Deafault Constructor    
    
Arguments:

    NONE

Return Value:

    NONE

--*/
:Deleted(FALSE),
 bCleanupCalled(FALSE),
 m_ReferenceCount(1)
{
    ICQ_TRC(TM_SYNC, TL_DUMP, ("%s> COMPONENT::DeFAULT Constructor",
            this->GetObjectName()));

    this->InitializeSync();
}






COMPONENT_SYNC::~COMPONENT_SYNC()
/*++

Routine Description:

    Destructor of the COMPONEN_REFERENCE and SYNC object   
    
Arguments:

    NONE

Return Value:

    NONE

--*/
{
    ICQ_TRC(TM_SYNC, TL_DUMP, ("%s> COMPONENT::~ Destructor",
            this->GetObjectName()));

    if(this->bCleanupCalled is FALSE)
    {
        COMPONENT_SYNC::ComponentCleanUpRoutine();
    }

    this->bCleanupCalled = FALSE;
}





void
COMPONENT_SYNC::ComponentCleanUpRoutine(void)
/*++

Routine Description:

    CleanupRoutine of the SYNCHRONIZATION Object.
    Only the CRITICAL_SECTION needs to be deleted properly.    
    
    
Arguments:

    NONE

Return Value:

    NONE

--*/
{
    ICQ_TRC(TM_SYNC, TL_TRACE, ("%s> COMPONENT::ComponentCleanUpRoutine",
            this->GetObjectName()));

    DeleteSync();

    this->bCleanupCalled = TRUE;
}




void
COMPONENT_SYNC::DeleteSync( void )
/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the lastreference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/
{
    DeleteCriticalSection(&this->m_Lock);

#if COMPREF_DEBUG_TRACKING

    if ( m_RecordArray != NULL )  
        HeapFree(GetProcessHeap(), 0, m_RecordArray);

    m_RecordArray = NULL;

#endif

}




ULONG
COMPONENT_SYNC::InitializeSync(void)
/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/
{
    ICQ_TRC(TM_SYNC, TL_DUMP, ("COMPONENT - InitializeSync"));

    InitializeCriticalSection(&this->m_Lock);

    this->Deleted           = FALSE;
    this->bCleanupCalled    = FALSE;
    this->m_ReferenceCount  = 1;


#if COMPREF_DEBUG_TRACKING
    m_RecordIndex       = 0;
    m_RecordArray       = (PCOMPREF_DEBUG_RECORD_)HeapAlloc(GetProcessHeap(),
                                                            0,
                                                            sizeof(COMPREF_DEBUG_RECORD_) * _COMPREF_DEBUG_RECORD_COUNT );

    if ( m_RecordArray != NULL )
    {
        ZeroMemory(m_RecordArray,
                   sizeof(COMPREF_DEBUG_RECORD_) * _COMPREF_DEBUG_RECORD_COUNT);
    }


#endif

    return NO_ERROR;
}




BOOLEAN
COMPONENT_SYNC::ReferenceSync(void)
/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/
{
    ICQ_TRC(TM_SYNC, TL_TRACE, ("%s> COMPONENT - REFERENCE %u + 1",
                        this->GetObjectName(),
                        this->m_ReferenceCount));

    EnterCriticalSection(&this->m_Lock);

    if(this->Deleted)
    {
        LeaveCriticalSection(&this->m_Lock);

        return FALSE;
    }

    InterlockedIncrement( (LPLONG) &m_ReferenceCount) ;

    LeaveCriticalSection(&this->m_Lock);

    return TRUE;
}




 BOOLEAN
COMPONENT_SYNC::DereferenceSync( void )
/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/
{
     ICQ_TRC(TM_SYNC, TL_TRACE, ("%s>  DEREFERENCE %u - 1",
                        this->GetObjectName(),
                        this->m_ReferenceCount));

    this->AcquireLock();

    if( InterlockedDecrement((LPLONG) &m_ReferenceCount) )
    {
        this->ReleaseLock();

        return FALSE;
    }

    this->ReleaseLock();

    this->ComponentCleanUpRoutine();

    this->Deleted = TRUE;

    return TRUE;
}





 //
 //
 //
inline void
COMPONENT_SYNC::AcquireLock()
{
    ICQ_TRC(TM_SYNC, TL_DUMP, ("COMPONENT - Acquire Lock"));

    EnterCriticalSection(&m_Lock);
}

inline void
COMPONENT_SYNC::ReleaseLock()
{
    ICQ_TRC(TM_SYNC, TL_DUMP, ("COMPONENT - Release Lock"));

    LeaveCriticalSection(&m_Lock);
}







#if 0 
void
COMPONENT_SYNC::ResetSync(void)
/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/
{
    EnterCriticalSection(&this->m_Lock);

    this->m_ReferenceCount = 1;
    this->Deleted = FALSE;

#if COMPREF_DEBUG_TRACKING

    this->RecordIndex =  0;

    ZeroMemory(this->RecordArray,
               sizeof(COMPREF_DEBUG_RECORD_) * _COMPREF_DEBUG_RECORD_COUNT);

#endif

} // Release




 BOOLEAN
COMPONENT_SYNC::ReleaseInitialSync(void)
/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/
{
    this->AcquireLock();

    if(this->Deleted)
    {
        this->ReleaseLock();

        return TRUE;
    }

    this->Deleted = TRUE;

    if(--this->m_ReferenceCount)
    {
        this->ReleaseLock();

        return FALSE;
    }

    this->ReleaseLock();

    this->ComponentCleanUpRoutine();

    return TRUE;
}

#endif 


BOOLEAN
COMPONENT_SYNC::RecordRef(
                          ULONG RefId,
                          PCHAR File,
                          ULONG Line
                         )
/*++

Routine Description:


Arguments:

    FILE - Records in which file the SYNC object is accessed
    LINE - which Line in the FILE
    TYPE - and the TYPE of operation desired

Return Value:

    none.

--*/

{

#if COMPREF_DEBUG_TRACKING

    if ( NULL == m_RecordArray )
    {
        return FALSE;
    }

    this->AcquireLock();

    //
    // Find The first empty slot to which to add this.
    // 

    for ( int i = 0; i < _COMPREF_DEBUG_RECORD_COUNT; i++ )
    {
        if ( FALSE == m_RecordArray[i].bInUse )
        {
            m_RecordArray[i].OpCode = RefId;

            m_RecordArray[i].File   = File;

            m_RecordArray[i].Line   = Line;

            m_RecordArray[i].Type   = eReferencing;

            m_RecordArray[i].bInUse = TRUE;

            break;
        }
    }

    this->ReleaseLock();

#endif

    return TRUE;
}


BOOLEAN
COMPONENT_SYNC::RecordDeref(
                            ULONG RefId,
                            PCHAR File,
                            ULONG Line
                           )
{
    int UnusedEntryIndex = -1;

    BOOLEAN bFound = FALSE;

#if COMPREF_DEBUG_TRACKING

    if ( NULL == m_RecordArray )
    {
        return FALSE;
    }
    
    this->AcquireLock();
    
    //
    // Search for the RefId in the existing
    //

    for ( int i = 0; i < _COMPREF_DEBUG_RECORD_COUNT; i++ )
    {
        
        //
        // if you find a reference with the same OpCode / RefId delete the entry
        //
        if ( 
            ( TRUE == m_RecordArray[i].bInUse  ) && 
            ( m_RecordArray[i].OpCode == RefId )  
           )
        {
            ZeroMemory( &(m_RecordArray[i]), sizeof(COMPREF_DEBUG_RECORD_) );

            bFound = TRUE;

            break;
        }

        if ( (-1 == UnusedEntryIndex ) && (FALSE == m_RecordArray[i].bInUse) )
        {
            UnusedEntryIndex = i;
        }
    }

    //
    // if there is no REF code for this DEREF note it down
    //
    if ( (FALSE == bFound) && (0 <= UnusedEntryIndex) )
    {
        m_RecordArray[i].OpCode = RefId;

        m_RecordArray[i].File   = File;

        m_RecordArray[i].Line   = Line;

        m_RecordArray[i].Type   = eDereferencing;

        m_RecordArray[i].bInUse = TRUE;
    }

    this->ReleaseLock();

#endif 

    return TRUE;
}



BOOLEAN
COMPONENT_SYNC::ReportRefRecord()
{

#if COMPREF_DEBUG_TRACKING

    if ( NULL == m_RecordArray )
    {
        return FALSE;
    }

    //
    // scan the Ref Records and print them..
    // 
    ICQ_TRC(TM_SYNC, TL_ERROR, ("Object Name: %s Ref History :",
                                this->GetObjectName()));


    for (int i = 0; i < _COMPREF_DEBUG_RECORD_COUNT; i++)
    {
        if ( TRUE == m_RecordArray[i].bInUse )
        {
            ICQ_TRC(TM_SYNC, TL_ERROR, 
                    ("%d) OpCode (%X), File (%s), Line (%u), Type (%s)",
                     i,
                     m_RecordArray[i].OpCode,
                     m_RecordArray[i].File,
                     m_RecordArray[i].Line,
                     (eReferencing == m_RecordArray[i].Type)?"Ref":"Deref"));
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\myadapternotify.h ===
//
// MyAdapterNotify.h : Declaration of the CMyAdapterNotify
//

#pragma once



// {6E590D42-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_MyAdapterNotificationSink, 0x6e590d42, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);


/////////////////////////////////////////////////////////////////////////////
//
// CMyAdapterNotify
//
class ATL_NO_VTABLE CMyAdapterNotify : 
    public CComObjectRoot,
    public CComCoClass<CMyAdapterNotify, &CLSID_MyAdapterNotificationSink>,
    public IAdapterNotificationSink
{
public:
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CMyAdapterNotify)

BEGIN_COM_MAP(CMyAdapterNotify)
	COM_INTERFACE_ENTRY(IAdapterNotificationSink)
END_COM_MAP()


//
// IAdapterNotificationSink
//
public:
	STDMETHODIMP    AdapterAdded     (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterRemoved   (IAdapterInfo*   pAdapter);
    STDMETHODIMP    AdapterModified  (IAdapterInfo*   pAdapter);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\sync.h ===
#ifndef  _SYNC_HEADER_
#define _SYNC_HEADER_



#if COMPREF_DEBUG_TRACKING

#define _COMPREF_DEBUG_RECORD_COUNT    (1024)

enum TypeOfRefOp
{
    eReferencing,
    eDereferencing
} ;

typedef struct _COMPREF_DEBUG_RECORD_
{
    BOOLEAN     bInUse;
    ULONG       OpCode;
    PCHAR       File;
    ULONG       Line;
    TypeOfRefOp Type;

} COMPREF_DEBUG_RECORD_, *PCOMPREF_DEBUG_RECORD_;

#endif




class COMPONENT_SYNC
{
public:
	                    COMPONENT_SYNC();

	virtual             ~COMPONENT_SYNC();

	virtual void	    ComponentCleanUpRoutine(void);

	//virtual void	shouldBeDeleted();

	virtual BOOLEAN     ReferenceSync(void);

    virtual BOOLEAN     DereferenceSync(void);

	virtual void	    DeleteSync(void);

    virtual void        StopSync(void) {};

	virtual ULONG	    InitializeSync(void);


	virtual BOOLEAN     RecordRef( 
                                  ULONG RefId,
                                  PCHAR File,
                                  ULONG Line
                                 );

    virtual BOOLEAN     RecordDeref(
                                    ULONG  RefId,
                                    PCHAR  File,
                                    ULONG  Line
                                   );

    virtual BOOLEAN     ReportRefRecord();


    // virtual BOOLEAN     RecordDeref(PCHAR File, ULONG Line, UCHAR Type);

	// virtual void	    ResetSync(void);

	virtual PCHAR       GetObjectName() { return ObjectNamep;} 

	
    inline virtual void	AcquireLock();

	inline virtual void	ReleaseLock();

protected:

	static const PCHAR ObjectNamep;

	CRITICAL_SECTION 			m_Lock;

	ULONG						m_ReferenceCount;

	BOOLEAN						Deleted;

	BOOLEAN						bCleanupCalled;


#if COMPREF_DEBUG_TRACKING

	struct _COMPREF_DEBUG_RECORD_ * m_RecordArray;

	ULONG m_RecordIndex;

#endif
};

typedef COMPONENT_SYNC * PCOMPONENT_SYNC;


// +-*****************
// Macro - Enum Definitions
// +-*****************

enum REFERENCE_OPCODE 
{
    eRefInitialization = 0x00000001,
    eRefSecondLevel    = 0x00000002,
    eRefIoRead         = 0x00000004,
    eRefIoWrite        = 0x00000008,
    eRefIoAccept       = 0x00000010,
    eRefIoConnect      = 0x00000020,
    eRefIoSharing      = 0x00000040,
    eRefIoClose        = 0x00000080,
    eRefList           = 0x00000100
};

//
//
//
#define REFERENCE_COMPONENT_OR_RETURN(c, retcode) \
	ICQ_TRC(TM_SYNC, TL_TRACE, ("%s %ld", __FILE__, __LINE__));\
    if (!(c)->ReferenceSync()) { return (retcode); }
    


//
//
//
#define DEREF_COMPONENT(_X_, _Y_)		                   \
ICQ_TRC(TM_SYNC, TL_TRACE, ("%s %ld", __FILE__, __LINE__));\
(_X_)->RecordDeref( (_Y_), __FILE__, __LINE__);              \
if((_X_)->DereferenceSync())	                           \
{								                           \
	delete (_X_);				                           \
	(_X_) = NULL;				                           \
}								 

//
//
//
#define REF_COMPONENT(_X_, _Y_ )                               \
ICQ_TRC(TM_SYNC, TL_TRACE, ("REF %s %ld", __FILE__, __LINE__));\
(_X_)->RecordRef( (_Y_), __FILE__, __LINE__ );                 \
(_X_)->ReferenceSync()
	


//
// This Macro is used to Stop or delete Asynchronous elements like
// - Sockets which are waiting on Reads or Writes and/or Accepts
// - Stops Timers or Waiting Objects if any.
//
#define STOP_COMPONENT(_X_) \
ICQ_TRC(TM_SYNC, TL_TRACE, ("%s %ld", __FILE__, __LINE__)); \
(_X_)->StopSync()

#define DELETE_COMPONENT(_X_)                               \
ICQ_TRC(TM_SYNC, TL_TRACE, ("%s %ld", __FILE__, __LINE__)); \
(_X_)->StopSync();                                          \
(_X_)->RecordRef( eRefInitialization, __FILE__, __LINE__ ); \
if( (_X_)->DereferenceSync() )                              \
{                                                           \
    delete (_X_);                                           \
    (_X_) = NULL;                                           \
}                                                           


#if COMPREF_DEBUG_TRACKING

//
//
//
//#define REF_COMPONENT_OR_RETURN(c,retcode) \
//    if (!c->RecordSync( __FILE__, __LINE__, ComprefAcquireRecord)) { return retcode; }

//
//
//
// #define DEREF_COMPONENT(c) \
//    c->RecordSync( __FILE__, __LINE__, ComprefReleaseRecord)

#else

#endif //if COMPREF





#endif // _SYNC_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "ALG ICQ proxy"
#define VER_INTERNALNAME_STR            "ALG_ICQ.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\util.h ===
#ifndef __UTIL_H
#define __UTIL_H

void ErrorOut( void );

#define ALG_IFC_BOUNDARY(_Type) \
    ((_Type) & eALG_BOUNDARY)

#define ALG_IFC_PRIVATE(_Type)  \
    ((_Type) & eALG_PRIVATE)

#define ALG_IFC_FW(_Type)       \
    ((_Type) & eALG_FIREWALLED)


#define NEW_OBJECT( _X_, _Y_ )                          \
__try                                                   \
{                                                       \
    (_X_) = new (_Y_);                                  \
}                                                       \
__except( EXCEPTION_EXECUTE_HANDLER )                   \
{                                                       \
    DbgPrintX("ALLOCATION ERROR Line %s, File %s",  __LINE__, __LINE__);  \
    delete _X_;                                         \
    _X_ = NULL;                                         \
}

typedef struct _TIMER_CONTEXT {
    HANDLE  TimerQueueHandle;
    HANDLE  TimerHandle;
    ULONG   uContext;
} TIMER_CONTEXT, *PTIMER_CONTEXT;


typedef enum _TIMER_DELETION
{
    eTIMER_DELETION_ASYNC = 0x00,
    eTIMER_DELETION_SYNC  = 0x01
} TIMER_DELETION;

#define TIMER_DELETION_ASYNC NULL
#define TIMER_DELETION_SYNC  

PTIMER_CONTEXT
AllocateAndSetTimer(
                    ULONG uContext,
                    ULONG timeOut,
                    WAITORTIMERCALLBACK Callbackp
                   );

extern HANDLE g_TimerQueueHandle;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ALG_TEST.rc
//
#define IDS_PROJNAME                    100
#define IDR_MYALG                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_icq\util.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    

Abstract:

    

Author:

    Savas Guven (savasg)   27-Nov-2000

Revision History:

--*/
#include "stdafx.h"
#include "util.h"



//
// GLOBALS
//

HANDLE g_TimerQueueHandle = NULL;



void
ErrorOut(void)
{
		LPVOID lpMsgBuf;
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL,
					  GetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
					  (LPTSTR) &lpMsgBuf,
					  0,
					  NULL );

		// Process any inserts in lpMsgBuf.
		// ...
		// Display the string.
		MessageBox( NULL, 
					(LPCTSTR)lpMsgBuf, 
					_T("Error"), 
					MB_OK | MB_ICONINFORMATION );

		// Free the buffer.
		LocalFree( lpMsgBuf );
}



PTIMER_CONTEXT
AllocateAndSetTimer(
                    ULONG uContext,
                    ULONG timeOut,
                    WAITORTIMERCALLBACK Callbackp
                   )
{
    ULONG         Error         = NO_ERROR;
    PTIMER_CONTEXT TimerContextp = NULL;

    TimerContextp = (PTIMER_CONTEXT) NH_ALLOCATE(sizeof(TIMER_CONTEXT));

    if(TimerContextp is NULL)
    {
        return NULL;
    }

    ZeroMemory(TimerContextp, sizeof(TIMER_CONTEXT));

    TimerContextp->TimerQueueHandle = g_TimerQueueHandle;
    TimerContextp->uContext         = uContext;

    Error = CreateTimerQueueTimer(&TimerContextp->TimerHandle,
                                  g_TimerQueueHandle,
                                  Callbackp,
                                  TimerContextp,
                                  timeOut * 1000,
                                  0,
                                  WT_EXECUTEDEFAULT);

    if(Error is 0)
    {
        NH_FREE(TimerContextp);

        return NULL;
    }

    return TimerContextp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\myalg.h ===
//
// MyALG.h : Declaration of the CMyALG
//
#pragma once


// {6E590D41-F6BC-4dad-AC21-7DC40D304059}
DEFINE_GUID(CLSID_MyALG, 0x6e590d41, 0xf6bc, 0x4dad, 0xac, 0x21, 0x7d, 0xc4, 0xd, 0x30, 0x40, 0x59);

/////////////////////////////////////////////////////////////////////////////
//
// CMyALG
//
class ATL_NO_VTABLE CMyALG : 
    public CComObjectRoot,
    public CComCoClass<CMyALG, &CLSID_MyALG>,
    public IApplicationGateway
{

public:
    DECLARE_REGISTRY(CMyALG, TEXT("ALG_TEST.MyALG.1"), TEXT("ALG_TEST.MyALG"), -1, THREADFLAGS_BOTH)
    DECLARE_NOT_AGGREGATABLE(CMyALG)

BEGIN_COM_MAP(CMyALG)
	COM_INTERFACE_ENTRY(IApplicationGateway) 
END_COM_MAP()

//
// IApplicationGateway
//
public:
	STDMETHODIMP Initialize(
        IApplicationGatewayServices* pIAlgServices
        );

	STDMETHODIMP Stop(
        void
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\myadapternotify.cpp ===
//
// MyAdapterNotify.cpp : Implementation of CMyALG
//
// Call back class for notification of adapter added, removed or modified
//

#include "PreComp.h"

#include "MyAdapterNotify.h"


/////////////////////////////////////////////////////////////////////////////
//
// CMyAdapterNotify
//


//
// This function will be call when a new adapter is made active
//
STDMETHODIMP 
CMyAdapterNotify::AdapterAdded(
	IAdapterInfo*   pAdapter
	)
{
    MYTRACE_ENTER("CMyAdapterNotify::AdapterAdded");

    ULONG   ulIndex;
    HRESULT hr = pAdapter->GetAdapterIndex(&ulIndex);
    
    if ( SUCCEEDED(hr) )
    {
        MYTRACE("Adapter Index %d", ulIndex);
    }
    else
    {
        MYTRACE_ERROR("On GetAdapterIndex", hr);
    }


    ALG_ADAPTER_TYPE    eType;
    hr = pAdapter->GetAdapterType(&eType);

    if ( SUCCEEDED(hr) )
    {
        MYTRACE("Adapter Type %d", eType);
    }
    else
    {
        MYTRACE_ERROR("On GetAdapterType", hr);
    }

    return S_OK;
}


//
// This function will be call when a adapter is remove and/or disable
//
STDMETHODIMP 
CMyAdapterNotify::AdapterRemoved(
	IAdapterInfo*   pAdapter
	)
{
    MYTRACE_ENTER("CMyAdapterNotify::AdapterRemoved");

    ULONG   ulIndex;
    HRESULT hr = pAdapter->GetAdapterIndex(&ulIndex);

    if ( SUCCEEDED(hr) )
    {
        MYTRACE("Adapter Index %d", ulIndex);
    }
    else
    {
        MYTRACE_ERROR("On GetAdapterIndex", hr);
    }

    return S_OK;
}


//
// This function will be call when a adapter is modified
//
STDMETHODIMP 
CMyAdapterNotify::AdapterModified(
	IAdapterInfo*   pAdapter
	)
{
    MYTRACE_ENTER("CMyAdapterNotify::AdapterModified");



    ULONG nIndex;

    HRESULT hr = pAdapter->GetAdapterIndex(
        &nIndex
        );
    MYTRACE("For Adapter INDEX %d", nIndex);





    ULONG   nAddressCount;
    ULONG*  pnAddresses;

    hr = pAdapter->GetAdapterAddresses(
        &nAddressCount,
        &pnAddresses
        );

    if ( SUCCEEDED(hr) )
    {
        for ( ULONG nI=0; nI < nAddressCount; nI++ )
        {
            MYTRACE("Address %s", MYTRACE_IP(pnAddresses[nI]));
        }
    }
    else
    {
        MYTRACE_ERROR("Could not get the addresss", hr);
    }

    CoTaskMemFree(pnAddresses);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\alg_test.cpp ===
//
// Copyright (C) 2001 Microsoft Corp
//
// ALG_TEST.cpp : Implementation of DLL Exports.
//
// JPDup@Microsoft.com
//


#include "PreComp.h"

#include <initguid.h>
#include "MyALG.h"
#include "MyAdapterNotify.h"



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MyALG,                       CMyALG)
    OBJECT_ENTRY(CLSID_MyAdapterNotificationSink,   CMyAdapterNotify)
END_OBJECT_MAP()






MYTRACE_ENABLE;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MYTRACE_START(L"ALG_TEST");
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MYTRACE_STOP;
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object from the Object Map
    return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\myalg.cpp ===
//////////////////////////////////////////////////////////////////////////////
// 
// MyALG.cpp : Implementation of CMyALG
//
// Main interface called by ALG.exe it wil call Initialise and stop when the ALG.exe is unloading
// or this ALG Module is disable/removed
//

#include "PreComp.h"

#include "MyALG.h"
#include "MyAdapterNotify.h"


#include <winsock.h>
#pragma comment(lib, "wsock32.lib")








/////////////////////////////////////////////////////////////////////////////
//
// CMyALG
//





#define PORTNUM                 1313
#define HOSTNAME                "localhost"                     // Server name string 
#define MAX_PENDING_CONNECTS    4                               // Maximum length of the queue of pending connections

IApplicationGatewayServices*    g_pIAlgServices=NULL;           // Cache main interface of ALG
IAdapterNotificationSink*       g_pIAdapterNotificationSink=NULL;
IPrimaryControlChannel*         g_pIControlChannel=NULL;

USHORT                          g_usPort= 0;                    // Test Reserve some ports
DWORD                           g_dwAdapterSinkCookie=0;

DWORD                           g_dwThreadID_Listen;
SOCKET                          g_ClientSock = INVALID_SOCKET;  // Socket for communicating 

//
// Forward declaration
//
DWORD WINAPI ThreadListenRedirect(LPVOID lpThreadParameter);





//
//
// Main entry point for ALG Modules
//
//
STDMETHODIMP 
CMyALG::Initialize(
	IApplicationGatewayServices* pIAlgServices
	)
{
    MYTRACE_ENTER("CMyALG::Initialize");
    
    USES_CONVERSION;
	HRESULT hr;


    ULONG   nAddress;

    //
    // Keep the service alive (this is optional since the ALG Manager is loading us it will always be around)
    //
	g_pIAlgServices = pIAlgServices;
    g_pIAlgServices->AddRef();

 
#if 1
    //
    // Requesting Notification of adapter ADD/REMOVE/MODIFY
    // when an adapter gets Added Removed or is modified this ALG will receive a notification
    //
    {
        MYTRACE_ENTER("###TEST### - STARTADAPTERNOTIFICATIONS");

        CComObject<CMyAdapterNotify>*   pIAdapterNotify;
        CComObject<CMyAdapterNotify>::CreateInstance(&pIAdapterNotify);
        hr = pIAdapterNotify->QueryInterface(IID_IAdapterNotificationSink, (void**)&g_pIAdapterNotificationSink);

        if ( FAILED(hr) )
            MYTRACE_ERROR("No QI on IID_IAdapterNotificationSink", hr);

        hr = g_pIAlgServices->StartAdapterNotifications(g_pIAdapterNotificationSink, &g_dwAdapterSinkCookie);

    }
#endif


#if 1
    //
    // Reserver some ports, these port will be garantied to be free and available for this ALG
    //
    {
        MYTRACE_ENTER("###TEST### - RESERVE PORT");
	    hr = g_pIAlgServices->ReservePort(4, &g_usPort);

        if ( SUCCEEDED(hr) )
            MYTRACE("ALG_TEST->ReservePorts (%d) to (%d)", ntohs(g_usPort), ntohs(g_usPort)+3);
        else
        {
            MYTRACE_ERROR("Could no reserver port", hr);
            return E_FAIL;
        }
    }
#endif



#if 1
    //
    // Redirect traffic of a well unknown port here we invented port 5000 as a port of interest
    //
    {
        MYTRACE_ENTER("###TEST### - CREATE PRIMARY CONTROL CHANNEL");

        

	    hr = g_pIAlgServices->CreatePrimaryControlChannel(
                eALG_TCP,
                htons(5000),
                eALG_DESTINATION_CAPTURE,
                true,
                inet_addr("127.0.0.1"), 
                htons(PORTNUM), 
                &g_pIControlChannel
			    );

	    if ( FAILED(hr) )
	    {
            MYTRACE_ERROR("FAILED the CreatePrimaryControlChannel", hr);
	    }
    }
#endif


#if 1
    //
    // SECONDARY CHANNEL
    //
    {
        MYTRACE_ENTER("###TEST### - CREATE SECONDARY CHANNAL");

        ISecondaryControlChannel*    mySecondaryDataChannel=NULL;
        hr = g_pIAlgServices->CreateSecondaryControlChannel(
            eALG_UDP,

            inet_addr("192.168.0.2"), 
            htons(99),

            inet_addr("157.157.157.2"),
            htons(5001),

            inet_addr("205.157.157.1"),
            htons(5002),

            inet_addr("127.0.0.1"),
            htons(666),

            eALG_INBOUND,
	        false,
            &mySecondaryDataChannel
            );

        if ( FAILED(hr) )
        {
            MYTRACE_ERROR("Could not create SecondaryDataChannel", hr);
        }
        else
        {
            hr = mySecondaryDataChannel->Cancel();
            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("Failed to cancel", hr);
            }

            mySecondaryDataChannel->Release();
        }

    }
#endif


    //
    // Listen on another thread for redirected packet
    //

    

	HANDLE hThread = CreateThread(
		NULL,						// SecurityDesc
		0,							// initial stack size
		ThreadListenRedirect,	    // thread function
		NULL,						// thread argument
		0,							// creation option
		&g_dwThreadID_Listen	    // thread identifier
		);


    if ( !hThread )
        MYTRACE_ERROR("Could not start listenning thread", 0);





    
#if 1
    //
    // TEST GetBestSourceAddressForDestinationAddress
    // should return the best IP Address to use 
    //
    {
        MYTRACE_ENTER("###TEST### - GET BEST SOURCE ADDRESS FOR DESTINATION ADDRESS");

        ULONG   nAddressDest = inet_addr("157.157.157.2");

        hr = g_pIAlgServices->GetBestSourceAddressForDestinationAddress( 
                nAddressDest,   // IP Address of destination
                false,          // if Dialup is involved
                &nAddress       // the Address to use
                );

	    if ( FAILED(hr) )
	    {
		    MYTRACE_ERROR("FAILED the CreatePrimaryControlChannel", hr);
	    }

        MYTRACE( "Best address is %s", MYTRACE_IP(nAddress) );
    }
#endif



#if 1
    //
    // D A T  A   C H A N N E L 
    //
    {
        MYTRACE_ENTER("###TEST### - CREATE DATA CHANNEL");

        IDataChannel*    myDataChannel=NULL;
        hr = g_pIAlgServices->CreateDataChannel(
            eALG_TCP,
            nAddress,
            g_usPort,
            inet_addr("157.157.157.2"),
            htons(5001),
            inet_addr("157.157.157.1"),
            htons(5001),
            eALG_INBOUND,
            eALG_NONE,
	        false,
            &myDataChannel
            );

        if ( FAILED(hr) )
        {
            MYTRACE_ERROR("Could not create DataChannel", hr);
        }
        else
        {
            hr = myDataChannel->Cancel();
            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("Failed to cancel", hr);
            }

            myDataChannel->Release();
        }

    }
#endif


    //
    //
    // TEST - PrepareProxyConnection
    //
    //

#if 1
    {
        MYTRACE_ENTER("###TEST### - PREPARE PROXY CONNECTION");

        IPendingProxyConnection*    myPendingProxyConnection=NULL;

        hr = g_pIAlgServices->PrepareProxyConnection(
            eALG_TCP,                   // Protocal
            nAddress,                   // Source Address
            g_usPort,                   // Source Port
            inet_addr("172.31.77.13"),  // Public Destination Address
            htons(21),                  // Public Destination port
            FALSE,
            &myPendingProxyConnection
            );


        if ( FAILED(hr) )
        {
            MYTRACE_ERROR("Could not create shadow redirect", hr);
        }
        else
        {
            hr = myPendingProxyConnection->Cancel();
            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("Failed to cancel", hr);
            }

            myPendingProxyConnection->Release();
        }
    }
#endif



#if 1
    //
    //
    // TEST - PrepareSourceModifiedProxyConnection
    //
    //
    {
        MYTRACE_ENTER("###TEST### - PREPARE SOURCE MODIFIED PROXY CONNECTION");

        IPendingProxyConnection*    myPendingProxyConnection2=NULL;

        hr = g_pIAlgServices->PrepareSourceModifiedProxyConnection(
            eALG_TCP,
            nAddress,
            htons(1212),
            inet_addr("172.31.77.13"),
            htons(21),
            inet_addr("172.31.77.14"),
            htons(22),
            &myPendingProxyConnection2
            );


        if ( FAILED(hr) )
        {
            MYTRACE_ERROR("Could not create shadow redirect", hr);
        }
        else
        {
            hr = myPendingProxyConnection2->Cancel();
            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("Failed to cancel", hr);
            }

            myPendingProxyConnection2->Release();
        }
    }
#endif

    return S_OK;
}



//
//
//
STDMETHODIMP 
CMyALG::Stop()
{
    MYTRACE_ENTER("CMyALG::Stop(void)");

    closesocket(g_ClientSock);
    g_ClientSock = INVALID_SOCKET;

    if ( g_dwAdapterSinkCookie )
    {
        HRESULT hr = g_pIAlgServices->StopAdapterNotifications(g_dwAdapterSinkCookie);
        g_pIAdapterNotificationSink->Release();
    }


    if ( g_pIControlChannel )
    {
        g_pIControlChannel->Cancel();
    }

    MYTRACE("ReleaseReservedPort %d", g_usPort);
    g_pIAlgServices->ReleaseReservedPort(g_usPort, 4);

    MYTRACE("About To Release");
//    g_pIAlgServices->Release();

    MYTRACE("Return");
	return S_OK;
}



//
//
// 
HRESULT
WaitForData()
{
    MYTRACE_ENTER("WaitForData()");
    //
    // Prepare winsock 	
    //
    
    int index = 0;						// Integer index
	SOCKET WinSocket = INVALID_SOCKET;  // Window socket
    
										// between the server and client
	SOCKADDR_IN local_sin;              // Local socket address

	WSADATA WSAData;                    // Contains details of the Winsock implementation

	// Initialize Winsock.
	if ( WSAStartup (MAKEWORD(1,1), &WSAData) != 0 ) 
	{
		MYTRACE_ERROR("WSAStartup failed.", WSAGetLastError ());
	}

	// Create a TCP/IP socket, WinSocket.
	if ((WinSocket = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
	{
		MYTRACE_ERROR("Allocating socket failed", WSAGetLastError());
		return E_FAIL;
	}


	// Fill out the local socket's address information.
	local_sin.sin_family        = AF_INET;
	local_sin.sin_port          = htons(PORTNUM); //g_usPort;  
	local_sin.sin_addr.s_addr   = inet_addr("127.0.0.1");


	// Associate the local address with WinSocket.
	if ( bind(WinSocket, (struct sockaddr *) &local_sin, sizeof (local_sin)) == SOCKET_ERROR ) 
	{
		MYTRACE_ERROR("Binding socket failed.", WSAGetLastError ());
		closesocket (WinSocket);
		return E_FAIL;
	}


	// Establish a socket to listen for incoming connections.
	if ( listen(WinSocket, MAX_PENDING_CONNECTS) == SOCKET_ERROR ) 
	{
		MYTRACE_ERROR("Listening to the client failed.", WSAGetLastError ());
		closesocket (WinSocket);
		return E_FAIL;
	}

    // Accept an incoming connection attempt on WinSocket.
    SOCKADDR_IN accept_sin;				// Receives the address of the 
										// connecting entity
	int accept_sin_len;                 // Length of accept_sin
	accept_sin_len = sizeof (accept_sin);

    MYTRACE("*** Accept is waiting for a connection");


	g_ClientSock = accept(
        WinSocket, 
        (struct sockaddr *) &accept_sin, 
        (int *) &accept_sin_len
        );

	// Stop listening for connections from clients.
	closesocket (WinSocket);

        {
            MYTRACE ("Getting original address");
            //
            ULONG   ulOriginalDestinationAddress;
            USHORT  usOriginalDestinationPort;


            IAdapterInfo* pAdapterInfo;

            HRESULT hr = g_pIControlChannel->GetOriginalDestinationInformation(
                accept_sin.sin_addr.S_un.S_addr, 
                accept_sin.sin_port, 
                &ulOriginalDestinationAddress, 
                &usOriginalDestinationPort, 
	            &pAdapterInfo
                );

            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("GetOriginalDestinationInformation did not work", hr);
            }
            else
            {
                MYTRACE("Original Address %s:%d", MYTRACE_IP(ulOriginalDestinationAddress), ntohs(usOriginalDestinationPort));

                ULONG nIndex;
                pAdapterInfo->GetAdapterIndex(&nIndex);

                ALG_ADAPTER_TYPE eType;
                pAdapterInfo->GetAdapterType(&eType);

                MYTRACE("AdapterIndex   %d", nIndex);
                MYTRACE("AdapterType    %d", eType);
            
            }
        }



	if ( g_ClientSock == INVALID_SOCKET) 
	{
		MYTRACE_ERROR("Accepting connection with client failed. Error: %d", WSAGetLastError ());
		return E_FAIL;
	}

    MYTRACE("**** AFTER Listen on port %d", g_usPort);

    TCHAR   cData;

    int iReturn;

	for (;;)
	{
		// Receive data from the client.
		iReturn = recv(
			g_ClientSock, 
			(char*)&cData, 
			sizeof(cData), 
			0);


		// Check if there is any data received. If there is, display it.
		if (iReturn == SOCKET_ERROR)
		{
			MYTRACE("Received failed. Error: %d", WSAGetLastError ());
			return E_FAIL;
		}
		else if (iReturn == 0)
		{
			MYTRACE("Finished receiving data");
            break;
		}
		else
		{
            MYTRACE("%c", cData);
		}
    } 

    closesocket(g_ClientSock);



    //
    // Enumerate The Adapters
    //
    IEnumAdapterInfo* pAdapters = NULL;
   
    HRESULT hr = g_pIAlgServices->EnumerateAdapters(&pAdapters);

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Call EnumerateAdapters did not worked", hr);
    }
    else
        pAdapters->Release();



    return S_OK;
}


//
//
//
DWORD WINAPI 
ThreadListenRedirect(LPVOID lpThreadParameter)
{
    MYTRACE_ENTER("ThreadListenRedirect()");

    while ( WaitForData() == S_OK );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\precomp.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0510
#endif
#define _ATL_APARTMENT_THREADED


//#define ATL_TRACE_CATEGORY(0xFFFFFFFF)
#define   ATL_TRACE_LEVEL 4


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "resource.h"

#include "ALG.h"
#include "MyTrace.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\alg_test\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "ALG Unit Test"
#define VER_INTERNALNAME_STR            "ALG_TEST.DLL"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\adapterinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CAdapterInfo
//
// AdapterInfo.cpp : Implementation of CAdapterInfo
//

#include "PreComp.h"
#include "AdapterInfo.h"



//
//
//
STDMETHODIMP 
CAdapterInfo::GetAdapterIndex(
    ULONG*  pulAdapterIndex
    )
{
	*pulAdapterIndex = m_nAdapterIndex;

	return S_OK;
}


//
//
//
STDMETHODIMP 
CAdapterInfo::GetAdapterType(
    ALG_ADAPTER_TYPE*   pAdapterType
    )
{
	*pAdapterType = (ALG_ADAPTER_TYPE )m_eType;

	return S_OK;
}



//
//
//
STDMETHODIMP 
CAdapterInfo::GetAdapterAddresses(
    ULONG*  pulAddressCount, 
    ULONG** prgAddresses
    )
{
	*pulAddressCount = m_nAddressCount;

    *prgAddresses = (ULONG*)CoTaskMemAlloc(m_nAddressCount*sizeof(ULONG));

    if ( *prgAddresses == NULL )
        return ERROR_OUTOFMEMORY;

    memcpy(*prgAddresses,  m_anAddress, m_nAddressCount*sizeof(ULONG));

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\algcontroller.h ===
// AlgController.h : Declaration of the CAlgController

#pragma once

#include "resource.h"       // main symbols


#include "ApplicationGatewayServices.h"

#include "CollectionAdapters.h"
#include "CollectionAlgModules.h"



/////////////////////////////////////////////////////////////////////////////
// CAlgController
class ATL_NO_VTABLE CAlgController : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAlgController, &CLSID_AlgController>,
    public IAlgController
{

//
// Constructors & Destructor
//
public:

    CAlgController()
    { 
        MYTRACE_ENTER_NOSHOWEXIT("CAlgController()");
        HRESULT hr;

        m_pINat         = NULL;
        m_pIAlgServices = NULL;
    }

    ~CAlgController()
    {
        MYTRACE_ENTER_NOSHOWEXIT("~CAlgController()");
    }


//
// ATL COM helper macros
//

DECLARE_REGISTRY_RESOURCEID(IDR_ALGCONTROLLER)
DECLARE_NOT_AGGREGATABLE(CAlgController)


BEGIN_COM_MAP(CAlgController)
    COM_INTERFACE_ENTRY(IAlgController)
END_COM_MAP()


//
// IAlgController - COM Interface exposed methods
//
public:


    STDMETHODIMP    Start(
        IN  INat*   pINat
        );
    
    STDMETHODIMP    Stop();
    
    STDMETHODIMP    Adapter_Add(	
        IN  ULONG   nCookie,
        IN  short   Type
        );
    
    STDMETHODIMP    Adapter_Remove(
        IN ULONG    nCookie
        );
    
    STDMETHODIMP    Adapter_Modify(
        IN  ULONG   nCookie
        );
    
    STDMETHODIMP    Adapter_Bind(
        IN  ULONG   nCookie,
        IN  ULONG   nAdapterIndex,
        IN  ULONG   nAddressCount,
        IN  DWORD   anAdress[]
        );

    STDMETHODIMP    Adapter_PortMappingChanged(
        IN  ULONG   nCookie,
        IN  UCHAR   ucProtocol,
        IN  USHORT  usPort
        );
        

//
// Private internal methods
//
private:




public:

    //
    // Return the private interface to CComNAT
    //
    INat*  GetNat()
    {
        return m_pINat;
    }
    
    //
    // Load new ALG module that may have been added and unload any modules not configured anymore
    //
    void
    ConfigurationUpdated()
    {
        m_AlgModules.Refresh();
    }

    //
    //
    //
    void
    FreeResources()
    {
        //
        // Cleanup member before the scalar destruction is 
        // done on them because at that time the
        // two next intruction will have been done ant the two interface will be nuked
        //
        m_CollectionOfAdapters.RemoveAll();
        m_ControlChannelsPrimary.RemoveAll();
        m_ControlChannelsSecondary.RemoveAll();
        m_AdapterNotificationSinks.RemoveAll();


        //
        // Done with the public interface
        //
        if ( m_pIAlgServices )
        {
            m_pIAlgServices->Release();
            m_pIAlgServices = NULL;
        }

        //
        // Done with the private interface
        //
        if ( m_pINat )
        {
            m_pINat->Release();
            m_pINat = NULL;
        }

    }

//
// Properties
//
private:
    INat*                                       m_pINat;
    CCollectionAlgModules                       m_AlgModules;

    
public:

    
    IApplicationGatewayServices*                m_pIAlgServices;

    CCollectionAdapters                         m_CollectionOfAdapters;
    CCollectionAdapterNotifySinks               m_AdapterNotificationSinks;   

    CCollectionControlChannelsPrimary           m_ControlChannelsPrimary;
    CCollectionControlChannelsSecondary         m_ControlChannelsSecondary;
    
};






extern CAlgController*   g_pAlgController;    // This is a singleton created by IPNATHLP/NatALG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\algmodule.h ===
#pragma once

#include <Softpub.h>




//
// Holds information on the ALG module loaded
//
class CAlgModule
{

public:

    CAlgModule(
        LPCTSTR pszProgID,
        LPCTSTR pszFriendlyName
        )
    {
        lstrcpy(m_szID,             pszProgID);
        lstrcpy(m_szFriendlyName,   pszFriendlyName);

        m_pInterface=NULL;
    };


    ~CAlgModule()
    {
        Stop();
    }


//
// Methods
//
private:

    HRESULT
    ValidateDLL(
	    LPCTSTR pszPathAndFileNameOfDLL
	    );

public:

    HRESULT 
    Start();


    HRESULT
    Stop();

//
// Properties
//
public:

    TCHAR                   m_szID[MAX_PATH];
    TCHAR                   m_szFriendlyName[MAX_PATH];
    IApplicationGateway*    m_pInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\algcontroller.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    AlgController.cpp : Implementation of CAlgController

Abstract:

    This module contains routines for the ALG Manager module's 
    private interface to be used only by ICS see rmALG.cpp

Author:

    JPDup        10-Nov-2000

Revision History:

--*/

#include "PreComp.h"
#include "AlgController.h"






//
// Globals
//
CAlgController*      g_pAlgController=NULL;       // This is a singleton created by IPNATHLP/NatALG




//
// IPNATHLP is ready and is asking the ALG manager to do it's magic and load all the ISV ALGs
//
STDMETHODIMP 
CAlgController::Start(
    INat*   pINat
    )
{
    MYTRACE_ENTER("CAlgController::Start");


    if ( !pINat )
    {
        MYTRACE_ERROR("NULL pINat",0);
        return E_INVALIDARG;
    }

    //
    // Cache the INat interface that is given, will be used for the total life time of the ALG manager
    //
    m_pINat = pINat;
    m_pINat->AddRef();
    


    //
    // Create the one and only ALG Public interface will be passed to all ALG module that we host
    //
    HRESULT hr;

    CComObject<CApplicationGatewayServices>* pAlgServices;
    CComObject<CApplicationGatewayServices>::CreateInstance(&pAlgServices);
    hr = pAlgServices->QueryInterface(
        IID_IApplicationGatewayServices, 
        (void**)&m_pIAlgServices
        );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("CreateInstance(CApplicationGateway)", hr);
        return hr;
    }
    

    //
    // Cache the ApplicationGatewayService, other call like PrimaryControlChannel etc.. will refer to this singleton 
    //
    g_pAlgController = this;


    //
    // Load all the ALG's will return S_OK even if some ALG had problem loading
    //
    m_AlgModules.Load();

    return S_OK;

}





extern HANDLE  g_EventKeepAlive;

//
// CALL by IPNATHLP when the ICS/Firewall SharedAccess service is stoped
//
STDMETHODIMP 
CAlgController::Stop()
{
    MYTRACE_ENTER("CAlgController::Stop()")

    //
    // Release all ALG currently loaded
    //
    m_AlgModules.Unload();

    FreeResources();

    //
    // Let's stop 
    //
    MYTRACE("Next intruction will signale the g_EventKeepAlive");
    SetEvent(g_EventKeepAlive); // see ALG.cpp the WinMain is waiting on the event before exiting the process

    return S_OK;
}









//
// CComNAT will call this interface when a new adapter is reported
//
STDMETHODIMP 
CAlgController::Adapter_Add(
    IN    ULONG                nCookie,    // Internal handle to indentify the Adapter being added
    IN    short                nType
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Add")
    MYTRACE("Adapter Cookie %d Type %d", nCookie, nType);

    
#if defined(DBG) || defined(_DEBUG)

    if ( nType & eALG_PRIVATE )
        MYTRACE("eALG_PRIVATE ADAPTER");

    if ( nType & eALG_FIREWALLED )
        MYTRACE("eALG_FIREWALLED ADAPTER");

    if ( nType & eALG_BOUNDARY )
        MYTRACE("eALG_BOUNDARY ADAPTER");

#endif
    
    
    m_CollectionOfAdapters.Add(
        nCookie,
        nType
        );
    
    return S_OK;
}



//
// CComNAT will call this interface when a new adapter is Removed
//
STDMETHODIMP 
CAlgController::Adapter_Remove(
    IN    ULONG                nCookie     // Internal handle to indentify the Adapter being removed
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Remove")
    MYTRACE("Adapter nCookie %d", nCookie);
        
    m_CollectionOfAdapters.Remove(
        nCookie
        );

    return S_OK;
}




//
// CComNAT will call this interface when a new adapter is modified
//
STDMETHODIMP 
CAlgController::Adapter_Modify(
    IN    ULONG                nCookie     // Internal handle to indentify the Adapter being Modified
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Modify")
    MYTRACE("Adapter nCookie %d", nCookie);

    return S_OK;
}



 
//
// CComNAT will call this interface when a new adapter is modified
//
STDMETHODIMP 
CAlgController::Adapter_Bind(
    IN  ULONG    nCookie,                // Internal handle to indentify the Adapter being Bind
    IN  ULONG    nAdapterIndex,
    IN  ULONG    nAddressCount,
    IN  DWORD    anAddresses[]
    )
{
    MYTRACE_ENTER("CAlgController::Adapter_Bind")
    MYTRACE("Adapter nCookie(%d)=Index(%d), AddressCount %d Address[0] %s", nCookie, nAdapterIndex, nAddressCount, MYTRACE_IP(anAddresses[0]));

    m_CollectionOfAdapters.SetAddresses(
        nCookie, 
        nAdapterIndex, 
        nAddressCount, 
        anAddresses
        );

    return S_OK;
}

//
// CComNat will call this method when a port mapping is modified
//
STDMETHODIMP
CAlgController::Adapter_PortMappingChanged(
    IN  ULONG   nCookie,
    IN  UCHAR   ucProtocol,
    IN  USHORT  usPort
   )
{
    MYTRACE_ENTER("CAlgController::Adapter_PortMappingChanged");
    MYTRACE("Adapter Cookie %d, Protocol %d, Port %d", nCookie, ucProtocol, usPort);

    HRESULT hr =
        m_ControlChannelsPrimary.AdapterPortMappingChanged(
            nCookie,
            ucProtocol,
            usPort
            );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\adapterinfo.h ===
// AdapterInfo.h : Declaration of the CAdapterInfo

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
//
// CAdapterInfo
//
class ATL_NO_VTABLE CAdapterInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAdapterInfo, &CLSID_AdapterInfo>,
	public IAdapterInfo
{
public:
	CAdapterInfo()
	{
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterInfo::NEW");
        m_nCookie       = 0;
        m_nAdapterIndex = 0;
        m_eType         = (ALG_ADAPTER_TYPE)0;
        m_nAddressCount = 0;
        m_bNotified     = false;    // Flag to see if a newly added adapter notified the user CallBack notification
                                    // This is used to only notify once the ALG plugin when the IP Address have been assign see CollectionAdapters.cpp
	}

	~CAdapterInfo()
	{
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterInfo::DELETE");
	}


 

DECLARE_REGISTRY_RESOURCEID(IDR_ADAPTERINFO)
DECLARE_NOT_AGGREGATABLE(CAdapterInfo)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAdapterInfo)
	COM_INTERFACE_ENTRY(IAdapterInfo)
END_COM_MAP()

//
// IAdapterInfo
//
public:
	STDMETHODIMP    GetAdapterAddresses(
        OUT ULONG*  pulAddressCount, 
        OUT ULONG** prgAddresses
        );

	STDMETHODIMP    GetAdapterType(
        OUT ALG_ADAPTER_TYPE* pAdapterType
        );

	STDMETHODIMP    GetAdapterIndex(
        OUT ULONG* pulIndex
        );

//
// Properties
//
public:
    ULONG               m_nCookie;
    ULONG               m_nAdapterIndex;
    ALG_ADAPTER_TYPE    m_eType;

    short               m_nAddressCount;
    DWORD               m_anAddress[65];
    DWORD               m_aMask[65];
    
    bool                m_bNotified;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\alg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// ALG.cpp : Implementation of WinMain
//
//
// JPDup  - 2000.12.15
//      
//      

#include "PreComp.h"

#include "AlgController.h"
#include "ApplicationGatewayServices.h"
#include "PrimaryControlChannel.h"
#include "SecondaryControlChannel.h"
#include "PendingProxyConnection.h"
#include "DataChannel.h"
#include "AdapterInfo.h"
#include "PersistentDataChannel.h"


#include <initguid.h>

#include "..\ALG_FTP\MyALG.h"



//
// GLOBALS
//
MYTRACE_ENABLE;                     // Define Tracing globals see MyTrace.h

CComModule              _Module;

HINSTANCE               g_hInstance=NULL;
HANDLE                  g_EventKeepAlive=NULL;
HANDLE                  g_EventRegUpdates=NULL;
SERVICE_STATUS          g_MyServiceStatus; 
SERVICE_STATUS_HANDLE   g_MyServiceStatusHandle; 



BEGIN_OBJECT_MAP(ObjectMap)

    OBJECT_ENTRY(CLSID_AlgController,               CAlgController)
    OBJECT_ENTRY(CLSID_ApplicationGatewayServices,  CApplicationGatewayServices)
    OBJECT_ENTRY(CLSID_PrimaryControlChannel,       CPrimaryControlChannel)
    OBJECT_ENTRY(CLSID_SecondaryControlChannel,     CSecondaryControlChannel)
    OBJECT_ENTRY(CLSID_PendingProxyConnection,      CPendingProxyConnection)
    OBJECT_ENTRY(CLSID_DataChannel,                 CDataChannel)
    OBJECT_ENTRY(CLSID_AdapterInfo,                 CAdapterInfo)
    OBJECT_ENTRY(CLSID_PersistentDataChannel,       CPersistentDataChannel)

    OBJECT_ENTRY(CLSID_AlgFTP,                      CAlgFTP)
//    OBJECT_ENTRY(CLSID_AlgICQ,                      CAlgICQ)

END_OBJECT_MAP()





 


//
///
//
VOID 
MyServiceCtrlHandler(
    DWORD Opcode
    ) 
{ 
    MYTRACE_ENTER("ALG.exe::MyServiceCtrlHandler");

    DWORD status; 
 
    switch(Opcode) 
    { 
        case SERVICE_CONTROL_PAUSE: 
            MYTRACE("SERVICE_CONTROL_PAUSE");
            // Do whatever it takes to pause here. 
            g_MyServiceStatus.dwCurrentState = SERVICE_PAUSED; 
            break; 
 
        case SERVICE_CONTROL_CONTINUE: 
            MYTRACE("SERVICE_CONTROL_CONTINUE");
            // Do whatever it takes to continue here. 
            g_MyServiceStatus.dwCurrentState = SERVICE_RUNNING; 
            break; 
 
        case SERVICE_CONTROL_STOP: 
            MYTRACE("SERVICE_CONTROL_STOP");
            // Do whatever it takes to stop here. 
            g_MyServiceStatus.dwWin32ExitCode = 0; 
            g_MyServiceStatus.dwCurrentState  = SERVICE_STOPPED; 
            g_MyServiceStatus.dwCheckPoint    = 0; 
            g_MyServiceStatus.dwWaitHint      = 0; 
 
            if (!SetServiceStatus(g_MyServiceStatusHandle, &g_MyServiceStatus))
            { 
                MYTRACE_ERROR("SetServiceStatus ",0);
            } 
 
            MYTRACE("Leaving MyService"); 
            return; 
 
        case SERVICE_CONTROL_INTERROGATE: 
            MYTRACE("SERVICE_CONTROL_STOP");
            break; 
 
        default: 
            MYTRACE("Unrecognized opcode %ld", Opcode); 
    } 
 
    // Send current status. 
    if (!SetServiceStatus (g_MyServiceStatusHandle,  &g_MyServiceStatus)) 
    { 
        MYTRACE_ERROR("SetServiceStatus error ",0);
    } 
    return; 
} 




// 
// Stub initialization function. 
//
DWORD 
MyServiceInitialization(
    DWORD   argc, 
    LPTSTR* argv
    ) 
{ 
    MYTRACE_ENTER("ALG.exe::MyServiceInitialization");

    DWORD status; 
    DWORD specificError; 
 
    g_MyServiceStatus.dwServiceType               = SERVICE_WIN32; 
    g_MyServiceStatus.dwCurrentState              = SERVICE_START_PENDING; 
    g_MyServiceStatus.dwControlsAccepted          = SERVICE_ACCEPT_STOP;// | SERVICE_ACCEPT_PAUSE_CONTINUE; 
    g_MyServiceStatus.dwWin32ExitCode             = 0; 
    g_MyServiceStatus.dwServiceSpecificExitCode   = 0; 
    g_MyServiceStatus.dwCheckPoint                = 0; 
    g_MyServiceStatus.dwWaitHint                  = 0; 
 
    g_MyServiceStatusHandle = RegisterServiceCtrlHandler(TEXT("ALG"), MyServiceCtrlHandler); 
 
    if ( g_MyServiceStatusHandle == (SERVICE_STATUS_HANDLE)0 ) 
    { 
        MYTRACE_ERROR("RegisterServiceCtrlHandler",0);
        return GetLastError();
    } 
/*
    // Handle error condition 
    if (status != NO_ERROR) 
    { 
        g_MyServiceStatus.dwCurrentState       = SERVICE_STOPPED; 
        g_MyServiceStatus.dwCheckPoint         = 0; 
        g_MyServiceStatus.dwWaitHint           = 0; 
        g_MyServiceStatus.dwWin32ExitCode      = status; 
        g_MyServiceStatus.dwServiceSpecificExitCode = specificError; 
 
        SetServiceStatus (g_MyServiceStatusHandle, &g_MyServiceStatus); 
        return; 
    } 
*/

    //
    // Initialise COM
    //
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _ASSERTE(SUCCEEDED(hr));

    _Module.Init(
        ObjectMap, 
        g_hInstance,
        &LIBID_ALGLib
        );
    

	//
	// Register the CLASS with the ROT
	//
    MYTRACE(">>>>>> RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE)");
    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);


    _ASSERTE(SUCCEEDED(hr));

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("RegisterClassObject", hr);
    }


    // Initialization complete - report running status. 
    g_MyServiceStatus.dwCurrentState       = SERVICE_RUNNING; 
    g_MyServiceStatus.dwCheckPoint         = 0; 
    g_MyServiceStatus.dwWaitHint           = 0; 
 
    if (!SetServiceStatus (g_MyServiceStatusHandle, &g_MyServiceStatus)) 
    { 
        MYTRACE_ERROR("SetServiceStatus error",0); 
        return GetLastError();
    } 

    return NO_ERROR; 
} 



//
// Since the RegNotifyChangeKeyValue is call at two place in MyServiceMain
// I created a function to clean up the code.
// 
void
SetRegNotifyEvent(
    CRegKey&    RegKeyToWatch
    )
{ 
    MYTRACE_ENTER("ALG.exe::SetRegNotifyEvent");


    //
    // Watch the registry key for a change of value.
    //
    LONG nError = RegNotifyChangeKeyValue(
        RegKeyToWatch, 
        TRUE, 
        REG_NOTIFY_CHANGE_LAST_SET, 
        g_EventRegUpdates, 
        TRUE
        );

    if ( ERROR_SUCCESS != nError )
    {
        MYTRACE_ERROR("Error calling RegNotifyChangeKeyValue", nError);
        return;
    }
}



//
// This is the entry point call by the Service Control manager
// This EXE stays loaded until the AlgController->Stop is invoke by rmALG-ICS it does that via a event
// and this is the thread that wait for that event to be signal
//
void 
MyServiceMain(
    DWORD   argc, 
    LPTSTR* argv
    ) 
{ 
    MYTRACE_ENTER("ALG.exe::MyServiceMain");

    
    //
    // This will satisfy the Service control mananager and also initialise COM
    //
    MyServiceInitialization(argc, argv);
 


    //
    // Open a key to be watch doged on
    //
    CRegKey KeyAlgISV;
    LONG nError = KeyAlgISV.Open(HKEY_LOCAL_MACHINE, REGKEY_ALG_ISV, KEY_NOTIFY);

    if (ERROR_SUCCESS != nError)
    {
        MYTRACE_ERROR("Error in opening ALG_ISV regkey", GetLastError());
        goto cleanup;
    }

    //
    // Create an events.
    //
    g_EventKeepAlive = CreateEvent(NULL, false, false, NULL);
    g_EventRegUpdates= CreateEvent(NULL, false, false, NULL);

    if ( !g_EventKeepAlive || !g_EventRegUpdates )
    {
        MYTRACE_ERROR("Error in CreateEvent", GetLastError());
        goto cleanup;
    }

    //
    // Ok no problem we set a registry notification
    //
    SetRegNotifyEvent(KeyAlgISV);


    //
    // These are the event we will wait for.
    //
    HANDLE  hArrayOfEvent[] = {g_EventKeepAlive, g_EventRegUpdates};


    //
    // Main wait loop
    //
    while ( true )
    {
        MYTRACE("");
        MYTRACE("(-(-(-(- Waiting for Shutdown or Registry update-)-)-)-)\n");

        DWORD nRet = WaitForMultipleObjects(
            sizeof(hArrayOfEvent)/sizeof(HANDLE),   // number of handles in array
            hArrayOfEvent,                          // object-handle array
            false,                                  // wait option, FALSE mean then can be signal individualy
            INFINITE                                // time-out interval
            );
            
                
        //
        // We are no longet waiting, let's see what trigger this wake up
        //

        if ( WAIT_FAILED        == nRet )   // Had a problem wainting
        {
            MYTRACE_ERROR("Main thread could not WaitForMulipleObject got a WAIT_FAILED",0);
            break;
        }
        else
        if ( WAIT_OBJECT_0 + 1  == nRet )    // g_EventRegUpdate got signaled
        {
            //
            // Some changes occured in the Registry we need to reload or disables some ALG modules
            //
            MYTRACE("");
            MYTRACE(")-)-) got signal Registry Changed (-(-(\n");

            if ( g_pAlgController )
                g_pAlgController->ConfigurationUpdated();

            SetRegNotifyEvent(KeyAlgISV);
        }
        else 
        if ( WAIT_OBJECT_0 + 0  == nRet )    // g_EventKeepAlive got signaled
        {
            //
            // Signal to terminate this process
            //
            MYTRACE("");
            MYTRACE(")-)-) got signal Shutdown (-(-(\n");
            break;
        }
    }




cleanup:

    MYTRACE("CleanUp*******************");

    //
    // We are done no COm object will be supported by ALG.exe anymore
    // the RevokeClassObjects could be done sooner Like just after the CAlgControl::Initialize is done
    // since only the IPNATHLP can call use and is consuming this only once
    // be because of the hosting of the ALG_ICQ and ALG_FTP we need o have the ROT class available 
    // even after we are initialize.
    //
    MYTRACE("<<<<< RevokeClassObjects");
    _Module.RevokeClassObjects();   

    //
    // Close the event handles.
    //
  
    if (g_EventKeepAlive)
    {
        CloseHandle(g_EventKeepAlive);
    }
    
    if (g_EventRegUpdates)
    {
        CloseHandle(g_EventRegUpdates);
    }

    Sleep(500); // Give the AlgController->Release() called by rmALG the time to cleanup

    
    //
    // We are done with COM
    //
    _Module.Term();
    CoUninitialize();


    //
    // we are all done here time to stop the Service
    //
    MYTRACE("SetServiceStatus 'SERVICE_STOPPED'");

    g_MyServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    g_MyServiceStatus.dwCheckPoint         = 0; 
    g_MyServiceStatus.dwWaitHint           = 0; 


    if (!SetServiceStatus(g_MyServiceStatusHandle, &g_MyServiceStatus)) 
    { 
        MYTRACE_ERROR("SetServiceStatus error for SERVICE_STOPPED",0); 
        return;
    } 


    return; 
} 
 





/////////////////////////////////////////////////////////////////////////////
//
// Starting point of this process
//
//
extern "C" int WINAPI 
_tWinMain(
	HINSTANCE	hInstance, 
    HINSTANCE	hPrevInstance,
	LPTSTR		pzCmdLine, 
	int			nShowCmd
	)
{
 
    MYTRACE_START(L"ALG");
    MYTRACE_ENTER("ALG.exe::WinMain");

    g_hInstance = hInstance;

    SERVICE_TABLE_ENTRY   DispatchTable[] = 
        { 
            { TEXT("ALG"), MyServiceMain }, 
            { NULL,        NULL          } 
        }; 
 
    if (!StartServiceCtrlDispatcher(DispatchTable)) 
    { 
        MYTRACE_ERROR("StartServiceCtrlDispatcher error",00);
        return 0;
    } 

    MYTRACE("Exiting");
    MYTRACE_STOP;
    
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\applicationgatewayservices.h ===
// ApplicationGatewayServices.h : Declaration of the CApplicationGatewayServices

#pragma once

#include "resource.h"       // main symbols


#include "CollectionChannels.h"
#include "CollectionAdapterNotifySinks.h"



/////////////////////////////////////////////////////////////////////////////
// CApplicationGatewayServices
class ATL_NO_VTABLE CApplicationGatewayServices : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CApplicationGatewayServices, &CLSID_ApplicationGatewayServices>,
    public IApplicationGatewayServices
{
public:

    CApplicationGatewayServices()
    {
        m_hTimerQueue = NULL;
    }

    ~CApplicationGatewayServices()
    {
        MYTRACE_ENTER_NOSHOWEXIT("~CApplicationGatewayServices()");

        if ( m_hTimerQueue )
        {

            MYTRACE("Deleting the TimerQueue");
            DeleteTimerQueueEx(
               m_hTimerQueue,          // handle to timer queue
               INVALID_HANDLE_VALUE    // handle to completion event
               );
        }
    }



    HRESULT FinalConstruct()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CApplicationGatewayServices()::FinalConstruct()");

        m_hTimerQueue = CreateTimerQueue();

        HRESULT hr = S_OK;

        if ( m_hTimerQueue == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            MYTRACE_ERROR("Could not CreateTimerQueue", hr);
        }

        return hr;
    }
    

DECLARE_REGISTRY_RESOURCEID(IDR_APPLICATIONGATEWAYSERVICES)
DECLARE_NOT_AGGREGATABLE(CApplicationGatewayServices)

DECLARE_PROTECT_FINAL_CONSTRUCT()


BEGIN_COM_MAP(CApplicationGatewayServices)
    COM_INTERFACE_ENTRY(IApplicationGatewayServices)
END_COM_MAP()

// IApplicationGatewayServices
public:

    STDMETHODIMP CreatePrimaryControlChannel (
        ALG_PROTOCOL                eProtocol, 
        USHORT                      usPortToCapture, 
        ALG_CAPTURE                 eCaptureType,    
        BOOL                        fCaptureInbound,    
        ULONG                       ulListenAddress,    
        USHORT                      usListenPort,
        IPrimaryControlChannel**    ppIControlChannel
        );


    STDMETHODIMP CreateSecondaryControlChannel(
        ALG_PROTOCOL                eProtocol,
        ULONG                       ulPrivateAddress,    
        USHORT                      usPrivatePort, 
        ULONG                       ulPublicAddress, 
        USHORT                      usPublicPort, 
        ULONG                       ulRemoteAddress, 
        USHORT                      usRemotePort, 
        ULONG                       ulListenAddress, 
        USHORT                      usListenPort, 
        ALG_DIRECTION               eDirection, 
        BOOL                        fPersistent, 
        ISecondaryControlChannel ** ppControlChannel
        );


    STDMETHODIMP GetBestSourceAddressForDestinationAddress(
        ULONG    ulDstAddress, 
        BOOL    fDemandDial, 
        ULONG *    pulBestSrcAddress
        );


    STDMETHODIMP PrepareProxyConnection(
        ALG_PROTOCOL                eProtocol, 
        ULONG                       ulSrcAddress, 
        USHORT                      usSrcPort, 
        ULONG                       ulDstAddress, 
        USHORT                      usDstPort, 
        BOOL                        fNoTimeout,
        IPendingProxyConnection **  ppPendingConnection
        );


    STDMETHODIMP PrepareSourceModifiedProxyConnection(
        ALG_PROTOCOL                eProtocol, 
        ULONG                       ulSrcAddress, 
        USHORT                      usSrcPort, 
        ULONG                       ulDstAddress, 
        USHORT                      usDstPort, 
        ULONG                       ulNewSrcAddress, 
        USHORT                      usNewSourcePort, 
        IPendingProxyConnection **  ppPendingConnection
        );


    STDMETHODIMP CreateDataChannel(
        ALG_PROTOCOL                eProtocol,
        ULONG                       ulPrivateAddress,
        USHORT                      usPrivatePort,
        ULONG                       ulPublicAddress,
        USHORT                      ulPublicPort,
        ULONG                       ulRemoteAddress,
        USHORT                      ulRemotePort,
        ALG_DIRECTION               eDirection,
        ALG_NOTIFICATION            eDesiredNotification,
        BOOL                        fNoTimeout,
        IDataChannel**              ppDataChannel
        );


    STDMETHODIMP CreatePersistentDataChannel(
        ALG_PROTOCOL                eProtocol,
        ULONG                       ulPrivateAddress,
        USHORT                      usPrivatePort,
        ULONG                       ulPublicAddress,
        USHORT                      ulPublicPort,
        ULONG                       ulRemoteAddress,
        USHORT                      ulRemotePort,
        ALG_DIRECTION               eDirection,
        IPersistentDataChannel**    ppPersistentDataChannel
        );
        


    STDMETHODIMP ReservePort(
        USHORT                      usPortCount,
        USHORT*                     pusReservedPort
        );


    STDMETHODIMP ReleaseReservedPort(
        USHORT                      usReservedPortBase,
        USHORT                      usPortCount
        );


    STDMETHODIMP EnumerateAdapters(
        IEnumAdapterInfo**          ppEnumAdapterInfo
        );
    
    STDMETHODIMP StartAdapterNotifications(
        IAdapterNotificationSink *  pSink,
        DWORD*                      pdwCookie
        );
    
    STDMETHODIMP StopAdapterNotifications(
        DWORD                       dwCookieToRemove
        );


//
// Properties
//
public:
    HANDLE  m_hTimerQueue;


//
// Methods
//
public:
    static VOID CALLBACK 
    TimerCallbackReleasePort(
        PVOID   lpParameter,      // thread data
        BOOLEAN TimerOrWaitFired  // reason
        );
};


//
// Reserved port release delay
//
#define ALG_PORT_RELEASE_DELAY      240000


//
//
//
class CTimerQueueReleasePort
{
public:
    CTimerQueueReleasePort(
        IN  HANDLE      MainTimerQueue,
        IN  USHORT      usPortBase,    // Port to release
        IN  USHORT      usPortCount
        ) :
        m_hTimerQueue(MainTimerQueue),
        m_usPortBase(usPortBase),
        m_usPortCount(usPortCount)
    {
        MYTRACE_ENTER_NOSHOWEXIT("CTimerQueueReleasePort:NEW");

        BOOL bRet = CreateTimerQueueTimer(
            &m_hTimerThis,
            m_hTimerQueue,
            CApplicationGatewayServices::TimerCallbackReleasePort,
            (PVOID)this,
            ALG_PORT_RELEASE_DELAY,
            0,
            WT_EXECUTEDEFAULT
            );


        if ( bRet == FALSE )
        {
            MYTRACE_ERROR("Could not CreateTimerQueueTimer", GetLastError());
            m_hTimerThis = NULL;
        }

    }


    ~CTimerQueueReleasePort()
    {
        if ( m_hTimerThis )
        {
            DeleteTimerQueueTimer(
                m_hTimerQueue,
                m_hTimerThis,
                NULL
                );  
        }
    }



    HANDLE  m_hTimerQueue;
    HANDLE  m_hTimerThis;
    USHORT  m_usPortBase;       // Port to release
    USHORT  m_usPortCount;      // Number of port to release
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\algmodule.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    AlgModule.cpp

Abstract:

    Iplementation of the CAlgModule class

Author:

    JP Duplessis    (jpdup)  2000.01.19

Revision History:

--*/

#include "PreComp.h"
#include "AlgModule.h"
#include "AlgController.h"




//
// Validate and Load an ALG
//
HRESULT
CAlgModule::Start()
{
    MYTRACE_ENTER("CAlgModule::Start");
    MYTRACE("---------------------------------------------------");
    MYTRACE("ALG Module:\"%S\"", m_szFriendlyName);
    MYTRACE("CLSID is  :\"%S\"", m_szID);
    MYTRACE("---------------------------------------------------");

    //
    // Extract Full Path and File Name of DLL of the ISV ALG
    //
    CLSID    guidAlgToLoad;


    HRESULT hr = CLSIDFromString(
        CComBSTR(m_szID),    // ProgID
        &guidAlgToLoad        // Pointer to the CLSID
    );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Could not convert to CLSID", hr);
        return hr;
    }


    hr = CoCreateInstance(
        guidAlgToLoad, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IApplicationGateway, 
        (void**)&m_pInterface
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Error CoCreating", hr);
        return hr;
    }



    //
    // Start the ALG plug-in
    //
    try
    {
        
        hr = m_pInterface->Initialize(g_pAlgController->m_pIAlgServices);
        
    }
    catch(...)
    {
        MYTRACE_ERROR("Exception done by this ISV ALG Module", hr);
        return hr;
    }


    return S_OK;
}



//
//
//
HRESULT
CAlgModule::Stop()
{
    MYTRACE_ENTER("CAlgModule::Stop");

    HRESULT hr=E_FAIL;

    try
    {
        if ( m_pInterface )
        {
            hr = m_pInterface->Stop(); 

            LONG nRef = m_pInterface->Release();
            MYTRACE("************ REF is NOW %d", nRef);
            m_pInterface = NULL;
        }
    }
    catch(...)
    {
        MYTRACE_ERROR("TRY/CATCH on Stop", GetLastError());
    }

    return hr;
};





//
// Verify that the DLL has a valid signature
//
HRESULT
CAlgModule::ValidateDLL(
    LPCTSTR pszPathAndFileNameOfDLL
    )
{
/*
    MYTRACE_ENTER("CAlgModule::ValidateDLL");

    USES_CONVERSION;

    HRESULT hr=0;

    try
    {

        //
        // Used by WINTRUST_DATA
        //

        WINTRUST_FILE_INFO    FileInfo;

        FileInfo.cbStruct        = sizeof(WINTRUST_FILE_INFO);
        FileInfo.pcwszFilePath  = T2W((LPTSTR)pszPathAndFileNameOfDLL); //szFilePath;
        FileInfo.hFile            = INVALID_HANDLE_VALUE;
        FileInfo.pgKnownSubject    = NULL;



    
        WINTRUST_DATA TrustData;

        memset(&TrustData,0,sizeof(TrustData));
        TrustData.cbStruct                = sizeof(WINTRUST_DATA);
        TrustData.pPolicyCallbackData    = NULL;
        TrustData.pSIPClientData        = NULL;
        TrustData.dwUIChoice            = WTD_UI_NONE; //WTD_UI_ALL; //;
        TrustData.fdwRevocationChecks    = WTD_REVOKE_NONE;
        TrustData.dwUnionChoice            = WTD_CHOICE_FILE;
        TrustData.pFile                    = &FileInfo;
        TrustData.dwStateAction            = WTD_STATEACTION_IGNORE;
        TrustData.hWVTStateData            = NULL;
        TrustData.pwszURLReference        = NULL;
        TrustData.dwProvFlags            = WTD_USE_IE4_TRUST_FLAG;
        

        //
        // Win32 Verification
        //
        GUID ActionGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;

        hr =  WinVerifyTrust(
            GetDesktopWindow(), 
            &ActionGUID, 
            &TrustData
            );

        if ( SUCCEEDED(hr) )
        {
    //        MessageBox(NULL, TEXT("Valid ALG"), TEXT("ALG.EXE"), MB_OK|MB_SERVICE_NOTIFICATION);
        }
        else
        {
            MYTRACE("******************************");
            MYTRACE(" NOT SIGNED - %ws", pszPathAndFileNameOfDLL);
            MYTRACE("******************************");
        }
    }
    catch(...)
    {
        MYTRACE_ERROR("WinTrust exception", hr);
    }

    hr = S_OK;  // For the purpose of DEV for now we will always report OK

    return hr;
*/
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\applicationgatewayservices.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ApplicationGatewayServices.cpp : Implementation of CApplicationGatewayServices

Abstract:

    This module contains routines for the ALG Manager module's 
    that expose a public api via COM.

Author:

    Jon Burstein            
    Jean-Pierre Duplessis   

    JPDup            10-Nov-2000


Revision History:


--*/


/////////////////////////////////////////////////////////////////////////////
// CApplicationGatewayServices
//
// ApplicationGatewayServices.cpp : Implementation of CApplicationGatewayServices
//

#include "PreComp.h"
#include "AlgController.h"
#include "ApplicationGatewayServices.h"
#include "PendingProxyConnection.h"
#include "DataChannel.h"
#include "PersistentDataChannel.h"
#include "EnumAdapterInfo.h" 




STDMETHODIMP 
CApplicationGatewayServices::CreatePrimaryControlChannel(
    IN  ALG_PROTOCOL                eProtocol, 
    IN  USHORT                      usPortToCapture, 
    IN  ALG_CAPTURE                 eCaptureType, 
    IN  BOOL                        fCaptureInbound, 
    IN  ULONG                       ulListenAddress, 
    IN  USHORT                      usListenPort, 
    OUT IPrimaryControlChannel**    ppIControlChannel
    )
/*++

Routine Description:


Arguments:

    eProtocol, 
    usPortToCapture, 
    eCaptureType, 
    fCaptureInbound, 
    ulListenAddress, 
    usListenPort, 
    ppIControlChannel

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreatePrimaryControlChannel")
    MYTRACE("eProtocol          %s",    eProtocol==1? "TCP" : "UDP");
    MYTRACE("usPortToCapture    %d",    ntohs(usPortToCapture));
    MYTRACE("eCaptureType       %s",    eCaptureType==eALG_SOURCE_CAPTURE ? "eALG_SOURCE_CAPTURE" : "eALG_DESTINATION_CAPTURE");
    MYTRACE("fCaptureInbound    %d",    fCaptureInbound);
    MYTRACE("ulListenAddress    %s:%d", MYTRACE_IP(ulListenAddress), ntohs(usListenPort));


    if ( !ppIControlChannel )
    {
        MYTRACE_ERROR("ppIControlChannel not supplied",0);
        return E_INVALIDARG;
    }


    if ( eProtocol != eALG_TCP && eProtocol != eALG_UDP )
    {
        MYTRACE_ERROR("Arg - eProtocol",0);
        return E_INVALIDARG;
    }


    if ( eCaptureType == eALG_SOURCE_CAPTURE && fCaptureInbound )
    {
        MYTRACE_ERROR("Can not have SOURCE CAPTURE and fCaptureInBount at same time",0);
        return E_INVALIDARG;
    }


    HRESULT hr;

    //
    // Add new ControlChannel to List of RULES
    //
    CComObject<CPrimaryControlChannel>*   pIChannel;
    hr = CComObject<CPrimaryControlChannel>::CreateInstance(&pIChannel);
    

    if ( SUCCEEDED(hr) )
    {
        pIChannel->AddRef();

        pIChannel->m_Properties.eProtocol           = eProtocol;
        pIChannel->m_Properties.eCaptureType        = eCaptureType;
        pIChannel->m_Properties.fCaptureInbound     = fCaptureInbound;
        pIChannel->m_Properties.ulListeningAddress  = ulListenAddress;
        pIChannel->m_Properties.usCapturePort       = usPortToCapture;
        pIChannel->m_Properties.usListeningPort     = usListenPort;

        hr = pIChannel->QueryInterface(IID_IPrimaryControlChannel, (void**)ppIControlChannel);

        if ( SUCCEEDED(hr) )
        {
            hr = g_pAlgController->m_ControlChannelsPrimary.Add(pIChannel);    

            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("from m_ControlChannelsPrimary.Add", hr);

                (*ppIControlChannel)->Release();
                *ppIControlChannel = NULL;
            }
        }
        else
        {
            MYTRACE_ERROR("from pIChannel->QueryInterface", hr);
        }

        pIChannel->Release();
        
    }
    else
    {
        MYTRACE_ERROR("CreateInstance(&pIChannel);", hr);
    }


    return hr;
}





STDMETHODIMP 
CApplicationGatewayServices::CreateSecondaryControlChannel(
    IN  ALG_PROTOCOL                eProtocol,                  

    IN  ULONG                       ulPrivateAddress,    
    IN  USHORT                      usPrivatePort, 

    IN  ULONG                       ulPublicAddress, 
    IN  USHORT                      usPublicPort, 

    IN  ULONG                       ulRemoteAddress, 
    IN  USHORT                      usRemotePort, 

    IN  ULONG                       ulListenAddress, 
    IN  USHORT                      usListenPort, 

    IN  ALG_DIRECTION               eDirection, 
    IN  BOOL                        fPersistent, 
    OUT ISecondaryControlChannel**  ppIControlChannel
    )
/*++

Routine Description:


Arguments:

    eProtocol,
    ulPrivateAddress,    
    usPrivatePort, 
    ulPublicAddress, 
    usPublicPort, 
    ulRemoteAddress, 
    usRemotePort, 
    ulListenAddress, 
    usListenPort, 
    eDirection, 
    fPersistent, 
    ppIControlChannel


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreateSecondaryControlChannel");

    if ( !ppIControlChannel )
    {
        MYTRACE_ERROR("ppIControlChannel not supplied",0);
        return E_INVALIDARG;
    }

    
    ULONG   ulSourceAddress=0;
    USHORT  usSourcePort=0;

    ULONG   ulDestinationAddress=0;
    USHORT  usDestinationPort=0;

    ULONG   ulNewSourceAddress=0;
    USHORT  usNewSourcePort=0;

    ULONG   ulNewDestinationAddress=0;
    USHORT  usNewDestinationPort=0;

    ULONG   nFlags=0;

    ULONG   ulRestrictAdapterIndex=0;



    if ( eALG_INBOUND == eDirection )
    {
        if ( ulPublicAddress == 0 || usPublicPort == 0 )
        {
            //
            // Madatory arguments for INBOUND
            //
            MYTRACE_ERROR("ulPublicAddress == 0 || usPublicPort == 0", E_INVALIDARG);
            return E_INVALIDARG;
        }

        //
        // All inbound cases map to a single redirect; unlike a primary control channel, there's no need to create per-adapter redirects.
        //

        if ( ulRemoteAddress==0 && usRemotePort == 0 )
        {
            //
            // Scenario #1a
            //
            // Inbound connection from unknown machine
            //
            MYTRACE("SCENARIO:eALG_INBOUND #1a");

            nFlags                   = NatRedirectFlagReceiveOnly;

            ulSourceAddress          = 0;
            usSourcePort             = 0;

            ulDestinationAddress     = ulPublicAddress;
            usDestinationPort        = usPublicPort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort == 0 )
        {
            //
            // Scenario #1b
            //
            // Inbound connection from known machine, but unknown port
            //
            MYTRACE("SCENARIO:eALG_INBOUND #1b");
            nFlags                   = NatRedirectFlagReceiveOnly|NatRedirectFlagRestrictSource;

            ulSourceAddress          = ulRemoteAddress;
            usSourcePort             = 0;

            ulDestinationAddress     = ulPublicAddress;
            usDestinationPort        = usPublicPort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;

        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort != 0 )
        {
            //
            // Scenario #1c
            //
            // Inbound connection from known machine and port
            //
            MYTRACE("SCENARIO:eALG_INBOUND #1c");

            nFlags                   = NatRedirectFlagReceiveOnly; 

            ulSourceAddress          = ulRemoteAddress;
            usSourcePort             = usRemotePort;

            ulDestinationAddress     = ulPublicAddress;
            usDestinationPort        = usPublicPort;

            ulNewSourceAddress       = ulRemoteAddress;
            usNewSourcePort          = usRemotePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;

        }
        else
            return E_INVALIDARG;
    
    }
    else
    if ( eALG_OUTBOUND == eDirection )
    {
        //
        // These cases can also be handled by a single ul
        //

        if ( ulRemoteAddress !=0 && usRemotePort != 0 && ulPrivateAddress == 0 && usPrivatePort == 0 )
        {
            //
            // Scenario #2a
            //
            // Outbound connection to known machine/port, from any private machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2a");

            nFlags                   = 0; 

            ulSourceAddress          = 0;
            usSourcePort             = 0;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = usRemotePort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            
            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort != 0 && ulPrivateAddress != 0 && usPrivatePort == 0 )
        {
            //
            // Scenario #2b
            //
            // Outbound connection to known machine/port, from a specific private machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2b");
            nFlags                   = NatRedirectFlagRestrictSource;

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = 0;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = usRemotePort;

            ulNewSourceAddress       = 0;
            usNewSourcePort          = 0;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulRemoteAddress !=0 && usRemotePort != 0 && ulPrivateAddress != 0 && usPrivatePort != 0 )
        {
            //
            // Scenario #2c
            //
            // Outbound connection to known machine/port, from a specific port on a specific private machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2c");
            nFlags                   = 0; 

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = usPrivatePort;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = usRemotePort;

            ulNewSourceAddress       = ulPrivateAddress;
            usNewSourcePort          = usPrivatePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort != 0 && ulRemoteAddress == 0 && usRemotePort == 0 )
        {
            //
            // Scenario #2d
            //
            // Outbound connection from a specific port on a specific private machine, to an unknown machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2d");
            nFlags                   = NatRedirectFlagSourceRedirect; 

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = usPrivatePort;

            ulDestinationAddress     = 0;
            usDestinationPort        = 0;

            ulNewSourceAddress       = ulPrivateAddress;
            usNewSourcePort          = usPrivatePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort != 0 && ulRemoteAddress != 0 && usRemotePort == 0 )
        {
            //
            // Scenario #2e
            //
            // Outbound connection from a specific port on a specific private machine, to a known machine
            //
            MYTRACE("SCENARIO:eALG_OUTBOUND #2e");
            nFlags                   = 0; 

            ulSourceAddress          = ulPrivateAddress;
            usSourcePort             = usPrivatePort;

            ulDestinationAddress     = ulRemoteAddress;
            usDestinationPort        = 0;

            ulNewSourceAddress       = ulPrivateAddress;
            usNewSourcePort          = usPrivatePort;

            ulNewDestinationAddress  = ulListenAddress;
            usNewDestinationPort     = usListenPort;

            ulRestrictAdapterIndex   = 0;
        }
        else
            return E_INVALIDARG;

    }
    else
    {
        //
        //
        //
        return E_INVALIDARG;
    }

    HRESULT     hr;
    HANDLE_PTR  HandleDynamicRedirect=NULL;

    if ( fPersistent )
    {
        // Dynamic
        hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
            nFlags, 
            0,                               // Adapter Index 
            (UCHAR)eProtocol,
                                         
            ulDestinationAddress,            // ULONG    DestinationAddress
            usDestinationPort,               // USHORT   DestinationPort

            ulSourceAddress,                 // ULONG    SourceAddress
            usSourcePort,                    // USHORT   SourcePort

            ulNewDestinationAddress,         // ULONG    NewDestinationAddress
            usNewDestinationPort,            // USHORT   NewDestinationPort

            ulNewSourceAddress,              // ULONG    NewSourceAddress
            usNewSourcePort,                 // USHORT   NewSourcePort

            &HandleDynamicRedirect
            );
    }
    else
    {

        // Normal
        hr = g_pAlgController->GetNat()->CreateRedirect(
            nFlags, 
            (UCHAR)eProtocol,

            ulDestinationAddress,            // ULONG    DestinationAddress
            usDestinationPort,               // USHORT   DestinationPort

            ulSourceAddress,                 // ULONG    SourceAddress
            usSourcePort,                    // USHORT   SourcePort

            ulNewDestinationAddress,         // ULONG    NewDestinationAddress
            usNewDestinationPort,            // USHORT   NewDestinationPort

            ulNewSourceAddress,              // ULONG    NewSourceAddress
            usNewSourcePort,                 // USHORT   NewSourcePort

            ulRestrictAdapterIndex,          // ULONG    RestrictAdapterIndex

            0,                               // DWORD_PTR    ThisProcessID
            NULL,                            // HANDLE_PTR   CreateEvent
            NULL                             // HANDLE_PTR   DeleteEvent
            );
    }


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("From g_pAlgController->GetNat()->CreateRedirect", hr);
        return hr;
    }


    //
    // Add new ControlChannel to List
    //
    CComObject<CSecondaryControlChannel>*   pIChannel;
    hr = CComObject<CSecondaryControlChannel>::CreateInstance(&pIChannel);

    if ( SUCCEEDED(hr) )
    {
        pIChannel->AddRef();

        pIChannel->m_Properties.eProtocol           = eProtocol;
        pIChannel->m_Properties.ulPrivateAddress    = ulPrivateAddress;
        pIChannel->m_Properties.usPrivatePort       = usPrivatePort;
        pIChannel->m_Properties.ulPublicAddress     = ulPublicAddress;
        pIChannel->m_Properties.usPublicPort        = usPublicPort;
        pIChannel->m_Properties.ulRemoteAddress     = ulRemoteAddress;
        pIChannel->m_Properties.usRemotePort        = usRemotePort;
        pIChannel->m_Properties.ulListenAddress     = ulListenAddress;
        pIChannel->m_Properties.usListenPort        = usListenPort;
        pIChannel->m_Properties.eDirection          = eDirection;
        pIChannel->m_Properties.fPersistent         = fPersistent;

        //
        // Cache calling parameters used to create the redirect we will need them to cancel the redirect
        //
        pIChannel->m_ulDestinationAddress           = ulDestinationAddress;
        pIChannel->m_usDestinationPort              = usDestinationPort;

        pIChannel->m_ulSourceAddress                = ulSourceAddress;
        pIChannel->m_usSourcePort                   = usSourcePort;

        pIChannel->m_ulNewDestinationAddress        = ulNewDestinationAddress;
        pIChannel->m_usNewDestinationPort           = usNewDestinationPort;

        pIChannel->m_ulNewSourceAddress             = ulNewSourceAddress;
        pIChannel->m_usNewSourcePort                = usNewSourcePort;

        pIChannel->m_HandleDynamicRedirect          = HandleDynamicRedirect;

        
        hr = pIChannel->QueryInterface(IID_ISecondaryControlChannel, (void**)ppIControlChannel);

        if ( SUCCEEDED(hr) )
        {
            hr = g_pAlgController->m_ControlChannelsSecondary.Add(pIChannel);    

            if ( FAILED(hr) )
            {
                MYTRACE_ERROR("Adding to list of SecondaryChannel", hr);   

               (*ppIControlChannel)->Release();
               *ppIControlChannel=NULL;

            }
        }
        else
        {
            MYTRACE_ERROR("QueryInterface(IID_ISecondaryControlChannel", hr);
        }

        pIChannel->Release();

    }
    else
    {
        MYTRACE_ERROR("From CreateInstance<CSecondaryControlChannel>", hr);
    }


    return hr;
}





STDMETHODIMP 
CApplicationGatewayServices::GetBestSourceAddressForDestinationAddress(
    IN  ULONG       ulDestinationAddress, 
    IN  BOOL        fDemandDial, 
    OUT ULONG*      pulBestSrcAddress
    )
/*++

Routine Description:

    We create a temporary UDP socket, connect the socket to the
    actual client's IP address, extract the IP address to which
    the socket is implicitly bound by the TCP/IP driver, and
    discard the socket. This leaves us with the exact IP address
    that we need to use to contact the client.

Arguments:

    ulDestinationAddress, 
    fDemandDial, 
    pulBestSrcAddress


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/

{
    MYTRACE_ENTER("CApplicationGatewayServices::GetBestSourceAddressForDestinationAddress");

    HRESULT hr = g_pAlgController->GetNat()->GetBestSourceAddressForDestinationAddress(
        ulDestinationAddress, 
        fDemandDial, 
        pulBestSrcAddress
        );

    MYTRACE("For Destination address of %s", MYTRACE_IP(ulDestinationAddress) );
    MYTRACE("the Best source address is %s", MYTRACE_IP(*pulBestSrcAddress) );

    return hr;

}




//
// 
// 
// 
// 
//

STDMETHODIMP 
CApplicationGatewayServices::PrepareProxyConnection(
    IN  ALG_PROTOCOL                eProtocol, 

    IN  ULONG                       ulSourceAddress, 
    IN  USHORT                      usSourcePort, 

    IN  ULONG                       ulDestinationAddress, 
    IN  USHORT                      usDestinationPort, 

    IN  BOOL                        fNoTimeout,
    OUT IPendingProxyConnection**   ppPendingConnection
    )
/*++

Routine Description:

    If we have a firwewall interface, possibly install a
    shadow redirect for this connection. The shadow redirect
    is necessary to prevent this connection from also being
    redirected to the proxy (setting in motion an infinite loop...)


Arguments:

    eProtocol, 

    ulSourceAddress, 
    usSourcePort, 

    ulDestinationAddress, 
    usDestinationPort, 

    fNoTimeout,
    ppPendingConnection


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::PrepareProxyConnection");

    MYTRACE("eProtocol    %s",    eProtocol==1? "TCP" : "UDP");
    MYTRACE("Source       %s:%d", MYTRACE_IP(ulSourceAddress),         ntohs(usSourcePort));
    MYTRACE("Destination  %s:%d", MYTRACE_IP(ulDestinationAddress),    ntohs(usDestinationPort));
    MYTRACE("NoTimeout    %d", fNoTimeout);

    ULONG   ulFlags = NatRedirectFlagLoopback;


    if ( !ppPendingConnection )
    {
        MYTRACE_ERROR("ppPendingConnection not supplied",0);
        return E_INVALIDARG;
    }


    if ( fNoTimeout )
    {
        MYTRACE("NoTimeout specified");

        if (  eProtocol == eALG_UDP )
        {
            ulFlags |= NatRedirectFlagNoTimeout;
        }
        else
        {
            MYTRACE("Wrong use of fNoTimeout && eProtocol != eALG_UDP");
            return E_INVALIDARG;
        }
    }


    HRESULT hr = g_pAlgController->GetNat()->CreateRedirect(
        ulFlags,
        (UCHAR)eProtocol,

        ulDestinationAddress,           // ULONG    DestinationAddress, 
        usDestinationPort,              // USHORT   DestinationPort,        

        ulSourceAddress,                // ULONG    SourceAddress, 
        usSourcePort,                   // USHORT   SourcePort,             

        ulDestinationAddress,           // ULONG    NewDestinationAddress
        usDestinationPort,              // USHORT   NewDestinationPort

        ulSourceAddress,                // ULONG    NewSourceAddress, 
        usSourcePort,                   // USHORT   NewSourcePort, 

        0,                              // ULONG    RestrictAdapterIndex

        0,                              // DWORD_PTR    ThisProcessID
        NULL,                           // HANDLE_PTR   CreateEvent
        NULL                            // HANDLE_PTR   DeleteEvent
        );

    

    if ( SUCCEEDED(hr) )
    {
        CComObject<CPendingProxyConnection>*   pIPendingProxyConnection;
        CComObject<CPendingProxyConnection>::CreateInstance(&pIPendingProxyConnection);

        pIPendingProxyConnection->m_eProtocol            = eProtocol;
        pIPendingProxyConnection->m_ulDestinationAddress = ulDestinationAddress;
        pIPendingProxyConnection->m_usDestinationPort    = usDestinationPort;

        pIPendingProxyConnection->m_ulSourceAddress      = ulSourceAddress;
        pIPendingProxyConnection->m_usSourcePort         = usSourcePort;

        pIPendingProxyConnection->m_ulNewSourceAddress   = ulSourceAddress; // Since the PendingProxyConenction is also used
        pIPendingProxyConnection->m_usNewSourcePort      = usSourcePort;    // by PrepareSourceModifiedProxyConnection we use the NewSource 
                                                                            // for the Cancel

        pIPendingProxyConnection->QueryInterface(ppPendingConnection);

    }
    else
    {
        MYTRACE_ERROR(">GetNat()->CreateRedirect failed", hr);
    }



    return hr;

}





STDMETHODIMP 
CApplicationGatewayServices::PrepareSourceModifiedProxyConnection(
    IN  ALG_PROTOCOL                eProtocol, 
    IN  ULONG                       ulSourceAddress, 
    IN  USHORT                      usSrcPort, 
    IN  ULONG                       ulDestinationAddress, 
    IN  USHORT                      usDestinationPort, 
    IN  ULONG                       ulNewSrcAddress, 
    IN  USHORT                      usNewSourcePort, 
    OUT IPendingProxyConnection**   ppPendingConnection
    )
/*++

Routine Description:

   

Arguments:

    eProtocol, 
    ulSourceAddress,   
    usSrcPort, 
    ulDestinationAddress,
    usDestinationPort, 
    ulNewSrcAddress, 
    usNewSourcePort, 
    ppPendingConnection

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::PrepareSourceModifiedProxyConnection");
    MYTRACE("Source      %s:%d", MYTRACE_IP(ulSourceAddress), ntohs(usSrcPort));
    MYTRACE("Destination %s:%d", MYTRACE_IP(ulDestinationAddress), ntohs(usDestinationPort));
    MYTRACE("NewSource   %s:%d", MYTRACE_IP(ulNewSrcAddress), ntohs(usNewSourcePort));

    if ( !ppPendingConnection )
    {
        MYTRACE_ERROR("IPendingProxyConnection** not supplied",0);
        return E_INVALIDARG;
    }



    HRESULT hr = g_pAlgController->GetNat()->CreateRedirect(
        NatRedirectFlagLoopback, 
        (UCHAR)eProtocol,

        ulDestinationAddress,           // ULONG    DestinationAddress, 
        usDestinationPort,              // USHORT   DestinationPort,       

        ulSourceAddress,                // ULONG    SourceAddress, 
        usSrcPort,                      // USHORT   SourcePort,             

        ulDestinationAddress,           // ULONG    NewDestinationAddress
        usDestinationPort,              // USHORT   NewDestinationPort

        ulNewSrcAddress,                // ULONG    NewSourceAddress, 
        usNewSourcePort,                // USHORT   NewSourcePort, 

        0,                              // ULONG    RestrictAdapterIndex

        0,                              // DWORD_PTR    ThisProcessID
        NULL,                           // HANDLE_PTR   CreateEvent
        NULL                            // HANDLE_PTR   DeleteEvent
        );


    if ( SUCCEEDED(hr) )
    {
        CComObject<CPendingProxyConnection>*   pIPendingProxyConnection;
        CComObject<CPendingProxyConnection>::CreateInstance(&pIPendingProxyConnection);

        pIPendingProxyConnection->m_eProtocol            = eProtocol;
        pIPendingProxyConnection->m_ulDestinationAddress = ulDestinationAddress;
        pIPendingProxyConnection->m_usDestinationPort    = usDestinationPort;

        pIPendingProxyConnection->m_ulSourceAddress      = ulSourceAddress;
        pIPendingProxyConnection->m_usSourcePort         = usSrcPort;

        pIPendingProxyConnection->m_ulNewSourceAddress   = ulNewSrcAddress;
        pIPendingProxyConnection->m_usNewSourcePort      = usNewSourcePort;

        hr  = pIPendingProxyConnection->QueryInterface(ppPendingConnection);

    }



    return hr;
}




HRESULT
GetRedirectParameters(
    IN  ALG_DIRECTION   eDirection,
    IN  ALG_PROTOCOL    eProtocol,

    IN  ULONG           ulPrivateAddress,
    IN  USHORT          usPrivatePort,
    IN  ULONG           ulPublicAddress,
    IN  USHORT          usPublicPort,
    IN  ULONG           ulRemoteAddress,
    IN  USHORT          usRemotePort,

    OUT ULONG&          ulFlags,
    OUT ULONG&          ulSourceAddress,
    OUT USHORT&         usSourcePort,
    OUT ULONG&          ulDestinationAddress,
    OUT USHORT&         usDestinationPort,
    OUT ULONG&          ulNewSourceAddress,
    OUT USHORT&         usNewSourcePort,
    OUT ULONG&          ulNewDestinationAddress,
    OUT USHORT&         usNewDestinationPort,

    OUT ULONG&          ulRestrictAdapterIndex
    )
/*++

Routine Description:

   The logic in these scenario are use by CreateDataChannel and CreatePersitenDataChannel

Arguments:

    eProtocol, 
    ulSourceAddress,   
    usSrcPort, 
    ulDestinationAddress,
    usDestinationPort, 
    ulNewSrcAddress, 
    usNewSourcePort, 
    ppPendingConnection

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{


    if ( eALG_INBOUND == eDirection )
    {
        if ( ulRemoteAddress == 0 && usRemotePort == 0 )
        {
            // 1a
            ulFlags = NatRedirectFlagReceiveOnly;

            ulSourceAddress = 0;
            usSourcePort = 0;
            ulDestinationAddress = ulPublicAddress;
            usDestinationPort = usPublicPort;
            ulNewSourceAddress = 0;
            usNewSourcePort = 0;
            ulNewDestinationAddress = ulPrivateAddress;
            usNewDestinationPort = usPrivatePort;
            ulRestrictAdapterIndex = 0;

        }
        else
        if ( ulRemoteAddress != 0 && usRemotePort == 0 )
        {
            // 1b
            ulFlags = NatRedirectFlagReceiveOnly|NatRedirectFlagRestrictSource;

            ulSourceAddress = ulRemoteAddress;
            usSourcePort    = 0;
            ulDestinationAddress = ulPublicAddress;
            usDestinationPort = usPublicPort;
            ulNewSourceAddress = 0;
            usNewSourcePort = 0;
            ulNewDestinationAddress = ulPrivateAddress;
            usNewDestinationPort = usPrivatePort;
            ulRestrictAdapterIndex = 0;
        }
        else
        if ( ulRemoteAddress != 0 && usRemotePort != 0 )
        {
            // 1c. 
            ulFlags = NatRedirectFlagReceiveOnly;

            ulSourceAddress = ulRemoteAddress;
            usSourcePort = usRemotePort;
            ulDestinationAddress = ulPublicAddress;
            usDestinationPort = usPublicPort;
            ulNewSourceAddress = ulRemoteAddress;
            usNewSourcePort = usRemotePort;
            ulNewDestinationAddress = ulPrivateAddress;
            usNewDestinationPort = usPrivatePort;

            ulRestrictAdapterIndex = 0;
        }
        else
            return E_INVALIDARG;
    }
    else
    if ( eALG_OUTBOUND == eDirection )
    {
        if ( ulPrivateAddress == 0 && usPrivatePort == 0 )
        {
            // 2a.
            ulFlags = 0;
            ulSourceAddress = 0;
            usSourcePort = 0;
            ulDestinationAddress = ulRemoteAddress;
            usDestinationPort = usRemotePort;
            ulNewSourceAddress = ulPublicAddress;
            usNewSourcePort = usPublicPort;
            ulNewDestinationAddress = ulRemoteAddress;
            usNewDestinationPort = usRemotePort;

            ulRestrictAdapterIndex = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort == 0 )
        {
            // 2b. 
            ulFlags = NatRedirectFlagRestrictSource;
            ulSourceAddress = ulPrivateAddress;
            usSourcePort = 0;
            ulDestinationAddress = ulRemoteAddress;
            usDestinationPort = usRemotePort;
            ulNewSourceAddress = ulPublicAddress;
            usNewSourcePort = usPublicPort;
            ulNewDestinationAddress = ulRemoteAddress;
            usNewDestinationPort = usRemotePort;

            ulRestrictAdapterIndex  = 0;
        }
        else
        if ( ulPrivateAddress != 0 && usPrivatePort != 0 )
        {
            // 2c. 
            ulFlags = 0;
            ulSourceAddress         = ulPrivateAddress;
            usSourcePort            = usPrivatePort;
            ulDestinationAddress    = ulRemoteAddress;
            usDestinationPort       = usRemotePort;
            ulNewSourceAddress      = ulPublicAddress;
            usNewSourcePort         = usPublicPort;
            ulNewDestinationAddress = ulRemoteAddress;
            usNewDestinationPort    = usRemotePort;
            
            ulRestrictAdapterIndex  = 0;
        }
        else
            return E_INVALIDARG;
    }
    else
    if ( (eALG_INBOUND | eALG_OUTBOUND) == eDirection )
    {
        ulFlags                 = 0;
        ulSourceAddress         = ulRemoteAddress;
        usSourcePort            = usRemotePort;
        ulDestinationAddress    = ulPublicAddress;
        usDestinationPort       = usPublicPort;
        ulNewSourceAddress      = ulRemoteAddress;
        usNewSourcePort         = usRemotePort;
        ulNewDestinationAddress = ulPrivateAddress;
        usNewDestinationPort    = usPrivatePort;

        ulRestrictAdapterIndex  = 0;
    }
    else
        return E_INVALIDARG;

    return S_OK;
}




STDMETHODIMP 
CApplicationGatewayServices::CreateDataChannel(
    IN  ALG_PROTOCOL          eProtocol,
    IN  ULONG                 ulPrivateAddress,
    IN  USHORT                usPrivatePort,
    IN  ULONG                 ulPublicAddress,
    IN  USHORT                usPublicPort,
    IN  ULONG                 ulRemoteAddress,
    IN  USHORT                usRemotePort,
    IN  ALG_DIRECTION         eDirection,
    IN  ALG_NOTIFICATION      eDesiredNotification,
    IN  BOOL                  fNoTimeout,
    OUT IDataChannel**        ppDataChannel
    )
/*++

Routine Description:



Arguments:

    eProtocol,  
    ulPrivateAddress,
    usPrivatePort,
    ulPublicAddress,
    usPublicPort,
    ulRemoteAddress,
    usRemotePort,
    eDirection,
    eDesiredNotification,
    fNoTimeout,
    ppDataChannel

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreateDataChannel");

    if ( !ppDataChannel )
    {
        MYTRACE_ERROR("IDataChannel** not supplied",0);
        return E_INVALIDARG;
    }

    MYTRACE("eProtocol              %d", eProtocol);
    MYTRACE("ulPrivateAddress       %s:%d", MYTRACE_IP(ulPrivateAddress), ntohs(usPrivatePort));
    MYTRACE("ulPublicAddress        %s:%d", MYTRACE_IP(ulPublicAddress), ntohs(usPublicPort));
    MYTRACE("ulRemoteAddress        %s:%d", MYTRACE_IP(ulRemoteAddress), ntohs(usRemotePort));
    MYTRACE("eDirection             %d", eDirection);
    MYTRACE("eDesiredNotification   %d", eDesiredNotification);
    MYTRACE("fNoTimeout             %d", fNoTimeout);


    ULONG   ulFlags=0;

    ULONG   ulSourceAddress=0;
    USHORT  usSourcePort=0;
    ULONG   ulDestinationAddress=0;
    USHORT  usDestinationPort=0;
    ULONG   ulNewSourceAddress=0;
    USHORT  usNewSourcePort=0;
    ULONG   ulNewDestinationAddress=0;
    USHORT  usNewDestinationPort=0;

    ULONG   ulRestrictAdapterIndex=0;


    HRESULT hr = GetRedirectParameters(
        // IN Params
        eDirection,
        eProtocol,
        ulPrivateAddress,
        usPrivatePort,
        ulPublicAddress,
        usPublicPort,
        ulRemoteAddress,
        usRemotePort,

        // OUT Params
        ulFlags,
        ulSourceAddress,
        usSourcePort,
        ulDestinationAddress,
        usDestinationPort,
        ulNewSourceAddress,
        usNewSourcePort,
        ulNewDestinationAddress,
        usNewDestinationPort,
        ulRestrictAdapterIndex
        );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Invalid parameters pass", hr);
        return E_INVALIDARG;
    }


    //
    // Check for timeout
    //
    if ( fNoTimeout && eALG_UDP == eProtocol)
        ulFlags |= NatRedirectFlagNoTimeout;

    HANDLE_PTR hCreateEvent = NULL;
    HANDLE_PTR hDeleteEvent = NULL;

    //
    // We need to events Create and Delete
    //
    if ( eALG_SESSION_CREATION & eDesiredNotification )
    {
        hCreateEvent = (HANDLE_PTR)CreateEvent(NULL, FALSE, FALSE, NULL);
        if ( !hCreateEvent )
        {
            MYTRACE_ERROR("Could not create hCreateEvent", GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        MYTRACE("NO eALG_SESSION_CREATION notification requested");
    }

    if ( eALG_SESSION_DELETION & eDesiredNotification )
    {
        hDeleteEvent = (HANDLE_PTR)CreateEvent(NULL, FALSE, FALSE, NULL);
        if ( !hDeleteEvent )
        {
            MYTRACE_ERROR("Could not create hDeleteEvent", GetLastError());
            if ( hCreateEvent )
                CloseHandle((HANDLE)hCreateEvent);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        MYTRACE("NO eALG_SESSION_DELETION notification requested");
    }

    //
    // Create a IDataChannel and cache arg to be able CancelRedirect
    //
    hr = g_pAlgController->GetNat()->CreateRedirect(
        ulFlags|NatRedirectFlagLoopback, 
        (UCHAR)eProtocol,

        ulDestinationAddress,     
        usDestinationPort,        

        ulSourceAddress,          
        usSourcePort,             

        ulNewDestinationAddress,  
        usNewDestinationPort,     

        ulNewSourceAddress,       
        usNewSourcePort,          

        ulRestrictAdapterIndex,   

        GetCurrentProcessId(),
        hCreateEvent,
        hDeleteEvent
        ); 

    
    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("GetNAT()->CreateRedirect",hr);
        if ( hCreateEvent )
            CloseHandle((HANDLE)hCreateEvent);

        if ( hDeleteEvent )
            CloseHandle((HANDLE)hDeleteEvent);
        return hr;
    }


    CComObject<CDataChannel>*   pIDataChannel;
    hr = CComObject<CDataChannel>::CreateInstance(&pIDataChannel);

    if ( SUCCEEDED(hr) )
    {
        //
        // Save these settings so to be able to return them to the user 
        // if the IDataChannel->GetProperties is called
        //
        pIDataChannel->m_Properties.eProtocol               = eProtocol;
        pIDataChannel->m_Properties.ulPrivateAddress        = ulPrivateAddress;
        pIDataChannel->m_Properties.usPrivatePort           = usPrivatePort;
        pIDataChannel->m_Properties.ulPublicAddress         = ulPublicAddress;
        pIDataChannel->m_Properties.usPublicPort            = usPublicPort;
        pIDataChannel->m_Properties.ulRemoteAddress         = ulRemoteAddress;
        pIDataChannel->m_Properties.usRemotePort            = usRemotePort;
        pIDataChannel->m_Properties.eDirection              = eDirection;
        pIDataChannel->m_Properties.eDesiredNotification    = eDesiredNotification;



        //
        // Cache these arguments in order to implement IDataChannel->Cancel
        //
        pIDataChannel->m_ulSourceAddress          = ulSourceAddress;
        pIDataChannel->m_usSourcePort             = usSourcePort;
        pIDataChannel->m_ulDestinationAddress     = ulDestinationAddress;
        pIDataChannel->m_usDestinationPort        = usDestinationPort;
        pIDataChannel->m_ulNewSourceAddress       = ulNewSourceAddress;
        pIDataChannel->m_usNewSourcePort          = usNewSourcePort;
        pIDataChannel->m_ulNewDestinationAddress  = ulNewDestinationAddress;
        pIDataChannel->m_usNewDestinationPort     = usNewDestinationPort;
        pIDataChannel->m_ulRestrictAdapterIndex   = ulRestrictAdapterIndex;

        pIDataChannel->m_hCreateEvent             = (HANDLE)hCreateEvent;
        pIDataChannel->m_hDeleteEvent             = (HANDLE)hDeleteEvent;

        hr = pIDataChannel->QueryInterface(ppDataChannel);

        if ( FAILED(hr) )
        {
            MYTRACE_ERROR("QI on IDataChannel", hr);
        }
    }


    return hr;
}





STDMETHODIMP 
CApplicationGatewayServices::CreatePersistentDataChannel(
    IN  ALG_PROTOCOL                eProtocol,
    IN  ULONG                       ulPrivateAddress,
    IN  USHORT                      usPrivatePort,
    IN  ULONG                       ulPublicAddress,
    IN  USHORT                      usPublicPort,
    IN  ULONG                       ulRemoteAddress,
    IN  USHORT                      usRemotePort,
    IN  ALG_DIRECTION               eDirection,
    OUT IPersistentDataChannel**    ppIPersistentDataChannel
    )
/*++

Routine Description:



Arguments:

    eProtocol,
    ulPrivateAddress,
    usPrivatePort,
    ulPublicAddress,
    usPublicPort,
    ulRemoteAddress,
    usRemotePort,
    eDirection,
    ppIPersistentDataChannel


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::CreatePersistentDataChannel");

    if ( !ppIPersistentDataChannel )
    {
        MYTRACE_ERROR("IPersistentDataChannel** not supplied",0);
        return E_INVALIDARG;
    }


    ULONG   ulFlags=0;

    ULONG   ulSourceAddress=0;
    USHORT  usSourcePort=0;
    ULONG   ulDestinationAddress=0;
    USHORT  usDestinationPort=0;
    ULONG   ulNewSourceAddress=0;
    USHORT  usNewSourcePort=0;
    ULONG   ulNewDestinationAddress=0;
    USHORT  usNewDestinationPort=0;

    ULONG   ulRestrictAdapterIndex=0;


    HRESULT hr = GetRedirectParameters(
        // IN Params
        eDirection,
        eProtocol,
        ulPrivateAddress,
        usPrivatePort,
        ulPublicAddress,
        usPublicPort,
        ulRemoteAddress,
        usRemotePort,

        // OUT Params
        ulFlags,
        ulSourceAddress,
        usSourcePort,
        ulDestinationAddress,
        usDestinationPort,
        ulNewSourceAddress,
        usNewSourcePort,
        ulNewDestinationAddress,
        usNewDestinationPort,
        ulRestrictAdapterIndex
        );

    if ( FAILED(hr) )
        return hr;


    //
    // Create a IDataChannel and cache arg so to CancelRedirect
    //

    HANDLE_PTR  HandleDynamicRedirect=NULL;

    // Dynamic
    hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
        ulFlags, 
        0,                               // Adapter Index 
        (UCHAR)eProtocol,

        ulDestinationAddress,            // ULONG    DestinationAddress
        usDestinationPort,               // USHORT   DestinationPort

        ulSourceAddress,                 // ULONG    SourceAddress
        usSourcePort,                    // USHORT   SourcePort

        ulNewDestinationAddress,         // ULONG    NewDestinationAddress
        usNewDestinationPort,            // USHORT   NewDestinationPort

        ulNewSourceAddress,              // ULONG    NewSourceAddress
        usNewSourcePort,                 // USHORT   NewSourcePort

        &HandleDynamicRedirect
        );

    
    if ( SUCCEEDED(hr) )
    {
        
        CComObject<CPersistentDataChannel>*   pIPersistentDataChannel;
        CComObject<CPersistentDataChannel>::CreateInstance(&pIPersistentDataChannel);


        //
        // Save these settings so to be able to return them to the user 
        // if the IDataChannel->GetProperties is called
        //
        pIPersistentDataChannel->m_Properties.eProtocol               = eProtocol;
        pIPersistentDataChannel->m_Properties.ulPrivateAddress        = ulPrivateAddress;
        pIPersistentDataChannel->m_Properties.usPrivatePort           = usPrivatePort;
        pIPersistentDataChannel->m_Properties.ulPublicAddress         = ulPublicAddress;
        pIPersistentDataChannel->m_Properties.usPublicPort            = usPublicPort;
        pIPersistentDataChannel->m_Properties.ulRemoteAddress         = ulRemoteAddress;
        pIPersistentDataChannel->m_Properties.usRemotePort            = usRemotePort;
        pIPersistentDataChannel->m_Properties.eDirection              = eDirection;



        //
        // Cache these hanlde in order to implement IPersistentDataChannel->Cancel
        //
        pIPersistentDataChannel->m_HandleDynamicRedirect = HandleDynamicRedirect;


        hr = pIPersistentDataChannel->QueryInterface(ppIPersistentDataChannel);

    }


    return hr;

}





STDMETHODIMP 
CApplicationGatewayServices::ReservePort(
    IN  USHORT     usPortCount,     // must be 1 or more and not more then ALG_MAXIMUM_PORT_RANGE_SIZE
    OUT USHORT*    pusReservedPort  // Received the base reserved port *pusReservedPort+usPortCount-1 are reserved for the caller
    )
/*++

Routine Description:

    Reserve a number of port (usPortCount) port(s)

Arguments:

    usPortCount     - greated then 1 and not more then ALG_MAXIMUM_PORT_RANGE_SIZE
    pusReservedPort - Received the base reserved port *pusReservedPort+usPortCount-1 are reserved for the caller

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::ReservePort")

    if ( usPortCount < 0 || usPortCount > ALG_MAXIMUM_PORT_RANGE_SIZE )
        return E_INVALIDARG;

    _ASSERT(pusReservedPort);

    HRESULT hr = g_pAlgController->GetNat()->ReservePort(usPortCount, pusReservedPort);

    if ( FAILED(hr) )
    {
        MYTRACE("Reserving Ports", hr);
    }
    else
    {
        MYTRACE("%d port stating at %d", usPortCount, ntohs(*pusReservedPort) );
    }
        
    return hr;
}





//
//
//
VOID CALLBACK 
CApplicationGatewayServices::TimerCallbackReleasePort(
    PVOID   pParameter,         // thread data
    BOOLEAN TimerOrWaitFired    // reason
    )
{
    MYTRACE_ENTER("CApplicationGatewayServices::TimerCallbackReleasePort");

    CTimerQueueReleasePort* pTimerQueueReleasePort = (CTimerQueueReleasePort*)pParameter;

    if ( pTimerQueueReleasePort )
    {
        MYTRACE("Releasing port Base %d count %d", ntohs(pTimerQueueReleasePort->m_usPortBase), pTimerQueueReleasePort->m_usPortCount);
        g_pAlgController->GetNat()->ReleasePort(pTimerQueueReleasePort->m_usPortBase, pTimerQueueReleasePort->m_usPortCount);

        delete pTimerQueueReleasePort;
    }
}




STDMETHODIMP 
CApplicationGatewayServices::ReleaseReservedPort(
    IN  USHORT      usPortBase,     // Port to release
    IN  USHORT      usPortCount     // Number of port in the range starting at usPortBase
    )
/*++

Routine Description:

    Release the given port(s)

Arguments:

    pusReservedPort - The starting base port number
    usPortCount     - greated then 1 and not more then ALG_MAXIMUM_PORT_RANGE_SIZE

Return Value:

    HRESULT         - S_OK      for success
                    - E_FAIL    could no release the port
                    
Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::ReleaseReservedPort")

    MYTRACE("BasePort %d, Count %d", ntohs(usPortBase), usPortCount);

    //
    // By creating a CTimerQueueReleasePort it will trigger a ReleaseReservePort after 4 minutes
    // we need this delay to insure that a ReserverPort does not get the same port that just go Released
    // because the connnection would not work (This is a TCP/IP TIME_WAIT restriction)
    //
    CTimerQueueReleasePort* pTimerReleasePort = new CTimerQueueReleasePort(m_hTimerQueue, usPortBase, usPortCount);
    
    if ( pTimerReleasePort )
        return S_OK;
    else
        return E_FAIL;
}





STDMETHODIMP 
CApplicationGatewayServices::EnumerateAdapters(
    OUT IEnumAdapterInfo**    ppEnumAdapterInfo 
    )
/*++

Routine Description:

    Create a list of IEnumAdapterInfo
    the AddRef will be done soe caller needs to call Release 

Arguments:

    ppEnumAdapterInfo   - receive the enumarator interface of the IAdapterInfo

Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::EnumerateAdapters")

    _ASSERT(ppEnumAdapterInfo==NULL);

    HRESULT hr = S_OK;

    CreateSTLEnumerator<ComEnumOnSTL_ForAdapters>(
        (IUnknown**)ppEnumAdapterInfo, 
        NULL, 
        g_pAlgController->m_CollectionOfAdapters.m_ListOfAdapters
        );

    return hr;
}

 



STDMETHODIMP 
CApplicationGatewayServices::StartAdapterNotifications(
    IN  IAdapterNotificationSink*    pSink,
    OUT DWORD*                       pdwCookie
    )
/*++

Routine Description:

    The ALG module calls this method to Register a notification sync with the ALG.exe

Arguments:

    pSink           - Interface to call back with future notification
    pdwCookie       - this cookie will be used to cancel this sink


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::StartAdapterNotifications")

    if ( pSink==NULL || pdwCookie==NULL )
    {
        MYTRACE("Invalid argument pass");
        return E_INVALIDARG;
    }

    return g_pAlgController->m_AdapterNotificationSinks.Add(pSink, pdwCookie);
}




STDMETHODIMP 
CApplicationGatewayServices::StopAdapterNotifications(
    IN  DWORD   dwCookieToRemove
    )
/*++

Routine Description:

    Cancel a previously registered sink

Arguments:

    
    pdwCookieToRemove   - Pass the cookie that was return from the StartAdapterNotifications


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/
{
    MYTRACE_ENTER("CApplicationGatewayServices::StopAdapterNotifications")

    return g_pAlgController->m_AdapterNotificationSinks.Remove(dwCookieToRemove);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionadapternotifysinks.h ===
//
// Microsoft
//
// CollectionAdapterNotifySinks.h

#pragma once

#include "ScopeCriticalSection.h"
//#include "AdapterNotificationSink.h"

#include <list>
#include <algorithm>



class CAdapterSinkBuket
{
public:
    CAdapterSinkBuket(IAdapterNotificationSink* pInterface)
    {
        MYTRACE_ENTER("CAdapterSinkBuket(IAdapterNotificationSink* pInterface)")

        m_pInterface = pInterface;
        m_pInterface->AddRef();

        m_dwCookie = 0;
    }

    ~CAdapterSinkBuket()
    {
        m_pInterface->Release();
    }


//
// Properties
//
    IAdapterNotificationSink*   m_pInterface;
    DWORD                       m_dwCookie;
};


//
// Adapters
//
typedef std::list<CAdapterSinkBuket*>        LISTOF_ADAPTER_NOTIFICATION_SINK;


enum eNOTIFY
{
    eNOTIFY_ADDED,
    eNOTIFY_REMOVED,
    eNOTIFY_MODIFIED
};





//
//
//
class CCollectionAdapterNotifySinks
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_ADAPTER_NOTIFICATION_SINK            m_ListOfAdapterSinks;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionAdapterNotifySinks();
 

    //
    // Add a new Adapter (Thread safe)
    //
    HRESULT 
    Add( 
        IN  IAdapterNotificationSink*       pAdapterSinkToAdd,
        OUT DWORD*                          pdwNewCookie
        );

 
    //
    // Remove a adapterSink from the list (Thead safe)
    //
    HRESULT 
    Remove( 
        IN  DWORD   dwCookie
        );


 
    //
    // Remove all the IAdapterNotificationSinks from the collection
    //
    HRESULT
    RemoveAll();


    //
    // Fire a notification to any ALG module requesting notification
    //
    HRESULT
    Notify(
        IN  eNOTIFY             eAction,
        IN  IAdapterInfo*       pIAdapterInfo
        );
 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionadapternotifysinks.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionAdapterNotifySinks.cpp

Abstract:

    Implement a collection of the CPrimaryControlChannel.cpp & CSecondaryControlChannel
    in a threa safe way.

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "CollectionAdapterNotifySinks.h"
#include "AlgController.h"


CCollectionAdapterNotifySinks::~CCollectionAdapterNotifySinks()
{
    RemoveAll();
}



//
// Add an already created Adapter
//
HRESULT 
CCollectionAdapterNotifySinks::Add( 
    IN  IAdapterNotificationSink*   pAdapterSinkToAdd,  // AdapterSink to be added at the collection
    OUT DWORD*                      pdwNewCookie        // Will be populated with the new unique id can be used later to retrieve the AdapterSink
    )
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAdapterNotifySinks::Add")

        if ( !pdwNewCookie )
        {
            MYTRACE_ERROR("Return Cookie address not supplied", 0);
            return E_INVALIDARG;
        }


        CAdapterSinkBuket* pNewBuketToAdd = new CAdapterSinkBuket(pAdapterSinkToAdd);

        if ( !pNewBuketToAdd )
            return E_OUTOFMEMORY;

        *pdwNewCookie = 1;

    
        //
        // Find a unique cookie
        //
        if ( m_ListOfAdapterSinks.empty() )
        {
            //
            // List is empty so obviously the cookie '1' is unique
            //
            MYTRACE("First SINK Cookie is %d", *pdwNewCookie);
            pNewBuketToAdd->m_dwCookie = *pdwNewCookie;
        }
        else
        {
            //
            // Travers the collection and stop when the cookie is not found 
            // this schema could be optimize but the number of Sink is not expect to be large (1 per ALG modules)
            //
            MYTRACE("Current size %d", m_ListOfAdapterSinks.size() );

            while ( pNewBuketToAdd->m_dwCookie==0 )
            {
                MYTRACE("Search for unique Cookie %d", *pdwNewCookie);

                for (   LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator = m_ListOfAdapterSinks.begin(); 
                        theIterator != m_ListOfAdapterSinks.end(); 
                        theIterator++ 
                    )
                {

                    CAdapterSinkBuket* pAdapterSinkBuket = (CAdapterSinkBuket*)(*theIterator);

                    if ( pAdapterSinkBuket->m_dwCookie == *pdwNewCookie )
                        break;
                    else
                    {
                        pNewBuketToAdd->m_dwCookie = *pdwNewCookie;
                        break; // ok we found a unique cookie
                    }

            
                }

                *pdwNewCookie = *pdwNewCookie + 1;
            }
        }
    

        //
        // Add Sync to Collection
        //
        m_ListOfAdapterSinks.push_back(pNewBuketToAdd);

    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}







//
// Remove a adapter from the list (Thead safe)
//
HRESULT 
CCollectionAdapterNotifySinks::Remove( 
    IN  DWORD   dwCookieToRemove
    )
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAdapterNotifySinks::Remove")

        HRESULT hr = S_OK;

        for (   LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator = m_ListOfAdapterSinks.begin(); 
                theIterator != m_ListOfAdapterSinks.end(); 
                theIterator++ 
            )
        {

            CAdapterSinkBuket* pAdapterSinkBuket = (CAdapterSinkBuket*)(*theIterator);

            if ( pAdapterSinkBuket->m_dwCookie == dwCookieToRemove )
            {
                delete pAdapterSinkBuket;
                m_ListOfAdapterSinks.erase(theIterator);
                return S_OK;
            }
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    return E_INVALIDARG;    // if we are here that mean the cookie was not found
}




//
// When an adapter form the collection
//
HRESULT
CCollectionAdapterNotifySinks::RemoveAll()
{
    try
    {

        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapterNotifySinks::RemoveAll")


        //
        // By deleting all the ControlChannel they will also cancel all their associated Redirection
        //
        LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator;

        MYTRACE("Collection has %d item", m_ListOfAdapterSinks.size());

        while ( m_ListOfAdapterSinks.size() > 0 )
        {
            theIterator = m_ListOfAdapterSinks.begin(); 

            delete (*theIterator);
            m_ListOfAdapterSinks.erase(theIterator);
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;

}






HRESULT
CCollectionAdapterNotifySinks::Notify(
    eNOTIFY             eAction,
    IAdapterInfo*       pIAdapterInfo
    )
/*++

Routine Description:

    For all AdapterSink inteface in the current collection do a notify with the given action ADDED,REMOVED,MODIFIED

Arguments:

    eAction         - ADDED, REMOVED, MODIFIED

    pIAdapterInfo   - Interface of the Adapter with the current action to be notify to alg modules

Return Value:

    void            - None

Environment:


--*/
{
    
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapterNotifySinks::NotifySink")
        MYTRACE("Collection size %d", m_ListOfAdapterSinks.size());


        for (   LISTOF_ADAPTER_NOTIFICATION_SINK::iterator theIterator = m_ListOfAdapterSinks.begin(); 
                theIterator != m_ListOfAdapterSinks.end(); 
                theIterator++ 
            )
        {

            CAdapterSinkBuket* pAdapterSinkBuket = (CAdapterSinkBuket*)(*theIterator);

            MYTRACE("Will notify AdapterSink with cookie #%d", pAdapterSinkBuket->m_dwCookie);

            switch ( eAction )
            {
            case eNOTIFY_ADDED:
                pAdapterSinkBuket->m_pInterface->AdapterAdded(pIAdapterInfo);
                break;

            case eNOTIFY_REMOVED:
                pAdapterSinkBuket->m_pInterface->AdapterRemoved(pIAdapterInfo);
                break;

            case eNOTIFY_MODIFIED:
                pAdapterSinkBuket->m_pInterface->AdapterModified(pIAdapterInfo);
                break;
            }
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionadapters.h ===
//
// Microsoft
//
// CollectionAdapter.h

#pragma once

#include "ScopeCriticalSection.h"
#include "AdapterInfo.h"
#include "PrimaryControlChannel.h"

#include <list>
#include <algorithm>

//
// Adapters
//
typedef std::list<IAdapterInfo*>        LISTOF_ADAPTERS;


//
//
//
class CCollectionAdapters
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_ADAPTERS                             m_ListOfAdapters;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionAdapters();
 

    //
    // Add a new Adapter (Thread safe)
    //
    HRESULT 
    Add( 
        IN  IAdapterInfo*       pAdapterToAdd
        );

    //
    // This version of Add will actualy create the new IAdapterInfo before adding it to the collection
    // return the newly created IAdapterInfo or NULL is faild
    //
    IAdapterInfo* 
    Add( 
        IN	ULONG				nCookie,
	    IN	short				nType
        );

 
    //
    // Remove a adapter from the list (Thead safe)
    // by removing a adapter it will also kill all associated ControlChannel 
    //
    HRESULT 
    Remove( 
        IN  IAdapterInfo*       pAdapterToRemove
        );


    //
    // This version od Remove will remove the IAdapterInfo base on the given index
    //
    HRESULT 
    Remove( 
        IN  ULONG               nCookie
        );

    //
    // Remove all the adapter from the collection
    //
    HRESULT
    RemoveAll();


    //
    // Return an IAdapterInfo the caller is responsable of releasing the interface
    //
    HRESULT
    GetAdapterInfo(
        IN  ULONG               nCookie,
        OUT IAdapterInfo**      ppAdapterInfo
        );

    //
    // Bind the given addresses with the given index representing the AdapterInfo
    //
    HRESULT
    SetAddresses(
        IN  ULONG               nCookie,
        IN  ULONG               nAdapterIndex,
	    IN  ULONG	            nAddressCount,
	    IN  DWORD	            anAddress[]
        );


    HRESULT
    ApplyPrimaryChannel(
        CPrimaryControlChannel* pChannelToActivate
        );

    HRESULT
    AdapterUpdatePrimaryChannel(
        ULONG nCookie,
        CPrimaryControlChannel *pChannel
        );
    

private:

    //
    // Will return the IAdapterInfo* of for the given Cookie or NULL if not found
    //
    IAdapterInfo*
    FindUsingCookie(
        ULONG nCookie
        )
    {

        for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
                theIterator != m_ListOfAdapters.end(); 
                theIterator++ 
            )
        {
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);
            if (  pAdapterInfo->m_nCookie == nCookie )
                return *theIterator;
        }

        return NULL;
    }

    //
    // Will return the IAdapterInfo* of given the AdapterIndex or NULL if not found
    //
    IAdapterInfo*
    FindUsingAdapterIndex(
        ULONG nAdapterIndex
        )
    {
        MYTRACE_ENTER("FindUsingAdapterIndex");
        MYTRACE("Looking for adapter %d", nAdapterIndex);

        for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
                theIterator != m_ListOfAdapters.end(); 
                theIterator++ 
            )
        {
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);
            MYTRACE("ADAPTER index %d", pAdapterInfo->m_nAdapterIndex);
            if (  pAdapterInfo->m_nAdapterIndex == nAdapterIndex )
                return *theIterator;
        }

        return NULL;
    }


    //
    // Return true if the AdapterInfo is part of the collection
    //
    inline bool
    FindUsingInterface(
        IAdapterInfo* pAdapterToFind
        )
    {
        LISTOF_ADAPTERS::iterator theIterator = std::find(
            m_ListOfAdapters.begin(),
            m_ListOfAdapters.end(),
            pAdapterToFind
            );

        return *theIterator ? true : false;
    }


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionalgmodules.h ===
#pragma once

#include "ScopeCriticalSection.h"
#include "AlgModule.h"


#include <list>
#include <algorithm>






typedef  std::list<CAlgModule*> LISTOF_ALGMODULE;



//
//
//
class CCollectionAlgModules
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;
    LISTOF_ALGMODULE                            m_ThisCollection;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionAlgModules();

    int	// Returns the total number of ISV ALG  loaded or -1 if could not load them  or 0 is none where setup
    Load();

    HRESULT
    Unload();

    HRESULT
    UnloadDisabledModule();


    //
    // Make sure that ALG modules reflect the curren configuration
    //
    void
    Refresh()
    {
        MYTRACE_ENTER("CCollectionAlgModules::Refresh()");

        UnloadDisabledModule();
        Load();
    }

private:

    //
    // Add a new control channel (Thread safe)
    //
    CAlgModule*
    CCollectionAlgModules::AddUniqueAndStart( 
        CRegKey&    KeyEnumISV,
        LPCTSTR     pszAlgID
        );


    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT 
    Remove( 
        CAlgModule* pAglToRemove
        );

    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionadapters.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionAdapters.cpp

Abstract:

    Implement a collection of the CPrimaryControlChannel.cpp & CSecondaryControlChannel
    in a threa safe way.

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "CollectionAdapters.h"
#include "CollectionAdapterNotifySinks.h"
#include "AlgController.h"


CCollectionAdapters::~CCollectionAdapters()
{
    RemoveAll();
}



//
// Add an already created Adapter
//
HRESULT 
CCollectionAdapters::Add( 
    IAdapterInfo* pAdapterToAdd
    )
{
    try
    {
        ENTER_AUTO_CS

        if ( !FindUsingInterface(pAdapterToAdd) )
            m_ListOfAdapters.push_back(pAdapterToAdd);
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}




//
// Add a NEW Adapter this function insure that the is only 1 adatper with the given INDEX
// returns the newly added adapter or NULL is faild
// if the Adapter index was already present the return pointer is of the one found in the collection
//
IAdapterInfo*
CCollectionAdapters::Add( 
    IN	ULONG				nCookie,
	IN	short				nType
    )
{
    CComObject<CAdapterInfo>*   pIAdapterInfo=NULL;

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::Add");
        MYTRACE("Adapter Cookie %d of type %d", nCookie, nType);
    

        IAdapterInfo*   pIFound = FindUsingCookie(nCookie);
    
        if ( pIFound )
            return pIFound;   // Adapter with the given Index is already in the collection


        
        HRESULT hr = CComObject<CAdapterInfo>::CreateInstance(&pIAdapterInfo);

        if ( FAILED(hr) ) 
        {
            MYTRACE_ERROR("CComObject<CAdapterInfo>::CreateInstance(&pIAdapterInfo)",hr);
            return NULL; //ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the new interface
        //
        pIAdapterInfo->m_nCookie = nCookie;
        pIAdapterInfo->m_eType  = (ALG_ADAPTER_TYPE)nType;

        m_ListOfAdapters.push_back(pIAdapterInfo);
        pIAdapterInfo->AddRef();

    }
    catch(...)
    {
        return NULL;
    }

    return pIAdapterInfo;
}




//
// Remove a adapter from the list (Thead safe)
//
HRESULT 
CCollectionAdapters::Remove( 
    IAdapterInfo* pAdapterToRemove
    )
{
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::Remove by IAdapterInfo");

        LISTOF_ADAPTERS::iterator theIterator = std::find(
            m_ListOfAdapters.begin(),
            m_ListOfAdapters.end(),
            pAdapterToRemove
            );

        if ( *theIterator )
        {
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)pAdapterToRemove;

            g_pAlgController->m_AdapterNotificationSinks.Notify(eNOTIFY_REMOVED, (*theIterator) );
            g_pAlgController->m_ControlChannelsPrimary.AdapterRemoved(pAdapterInfo->m_nAdapterIndex);

            (*theIterator)->Release();
            m_ListOfAdapters.erase(theIterator);
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}



//
// Remove a adapter from the list (Thead safe)
//
HRESULT 
CCollectionAdapters::Remove( 
    ULONG   nCookieOfAdapterToRemove
    )
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAdapters::Remove by Index");

        for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
                theIterator != m_ListOfAdapters.end(); 
                theIterator++ 
            )
        {

            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);

            if (  pAdapterInfo->m_nCookie == nCookieOfAdapterToRemove )
            {
                g_pAlgController->m_AdapterNotificationSinks.Notify(eNOTIFY_REMOVED, (*theIterator) );
                g_pAlgController->m_ControlChannelsPrimary.AdapterRemoved(pAdapterInfo->m_nAdapterIndex);

                pAdapterInfo->Release();
                m_ListOfAdapters.erase(theIterator);

                return S_OK;
            }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return E_INVALIDARG;
}


//
// When an adapter form the collection
//
HRESULT
CCollectionAdapters::RemoveAll()
{
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::RemoveAll");

        //
        // By deleting all the ControlChannel they will also cancel all their associated Redirection
        //
        MYTRACE("Collection has %d item", m_ListOfAdapters.size());

        LISTOF_ADAPTERS::iterator theIterator;

        while ( m_ListOfAdapters.size() > 0 )
        {
            theIterator = m_ListOfAdapters.begin(); 
            CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);

            pAdapterInfo->Release();
            m_ListOfAdapters.erase(theIterator);
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}



//
// Return an IAdapterInfo the caller is responsable of releasing the interface
//
HRESULT
CCollectionAdapters::GetAdapterInfo(
    IN  ULONG               nAdapterIndex,
    OUT IAdapterInfo**      ppAdapterInfo
    )
{
    MYTRACE_ENTER("CCollectionAdapters::GetAdapterInfo");

    try
    {
        ENTER_AUTO_CS

        MYTRACE("Adapter index %d requested", nAdapterIndex);

        *ppAdapterInfo = FindUsingAdapterIndex(nAdapterIndex);

        if ( *ppAdapterInfo == NULL )
        {
            MYTRACE_ERROR("Adapter was not found in the collection", 0);
            return E_INVALIDARG;
        }

        (*ppAdapterInfo)->AddRef();

    }
    catch(...)
    {
        MYTRACE_ERROR("TRY/CATCH",0);
        return E_FAIL;
    }

    return S_OK;
}


//
// Update the addresses member proprety
//
// Now that we have the address we can apply any outstanding ControlChannel (Redirect)
//
HRESULT
CCollectionAdapters::SetAddresses(
	ULONG	nCookie,
    ULONG   nAdapterIndex,
	ULONG	nAddressCount,
	DWORD	anAddress[]
    )
{

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAdapters::SetAddresses");
        MYTRACE("Adapter BIND Cookie %d  Address Count %d", nCookie, nAddressCount);


        CAdapterInfo*  pIAdapterFound = (CAdapterInfo*)FindUsingCookie(nCookie);

        if ( !pIAdapterFound )
        {
            MYTRACE_ERROR("Adapter was not found in the collection", 0);
            return E_INVALIDARG;
        }

        //
        // Cache the Adapter Index 
        //
        pIAdapterFound->m_nAdapterIndex = nAdapterIndex;

        //
        // Cache the addresses
        //
        pIAdapterFound->m_nAddressCount = nAddressCount;

        for ( short nA=0; nA < nAddressCount; nA++ )
            pIAdapterFound->m_anAddress[nA] = anAddress[nA];


        //
        // Fire any Sink that may be setup
        //
        if ( pIAdapterFound->m_bNotified )
        {
            //
            // Already notify once the user that this adapter was added
            // from now on any CCollectionAdapters::SetAddresses
            // will trigger a eNOTIFY_MODIFIED notification
            //
            g_pAlgController->m_AdapterNotificationSinks.Notify(
                eNOTIFY_MODIFIED, 
                pIAdapterFound 
                );
        }
        else
        {
            //
            // Ok this is the first time we received address for this
            // adapter we will let the user know that a new adapter got added
            //
            g_pAlgController->m_AdapterNotificationSinks.Notify(
                eNOTIFY_ADDED, 
                pIAdapterFound 
                );

            pIAdapterFound->m_bNotified = true;
        }


        //
        // Create redirect(s) for any ControlChannels in the Collection of PrimaryControlChannel
        //
        g_pAlgController->m_ControlChannelsPrimary.SetRedirects(
            pIAdapterFound->m_eType, 
            nAdapterIndex,
            anAddress[0]
            );
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}



//
//
//
HRESULT
CCollectionAdapters::ApplyPrimaryChannel(
    CPrimaryControlChannel* pChannelToActivate
    )
{
    MYTRACE_ENTER("CCollectionAdapters::ApplyPrimaryChannel");

    if ( !pChannelToActivate )
        return E_INVALIDARG;

    ENTER_AUTO_CS

    for (   LISTOF_ADAPTERS::iterator theIterator = m_ListOfAdapters.begin(); 
            theIterator != m_ListOfAdapters.end(); 
            theIterator++ 
        )
    {

        CAdapterInfo* pAdapterInfo = (CAdapterInfo*)(*theIterator);

        if ( pAdapterInfo && pAdapterInfo->m_nAddressCount >0 )
        {
            pChannelToActivate->SetRedirect(
                pAdapterInfo->m_eType, 
                pAdapterInfo->m_nAdapterIndex,
                pAdapterInfo->m_nAddressCount
                );
        }
    }

    return S_OK;
}





//
// Will be called when port mapping has changed
//
HRESULT
CCollectionAdapters::AdapterUpdatePrimaryChannel(
    ULONG nCookie,
    CPrimaryControlChannel *pChannel
    )
{
    HRESULT hr = S_OK;

    MYTRACE_ENTER("CCollectionAdapters::AdapterUpdatePrimaryChannel");

    try
    {
        ENTER_AUTO_CS

        CAdapterInfo *pAdapter = (CAdapterInfo*) FindUsingCookie(nCookie);
        if (NULL != pAdapter
            && ( (eALG_BOUNDARY   & pAdapter->m_eType) || 
                 (eALG_FIREWALLED & pAdapter->m_eType) 
               )
           )
        {
            ULONG ulAddress;
            USHORT usPort;
            HANDLE_PTR hRedirect;
            
            HRESULT hrPortMappingExists =
                g_pAlgController->GetNat()->LookupAdapterPortMapping(
                    pAdapter->m_nAdapterIndex,
                    pChannel->m_Properties.eProtocol,
                    0,
                    pChannel->m_Properties.usCapturePort,
                    &ulAddress,
                    &usPort
                    );

            hRedirect = pChannel->m_CollectionRedirects.FindInboundRedirect(pAdapter->m_nAdapterIndex);

            if (SUCCEEDED(hrPortMappingExists) && NULL == hRedirect)
            {
                MYTRACE("PortMapping Exist and We had no Redirect so create them");
                hr = pChannel->CreateInboundRedirect(pAdapter->m_nAdapterIndex);
            }
            else if (FAILED(hrPortMappingExists) && NULL != hRedirect)
            {
                MYTRACE("PortMapping DOES NOT Exist and We had Redirect set so remove them");
                hr = pChannel->m_CollectionRedirects.Remove(hRedirect);
            }
        }
        else
        {
            MYTRACE("Adapter is not ICS or ICF");
        }
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionchannels.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionChannels.cpp

Abstract:

    Implement a collection of the CPrimaryControlChannel.cpp & CSecondaryControlChannel
    in a threa safe way.

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "AlgController.h"

#define NAT_PROTOCOL_TCP 0x06
#define NAT_PROTOCOL_UDP 0x11

CCollectionControlChannelsPrimary::~CCollectionControlChannelsPrimary()
{
    RemoveAll();
}



//
// Add a new control channel (Thread safe)
//
HRESULT 
CCollectionControlChannelsPrimary::Add( 
    CPrimaryControlChannel* pChannelToAdd
    )
{
    try
    {
        ENTER_AUTO_CS

        m_ListOfChannels.push_back(pChannelToAdd);
        g_pAlgController->m_CollectionOfAdapters.ApplyPrimaryChannel(pChannelToAdd);
        pChannelToAdd->AddRef();
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// Remove a channel from the list (Thead safe)
//
HRESULT 
CCollectionControlChannelsPrimary::Remove( 
    CPrimaryControlChannel* pChannelToRemove
    )
{
    HRESULT hr = S_OK;

    try
    {
        ENTER_AUTO_CS
        

        LISTOF_CHANNELS_PRIMARY::iterator theIterator = std::find(
            m_ListOfChannels.begin(),
            m_ListOfChannels.end(),
            pChannelToRemove
            );

        if ( *theIterator )
        {
            m_ListOfChannels.erase(theIterator);    // Remove from list

            pChannelToRemove->CancelRedirects();
            pChannelToRemove->Release();
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return hr;
}


//
// Empty the list and free the PrimaryControlChannels
//
HRESULT
CCollectionControlChannelsPrimary::RemoveAll()
{

    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionControlChannelsPrimary::RemoveAll()");

        //
        // By deleting all the ControlChannel they will also cancel all associated Redirects
        //
        MYTRACE("Collection has %d item", m_ListOfChannels.size());

        LISTOF_CHANNELS_PRIMARY::iterator theIterator;

        while ( m_ListOfChannels.size() > 0 )
        {
            theIterator = m_ListOfChannels.begin(); 


            m_ListOfChannels.erase(theIterator);    // Remove from list

            (*theIterator)->CancelRedirects();
            (*theIterator)->Release();

        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    
    return S_OK;
}




//
// Set a dynamic redirection and all collected Primary ControlChannel
//
HRESULT
CCollectionControlChannelsPrimary::SetRedirects(       
    ALG_ADAPTER_TYPE    eAdapterType,
    ULONG               nAdapterIndex,
    ULONG               nAdapterAddress
    )
{
    HRESULT hr=S_OK;

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionControlChannelsPrimary::SetRedirects");
        MYTRACE("AdapterType %d, RealAdapterIndex %d, Currently %d ControlChannel in the collection", eAdapterType, nAdapterIndex, m_ListOfChannels.size());
    


        //
        // Set redirect for all Channel
        //
        for (   LISTOF_CHANNELS_PRIMARY::iterator theIterator = m_ListOfChannels.begin(); 
                theIterator != m_ListOfChannels.end(); 
                theIterator++ 
            )
        {
            (*theIterator)->SetRedirect(    
                eAdapterType,
                nAdapterIndex,
                nAdapterAddress
                );
        }

    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return hr;
}


//
// Check to see if the any PrimaryChannel need to be apply or his redirect should be removed
//
HRESULT
CCollectionControlChannelsPrimary::AdapterPortMappingChanged(
    ULONG               nCookie,
    UCHAR               ucProtocol,
    USHORT              usPort
    )
{
    HRESULT hr = S_OK;
    ALG_PROTOCOL algProtocol;

    MYTRACE_ENTER("CCollectionControlChannelsPrimary::AdapterPortMappingChanged");
    MYTRACE("AdapterCookie %d, Protocol %d, Port %d", nCookie, ucProtocol, usPort);

    if (NAT_PROTOCOL_TCP == ucProtocol)
    {
        algProtocol = eALG_TCP;
    }
    else if (NAT_PROTOCOL_UDP == ucProtocol)
    {
        algProtocol = eALG_UDP;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        try
        {
            ENTER_AUTO_CS


            CPrimaryControlChannel *pControlChannel = FindControlChannel(algProtocol, usPort);
            if (NULL != pControlChannel
                && pControlChannel->m_Properties.fCaptureInbound)
            {
                hr = g_pAlgController->m_CollectionOfAdapters.AdapterUpdatePrimaryChannel(
                        nCookie,
                        pControlChannel
                        );
            }
        }
        catch (...)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}





//
// Called when an adapter got removed
// function will cancel any redirect that was done on this adapter index
//
HRESULT
CCollectionControlChannelsPrimary::AdapterRemoved(
    ULONG               nAdapterIndex
    )
{
    HRESULT hr = S_OK;
    MYTRACE_ENTER("CCollectionControlChannelsPrimary::AdapterRemoved");
    MYTRACE("AdapterIndex %d", nAdapterIndex);

    try
    {
        ENTER_AUTO_CS

        //
        // Set redirect for all Channel
        //
        for (   LISTOF_CHANNELS_PRIMARY::iterator theIterator = m_ListOfChannels.begin(); 
                theIterator != m_ListOfChannels.end(); 
                theIterator++ 
            )
        {
            
            (*theIterator)->CancelRedirectsForAdapter(    
                nAdapterIndex
                );
        }

    }
    catch (...)
    {
        hr = E_FAIL;
    }

    return hr;
}




//
//
// Collection of Secondary control channels
//
//




//
//
//
CCollectionControlChannelsSecondary::~CCollectionControlChannelsSecondary()
{
    RemoveAll();
}



//
// Add a new control channel (Thread safe)
//
HRESULT 
CCollectionControlChannelsSecondary::Add( 
    CSecondaryControlChannel* pChannelToAdd
    )
{
    try
    {
        ENTER_AUTO_CS

        m_ListOfChannels.push_back(pChannelToAdd);
        pChannelToAdd->AddRef();
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// Remove a channel from the list (Thead safe)
//
HRESULT 
CCollectionControlChannelsSecondary::Remove( 
    CSecondaryControlChannel* pChannelToRemove
    )
{
    try
    {
        ENTER_AUTO_CS

        LISTOF_CHANNELS_SECONDARY::iterator theIterator = std::find(
            m_ListOfChannels.begin(),
            m_ListOfChannels.end(),
            pChannelToRemove
            );

        if ( *theIterator )
        {
            m_ListOfChannels.erase(theIterator);    // Remove from list

            pChannelToRemove->CancelRedirects();
            pChannelToRemove->Release();
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// When a Control is cancel it need to Cancel all it's redirect previousely created
//
HRESULT
CCollectionControlChannelsSecondary::RemoveAll()
{
  
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionControlChannelsSecondary::RemoveAll()");

        //
        // By deleting all the SecondaryControlChannel they will also cancel all associated Redirects
        //
        MYTRACE("Collection has %d item", m_ListOfChannels.size());

        LISTOF_CHANNELS_SECONDARY::iterator theIterator;

        while ( m_ListOfChannels.size() > 0 )
        {
            theIterator = m_ListOfChannels.begin(); 

            m_ListOfChannels.erase(theIterator);    // Remove from list

            (*theIterator)->CancelRedirects();
            (*theIterator)->Release();
        }

    }
    catch(...)
    {
        return E_FAIL;
    }

    
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionchannels.h ===
//
// Microsoft
//
//

#include "PrimaryControlChannel.h"
#include "SecondaryControlChannel.h"


#include <list>



//
// Free the Channels
//
typedef  std::list<CPrimaryControlChannel*>     LISTOF_CHANNELS_PRIMARY;
typedef  std::list<CSecondaryControlChannel*>   LISTOF_CHANNELS_SECONDARY;





//
//
//
class CCollectionControlChannelsPrimary
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_CHANNELS_PRIMARY                     m_ListOfChannels;



//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionControlChannelsPrimary();
 

    //
    // Add a new control channel (Thread safe)
    //
    HRESULT 
    Add( 
        CPrimaryControlChannel* pChannelToAdd
        );

 
    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT 
    Remove( 
        CPrimaryControlChannel* pChannelToRemove
        );


    //
    // Use to cancel all ControlChannel in the collection and free the list
    //
    HRESULT
    RemoveAll();


    //
    // Set a dynamic redirection and all collected Primary ControlChannel
    //
    HRESULT
    SetRedirects(       
        ALG_ADAPTER_TYPE    eAdapterType,
        ULONG               nAdapterIndex,
        ULONG               nAdapterAddress
        );

    //
    // Called when a port mapping is modified
    //
    HRESULT
    AdapterPortMappingChanged(
        ULONG               nCookie,
        UCHAR               ucProtocol,
        USHORT              usPort
        );

    //
    // Called when an adapter got removed
    // function will cancel any redirect that was done on this adapter index
    //
    HRESULT
    AdapterRemoved(
        ULONG               nAdapterIndex
        );

private:

    CPrimaryControlChannel*
    FindControlChannel(
        ALG_PROTOCOL        eProtocol,
        USHORT              usPort
        )
    {
        for (   LISTOF_CHANNELS_PRIMARY::iterator theIterator = m_ListOfChannels.begin(); 
                theIterator != m_ListOfChannels.end(); 
                theIterator++ 
            )
        {
            CPrimaryControlChannel* pControlChannel = (CPrimaryControlChannel*)(*theIterator);
            if (pControlChannel->m_Properties.eProtocol == eProtocol
                && pControlChannel->m_Properties.usCapturePort == usPort)
            {
                return pControlChannel;
            }
        }

        return NULL;
    };
    

};









//
//
//
class CCollectionControlChannelsSecondary
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;

    LISTOF_CHANNELS_SECONDARY                   m_ListOfChannels;



//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionControlChannelsSecondary();


    //
    // Add a new control channel (Thread safe)
    //
    HRESULT Add( 
        CSecondaryControlChannel* pChannelToAdd
        );


    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT Remove( 
        CSecondaryControlChannel* pChannelToRemove
        );

    //
    // Use to cancel all ControlChannel in the collection and free the list
    //
    HRESULT
    RemoveAll();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionredirects.h ===
#pragma once


#include "ScopeCriticalSection.h"
#include <list>
#include <algorithm>


class CPrimaryControlChannelRedirect
{
public:
    HANDLE_PTR m_hRedirect;
    ULONG m_nAdapterIndex;
    BOOL m_fInboundRedirect;

    CPrimaryControlChannelRedirect(
        HANDLE_PTR hRedirect,
        ULONG nAdapterIndex,
        BOOL fInboundRedirect
        )
    {
        m_hRedirect = hRedirect;
        m_nAdapterIndex = nAdapterIndex;
        m_fInboundRedirect = fInboundRedirect;
    }

};



typedef  std::list<CPrimaryControlChannelRedirect> LISTOF_REDIRECTS;


//
//
//
class CCollectionRedirects
{

//
// Properties
//
public:

    CComAutoCriticalSection                     m_AutoCS;
    LISTOF_REDIRECTS                            m_ListOfRedirects;


//
// Methods
//
public:

    //
    // standard destructor
    //
    ~CCollectionRedirects();


    //
    // Add a new control channel (Thread safe)
    //
    HRESULT Add( 
        HANDLE_PTR hRedirect,
        ULONG nAdapterIndex,
        BOOL fInboundRedirect
        );


    //
    // Remove a channel from the list (Thead safe)
    //
    HRESULT Remove( 
        HANDLE_PTR hRedirect    // Redirect handle to remove
        );

    //
    // Remove all redirect that are targeted a for given Adapter
    // this is use when an adapter is removed and it had a PrimaryControlChannel
    //
    HRESULT RemoveForAdapter( 
        ULONG   nAdapterIndex   // Cookie of adapter to remove
        );


    //
    // Same as remove but for all Redirect in part of the collection
    //
    HRESULT
    RemoveAll();

    //
    // Searches for an inbound redirect for this adapter. Returns the
    // redirect handle if found, or NULL if not found.
    //
    HANDLE_PTR
    FindInboundRedirect(
        ULONG nAdapterIndex
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionredirects.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionRedirects.cpp

Abstract:

    Implement a thread safe collection of HANDLE

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "CollectionRedirects.h"
#include "AlgController.h"



CCollectionRedirects::~CCollectionRedirects()
{
    MYTRACE_ENTER("CCollectionRedirects::~CCollectionRedirects()");

    RemoveAll();
}



//
// Add a new control channel (Thread safe)
//
HRESULT 
CCollectionRedirects::Add( 
    HANDLE_PTR hRedirect,
    ULONG nAdapterIndex,
    BOOL fInboundRedirect
    )
{
    try
    {
        ENTER_AUTO_CS

        CPrimaryControlChannelRedirect cRedirect(hRedirect, nAdapterIndex, fInboundRedirect);

        MYTRACE_ENTER("CCollectionRedirects::Add");

        m_ListOfRedirects.push_back(cRedirect);
        MYTRACE ("Added %d now Total redirect is %d", hRedirect, m_ListOfRedirects.size());
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}


//
// Remove a channel from the list (Thead safe)
//
HRESULT CCollectionRedirects::Remove( 
    HANDLE_PTR hRedirect
    )
{
    HRESULT hr = E_INVALIDARG;
    
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionRedirects::Remove");

        for (LISTOF_REDIRECTS::iterator theIterator = m_ListOfRedirects.begin();
             theIterator != m_ListOfRedirects.end(); 
             theIterator++
            )
        {
            if ((*theIterator).m_hRedirect == hRedirect)
            {
                g_pAlgController->GetNat()->CancelDynamicRedirect(hRedirect);
                m_ListOfRedirects.erase(theIterator);
                hr = S_OK;
                break;
            }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return hr;
}


//
// Remove all redirect that are targeted a for given AdapterIndex
// this is use when an adapter is removed and it had a PrimaryControlChannel
//
HRESULT CCollectionRedirects::RemoveForAdapter( 
    ULONG      nAdapterIndex
    )
{
    HRESULT hr = S_OK;
    
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionRedirects::RemoveForAdapter");
        MYTRACE ("Total redirect is %d looking for %d", m_ListOfRedirects.size(), nAdapterIndex);

        for (LISTOF_REDIRECTS::iterator theIterator = m_ListOfRedirects.begin();
             theIterator != m_ListOfRedirects.end(); 
             theIterator++
            )
        {
	        MYTRACE("Index %d handle %d", (*theIterator).m_nAdapterIndex, (*theIterator).m_hRedirect);

            if ( (*theIterator).m_nAdapterIndex == nAdapterIndex )
            {
                MYTRACE("Found redirect for adapter %d and calling CancelDynamicRedirect", nAdapterIndex);
                g_pAlgController->GetNat()->CancelDynamicRedirect((*theIterator).m_hRedirect);
                m_ListOfRedirects.erase(theIterator);
                theIterator = m_ListOfRedirects.begin(); // start over stl list does not like to have mid node go away in a for loop
            }
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return hr;
}


//
// Same as remove but for all Redirect in part of the collection
//
HRESULT
CCollectionRedirects::RemoveAll()
{
    try
    {
 
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionRedirects::RemoveAll");
        MYTRACE("Collection has %d item(s)", m_ListOfRedirects.size());


        LISTOF_REDIRECTS::iterator itRedirect;

        while ( m_ListOfRedirects.size() > 0 )
        {
            itRedirect = m_ListOfRedirects.begin();

            g_pAlgController->GetNat()->CancelDynamicRedirect((*itRedirect).m_hRedirect);
            m_ListOfRedirects.erase(itRedirect);

        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}

HANDLE_PTR
CCollectionRedirects::FindInboundRedirect(
    ULONG nAdapterIndex
    )
{
    HANDLE_PTR hRedirect = NULL;

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionRedirects::FindInboundRedirect");

        for (LISTOF_REDIRECTS::iterator theIterator = m_ListOfRedirects.begin();
             theIterator != m_ListOfRedirects.end(); 
             theIterator++
            )
        {
            if ((*theIterator).m_nAdapterIndex == nAdapterIndex
                && (*theIterator).m_fInboundRedirect == TRUE)
            {
                hRedirect = (*theIterator).m_hRedirect;
                break;
            }
        }
    }
    catch (...)
    {
    }

    return hRedirect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\collectionalgmodules.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    CollectionAlgModules.cpp

Abstract:

    Implement a thread safe collection of CAlgModules

Author:

    JP Duplessis    (jpdup)  2000.01.19

Revision History:

--*/

#include "PreComp.h"
#include "CollectionAlgModules.h"
#include "AlgController.h"




CCollectionAlgModules::~CCollectionAlgModules()
{
    MYTRACE_ENTER("CCollectionAlgModules::~CCollectionAlgModules()");

    Unload(); 
}



//
// Add a new ALG Module only if it's uniq meaning that if it's alread in the collection 
// it will return the one found and not add a new one
//
CAlgModule*
CCollectionAlgModules::AddUniqueAndStart( 
    CRegKey&    KeyEnumISV,
    LPCTSTR     pszAlgID
    )
{

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAlgModules::AddUniqueAndStart");

        //
        // Is it already in the collection ?
        //
        for (   LISTOF_ALGMODULE::iterator theIterator = m_ThisCollection.begin(); 
                theIterator != m_ThisCollection.end(); 
                theIterator++ 
            )
        {
            if ( _wcsicmp( (*theIterator)->m_szID, pszAlgID) == 0 )
            {
                //
                // Found it already
                //
                MYTRACE("Already loaded nothing to do");
                return (*theIterator);
            }
        }
        //
        // At this point we know that it's not in the collection
        //


        //
        // Get more information on the ALG module
        //
        CRegKey RegAlg;
        RegAlg.Open(KeyEnumISV, pszAlgID, KEY_QUERY_VALUE);

        TCHAR szFriendlyName[MAX_PATH];
        DWORD   dwSize = MAX_PATH;
        RegAlg.QueryValue(szFriendlyName, TEXT("Product"), &dwSize);
        

        //
        // Stuff in a CAlgModule that will be added to the collection
        //
        CAlgModule* pAlg = new CAlgModule(pszAlgID, szFriendlyName);

        if ( !pAlg )
            return NULL;

        HRESULT hr = pAlg->Start();

        if ( FAILED(hr) )
        {
            delete pAlg;
        }

        //
        // Now we know this is a valid and trouble free ALG plug-in we can safely cache it to our collection
        //
        try
        {
            m_ThisCollection.push_back(pAlg);
        }
        catch(...)
        {
            MYTRACE_ERROR("Had problem adding the ALG plun-in to the collection", 0);
            pAlg->Stop();
            delete pAlg;
            return NULL;
        }
        

        return pAlg;
    }
    catch(...)
    {
        return NULL;
    }


    return NULL;
}




//
// Remove a AlgModule from the list (Thead safe)
//
HRESULT CCollectionAlgModules::Remove( 
    CAlgModule* pAlgToRemove
    )
{

    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAlgModules::Remove");

    
        LISTOF_ALGMODULE::iterator theIterator = std::find(
            m_ThisCollection.begin(),
            m_ThisCollection.end(),
            pAlgToRemove
            );

        if ( *theIterator )
        {
            m_ThisCollection.erase(theIterator);
        }

    }
    catch(...)
    {
        return E_FAIL;
    }


    return S_OK;
}


//
// return TRUE is the ALG Module specified by pszAlgProgID
// is currently marked as "Enable"
//
bool
IsAlgModuleEnable(
    CRegKey&    RegKeyISV,
    LPCTSTR     pszAlgID
    )
{

    DWORD dwSize = MAX_PATH;
    TCHAR szState[MAX_PATH];

    LONG nRet = RegKeyISV.QueryValue(
        szState, 
        pszAlgID, 
        &dwSize
        );


    if ( ERROR_SUCCESS != nRet )
        return false;
    
    if ( dwSize == 0 || dwSize > sizeof(szState)*sizeof(TCHAR) )
        return false;


    return ( _wcsicmp(szState, L"Enable") == 0);

};


//
//
//
HRESULT
CCollectionAlgModules::UnloadDisabledModule()
{
    try
    {
        ENTER_AUTO_CS
        MYTRACE_ENTER("CCollectionAlgModules::UnloadDisabledModule()");

        CRegKey KeyEnumISV;
        LONG nError = KeyEnumISV.Open(HKEY_LOCAL_MACHINE, REGKEY_ALG_ISV, KEY_READ);

        bool bAllEnable = false;

        //
        // The total of item in the collectio is the maximum time we should attempt 
        // to verify and unload Alg Module that are disable
        //
        int nPassAttemp = m_ThisCollection.size();         
        
        while ( !bAllEnable && nPassAttemp > 0 )
        {
            bAllEnable = true;

            //
            // For all Module unload if not mark as "ENABLE"
            //
            for (   LISTOF_ALGMODULE::iterator theIterator = m_ThisCollection.begin(); 
                    theIterator != m_ThisCollection.end(); 
                    theIterator++ 
                )
            {
                if ( IsAlgModuleEnable(KeyEnumISV, (*theIterator)->m_szID) )
                {
                    MYTRACE("ALG Module %S is ENABLE", (*theIterator)->m_szFriendlyName);
                }
                else
                {
                    MYTRACE("ALG Module %S is DISABLE", (*theIterator)->m_szFriendlyName);
                    //
                    // Stop/Release/Unload this module it's not enabled
                    //
                    delete (*theIterator);
                    m_ThisCollection.erase(theIterator);

                    bAllEnable = false;
                    break;
                }
            }
            
            nPassAttemp--;      // Ok one pass done 
        }
        
        
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}




//
//
// Enumared the regsitry for all ALG-ISV module and verify that they are sign and CoCreates them and call there  Initialise method
//
//
int	                            // Returns the total number of ISV ALG loaded or -1 for error or 0 is none where setup
CCollectionAlgModules::Load()
{
    MYTRACE_ENTER("CAlgController::LoadAll()");

    int nValidAlgLoaded = 0;

	CRegKey KeyEnumISV;
	LONG nError = KeyEnumISV.Open(HKEY_LOCAL_MACHINE, REGKEY_ALG_ISV, KEY_READ|KEY_ENUMERATE_SUB_KEYS);

    if ( ERROR_SUCCESS != nError )
    {
        MYTRACE_ERROR("Could not open RegKey 'HKLM\\SOFTWARE\\Microsoft\\ALG\\ISV'",nError);
        return nError;
    }


	DWORD dwIndex=0;
	TCHAR szID_AlgToLoad[256];
	DWORD dwKeyNameSize;
	LONG  nRet;


	do
	{
		dwKeyNameSize = 256;

		nRet = RegEnumKeyEx(
			KeyEnumISV.m_hKey,      // handle to key to enumerate
			dwIndex,				// subkey index
			szID_AlgToLoad,         // subkey name
			&dwKeyNameSize,         // size of subkey buffer
			NULL,					// reserved
			NULL,					// class string buffer
			NULL,					// size of class string buffer
			NULL					// last write time
			);

		dwIndex++;

        if ( ERROR_NO_MORE_ITEMS == nRet )
            break;  // All items are enumerated we are done here


		if ( ERROR_SUCCESS == nRet )
		{
            //
            // Must be flag as enable under the main ALG/ISV hive to be loaded
            //
            if ( IsAlgModuleEnable(KeyEnumISV, szID_AlgToLoad) )
            {
                MYTRACE("* %S Is 'ENABLE' make sure it's loaded", szID_AlgToLoad);

                AddUniqueAndStart(KeyEnumISV, szID_AlgToLoad);
            }
            else
            {
                MYTRACE("* %S Is 'DISABLE' will not be loaded", szID_AlgToLoad);
            }
		}
        else
        {
            MYTRACE_ERROR("RegEnumKeyEx", nRet);
        }

	} while ( ERROR_SUCCESS == nRet );



	return nValidAlgLoaded;
}
 





//
// For all loaded ALG moudles calls the STOP method and release any resources
//
HRESULT
CCollectionAlgModules::Unload()
{
    try
    {
        ENTER_AUTO_CS

        MYTRACE_ENTER("CCollectionAlgModules::Unload ***");
        MYTRACE("Colletion size is %d", m_ThisCollection.size());

        HRESULT hr;


        LISTOF_ALGMODULE::iterator theIterator;

        while ( m_ThisCollection.size() > 0 )
        {
            theIterator = m_ThisCollection.begin();
            
            delete (*theIterator);

            m_ThisCollection.erase(theIterator);
        }
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\datachannel.cpp ===
//
// DataChannel.cpp : Implementation of CDataChannel
//
#include "PreComp.h"
#include "DataChannel.h"
#include "AlgController.h"

/////////////////////////////////////////////////////////////////////////////
// CDataChannel


STDMETHODIMP CDataChannel::Cancel()
{
    MYTRACE_ENTER_NOSHOWEXIT("CDataChannel::Cancel()");

    //
    // Normal redirect cancel using original argument pass to CreateRedirect
    //
    HRESULT hr = g_pAlgController->GetNat()->CancelRedirect(
        (UCHAR)m_Properties.eProtocol,
        m_ulDestinationAddress,                             
	    m_usDestinationPort,                               
	    m_ulSourceAddress,                                  
	    m_usSourcePort,
        m_ulNewDestinationAddress,                          
        m_usNewDestinationPort,
	    m_ulNewSourceAddress,                                
	    m_usNewSourcePort 
        );

    return hr;
}

STDMETHODIMP CDataChannel::GetChannelProperties(ALG_DATA_CHANNEL_PROPERTIES** ppProperties)
{
    HRESULT hr = S_OK;
    
    if (NULL != ppProperties)
    {
        *ppProperties = reinterpret_cast<ALG_DATA_CHANNEL_PROPERTIES*>(
            CoTaskMemAlloc(sizeof(ALG_DATA_CHANNEL_PROPERTIES))
            );

        if (NULL != *ppProperties)
        {
            CopyMemory(*ppProperties, &m_Properties, sizeof(ALG_DATA_CHANNEL_PROPERTIES));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;

}


//
// Retrieve the requested event handle. 
// The caller must call CloseHandle on this handle.
// This routine will fail if session creation notification was not requested.
//
// Notification will be triggered when the Channel is open (TCP)
// or when the first UDP packet are received
//
STDMETHODIMP CDataChannel::GetSessionCreationEventHandle(HANDLE* pHandle)
{
    MYTRACE_ENTER("CDataChannel::GetSessionCreationEventHandle");

    if ( pHandle == NULL )
        return E_INVALIDARG;

    if ( !m_hCreateEvent )
        return E_FAIL;

    if ( DuplicateHandle(
            GetCurrentProcess(),
            m_hCreateEvent,
            GetCurrentProcess(),
            pHandle,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            )
        )
    {
        MYTRACE("Duplicated handle from %d to new %d", m_hCreateEvent, *pHandle);
    }
    else
    {

        MYTRACE_ERROR("Duplicating handle", 0);
        return E_FAIL;
    }
    return S_OK;
}


//
// Retrieve the requested event handle. 
// The caller must call CloseHandle on this handle.
// This routine will fail if session deletion notification was not requested.
//
// Notification will be triggered when the Channel is close
// or when UDP packet are now reveice for a period of time.
//
STDMETHODIMP CDataChannel::GetSessionDeletionEventHandle(HANDLE* pHandle)
{
    MYTRACE_ENTER("CDataChannel::GetSessionDeletionEventHandle");

    if ( pHandle == NULL )
        return E_INVALIDARG;

    if ( !m_hDeleteEvent )
        return E_FAIL;

    if ( DuplicateHandle(
            GetCurrentProcess(),
            m_hDeleteEvent,
            GetCurrentProcess(),
            pHandle,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            )
        )
    {
        MYTRACE("Duplicated handle from %d to new %d", m_hDeleteEvent, *pHandle);
    }
    else
    {
        MYTRACE_ERROR("Duplicating handle", 0);
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\enumadapterinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CEnumAdapterInfo
//
// EnumAdapterInfo.cpp : Implementation of CEnumAdapterInfo
//

#include "PreComp.h"
#include "EnumAdapterInfo.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\datachannel.h ===
/////////////////////////////////////////////////////////////////////////////
//
// DataChannel.h : Declaration of the CDataChannel
//
// JPDup 2000.12.10

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CDataChannel
//
class ATL_NO_VTABLE CDataChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CDataChannel, &CLSID_DataChannel>,
	public IDataChannel
{
public:
    CDataChannel()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CDataChannel::NEW");

        m_hCreateEvent=NULL;
        m_hDeleteEvent=NULL;
    }


    ~CDataChannel()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CDataChannel::DELETE");

        if ( m_hCreateEvent )
            CloseHandle((HANDLE)m_hCreateEvent);

        if ( m_hDeleteEvent )
            CloseHandle((HANDLE)m_hDeleteEvent);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DATACHANNEL)
DECLARE_NOT_AGGREGATABLE(CDataChannel)


BEGIN_COM_MAP(CDataChannel)
	COM_INTERFACE_ENTRY(IDataChannel)
END_COM_MAP()

//
// IDataChannel
//
public:
	STDMETHODIMP    GetSessionDeletionEventHandle(
        OUT HANDLE* pHandle
        );

	STDMETHODIMP    GetSessionCreationEventHandle(
        OUT HANDLE* pHandle
        );

	STDMETHODIMP    GetChannelProperties(
        OUT ALG_DATA_CHANNEL_PROPERTIES** ppProperties
        );

	STDMETHODIMP    Cancel();


//
// Properties
//
    
    ALG_DATA_CHANNEL_PROPERTIES     m_Properties;

    //
    // Used to cache the last arguments used to create the redirect
    // will be use to cancel the redirect
    //
    ULONG                           m_ulFlags;

    ULONG                           m_ulSourceAddress;
    USHORT                          m_usSourcePort;
    ULONG                           m_ulDestinationAddress;
    USHORT                          m_usDestinationPort;
    ULONG                           m_ulNewSourceAddress;
    USHORT                          m_usNewSourcePort;
    ULONG                           m_ulNewDestinationAddress;
    USHORT                          m_usNewDestinationPort;

    ULONG                           m_ulRestrictAdapterIndex;

    HANDLE                          m_hCreateEvent;
    HANDLE                          m_hDeleteEvent;
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\enumadapterinfo.h ===
// EnumerateAdapterInfo.h : Declaration of the CAdapterInfo

#pragma once

#include "resource.h"       // main symbols

#include "AdapterInfo.h"


#include <list>

#include "CollectionAdapters.h"


//
// Store the data in a vector of std::strings
//


typedef CComEnumOnSTL<IEnumAdapterInfo, &IID_IEnumAdapterInfo, IAdapterInfo*, _CopyInterface<IAdapterInfo>, LISTOF_ADAPTERS>    ComEnumOnSTL_ForAdapters;





/////////////////////////////////////////////////////////////////////////////
// CEnumAdapterInfo
//
class ATL_NO_VTABLE CEnumAdapterInfo : 
    public ComEnumOnSTL_ForAdapters,
	public CComCoClass<CEnumAdapterInfo, &CLSID_EnumAdapterInfo>
{
public:
	CEnumAdapterInfo()
	{
  	}

DECLARE_REGISTRY_RESOURCEID(IDR_MAPCOLLECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEnumAdapterInfo)
	COM_INTERFACE_ENTRY(IEnumAdapterInfo)
END_COM_MAP()

};



//
// Helper template to create the IEnum
//
template <class EnumType, class CollType>
HRESULT CreateSTLEnumerator(IUnknown** ppUnk, IUnknown* pUnkForRelease, CollType& collection)
{
    if (ppUnk == NULL)
        return E_POINTER;
    *ppUnk = NULL;

    CComObject<EnumType>* pEnum = NULL;
    HRESULT hr = CComObject<EnumType>::CreateInstance(&pEnum);

    if (FAILED(hr))
        return hr;

    hr = pEnum->Init(pUnkForRelease, collection);

    if (SUCCEEDED(hr))
        hr = pEnum->QueryInterface(ppUnk);

    if (FAILED(hr))
        delete pEnum;

    return hr;

} // CreateSTLEnumerator
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//

#pragma once


#define STRICT


#define _ATL_FREE_THREADED

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>




#include "ALG.h"            // From Publish\IDLOLE
#include "ALG_Private.h"	// From ALG\IDL_Private publish in NT\net\inc


//
// Tracing routines
//
#include "MyTrace.h"

#include <ipnatapi.h>


#include "resource.h"
#define REGKEY_ALG_ISV      TEXT("SOFTWARE\\Microsoft\\ALG\\ISV")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\persistentdatachannel.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  PersistentDataChannel.h : Declaration of the CPersistentDataChannel
//
//
//  JPDup   2000.12.10
//

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
//
// CPersistentDataChannel
//
class ATL_NO_VTABLE CPersistentDataChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CPersistentDataChannel, &CLSID_PersistentDataChannel>,
	public IPersistentDataChannel
{

public:

	CPersistentDataChannel()
	{
        m_HandleDynamicRedirect=NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PERSISTENTDATACHANNEL)
DECLARE_NOT_AGGREGATABLE(CPersistentDataChannel)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPersistentDataChannel)
	COM_INTERFACE_ENTRY(IPersistentDataChannel)
END_COM_MAP()

//
// IPersistentDataChannel
//
public:
	STDMETHODIMP    GetChannelProperties(
        OUT ALG_PERSISTENT_DATA_CHANNEL_PROPERTIES ** ppProperties
        );

	STDMETHODIMP    Cancel();

//
// Properties
//
    ALG_PERSISTENT_DATA_CHANNEL_PROPERTIES  m_Properties;
    HANDLE_PTR                              m_HandleDynamicRedirect;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\pendingproxyconnection.h ===
/////////////////////////////////////////////////////////////////////////////
//
// PendingProxyConnection.h : Declaration of the CPendingProxyConnection
//

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CPendingProxyConnection
//
class ATL_NO_VTABLE CPendingProxyConnection : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPendingProxyConnection, &CLSID_PendingProxyConnection>,
	public IPendingProxyConnection
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_PENDINGPROXYCONNECTION)
DECLARE_NOT_AGGREGATABLE(CPendingProxyConnection)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPendingProxyConnection)
	COM_INTERFACE_ENTRY(IPendingProxyConnection)
END_COM_MAP()

//
// IPendingProxyConnection
//
public:
	STDMETHODIMP    Cancel();


//
// Properties
//
public:

    ALG_PROTOCOL				m_eProtocol;
    
	ULONG						m_ulDestinationAddress;
	USHORT						m_usDestinationPort;

    ULONG						m_ulSourceAddress;
	USHORT						m_usSourcePort;

    ULONG						m_ulNewSourceAddress;
	USHORT						m_usNewSourcePort;

    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\persistentdatachannel.cpp ===
//
// PersistentDataChannel.cpp : Implementation of CPersistentDataChannel
//
#include "PreComp.h"
#include "PersistentDataChannel.h"
#include "AlgController.h"


/////////////////////////////////////////////////////////////////////////////
//
// CPersistentDataChannel
//



//
// Cancel the associated DynamicRedirect of the PersistenDataChannel
//
STDMETHODIMP CPersistentDataChannel::Cancel()
{
    HRESULT hr = S_OK;

    if ( m_HandleDynamicRedirect )
    {
        hr = g_pAlgController->GetNat()->CancelDynamicRedirect(m_HandleDynamicRedirect);
    }

	return hr;
}



//
// Return the propreties to an ALG Modules
//
STDMETHODIMP CPersistentDataChannel::GetChannelProperties(ALG_PERSISTENT_DATA_CHANNEL_PROPERTIES **ppProperties)
{
    *ppProperties = &m_Properties;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\primarycontrolchannel.h ===
// PrimaryControlChannel.h : Declaration of the CPrimaryControlChannel

#pragma once


#include "CollectionRedirects.h"

#include "resource.h"       // main symbols
#include <list>



/////////////////////////////////////////////////////////////////////////////
// CPrimaryControlChannel
class ATL_NO_VTABLE CPrimaryControlChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CPrimaryControlChannel, &CLSID_PrimaryControlChannel>,
	public IPrimaryControlChannel
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PRIMARYCONTROLCHANNEL)
DECLARE_NOT_AGGREGATABLE(CPrimaryControlChannel)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPrimaryControlChannel)
	COM_INTERFACE_ENTRY(IPrimaryControlChannel)
END_COM_MAP()


//
// IPrimaryControlChannel - Methods
//
public:
	STDMETHODIMP    Cancel();

	STDMETHODIMP    GetChannelProperties(
        ALG_PRIMARY_CHANNEL_PROPERTIES ** ppProperties
        );

    STDMETHODIMP    GetOriginalDestinationInformation(
	    ULONG				ulSourceAddress, 
	    USHORT				usSourcePort, 
	    ULONG *				pulOriginalDestinationAddress, 
	    USHORT *			pusOriginalDestinationPort, 
	    IAdapterInfo **		ppReceiveAdapter
	    );


//
// Methods not part of the Interface
//


    // Set the redirect and return the hCookie associated with the new redirect
    HRESULT      
    SetRedirect(
        ALG_ADAPTER_TYPE    eAdapterType,
        ULONG               nAdapterIndex,
        ULONG               nAdapterAddress
        );  

    //
    HRESULT
    CancelRedirects()
    {
        return m_CollectionRedirects.RemoveAll();
    }

    //
    HRESULT
    CancelRedirectsForAdapter(
        ULONG               nAdapterIndex
        );

    HRESULT
    CreateInboundRedirect(
        ULONG               nAdapterIndex
        );

//
// Properties
//
    ALG_PRIMARY_CHANNEL_PROPERTIES  m_Properties;

    CCollectionRedirects            m_CollectionRedirects;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\pendingproxyconnection.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CPendingProxyConnection
//
// PendingProxyConnection.cpp : Implementation of CPendingProxyConnection

#include "PreComp.h"
#include "AlgController.h"
#include "PendingProxyConnection.h"



STDMETHODIMP 
CPendingProxyConnection::Cancel()
{
    MYTRACE_ENTER("CPendingProxyConnection::Cancel()");
    MYTRACE("Protocol       %s", m_eProtocol==1? "TCP" : "UDP");
    MYTRACE("Destination    %s:%d", MYTRACE_IP(m_ulDestinationAddress), ntohs(m_usDestinationPort));
    MYTRACE("Source         %s:%d", MYTRACE_IP(m_ulSourceAddress), ntohs(m_usSourcePort));
    MYTRACE("Destination    %s:%d", MYTRACE_IP(m_ulDestinationAddress), ntohs(m_usDestinationPort));
    MYTRACE("NewSource      %s:%d", MYTRACE_IP(m_ulNewSourceAddress), ntohs(m_usNewSourcePort));


    HRESULT hr = g_pAlgController->GetNat()->CancelRedirect(
	    (UCHAR)m_eProtocol,

	    m_ulDestinationAddress,                              
	    m_usDestinationPort,                                 

	    m_ulSourceAddress,                                   
	    m_usSourcePort,                   

        m_ulDestinationAddress,                              
        m_usDestinationPort,                                 

	    m_ulNewSourceAddress,                                
	    m_usNewSourcePort                                    

        );

    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("CancelRedirect", hr);
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\primarycontrolchannel.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    PrimaryControlChannel.cpp.cpp

Abstract:

    Control channel a created to control the life time of a newly created DynamicRedirection

Author:

    JP Duplessis    (jpdup)  08-Dec-2000

Revision History:

--*/

#include "PreComp.h"
#include "PrimaryControlChannel.h"
#include "AlgController.h"



/////////////////////////////////////////////////////////////////////////////
//
// CPrimaryControlChannel
//



//
// Cancel the control channel. Cleans up by Reversing the Redirection
//
STDMETHODIMP CPrimaryControlChannel::Cancel()
{
    MYTRACE_ENTER("STDMETHODIMP CPrimaryControlChannel::Cancel()");


    //
    // No longer valid so no need to keep track of this Channel
    //
    g_pAlgController->m_ControlChannelsPrimary.Remove(this);

    return S_OK;
}



//
//
//
STDMETHODIMP 
CPrimaryControlChannel::GetChannelProperties(
    OUT ALG_PRIMARY_CHANNEL_PROPERTIES** ppProperties
    )
{
    HRESULT hr = S_OK;
    
    if (NULL != ppProperties)
    {
        *ppProperties = reinterpret_cast<ALG_PRIMARY_CHANNEL_PROPERTIES*>(
            CoTaskMemAlloc(sizeof(ALG_PRIMARY_CHANNEL_PROPERTIES))
            );

        if (NULL != *ppProperties)
        {
            CopyMemory(*ppProperties, &m_Properties, sizeof(ALG_PRIMARY_CHANNEL_PROPERTIES));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}





//
// Small helper class to get the IP address of an adapter 
// and release the memory allocated on the destructor
//
class CAdapterAddresses
{
public:
    LRESULT         m_hResultLastState;
    IAdapterInfo*   m_pIAdapter;
    ULONG           m_ulAddressCount;
    ULONG*          m_arAddresses;

    CAdapterAddresses(
        ULONG nIndexOfAdapter
        )
    {
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterAddresses:NEW");

        m_pIAdapter      = NULL;
        m_ulAddressCount = 0;

        m_hResultLastState = g_pAlgController->m_CollectionOfAdapters.GetAdapterInfo(
            nIndexOfAdapter, 
            &m_pIAdapter
            );

        if ( SUCCEEDED(m_hResultLastState) )
        {
            m_arAddresses = NULL;
            m_hResultLastState = m_pIAdapter->GetAdapterAddresses(
                &m_ulAddressCount, 
                &m_arAddresses
                );

            if ( FAILED(m_hResultLastState) )
            {
                MYTRACE_ERROR("Could not get the address", m_hResultLastState);
            }
        }
        else
        {
            MYTRACE_ERROR("On GetAdapterInfo", m_hResultLastState);
        }
    }

    ~CAdapterAddresses()
    {
        MYTRACE_ENTER_NOSHOWEXIT("CAdapterAddresses:DELETE");
        if ( m_pIAdapter )
        {
            m_pIAdapter->Release();

            if ( m_arAddresses )
                CoTaskMemFree(m_arAddresses);
        }
    }

    bool
    FindAddress(
        ULONG  ulAddressToFind
        )
    {
        int nAddress = (int)m_ulAddressCount;

        //
        // Is the original address on the edgebox adapter
        //
        while ( --nAddress >= 0 ) 
        {   
            if ( m_arAddresses[nAddress] == ulAddressToFind )
                return true;
        }
        
        return false;
    }
};



//
//
//
STDMETHODIMP 
CPrimaryControlChannel::GetOriginalDestinationInformation(
    IN           ULONG              ulSourceAddress, 
    IN           USHORT             usSourcePort, 
    OUT          ULONG*             pulOriginalDestinationAddress, 
    OUT          USHORT*            pusOriginalDestinationPort, 
    OUT          IAdapterInfo**     ppReceiveAdapter               
    )
{
    MYTRACE_ENTER("CPrimaryControlChannel::GetOriginalDestinationInformation");
    MYTRACE("Source                   %s:%d", MYTRACE_IP(ulSourceAddress), ntohs(usSourcePort));

    if ( !ppReceiveAdapter )
    {
        MYTRACE_ERROR("Invalid Arg no Pointer supplied for the AdapterInfo", E_INVALIDARG);
        return E_INVALIDARG;
    }

    ULONG   nAdapterIndex;


    HRESULT hr = g_pAlgController->GetNat()->GetOriginalDestinationInformation(
        m_Properties.eProtocol,

        m_Properties.ulListeningAddress,    //  ULONG   DestinationAddress,
        m_Properties.usListeningPort,       //  USHORT  DestinationPort,

        ulSourceAddress,
        usSourcePort,

        pulOriginalDestinationAddress, 
        pusOriginalDestinationPort,
        &nAdapterIndex
        );


    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("Could not GetNat()->GetOriginalDestinationInformation", hr);
        return hr;
    }

    MYTRACE("Original destination is  %s:%d", MYTRACE_IP(*pulOriginalDestinationAddress), ntohs(*pusOriginalDestinationPort));

    //
    // Get the AdapterInfo interface object and list of IP Address
    //
    CAdapterAddresses Adapter(nAdapterIndex);

    if ( FAILED(Adapter.m_hResultLastState) )
    {
        MYTRACE_ERROR("On GetAdapterInfo", hr);
        return Adapter.m_hResultLastState;
    }

    if ( Adapter.m_ulAddressCount==0 )
    {
        //
        // We have a problem there is no IP address on this adapter
        // 
        MYTRACE_ERROR("No address on adapter %d", nAdapterIndex);
        return E_FAIL;
    }

    //
    // Return the AdapterInfo to the caller
    //
    Adapter.m_pIAdapter->AddRef();              // The destructor of CAdapterAddress does a release on this interface so we need to pump it up by one
    *ppReceiveAdapter = Adapter.m_pIAdapter;   



    bool bOriginalAddressIsOnTheEdgeAdapters = Adapter.FindAddress(*pulOriginalDestinationAddress);
        
    //
    // if pulOriginalDestinationAddress match one of the adapter on the edge box
    // then lookup for a remap port
    //
    if ( bOriginalAddressIsOnTheEdgeAdapters )
    {

        //
        // This may be an inbound
        //
        ULONG   nRemapAddress;
        USHORT  nRemapPort;

        HRESULT hr = g_pAlgController->GetNat()->LookupAdapterPortMapping(
            nAdapterIndex,
            m_Properties.eProtocol, 
            *pulOriginalDestinationAddress,
            *pusOriginalDestinationPort,
            &nRemapAddress,
            &nRemapPort
            );

        if ( SUCCEEDED(hr) )  
        {
            //
            // Theres a remap address/Port
            //

            *pulOriginalDestinationAddress = nRemapAddress;
            *pusOriginalDestinationPort    = nRemapPort;
            
            MYTRACE("Remap    destination to  %s:%d", MYTRACE_IP(*pulOriginalDestinationAddress), ntohs(*pusOriginalDestinationPort));        
        }
        else
        {
            //
            // This is just a soft error meaning no mapping where found we can still continue
            //
            MYTRACE("LookupAdapterPortMapping did not find a port maping %x", hr);        
        }
    }


    return hr;
}



//
// Need to remove any redirect that was set for this Adapter
//
HRESULT
CPrimaryControlChannel::CancelRedirectsForAdapter(
    ULONG               nAdapterIndex
    )
{
    return m_CollectionRedirects.RemoveForAdapter(nAdapterIndex);
}



//
//
//
HRESULT
CPrimaryControlChannel::SetRedirect(
    ALG_ADAPTER_TYPE    eAdapterType,
    ULONG               nAdapterIndex,
    ULONG               nAdapterAddress
    )
{
    MYTRACE_ENTER("CPrimaryControlChannel::SetRedirect");
            

    HANDLE_PTR  hCookie;
    HRESULT     hr=S_OK;

    ULONG       nFlags=NatRedirectFlagPortRedirect|NatRedirectFlagRestrictAdapter;
    ULONG       nProtocol=0;
    ULONG       nDestinationAddress=0;
    USHORT      nDestinationPort=0;
    ULONG       nSourceAddress=0;
    USHORT      nSourcePort=0;



    //
    // What type of port is supplied
    //
    if ( m_Properties.eCaptureType == eALG_DESTINATION_CAPTURE )
    {
        MYTRACE("CAPTURE TYPE is eALG_DESTINATION_CAPTURE");

        nDestinationPort    = m_Properties.usCapturePort;
    }

    if ( m_Properties.eCaptureType == eALG_SOURCE_CAPTURE )
    {
        MYTRACE("CAPTURE TYPE is eALG_SOURCE_CAPTURE");

        nFlags |= NatRedirectFlagSourceRedirect;

        nSourcePort         = m_Properties.usCapturePort;
    }






    //
    // ADAPTER IS FIREWALL or SHARED
    //
    if ( (eAdapterType & eALG_FIREWALLED) ||  (eAdapterType & eALG_BOUNDARY) )
    {
        nFlags |= NatRedirectFlagSendOnly;

        MYTRACE("ADAPTER TYPE is %s %s", 
            eAdapterType & eALG_FIREWALLED ? "FIREWALLED"   : "", 
            eAdapterType & eALG_BOUNDARY   ? "SHARED"       : ""  
            );
        MYTRACE("Destination    %s:%d",     MYTRACE_IP(nDestinationAddress), ntohs(nDestinationPort));
        MYTRACE("Source         %s:%d",     MYTRACE_IP(nSourceAddress), ntohs(nSourcePort));
        MYTRACE("NewDestination %s:%d",     MYTRACE_IP(m_Properties.ulListeningAddress), ntohs(m_Properties.usListeningPort));

        //
        // INBOUND Additional Redirect needed
        //
        if ( m_Properties.fCaptureInbound == TRUE)
        {
            MYTRACE("INBOUND requested - Lookup Remap port service to see if we should allow it");

            //
            // Create an additional Redirect for inbound from the Public side to the ICS box
            //

            //
            // before we allow the redirection 
            // See if a maping was set by the user ("under the SERVICE Tab of ICS")
            // 
            ULONG   nRemapAddress;
            USHORT  nRemapPort;

            hr = g_pAlgController->GetNat()->LookupAdapterPortMapping(
                    nAdapterIndex,
                    m_Properties.eProtocol, 
                    nDestinationAddress,
                    nDestinationPort,
                    &nRemapAddress,
                    &nRemapPort
                    );

            if ( SUCCEEDED(hr) )
            {
                MYTRACE("RemapAddress is %s:%d", MYTRACE_IP(nRemapAddress), ntohs(nRemapPort));

                hr = CreateInboundRedirect(nAdapterIndex);
            }
            else
            {
                MYTRACE_ERROR("LookupPortMappingAdapter Failed", hr);
            }

        }

    }
    else
    {
        //
        // ADAPTER IS PRIVATE
        //
        if ( eAdapterType & eALG_PRIVATE )
        {
            MYTRACE("ADAPTER TYPE is PRIVATE");

            CAdapterAddresses PrivateAdapter(nAdapterIndex);

            if ( PrivateAdapter.m_ulAddressCount > 0 )
            {
                MYTRACE("Create Shadow redirect between any private computers to private adapter %s", MYTRACE_IP(PrivateAdapter.m_arAddresses[0]) );
                
                hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
                        NatRedirectFlagReceiveOnly,
                        nAdapterIndex,
                        (UCHAR)    m_Properties.eProtocol,
                        PrivateAdapter.m_arAddresses[0],                    // ULONG    DestinationAddress, 
                        nDestinationPort,                                   // USHORT   DestinationPort,       
                        0,                                                  // ULONG    SourceAddress, 
                        0,                                                  // USHORT    SourcePort,            
                        PrivateAdapter.m_arAddresses[0],                    // ULONG    NewDestinationAddress
                        nDestinationPort,                                   // USHORT   NewDestinationPort
                        0,                                                  // ULONG    NewSourceAddress, 
                        0,                                                  // USHORT    NewSourcePort, 
                        &hCookie
                        );
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_CollectionRedirects.Add(hCookie, nAdapterIndex, FALSE); // Cache the Dynamic redirect Handle            
            }
            else
            {
                MYTRACE_ERROR("Failed to createDynamicRedirect PRIVATE", hr);
            }



            nFlags |= NatRedirectFlagReceiveOnly;

            if ( m_Properties.eCaptureType == eALG_SOURCE_CAPTURE )
            {
                nFlags |= NatRedirectFlagSourceRedirect;
            }
        }
    }


    MYTRACE("CreateDynamicRedirect for OUTBOUND");
    hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
            nFlags,
            nAdapterIndex,
            (UCHAR)    m_Properties.eProtocol,
            nDestinationAddress,                                // ULONG    DestinationAddress, 
            nDestinationPort,                                   // USHORT   DestinationPort,       
            nSourceAddress,                                     // ULONG    SourceAddress, 
            nSourcePort,                                        // USHORT    SourcePort,            
            m_Properties.ulListeningAddress,                    // ULONG    NewDestinationAddress
            m_Properties.usListeningPort,                       // USHORT   NewDestinationPort
            0,                                                  // ULONG    NewSourceAddress, 
            0,                                                  // USHORT    NewSourcePort, 
            &hCookie
            );


    if ( SUCCEEDED(hr) )
    {
        hr = m_CollectionRedirects.Add(hCookie, nAdapterIndex, FALSE); // Cache the Dynamic redirect Handle            
    }
    else
    {
        MYTRACE_ERROR("Failed to createDynamicRedirect PRIVATE", hr);
    }

    return hr;
}

HRESULT
CPrimaryControlChannel::CreateInboundRedirect(
    ULONG               nAdapterIndex
    )
{
    HRESULT hr;
    HANDLE_PTR hCookie;

    MYTRACE_ENTER("CPrimaryControlChannel::SetRedirect");
    
    hr = g_pAlgController->GetNat()->CreateDynamicRedirect(
            NatRedirectFlagPortRedirect|NatRedirectFlagReceiveOnly|NatRedirectFlagRestrictAdapter, 
            nAdapterIndex,
            (UCHAR)m_Properties.eProtocol,
            0,                                                  // ULONG    DestinationAddress, 
            m_Properties.usCapturePort,                         // USHORT   DestinationPort,        
            0,                                                  // ULONG    SourceAddress, 
            0,                                                  // USHORT   SourcePort,
            m_Properties.ulListeningAddress,                    // ULONG    NewDestinationAddress
            m_Properties.usListeningPort,                       // USHORT   NewDestinationPort
            0,                                                  // ULONG    NewSourceAddress, 
            0,                                                  // USHORT   NewSourcePort, 
            &hCookie
            );

    if ( SUCCEEDED(hr) )
    {
        hr = m_CollectionRedirects.Add(hCookie, nAdapterIndex, TRUE);  // Cache the Dynamic redirect Handle
    }
    else
    {
        MYTRACE_ERROR("Failed to CreateDynamicRedirect INBOUND", hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ALG.rc
//
#define IDS_PROJNAME                    100
#define IDR_ALG                         100
#define IDR_ALGCONTROLLER               101
#define IDR_APPLICATIONGATEWAYSERVICES  102
#define IDR_PRIMARYCONTROLCHANNEL       103
#define IDR_SECONDARYCONTROLCHANNEL     104
#define IDR_ADAPTERINFO                 105
#define IDR_PENDINGPROXYCONNECTION      106
#define IDR_DATACHANNEL                 107
#define IDR_PERSISTENTDATACHANNEL       108
#define IDR_ADAPTERNOTIFICATIONSINK     109
#define IDR_CONTROLCHANNEL              110
#define IDR_MAPCOLLECTION               111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\secondarycontrolchannel.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// CSecondaryControlChannel
//
// SecondaryControlChannel.cpp : Implementation of CSecondaryControlChannel
//

#include "PreComp.h"
#include "AlgController.h"
#include "SecondaryControlChannel.h"







//
// Cancel the redirect when it was created we stored the original demanded addresses & ports
// now we need to reverse(Cancel) them
//
STDMETHODIMP 
CSecondaryControlChannel::Cancel()
{
    //
    // By removing this Channel from the collection of SecondaryChannel
    // the Redirect associated with this channel will be cancel(release)
    // and ref count decrement.

    return g_pAlgController->m_ControlChannelsSecondary.Remove(this);
}



STDMETHODIMP 
CSecondaryControlChannel::GetChannelProperties(
    ALG_SECONDARY_CHANNEL_PROPERTIES** ppProperties
    )
{
    HRESULT hr = S_OK;
    
    if (NULL != ppProperties)
    {
        *ppProperties = reinterpret_cast<ALG_SECONDARY_CHANNEL_PROPERTIES*>(
            CoTaskMemAlloc(sizeof(ALG_SECONDARY_CHANNEL_PROPERTIES))
            );

        if (NULL != *ppProperties)
        {
            CopyMemory(*ppProperties, &m_Properties, sizeof(ALG_SECONDARY_CHANNEL_PROPERTIES));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}



//
//
//
STDMETHODIMP 
CSecondaryControlChannel::GetOriginalDestinationInformation(
    IN           ULONG          ulSourceAddress, 
    IN           USHORT         usSourcePort, 
    OUT          ULONG*         pulOriginalDestinationAddress, 
    OUT          USHORT*        pusOriginalDestinationPort, 
    OUT OPTIONAL IAdapterInfo** ppReceiveAdapter               
    )
{
    MYTRACE_ENTER("CSecondaryControlChannel::GetOriginalDestinationInformation");

    if (    pulOriginalDestinationAddress==NULL ||
            pusOriginalDestinationPort== NULL
        )
    {
        MYTRACE_ERROR("Invalid argument pass pulOriginalDestinationAddress or pulOriginalDestinationPort", E_INVALIDARG);
        return E_INVALIDARG;
    }


    ULONG   nAdapterCookie;

    HRESULT hr = g_pAlgController->GetNat()->GetOriginalDestinationInformation(
        m_Properties.eProtocol,
        m_ulNewDestinationAddress,
        m_usNewDestinationPort,
        ulSourceAddress,
        usSourcePort,
        pulOriginalDestinationAddress, 
        pusOriginalDestinationPort,
        &nAdapterCookie
        );



    if ( FAILED(hr) )
    {
        MYTRACE_ERROR("GetNat()->GetOriginalDestinationInformation", hr);
        return hr;
    }


    if ( ppReceiveAdapter )
    {
        hr = g_pAlgController->m_CollectionOfAdapters.GetAdapterInfo(
            nAdapterCookie, 
            ppReceiveAdapter
            );
    }

    return hr;

}




//
// Public method
// 
// release associated Redirects
//
HRESULT    
CSecondaryControlChannel::CancelRedirects()
{
    HRESULT hr;

    if ( m_HandleDynamicRedirect )
    {
        //
        // We have a handle to a dynamic redirect so we cancel it using this handle
        //
        hr = g_pAlgController->GetNat()->CancelDynamicRedirect(m_HandleDynamicRedirect);
    }
    else
    {
        //
        // Normal redirect cancel using original argument pass to CreateRedirect
        //
        hr = g_pAlgController->GetNat()->CancelRedirect(
            (UCHAR)m_Properties.eProtocol,
            m_ulDestinationAddress,                             
            m_usDestinationPort,                               
            m_ulSourceAddress,                                  
            m_usSourcePort,
            m_ulNewDestinationAddress,                          
            m_usNewDestinationPort,
            m_ulNewSourceAddress,                                
            m_usNewSourcePort 
            );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\scopecriticalsection.h ===
#pragma once

//
// This is a generic class that wraps a given CComAutoCriticalSection
//
class CScopeCriticalSection
{

private:
	CComAutoCriticalSection* m_pCriticalSection;

public:
	CScopeCriticalSection(CComAutoCriticalSection* pNewCS) : 
      m_pCriticalSection(pNewCS) 
    {
        Lock();
    }

	~CScopeCriticalSection() 
    {
        Unlock();
    }

    void
    inline Lock()
    {
        m_pCriticalSection->Lock();
    }


    void
    inline Unlock()
    {
        m_pCriticalSection->Unlock();
    }

};


#define ENTER_AUTO_CS CScopeCriticalSection _ScopeAutoCriticalSection(&m_AutoCS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Application Layer Gateway Service"
#define VER_INTERNALNAME_STR            "ALG.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\beacon.h ===
#pragma once

#include "stdafx.h"
#include "netconp.h"

class ATL_NO_VTABLE CInternetGateway :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IInternetGateway
{

public:
    BEGIN_COM_MAP(CInternetGateway)
        COM_INTERFACE_ENTRY(IInternetGateway)
    END_COM_MAP()
    
    CInternetGateway();
    
    // IInternetGateway
    STDMETHODIMP GetMediaType(NETCON_MEDIATYPE* pMediaType);
    STDMETHODIMP GetLocalAdapterGUID(GUID* pGuid);
    STDMETHODIMP GetService(SAHOST_SERVICES ulService, IUPnPService**);
    STDMETHODIMP GetUniqueDeviceName(BSTR* pUniqueDeviceName);

    HRESULT SetMediaType(NETCON_MEDIATYPE MediaType);
    HRESULT SetLocalAdapterGUID(GUID* pGuid);
    HRESULT SetService(ULONG ulService, IUPnPService* pService);
    HRESULT SetUniqueDeviceName(BSTR UniqueDeviceName);
    HRESULT FinalRelease();
private:
    
    NETCON_MEDIATYPE m_MediaType;
    GUID m_LocalAdapterGUID;
    IUPnPService* m_Services[SAHOST_SERVICE_MAX];
    BSTR m_UniqueDeviceName;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\beacon.cpp ===
#include "beacon.h"

CInternetGateway::CInternetGateway()
{
    m_MediaType = NCM_NONE;
    ZeroMemory(&m_LocalAdapterGUID, sizeof(m_LocalAdapterGUID));
    ZeroMemory(&m_Services, sizeof(m_Services));
    m_UniqueDeviceName = NULL;
}

HRESULT CInternetGateway::FinalRelease()
{
    for(int i = 0; i < SAHOST_SERVICE_MAX; i++)
    {
        if(NULL != m_Services[i])
        {
            m_Services[i]->Release();
        }
    }

    SysFreeString(m_UniqueDeviceName);

    return S_OK;
}

HRESULT CInternetGateway::SetMediaType(NETCON_MEDIATYPE MediaType)
{
    m_MediaType = MediaType;
    return S_OK;
}

HRESULT CInternetGateway::SetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(&m_LocalAdapterGUID, pGuid, sizeof(GUID));
    return S_OK;
}

HRESULT CInternetGateway::SetService(ULONG ulService, IUPnPService* pService)
{
    HRESULT hr = S_OK;
    if(SAHOST_SERVICE_MAX > ulService && NULL == m_Services[ulService])
    {
        m_Services[ulService] = pService;
        pService->AddRef();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CInternetGateway::SetUniqueDeviceName(BSTR UniqueDeviceName)
{
    HRESULT hr = S_OK;

    m_UniqueDeviceName = SysAllocString(UniqueDeviceName);
    if(NULL == m_UniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CInternetGateway::GetMediaType(NETCON_MEDIATYPE* pMediaType)
{
    *pMediaType = m_MediaType;    
    return S_OK;
}

HRESULT CInternetGateway::GetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(pGuid, &m_LocalAdapterGUID, sizeof(GUID));
    return S_OK;
}

HRESULT CInternetGateway::GetService(SAHOST_SERVICES ulService, IUPnPService** ppService)
{
    HRESULT hr = S_OK;

    *ppService = NULL;

    if(SAHOST_SERVICE_MAX > ulService)
    {
        *ppService = m_Services[ulService];
        if(NULL != *ppService)
        {
            (*ppService)->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CInternetGateway::GetUniqueDeviceName(BSTR* pUniqueDeviceName)
{
    HRESULT hr = S_OK;

    *pUniqueDeviceName = SysAllocString(m_UniqueDeviceName);
    if(NULL == *pUniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\inc\mytrace.h ===
#pragma once

#include <stdio.h>
#include <stdarg.h>
#include <stdio.h>
#include <Rtutils.h>
#include <Winsock.h>

extern DWORD    g_dwTraceId;                                

#if defined(DBG) || defined(_DEBUG)
    #define MYTRACE_ENABLE                      DWORD g_dwTraceId=0;  int CMyDebugTrace::m_nIndent=-1; 
    #define MYTRACE_START(UNIQUE_NAME)          g_dwTraceId = TraceRegister(UNIQUE_NAME); // TRACE_USE_FILE
    #define MYTRACE_STOP                        TraceDeregister(g_dwTraceId);

    #define MYTRACE_ENTER(MSG)                  CMyDebugTrace   _NewMyTrace(MSG, __FILE__, __LINE__, true);
    #define MYTRACE_ENTER_EXTRA_SPACE(MSG)      CMyDebugTrace   _NewMyTrace(MSG, __FILE__, __LINE__, true,1);
    #define MYTRACE_ENTER_NOSHOWEXIT(MSG)       CMyDebugTrace   _NewMyTrace(MSG, __FILE__, __LINE__, false);
    #define MYTRACE_ERROR(MSG,ERROR_NUMBER)     _NewMyTrace.TraceError(MSG, ERROR_NUMBER, __LINE__);
    #define MYTRACE_IP(ULONG_ADDRESS)           _NewMyTrace.IP2A(ULONG_ADDRESS)
    #define MYTRACE                             _NewMyTrace.MyTrace
    #define MYTRACE_BUFFER2STR(BUFF, NLEN)      _NewMyTrace.Buffer2Str(BUFF, NLEN)
#else
    #define MYTRACE_ENABLE              
    #define MYTRACE_START(UNIQUE_NAME)  
    #define MYTRACE_STOP                

    #define MYTRACE_ENTER(MSG)
    #define MYTRACE_ENTER_EXTRA_SPACE(MSG)
    #define MYTRACE_ENTER_NOSHOWEXIT(MSG)
    #define MYTRACE_ERROR(MSG,ERROR_NUMBER)
    #define MYTRACE_IP(ULONG_ADDRESS)   0
    #define MYTRACE
    #define MYTRACE_BUFFER2STR(BUFF, NLEN) 0
#endif



//#define DOTRACE(ID, str)
#define DOTRACE(ID, str)    TracePrintf(g_dwTraceId, str);
//#define DOTRACE(ID, str)    OutputDebugString(str);OutputDebugString(L"\n");
//#define DOTRACE(ID, str)    MessageBox(NULL,str,m_szMsgEnter,MB_OK|MB_SERVICE_NOTIFICATION);







class CMyDebugTrace
{
public:
    CMyDebugTrace(
        LPCSTR      szMsgEnter, 
        LPCSTR      szFile, 
        const int   nLine,
        bool        bShowExit,
        int         nExtraWhiteSpace=0
        )
    {
        USES_CONVERSION;
        m_nExtraSpace = nExtraWhiteSpace;
        m_bShowExit = bShowExit;
        lstrcpy(m_szMsgEnter,    A2T(szMsgEnter));

        // From the entry/creation text we extract the function name 
        // example   "CFoo::Format" we will have CFoo to prefix in front of all traces done after
        lstrcpy(m_szFunction, A2T(szMsgEnter));
        wchar_t* pEnd = wcschr(m_szFunction, L':');
        if ( pEnd )
            *pEnd = L'\0';
        else
            lstrcpy(m_szFunction, L"");


        lstrcpy(m_szFile,   A2T(szFile));
        
        m_nIndent++;
        
        wsprintf(
            m_szTrace, 
            L"%s%s %s", 
            SzRepeat(m_nIndent), 
            m_bShowExit ? L"++" : L"+-",
            m_szMsgEnter
            );

        int nLen = lstrlen(m_szTrace);

        wsprintf(
            m_szTrace,
            L"%s%s[L%d]%s",
            m_szTrace,
            SzRepeat(80-nLen),
            nLine,
            m_szFile
            );
            
        if ( m_nExtraSpace != 0 )
            DOTRACE(g_dwTraceId, TEXT(""));

        DOTRACE(g_dwTraceId, m_szTrace);
    }

    ~CMyDebugTrace()
    {
        if ( m_bShowExit )
        {
    
            wsprintf(m_szTrace, L"%s-- %s", SzRepeat(m_nIndent), m_szMsgEnter);
            DOTRACE(g_dwTraceId, m_szTrace);

            if ( m_nExtraSpace != 0 )
                DOTRACE(g_dwTraceId, TEXT(""));
        }

        m_nIndent--;
    }


    //
    // Output to the debug window a user trace
    //
    inline void _cdecl MyTrace(LPCSTR lpszFormat, ...)
    {
    #if defined(DBG) || defined(_DEBUG)

        USES_CONVERSION;
        va_list args;
        va_start(args, lpszFormat);

        char szBuffer[2048];

        _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);

        TCHAR szLine[2048];
        wsprintf(szLine, L"%s%s   %s", SzRepeat(CMyDebugTrace::m_nIndent+3), m_szFunction, A2T(szBuffer));
        DOTRACE(g_dwTraceId, szLine);

        va_end(args);

    #endif
    }


    //
    // Output a debug trace for a error including Line number and source file name
    //
    inline void 
    TraceError(
        LPCSTR      szMsg, 
        int         nError,
        const int   nLine
        )
    {
        USES_CONVERSION;
	    TCHAR   szBuffer[512];

        //
        // No Error # was given so lets get the last one raised
        //
        if ( nError == 0 )
            nError = GetLastError();
    
        wsprintf(szBuffer, L"%s  %s   ERROR(0x%X):%s               [L%d]%s", SzRepeat(CMyDebugTrace::m_nIndent), m_szMsgEnter, nError, A2T(szMsg), nLine, m_szFile);
        DOTRACE(g_dwTraceId, szBuffer);
    }

    //
    // Return the ascii equivalent of the IP example "192.168.0.1"
    //
    inline char*
    IP2A(ULONG ulAddress)
    {
        in_addr tmpAddr;
        tmpAddr.s_addr = ulAddress;
        return inet_ntoa(tmpAddr);
    }


    inline char*
    Buffer2Str(char* pBuff, int nLen)
    {
        static char szPrintableStr[1024];
        memcpy(szPrintableStr, pBuff, min(nLen,1022));
        szPrintableStr[min(nLen,1023)] = '\0';

        int nLenMin = strlen(szPrintableStr);

        for ( int nChar=0; nChar < nLenMin; nChar++ )
        {
            if ( isprint(szPrintableStr[nChar])==0 )
                szPrintableStr[nChar] =  '';
        }

        return szPrintableStr;
    }

    //
    // Return a left paded space indentation
    //
    inline LPCTSTR 
    SzRepeat(int nCount)
    {
        static TCHAR szPading[200];

        lstrcpy(szPading, L"");

        for ( int nI=0; nI < nCount; nI++ )
            lstrcat(szPading, L" ");

        return szPading;
    }
    int         m_nExtraSpace;
    bool        m_bShowExit;
    TCHAR       m_szTrace[512];
    TCHAR       m_szMsgEnter[1024];
    TCHAR       m_szFunction[256];
    TCHAR       m_szFile[256];
    static      int m_nIndent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\alg\exe\secondarycontrolchannel.h ===
// SecondaryControlChannel.h : Declaration of the CSecondaryControlChannel

#pragma once

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CSecondaryControlChannel
class ATL_NO_VTABLE CSecondaryControlChannel : 
	public CComObjectRootEx<CComMultiThreadModel>, 
	public CComCoClass<CSecondaryControlChannel, &CLSID_SecondaryControlChannel>,
	public ISecondaryControlChannel
{
public:
	CSecondaryControlChannel()
	{
        m_HandleDynamicRedirect = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SECONDARYCONTROLCHANNEL)
DECLARE_NOT_AGGREGATABLE(CSecondaryControlChannel)


BEGIN_COM_MAP(CSecondaryControlChannel)
	COM_INTERFACE_ENTRY(ISecondaryControlChannel)
END_COM_MAP()

// ISecondaryControlChannel
public:


	STDMETHODIMP    Cancel();

	STDMETHODIMP    GetChannelProperties(
        ALG_SECONDARY_CHANNEL_PROPERTIES ** ppProperties
        );

    STDMETHODIMP    GetOriginalDestinationInformation(
	    ULONG				ulSourceAddress, 
	    USHORT				usSourcePort, 
	    ULONG *				pulOriginalDestinationAddress, 
	    USHORT *			pusOriginalDestinationPort, 
	    IAdapterInfo **		ppReceiveAdapter
	    );

//
// Methods
//
    HRESULT         CancelRedirects();

//
// Properties
//

    ALG_SECONDARY_CHANNEL_PROPERTIES    m_Properties;

    

    // Cache original argument of the redirect


    // Dynamic Redirect
    HANDLE_PTR                          m_HandleDynamicRedirect;

    // None dynamic redirect
    ULONG                               m_ulDestinationAddress;
    USHORT                              m_usDestinationPort;       

    ULONG                               m_ulSourceAddress;         
    USHORT                              m_usSourcePort;

    ULONG                               m_ulNewDestinationAddress; 
    USHORT                              m_usNewDestinationPort;    

    ULONG                               m_ulNewSourceAddress;      
    USHORT                              m_usNewSourcePort;



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\client.h ===
#pragma once

#include "beacon.h"
#include <upnp.h>

class ATL_NO_VTABLE CBeaconFinder :
    public CComObjectRootEx <CComSingleThreadModel>,
    public IUPnPDeviceFinderCallback
{

public:
    BEGIN_COM_MAP(CBeaconFinder)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT();

    CBeaconFinder();
    
    STDMETHODIMP DeviceAdded(LONG lFindData, IUPnPDevice* pDevice); 
    STDMETHODIMP DeviceRemoved(LONG lFindData, BSTR bstrUDN); 
    STDMETHODIMP SearchComplete(LONG lFindData); 

    HRESULT Initialize(HWND hCallbackWindow);

private:
    HRESULT FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService);
    HRESULT FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT GetServices(IUPnPDevice* pDevice, IInternetGateway** ppInternetGateway);
    HRESULT IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch);
    
    HWND m_hCallbackWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "icsdclt_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\client.cpp ===
#include "stdafx.h"
#include <windows.h>
#include "client.h"
#include "trayicon.h"
#include "resource.h"
#include "util.h"
#include "shellapi.h"
#include "winsock2.h"


static const LPTSTR g_szWindowTitle = TEXT("Internet Gateway Status");
static const LPWSTR g_szWANIPConnectionService = L"urn:schemas-upnp-org:service:WANIPConnection:1";
static const LPWSTR g_szWANPPPConnectionService = L"urn:schemas-upnp-org:service:WANPPPConnection:1";

void CALLBACK ICSClient(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;

    // first see if app is already running and if so activate status window
    
    HWND hExistingWindow = FindWindow(NULL, g_szWindowTitle); // check only current winstation, every login session can have an instance
    if(NULL != hExistingWindow)
    {
        if(0 == lstrcmp(lpszCmdLine, TEXT("/force"))) // secret command line to close existing instance and run new one instead
        {
            ::PostMessage(hExistingWindow, WM_CLOSE, NULL, NULL);
        }
        else if(0 == lstrcmp(lpszCmdLine, TEXT("/close"))) // secret command line to close existing instance 
        {
            ::PostMessage(hExistingWindow, WM_CLOSE, NULL, NULL);
            hr = E_FAIL;
        }
        else
        {
            DWORD dwProcessId = NULL;
            GetWindowThreadProcessId(hExistingWindow, &dwProcessId); // no documented error return
            
            HMODULE hUser32 = GetModuleHandle(TEXT("user32.dll"));
            if(NULL != hUser32)
            {
                BOOL (WINAPI *pAllowSetForegroundWindow)(DWORD);
                
                pAllowSetForegroundWindow = reinterpret_cast<BOOL (WINAPI*)(DWORD)>(GetProcAddress(hUser32, "AllowSetForegroundWindow"));
                if(NULL != pAllowSetForegroundWindow)
                {
                    pAllowSetForegroundWindow(dwProcessId);
                }
            }
            
            ::PostMessage(hExistingWindow, WM_COMMAND, IDM_TRAYICON_STATUS, NULL);
            hr = E_FAIL;
        }
    }
    
    // if this is first instance then start up the main apartment
    
    if(SUCCEEDED(hr))
    {
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if(SUCCEEDED(hr))
        {
            WSADATA SocketVersionData;
            if(0 == WSAStartup(MAKEWORD(2,2), &SocketVersionData))
            {
            
                CICSTrayIcon TrayIcon;
                HWND hWindow = TrayIcon.Create(NULL, CWindow::rcDefault, g_szWindowTitle, WS_OVERLAPPEDWINDOW);
                if(NULL != hWindow)
                {
                    BOOL bGetMessage;
                    MSG Message;
                    while(bGetMessage = GetMessage(&Message, NULL, 0, 0) && -1 != bGetMessage)
                    {
                        DispatchMessage(&Message);
                    }
                }
                WSACleanup();
            }
            CoUninitialize();
        }
    }
    return;
}

CBeaconFinder::CBeaconFinder()
{
    m_hCallbackWindow = NULL;
}

HRESULT CBeaconFinder::Initialize(HWND hCallbackWindow)
{
    HRESULT hr = S_OK;
    
    m_hCallbackWindow = hCallbackWindow;
    
    return hr;
}

HRESULT CBeaconFinder::DeviceAdded(LONG lFindData, IUPnPDevice* pDevice)
{
    HRESULT hr = S_OK;
    
    if(SUCCEEDED(hr))
    {
        IInternetGateway* pInternetGateway;
        hr = GetServices(pDevice, &pInternetGateway);
        if(SUCCEEDED(hr))
        {
            SendMessage(m_hCallbackWindow, WM_APP_ADDBEACON, 0, reinterpret_cast<LPARAM>(pInternetGateway));
            pInternetGateway->Release();
        }
    }
    

    return hr;
}

HRESULT CBeaconFinder::DeviceRemoved(LONG lFindData, BSTR bstrUDN)
{

    SendMessage(m_hCallbackWindow, WM_APP_REMOVEBEACON, 0, reinterpret_cast<LPARAM>(bstrUDN));

    return S_OK;
}

HRESULT CBeaconFinder::SearchComplete(LONG lFindData)
{
    HRESULT hr = S_OK;

    // don't care

    return hr;
}

HRESULT CBeaconFinder::GetServices(IUPnPDevice* pDevice, IInternetGateway** ppInternetGateway)
{
    HRESULT hr = S_OK;
    
    *ppInternetGateway = NULL;

    CComObject<CInternetGateway>* pInternetGateway;
    hr = CComObject<CInternetGateway>::CreateInstance(&pInternetGateway);    
    if(SUCCEEDED(hr))
    {
        pInternetGateway->AddRef();

        BSTR pUniqueDeviceName;
        hr = pDevice->get_UniqueDeviceName(&pUniqueDeviceName);
        if(SUCCEEDED(hr))
        {
            hr = pInternetGateway->SetUniqueDeviceName(pUniqueDeviceName);
            SysFreeString(pUniqueDeviceName);
        }
        
        if(SUCCEEDED(hr))
        {
            
            IUPnPService* pOSInfoService;
            hr = FindService(pDevice, L"urn:schemas-microsoft-com:service:OSInfo:1", &pOSInfoService); // this service is not required
            if(SUCCEEDED(hr))
            {
                pInternetGateway->SetService(SAHOST_SERVICE_OSINFO, pOSInfoService);
                pOSInfoService->Release();
            }
            
            IUPnPDevice* pWANDevice;
            hr = FindChildDevice(pDevice, L"urn:schemas-upnp-org:device:WANDevice:1", &pWANDevice);
            if(SUCCEEDED(hr))
            {
                
                IUPnPService* pWANCommonInterfaceConfigService;
                hr = FindService(pWANDevice, L"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1", &pWANCommonInterfaceConfigService);
                if(SUCCEEDED(hr))
                {
                    pInternetGateway->SetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, pWANCommonInterfaceConfigService);
                    
                    IUPnPDevice* pWANCommonDevice;
                    hr = FindChildDevice(pWANDevice, L"urn:schemas-upnp-org:device:WANConnectionDevice:1", &pWANCommonDevice);
                    if(SUCCEEDED(hr))
                    {
                        IUPnPService* pWANConnectionService;
                        hr = FindService(pWANCommonDevice, NULL, &pWANConnectionService);
                        if(SUCCEEDED(hr))
                        {
                            BSTR ServiceType;
                            hr = pWANConnectionService->get_ServiceTypeIdentifier(&ServiceType);
                            if(SUCCEEDED(hr))
                            {
                                if(0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
                                {
                                    pInternetGateway->SetMediaType(NCM_SHAREDACCESSHOST_RAS);
                                    pInternetGateway->SetService(SAHOST_SERVICE_WANPPPCONNECTION, pWANConnectionService);
                                }
                                else // we can assume this is WANPPPConnectionService
                                {
                                    pInternetGateway->SetMediaType(NCM_SHAREDACCESSHOST_LAN);
                                    pInternetGateway->SetService(SAHOST_SERVICE_WANIPCONNECTION, pWANConnectionService);
                                }
                                
                                SysFreeString(ServiceType);
                            }
                            pWANConnectionService->Release();
                        }
                        pWANCommonDevice->Release();
                    }
                    pWANCommonInterfaceConfigService->Release();
                }
                pWANDevice->Release();
            }
        }
        
        if(SUCCEEDED(hr))
        {
            *ppInternetGateway = static_cast<IInternetGateway*>(pInternetGateway);
            (*ppInternetGateway)->AddRef();
        }
        pInternetGateway->Release();
    }
    return hr;
}

HRESULT CBeaconFinder::FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;
    
    IUPnPDevices* pDevices;
    hr = pDevice->get_Children(&pDevices);
    if(SUCCEEDED(hr))
    {
        hr = FindDevice(pDevices, pszDeviceType, ppChildDevice);
        pDevices->Release();
    }
    return hr;
}


HRESULT CBeaconFinder::FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;

    *ppChildDevice = NULL;

    IUnknown* pEnumerator;
    hr = pDevices->get__NewEnum(&pEnumerator);
    
    if (SUCCEEDED(hr))
    {
        IEnumVARIANT* pVariantEnumerator;
        hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
        if (SUCCEEDED(hr))
        {
            VARIANT DeviceVariant;
            
            VariantInit(&DeviceVariant);
            
            pVariantEnumerator->Reset();
            
            // Traverse the collection.
            
            while (NULL == *ppChildDevice && S_OK == pVariantEnumerator->Next(1, &DeviceVariant, NULL))
            {
                IDispatch   * pDeviceDispatch = NULL;
                IUPnPDevice * pDevice = NULL;
                
                pDeviceDispatch = V_DISPATCH(&DeviceVariant);
                hr = pDeviceDispatch->QueryInterface(IID_IUPnPDevice, reinterpret_cast<void **>(&pDevice));
                if (SUCCEEDED(hr))
                {
                    BSTR Type;
                    hr = pDevice->get_Type(&Type);
                    if(SUCCEEDED(hr))
                    {
                        if(0 == wcscmp(Type, pszDeviceType))
                        {
                            *ppChildDevice = pDevice;
                            pDevice->AddRef();

                        }
                        SysFreeString(Type);
                    }                    
                    pDevice->Release();
                }
                VariantClear(&DeviceVariant);                                
            };
            
            if(NULL == *ppChildDevice)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            pVariantEnumerator->Release();
        }
        pEnumerator->Release();
    }
    return hr;

    
}

HRESULT CBeaconFinder::FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService)
{
    HRESULT hr;

    *ppICSService = NULL;

    IUPnPServices* pServices;        
    hr = pDevice->get_Services(&pServices);
    if (SUCCEEDED(hr))
    {
        IUnknown* pEnumerator;
        hr = pServices->get__NewEnum(&pEnumerator);
        if (SUCCEEDED(hr))
        {
            IEnumVARIANT* pVariantEnumerator;
            hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
            if (SUCCEEDED(hr))
            {
                VARIANT ServiceVariant;
                
                VariantInit(&ServiceVariant);
                
                while (NULL == *ppICSService && S_OK == pVariantEnumerator->Next(1, &ServiceVariant, NULL))
                {
                    IDispatch   * pServiceDispatch = NULL;
                    IUPnPService * pService = NULL;
                    
                    pServiceDispatch = V_DISPATCH(&ServiceVariant);
                    hr = pServiceDispatch->QueryInterface(IID_IUPnPService, reinterpret_cast<void **>(&pService));
                    if (SUCCEEDED(hr))
                    {
                        BOOL bMatch;
                        hr = IsServiceMatch(pService, pszServiceName, &bMatch);
                        if(SUCCEEDED(hr) && TRUE == bMatch)
                        {
                            *ppICSService = pService;
                            pService->AddRef();
                        }
                        pService->Release();
                    }
                    VariantClear(&ServiceVariant);
                }
                if(NULL == *ppICSService)
                {
                    hr = E_FAIL;
                }                   
                pVariantEnumerator->Release();
            }
            pEnumerator->Release();
        }
        pServices->Release();
    }
    return hr;
}

HRESULT CBeaconFinder::IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch)
{
    HRESULT hr = S_OK;

    *pbMatch = FALSE;
    
    BSTR ServiceType;
    hr = pService->get_ServiceTypeIdentifier(&ServiceType);
    if(SUCCEEDED(hr))
    {
        if(NULL != SearchCriteria) // if the caller provides a name then we search for it
        {
            if(0 == wcscmp(ServiceType, SearchCriteria))
            {
                *pbMatch = TRUE;
            }                            
        }
        else // otherwise we enter the special search case
        {
            if(0 == wcscmp(ServiceType, g_szWANIPConnectionService) || 0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
            {
                VARIANT OutArgsGetConnectionTypeInfo;
                hr = InvokeVoidAction(pService, L"GetConnectionTypeInfo", &OutArgsGetConnectionTypeInfo);
                if(SUCCEEDED(hr))
                {
                    VARIANT ConnectionType;
                    LONG lIndex = 0;
                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetConnectionTypeInfo), &lIndex, &ConnectionType);
                    if(SUCCEEDED(hr))
                    {
                        if(V_VT(&ConnectionType) == VT_BSTR)
                        {
                            if(0 == wcscmp(V_BSTR(&ConnectionType), L"IP_Routed"))
                            {
                                VARIANT OutArgsGetNATRSIPStatus;
                                hr = InvokeVoidAction(pService, L"GetNATRSIPStatus", &OutArgsGetNATRSIPStatus);
                                if(SUCCEEDED(hr))
                                {
                                    VARIANT NATEnabled;
                                    lIndex = 1;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetNATRSIPStatus), &lIndex, &NATEnabled);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&NATEnabled) == VT_BOOL)
                                        {
                                            if(VARIANT_TRUE == V_BOOL(&NATEnabled))
                                            {
                                                *pbMatch = TRUE;
                                            }
                                        }
                                        VariantClear(&NATEnabled);
                                    }
                                    VariantClear(&OutArgsGetNATRSIPStatus);
                                }
                            }
                        }
                        VariantClear(&ConnectionType);
                    }
                    VariantClear(&OutArgsGetConnectionTypeInfo);
                }
            }
        }
        SysFreeString(ServiceType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__9B23B3D8_8B85_4FDF_BC3E_83D5A56E02C0__INCLUDED_)
#define AFX_DLLDATAX_H__9B23B3D8_8B85_4FDF_BC3E_83D5A56E02C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__9B23B3D8_8B85_4FDF_BC3E_83D5A56E02C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\dllmain.cpp ===
// testatl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for testatl.idl by adding the following 
//      files to the Outputs.
//          testatl_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f testatlps.mk in the project directory.

#include <stdafx.h>
#include <ole2.h>
#include "resource.h"
#include <initguid.h>
#include "dlldatax.h"

#include "icsdclt_i.c"
#include "InternetGatewayFinder.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#include "atlbase.h"
CComModule _Module;
#include "atlcom.h"

#include "NATUPnP.h"
#include "UPnPNAT.h"

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPNAT, CUPnPNAT)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\internetgatewayfinder.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "InternetGatewayFinder.h"
#include "trayicon.h"

CInternetGatewayFinder::CInternetGatewayFinder()
{
    m_hWindow = NULL;
}

HRESULT CInternetGatewayFinder::Initialize(HWND hWindow)
{
    HRESULT hr = S_OK;
    
    m_hWindow = hWindow;
    
    return hr;    
}

HRESULT CInternetGatewayFinder::GetInternetGateway(BSTR DeviceId, IInternetGateway** ppInternetGateway)
{
    HRESULT hr = S_OK;
    
    *ppInternetGateway = NULL;
    
    IInternetGateway* pInternetGateway;
    if(1 == SendMessage(m_hWindow, WM_APP_GETBEACON, 0, reinterpret_cast<LPARAM>(&pInternetGateway)))
    {
        *ppInternetGateway = pInternetGateway;
        // pass reference
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    return hr;
}




CInternetGatewayFinderClassFactory::CInternetGatewayFinderClassFactory()
{
    m_hWindow = NULL;
}

HRESULT CInternetGatewayFinderClassFactory::Initialize(HWND hWindow)
{
    HRESULT hr = S_OK;
    
    m_hWindow = hWindow;
    
    return hr;    
}

HRESULT CInternetGatewayFinderClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppvObject)
{
    HRESULT hr = S_OK;

    if(NULL != pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    
    if(NULL == ppvObject)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppvObject = NULL;
    }

    if(SUCCEEDED(hr))
    {
        CComObject<CInternetGatewayFinder>* pInternetGatewayFinder;
        hr = CComObject<CInternetGatewayFinder>::CreateInstance(&pInternetGatewayFinder);
        if(SUCCEEDED(hr))
        {
            pInternetGatewayFinder->AddRef();

            hr = pInternetGatewayFinder->Initialize(m_hWindow);
            if(SUCCEEDED(hr))
            {
                hr = pInternetGatewayFinder->QueryInterface(riid, ppvObject);
                // pass reference
            }
            pInternetGatewayFinder->Release();
        }
    }
    
    return hr;
}

HRESULT CInternetGatewayFinderClassFactory::LockServer(BOOL fLock)
{
    HRESULT hr = S_OK;

    fLock ? _Module.Lock() : _Module.Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\internetgatewayfinder.h ===
#pragma once

// {4D3F9715-73DA-4506-8933-1E0E1718BA3B}
DEFINE_GUID(CLSID_CInternetGatewayFinder, 
0x4d3f9715, 0x73da, 0x4506, 0x89, 0x33, 0x1e, 0xe, 0x17, 0x18, 0xba, 0x3b);

class ATL_NO_VTABLE CInternetGatewayFinder :
    public CComObjectRootEx <CComSingleThreadModel>,
    public IInternetGatewayFinder
{

public:
    BEGIN_COM_MAP(CInternetGatewayFinder)
        COM_INTERFACE_ENTRY(IInternetGatewayFinder)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT();

    CInternetGatewayFinder();
    HRESULT Initialize(HWND hWindow);
    
    STDMETHODIMP GetInternetGateway(BSTR DeviceId, IInternetGateway** ppInternetGateway);

    HWND m_hWindow;
};



class ATL_NO_VTABLE CInternetGatewayFinderClassFactory :
    public CComObjectRootEx <CComSingleThreadModel>,
    public IClassFactory
{

public:
    BEGIN_COM_MAP(CInternetGatewayFinderClassFactory)
        COM_INTERFACE_ENTRY(IClassFactory)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT();

    CInternetGatewayFinderClassFactory();
    HRESULT Initialize(HWND hWindow);
    
    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

    HWND m_hWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\main.cpp ===
#pragma hdrstop
#include <stdio.h>
#include "debug.h"
#include "upnp.h"

HRESULT PrintVariantBool(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_BOOL)
    {
        wprintf(L"%s is %s\n", pszVariable, VARIANT_TRUE == V_BOOL(pVariant) ?  L"TRUE" : L"FALSE");
    }

    return hr;
}

HRESULT PrintVariableBool(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantBool(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintVariantShort(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_UI2)
    {
        wprintf(L"%s is %d\n", pszVariable, V_UI2(pVariant));
    }

    return hr;
}

HRESULT PrintVariableShort(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantShort(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintVariantLong(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_UI4)
    {
        wprintf(L"%s is %d\n", pszVariable, V_UI4(pVariant));
    }

    return hr;
}

HRESULT PrintVariableLong(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantLong(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintVariantString(LPWSTR pszVariable, VARIANT* pVariant)
{
    HRESULT hr = S_OK;

    if(V_VT(pVariant) == VT_BSTR)
    {
        wprintf(L"%s is %s\n", pszVariable, V_BSTR(pVariant));
    }

    return hr;
}

HRESULT PrintVariableString(IUPnPService* pService, LPWSTR pszVariable)
{
    HRESULT hr = S_OK;
    
    BSTR VariableName; 
    VARIANT Variant;
    VariantInit(&Variant);
    
    VariableName = SysAllocString(pszVariable);
    hr = pService->QueryStateVariable(VariableName, &Variant);
    if(SUCCEEDED(hr))
    {
        hr = PrintVariantString(pszVariable, &Variant);
    }
    else
    {
        wprintf(L"error %x\n", hr);
    }
    SysFreeString(VariableName);
    VariantClear(&Variant);
    
    return hr;
    
}

HRESULT PrintOutParams(VARIANT* pOutParams)
{
    HRESULT hr = S_OK;
    
    SAFEARRAY* pArray = V_ARRAY(pOutParams);
    
    LONG lIndex = 0;
    VARIANT Param;
    
    while(SUCCEEDED(hr))
    {
        hr = SafeArrayGetElement(pArray, &lIndex, &Param);
        if(SUCCEEDED(hr))
        {
            switch(V_VT(&Param))
            {
                
            case VT_BOOL:
                PrintVariantBool(L"B  ", &Param);
                break;
            case VT_UI4:
                PrintVariantLong(L"D  ", &Param);
                break;
            case VT_UI2:
                PrintVariantShort(L"W  ", &Param);
                break;
            case VT_BSTR:
                PrintVariantString(L"S  ", &Param);
                break;
            }
            
        }
        lIndex++;
    }
    
    return hr;
}


HRESULT FindFirstDevice(IUPnPDevices* pDevices, IUPnPDevice** ppDevice)
{
    HRESULT hr = S_OK;

    IUnknown* pEnumerator;
    hr = pDevices->get__NewEnum(&pEnumerator);
    
    if (SUCCEEDED(hr))
    {
        IEnumVARIANT* pVariantEnumerator;
        hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
        if (SUCCEEDED(hr))
        {
            VARIANT DeviceVariant;
            
            VariantInit(&DeviceVariant);
            
            pVariantEnumerator->Reset();
            
            // Traverse the collection.
            
            while (S_OK == pVariantEnumerator->Next(1, &DeviceVariant, NULL))
            {
                IDispatch   * pDeviceDispatch = NULL;
                IUPnPDevice * pDevice = NULL;
                
                pDeviceDispatch = V_DISPATCH(&DeviceVariant);
                
                
                hr = pDeviceDispatch->QueryInterface(IID_IUPnPDevice, reinterpret_cast<void **>(&pDevice));
                if (SUCCEEDED(hr))
                {
                    // Do something interesting with pDevice.
                    *ppDevice = pDevice;
                    
                    BSTR FriendlyName;
                    hr = pDevice->get_FriendlyName(&FriendlyName);
                    if(SUCCEEDED(hr))
                    {
                        wprintf(L"Friendly Name %s\n", FriendlyName);
                        SysFreeString(FriendlyName);
                    }
                    //                                pDevice->Release();
                    break; // BUGBUG
                }
                
                VariantClear(&DeviceVariant);                                
            };
            
            if(NULL == *ppDevice)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            pVariantEnumerator->Release();
        }
        pEnumerator->Release();
    }

    return hr;
}

HRESULT FindGatewayDevice(IUPnPDevice** ppGatewayDevice)
{
    HRESULT hr;
    
    *ppGatewayDevice = NULL;
    
    IUPnPDeviceFinder *pDeviceFinder;
    hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, reinterpret_cast<void **>(&pDeviceFinder));
    if(SUCCEEDED(hr))
    {

        BSTR            bstrTypeURI;
        
        bstrTypeURI = SysAllocString(L"urn:schemas-upnp-org:device:InternetGatewayDevice:0.3");
        if (NULL != bstrTypeURI)
        {
            IUPnPDevices* pFoundDevices;
            hr = pDeviceFinder->FindByType(bstrTypeURI, 0, &pFoundDevices);
            if (SUCCEEDED(hr))
            {
                hr = FindFirstDevice(pFoundDevices, ppGatewayDevice);
                pFoundDevices->Release();
            }
            SysFreeString(bstrTypeURI);
        }
        pDeviceFinder->Release();
    }
    else
    {
        printf("Couldn't create device finder %x\n", hr);
    }
    return hr;
}

HRESULT FindChildDevice(IUPnPDevice* pDevice, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;
    
    IUPnPDevices* pDevices;
    hr = pDevice->get_Children(&pDevices);
    if(SUCCEEDED(hr))
    {
        hr = FindFirstDevice(pDevices, ppChildDevice);
    }

    return hr;
}

HRESULT FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService)
{
    HRESULT hr;
    IUPnPServices* pServices;        
    hr = pDevice->get_Services(&pServices);
    if (SUCCEEDED(hr))
    {
//        IUnknown* pEnumerator;
//        hr = pServices->get__NewEnum(&pEnumerator);
//        if (SUCCEEDED(hr))
//        {
//            IEnumVARIANT* pVariantEnumerator;
//            hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
//            if (SUCCEEDED(hr))
//            {
//                VARIANT ServiceVariant;
//                
//                VariantInit(&ServiceVariant);
//                
//                pVariantEnumerator->Reset();
//                
//                // Traverse the collection.
//                
//                while (S_OK == pVariantEnumerator->Next(1, &ServiceVariant, NULL))
//                {
//                    wprintf(L"getting i1d\n");
//                    IDispatch   * pServiceDispatch = NULL;
//                    IUPnPService * pService = NULL;
//                    
//                    pServiceDispatch = V_DISPATCH(&ServiceVariant);
//                    hr = pServiceDispatch->QueryInterface(IID_IUPnPService, reinterpret_cast<void **>(&pService));
//                    if (SUCCEEDED(hr))
//                    {
//                        wprintf(L"getting id\n");
//                        
//                        BSTR ServiceId;
//                        hr = pService->get_Id(&ServiceId);
//                        if(SUCCEEDED(hr))
//                        {
//                            wprintf(L"service %s\n", ServiceId);
//                            SysFreeString(ServiceId);
//                        }
//                        pService->Release();
//                    }
//                    
//                    VariantClear(&ServiceVariant);                                
//                };
//                wprintf(L"done enum\n");
//                pVariantEnumerator->Release();
//            }
//            pEnumerator->Release();
//        }
        
        BSTR ServiceId = SysAllocString(pszServiceName);
        if (NULL != ServiceId)
        {
            IUPnPService* pICSService;
            hr = pServices->get_Item(ServiceId, &pICSService);
            if(SUCCEEDED(hr))
            {
                wprintf(L"found service\n");
                *ppICSService = pICSService;    
            }
            SysFreeString(ServiceId);
        }
        
        pServices->Release();
    }
    if(FAILED(hr))
    {
        wprintf(L"find ICS Service %x\n", hr);
    }
    
    return hr;
}

HRESULT CreateParamArray(LONG lElements, VARIANT* pInParams)
{
    HRESULT hr = S_OK;
    
    VariantInit(pInParams);
    
    
    SAFEARRAYBOUND  rgsaBound[1];
    SAFEARRAY       * psa = NULL;
    
    rgsaBound[0].lLbound = 0;
    rgsaBound[0].cElements = lElements;
    
    psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
    if(NULL != psa)
    {
        pInParams->vt = VT_VARIANT | VT_ARRAY;
        V_ARRAY(pInParams) = psa;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT InvokeAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pInParams, VARIANT* pOutParams)
{
    HRESULT hr = S_OK;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        
        VARIANT varReturnVal;
        VariantInit(pOutParams);
        VariantInit(&varReturnVal);
        
        hr = pService->InvokeAction(bstrActionName, *pInParams, pOutParams, &varReturnVal);
        if(SUCCEEDED(hr))
        {
            VariantClear(&varReturnVal);
        }
        
        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }


    return hr;
}

HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr = S_OK;
    
    VARIANT varInArgs;
    hr = CreateParamArray(0, &varInArgs);
    if (SUCCEEDED(hr))
    {
        hr = InvokeAction(pService, pszCommand, &varInArgs, pOutParams);
        
        VariantClear(&varInArgs);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }   
    
    return hr;
}

HRESULT TestInternetGatewayDevice_OSInfo(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestInternetGatewayDevice_OSInfo\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:OSInfo", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            BSTR VariableName; 
            VARIANT Variant;
            VariantInit(&Variant);
            
            VariableName = SysAllocString(L"OSMajorVersion");
            hr = pICSService->QueryStateVariable(VariableName, &Variant);
            if(SUCCEEDED(hr))
            {
                if(V_VT(&Variant) == VT_I4)
                {
                    wprintf(L"OSMajorVersion is %d\n", V_I4(&Variant));
                }
            }
            else
            {
                wprintf(L"error %x\n", hr);
            }
            SysFreeString(VariableName);
            VariantClear(&Variant);
            
            if(SUCCEEDED(hr))
            {
                VariableName = SysAllocString(L"OSMinorVersion");
                hr = pICSService->QueryStateVariable(VariableName, &Variant);
                if(SUCCEEDED(hr))
                {
                    if(V_VT(&Variant) == VT_I4)
                    {
                        wprintf(L"OSMinorVersion is %d\n", V_I4(&Variant));
                    }
                }
                else
                {
                    wprintf(L"error %x\n", hr);
                }
                SysFreeString(VariableName);
                VariantClear(&Variant);
            }
            
            if(SUCCEEDED(hr))
            {
                VariableName = SysAllocString(L"OSBuildNumber");
                hr = pICSService->QueryStateVariable(VariableName, &Variant);
                if(SUCCEEDED(hr))
                {
                    if(V_VT(&Variant) == VT_I4)
                    {
                        wprintf(L"OSBuildNumber is %d\n", V_I4(&Variant));
                    }
                }
                else
                {
                    wprintf(L"error %x\n", hr);
                }
                SysFreeString(VariableName);
                VariantClear(&Variant);
            }
            
            //            if(SUCCEEDED(hr))
            //            {
            //                MessageBox(NULL, L"click to disconnect", L"debug", MB_OK);
            //                wprintf(L"disconnect\n");
            //                hr = InvokePlay(pICSService, L"Disconnect");
            //                wprintf(L"invoke failed %x\n", hr);
            //                MessageBox(NULL, L"click to connect", L"debug", MB_OK);
            //                wprintf(L"connect\n");
            //                hr = InvokePlay(pICSService, L"Connect");
            //                wprintf(L"invoke failed %x\n", hr);
            //            }
            //            
            //        
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANDevice_WANCommonInterfaceConfig(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANDevice_WANCommonInterfaceConfig\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANCommonInterfaceConfig", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"WANAccessType");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"Layer1UpstreamMaxBitRate");
            }

            if(SUCCEEDED(hr))
            {                                                                                     
                hr = PrintVariableLong(pICSService, L"Layer1DownstreamMaxBitRate");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PhysicalLinkStatus");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"WANAccessProvider");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalBytesSent");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalBytesReceived");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalPacketsSent");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"TotalPacketsReceived");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableShort(pICSService, L"MaximumActiveConnections");
            }

            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"PersonalFirewallEnabled");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetCommonLinkProperties\n");

                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetCommonLinkProperties", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  WANAccessType", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  Layer1UpstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  Layer1DownstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 3;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  PhysicalLinkStatus", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }

            if(SUCCEEDED(hr))
            {
                wprintf(L"GetCommonConnectionProperties\n");
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetCommonConnectionProperties", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);

                    LONG lIndex = 0;
                    VARIANT Param;

                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  WANAccessProvider", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantShort(L"  MaximumActiveConnections", &Param);
                        VariantClear(&Param);
                    }

                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalBytesSent", &Param);
                        VariantClear(&Param);
                    }

                    lIndex = 3;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalBytesReceived", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 4;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalPacketsSent", &Param);
                        VariantClear(&Param);
                    }

                    lIndex = 5;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  TotalPacketsReceived", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_WANPOTSLinkConfig(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_WANPOTSLinkConfig\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANPOTSLinkConfig", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ISPPhoneNumber");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ISPInfo");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"LinkType");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"NumberOfRetries");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"DelayBetweenRetries");
            }
            
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_WANPPPConnection(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_WANPPPConnection\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANPPPConnection", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionType");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PossibleConnectionTypes");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionStatus");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"Uptime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"UpstreamMaxBitRate");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"DownstreamMaxBitRate");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"LastConnectionError");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"RSIPAvailable");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"NATEnabled");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"AutoDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"IdleDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"WarnDisconnectDelay");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PPPEncryptionProtocol");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PPPCompressionProtocol");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PPPAuthenticationProtocol");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableShort(pICSService, L"ServiceMapNumberOfEntries");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetConnectionTypeInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetConnectionTypeInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionType", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPossibleConnectionTypes", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStatusInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetStatusInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionStatus", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewLastConnectionError", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewUptime", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetNATInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetNATInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewRSIPAvailable", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewNATEnabled", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantShort(L"  NewServiceMapNumberOfEntries", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetLinkLayerInfo\n");
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetLinkLayerInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewUpstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewDownstreamMaxBitRate", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPPPEncryptionProtocol", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 3;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPPPCompressionProtocol", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 4;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPPPAuthenticationProtocol", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetTerminationInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetTerminationInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  AutoDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  IdleDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  WarnDisconnectDelay", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_WANIPConnection(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_WANIPConnection\n");
    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:WANIPConnection", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionType");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"PossibleConnectionTypes");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"ConnectionStatus");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"Uptime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"RSIPAvailable");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableBool(pICSService, L"NATEnabled");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"AutoDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"IdleDisconnectTime");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableLong(pICSService, L"WarnDisconnectDelay");
            }
            
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableShort(pICSService, L"ServiceMapNumberOfEntries");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetConnectionTypeInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetConnectionTypeInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionType", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewPossibleConnectionTypes", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStatusInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetStatusInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewConnectionStatus", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantString(L"  NewLastConnectionError", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  NewUptime", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetNATInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetNATInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewRSIPAvailable", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantBool(L"  NewNATEnabled", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantShort(L"  NewServiceMapNumberOfEntries", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetTerminationInfo\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetTerminationInfo", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                    
                    LONG lIndex = 0;
                    VARIANT Param;
                    
                    lIndex = 0;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  AutoDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 1;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  IdleDisconnectTime", &Param);
                        VariantClear(&Param);
                    }
                    
                    lIndex = 2;
                    hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                    if(SUCCEEDED(hr))
                    {
                        PrintVariantLong(L"  WarnDisconnectDelay", &Param);
                        VariantClear(&Param);
                    }
                    
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_NATStaticPortMapping(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_NATStaticPortMapping\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:NATStaticPortMapping", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            if(SUCCEEDED(hr))
            {
                hr = PrintVariableString(pICSService, L"StaticPortDescriptionList");
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStaticPortMappingList\n");
                
                VARIANT OutArgs;
                hr = InvokeVoidAction(pICSService, L"GetStaticPortMappingList", &OutArgs);
                if(SUCCEEDED(hr))
                {
                    PrintOutParams(&OutArgs);
                    VariantClear(&OutArgs);
                }
                else
                {
                    printf("no action %x\n", hr);
                }
            }
            
            if(SUCCEEDED(hr))
            {
                wprintf(L"GetStaticPortMapping\n");
                
                VARIANT InArgs;
                VARIANT OutArgs;
                hr = CreateParamArray(1, &InArgs);
                if(SUCCEEDED(hr))
                {
                    SAFEARRAY* pArray = V_ARRAY(&InArgs);

                    long lIndex = 0;
                    VARIANT Param0;
                    Param0.vt = VT_BSTR;
                    V_BSTR(&Param0) = SysAllocString(L"tester");
                    SafeArrayPutElement(pArray, &lIndex, &Param0);
                    
                    hr = InvokeAction(pICSService, L"GetStaticPortMapping", &InArgs, &OutArgs);
                    if(SUCCEEDED(hr))
                    {
                        PrintOutParams(&OutArgs);
                        VariantClear(&OutArgs);
                    }
                    else
                    {
                        printf("no action %x\n", hr);
                    }
                }
            }

            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_NATDynamicPortMapping(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_NATDynamicPortMapping\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:NATDynamicPortMapping", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

HRESULT TestWANCommonDevice_NATInfo(IUPnPDevice* pGatewayDevice)
{

    HRESULT hr;
    wprintf(L"TestWANCommonDevice_NATInfo\n");

    
    IUPnPService* pICSService;
    hr = FindService(pGatewayDevice, L"upnp:id:NATInfo", &pICSService);
    if(SUCCEEDED(hr))
    {
        do
        {
            
        } while (UPNP_E_VARIABLE_VALUE_UNKNOWN == hr);
        pICSService->Release();
    }
    return hr;
}

int __cdecl main(int argc, char* argv[])
{

    HRESULT hr;

    hr = CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        
        IUPnPDevice* pGatewayDevice;
        
        hr = FindGatewayDevice(&pGatewayDevice);
        if(SUCCEEDED(hr))
        {
//            TestInternetGatewayDevice_OSInfo(pGatewayDevice);
            
            IUPnPDevice* pWANDevice;
            hr = FindChildDevice(pGatewayDevice, &pWANDevice);
            if(SUCCEEDED(hr))
            {
                //TestWANDevice_WANCommonInterfaceConfig(pWANDevice);        

                IUPnPDevice* pWANConnectionDevice;
                hr = FindChildDevice(pWANDevice, &pWANConnectionDevice);
                if(SUCCEEDED(hr))
                {
                    //        TestWANCommonDevice_WANPOTSLinkConfig(pWANConnectionDevice); 
                    //        TestWANCommonDevice_WANPPPConnection(pWANConnectionDevice);
//                            TestWANCommonDevice_WANIPConnection(pWANConnectionDevice);
                            TestWANCommonDevice_NATStaticPortMapping(pWANConnectionDevice);
                            TestWANCommonDevice_NATDynamicPortMapping(pWANConnectionDevice);
                            TestWANCommonDevice_NATInfo(pWANConnectionDevice);
                    
                    pWANConnectionDevice->Release();
                }
                pWANDevice->Release();
            }
            pGatewayDevice->Release();
        }
        CoUninitialize();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\properties.h ===
#pragma once

#include "stdafx.h"
#include <windows.h>
#include "resource.h"
#include "atlsnap.h"
#include "netconp.h"

class CPropertiesDialog : public CSnapInPropertyPageImpl<CPropertiesDialog, FALSE>
{

public:
    BEGIN_MSG_MAP(CPropertiesDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
      
    END_MSG_MAP()

    enum { IDD = IDD_PROPERTIES };    

    CPropertiesDialog(IInternetGateway* pInternetGateway);
    ~CPropertiesDialog();
    
    static HRESULT ShouldShowIcon(void);
    static HRESULT SetShowIcon(BOOL bShowIcon);

private:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HICON m_hIcon;
    IInternetGateway* m_pInternetGateway;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\resource.h ===
#pragma once

#define IDC_STATIC -1

// strings
#define IDS_DEFAULTADAPTERNAME 100
#define IDS_UPTIME_ZERODAYS 101
#define IDS_UPTIME_ONEDAY 102
#define IDS_UPTIME_MANYDAYS 103
#define IDS_TOOLTIP_FORMAT 104
#define IDS_NAME_FORMAT 105
#define IDS_PROPERTIES_FORMAT 106
#define IDS_STATUS_FORMAT 107
#define IDS_BEACONNOTFOUND 108
#define IDS_APPTITLE 109
#define IDS_CONNECTED 110
#define IDS_DISCONNECTED 111
#define IDS_ENABLE 112
#define IDS_DISABLE 113
#define IDS_CONNECT 114
#define IDS_DISCONNECT 115
#define IDS_CONNECTING 116
#define IDS_DISCONNECTING 117
#define IDS_UNCONFIGURED 118
#define IDS_ACCESSDENIED 119
#define IDS_NOTAVAILABLE 120
#define IDS_CLOSE 121
#define IDS_NEEDNEWERIE 122
#define IDS_CONNECTIONFAILED 123


// status bps strings, must remain in order
#define IDS_METRIC_ZERO 200
#define IDS_METRIC_KILO 201
#define IDS_METRIC_MEGA 202
#define IDS_METRIC_GIGA 203
#define IDS_METRIC_TERA 204
// end status bps string, must remain in order


// icons
#define IDI_TRAYICON 100
// REMOVED #define IDI_PROPERTIESICON 101
#define IDI_INTERNET 102
// REMOVED #define IDI_LAN 103
#define IDI_GATEWAY 104
#define IDI_MYCOMPUTER 105

// menu items
#define IDM_TRAYICON_LAN_CONNECT 100
#define IDM_TRAYICON_LAN_DISCONNECT 101
#define IDM_TRAYICON_RAS_CONNECT 102
#define IDM_TRAYICON_RAS_DISCONNECT 103
#define IDM_TRAYICON_CONNECT 104
#define IDM_TRAYICON_DISCONNECT 105
#define IDM_TRAYICON_STATUS 106
#define IDM_TRAYICON_PROPERTIES 107

// dialogs
#define IDD_STATUS 100
#define IDD_PROPERTIES 101

// status dialog control
#define IDC_STATUS_STATUS 100
#define IDC_STATUS_DURATION 101
#define IDC_STATUS_SPEED 102
#define IDC_STATUS_BYTESSENT 103
#define IDC_STATUS_BYTESRECEIVED 104
#define IDC_STATUS_LOCALBYTESSEND 105
#define IDC_STATUS_LOCALBYTESRECEIVTED 106
#define IDC_STATUS_PROPERTIES 107
#define IDC_STATUS_DISCONNECT 108
// REMOVED #define IDC_STATUS_DISABLE 109
#define IDC_STATUS_BYTESLABEL 110
#define IDC_STATUS_PACKETSLABEL 111
#define IDC_STATUS_CONNECT 112

// properties dialog controls
#define IDC_PROPERTIES_ADAPTERNAME 100
#define IDC_PROPERTIES_SHOWICON 101
#define IDC_PROPERTIES_ADAPTERICON 102

// registry data
#define IDR_UPNPNAT                 103

// end of resources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\status.cpp ===
#include "status.h"
#include "properties.h"
#include "util.h"

CStatusDialog::CStatusDialog(IInternetGateway* pInternetGateway)
{
    m_pInternetGateway = pInternetGateway;
    m_pInternetGateway->AddRef();

    m_uTimerId = 0;
    m_bGettingStatistics = FALSE;
    m_bShowingBytes = TRUE;
}

CStatusDialog::~CStatusDialog()
{
    m_pInternetGateway->Release();
    
}

LRESULT CStatusDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_uTimerId = SetTimer(1, 1000);

    TCHAR szCloseText[64];
    if(0 != ::LoadString(_Module.GetResourceInstance(), IDS_CLOSE, szCloseText, sizeof(szCloseText) / sizeof(TCHAR)))
    {
        ::SetDlgItemText(GetParent(), IDCANCEL, szCloseText); // set the cancel to close
    }
    
    ::ShowWindow(::GetDlgItem(GetParent(), IDOK), SW_HIDE); // hide the original close
    ::EnableWindow(::GetDlgItem(GetParent(), IDCANCEL), TRUE); // and re-enable the cancel button
    
    
    IUPnPService* pWANConnectionService;
    HRESULT hr = GetWANConnectionService(m_pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        NETCON_STATUS Status;
        hr = GetConnectionStatus(pWANConnectionService, &Status);
        if(SUCCEEDED(hr))
        {
            UpdateButtons(Status);
        }
        pWANConnectionService->Release();
    }

    return TRUE;
}

LRESULT CStatusDialog::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(0 != m_uTimerId)
    {
        ::KillTimer(m_hWnd, m_uTimerId);
    }
    return 0;
}

LRESULT CStatusDialog::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    
    if(FALSE == m_bGettingStatistics) // this functions pumps messages, so don't let us be re-entered  
    {
        m_bGettingStatistics = TRUE;
        
        NETCON_STATUS Status = NCS_CONNECTED;
        ULONG ulTotalBytesSent = 0;
        ULONG ulTotalBytesReceived = 0;
        ULONG ulTotalPacketsSent = 0;
        ULONG ulTotalPacketsReceived = 0;
        ULONG ulSpeedbps = 0;
        ULONG ulUptime = 0;
        BOOL bStatisticsAvailable = TRUE;
        
        
        IUPnPService* pWANConnection;
        hr = GetWANConnectionService(m_pInternetGateway, &pWANConnection);
        if(SUCCEEDED(hr))
        {
            IUPnPService* pWANCommonInterfaceConfig;
            hr = m_pInternetGateway->GetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, &pWANCommonInterfaceConfig);
            if(SUCCEEDED(hr))
            {
                
                hr = GetConnectionStatus(pWANConnection, &Status);                
                if(SUCCEEDED(hr))
                {
                    if(NCS_CONNECTED == Status)
                    {
                        VARIANT OutArgs;
                        VariantInit(&OutArgs);
                        hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"X_GetICSStatistics", &OutArgs);
                        if(SUCCEEDED(hr))
                        {
                            SAFEARRAY* pArray = V_ARRAY(&OutArgs);
                            
                            LONG lIndex = 0;
                            VARIANT Param;
                            
                            lIndex = 0;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalBytesSent = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 1;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalBytesReceived = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 2;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalPacketsSent = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 3;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulTotalPacketsReceived = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 4;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulSpeedbps = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            lIndex = 5;
                            hr = SafeArrayGetElement(pArray, &lIndex, &Param);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Param) == VT_UI4)
                                {
                                    ulUptime = V_UI4(&Param);
                                }
                                VariantClear(&Param);
                            }
                            
                            VariantClear(&OutArgs);
                        }
                        else if(UPNP_E_INVALID_ACTION == hr)
                        {
                            VARIANT OutArgs;
                            LONG lIndex = 0;
                            VARIANT Param;
                            
                            hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalBytesSent", &OutArgs);
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                if(SUCCEEDED(hr))
                                {
                                    if(V_VT(&Param) == VT_UI4)
                                    {
                                        ulTotalBytesSent = V_UI4(&Param);
                                    }
                                    VariantClear(&Param);
                                }
                                VariantClear(&OutArgs);
                            }
                            
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalBytesReceived", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulTotalBytesReceived = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                lIndex = 0;
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalPacketsSent", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulTotalPacketsSent = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetTotalPacketsReceived", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    lIndex = 0;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulTotalPacketsReceived = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = InvokeVoidAction(pWANCommonInterfaceConfig, L"GetCommonLinkProperties", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    lIndex = 2;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulSpeedbps = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = InvokeVoidAction(pWANConnection, L"GetStatusInfo", &OutArgs);
                                if(SUCCEEDED(hr))
                                {
                                    lIndex = 2;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgs), &lIndex, &Param);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&Param) == VT_UI4)
                                        {
                                            ulUptime = V_UI4(&Param);
                                        }
                                        VariantClear(&Param);
                                    }
                                    VariantClear(&OutArgs);
                                }
                            }
                            
                            if(UPNP_E_INVALID_ACTION == hr)
                            {
                                hr = S_OK; // server does not support statistics
                                bStatisticsAvailable = FALSE;
                            }
                        }
                    }
                }
                pWANCommonInterfaceConfig->Release();
            }
            pWANConnection->Release();
        }
    
        if(SUCCEEDED(hr) && NCS_CONNECTED == Status)
        {
            if(TRUE == bStatisticsAvailable)
            {
                if(0 != ulTotalBytesSent && 0 != ulTotalBytesReceived)
                {
                    if(FALSE == m_bShowingBytes) // switch labels
                    {
                        m_bShowingBytes = TRUE;
                        ::ShowWindow(GetDlgItem(IDC_STATUS_BYTESLABEL), SW_SHOW);
                        ::ShowWindow(GetDlgItem(IDC_STATUS_PACKETSLABEL), SW_HIDE);
                    
                    }
                    SetDlgItemInt(IDC_STATUS_BYTESSENT, ulTotalBytesSent, FALSE);
                    SetDlgItemInt(IDC_STATUS_BYTESRECEIVED, ulTotalBytesReceived, FALSE);
                }
                else
                {
                    if(TRUE == m_bShowingBytes) // switch labels
                    {
                        m_bShowingBytes = FALSE;
                        ::ShowWindow(GetDlgItem(IDC_STATUS_PACKETSLABEL), SW_SHOW);
                        ::ShowWindow(GetDlgItem(IDC_STATUS_BYTESLABEL), SW_HIDE);
                    }
                    SetDlgItemInt(IDC_STATUS_BYTESSENT, ulTotalPacketsSent, FALSE);
                    SetDlgItemInt(IDC_STATUS_BYTESRECEIVED, ulTotalPacketsReceived, FALSE);
                }
            
                TCHAR szTimeDuration[128];
                hr = FormatTimeDuration(ulUptime, szTimeDuration, sizeof(szTimeDuration) / sizeof(TCHAR));
                if(SUCCEEDED(hr))
                {
                    SetDlgItemText(IDC_STATUS_DURATION, szTimeDuration);
                }                                                                                                                                 \
            
                TCHAR szBytesPerSecond[128];
                hr = FormatBytesPerSecond(ulSpeedbps, szBytesPerSecond, sizeof(szBytesPerSecond) / sizeof(TCHAR));
                if(SUCCEEDED(hr))
                {
                    SetDlgItemText(IDC_STATUS_SPEED, szBytesPerSecond);
                }
            }
            else
            {                
                TCHAR szNotAvailable[64];
                if(0 == LoadString(_Module.GetResourceInstance(), IDS_NOTAVAILABLE, szNotAvailable, sizeof(szNotAvailable) / sizeof(TCHAR)))
                {
                    szNotAvailable[0] = TEXT('\0');
                }
                
                SetDlgItemText(IDC_STATUS_BYTESSENT, szNotAvailable);
                SetDlgItemText(IDC_STATUS_BYTESRECEIVED, szNotAvailable);
                SetDlgItemText(IDC_STATUS_DURATION, szNotAvailable);
                SetDlgItemText(IDC_STATUS_SPEED, szNotAvailable);
            }
            
        }
        else
        {
            SetDlgItemText(IDC_STATUS_BYTESSENT, TEXT(""));
            SetDlgItemText(IDC_STATUS_BYTESRECEIVED, TEXT(""));
            SetDlgItemText(IDC_STATUS_DURATION, TEXT(""));
            SetDlgItemText(IDC_STATUS_SPEED, TEXT(""));
        }
        
        if(SUCCEEDED(hr) || UPNP_E_ACTION_REQUEST_FAILED == hr) // if we disconnected after getting status this will fail
        {
            UpdateButtons(Status);
            
            TCHAR szConnectionStatus[64];
            hr = ConnectionStatusToString(Status, szConnectionStatus, sizeof(szConnectionStatus) / sizeof(TCHAR));
            if(SUCCEEDED(hr)) 
            {
                SetDlgItemText(IDC_STATUS_STATUS, szConnectionStatus);
            }
        }
        


        if(FAILED(hr))
        {
            ::PropSheet_PressButton(GetParent(), PSBTN_CANCEL);
        }

        m_bGettingStatistics = FALSE;
    }
    return 0;
}

LRESULT CStatusDialog::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND hPropertySheet = GetParent();
    if(NULL != hPropertySheet)
    {
        HWND hTopLevelWindow = ::GetParent(hPropertySheet);
        if(NULL != hTopLevelWindow)
        {
            ::PostMessage(hTopLevelWindow, WM_COMMAND, IDM_TRAYICON_PROPERTIES, (LPARAM)hPropertySheet);
        }
    }

    return 0;
}

LRESULT CStatusDialog::OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    HRESULT hr = S_OK;
    

    IUPnPService* pWANConnectionService;
    hr = GetWANConnectionService(m_pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        VARIANT OutArgs;
        hr = InvokeVoidAction(pWANConnectionService, L"ForceTermination", &OutArgs);
        if(SUCCEEDED(hr))
        {
            VariantClear(&OutArgs);
        }
        else if(UPNP_ACTION_HRESULT(800) == hr)
        {
            ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
        }

        pWANConnectionService->Release();
    }
    
    return 0;
}

LRESULT CStatusDialog::OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    HRESULT hr = S_OK;
    
    IUPnPService* pWANConnectionService;
    hr = GetWANConnectionService(m_pInternetGateway, &pWANConnectionService);
    if(SUCCEEDED(hr))
    {
        VARIANT OutArgs;
        hr = InvokeVoidAction(pWANConnectionService, L"RequestConnection", &OutArgs);
        if(SUCCEEDED(hr))
        {
            VariantClear(&OutArgs);
        }
        else if(UPNP_ACTION_HRESULT(800) == hr)
        {
            ShowErrorDialog(m_hWnd, IDS_ACCESSDENIED);
        }
        else if(UPNP_E_DEVICE_TIMEOUT != hr)
        {
            ShowErrorDialog(m_hWnd, IDS_CONNECTIONFAILED);
        }


        pWANConnectionService->Release();
    }
    
    return 0;
}

HRESULT CStatusDialog::UpdateButtons(NETCON_STATUS Status)
{
     
    NETCON_MEDIATYPE MediaType;
    HRESULT hr = m_pInternetGateway->GetMediaType(&MediaType);
    if(SUCCEEDED(hr))
    {
        TCHAR szButtonText[64];
        
        if(NCS_CONNECTED == Status)
        {
            if(NCM_SHAREDACCESSHOST_RAS == MediaType)
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_DISCONNECT, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_DISCONNECT, szButtonText);
                }
            }
            else
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_DISABLE, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_DISCONNECT, szButtonText);
                }
            }

            ::ShowWindow(GetDlgItem(IDC_STATUS_DISCONNECT), SW_SHOW);
            ::ShowWindow(GetDlgItem(IDC_STATUS_CONNECT), SW_HIDE);

        }
        else if(NCS_DISCONNECTED == Status)
        {
            if(NCM_SHAREDACCESSHOST_RAS == MediaType)
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_CONNECT, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_CONNECT, szButtonText);
                }
            }
            else
            {
                if(0 != LoadString(_Module.GetResourceInstance(), IDS_ENABLE, szButtonText, sizeof(szButtonText) / sizeof(TCHAR)))
                {
                    SetDlgItemText(IDC_STATUS_CONNECT, szButtonText);
                }
            }

            ::ShowWindow(GetDlgItem(IDC_STATUS_CONNECT), SW_SHOW);
            ::ShowWindow(GetDlgItem(IDC_STATUS_DISCONNECT), SW_HIDE);
        }
    }
 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\status.h ===
#pragma once

#include "stdafx.h"
#include <windows.h>
#include "resource.h"
#include "atlsnap.h"
#include "netconp.h"

class CStatusDialog : public CSnapInPropertyPageImpl<CStatusDialog, FALSE>
{

public:
    BEGIN_MSG_MAP(CStatusDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        COMMAND_ID_HANDLER(IDC_STATUS_PROPERTIES, OnProperties)
        COMMAND_ID_HANDLER(IDC_STATUS_DISCONNECT, OnDisconnect)
        COMMAND_ID_HANDLER(IDC_STATUS_CONNECT, OnConnect)
    END_MSG_MAP()

    enum { IDD = IDD_STATUS };    

    CStatusDialog(IInternetGateway* pInternetGateway);
    ~CStatusDialog();
    
private:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT UpdateButtons(NETCON_STATUS Status);

    IInternetGateway* m_pInternetGateway;
    UINT_PTR m_uTimerId;
    BOOL m_bGettingStatistics;
    BOOL m_bShowingBytes;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\client\saprop.cpp ===
#include <stdio.h>

#ifdef DBG
#undef DBG
#endif

//#ifdef ASSERT
//#undef ASSERT
//#endif
//#define ASSERT(a)

//#ifdef _ASSERT
//#undef _ASSERT
//#endif
//#define _ASSERT(a)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>    // added to "Fusionized"
#include <windowsx.h>
#include <wbemidl.h>
#include <netcon.h>
#include <netconp.h>
#include <devguid.h>
#include <iphlpapi.h>
#include <ipnathlp.h>
#include <lmerr.h>

#include "hncbase.h"
#include "hncdbg.h"
#include "hnetcfg.h"
#include "hncres.h"
#include "hncstrs.h"
#include "hncutil.h"

#include "hncenum.h"
#include "hncaenum.h"
#include "hnappprt.h"
#include "hnprtmap.h"
#include "hnprtbnd.h"
#include "hnetconn.h"
#include "hnbridge.h"
#include "hnbrgcon.h"
#include "hnicspub.h"
#include "hnicsprv.h"
#include "hnfwconn.h"
#include "hncfgmgr.h"
#include "hnapi.h"
#include "icsdclt.h"

#include <NATUPnP.h>
#include "UPnPNAT.h"

#define DOWNLEVEL_CLIENT
#include "..\..\config\dll\resourc2.h"
#include "..\..\config\dll\sadlg.cpp"
#include "..\..\config\dll\sautil.cpp"

HINSTANCE g_hinstDll = NULL;

extern HRESULT GetWANConnectionService(IInternetGateway* pInternetGateway, IUPnPService** ppWANConnectionService);
HPROPSHEETPAGE GetSharedAccessPropertyPage (IInternetGateway* pInternetGateway, HWND hwndOwner)
{
    g_hinstDll = _Module.GetResourceInstance();

    HPROPSHEETPAGE hpsp = NULL;

    CComPtr<IUPnPService> spUPS;
    HRESULT hr = GetWANConnectionService (pInternetGateway, &spUPS);
    if (spUPS) {
        PROPSHEETPAGE psp;
        ZeroMemory (&psp, sizeof(psp));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.lParam = (LPARAM)hwndOwner;     // double-secret place to hang owner (will get wiped)
        hr = HNetGet