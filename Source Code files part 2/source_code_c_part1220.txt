sAngle     = 0;
	pFeat->boundingBox  = *RectFRAME(pFrame2);

	return TRUE;
}

int FeaturizeGLYPH(GLYPH *glyph, PRIMITIVE *rgprim, RECT *pRect)
{
	KPROTO *kproto;
	int             cstepmax, cframe, cstep, cprim;
	STEP   *rgstep;
	FRAME  *frame;
	int             iframe;

	ASSERT(glyph);

	kproto = (KPROTO *) ExternAlloc(sizeof(KPROTO));

	if (kproto == (KPROTO *) NULL)
		return 0;

	memset(kproto, '\0', sizeof(KPROTO));
	kproto->rgfeat  = rgprim;
	GetRectGLYPH(glyph, &kproto->rect);
   *pRect           = kproto->rect; // Pass bounding rect up.

	rgstep          = (STEP *) ExternAlloc(FRAME_MAXSTEPS * sizeof(STEP));
	if (rgstep == (STEP *) NULL)
		goto cleanup;

	cstepmax        = FRAME_MAXSTEPS;
	cframe          = CframeGLYPH(glyph);

	for (iframe = 0; iframe < cframe; iframe++) 
	{
		frame   = FrameAtGLYPH(glyph, iframe);

	// Special check for dakuten.  If we have 3 to 6 strokes and are looking
	// at the next to last stroke, we need to check if the last two strokes form
	// a dakuten.

		if (3 <= cframe && cframe <= 6 && iframe == cframe - 2) 
		{
			FRAME *frame2;

		// Get the last frame as well

			frame2  = FrameAtGLYPH(glyph, iframe + 1);

		// Check the strokes, adds two features if it is a match.

			if (IsDakuten(&kproto->rect, frame, frame2, kproto)) 
			{
			// OK, Have it abort the rest of the processing on the last two strokes.

				break;
			}
		}

		cstep = StepsFromFRAME(frame, rgstep, cstepmax);
		if (cstep == 0)
		{
			kproto->cfeat = 0;			// Indicate a failure condition
			goto cleanu2;
		}

		cstep = CraneSmoothSteps(rgstep, cstep, cframe);
		AddStepsKPROTO(kproto, rgstep, cstep, cframe, frame);
	}

cleanu2:
	ExternFree(rgstep);

cleanup:
	cprim   = kproto->cfeat;
	ExternFree(kproto);

	return cprim;
}

BOOL AllocFeature(SAMPLE *, int);

BOOL MakeFeatures(SAMPLE *_this, void *pv)
{
	PRIMITIVE       rgprim[CPRIMMAX];
	RECT            rc;
	int                     ifeat;
	int                     iprim, cprim;
	int                     xShift, yShift;                 // Normalize position
	double          xScale, yScale;                 // Normalize size
	double          xyRatio;                                // Ratio of xy (scaled to fit in a WORD)

	cprim = FeaturizeGLYPH((GLYPH *) pv, rgprim, &rc);
	if (!cprim)
		return FALSE;

// Figure normilization constants.

	xShift  = -rc.left;
	xScale  = 1000.0 / (double)(rc.right - rc.left);
	yShift  = -rc.top;
	yScale  = 1000.0 / (double)(rc.bottom - rc.top);
	xyRatio = (xScale / yScale) * 256.0;

// Stroke count MUST be set before any per stroke data can be allocated

	_this->cstrk     = (short)CframeGLYPH((GLYPH *) pv);

// Now allocate per stroke features (currently, this is all of them)

	for (ifeat = 0; ifeat < FEATURE_COUNT; ifeat++)
	{
		if (!AllocFeature(_this, ifeat))
			return FALSE;
	}

// Set per character information (stroke count, dakuten, et.al.)

	_this->fDakuten  = rgprim[cprim - 1].fDakuTen;

// Set per stroke information (angle, stepping, end point position, et.al.)

	for (iprim = 0; iprim < cprim; iprim++)
	{
		((SHORT *)  _this->apfeat[FEATURE_ANGLE_NET]->data)[iprim]  
			= max(min(rgprim[iprim].netAngle, 32767), -32768);
		((USHORT *) _this->apfeat[FEATURE_ANGLE_ABS]->data)[iprim]  
			= min(rgprim[iprim].absAngle, 0x0000ffff);
		((USHORT *) _this->apfeat[FEATURE_LENGTH]->data)[iprim]
			= min(rgprim[iprim].nLength, 0x0000ffff);
		((BYTE *)   _this->apfeat[FEATURE_STEPS]->data)[iprim]      
			= rgprim[iprim].cSteps;
		((BYTE *)   _this->apfeat[FEATURE_FEATURES]->data)[iprim]   
			= rgprim[iprim].cFeatures;

		((END_POINTS *) _this->apfeat[FEATURE_XPOS]->data)[iprim].start 
			= (short) ((double) (rgprim[iprim].x1 + xShift) * xScale);
		((END_POINTS *) _this->apfeat[FEATURE_XPOS]->data)[iprim].end   
			= (short) ((double) (rgprim[iprim].x2 + xShift) * xScale);
		((END_POINTS *) _this->apfeat[FEATURE_YPOS]->data)[iprim].start 
			= (short) ((double) (rgprim[iprim].y1 + yShift) * yScale);
		((END_POINTS *) _this->apfeat[FEATURE_YPOS]->data)[iprim].end   
			= (short) ((double) (rgprim[iprim].y2 + yShift) * yScale);

		((RECTS *) _this->apfeat[FEATURE_STROKE_BBOX]->data)[iprim].x1 
			= (short) ((double) (rgprim[iprim].boundingBox.left + xShift) * xScale);
		((RECTS *) _this->apfeat[FEATURE_STROKE_BBOX]->data)[iprim].y1 
			= (short) ((double) (rgprim[iprim].boundingBox.top + yShift) * yScale);
		((RECTS *) _this->apfeat[FEATURE_STROKE_BBOX]->data)[iprim].x2   
			= (short) ((double) (rgprim[iprim].boundingBox.right + xShift) * xScale);
		((RECTS *) _this->apfeat[FEATURE_STROKE_BBOX]->data)[iprim].y2   
			= (short) ((double) (rgprim[iprim].boundingBox.bottom + yShift) * yScale);
	};

	return TRUE;
}

BOOL CraneLoadFromPointer(LOCRUN_INFO *pLocRunInfo, QHEAD ** ppHead,QNODE **ppNode,BYTE *pbRes)
{
	int *pOffsetQBT;
    int *pOffsetQBH;
	int iLoad;
	const CRANEDB_HEADER	*pHeader	= (CRANEDB_HEADER *)pbRes;

	if ( (pHeader->fileType != CRANEDB_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > CRANEDB_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < CRANEDB_OLD_FILE_VERSION) 
		|| memcmp (pHeader->adwSignature, pLocRunInfo->adwSignature,sizeof(pHeader->adwSignature))
		) 
	{
		return FALSE;
	}
	pOffsetQBT = (int *)(pbRes + pHeader->headerSize);
    pOffsetQBH = pOffsetQBT + 29;

    for (iLoad = 1; iLoad <= 30; iLoad++)
	{
        ppHead[iLoad - 1] = (QHEAD *) (((BYTE *) pOffsetQBT) + pOffsetQBH[iLoad - 1]);
        ppNode[iLoad - 1] = (QNODE *) (((BYTE *) pOffsetQBT) + pOffsetQBT[iLoad - 1]);
	}
	return TRUE;
}

BOOL CraneLoadRes(HINSTANCE hInst, int resNumber, int resType, LOCRUN_INFO *pLocRunInfo)
{
	HANDLE          hres;
    HGLOBAL         hglb;

	BYTE * pBase;
    hres = FindResource(hInst, (LPCTSTR) resNumber, (LPCTSTR) resType);

    ASSERT(hres);

    if (hres == NULL)
        return FALSE;

    hglb = LoadResource(hInst, hres);

    ASSERT(hglb);

    if (hglb == NULL)
        return FALSE;

    pBase = (BYTE *) LockResource(hglb);

    if (pBase == NULL)
        return FALSE;

	return CraneLoadFromPointer(pLocRunInfo, gapqhList, gapqnList, pBase);
}

QNODE *SkipAltList(UNIQART *puni)
{
	while (puni->unicode)
		puni++;

	return (QNODE *) ++puni;
}

//FILE	*pDebugFile	 = 0;

QNODE *CraneFindAnswer(SAMPLE *psample, QNODE *pnode)
{
	SAMPLE_INFO             sample;

	if ((pnode->uniqart.qart.flag & 0xf0) != QART_QUESTION)
		return pnode;

// Now ask the question

	sample.pSample = psample;
	AnswerQuestion(pnode->uniqart.qart.question, pnode->param1, pnode->param2, &sample, 1);

//if (pDebugFile) {
//	fwprintf(pDebugFile, L"    CART: (%2d:%5d:%5d) -> %5d ?< %5d\n", pnode->uniqart.qart,
//		pnode->param1, pnode->param2, sample.iAnswer, pnode->value
//	);
//}
	if (sample.iAnswer <= pnode->value)
	{
		if (pnode->uniqart.qart.flag & QART_NOBRANCH)
			return CraneFindAnswer(psample, SkipAltList((UNIQART *) pnode->extra));
		else
			return CraneFindAnswer(psample, (QNODE *) pnode->extra);
	}
	else
	{
		if (pnode->uniqart.qart.flag & QART_NOBRANCH)
			return CraneFindAnswer(psample, (QNODE *) &pnode->offset);
		else
			return CraneFindAnswer(psample, (QNODE *) (((BYTE *) pnode->extra) + pnode->offset));
	}
}

BOOL CraneMatch(ALT_LIST *pAlt, 
				int cAlt, 
				GLYPH *pGlyph, 
				CHARSET *pCS, 
				DRECTS *pdrcs, 
				FLOAT eCARTWeight,
				LOCRUN_INFO *pLocRunInfo)
{
	int			cstrk = CframeGLYPH(pGlyph) - 1;		// Our arrays are zero based
	int			index;
	WORD		wStart;
	WORD		wFinal;
	QNODE	   *pqnode;
	SAMPLE		sample;

// See if Afterburner even has something with which to work

	if ((!pAlt->cAlt) || (cstrk < 0) || (cstrk >= 30))
		return FALSE;

// Get the page number of the top choice from the previous shape matcher

	index = HIGH_INDEX(pAlt->awchList[0]);

	if ((index < 0) || (index >= HIGH_INDEX_LIMIT - 1))
		return FALSE;

	wStart = gapqhList[cstrk]->awIndex[index];
	wFinal = gapqhList[cstrk]->awIndex[index + 1];

// Note that wStart may equal wFinal, in which case there are no valid selections.
// Next get the low byte from the top choice, shift it to the left-most byte position.
// Also, assume we didn't find a CART to run.

	index  = (pAlt->awchList[0] & 0x00ff) << 24;
	pqnode = (QNODE *) NULL;

	while (wStart < wFinal)
	{
		if ((gapqhList[cstrk]->aqIndex[wStart] & 0xff000000) == ((DWORD) index))
		{
			pqnode = (QNODE *) &(((BYTE *) gapqnList[cstrk])[gapqhList[cstrk]->aqIndex[wStart] & 0x00ffffff]);
			break;
		}

		if (gapqhList[cstrk]->aqIndex[wStart] > ((DWORD) index))
			break;

		wStart++;
	}

// If no tree was found, exit

	if (pqnode == (QNODE *) NULL)
		return FALSE;

// OK, now we know we have a CART to run.  Featurize the ink and run the tree

	InitFeatures(&sample);
	sample.drcs = *pdrcs;
	wFinal = MakeFeatures(&sample, pGlyph) ? *((WORD *) CraneFindAnswer(&sample, pqnode)) : 0;
	FreeFeatures(&sample);

// Did CART give us back a meaningful result?

	if (!wFinal)
        return FALSE;

	// Short cut processing if we are top 1 already.
	if (wFinal == pAlt->awchList[0]) {
		pAlt->aeScore[0] += (FLOAT)eCARTWeight;
		return TRUE;
	}

// Did CART give us a code point that is enabled by the current recmask

    {
        if (!IsAllowedChar(pLocRunInfo, pCS, wFinal))
        {
            return FALSE;  // Can't stick it in.
        }
    }

// Now, walk through the previous ALT_LIST and see if this character was already proposed

	index = 0;
	while (((UINT) index) < pAlt->cAlt)
	{
		if (pAlt->awchList[index] == wFinal)
			break;

		index++;
	}

	if ((UINT) index >= pAlt->cAlt) {
		if (pAlt->cAlt < (UINT) cAlt) {
			pAlt->cAlt++; 
		} else {
			index--;
		}
	}

	while (index)
	{
		pAlt->awchList[index] = pAlt->awchList[index - 1];
		pAlt->aeScore[index] = pAlt->aeScore[index - 1];
		index--;
	}

	pAlt->awchList[0] = wFinal;
	pAlt->aeScore[0] = pAlt->aeScore[1] + (FLOAT)eCARTWeight;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\features.c ===
#include "crane.h"
#include "common.h"

const FEATURE_KIND gakind[FEATURE_COUNT] =
{
	{ typeSHORT,	freqSTROKE },	// FEATURE_ANGLE_NET
	{ typeUSHORT,	freqSTROKE },	// FEATURE_ANGLE_ABS
	{ typeBYTE,		freqSTROKE },	// FEATURE_STEPS
	{ typeBYTE,		freqSTROKE },	// FEATURE_FEATURES
	{ typePOINTS,	freqSTROKE },	// FEATURE_XPOS
	{ typePOINTS,	freqSTROKE },	// FEATURE_YPOS
	{ typeRECTS,	freqSTROKE },	// FEATURE_STROKE_BBOX
	{ typeUSHORT,	freqSTROKE }	// FEATURE_LENGTH
};

const size_t gasize[typeCOUNT] =
{
	sizeof(BYTE),					// typeBOOL
	sizeof(BYTE),					// typeBYTE
	2 * sizeof(BYTE),				// type8DOT8
	sizeof(SHORT),					// typeSHORT
	sizeof(USHORT),					// typeUSHORT
	2 * sizeof(WORD),				// type16DOT16
	sizeof(POINTS),					// typePOINTS
	sizeof(LONG),					// typeLONG
	sizeof(ULONG),					// typeULONG
	2 * sizeof(ULONG),				// type32DOT32
	sizeof(RECTS),					// typeRECTS
	sizeof(DRECTS),					// typeDRECTS
	sizeof(POINTL),					// typePOINT
	sizeof(DRECT)					// typeDRECT
};

void InitFeatures(SAMPLE *_this)
{
	memset(_this->apfeat, '\0', sizeof(FEATURES) * FEATURE_COUNT);
}

void FreeFeatures(SAMPLE *_this)
{
	int		ifeat;

	for (ifeat = 0; ifeat < FEATURE_COUNT; ifeat++)
	{
		if (_this->apfeat[ifeat])
			ExternFree(_this->apfeat[ifeat]);
	}
}

BOOL AllocFeature(SAMPLE *_this, int nID)
{
	DWORD	cnt;

	switch (gakind[nID].freq)
	{
	case freqSTROKE:
		cnt = _this->cstrk;
		break;

	case freqFEATURE:
	case freqSTEP:
	case freqPOINT:
		return FALSE;
	}

	if ((_this->apfeat[nID] = (FEATURES *) ExternAlloc(sizeof(FEATURES) + cnt * gasize[gakind[nID].type])) == (FEATURES *) NULL)
		return FALSE;

	_this->apfeat[nID]->cElements = cnt;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\dfa.h ===
// dfa.h
// Angshuman Guha
// aguha
// Jan 17, 2001

#ifndef __INC_DFA_H_
#define __INC_DFA_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	short iState;
	short jState;
	short iAlphabet;
} Transition;

short MakeDFA(PARSETREE *tree,			// in
			  int cPosition,	        // in
			  IntSet *aFollowpos,		// in
			  WCHAR *aPos2Wchar,         // in
			  int cAlphabet,            // in
			  WCHAR *aAlphabet,         // in
			  int *pcTransition,         // out
			  Transition **paTransition, // out
			  unsigned char **ppbFinal); // out

BOOL MinimizeDFA(short *pcState,
			     unsigned char **ppbFinal,
				 int *pcTransition,
				 Transition **ppTransition);

BOOL MakeCanonicalDFA(short cState,
					  unsigned char *abFinal,
					  int cTransition,
					  Transition *aTransition);

void *ConvertDFAtoBlob(int cTransition, 
					   Transition *aTransition, 
					   int cAlphabet, 
					   WCHAR *aAlphabet, 
					   int cState, 
					   unsigned char *abFinal);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\io.c ===
#include "crane.h"
#include <ASSERT.h>

#define	READ_BUF_SIZE	1024

#define	MAX_LINE		2048

static	wchar_t			abuff[MAX_LINE];
extern	FEATURE_KIND	gakind[];
extern	size_t			gasize[];

wchar_t *LastLineSample()
{
	return abuff;
}

BOOL AllocFeature(SAMPLE *, int);

void PutElement(FILE *fpo, void *pv, int type, wchar_t chSep)
{
	int		status;

	switch (type)
	{
	case typeBOOL:
		status	= fwprintf(fpo, L"%c%c", chSep, *((BYTE *) pv) ? L'T' : L'F');
		ASSERT(status == 2);
		break;

	case typeBYTE:
		status	= fwprintf(fpo, L"%c%02X", chSep, *((BYTE *) pv));
		ASSERT(status == 3);
		break;

	case type8DOT8:
		status	= fwprintf(fpo, L"%c%04X", chSep, *((WORD *) pv));
		ASSERT(status == 5);
		break;

	case typeSHORT:
		status	= fwprintf(fpo, L"%c%d", chSep, *((SHORT *) pv));
		ASSERT(status >= 2 && status <= 7);
		break;

	case typeUSHORT:
		status	= fwprintf(fpo, L"%c%d", chSep, *((USHORT *) pv));
		ASSERT(status >= 2 && status <= 6);
		break;

	case typePOINTS:
		status	= fwprintf(fpo, L"%c%d,%d", chSep, ((END_POINTS *) pv)->start, ((END_POINTS *) pv)->end);
		ASSERT(status >= 4 && status <= 14);
		break;

	case typeDRECTS:
		status	= fwprintf(fpo, L"%c%d,%d,%d,%d", chSep, ((DRECTS *) pv)->x, ((DRECTS *) pv)->y, ((DRECTS *) pv)->w, ((DRECTS *) pv)->h);
		ASSERT(status >= 8 && status <= 28);
		break;

	case typeRECTS:
		status	= fwprintf(fpo, L"%c%d,%d,%d,%d", chSep, ((RECTS *) pv)->x1, ((RECTS *) pv)->y1, ((RECTS *) pv)->x2, ((RECTS *) pv)->y2);
		ASSERT(status >= 8 && status <= 28);
		break;

	default:
		break;
	}
}

// Write out one featurized ink sample

BOOL WriteSample(SAMPLE *_this, FILE *fpo)
{
	int		ifeat;
	int		ielem;
	int		cstrk;
	int		size;
	int		type;
	BYTE   *base;

// Get the stroke count

	cstrk = _this->cstrk;

	if ( fwprintf(fpo, L"%02d %04X <%s %d %d>", cstrk, _this->wchLabel, _this->aSampleFile, _this->ipanel, _this->ichar) < 15 ||
		 fwprintf(fpo, L" %d %d,%d,%d,%d", _this->fDakuten, _this->drcs.x, _this->drcs.y, _this->drcs.w, _this->drcs.h) < 10 )
	{
		return FALSE;
	}

	for (ielem = 0; ielem < MAX_RECOG_ALTS; ielem++) 
	{
		if ( fwprintf(fpo, L"%c%04X", ielem ? L',' : L' ', _this->awchAlts[ielem]) < 5 )
		{
			return FALSE;
		}
	}

	for (ifeat = 0; ifeat < FEATURE_COUNT; ifeat++)
	{
	// Get the number of elements in this feature

		switch (gakind[ifeat].freq)
		{
		case freqSTROKE:
			base = (BYTE *) (_this->apfeat[ifeat]->data);
			type = gakind[ifeat].type;
			size = gasize[type];
			for (ielem = 0; ielem < cstrk; ielem++)
				PutElement(fpo, (void *) (base + ielem * size), type, (wchar_t) (ielem ? L':' : L' '));
			break;

		case freqFEATURE:
		case freqSTEP:
		case freqPOINT:
			break;
		}

	// Print the element list

	}

	if ( fwprintf(fpo, L"\n") != 1 )
	{
		return FALSE;
	}
	return TRUE;
}

// Read a hexadecimal number

wchar_t *GetHEXADEC(wchar_t *pbuff, long *pval)
{
	wchar_t	*pRef = pbuff;

   *pval = 0;

	while (iswxdigit(*pbuff))
	{
	   *pval <<= 4;
	   *pval  += (BYTE)(*pbuff < L'A' ? *pbuff - L'0' : *pbuff - L'A' + 10);
	  ++pbuff;
	}

	ASSERT(pRef + 1 <= pbuff);
	ASSERT(pRef + 8 >= pbuff);

	return pbuff;
}

// Read in a signed integer

wchar_t *GetInteger(wchar_t *pbuff, long *pval)
{
	wchar_t	*pRef = pbuff;

	BOOL	bNeg = FALSE;

	if (*pbuff == L'-')
	{
		pbuff++;
		bNeg = TRUE;
	}

   *pval = 0;

	while (iswdigit(*pbuff))
	{
	   *pval *= 10;
	   *pval += (BYTE)(*pbuff - L'0');
	  ++pbuff;
	}

	if (bNeg)
	   *pval = -(*pval);

	ASSERT(pRef + 1 + bNeg <= pbuff);
	ASSERT(pRef + 11 >= pbuff);

	return pbuff;
}

wchar_t *GetPOINT(wchar_t *pbuff, POINT *ppt)
{
	if (((pbuff = GetInteger(pbuff, &ppt->x)) == (wchar_t *) NULL) || (*pbuff++ != L',')) {
		ASSERT(FALSE);
		return (wchar_t *) NULL;
	}

	return GetInteger(pbuff, &ppt->y);
}

wchar_t *GetRECT(wchar_t *pbuff, RECT *prc)
{
	if (((pbuff = GetInteger(pbuff, &prc->left)) == (wchar_t *) NULL) || (*pbuff++ != L',')) {
		ASSERT(FALSE);
		return (wchar_t *) NULL;
	}

	if (((pbuff = GetInteger(pbuff, &prc->top)) == (wchar_t *) NULL) || (*pbuff++ != L',')) {
		ASSERT(FALSE);
		return (wchar_t *) NULL;
	}

	if (((pbuff = GetInteger(pbuff, &prc->right)) == (wchar_t *) NULL) || (*pbuff++ != L',')) {
		ASSERT(FALSE);
		return (wchar_t *) NULL;
	}

	return GetInteger(pbuff, &prc->bottom);
}

wchar_t *GetElement(wchar_t *pbuff, void *pv, int type)
{
	long	val;
	POINT	pt;
	RECT	rc;

	switch (type)
	{
	case typeBOOL:
		if (*pbuff == L'T')
			*((BYTE *) pv) = TRUE, pbuff++;
		else if (*pbuff == L'F')
			*((BYTE *) pv) = FALSE, pbuff++;
		else {
			ASSERT(FALSE);
			pbuff = (wchar_t *) NULL;
		}
		break;
		
	case typeBYTE:
		pbuff = GetHEXADEC(pbuff, &val);
		ASSERT(pbuff);
		*((BYTE *) pv) = (BYTE) val;
		break;

	case type8DOT8:
		pbuff = GetHEXADEC(pbuff, &val);
		ASSERT(pbuff);
		*((WORD *) pv) = (WORD) val;
		break;

	case typeSHORT:
		pbuff = GetInteger(pbuff, &val);
		ASSERT(pbuff);
		*((short *) pv) = (short) val;
		break;

	case typeUSHORT:
		pbuff = GetInteger(pbuff, &val);
		ASSERT(pbuff);
		*((USHORT *) pv) = (USHORT) val;
		break;

	case typePOINTS:
		pbuff = GetPOINT(pbuff, &pt);
		ASSERT(pbuff);
		((END_POINTS *) pv)->start = (short) pt.x;
		((END_POINTS *) pv)->end   = (short) pt.y;
		break;

	case typeDRECTS:
		pbuff = GetRECT(pbuff, &rc);
		ASSERT(pbuff);
		((DRECTS *) pv)->x = (short) rc.left;
		((DRECTS *) pv)->y = (short) rc.top;
		((DRECTS *) pv)->w = (short) rc.right;
		((DRECTS *) pv)->h = (short) rc.bottom;
		break;

	case typeRECTS:
		pbuff = GetRECT(pbuff, &rc);
		ASSERT(pbuff);
		((RECTS *) pv)->x1 = (short) rc.left;
		((RECTS *) pv)->y1 = (short) rc.top;
		((RECTS *) pv)->x2 = (short) rc.right;
		((RECTS *) pv)->y2 = (short) rc.bottom;
		break;

	default:
		pbuff = (wchar_t *) NULL;
		ASSERT(pbuff);
		break;
	}

	return pbuff;
}

// Read in a feature list.  This will allocate the sample if needed as well as all the space
// needed to store the feature lists. 

SAMPLE *DoReadSample(SAMPLE *_this)
{
	BOOL	bAlloc  = FALSE;
	BOOL	bFailed = FALSE;
	int		ifeat;
	int		ielem;
	int		type;
	int		size;
	BYTE   *base;
	wchar_t   *pbuff;
	unsigned long	uLong;
	int		status;

	if (_this == (SAMPLE *) NULL)
	{
		if ((_this = (SAMPLE *) ExternAlloc(sizeof(SAMPLE))) == (SAMPLE *) NULL) {
			ASSERT(FALSE);
			return (SAMPLE *) NULL;
		}

		bAlloc = TRUE;
	}

	InitFeatures(_this);

// Get the first items: stroke count, codepoint, file name and file index

	status	= swscanf(abuff, L"%2d %4X <%s %d %d>", &_this->cstrk, &_this->wchLabel, _this->aSampleFile, &_this->ipanel, &_this->ichar);
	if (status != 5) {
		return (SAMPLE *) NULL;
	}

// Position the input cursor to the space just after the closing angle bracket of the file info

	pbuff = abuff;
	while (*pbuff && (*pbuff++ != L'>'))
		;
	if (pbuff < abuff + 15) {
		return (SAMPLE *) NULL;
	}
	if (pbuff > abuff + 50) {
		return (SAMPLE *) NULL;
	}

// The dakuten and guide features live directly in the sample, handle them

	pbuff = GetElement(++pbuff, (void *) &_this->fDakuten, typeSHORT);
	if (!pbuff) {
		return (SAMPLE *) NULL;
	}
	pbuff = GetElement(++pbuff, (void *) &_this->drcs, typeDRECTS);
	if (!pbuff) {
		return (SAMPLE *) NULL;
	}

// The Zilla alternate list comes next
	++pbuff;	// Skip space
	pbuff				= GetHEXADEC(pbuff, &uLong);
	if (!pbuff) {
		return (SAMPLE *) NULL;
	}
	_this->awchAlts[0]	= (wchar_t)uLong;
	for (ielem = 1; ielem < MAX_RECOG_ALTS && pbuff && *pbuff++ == L','; ielem++) 
	{
		pbuff					= GetHEXADEC(pbuff, &uLong);
		if (!pbuff) {
			return (SAMPLE *) NULL;
		}
		_this->awchAlts[ielem]	= (wchar_t)uLong;
	}

// Allocate the remaining features and read them.  If the cursor is ever pointing 
// at something we don't expect, panic.

	for (ifeat = 0; ifeat < FEATURE_COUNT; ifeat++)
	{
		if (bFailed || !AllocFeature(_this, ifeat) || *pbuff != L' ')
		{
			FreeFeatures(_this);

			if (bAlloc)
				ExternFree(_this);

			ASSERT(FALSE);
			return (SAMPLE *) NULL;
		}

	// OK, now we have space to store the results

		switch (gakind[ifeat].freq)
		{
		case freqSTROKE:
			base = (BYTE *) (_this->apfeat[ifeat]->data);
			type = gakind[ifeat].type;
			size = gasize[type];
			for (ielem = 0; ielem < _this->cstrk; ielem++)
			{
			// Each element should be preceded by a colon

				if (ielem && (*pbuff != L':'))
					bFailed = TRUE;

				pbuff = GetElement(++pbuff, (void *) (base + ielem * size), type);
				if (pbuff == (wchar_t *) NULL) {
					ASSERT(pbuff);
					bFailed = TRUE;
					break;
				}
			}
			break;

		case freqFEATURE:
		case freqSTEP:
		case freqPOINT:
			break;
		}
	}

	if (bFailed)
	{
		FreeFeatures(_this);

		if (bAlloc)
			ExternFree(_this);

		ASSERT(FALSE);
		return (SAMPLE *) NULL;
	}

	return _this;
}

// Read using stdio library.
SAMPLE *ReadSample(SAMPLE *_this, FILE *fpi)
{
	if (!fgetws(abuff, MAX_LINE, fpi)) {
		ASSERT(feof(fpi));
		return (SAMPLE *) NULL;
	}

	return DoReadSample(_this);
}

// EOF Flag for DoLineRead used by ReadSampleH
static int	g_fEOF		= FALSE;

// Reset EOF Flag for DoLineRead.
void ResetReadSampleH()
{
	g_fEOF		= FALSE;
}

// Read one line of input.
BOOL DoLineRead(HANDLE hFile, wchar_t *pBuf, int sizeBuf)
{
	static int	iReadBuf	= 0;
	static int	cReadBuf	= 0;
	static BYTE	aReadBuf[READ_BUF_SIZE];

	BOOL		fHaveCR;
	int			cBuf;

	// Check for end of file on last call.
	if (g_fEOF) {
		return FALSE;
	}

	// Make sure we keep room for null.
	--sizeBuf;

	// Loop until we have a full line.
	cBuf	= 0;
	fHaveCR	= FALSE;
	while (TRUE) {
		DWORD		bytesRead;

		// Make sure we have something in the buffer.
		if (iReadBuf == cReadBuf) {
			if (!ReadFile(hFile, aReadBuf, READ_BUF_SIZE, &bytesRead, NULL)) {
				// Read error!
				ASSERT(0);
				return FALSE;
			}
			if (bytesRead == 0) {
				// EOF
				g_fEOF	= TRUE;
				pBuf[cBuf]	= L'\0';
				return cBuf != 0;
			}

			cReadBuf	= bytesRead;
			iReadBuf	= 0;
		}

		// If we had a CR last time we must have a LF this time.
		if (fHaveCR) {
			if (aReadBuf[iReadBuf] == '\n') {
				++iReadBuf;
			} else {
				// Missing LF?!?!
				ASSERT(0);
			}
			break;
		}

		// Copy one character, checking for end of line.
		// We convert to Unicode, but since we just use
		// plain ASCII, so all we do is zero extend.
		if (aReadBuf[iReadBuf] == '\r') {
			++iReadBuf;
			fHaveCR		= TRUE;
		} else if (aReadBuf[iReadBuf] == '\n') {
			// Floating NL?!?!
			++iReadBuf;
			break;
		} else {
			if (cBuf >= sizeBuf) {
				// Line too long!
				ASSERT(0);
				break;
			}
			pBuf[cBuf++]	= (wchar_t)aReadBuf[iReadBuf++];
		}
	}

	// Terminate string and return.
	pBuf[cBuf]	= L'\0';
	return TRUE;
}

// Read using Windows calls.
SAMPLE *ReadSampleH(SAMPLE *_this, HANDLE hFile)
{
	// Outer loop to deal with stuped COPY comand putting ^Z characters in the file.
	do {
		if (!DoLineRead(hFile, abuff, MAX_LINE)){
			return (SAMPLE *)-1;
		}
	} while (abuff[0] == L'\x1a' && abuff[1] == L'\0');

	return DoReadSample(_this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\cranep.h ===
/**************************************************************************\
 * FILE: cranep.h
 *
 * Main include file for stuff private to crane.lib and crane.dat
\**************************************************************************/

#ifndef CRANEP_H
#define CRANEP_H 1

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif

// Global data tables used to get at crane database.
extern QHEAD  *gapqhList[30];
extern QNODE  *gapqnList[30];

// Magic keys the identifies crane.dat file
#define	CRANEDB_FILE_TYPE	0xAAAABBBB

// Version information for each file type.
#define	CRANEDB_MIN_FILE_VERSION		0		// First version of code that can read this file
#define CRANEDB_CUR_FILE_VERSION		0		// Current version of code.
#define	CRANEDB_OLD_FILE_VERSION		0		// Oldest file version this code can read.


// The header of the costcalc.bin file
typedef struct tagCRANEDB_HEADER {
	DWORD		fileType;		// This should always be set to CRANEDB_FILE_TYPE.
	DWORD		headerSize;		// Size of the header.
	BYTE		minFileVer;		// Earliest version of code that can read this file
	BYTE		curFileVer;		// Current version of code that wrote the file.
	wchar_t		locale[4];		// Locale ID string.
	DWORD		adwSignature[3];	// Locale signature
	WORD		reserved1;
	DWORD		reserved2[3];
} CRANEDB_HEADER;

// Load fundtions.
BOOL CraneLoadFromPointer(LOCRUN_INFO *pLocRunInfo, QHEAD ** ppHead,QNODE **ppNode,BYTE *pbRes);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\intset.h ===
// IntSet.h
// Angshuman Guha
// aguha
// Jan 15, 2001


#ifndef __INC_INTSET_H
#define __INC_INTSET_H

#ifdef __cplusplus
extern "C" {
#endif

typedef void * IntSet;

BOOL MakeIntSet(unsigned int cUniverse, IntSet *pIntSet);  // members are 0 thru cUniverse-1, initially empty
BOOL CopyIntSet(IntSet is, IntSet *pIntSet);
void DestroyIntSet(IntSet is);

BOOL AddMemberIntSet(IntSet is, unsigned int member); // TRUE == success
BOOL UnionIntSet(IntSet dst, IntSet src); // TRUE == success
BOOL FirstMemberIntSet(IntSet is, unsigned int *pmember); // TRUE == success
BOOL NextMemberIntSet(IntSet is, unsigned int *pmember); // TRUE == success
BOOL IsEqualIntSet(IntSet is1, IntSet is2);
BOOL IsMemberIntSet(IntSet is, unsigned int member);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\factoid.h ===
// factoid.h

#ifndef __INC_FACTOID_REGEXP_H
#define __INC_FACTOID_REGEXP_H

//#define FACTOID_DEFAULT		0

#define FACTOID_SYSDICT		1
#define FACTOID_WORDLIST	2
#define FACTOID_EMAIL		3
#define FACTOID_WEB			4
/* all of the 10 number classes, see below */
#define FACTOID_NUMBER		5
/* sequence of leading punctuation */
#define FACTOID_LPUNC		6
/* sequence of trailing punctuation */
#define FACTOID_TPUNC		7
/* stand-alone sequence of punctuation characters */
#define FACTOID_PUNC		8
/* '-' or '/' */
#define FACTOID_HYPHEN		9
/* optional-sign integer-part optional-fractional-part */
#define FACTOID_NUMSIMPLE	10
/* integer followed by a rank like st, nd, rd, th */
#define FACTOID_NUMNTH		11
/* number followed by a common unit like km */
#define FACTOID_NUMUNIT		12
/* the "#" sign followed by an integer */
#define FACTOID_NUMNUM		13
/* number followed by a "%" sign */
#define FACTOID_NUMPERCENT	14
#define FACTOID_NUMDATE		15
#define FACTOID_NUMTIME		16
#define FACTOID_NUMCURRENCY	17
#define FACTOID_NUMPHONE	18
/* simple math expression or (in)equation */
#define FACTOID_NUMMATH		19
/* single uppercase alphabetic character */
#define FACTOID_UPPERCHAR	20
/* single lowercase alphabetic character */
#define FACTOID_LOWERCHAR	21
/* single digit */
#define FACTOID_DIGITCHAR  	22
/* single punctuation character */
#define FACTOID_PUNCCHAR	23
/* any single character */
#define FACTOID_ONECHAR		24
#define FACTOID_ZIP			25
#define FACTOID_CREDITCARD	26
#define FACTOID_DAYOFMONTH	27
#define FACTOID_MONTHNUM	28
#define FACTOID_YEAR		29
#define FACTOID_SECOND		30
#define FACTOID_MINUTE		31
#define FACTOID_HOUR		32
/* social security number */
#define FACTOID_SSN			33
#define FACTOID_DAYOFWEEK	34
#define FACTOID_MONTH		35
#define FACTOID_GENDER		36
#define FACTOID_BULLET		37
#define FACTOID_FILENAME    38
#define FACTOID_NONE		39

/* EA factoid IDs */
#define FACTOID_JPN_COMMON    100
#define FACTOID_CHS_COMMON    101
#define FACTOID_CHT_COMMON    102
#define FACTOID_KOR_COMMON    103
#define FACTOID_HIRAGANA      104
#define FACTOID_KATAKANA      105
#define FACTOID_KANJI_COMMON  106
#define FACTOID_KANJI_RARE    107
#define FACTOID_BOPOMOFO      108
#define FACTOID_JAMO          109
#define FACTOID_HANGUL_COMMON 110
#define FACTOID_HANGUL_RARE   111

#endif
#ifdef __cplusplus
extern "C" {
#endif

int StringToFactoid(WCHAR *wsz, int iLength);
int ParseFactoidString(WCHAR *wsz, int cMaxFactoid, DWORD *aFactoidID);
void SortFactoidLists(DWORD *a, int c);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\sources.inc ===
TARGETNAME=crane
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\crane\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\answer.c \
         ..\crane.c \
         ..\features.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\ptree.h ===
// ptree.h

#ifndef __INC_PTREE_H
#define __INC_PTREE_H

#include "common.h"
#include "intset.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct tagPARSETREE {
	int value;
	BOOL nullable;
	IntSet FirstPos;
	IntSet LastPos;
	unsigned int position; // used only for leaves
	struct tagPARSETREE *left;
	struct tagPARSETREE *right;
} PARSETREE;

void DestroyPARSETREE(PARSETREE *tree);
PARSETREE *MakePARSETREE(int value);
PARSETREE *MergePARSETREE(PARSETREE *tree1, PARSETREE *tree2);
int SizePARSETREE(PARSETREE *tree);
PARSETREE *CopyPARSETREE(PARSETREE *tree);
BOOL MakePureRegularExpression(PARSETREE *tree);
int ComputeNodeAttributes(PARSETREE *tree, IntSet **paFollowpos, WCHAR **paPos2Wchar);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\re_api.h ===
// re_api.h
// Angshuman Guha
// aguha
// July 18, 2001

#ifndef __INC_REGULAR_EXPRESSION_API_
#define __INC_REGULAR_EXPRESSION_API_

#ifdef __cplusplus
extern "C" {
#endif

void *CompileRegularExpression(WCHAR *wsz);
void *CompileSingleFactoid(DWORD factoid);
void *CompileFactoidList(DWORD *aFactoidID, int cFactoid);
void *CopyCompiledFactoid(void *pvFactoid);
#ifdef STANDALONE_RE2FSA
void *CompileWordlistA(char *szInFile);
#endif

int CountOfStatesFACTOID(void *pvFactoid);
BOOL IsValidStateFACTOID(void *pvFactoid, WORD state);
int CountOfTransitionsFACTOID(void *pvFactoid, WORD state);
BOOL GetTransitionFACTOID(void *pvFactoid, WORD state, int iTransition, WORD *pFactoidID, WORD *pNextState);

void *CompileRegExpW(BOOL bFile, WCHAR *wsz);
void *CompileRegExpA(BOOL bFile, unsigned char *sz);
char *RegExpErrorA(void);
WCHAR *RegExpErrorW(void);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\re_input.h ===
#ifndef __INC_REGULAR_EXPRESSION_INPUT_
#define __INC_REGULAR_EXPRESSION_INPUT_

#ifdef __cplusplus
extern "C" {
#endif

PARSETREE *ParseInput(WCHAR *wsz);

#ifdef STANDALONE_RE2FSA
PARSETREE *ParseWordlist(WCHAR *wsz);
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\strtable.h ===
// strtable.h
// Angshuman Guha
// aguha
// Dec 1, 2000

#ifndef __INC_STRTABLE_H
#define __INC_STRTABLE_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct tagStringNode {
	WCHAR *wsz;
	short value;
	struct tagStringNode *left;
	struct tagStringNode *right;
} STRINGNODE;

typedef struct tagStringTable {
	int count;
	STRINGNODE *root;
} STRINGTABLE;

int InsertSymbol(WCHAR *wsz, int length, STRINGTABLE *strtable);
WCHAR **FlattenSymbolTable(STRINGTABLE *strtable);
void DestroySymbolTable(STRINGNODE *root, BOOL bStringsToo);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif

!if $(FREEBUILD)
HWXBIN=$(_TPG_ROOT)\hwx\release
!else
HWXBIN=$(_TPG_ROOT)\hwx\debug
!endif

hwxbin: $(O)\$(TARGETNAME).$(TARGETEXT)
    mkdir $(HWXBIN)
    copy $(O)\$(TARGETNAME).$(TARGETEXT) $(HWXBIN)
    copy $(O)\$(TARGETNAME).pdb $(HWXBIN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\dfa.c ===
// dfa.c
// Angshuman Guha
// aguha
// Jan 17, 2001

/* This file contains all functions pertaining to manipulating
deterministic finite state machines including functions to 
create (from the parse tree of a regular expression)
and minimizing a machine.
*/

#include <stdlib.h>
#include <search.h>
#include <common.h>
#include "ptree.h"
#include "dfa.h"
#include "regexp.h"

typedef struct tagStateList {
	IntSet is;
	short index;
	struct tagStateList *next;
} StateList;

typedef struct tagTransitionList {
	short iState;
	short iAlphabet; // index
	short jState;
	struct tagTransitionList *next;
} TransitionList;

/******************************Private*Routine******************************\
* MakeTransitionList
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
TransitionList *MakeTransitionList(short iState, short iAlphabet, short jState)
{
	TransitionList *p = (TransitionList *) ExternAlloc(sizeof(TransitionList));
	if (!p)
		return NULL;
	p->iState = iState;
	p->iAlphabet = iAlphabet;
	p->jState = jState;
	p->next = NULL;
	return p;
}

/******************************Private*Routine******************************\
* MakeStateList
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
StateList *MakeStateList(IntSet is, short index)
{
	StateList *p = (StateList *) ExternAlloc(sizeof(StateList));
	if (!p)
		return NULL;
	p->is = is;
	p->index = index;
	p->next = NULL;
	return p;
}

/******************************Private*Routine******************************\
* FindIntSet
*
* Given a list of states (each state is an IntSet), searches for a given
* IntSet.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
short FindIntSet(StateList *pStateList, IntSet is)
{
	while (pStateList)
	{
		if (IsEqualIntSet(pStateList->is, is))
			return pStateList->index;
		pStateList = pStateList->next;
	}

	return -1;
}

/******************************Private*Routine******************************\
* DestroyStateList
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyStateList(StateList *p)
{
	StateList *q;

	while (p)
	{
		q = p->next;
		DestroyIntSet(p->is);
		ExternFree(p);
		p = q;
	}
}

/******************************Public*Routine******************************\
* MakeDFA
*
* Top-level function to construct a DFA directly from the parse tree of
* a regular expression (without producing an intermediate NDFA).
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
short MakeDFA(PARSETREE *tree,			// in
			  int cPosition,	        // in
			  IntSet *aFollowpos,		// in
			  WCHAR *aPos2Wchar,         // in
			  int cAlphabet,            // in
			  WCHAR *aAlphabet,         // in
			  int *pcTransition,         // out
			  Transition **paTransition, // out
			  unsigned char **ppbFinal)  // out
{
	int i, cTrans=0;
	short cState = 0;
	StateList *Marked=NULL, *Unmarked=NULL, *p;
	unsigned char iAlphabet;
	unsigned int pos;
	TransitionList *pTrans = NULL, *tmp;
	unsigned char *abFinal = NULL;
	Transition *aTransition = NULL;
	IntSet intset = 0;
	BOOL b, bRet=TRUE;

	// initialize list of unmarked states
	if (!CopyIntSet(tree->FirstPos, &intset))
	{
		SetErrorMsgS("malloc failure");
		bRet = FALSE;
		goto cleanup;
	}
	Unmarked = MakeStateList(intset, cState++);
	if (!Unmarked)
	{
		SetErrorMsgS("malloc failure");
		bRet = FALSE;
		goto cleanup;
	}
	intset = 0;
	// process each unmarked state
	while (Unmarked)
	{
		IntSet is = Unmarked->is;
		short iState = Unmarked->index;
		p = Unmarked->next;
		Unmarked->next = Marked;
		Marked = Unmarked;
		Unmarked = p;

		// for each alphabet:
		// find a position included in the current state (a state is a set of positions)
		// such that the position corresponds to the alphabet
		// find the followpos of that position
		// and make the union of all these followpos'es
		for (iAlphabet=0; iAlphabet<cAlphabet; iAlphabet++)
		{
			IntSet newset = 0;

			for (b = FirstMemberIntSet(is, &pos); b; b = NextMemberIntSet(is, &pos))
			{
				if (aPos2Wchar[pos] == aAlphabet[iAlphabet])
				{
					if (newset)
					{
						b = UnionIntSet(newset, aFollowpos[pos]);
						ASSERT(b);
					}
					else
					{
						if (!CopyIntSet(aFollowpos[pos], &newset))
						{
							SetErrorMsgS("malloc failure");
							bRet = FALSE;
							goto cleanup;
						}
					}
				}
			}

			// if the union of the followpos'es is nonempty,
			// it is the next state from the current state on the current alphabet
			if (newset)
			{
				// make the state if it doesn't already exist
				short jState = FindIntSet(Unmarked, newset);
				if (jState < 0)
					jState = FindIntSet(Marked, newset);
				if (jState < 0)
				{
					p = MakeStateList(newset, cState);
					if (!p)
					{
						bRet = FALSE;
						goto cleanup;
					}
					jState = cState++;
					p->next = Unmarked;
					Unmarked = p;
				}
				else
					DestroyIntSet(newset);
				// record the transition from the current state to the new state
				tmp = MakeTransitionList(iState, iAlphabet, jState);
				if (!tmp)
				{
					bRet = FALSE;
					goto cleanup;
				}
				if (pTrans)
					tmp->next = pTrans;
				pTrans = tmp;
				cTrans++;
			}
		}
	}

	// need to find out which states are final
	ASSERT(aPos2Wchar[cPosition-1] == 1);
	ASSERT(!Unmarked);
	abFinal = (unsigned char *) ExternAlloc(cState);
	if (!abFinal)
	{
		SetErrorMsgSD("malloc failure %d", cState);
		bRet = FALSE;
		goto cleanup;
	}
	// all states containing the position associated with the endmarker
	// are valid (final)
	p = Marked;
	while (p)
	{
		StateList *q = p->next;

		abFinal[p->index] = !!IsMemberIntSet(p->is, cPosition-1);

		DestroyIntSet(p->is);
		ExternFree(p);
		p = q;
	}
	Marked = NULL;

	// convert the transition list into a plain array
	aTransition = (Transition *) ExternAlloc(cTrans * sizeof(Transition));
	if (!aTransition)
	{
		SetErrorMsgSD("malloc failure %d", cTrans * sizeof(Transition));
		bRet = FALSE;
		goto cleanup;
	}
	for (i=0; i<cTrans; i++)
	{
		aTransition[i].iState = pTrans->iState;
		aTransition[i].jState = pTrans->jState;
		aTransition[i].iAlphabet = pTrans->iAlphabet;
		tmp = pTrans->next;
		ExternFree(pTrans);
		pTrans = tmp;
	}
	ASSERT(pTrans == NULL);

cleanup:
	if (bRet)
	{
		// return computed values
		*pcTransition = cTrans;
		*paTransition = aTransition;
		*ppbFinal = abFinal;
		return cState;
	}
	else
	{
		if (intset)
			DestroyIntSet(intset);
		DestroyStateList(Unmarked);
		DestroyStateList(Marked);
		while (pTrans)
		{
			tmp = pTrans->next;
			ExternFree(pTrans);
			pTrans = tmp;
		}
		if (abFinal)
			ExternFree(abFinal);
		if (aTransition)
			ExternFree(aTransition);
		return -1;
	}
}

/******************************Private*Routine******************************\
* EqualArrays
*
* Test if two short arrays are equal or not.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int EqualArrays(short c, short *p1, short *p2)
{
	for (; c; c--)
	{
		if (*p1++ != *p2++)
			return 0;
	}

	return 1;
}

/******************************Private*Routine******************************\
* DistinguishableStates
*
* Can we distinguish between two given states by considering the next state
* by transition on each alphabet?  They are distinguishable if and only if
* one pair of such next states are distinguishable according to the partition
* of states given by aiGroup[].
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int DistinguishableStates(short cState, short *aiGroup, int c1, Transition *a1, int c2, Transition *a2)
{
	// transitions are sorted by iState, iAlphabet, jState
	if (c1 != c2)
		return 1;
	for (; c1; c1--, a1++, a2++)
	{
		if (a1->iAlphabet != a2->iAlphabet)
			return 1;
		if (aiGroup[a1->jState] != aiGroup[a2->jState])
			return 1;
	}
	return 0;
}

/******************************Private*Routine******************************\
* MakeNewPartition
*
* Given a partition of states, aiGroupOld, we try to come up with a new partition,
* aiGroupNew.  For each group of states in the old partition, we make a new
* partition such that two states iState and jState of the group fall under
* the same group in the new partition if and only if they are not distinguishable.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
short MakeNewPartition(short cState, int *acTransition, Transition **apTransition, short cGroup, short *aiGroupOld, short *aiGroupNew)
{
	short cGroupNew = 0;
	short iState, jState, iGroup, iGroupNew;

	// initialy all group assignments for the new partition are undefined
	for (iState=0; iState<cState; iState++)
		aiGroupNew[iState] = -1;  

	for (iGroup=0; iGroup<cGroup; iGroup++)
	{
		// find all pairs of states in this group
		for (iState=0; iState<cState; iState++)
		{
			if (aiGroupOld[iState] == iGroup)
			{
				// found one of a pair
				if (aiGroupNew[iState] < 0)
					aiGroupNew[iState] = cGroupNew++;
				iGroupNew = aiGroupNew[iState];
				for (jState=iState+1; jState<cState; jState++)
				{
					if (aiGroupOld[jState] == iGroup)
					{
						// found second one of the pair
						if (aiGroupNew[jState] < 0)
						{
							if (!DistinguishableStates(cState, aiGroupOld, acTransition[iState], apTransition[iState], acTransition[jState], apTransition[jState]))
								aiGroupNew[jState] = iGroupNew;
						}
						else if (aiGroupNew[jState] == iGroupNew)
						{
							// sanity check
							ASSERT(!DistinguishableStates(cState, aiGroupOld, acTransition[iState], apTransition[iState], acTransition[jState], apTransition[jState]));
						}
						else
						{
							// sanity check
							ASSERT(DistinguishableStates(cState, aiGroupOld, acTransition[iState], apTransition[iState], acTransition[jState], apTransition[jState]));
						}
					}
				}
			}
		}
	}

	return cGroupNew;
}

/******************************Private*Routine******************************\
* CompareState
*
* Callback function for qsort.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int __cdecl CompareState(const void *arg1, const void *arg2)
{
	return ((Transition *)arg1)->iState - ((Transition *)arg2)->iState;
}

/******************************Private*Routine******************************\
* EliminateDeadState
*
* If there is a state such that it is not final and it transitions to itself
* on all alphabets, it is called a dead state.  This function tries to find
* the dead state, if it exists, and eliminates it.
*
* Assumption:  At most one dead state exists.  If there is more than one
* dead states, a warning is issued and only one is eliminated.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL EliminateDeadState(short *pcState,
						unsigned char **ppbFinal,
						int *pcTransition,
						Transition **ppTransition)
{
	short cState = *pcState;
	unsigned char *abFinal = *ppbFinal;
	int cTransition = *pcTransition, cTransitionNew;
	Transition *aTransition = *ppTransition, *aTransitionNew;
	int iTransition, iTransitionNew, iState, iDeadState=-1;

	// sort transitions by iState
	qsort((void *)aTransition, cTransition, sizeof(Transition), CompareState);

	// find the dead state
	for (iState=0, iTransition=0; iState<cState; iState++)
	{
		if (!abFinal[iState])
		{
			// is there any transition leading to another state?
			while ((iTransition < cTransition) && (aTransition[iTransition].iState == iState))
			{
				if (aTransition[iTransition].jState != iState)
					break;
				iTransition++;
			}
			if ((iTransition >= cTransition) || (aTransition[iTransition].iState != iState))
			{
				// we have found a dead state
				if (iDeadState >= 0)
				{
					SetErrorMsgSDD("Something wrong! We have found at least two dead states! %d %d", iDeadState, iState);
					return FALSE;
				}
				iDeadState = iState;
			}
		}
		while ((iTransition<cTransition) && (aTransition[iTransition].iState == iState))
			iTransition++;
	}

	if (iDeadState < 0)
	{
		DebugOutput1("No dead state found.\n");
		return TRUE;
	}

	// mark transitions to/from dead state as dead
	for (iTransition=0, cTransitionNew=0; iTransition<cTransition; iTransition++)
	{
		if ((aTransition[iTransition].iState == iDeadState) || (aTransition[iTransition].jState == iDeadState))
			aTransition[iTransition].iState = cState; // transition needs to be eliminated
		else
			cTransitionNew++;
	}

	// make new list of transitions
	aTransitionNew = (Transition *) ExternAlloc(cTransitionNew*sizeof(Transition));
	if (!aTransitionNew)
	{
		SetErrorMsgSD("malloc failure %d", cTransitionNew*sizeof(Transition));
		return FALSE;
	}
	for (iTransition=0, iTransitionNew=0; iTransition<cTransition; iTransition++)
	{
		if (aTransition[iTransition].iState < cState)
			aTransitionNew[iTransitionNew++] = aTransition[iTransition];
	}
	ASSERT(iTransitionNew == cTransitionNew);
	ExternFree(aTransition);

	// rename last state (cState-1) to be iDeadState
	if (iDeadState < cState-1)
	{
		for (iTransitionNew=0; iTransitionNew<cTransitionNew; iTransitionNew++)
		{
			if (aTransitionNew[iTransitionNew].iState == cState-1)
				aTransitionNew[iTransitionNew].iState = (short)iDeadState;
			if (aTransitionNew[iTransitionNew].jState == cState-1)
				aTransitionNew[iTransitionNew].jState = (short)iDeadState;
		}
		// don't forget abFinal!
		abFinal[iDeadState] = abFinal[cState-1];
	}

	// return values
	*pcState = cState-1;
	*pcTransition = cTransitionNew;
	*ppTransition = aTransitionNew;
	DebugOutput2("Eliminated dead state %d\n", iDeadState);
	return TRUE;
}

/******************************Private*Routine******************************\
* CompareState
*
* Another callback function for qsort.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int __cdecl CompareStateAlphabetState(const void *arg1, const void *arg2)
{
	Transition *a = (Transition *)arg1;
	Transition *b = (Transition *)arg2;
	int x;

	x = a->iState - b->iState;
	if (!x)
		x = a->iAlphabet - b->iAlphabet;
	if (!x)
		x = a->jState - b->jState;
	return x;
}

/******************************Public*Routine******************************\
* MinimizeDFA
*
* Tries to minimize the number of states in a DFA.  The way it does that is
* by finding a partition of the states where all equivalent states are in the
* same group.  The partition is computed using an iterative method.  We
* start with a partition of two groups: final states and other states.
* For each iteration, we refine the partition by subdividing a group of
* states into smaller groups of un-distiguishable states.  Whether two states
* are distinguishable or not depends on the current partition.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL MinimizeDFA(short *pcState,
			     unsigned char **ppbFinal,
				 int *pcTransition,
				 Transition **ppTransition)
{
	short cState = *pcState;
	unsigned char *abFinal = *ppbFinal, bFinal, *abFinalNew = NULL;
	int cTransition = *pcTransition;
	Transition *aTransition = *ppTransition, **apTransition = NULL, *aTransitionNew = NULL;
	short cGroup;
	short *aiGroup = NULL, *aiGroupNew = NULL;
	short iState, iGroup;
	int *acTransition = NULL, iTransition, cTransitionNew, iTransitionNew;
	unsigned char *abFirst = NULL;
	BOOL bRet = TRUE;

	// make initial partition
	aiGroup = (short *) ExternAlloc(cState*sizeof(short));
	if (!aiGroup)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(short));
		bRet = FALSE;
		goto cleanup;
	}
	cGroup = 1;
	aiGroup[0] = 0;
	bFinal = abFinal[0];
	for (iState=1; iState<cState; iState++)
	{
		if ((bFinal && abFinal[iState]) || (!bFinal && !abFinal[iState]))
			aiGroup[iState] = 0;
		else
		{
			aiGroup[iState] = 1;
			cGroup = 2;
		}
	}

	// sort transitions by iState, iAlphabet, jState
	qsort((void *)aTransition, cTransition, sizeof(Transition), CompareStateAlphabetState);

	// compute a couple of arrays indexed by iState 
	// where each element will specify the transitions from a state
	acTransition = (int *) ExternAlloc(cState*sizeof(int));
	if (!acTransition)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(int));
		bRet = FALSE;
		goto cleanup;
	}
	apTransition = (Transition **) ExternAlloc(cState*sizeof(Transition *));
	if (!apTransition)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(Transition *));
		bRet = FALSE;
		goto cleanup;
	}
	for (iState=0, iTransition=0; iState<cState; iState++)
	{
		if ((iTransition >= cTransition) || (aTransition[iTransition].iState > iState))
		{
			acTransition[iState] = 0;
			apTransition[iState] = NULL;
		}
		else
		{
			ASSERT(aTransition[iTransition].iState == iState);
			apTransition[iState] = aTransition + iTransition;
			acTransition[iState] = 1;
			for (iTransition++; iTransition<cTransition; iTransition++)
			{
				if (aTransition[iTransition].iState == iState)
					acTransition[iState]++;
				else
					break;
			}
		}
	}

	// refine partition iteratively
	aiGroupNew = (short *) ExternAlloc(cState*sizeof(short));
	if (!aiGroupNew)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(short));
		bRet = FALSE;
		goto cleanup;
	}
	for (;;)
	{
		short cGroupNew, *tmp;

		cGroupNew = MakeNewPartition(cState, acTransition, apTransition, cGroup, aiGroup, aiGroupNew);
		if ((cGroup == cGroupNew) && EqualArrays(cState, aiGroup, aiGroupNew))
			break;

		tmp = aiGroup;
		aiGroup = aiGroupNew;
		aiGroupNew = tmp;
		cGroup = cGroupNew;
	}
	ExternFree(aiGroupNew);
	aiGroupNew = NULL;

	// clean up
	ExternFree(acTransition);
	acTransition = NULL;
	ExternFree(apTransition);
	apTransition = NULL;

	// we now have a final partition
	if (cGroup == cState)
	{
		ExternFree(aiGroup);
		return TRUE;
	}
	ASSERT(cGroup < cState);

	// find the first state in each group
	abFirst = (unsigned char *) ExternAlloc(cState * sizeof(unsigned char));
	if (!abFirst)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(unsigned char));
		bRet = FALSE;
		goto cleanup;
	}
	memset(abFirst, 0, cState*sizeof(unsigned char));
	for (iGroup=0; iGroup<cGroup; iGroup++)
	{
		for (iState=0; iState<cState; iState++)
		{
			if (aiGroup[iState] == iGroup)
				break;
		}
		ASSERT(iState < cState);
		abFirst[iState] = 1;
	}
	ASSERT(aiGroup[0] == 0);
	ASSERT(abFirst[0]);

	// make new final states
	abFinalNew = (unsigned char *) ExternAlloc(cGroup*sizeof(unsigned char));
	if (!abFinalNew)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(unsigned char));
		bRet = FALSE;
		goto cleanup;
	}
	memset(abFinalNew, 0, cGroup*sizeof(unsigned char));
	for (iState=0; iState<cState; iState++)
	{
		if (abFirst[iState] && abFinal[iState])
			abFinalNew[aiGroup[iState]] = 1;
	}

	// for each transition for a "first state" replace the state names with new names
	// delete all other transitions
	cTransitionNew = 0;
	for (iTransition=0; iTransition<cTransition; iTransition++)
	{
		if (abFirst[aTransition[iTransition].iState])
		{
			aTransition[iTransition].iState = aiGroup[aTransition[iTransition].iState];
			aTransition[iTransition].jState = aiGroup[aTransition[iTransition].jState];
			cTransitionNew++;
		}
		else
		{
			aTransition[iTransition].iState = cGroup;  // this transition has to be deleted
		}
	}
	ExternFree(abFirst);
	abFirst = NULL;
	ExternFree(aiGroup);
	aiGroup = NULL;

	// make new transition array
	aTransitionNew = (Transition *) ExternAlloc(cTransitionNew*sizeof(Transition));
	if (!aTransitionNew)
	{
		SetErrorMsgSD("malloc failure %d", cTransitionNew*sizeof(Transition));
		bRet = FALSE;
		goto cleanup;
	}
	for (iTransition=0, iTransitionNew=0; iTransition<cTransition; iTransition++)
	{
		if (aTransition[iTransition].iState < cGroup)
			aTransitionNew[iTransitionNew++] = aTransition[iTransition];
	}
	ASSERT(iTransitionNew == cTransitionNew);

cleanup:
	// return values
	if (bRet)
	{
		ExternFree(abFinal);
		ExternFree(aTransition);

		*pcState = cGroup;
		*pcTransition = cTransitionNew;
		*ppTransition = aTransitionNew;
		*ppbFinal = abFinalNew;

		// one last thing to do: eliminate dead states if any
		return EliminateDeadState(pcState, ppbFinal, pcTransition, ppTransition);
	}
	else
	{
		if (aiGroup)
			ExternFree(aiGroup);
		if (acTransition)
			ExternFree(acTransition);
		if (apTransition)
			ExternFree(apTransition);
		if (aiGroupNew)
			ExternFree(aiGroupNew);
		if (abFirst)
			ExternFree(abFirst);
		if (abFinalNew)
			ExternFree(abFinalNew);
		if (aTransitionNew)
			ExternFree(aTransitionNew);
		return FALSE;
	}
}

void RenameState(int cTransition, Transition *aTransition, short iOldState, short iNewState)
{
	for (; cTransition>0; cTransition--, aTransition++)
	{
		if (aTransition->iState == iOldState)
			aTransition->iState = iNewState;
		if (aTransition->jState == iOldState)
			aTransition->jState = iNewState;
	}
}

BOOL MakeCanonicalDFA(short cState,
					  unsigned char *abFinal,
					  int cTransition,
					  Transition *aTransition)
{
	short *aName;
	short cNamed, iState;
	int iTransition;
	unsigned char *abFinalNew;

	if (cState < 3)
		return TRUE;

	aName = (short *) ExternAlloc(cState*sizeof(short));
	if (!aName)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(short));
		return FALSE;
	}

	abFinalNew = (unsigned char *) ExternAlloc(cState*sizeof(unsigned char));
	if (!abFinalNew)
	{
		SetErrorMsgSD("malloc failure %d", cState*sizeof(unsigned char));
		ExternFree(aName);
		return FALSE;
	}

	// rename all states iState to iState+cState except state 0
	for (iState=1; iState<cState; iState++)
		RenameState(cTransition, aTransition, iState, (short)(iState+cState));
	cNamed = 1;

	// sort transitions by iState, iAlphabet, jState
	qsort((void *)aTransition, cTransition, sizeof(Transition), CompareStateAlphabetState);

	aName[0] = 0;  // state 0 doesn't change name
	for (iState=1; iState<cState; iState++)
	{
		aName[iState] = cState;
		abFinalNew[iState] = 2;
	}

	for (iTransition=0; (iTransition<cTransition) && (cNamed<cState); iTransition++)
	{
		short jState;

		ASSERT(aTransition[iTransition].iState < cState); // has already been renamed
		if ((jState = aTransition[iTransition].jState) > cState)
		{
			// need to rename this jState
			RenameState(cTransition, aTransition, jState, cNamed);
			aName[jState-cState] = cNamed++;
			qsort((void *)(aTransition+iTransition), cTransition-iTransition, sizeof(Transition), CompareStateAlphabetState);
		}
	}

	ASSERT(cNamed == cState);

	for (iState=0; iState<cState; iState++)
	{
		ASSERT(aName[iState] >= 0);
		ASSERT(aName[iState] < cState);
		abFinalNew[aName[iState]] = !!abFinal[iState];  // make sure abFinalNew[] is 0 or 1
	}

	ExternFree(aName);

	for (iState=0; iState<cState; iState++)
	{
		ASSERT((abFinalNew[iState] == 0) || (abFinalNew[iState] == 1));
		abFinal[iState] = abFinalNew[iState];
	}
	ExternFree(abFinalNew);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\inc\regexp.h ===
// re2fsa.h
// Angshuman Guha
// aguha
// Nov 30, 2000

#ifndef __INC_RE2FSA_H
#define __INC_RE2FSA_H

#ifdef __cplusplus
extern "C" {
#endif

#define MAXLINE 1024

#define MIN_TERMINAL 0
#define MAX_TERMINAL 65535

// the private use area of Unicode 3.0 is 0xE000 to 0xF8FF
#define MIN_FACTOID_TERMINAL 0xE000

#define TOKEN_EMPTY_STRING 0
#define TOKEN_END_MARKER   1
#define TOKEN_UNDEFINED    2
#define TOKEN_NONE         3

#define MIN_OPERATOR 65536
#define MAX_OPERATOR 65600

#define OPERATOR_EQUALS   (MIN_OPERATOR)
#define OPERATOR_CAT      (MIN_OPERATOR+1)
#define OPERATOR_OR       (MIN_OPERATOR+2)
#define OPERATOR_ZERO     (MIN_OPERATOR+3)
#define OPERATOR_OPTIONAL (MIN_OPERATOR+4)
#define OPERATOR_ONE      (MIN_OPERATOR+5)
#define OPERATOR_LPAREN   (MIN_OPERATOR+6)
#define OPERATOR_RPAREN   (MIN_OPERATOR+7)
#define OPERATOR_LBRACKET (MIN_OPERATOR+8)
#define OPERATOR_RBRACKET (MIN_OPERATOR+9)
#define OPERATOR_STOP     (MIN_OPERATOR+10)

#define MIN_NONTERMINAL 65601
#define MAX_NONTERMINAL 0x7FFFFFFF

#define WCHAR2Terminal(wch) ((int)wch)
#define IsOperator(x) (((x) >= MIN_OPERATOR) && ((x) <= MAX_OPERATOR))
#define IsUnaryOperator(x) (((x)==OPERATOR_ZERO)||((x)==OPERATOR_ONE)||((x)==OPERATOR_OPTIONAL))
#define IsBinaryOperator(x) (((x)==OPERATOR_CAT)||((x)==OPERATOR_OR))
#define IsNonterminal(x) (((x) >= MIN_NONTERMINAL) && ((x) <= MAX_NONTERMINAL))
#define IsTerminal(x) (((x) >= MIN_TERMINAL) && ((x) <= MAX_TERMINAL))

#define CHARCONST_EQUALS   L'='
#define CHARCONST_CAT      L'.'
#define CHARCONST_OR       L'|'
#define CHARCONST_ZERO     L'*'
#define CHARCONST_OPTIONAL L'?'
#define CHARCONST_ONE      L'+'
#define CHARCONST_LPAREN   L'('
#define CHARCONST_RPAREN   L')'
#define CHARCONST_LBRACKET L'['
#define CHARCONST_RBRACKET L']'
#define CHARCONST_COMMENT  L'#'
#define CHARCONST_STOP     L';'
#define CHARCONST_STRING   L'"'
#define CHARCONST_UNDERSCORE L'_'
#define CHARCONST_ESCAPE   L'\\'

void SetErrorMsgS(char *sz);
void SetErrorMsgSD(char *sz, int x);
void SetErrorMsgSS(char *sz, char *sz1);
void SetErrorMsgSDD(char *sz, int x, int y);
BOOL IsErrorMsgSet(void);

#if defined(DEBUG_OUTPUT) && defined(_CONSOLE)
#define DebugOutput1(x) fprintf(stderr, x)
#define DebugOutput2(x, y) fprintf(stderr, x, y)
#else
#define DebugOutput1(x)
#define DebugOutput2(x, y)
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\factoid.c ===
#include <common.h>
#include "factoid.h"
#include "regexp.h"

typedef struct {
	WCHAR *wszFactoid;
	DWORD dwFactoid;
} FactoidID;

static FactoidID gaStringToFactoid[] = {
	{L"BOPOMOFO",      FACTOID_BOPOMOFO},
	{L"CHS_COMMON",    FACTOID_CHS_COMMON},
	{L"CHT_COMMON",    FACTOID_CHT_COMMON},
	{L"CURRENCY",      FACTOID_NUMCURRENCY},
	{L"DATE",          FACTOID_NUMDATE},
	{L"DIGIT",         FACTOID_DIGITCHAR},
	{L"EMAIL",         FACTOID_EMAIL},
	{L"FILENAME",      FACTOID_FILENAME},
	{L"HANGUL_COMMON", FACTOID_HANGUL_COMMON},
	//{L"HANGUL_RARE",   FACTOID_HANGUL_RARE},
	{L"HIRAGANA",      FACTOID_HIRAGANA},
	{L"JAMO",          FACTOID_JAMO},
	{L"JPN_COMMON",    FACTOID_JPN_COMMON},
	{L"KANJI_COMMON",  FACTOID_KANJI_COMMON},
	//{L"KANJI_RARE",    FACTOID_KANJI_RARE},
	{L"KATAKANA",      FACTOID_KATAKANA},
	{L"KOR_COMMON",    FACTOID_KOR_COMMON},
	//{L"LOWERCHAR",     FACTOID_LOWERCHAR},
	{L"NONE",          FACTOID_NONE},
	{L"NUMBER",        FACTOID_NUMBER},
	//{L"NUMSIMPLE",     FACTOID_NUMSIMPLE},
	{L"ONECHAR",       FACTOID_ONECHAR},
	{L"PERCENT",       FACTOID_NUMPERCENT},
	{L"POSTALCODE",    FACTOID_ZIP},
	//{L"PUNCCHAR",      FACTOID_PUNCCHAR},
	{L"SYSDICT",       FACTOID_SYSDICT},
	{L"TELEPHONE",     FACTOID_NUMPHONE},
	{L"TIME",          FACTOID_NUMTIME},
	{L"UPPERCHAR",     FACTOID_UPPERCHAR},
	{L"WEB",           FACTOID_WEB},
	{L"WORDLIST",      FACTOID_WORDLIST}
};

/******************************Public*Routine******************************\
* StringToFactoid
*
* Function to convert a string-name for a factoid into its value.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int StringToFactoid(WCHAR *wsz, int iLength)
{
	int lo=0;
	int hi=sizeof(gaStringToFactoid)/sizeof(FactoidID) - 1;
	int mid, n;

	while (lo <= hi)
	{
		mid = (lo + hi) >> 1;
		n = wcsncmp(gaStringToFactoid[mid].wszFactoid, wsz, iLength);
		if (n == 0)
			n = gaStringToFactoid[mid].wszFactoid[iLength];
		if (n < 0)
			lo = mid+1;
		else if (n > 0)
			hi = mid-1;
		else
			return gaStringToFactoid[mid].dwFactoid;
	}

	return -1;
}

int ConvertFactoidStringToID(WCHAR *wsz, int cLength, DWORD *aFactoidID, int cMaxFactoid, int cFactoid)
{
	int lookup, iFactoid;
	DWORD dwFactoid;

	if (cFactoid < 0) 
		return -1;

	lookup = StringToFactoid(wsz, cLength);
	if (lookup < 0)
		return -1;  // unknown factoid name

	dwFactoid = (DWORD) lookup;

	// is it a duplicate?
	for (iFactoid=0; iFactoid<cFactoid; iFactoid++)
	{
		if (aFactoidID[iFactoid] == dwFactoid)
			return cFactoid;
	}

	// do we have space?
	if (cFactoid >= cMaxFactoid)
		return -1;  // caller did not provide enough space


	aFactoidID[cFactoid] = dwFactoid;
	return cFactoid+1;
}

/******************************Public*Routine******************************\
* ParseFactoidString
*
* This function can parse a factoid string which only uses the OR operator.
* This is for V1 of Tablet PC.
*
* cMaxFactoid is an input parameter that refers to the size of aFactoidID
* The return value is the actual count.
*
* A return value of -1 indicates error.
* A return value greater than or equal to zero indicates success.
*
* History:
* 13-Nov-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int ParseFactoidString(WCHAR *wsz, int cMaxFactoid, DWORD *aFactoidID)
{
	int iFactoid = 0;
	WCHAR *wszStart, wch;
	BOOL bFound = FALSE;
	int state = 0;

	if (!wsz)
		return -1;
	if (cMaxFactoid < 0)
		return -1;

	/* the state machine
	state 0: valid only if the string is empty
		alpha -> state 1
		space -> state 0
	state 1: valid
		alpha, num, '_' -> state 1
		space -> state 2
		'|'   -> state 0
	state 2: valid
		space -> state 2
		'|' -> state 0
	*/

	while (wch = *wsz++)
	{
		switch(state)
		{
		case 0:
			if (iswspace(wch))
				break;
			if (iswalpha(wch))
			{
				state = 1;
				wszStart = wsz-1;
			}
			else
				return -1;  // syntax error
			break;
		case 1:
			if (iswspace(wch))
			{
				bFound = TRUE;
				state = 2;
			} 
			else if (wch == CHARCONST_OR)
			{
				bFound = TRUE;
				state = 0;
			}
			else if (iswalpha(wch) || iswdigit(wch) || (wch == CHARCONST_UNDERSCORE))
			{
				break;
			}
			else
				return -1;  // syntax error
			break;
		case 2:
			if (iswspace(wch))
				break;
			if (wch == CHARCONST_OR)
				state = 0;
			else
				return -1;  // syntax error
			break;
		default:
			ASSERT(0);
			// should never be here
			return -1;
		}

		if (bFound)
		{
			bFound = FALSE;
			iFactoid = ConvertFactoidStringToID(wszStart, wsz-wszStart-1, aFactoidID, cMaxFactoid, iFactoid);
			if (iFactoid < 0)
				return -1;
		}
	}

	if (state == 1)
	{
		// the last factoid has not been processed yet
		iFactoid = ConvertFactoidStringToID(wszStart, wsz-wszStart-1, aFactoidID, cMaxFactoid, iFactoid);
		if (iFactoid < 0)
			return -1;
	}

	if ((state == 0) && iFactoid)
		return -1; // the last thing we saw was an OR

	return iFactoid;
}

/******************************Public*Routine******************************\
* SortFactoidLists
*
* History:
* 13-Nov-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void SortFactoidLists(DWORD *a, int c)
{
	int i, j;
	DWORD tmp;

	for (i=0; i<c-1; i++)
	{
		for (j=i+1; j<c; j++)
		{
			if (a[j] < a[i])
			{
				tmp = a[i];
				a[i] = a[j];
				a[j] = tmp;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\bdfa.c ===
// bdfa.c
// Angshuman Guha
// aguha
// July 18, 2001

/* This file contains all information pertaining to the binary format of
a "compiled regular expression".  It is really a binary format for
a minimal deterministic finite state automaton.  No other piece of
code is supposed to "know" about the binary format.  This file
provides both functions to create a binary blob from a regular
expression and functions to enumerate/browse through a compiled
binary blob.
*/
#include <stdlib.h>
#include <search.h>
#include <common.h>
#include "ptree.h"
#include "dfa.h"
#include "regexp.h"
#include "factoid.h"

/******************************Public*Routine******************************\
* CopyCompiledFactoid
*
* Function to clone a binary compiled regular expression.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void *CopyCompiledFactoid(void *pvFactoid)
{
	WORD *pWord = (WORD *)pvFactoid;
	WORD size;

	if (!pWord)
		return NULL;
	size = *pWord;
	pWord = (WORD *) ExternAlloc(size);
	if (!pWord)
		return NULL;
	memcpy(pWord, pvFactoid, size);
	ASSERT(pWord[size/2 - 1] == 0xBDFA);
	return pWord;
}

/******************************Public*Routine******************************\
* CountOfStatesFACTOID
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int CountOfStatesFACTOID(void *pvFactoid)
{
	WORD *aStateDesc = (WORD *) pvFactoid;
	return aStateDesc[2];
}

/******************************Public*Routine******************************\
* IsValidStateFACTOID
*
* The first function to enumerate/browse through a compiled deterministic 
* finite state automaton.
*
* These functions currently rely on a non-malicious caller.  There
* is practically no error checking.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsValidStateFACTOID(void *pvFactoid, WORD state)
{
	WORD *aStateDesc = (WORD *) pvFactoid;
	
	ASSERT(state < aStateDesc[2]);
	aStateDesc += aStateDesc[3 + state]/2;  // the offset is expressed in bytes, hence divide by 2
	return *aStateDesc ? TRUE : FALSE;
}

/******************************Public*Routine******************************\
* CountOfTransitionsFACTOID
*
* The second function to enumerate/browse through a compiled deterministic 
* finite state automaton.
*
* These functions currently rely on a non-malicious caller.  There
* is practically no error checking.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int CountOfTransitionsFACTOID(void *pvFactoid, WORD state)
{
	WORD *aStateDesc = (WORD *) pvFactoid;
	
	ASSERT(state < aStateDesc[2]);
	aStateDesc += aStateDesc[3 + state]/2 + 1;
	return (int) *aStateDesc;
}

/******************************Public*Routine******************************\
* GetTransitionFACTOID
*
* The third function to enumerate/browse through a compiled deterministic 
* finite state automaton.
*
* These functions currently rely on a non-malicious caller.  There
* is practically no error checking.
*
* The return value is TRUE if the transition is on a Unicode literal constant.
* It is FALSE if the transition is on a Factoid.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL GetTransitionFACTOID(void *pvFactoid, WORD state, int iTransition, WORD *pFactoidID, WORD *pNextState)
{
	WORD *aStateDesc = (WORD *) pvFactoid;

	aStateDesc += aStateDesc[3 + state]/2 + 1;
	ASSERT(iTransition >= 0);
	ASSERT(iTransition < *aStateDesc);
	aStateDesc += 1 + 2*iTransition;

	*pFactoidID = *aStateDesc++;
	*pNextState = *aStateDesc;

	if (*pFactoidID < MIN_FACTOID_TERMINAL)
		return TRUE;
	else
	{
		*pFactoidID -= MIN_FACTOID_TERMINAL;
		return FALSE;
	}
}

/******************************Public*Routine******************************\
* CompileFactoidList
*
* Function to produce a binary compiled regular expression in the
* degenerate case where the regular expression is a simple OR of factoids.
*
* History:
* 13-Nov-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void *CompileFactoidList(DWORD *aFactoidID, int cFactoid)
{
	void *pvFactoid;
	WORD *pWord;
	int iFactoid;
	
	ASSERT(cFactoid > 0);
	if (cFactoid <= 0)
		return NULL;

	pWord = (WORD *)ExternAlloc(20+cFactoid*4);
	if (!pWord)
		return FALSE;
	pvFactoid = (void *) pWord;

	*pWord++ = 20+cFactoid*4;  // size;
	*pWord++ = 0;   // version
	*pWord++ = 2;   // cState
	*pWord++ = 10;				// offset (in bytes) for state 0
	*pWord++ = 14+cFactoid*4;	// offset (in bytes) for state 1
	*pWord++ = 0;				// state 0 is not valid
	*pWord++ = (WORD)cFactoid;	// # of transitions out of state 0;

	for (iFactoid=0; iFactoid<cFactoid; iFactoid++)
	{
		*pWord++ = (WORD)(MIN_FACTOID_TERMINAL+aFactoidID[iFactoid]);  // the transition out of state 0 is on this factoid
		*pWord++ = 1;	 // the transition out of state 0 is to state 1
	}

	*pWord++ = 1;   // state 1 is valid
	*pWord++ = 0;  // no transitions out of state 1
	*pWord++ = 0xBDFA; // end-marker

	return pvFactoid;
}

// The following 2 functions are turned off in the recognizer DLL for V1 TabletPC because
// 1) they are unused
// 2) they require the SetErrorMsg function which is currently not included in factoid.lib
// These functions are included in the stand-alone re2fsa program.

#ifdef STANDALONE_RE2FSA
/******************************Private*Routine******************************\
* CompareStateStateAlphabet
*
* Callback function for qsort.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int __cdecl CompareStateStateAlphabet(const void *arg1, const void *arg2)
{
	Transition *a = (Transition *)arg1;
	Transition *b = (Transition *)arg2;
	int x;

	x = a->iState - b->iState;
	if (!x)
		x = a->jState - b->jState;
	if (!x)
		x = a->iAlphabet - b->iAlphabet;
	return x;
}

/* format of binary blob returned by CompileRegularExpression()

Version 0

	WORD size (count of bytes)
	WORD version
	WORD cState
	WORD offset for state 0 (in bytes)
	WORD offset for state 1 (in bytes)
	...
	WORD offset for state n-1 (in bytes)
	description for state 0
	description for state 1
	...
	description for state n-1
	WORD endmarker

Description for a state is
	WORD bValid
	WORD cTransition
	transition 0
	transition 1
	...
	transition k-1

A transition is
	WORD factoid or literal unicode
	WORD next state

*/

/******************************Public*Routine******************************\
* ConvertDFAtoBlob
*
* Function to convert a deterministic finite automaton into a binary
* format.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void *ConvertDFAtoBlob(int cTransition, Transition *aTransition, int cAlphabet, WCHAR *aAlphabet, int cState, unsigned char *abFinal)
{
	int size, iState, iTrans;
	WORD *pWord, *aOffset;
	void *pv;

	size = 6 // size, version and cState
		   + 2*cState      // offsets
		   + 4*cState      // 4 bytes per state for bValid & cTransition
		   + 4*cTransition // 4 bytes per transition
		   + 2;            // end-marker

	pv = (void *) ExternAlloc(size);
	if (!pv)
	{
		SetErrorMsgSD("malloc failure %d", size);
		return NULL;
	}

	pWord = (WORD *) pv;
	*pWord++ = (WORD)size;
	*pWord++ = 0; // version
	*pWord++ = (WORD) cState;
	aOffset = pWord;
	pWord += cState;

	qsort((void *)aTransition, cTransition, sizeof(Transition), CompareStateStateAlphabet);

	iTrans = 0;
	for (iState=0; iState<cState; iState++)
	{
		int cTrans;
		WORD *pcTrans;
		
		*aOffset++ = (BYTE *)pWord - (BYTE *)pv;
		*pWord++ = (WORD) *abFinal++;
		pcTrans = pWord++; // to be filled in later
		cTrans = 0;
		while (iTrans < cTransition)
		{
			ASSERT(iState <= aTransition->iState);
			if (iState == aTransition->iState)
			{
				*pWord++ = (WORD) aAlphabet[aTransition->iAlphabet];
				*pWord++ = (WORD) aTransition->jState;
				iTrans++;
				aTransition++;
				cTrans++;
			}
			else
				break;
		}
		*pcTrans = (WORD)cTrans;
	}

	*pWord++ = 0xBDFA;  // end marker "binary deterministic finite automaton"

	ASSERT((BYTE *)pWord - (BYTE *)pv == size);
	return pv;
}

#endif


#ifdef DEAD
/******************************Public*Routine******************************\
* CompileSingleFactoid  --- THIS IS AN OBSOLETE FUNCTION
*
* Function to produce a binary compiled regular expression in the
* degenerate case where the regular expression is a sinle factoid.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void *CompileSingleFactoid(DWORD factoid)
{
	void *pvFactoid;
	WORD *pWord;
	
	if (!IsSupportedFactoid(factoid))
		return NULL;

	pWord = (WORD *)ExternAlloc(24);
	if (!pWord)
		return FALSE;
	pvFactoid = (void *) pWord;

	*pWord++ = 24;  // size;
	*pWord++ = 0;   // version
	*pWord++ = 2;   // cState
	*pWord++ = 10;  // offset (in bytes) for state 0
	*pWord++ = 18;  // offset (in bytes) for state 1
	*pWord++ = 0;   // state 0 is not valid
	*pWord++ = 1;   // 1 transition out of state 0;
	*pWord++ = (WORD)(MIN_FACTOID_TERMINAL+factoid);  // the transition out of state 0 is on this factoid
	*pWord++ = 1;	 // the transition out of state 0 is to state 1
	*pWord++ = 1;   // state 1 is valid
	*pWord++ = 0;  // no transitions out of state 1
	*pWord++ = 0xBDFA; // end-marker

	return pvFactoid;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\intset.c ===
// IntSet.c
// Angshuman Guha
// aguha
// Jan 15, 2001

// This is a set of routines to compute with sets of unsigned integers.
// Supported operations are creation, destruction, union, adding members,
// enumerating members, testing membership and testing set equality.

#include "common.h"
#include "intset.h"

typedef unsigned char BYTE;
#define SizeOfByte 8

static unsigned char BitInByte[256] = // the bit position of the rightmost 1 of a byte
{
	0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0,
	3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0,
	3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0,
	3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
	3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0,
	3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};
static BYTE PositionToMask[8] = {0xfe,	0xfc, 0xf8,	0xf0, 0xe0, 0xc0, 0x80,	0x00};

/*
The BitInByte array was computed using:

unsigned char BitInByte(unsigned char x)
{
	int i;

	for (i=0; i<8; i++)
	{
		if (x & 1)
			return i;
		x >>= 1;
	}
	return 0;
}

The PositionToMask array was computed using:

int i;
unsigned char mask = 0xFF;

for (i=0; i<8; i++)
{
	mask &= mask - 1;
	printf("\t0x%02x,\n", mask);
}

*/

/******************************Public*Routine******************************\
* MakeIntSet
*
* Function to make a new (empty) set given the size of the universe.
* Possible future members of the set are 0 through cUniverse-1
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL MakeIntSet(unsigned int cUniverse, IntSet *pIntSet) 
{
	unsigned int cByte;
	BYTE *p;

	if (!cUniverse)
		return FALSE;

	cByte = (cUniverse - 1)/SizeOfByte + 1;
	p = (BYTE *) ExternAlloc(cByte + sizeof(int));
	if (!p)
		return FALSE;
	*(unsigned int *)p = cByte;
	memset(p+sizeof(int), 0, cByte);
	*pIntSet = (IntSet)p;
	return TRUE;
}

/******************************Public*Routine******************************\
* CopyIntSet
*
* Creates a copy of an existing set.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL CopyIntSet(IntSet is, IntSet *pIntSet)
{
	unsigned int cByte;
	BYTE *pb, *pbNew;

	pb = (BYTE *)is;
	cByte = *(unsigned int *)pb;
	pb += sizeof(int);

	pbNew = (BYTE *) ExternAlloc(cByte + sizeof(int));
	if (!pbNew)
		return FALSE;
	*(unsigned int *)pbNew = cByte;
	*pIntSet = (IntSet)pbNew;
	pbNew += sizeof(int);

	for (; cByte; cByte--)
		*pbNew++ = *pb++;

	return TRUE;
}

/******************************Public*Routine******************************\
* DestroyIntSet
*
* Destroys a given set.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyIntSet(IntSet is)
{
	if (is)
		ExternFree(is);
}

/******************************Public*Routine******************************\
* AddMemberIntSet
*
* Adds a member to a given set.  The member may or may not have already
* existed in the set.
* Zero is returned on failure.  Otherwise 1 is returned.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL AddMemberIntSet(IntSet is, unsigned int member)
{
	unsigned int cByte, index;
	BYTE *pb, shift;

	pb = (BYTE *)is;
	cByte = *(unsigned int *)pb;
	pb += sizeof(int);
	index = member/SizeOfByte;
	if (index >= cByte)
		return FALSE;
	pb += index;
	shift = member % SizeOfByte;
	*pb |= ((BYTE)1) << shift;
	return TRUE;
}

/******************************Public*Routine******************************\
* UnionIntSet
*
* This is an in-place union of two sets.  The first set is the one modified.
* Zero is returned on failure.  Otherwise 1 is returned.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL UnionIntSet(IntSet dst, IntSet src)
{
	BYTE *pdst, *psrc;
	unsigned int cByte;

	pdst = (BYTE *)dst;
	psrc = (BYTE *)src;
	cByte = *(unsigned int *)pdst;
	pdst += sizeof(int);
	if (cByte != *(unsigned int *)psrc)
		return FALSE;
	psrc += sizeof(int);
	for (; cByte; cByte--)
		*pdst++ |= *psrc++;
	return TRUE;
}

/******************************Public*Routine******************************\
* FirstMemberIntSet
*
* This is the first of the two member-enumerating functions of a set.
* Zero is returned if the set is empty.  Otherwise 1 is returned.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL FirstMemberIntSet(IntSet is, unsigned int *pmember)
{
	BYTE *pb = (BYTE *)is;
	unsigned int cByte = *(unsigned int *)pb, index;

	pb += sizeof(int);
	for (index=0; index<cByte; index++, pb++)
	{
		if (*pb)
		{
			*pmember = index*SizeOfByte + BitInByte[*pb];
			return TRUE;
		}
	}

	return FALSE;
}

/******************************Public*Routine******************************\
* NextMemberIntSet
*
* This is the second of the two member-enumerating functions of a set.
* The argument pmember should point to the last member obtained using
* FirstMemberIntSet() or NextMemberIntSet().  It is modified to hold
* the next member if there are any and 1 is returned.
* If there are no more members, 0 is returned.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL NextMemberIntSet(IntSet is, unsigned int *pmember)
{
	unsigned int cByte, index;
	BYTE position, tmp, *pb;

	pb = (BYTE *)is;
	cByte = *(unsigned int *)pb;
	pb += sizeof(int);
	index = *pmember/SizeOfByte;
	if (index >= cByte)
		return FALSE;

	pb += index;
	position = *pmember % SizeOfByte;
	tmp = *pb & PositionToMask[position]; // erase the bit for the last member
	if (tmp)
	{
		*pmember = index*SizeOfByte + BitInByte[tmp];
		return TRUE;
	}

	for (index++, pb++; index<cByte; index++, pb++)
	{
		if (*pb)
		{
			*pmember = index*SizeOfByte + BitInByte[*pb]; 
			return TRUE;
		}
	}

	return FALSE;
}

/******************************Public*Routine******************************\
* IsEqualIntSet
*
* Tests equality of two sets.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsEqualIntSet(IntSet is1, IntSet is2)
{
	BYTE *pb1, *pb2;
	unsigned int cByte;

	pb1 = (BYTE *)is1;
	pb2 = (BYTE *)is2;
	cByte = *(unsigned int *)pb1;
	pb1 += sizeof(int);
	if (cByte != *(unsigned int *)pb2)
		return FALSE;
	pb2 += sizeof(int);
	for (; cByte; cByte--)
	{
		if (*pb1++ != *pb2++)
			return FALSE;
	}
	return TRUE;
}

/******************************Public*Routine******************************\
* IsMemberIntSet
*
* Tests whether a given unsigned integer is a member of a set.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsMemberIntSet(IntSet is, unsigned int member)
{
	unsigned int cByte, index;
	BYTE *pb, shift;

	pb = (BYTE *)is;
	cByte = *(unsigned int *)pb;
	pb += sizeof(int);
	index = member/SizeOfByte;
	if (index >= cByte)
		return FALSE;
	pb += index;
	shift = member % SizeOfByte;
	return (BOOL) (*pb & (((BYTE)1) << shift));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\re_input.c ===
// re_input.c
// regular expression - input parsing
// Angshuman Guha
// aguha
// July 19, 2001

#include <common.h>
#include "regexp.h"
#include "ptree.h"
#include "strtable.h"

// The following function StringToFactoid() has to linked
// in from somewhere.  For Avalanche/Madcow/Bear, this
// function is defined in inferno\src\factoid.c

int StringToFactoid(WCHAR *wsz, int iLength);

typedef struct tagRULE {
	int left;
	PARSETREE *tree;
	struct tagRULE *next;
} RULE;

typedef struct tagTOKENPARSING {
	WCHAR *wsz;
	BOOL bInString;
	BOOL bLastTerminal;
} TOKENPARSING;

typedef struct tagTOKENSTREAM {
	int *aToken;
	int cToken;
} TOKENSTREAM;

// forward prototype
PARSETREE *TokensToTree(TOKENSTREAM *pTokenstream);

/******************************Public*Routine******************************\
* ReplaceNonterminal
*
* Function to replace all occurrences of a nonterminal in a parsetree
* with a subtree.  Returns number of times replaced.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int ReplaceNonterminal(PARSETREE **pTree, int nonterminal, PARSETREE *ruletree)
{
	PARSETREE *tree = *pTree;

	if (!tree)
		return 0;

	if (tree->value == nonterminal)
	{
		ASSERT(!tree->left);
		ASSERT(!tree->right);
		DestroyPARSETREE(tree);
		*pTree = CopyPARSETREE(ruletree);
		return 1;
	}
	return ReplaceNonterminal(&tree->left, nonterminal, ruletree)
		 + ReplaceNonterminal(&tree->right, nonterminal, ruletree);
}

/******************************Public*Routine******************************\
* MarkUsedNonterminals
*
* Function to determine which non-terminals are being used in a parse tree.
* The array abUsed is used to mark used non-terminals.  The search
* happens recursively on the tree and also recursively on any rules
* (parse trees) for other non-terminals in the tree.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void MarkUsedNonterminals(PARSETREE *tree, PARSETREE **aRuleTree, int cNonterminal, BOOL *abUsed)
{
	int token;

	if (!tree)
		return;

	token = tree->value;
	if (IsNonterminal(token) && !abUsed[token - MIN_NONTERMINAL])
	{
		token -= MIN_NONTERMINAL;
		ASSERT(token >= 0);
		ASSERT(token < cNonterminal);
		abUsed[token] = TRUE;
		MarkUsedNonterminals(aRuleTree[token], aRuleTree, cNonterminal, abUsed);
	}
	MarkUsedNonterminals(tree->left, aRuleTree, cNonterminal, abUsed);
	MarkUsedNonterminals(tree->right, aRuleTree, cNonterminal, abUsed);
}

/******************************Public*Routine******************************\
* CountNonterminal
*
* Function to count nonterminals.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int CountNonterminal(PARSETREE *tree)
{
	if (!tree)
		return 0;
	return CountNonterminal(tree->left) + CountNonterminal(tree->right) + (IsNonterminal(tree->value) ? 1 : 0);
}

/******************************Public*Routine******************************\
* DestroyRules
*
* Function to destroy a list of rules.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyRules(RULE *rule)
{
	while (rule)
	{
		RULE *tmp = rule->next;
		DestroyPARSETREE(rule->tree);
		ExternFree(rule);
		rule = tmp;
	}
}

/******************************Private*Routine******************************\
* ExpandExpr
*
* Given the parse tree of an expression and a set of rules, this function
* repeatedly replaces all non-terminals in the expression with the rules
* to derive a final expression devoid of non-terminals
* It detects any recursion or undefined-but-used non-terminals.
*
* Warning: This function destroys the original expression supplied.
* Warning: This function destroys the rules too.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *ExpandExpr(PARSETREE *expr, RULE *rule, WCHAR **awszName, int cNonterminal)
{
	int i, c;
	BOOL *abUsed = NULL;
	PARSETREE **aTree = NULL;
	int *acNonterminal = NULL;
	BOOL bRet = TRUE;

	// array to track which non-terminals are actually being used
	abUsed = (BOOL *) ExternAlloc(cNonterminal*sizeof(BOOL));
	if (!abUsed)
	{
		SetErrorMsgSD("Malloc failure %d", cNonterminal*sizeof(BOOL));
		bRet = FALSE;
		goto cleanup;
	}
	memset(abUsed, 0, cNonterminal*sizeof(BOOL));

	// put the rules in an array for easy access
	aTree = (PARSETREE **) ExternAlloc(cNonterminal*sizeof(PARSETREE *));
	if (!aTree)
	{
		SetErrorMsgSD("Malloc failure %d", cNonterminal*sizeof(PARSETREE *));
		bRet = FALSE;
		goto cleanup;
	}
	memset(aTree, 0, cNonterminal*sizeof(RULE *));
	while (rule)
	{
		int index;
		RULE *tmp;

		ASSERT(IsNonterminal(rule->left));
		index = rule->left - MIN_NONTERMINAL;
		ASSERT(index >= 0);
		ASSERT(index < cNonterminal);
		aTree[index] = rule->tree;
		tmp = rule;
		rule = rule->next;
		ExternFree(tmp);
	}

	// now let's figure out which non-terminals are really being used
	MarkUsedNonterminals(expr, aTree, cNonterminal, abUsed);

	// are there any un-defined but used non-terminals?
	for (i=0; i<cNonterminal; i++)
	{
		if (abUsed[i] && !aTree[i])
		{
			unsigned char *sz = UnicodeToCP1252String(awszName[i]);
			if (sz)
			{
				SetErrorMsgSS("could not expand nonterminal %s", sz);
				ExternFree(sz);
			}
			else
				SetErrorMsgS("could not expand nonterminal");
			bRet = FALSE;
			goto cleanup;
		}
		else if (!abUsed[i])
		{
			DestroyPARSETREE(aTree[i]);
			aTree[i] = NULL;
		}
	}

	// count number of non-terminals used in each rule
	acNonterminal = (int *) ExternAlloc(cNonterminal * sizeof(int));
	if (!acNonterminal)
	{
		SetErrorMsgSD("Malloc failure %d", cNonterminal*sizeof(int));
		bRet = FALSE;
		goto cleanup;
	}
	for (i=0; i<cNonterminal; i++)
		acNonterminal[i] = CountNonterminal(aTree[i]);

	// replace non-terminals one by one
	c = CountNonterminal(expr);
	while (c > 0)
	{
		PARSETREE *ruletree;
		int nonterminal;

		// find a rule with no non-terminals
		for (i=0; i<cNonterminal; i++)
			if (aTree[i] && (acNonterminal[i] == 0))
				break;
		if (i >= cNonterminal)
		{
			SetErrorMsgS("recursion detected in regular expression definition");
			bRet = FALSE;
			goto cleanup;
		}
		ASSERT(aTree[i]);
		ASSERT(acNonterminal[i] == 0);

		// replace non-terminal i with its rule everywhere
		ruletree = aTree[i];
		aTree[i] = NULL;
		nonterminal = i + MIN_NONTERMINAL;
		for (i=0; i<cNonterminal; i++)
		{
			acNonterminal[i] -= ReplaceNonterminal(&aTree[i], nonterminal, ruletree);
			ASSERT(acNonterminal[i] == CountNonterminal(aTree[i]));
		}
		c -= ReplaceNonterminal(&expr, nonterminal, ruletree);
		ASSERT(c == CountNonterminal(expr));
		DestroyPARSETREE(ruletree);
	}
	ASSERT(c == 0);

cleanup:
	if (abUsed)
		ExternFree(abUsed);
	if (aTree)
	{
		for (i=0; i<cNonterminal; i++)
			if (aTree[i])
				DestroyPARSETREE(aTree[i]);
		ExternFree(aTree);
	}
	if (rule)
		DestroyRules(rule);
	if (acNonterminal)
		ExternFree(acNonterminal);
	if (!bRet)
	{
		DestroyPARSETREE(expr);
		expr = NULL;
	}
	return expr;
}

/******************************Private*Routine******************************\
* MergeRules
*
* Given a set of rules, this function merges all rules with identical
* left-hand-sides into a single rule.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL MergeRules(RULE *rule)
{
	while (rule)
	{
		int left = rule->left;
		RULE *tmp = rule->next, *last=rule;

		while (tmp)
		{
			if (tmp->left == left)
			{
				PARSETREE *tmpTree;

				tmpTree = MergePARSETREE(rule->tree, tmp->tree);
				if (!tmpTree)
					return FALSE;
				rule->tree = tmpTree;
				last->next = tmp->next;
				ExternFree(tmp);
				tmp = last->next;
			}
			else
			{
				last = tmp;
				tmp = tmp->next;
			}
		}

		rule = rule->next;
	}
	return TRUE;
}

/******************************Private*Routine******************************\
* ParseOneTerm
*
* Parse one term i.e.
*		a terminal
*		a non-terminal
*		a parenthesized expression
* Also consume any following unary operators like ? * + 
*
* a NULL return is equivalent to error
* 
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *ParseOneTerm(TOKENSTREAM *pTokenstream)
{
	PARSETREE *tree = NULL, *tree1;
	int token;

	ASSERT(pTokenstream);

	if (pTokenstream->cToken <= 0)
		return NULL;

	// read the first "term" i.e. an ID or an parenthesised expression
	// also read any unary operators at the end
	token = pTokenstream->aToken[0];
	if (token == OPERATOR_LPAREN)
	{
		pTokenstream->aToken++;
		pTokenstream->cToken--;
		tree = TokensToTree(pTokenstream);
		if (!tree)
		{
			if (!IsErrorMsgSet())
				SetErrorMsgS("nothing following left paren (");
			return NULL;
		}
		if ((pTokenstream->cToken <= 0) || (pTokenstream->aToken[0] != OPERATOR_RPAREN))
		{
			DestroyPARSETREE(tree);
			if (!IsErrorMsgSet())
				SetErrorMsgS("expecting right paren )");
			return NULL;
		}
		pTokenstream->aToken++;
		pTokenstream->cToken--;
	}
	else if (token == OPERATOR_LBRACKET)
	{
		pTokenstream->aToken++;
		pTokenstream->cToken--;
		tree = TokensToTree(pTokenstream);
		if (!tree)
		{
			if (!IsErrorMsgSet())
				SetErrorMsgS("nothing following left bracket [");
			return NULL;
		}
		if ((pTokenstream->cToken <= 0) || (pTokenstream->aToken[0] != OPERATOR_RBRACKET))
		{
			DestroyPARSETREE(tree);
			if (!IsErrorMsgSet())
				SetErrorMsgS("expecting right bracket ]");
			return NULL;
		}
		pTokenstream->aToken++;
		pTokenstream->cToken--;
		// convert the [] notation to the "?" notation
		tree1 = MakePARSETREE(OPERATOR_OPTIONAL);
		if (!tree1)
		{
			DestroyPARSETREE(tree);
			return NULL;
		}
		tree1->left = tree;
		tree1->right = NULL;
		tree = tree1;
	}
	else if (!IsOperator(token))
	{
		tree = MakePARSETREE(token);
		if (!tree)
			return NULL;
		pTokenstream->aToken++;
		pTokenstream->cToken--;
	}

	// use up any unary operators
	ASSERT(tree);
	if (pTokenstream->cToken > 0)
	{
		token = pTokenstream->aToken[0];
		while (IsUnaryOperator(token))
		{
			tree1 = MakePARSETREE(token);
			if (!tree1)
			{
				DestroyPARSETREE(tree);
				return NULL;
			}
			tree1->left = tree;
			tree1->right = NULL;
			tree = tree1;
			pTokenstream->aToken++;
			pTokenstream->cToken--;
			if (pTokenstream->cToken > 0)
				token = pTokenstream->aToken[0];
			else
				break;
		}
	}

	return tree;
}

/******************************Private*Routine******************************\
* TokensToTree
*
* This is the top level function to parse a token stream and produce a parse tree.
*
* a NULL return is equivalent to error
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *TokensToTree(TOKENSTREAM *pTokenstream)
{
	PARSETREE *tree, *tree1, *tree2;
	int token;

	ASSERT(pTokenstream);

	if (pTokenstream->cToken <= 0)  // shouldn't happen
		return NULL;

	tree = ParseOneTerm(pTokenstream);
	if (!tree || (pTokenstream->cToken <= 0))
		return tree;

	// process the binary operators including the implicit CAT

	// in order to impose the higher precedence of CAT over OR, 
	// we do a loop over the CATs here
	token = pTokenstream->aToken[0];
	while ((token == OPERATOR_CAT) || (token == OPERATOR_LPAREN) || (token == OPERATOR_LBRACKET) || !IsOperator(token))
	{
		if (token == OPERATOR_CAT)
		{
			pTokenstream->aToken++;
			pTokenstream->cToken--;
		}
		tree2 = ParseOneTerm(pTokenstream);
		if (!tree2)
		{
			if (!IsErrorMsgSet())
			{
				if (token == OPERATOR_CAT)
					SetErrorMsgS("could not find second operand for CAT");
				else
					SetErrorMsgS("could not find second operand for implicit CAT");
			}
			DestroyPARSETREE(tree);
			return NULL;
		}
		tree1 = MakePARSETREE(OPERATOR_CAT);
		if (!tree1)
		{
			DestroyPARSETREE(tree);
			return NULL;
		}
		tree1->right = tree2;
		tree1->left = tree;
		tree = tree1;
		// any more?
		if (pTokenstream->cToken <= 0)
			break;
		token = pTokenstream->aToken[0];
	}

	if (pTokenstream->cToken <= 0)
		return tree;

	// now deal with any ORs
	token = pTokenstream->aToken[0];
	if (token == OPERATOR_OR)
	{
		pTokenstream->aToken++;
		pTokenstream->cToken--;
		tree2 = TokensToTree(pTokenstream);
		if (!tree2)
		{
			if (!IsErrorMsgSet())
				SetErrorMsgS("could not find second operand for OR");
			DestroyPARSETREE(tree);
			return NULL;
		}
		tree1 = MakePARSETREE(OPERATOR_OR);
		tree1->right = tree2;
		tree1->left = tree;
		tree = tree1;
	}
	else
	{
		ASSERT((token == OPERATOR_RPAREN) || (token == OPERATOR_RBRACKET));
		if ((token != OPERATOR_RPAREN) && (token != OPERATOR_RBRACKET))
		{
			SetErrorMsgS("syntax error");
			DestroyPARSETREE(tree);
			return NULL;
		}
	}
	
	return tree;
}

/******************************Public*Routine******************************\
* GetAtomLength
*
* Function to compute the length of the next syntactic token in a
* regular expression.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int GetAtomLength(WCHAR *wsz)
{
	int state = 0;
	int length = 0;
	WCHAR wch;

	while (wch = *wsz++)
	{
		switch(state)
		{
		case 0:
			length = 1;
			if (iswalpha(wch))
			{
				state = 1;
				break;
			}
			if (wch == CHARCONST_STRING)
			{
				state = 2;
				break;
			}
			if (wch == CHARCONST_COMMENT)
			{
				state = 4;
				break;
			}
			return 1;
		case 1:
			if (iswalpha(wch) || iswdigit(wch) || (wch == CHARCONST_UNDERSCORE))
			{
				length++;
				break;
			}
			return length;
		case 2:
			length++;
			if (wch == CHARCONST_STRING)
				return length;
			if (wch == CHARCONST_ESCAPE)
			{
				state = 3;
				break;
			}
			break;
		case 3:
			if ((wch != CHARCONST_ESCAPE) && (wch != CHARCONST_STRING))
			{
				SetErrorMsgS("Only \"\\\\\" and \"\\\"\" are allowed as escapes in strings.");
				return -1;
			}
			state = 2;
			length++;
			break;
		case 4:
			length++;
			if (wch == CHARCONST_STOP)
				return length;
			break;
		default:
			ASSERT(0);
			SetErrorMsgS("Unexpected error");
			return -1;
			break;
		}
	}

	if ((state == 2) || (state == 3))
	{
		SetErrorMsgS("string not terminated?");
		return -1;
	}
	return length;
}

/******************************Public*Routine******************************\
* WcharToOperator
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WcharToOperator(WCHAR wch)
{
	switch(wch)
	{
	case CHARCONST_EQUALS:
		return OPERATOR_EQUALS;
	case CHARCONST_CAT:
		return OPERATOR_CAT;
	case CHARCONST_OR:
		return OPERATOR_OR;
	case CHARCONST_ZERO:
		return OPERATOR_ZERO;
	case CHARCONST_ONE:
		return OPERATOR_ONE;
	case CHARCONST_OPTIONAL:
		return OPERATOR_OPTIONAL;
	case CHARCONST_LPAREN:
		return OPERATOR_LPAREN;
	case CHARCONST_RPAREN:
		return OPERATOR_RPAREN;
	case CHARCONST_LBRACKET:
		return OPERATOR_LBRACKET;
	case CHARCONST_RBRACKET:
		return OPERATOR_RBRACKET;
	case CHARCONST_STOP:
		return OPERATOR_STOP;
	default:
		return -1;
	}
}

/******************************Public*Routine******************************\
* GetToken
*
* Function to parse the raw input for a regular expression into a
* stream of tokens.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int GetToken(TOKENPARSING *pTokenparsing, STRINGTABLE *nonterminals)
{
	int token, iAtomLength;
	WCHAR *wsz;

	if (pTokenparsing->bInString)
	{
		// we are in the middle of processing string terminals like "abc"
		wsz = pTokenparsing->wsz;
		if (*wsz == CHARCONST_STRING)
		{
			pTokenparsing->bInString = FALSE;
			pTokenparsing->bLastTerminal = FALSE;
			token = OPERATOR_RPAREN;
			wsz++;
		}
		else if (pTokenparsing->bLastTerminal)
		{
			pTokenparsing->bLastTerminal = FALSE;
			token = OPERATOR_OR;
		}
		else
		{
			if (*wsz == CHARCONST_ESCAPE)
				wsz++;
			token = WCHAR2Terminal(*wsz);
			pTokenparsing->bLastTerminal = TRUE;
			wsz++;
		}
		pTokenparsing->wsz = wsz;
		return token;
	}

	wsz = pTokenparsing->wsz;
	while (*wsz && iswspace(*wsz))
		wsz++;
	iAtomLength = GetAtomLength(wsz);
	if (iAtomLength < 0)
		return TOKEN_UNDEFINED;
	if (iAtomLength == 0)
		return TOKEN_NONE;

	// okay, now convert string to token(s)
	if (iswalpha(*wsz))
	{
#ifndef DISABLE_FACTOID
		// is it really a non-terminal or is it a factoid?
		token = StringToFactoid(wsz, iAtomLength);
		if (token < 0)
		{
#endif
			// convert non-terminals to unique IDs
			token = InsertSymbol(wsz, iAtomLength, nonterminals) + MIN_NONTERMINAL;
			if (token < 0)
				token = TOKEN_UNDEFINED;
#ifndef DISABLE_FACTOID
		}
		else
			token += MIN_FACTOID_TERMINAL;
#endif
	}
	else if (*wsz == CHARCONST_COMMENT)
	{
		ASSERT(iAtomLength > 0);
		if (wsz[iAtomLength-1] == CHARCONST_STOP)
			token = OPERATOR_STOP;
		else
			token = TOKEN_NONE;
	}
	else if (*wsz == CHARCONST_STRING)
	{
		// deal with string terminals like "abc"
		ASSERT(iAtomLength >= 2);
		if (iAtomLength == 2)
			token = TOKEN_EMPTY_STRING;
		else if (iAtomLength == 3)
			token = WCHAR2Terminal(*(wsz+1));
		else
		{
			token = OPERATOR_LPAREN;
			pTokenparsing->bInString = TRUE;
			iAtomLength = 1;
		}
	}
	else if (iAtomLength == 1)
	{
		// convert char operators like '| into IDs like OPERATOR_OR
		token = WcharToOperator(*wsz);
		if (token < 0)
		{
			SetErrorMsgSD("expecting operator, got 0x%x", *wsz);
			token = TOKEN_UNDEFINED;
		}
	}
	else
	{
		SetErrorMsgSD("cannot parse: 0x%x", *wsz);
		token = TOKEN_UNDEFINED;
	}
	pTokenparsing->wsz = wsz + iAtomLength;
	return token;
}

/******************************Public*Routine******************************\
* GetRule
*
* Function to organize an input regular expression into rules.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
RULE *GetRule(WCHAR **pwsz, STRINGTABLE *nonterminals, BOOL *pbError)
{
	int token, left;
	RULE *rule;
	PARSETREE *tree;
	TOKENPARSING tokenparsing;
	int *aToken = NULL;
	int cToken = 0, cTokenMax = 0;
	TOKENSTREAM tokenstream;
	BOOL bEqualsFound = FALSE;

	memset(&tokenparsing, 0, sizeof(TOKENPARSING));
	tokenparsing.wsz = *pwsz;
	for (;;)
	{
		token = GetToken(&tokenparsing, nonterminals);
		if (token == TOKEN_UNDEFINED)
		{
			if (cToken)
				ExternFree(aToken);
			*pbError = TRUE;
			return NULL;
		}
		else if (token == TOKEN_NONE)
			break;
		else if (token == OPERATOR_STOP)
		{
			if (cToken > 0)
				break;
			continue;
		}
		else if (token == OPERATOR_EQUALS)
		{
			if (bEqualsFound)
			{
				SetErrorMsgSD("found two '='s in a rule, may be missing terminator ';'", cTokenMax*sizeof(int));
				ExternFree(aToken);
				*pbError = TRUE;
				return NULL;
			}
			bEqualsFound = TRUE;
		}
		if (cToken >= cTokenMax)
		{
			cTokenMax += 100;
			aToken = (int *) ExternRealloc(aToken, cTokenMax*sizeof(int));
			if (!aToken)
			{
				SetErrorMsgSD("malloc failure %d", cTokenMax*sizeof(int));
				*pbError = TRUE;
				return NULL;
			}
		}
		aToken[cToken++] = token;
	}

	if (cToken <= 0)
		return NULL;

	if (aToken[0] != OPERATOR_EQUALS)
	{
		if ((cToken == 1) || (aToken[1] != OPERATOR_EQUALS))
		{
			SetErrorMsgS("cannot find = operator");
			ExternFree(aToken);
			*pbError = TRUE;
			return NULL;
		}
	}
	left = aToken[0];

	// now convert the token stream into a parse-tree
	if (left == OPERATOR_EQUALS)
	{
		tokenstream.aToken = aToken+1;
		tokenstream.cToken = cToken-1;
	}
	else
	{
		if (!IsNonterminal(left))
		{
			if (IsTerminal(left) && (left >= MIN_FACTOID_TERMINAL))
				SetErrorMsgS("factoid name cannot be on left side of rule");
			else
				SetErrorMsgS("left side of rule is not a nonterminal");
			ExternFree(aToken);
			*pbError = TRUE;
			return NULL;
		}
		tokenstream.aToken = aToken+2;
		tokenstream.cToken = cToken-2;
	}
	SetErrorMsgS("");
	tree = TokensToTree(&tokenstream);
	ExternFree(aToken);
	if (!tree)
	{
		*pbError = TRUE;
		if (!IsErrorMsgSet())
			SetErrorMsgS("empty rule?");
		*pbError = TRUE;
		return NULL;
	}

	rule = (RULE *) ExternAlloc(sizeof(RULE));
	rule->left = left;
	rule->tree = tree;
	*pwsz = tokenparsing.wsz;

	return rule;
}

/******************************Public*Routine******************************\
* ParseInput
*
* Top-level function to convert a raw char-sequence representation of a 
* regular expression into a parse tree.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *ParseInput(WCHAR *wsz)
{
	RULE *rule, *head=NULL;
	PARSETREE *expr;
	STRINGTABLE nonterminals;
	int cNonterminal;
	WCHAR **awszNonterminal = NULL;
	int i;
	BOOL bError = FALSE;

	// read all the file
	memset(&nonterminals, 0, sizeof(STRINGTABLE));
	i = 0;
	while (rule = GetRule(&wsz, &nonterminals, &bError))
	{
		rule->next = head;
		head = rule;
		i++;
	}
	if (bError)
	{
		DestroyRules(head);
		DestroySymbolTable(nonterminals.root, TRUE);
		return NULL;
	}
	DebugOutput2("%d rules\n", i);

	// sanity check:
	if (!head)
		return NULL;
	if (head->left != OPERATOR_EQUALS)
	{
		SetErrorMsgS("last rule has to start with =");
		DestroyRules(head);
		return NULL;
	}
	rule = head->next;
	while (rule)
	{
		if (rule->left == OPERATOR_EQUALS)
		{
			SetErrorMsgS("only last rule can start with a =");
			DestroyRules(head);
			DestroySymbolTable(nonterminals.root, TRUE);
			return NULL;
		}
		rule = rule->next;
	}

	// convert non-terminal table from binary-tree format to simple array
	cNonterminal = nonterminals.count;
	if (cNonterminal)
	{
		awszNonterminal = FlattenSymbolTable(&nonterminals);
		if (!awszNonterminal)
		{
			DestroyRules(head);
			DestroySymbolTable(nonterminals.root, TRUE);
			return NULL;
		}
		DestroySymbolTable(nonterminals.root, FALSE);
		nonterminals.root = NULL;
	}
	DebugOutput2("%d nonterminals\n", cNonterminal);

	// get expression to be expanded
	rule = head->next;
	expr = head->tree;
	ExternFree(head);
	head = rule;

	// merge rules with the same left hand side
	if (!MergeRules(head))
	{
		DestroyRules(head);
		return NULL;
	}

	// expand root rule into expression
	expr = ExpandExpr(expr, head, awszNonterminal, cNonterminal);
	if (expr)
	{
		DebugOutput2("%d nodes in parse tree.\n", SizePARSETREE(expr));
	}

	// destroy all objects no longer required
	for (i=0; i<cNonterminal; i++)
		ExternFree(awszNonterminal[i]);
	ExternFree(awszNonterminal);

	return expr;
}

#ifdef STANDALONE_RE2FSA
/******************************Private*Routine******************************\
* WordToTree
*
* Function to produce a simple parsetree (using only the concatenation
* operator) for a word.
*
* History:
* 23-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *WordToTree(WCHAR *wszWord)
{
	PARSETREE *tree;

	if (!wszWord)
		return NULL;
	tree = MakePARSETREE(*wszWord++);
	if (!tree)
		return NULL;
	while (*wszWord)
	{
		PARSETREE *tmp = MakePARSETREE(OPERATOR_CAT);
		if (!tmp)
		{
			DestroyPARSETREE(tree);
			return NULL;
		}
		tmp->left = tree;
		tree = tmp;
		tree->right = MakePARSETREE(*wszWord++);
		if (!tree->right)
		{
			DestroyPARSETREE(tree);
			return NULL;
		}
	}

	return tree;
}

/******************************Public*Routine******************************\
* ParseWordlist
*
* Function to produce a simple parsetree for a list of words.
* Each word generates a tree using only the concatenation operator.
* The indicidual word-trees are then put together using the "or" operator.
*
* History:
* 23-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *ParseWordlist(WCHAR *wsz)
{
	PARSETREE *tree = NULL, *word;

	while (*wsz)
	{
		while (*wsz && iswspace(*wsz))
			wsz++;
		if (*wsz)
		{
			WCHAR *wsz1;

			wsz1 = wsz;
			while (*wsz1 && !iswspace(*wsz1))
				wsz1++;
			if (*wsz1)
				*wsz1 = 0;
			else
				wsz1 = NULL;

			word = WordToTree(wsz);
			if (!word)
			{
				DestroyPARSETREE(tree);
				return NULL;
			}
			if (tree)
			{
				PARSETREE *tmp = MakePARSETREE(OPERATOR_OR);
				if (!tmp)
				{
					DestroyPARSETREE(tree);
					DestroyPARSETREE(word);
					return NULL;
				}
				tmp->left = tree;
				tree = tmp;
				tree->right = word;
			}
			else
			{
				tree = word;
			}

			if (wsz1)
				wsz = wsz1+1;
		}
	}

	return tree;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\ptree.c ===
// ptree.c
// parse tree for regular expressions
// Angshuman Guha
// aguha
// July 19, 2001

#include "ptree.h"
#include "regexp.h"

/******************************Public*Routine******************************\
* DestroyPARSETREE
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyPARSETREE(PARSETREE *tree)
{
	if (!tree)
		return;
	DestroyPARSETREE(tree->left);
	DestroyPARSETREE(tree->right);
	DestroyIntSet(tree->FirstPos);
	DestroyIntSet(tree->LastPos);
	ExternFree(tree);
}

/******************************Public*Routine******************************\
* MakePARSETREE
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *MakePARSETREE(int value)
{
	PARSETREE *tree;

	tree = (PARSETREE *) ExternAlloc(sizeof(PARSETREE));
	if (!tree)
	{
		SetErrorMsgSD("malloc failure %d", sizeof(PARSETREE));
		return NULL;
	}
	tree->left = tree->right = NULL;
	tree->value = value;
	tree->FirstPos = tree->LastPos = 0;
	tree->nullable = 0;
	return tree;
}

/******************************Public*Routine******************************\
* MergePARSETREE
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *MergePARSETREE(PARSETREE *tree1, PARSETREE *tree2)
{
	PARSETREE *tree = MakePARSETREE(OPERATOR_OR);
	if (!tree)
		return NULL;
	tree->left = tree1;
	tree->right = tree2;
	return tree;
}

/******************************Public*Routine******************************\
* SizePARSETREE
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int SizePARSETREE(PARSETREE *tree)
{
	if (tree)
		return 1 + SizePARSETREE(tree->left) + SizePARSETREE(tree->right);
	return 0;
}

/******************************Public*Routine******************************\
* CopyPARSETREE
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
PARSETREE *CopyPARSETREE(PARSETREE *tree)
{
	PARSETREE *newtree;

	if (!tree)
		return NULL;

	newtree = MakePARSETREE(tree->value);
	if (!newtree)
		return NULL;
	if (tree->left)
	{
		newtree->left = CopyPARSETREE(tree->left);
		if (!newtree->left)
		{
			ExternFree(newtree);
			return NULL;
		}
	}
	else
		newtree->left = NULL;
	if (tree->right)
	{
		newtree->right = CopyPARSETREE(tree->right);
		if (!newtree->right)
		{
			DestroyPARSETREE(newtree);
			return NULL;
		}
	}
	else
		newtree->right = NULL;
	tree->FirstPos = tree->LastPos = 0;
	tree->nullable = 0;
	return newtree;
}

/******************************Public*Routine******************************\
* MakePureRegularExpression
*
* The purpose of this function is to eliminate non-standard operators like
* '+' (OPERATOR_ONE) and '?" (OPERATOR_OPTIONAL) from a given parsed regular
* expression.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL MakePureRegularExpression(PARSETREE *tree)
{
	PARSETREE *tree1;

	if (!tree)
		return TRUE;

	if (tree->value == OPERATOR_ONE)
	{
		tree->value = OPERATOR_CAT;
		tree1 = MakePARSETREE(OPERATOR_ZERO);
		if (!tree1)
			return FALSE;
		tree->right = tree1;
		tree1 = CopyPARSETREE(tree->left);
		if (!tree1)
			return FALSE;
		tree->right->left = tree1;
		tree->right->right = NULL;
	}
	else if (tree->value == OPERATOR_OPTIONAL)
	{
		tree->value = OPERATOR_OR;
		tree1 = MakePARSETREE(TOKEN_EMPTY_STRING);
		if (!tree1)
			return FALSE;
		tree->right = tree1;
	}

	if (!MakePureRegularExpression(tree->left))
		return FALSE;
	return MakePureRegularExpression(tree->right);
}

/******************************Private*Routine******************************\
* SetPositionValues
*
* Assign a unique 'position' value to all terminals (leaves) in a parsed
* regular expression.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void SetPositionValues(PARSETREE *tree, unsigned int *pposition)
{
	if (!tree)
		return;

	if (tree->left)
	{
		SetPositionValues(tree->left, pposition);
		SetPositionValues(tree->right, pposition);
	}
	else
		tree->position = (*pposition)++;
}

/******************************Private*Routine******************************\
* ComputePos2Char
*
* Compute the mapping from each 'position' in a parsed tree to its corresponding
* terminal.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void ComputePos2Wchar(PARSETREE *tree, WCHAR *aPos2Wchar)
{
	if (!tree)
		return;

	if (tree->left)
	{
		ComputePos2Wchar(tree->left, aPos2Wchar);
		ComputePos2Wchar(tree->right, aPos2Wchar);
	}
	else
		aPos2Wchar[tree->position] = (WCHAR) tree->value;
}

/******************************Private*Routine******************************\
* ComputeFollowpos
*
* Compute the function FollowPos: position -> set of positions.
* This is directly from the Dragon book.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void ComputeFollowpos(PARSETREE *tree, IntSet *aFollowpos)
{
	unsigned int pos;
	BOOL b;

	if (!tree)
		return;

	if (tree->value == OPERATOR_CAT)
	{
		// for every position pos in tree->left->LastPos
		// add tree->right->FirstPos to followpos(pos)
		for (b = FirstMemberIntSet(tree->left->LastPos, &pos); b; b = NextMemberIntSet(tree->left->LastPos, &pos))
		{
			b = UnionIntSet(aFollowpos[pos], tree->right->FirstPos);
			ASSERT(b);
		}
	}
	else if (tree->value == OPERATOR_ZERO)
	{
		// for every position pos in tree->Lastpos
		// add tree->Firstpos to followpos(pos)
		for (b = FirstMemberIntSet(tree->LastPos, &pos); b; b = NextMemberIntSet(tree->LastPos, &pos))
		{
			b = UnionIntSet(aFollowpos[pos], tree->FirstPos);
			ASSERT(b);
		}
	}
	
	ComputeFollowpos(tree->left, aFollowpos);
	ComputeFollowpos(tree->right, aFollowpos);
}

/******************************Private*Routine******************************\
* ComputeNodeAttributesRecursive
*
* Compute the functions
*		Nullable: node -> Boolean
*		FirstPos: node -> set of positions
*		LastPos:  node -> set of positions
* This is directly from the Dragon book.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL ComputeNodeAttributesRecursive(PARSETREE *tree, int cPosition)
{
	BOOL b;

	if (!tree)
		return TRUE;

	if (tree->value == TOKEN_EMPTY_STRING) // epsilon leaf
	{
		// nullable
		tree->nullable = TRUE;
		// firstpos & lastpos
		if (!MakeIntSet(cPosition, &tree->FirstPos) || !MakeIntSet(cPosition, &tree->LastPos))
		{
			SetErrorMsgS("malloc failure");
			return FALSE;
		}
		return TRUE; 
	}
	else if (!tree->left)   // non-epsilon leaf
	{
		// nullable
		tree->nullable = FALSE; 
		// firstpos & lastpos
		if (!MakeIntSet(cPosition, &tree->FirstPos) || !MakeIntSet(cPosition, &tree->LastPos))
		{
			SetErrorMsgS("malloc failure");
			return FALSE;
		}
		b = AddMemberIntSet(tree->FirstPos, tree->position);
		ASSERT(b);
		b = AddMemberIntSet(tree->LastPos, tree->position);
		ASSERT(b);
	}
	else // non-leaf
	{
		if (!ComputeNodeAttributesRecursive(tree->left, cPosition))
			return FALSE;
		if (!ComputeNodeAttributesRecursive(tree->right, cPosition))
			return FALSE;
		if (tree->value == OPERATOR_OR)
		{
			// nullable
			tree->nullable = tree->left->nullable | tree->right->nullable;
			// firstpos
			if (!CopyIntSet(tree->left->FirstPos, &tree->FirstPos))
			{
				SetErrorMsgS("malloc failure");
				return FALSE;
			}
			b = UnionIntSet(tree->FirstPos, tree->right->FirstPos);
			ASSERT(b);
			// lastpos
			if (!CopyIntSet(tree->left->LastPos, &tree->LastPos))
			{
				SetErrorMsgS("malloc failure");
				return FALSE;
			}
			b = UnionIntSet(tree->LastPos, tree->right->LastPos);
			ASSERT(b);
		}
		else if (tree->value == OPERATOR_CAT)
		{
			// nullable
			tree->nullable = tree->left->nullable & tree->right->nullable;
			// firstpos
			if (!CopyIntSet(tree->left->FirstPos, &tree->FirstPos))
			{
				SetErrorMsgS("malloc failure");
				return FALSE;
			}
			if (tree->left->nullable)
			{
				b = UnionIntSet(tree->FirstPos, tree->right->FirstPos);
				ASSERT(b);
			}
			// lastpos
			if (!CopyIntSet(tree->right->LastPos, &tree->LastPos))
			{
				SetErrorMsgS("malloc failure");
				return FALSE;
			}
			if (tree->right->nullable)
			{
				b = UnionIntSet(tree->LastPos, tree->left->LastPos);
				ASSERT(b);
			}
		}
		else if (tree->value == OPERATOR_ZERO)
		{
			// nullable
			tree->nullable = TRUE;
			// firstpos & lastpos
			if (!CopyIntSet(tree->left->FirstPos, &tree->FirstPos) || !CopyIntSet(tree->left->LastPos, &tree->LastPos))
			{
				SetErrorMsgS("malloc failure");
				return FALSE;
			}
		}
		else
			ASSERT(0);
	}
	return TRUE;
}

/******************************Public*Routine******************************\
* ComputeNodeAttributes
*
* The top-level call to compute the Nullable, FirstPos, LastPos and
* FollowPos functions as described in the Dragon book.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int ComputeNodeAttributes(PARSETREE *tree, IntSet **paFollowpos, WCHAR **paPos2Wchar)
{
	int cPosition = 0, i;
	IntSet *aFollowpos;
	WCHAR *aPos2Wchar;
	
	SetPositionValues(tree, &cPosition);
	if (!ComputeNodeAttributesRecursive(tree, cPosition))
		return -1;

	aFollowpos = (IntSet *) ExternAlloc(cPosition*sizeof(IntSet));
	if (!aFollowpos)
	{
		SetErrorMsgSD("Malloc failure %d", cPosition*sizeof(IntSet));
		return -1;
	}

	for (i=0; i<cPosition; i++)
	{
		if (!MakeIntSet(cPosition, &aFollowpos[i]))
		{
			for (--i; i>=0; --i)
				DestroyIntSet(aFollowpos[i]);
			ExternFree(aFollowpos);
			SetErrorMsgS("malloc failure");
			return -1;
		}
	}
	ComputeFollowpos(tree, aFollowpos);
	*paFollowpos = aFollowpos;

	aPos2Wchar = (WCHAR *) ExternAlloc(cPosition*sizeof(WCHAR));
	if (!aPos2Wchar)
	{
		ExternFree(aFollowpos);
		SetErrorMsgSD("Malloc failure %d", cPosition*sizeof(WCHAR));
		return -1;
	}
	ComputePos2Wchar(tree, aPos2Wchar);
	*paPos2Wchar = aPos2Wchar;

	return cPosition;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\regexp.c ===
// regexp.c
// Angshuman Guha
// aguha
// June 27, 2001

// program to convert a regular expression into a minimal deterministic finte state automaton
// input is read from a file
// output is stdout

// The parsing algorithm is nothing fancy because you don't need too much power to parse
// a regular expression.
// The RegExp -> DFA conversion algorithm and the DFA state minimization algorithm are from the Dragon book:
//		Compilers
//		Principles, Techniques and Tools
//		Aho, Sethi & Ullman
//		Addison Wesley, 1988
//		Chapter 3, Section 9, Pages 134-144.
// The RegExp->DFA algorithm is kind of neat and avoids construction of the intermediate NFA.
// The DFA minimization algorithm is the standard one.

/*
An interesting example is:
a = "a";
b = "b";
c = "c";
e = "";
D = b (c.b)* (e | c) | c (b.c)* (e | b);
X = a* D a;
Y = a* (e | D);
= X* Y;

The corresponding DFA is:
3 states
state 0
valid=1 cTrans=3
{L'a', 0}, {L'b', 1}, {L'c', 2}
state 1
valid=1 cTrans=2
{L'a', 0}, {L'c', 2}
state 2
valid=1 cTrans=2
{L'a', 0}, {L'b', 1}
*/

// a '#' triggers the beginning of a comment
// no parsing is done inside a comment
// a comment is considered terminated once the stop character ';' is encountered

#include <stdlib.h>
#include <search.h>
#include <common.h>
#include "regexp.h"
#include "ptree.h"
#include "dfa.h"
#include "strtable.h"
#include <sys/stat.h>
#include "re_input.h"

/******************************Public*Routine******************************\
* Error Message routines and global buffers.
*
* This is potentially thread-unsafe.  In case we have two threads compiling
* regular expressions at the same time and they both encounter errors, we
* have a big problem.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/

WCHAR gwszRegExpErrorMsg[256];
unsigned char gszRegExpErrorMsg[256] = "";

BOOL IsErrorMsgSet(void)
{
	return gszRegExpErrorMsg[0];
}

void SetErrorMsgS(char *sz)
{
	strcpy(gszRegExpErrorMsg, sz);
}

void SetErrorMsgSD(char *sz, int x)
{
	sprintf(gszRegExpErrorMsg, sz, x);
}

void SetErrorMsgSS(char *sz, char *sz1)
{
	sprintf(gszRegExpErrorMsg, sz, sz1);
}

void SetErrorMsgSDD(char *sz, int x, int y)
{
	sprintf(gszRegExpErrorMsg, sz, x, y);
}

int __cdecl CompareAlphabet(const void *arg1, const void *arg2)
{
	return *((WCHAR *)arg1) - *((WCHAR *)arg2);
}

/******************************Private*Routine******************************\
* MakeAlphabet
*
* This function finds out all the terminals (wchar literals) used in
* regular expression.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int MakeAlphabet(int cPosition, WCHAR *aPos2Wchar, WCHAR **paAlphabet)
{
	WCHAR *aAlphabet, **apAlphabet;
	int cAlphabet, i;
	STRINGTABLE strTable;

	memset(&strTable, 0, sizeof(STRINGTABLE));

	ASSERT(cPosition > 0);
	for (; cPosition; cPosition--, aPos2Wchar++)
	{
		if ((*aPos2Wchar != TOKEN_EMPTY_STRING) && (*aPos2Wchar != TOKEN_END_MARKER))
		{
			if (InsertSymbol(aPos2Wchar, 1, &strTable) < 0)
				return -1;
		}
	}

	cAlphabet = strTable.count;
	ASSERT(cAlphabet > 0);

	apAlphabet = FlattenSymbolTable(&strTable);
	if (!apAlphabet)
	{
		DestroySymbolTable(strTable.root, TRUE);
		return -1;
	}
	DestroySymbolTable(strTable.root, FALSE);

	aAlphabet = (WCHAR *) ExternAlloc(cAlphabet*sizeof(WCHAR));
	if (!aAlphabet)
	{
		for (i=0; i<cAlphabet; i++)
			ExternFree(apAlphabet[i]);
		ExternFree(apAlphabet);
		return -1;
	}

	for (i=0; i<cAlphabet; i++)
	{
		ASSERT(apAlphabet[i]);
		ASSERT(apAlphabet[i][0]);
		ASSERT(!apAlphabet[i][1]);
		aAlphabet[i] = apAlphabet[i][0];
		ExternFree(apAlphabet[i]);
	}
	ExternFree(apAlphabet);

	// the following sort is, strictly speaking, not necessary
	// It only contributes to the "canonicalness" of the final DFA.
	qsort((void *)aAlphabet, cAlphabet, sizeof(WCHAR), CompareAlphabet);

	*paAlphabet = aAlphabet;
	return cAlphabet;
}

/******************************Public*Routine******************************\
* CompileRegularExpression
*
* Top-level function to parse a regular expression into a parse tree,
* produce a detereministic finite automaton and then convert it
* to a minimal deterministic finite automaton.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void *CompileRegularExpression(WCHAR *wsz, BOOL bWordlist)
{
	PARSETREE *tree, *tree1;
	int cPosition, i, cAlphabet;
	short cState;
	IntSet *aFollowpos;
	WCHAR *aPos2Wchar;
	WCHAR *aAlphabet;
	Transition *aTransition;
	unsigned char *abFinal;
	int cTransition;
	void *pv;

	// produce parse tree
#ifdef STANDALONE_RE2FSA
	if (bWordlist)
		tree = ParseWordlist(wsz);
	else
#endif
		tree = ParseInput(wsz);
	if (!tree)
		return NULL;

	// remove non-standard operators like + and ?
	if (!MakePureRegularExpression(tree))
	{
		DestroyPARSETREE(tree);
		return NULL;
	}

	// add special end marker
	tree1 = MakePARSETREE(OPERATOR_CAT);
	if (!tree1)
	{
		DestroyPARSETREE(tree);
		return NULL;
	}
	tree1->left = tree;
	tree1->right = MakePARSETREE(TOKEN_END_MARKER);
	if (!tree1->right)
	{
		DestroyPARSETREE(tree1);
		return NULL;
	}
	tree = tree1;

	// compute Nullable, FirstPos, LastPos attributes for each node in parse tree
	cPosition = ComputeNodeAttributes(tree, &aFollowpos, &aPos2Wchar);
	if (cPosition <= 0)
	{
		DestroyPARSETREE(tree);
		return NULL;
	}
	DebugOutput2("%d positions\n", cPosition);

	// get the alphabet set
	cAlphabet = MakeAlphabet(cPosition, aPos2Wchar, &aAlphabet);
	if (cAlphabet <= 0)
	{
		DestroyPARSETREE(tree);
		ExternFree(aPos2Wchar);
		for (i=0; i<cPosition; i++)
			DestroyIntSet(aFollowpos[i]);
		ExternFree(aFollowpos);
	}
	DebugOutput2("%d alphabets\n", cAlphabet);

	// convert to a DFA
	cState = MakeDFA(tree, cPosition, aFollowpos, aPos2Wchar, cAlphabet, aAlphabet,
					 &cTransition, &aTransition, &abFinal);
	DebugOutput2("%d states in initial DFA\n", cState);

	// clean up
	DestroyPARSETREE(tree);
	ExternFree(aPos2Wchar);
	for (i=0; i<cPosition; i++)
		DestroyIntSet(aFollowpos[i]);
	ExternFree(aFollowpos);

	// minimize states in DFA
	if (!MinimizeDFA(&cState, &abFinal, &cTransition, &aTransition))
	{
		ExternFree(aAlphabet);
		ExternFree(abFinal);
		ExternFree(aTransition);
		return NULL;
	}
	DebugOutput2("%d states in minimal DFA\n", cState);

	// convert to canonical form
	// This step is simply a re-naming of states.
	// Its not really necessary except for debugging purposes.
	// Without this step, a slight syntactic modification of the
	// regular expression, without any semantic change, can result
	// in a different (isomorphic) DFA.
	if (!MakeCanonicalDFA(cState, abFinal, cTransition, aTransition))
	{
		ExternFree(aAlphabet);
		ExternFree(abFinal);
		ExternFree(aTransition);
		return NULL;
	}

	pv = ConvertDFAtoBlob(cTransition, aTransition, cAlphabet, aAlphabet, cState, abFinal);
	ExternFree(aTransition);
	ExternFree(aAlphabet);
	ExternFree(abFinal);
	return pv;
}

/******************************Public*Routine******************************\
* CompileRegExpW
*
* Exported function to compile a regular expression.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void * WINAPI CompileRegExpW(BOOL bFile, WCHAR *wsz)
{
	if (bFile)
	{
		FILE *f;
		struct _stat stat;
		void *pv;

		f = _wfopen(wsz, L"rb");
		if (!f)
		{
			SetErrorMsgS("Could not open input file");
			return NULL;
		}
		_wstat(wsz, &stat);
		wsz = (WCHAR *) ExternAlloc((stat.st_size+1)*sizeof(WCHAR));
		if (!wsz)
		{
			fclose(f);
			SetErrorMsgSD("Malloc failure %d", stat.st_size+1);
			return NULL;
		}
		if ((int)fread(wsz, sizeof(WCHAR), stat.st_size, f) < stat.st_size)
		{
			fclose(f);
			SetErrorMsgS("file read failed");
			return NULL;
		}
		fclose(f);	
		wsz[stat.st_size] = L'\0';
		pv = CompileRegularExpression(wsz, FALSE);
		ExternFree(wsz);
		return pv;
	}
	else
		return CompileRegularExpression(wsz, FALSE);
}

/******************************Private*Routine******************************\
* AsciiFileToString
*
* History:
* 23-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
unsigned char *AsciiFileToString(unsigned char *sz)
{
	FILE *f;
	struct _stat stat;
	
	f = fopen(sz, "rb");
	if (!f)
	{
		SetErrorMsgS("Could not open input file");
		return NULL;
	}
	_stat(sz, &stat);
	sz = (unsigned char *) ExternAlloc((stat.st_size+1)*sizeof(unsigned char));
	if (!sz)
	{
		fclose(f);
		SetErrorMsgSD("Malloc failure %d", stat.st_size+1);
		return NULL;
	}
	if ((int)fread(sz, sizeof(unsigned char), stat.st_size, f) < stat.st_size)
	{
		fclose(f);
		SetErrorMsgS("file read failed");
		return NULL;
	}
	fclose(f);	
	sz[stat.st_size] = '\0';

	return sz;
}

/******************************Private*Routine******************************\
* AsciiStringToUnicode
*
* History:
* 23-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
WCHAR *AsciiStringToUnicode(unsigned char *sz)
{
	int n;
	char *sz1;
	WCHAR *wsz, *wszBuffer;

	n = (strlen(sz)+1)*sizeof(WCHAR);
	wsz = wszBuffer = ExternAlloc(n);
	if (!wsz)
	{
		SetErrorMsgSD("Malloc failure %d", n);
		return NULL;
	}

	sz1 = sz;
	while (*sz1)
	{
		if (!CP1252ToUnicode(*sz1, wsz))
		{
			SetErrorMsgSD("Could not convert 0x%x to Unicode", *sz1);
			ExternFree(wszBuffer);
			return NULL;
		}
		sz1++;
		wsz++;
	}
	*wsz = L'\0';

	return wszBuffer;
}

/******************************Public*Routine******************************\
* CompileRegExpA
*
* Exported function to compile a regular expression.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void * WINAPI CompileRegExpA(BOOL bFile, unsigned char *sz)
{
	WCHAR *wsz;
	void *pv;
	
	if (bFile)
	{
		sz = AsciiFileToString(sz);
		if (!sz)
			return NULL;
	}

	wsz = AsciiStringToUnicode(sz);
	if (bFile)
		ExternFree(sz);
	if (!wsz)
		return NULL;

	pv = CompileRegularExpression(wsz, FALSE);
	ExternFree(wsz);
	return pv;
}

#ifdef STANDALONE_RE2FSA
void *CompileWordlistA(char *szInFile)
{
	void *pv;
	WCHAR *wsz;
	unsigned char *sz;
	
	sz = AsciiFileToString(szInFile);
	if (!sz)
		return NULL;
	wsz = AsciiStringToUnicode(sz);
	ExternFree(sz);
	if (!wsz)
		return NULL;
	pv = CompileRegularExpression(wsz, TRUE);
	ExternFree(wsz);
	return pv;
}
#endif

/******************************Public*Routine******************************\
* RegExpErrorA
*
* Exported function to get detailed message in case of an error in
* compiling a regular expression.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
char *RegExpErrorA(void)
{
	return gszRegExpErrorMsg;
}

/******************************Public*Routine******************************\
* RegExpErrorW
*
* Exported function to get detailed message in case of an error in
* compiling a regular expression.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
WCHAR *RegExpErrorW(void)
{
	WCHAR *wsz = gwszRegExpErrorMsg;
	unsigned char *sz = gszRegExpErrorMsg;

	while (*sz)
	{
		if (!CP1252ToUnicode(*sz++, wsz))
			*wsz = L'?';
		wsz++;
	}
	*wsz = L'\0';
	return gwszRegExpErrorMsg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\minifugufl.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      minifugufl.c
//
// Description:
//      Functions to map fugu databases from files
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <stdlib.h>
#include "fugu.h"

///////////////////////////////////////
//
// FuguLoadFile
//
// Load an integer Fugu database from a file
//
// Parameters:
//      pInfo:   [out] Structure where information for unloading is stored
//      wszPath: [in]  Path to load the database from
//      pLocRunInfo: [in] Locale database to check header on file
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadFile(FUGU_LOAD_INFO *pInfo, wchar_t *wszPath, LOCRUN_INFO *pLocRunInfo)
{
	wchar_t	wszFile[MAX_PATH];

	// Generate path to file.
	FormatPath(wszFile, wszPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"fugu.bin");

    if (!DoOpenFile(&pInfo->info, wszFile)) 
    {
        return FALSE;
    }
    if (!FuguLoadPointer(pInfo, pLocRunInfo, pInfo->info.iSize))
	{
		DoCloseFile(&pInfo->info);
		return FALSE;
	}
	return TRUE;
}

///////////////////////////////////////
//
// FuguUnLoadFile
//
// Unload a Fugu database loaded from a file
//
// Parameters:
//      pInfo: [in] Load information for unloading
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguUnLoadFile(FUGU_LOAD_INFO *pInfo)
{
    return DoCloseFile(&pInfo->info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\ftrain.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      ftrain.c
//
// Description:
//      Fugu training code
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <math.h>
#include <stdio.h>
#include "fugu.h"

///////////////////////////////////////
//
// Sigmoid
//
// Compute the Sigmoid activation function
//
// Parameters:
//      flAct: [in] Input activation value
//
// Return values:
//      Result of function, in the range 0 to 1
//
//////////////////////////////////////
float Sigmoid(float flAct)
{
	return (float)(1.0 / (1.0 + exp(-flAct)));
}

///////////////////////////////////////
//
// FuguScaleGlyph
//
// Scales the coordinate values in the glyph to fit in a 256x256 range.
//
// Parameters:
//      pGlyph: [in]  Ink to be scaled 
//              [out] Scaled version of Ink
//      pGuide:  [in]  Guide to scale ink to, or NULL to use the ink bounds
//
// Return values:
//
//////////////////////////////////////
void FuguScaleGlyph(GLYPH *pGlyph, RECT *pGuide)
{
	GLYPH *p;
	int iPoint;

	// Min coordinate for rendering; should probably be 8 but using this 
	// value for compatibility with Dave's code.
	const int MONO_CLIP_MARGIN = 16 + 8;

	// Max coordinate for rendering; should probably be 29 * 8 - 8 * 2, but
	// using this value for compatibility with Dave's code
	const float MONO_CLIP_BOX = 232.0 - 32;

	// Rectangle in ink space which will be scaled to fill the range above
	int minX = INT_MAX;
	int minY = INT_MAX;
	int maxX = INT_MIN;
	int maxY = INT_MIN;

	// How much to scale the ink by
	float scaleBy = 1.0;

	// How much to shift the ink by
	int offX = 0;
	int offY = 0;

    if (pGuide != NULL) 
    {
        // Scale according to the guide
        minX = pGuide->left;
        minY = pGuide->top;
        maxX = pGuide->right;
        maxY = pGuide->bottom;
    }
    else
    {
	    // Compute the bounding box of the ink.
	    p = pGlyph;
	    while (p != NULL) 
        {
		    for (iPoint = 0; iPoint < (int) p->frame->info.cPnt; iPoint++)
		    {
			    int x = p->frame->rgrawxy[iPoint].x;
			    int y = p->frame->rgrawxy[iPoint].y;
			    if( x < minX )
				    minX = x;
			    if( x > maxX )
				    maxX = x;
			    if( y < minY )
				    minY = y;
			    if( y > maxY )
				    maxY = y;
		    }
		    p = p->next;
	    }
    }

	// The only way this test can fail is if we're passed no ink
	if (minX <= maxX && minY <= maxY) 
    {
		// scale to fit the larger dimension. also determine 
		// the amounts to add to each point before scaling.
		int dX = maxX - minX;
		int dY = maxY - minY;

		if( dX > dY )
		{
			// If the ink is larger in the X direction, center in the Y direction
			scaleBy = MONO_CLIP_BOX / dX;
			offX = 0;
			offY = (int) ( MONO_CLIP_BOX - dY * scaleBy ) / 2;
		}
		else
		{
			if (dY == 0) 
            {
				// If the ink is just a point, then center it
				scaleBy = 0;
				offY = (int)(MONO_CLIP_BOX / 2);
				offX = (int)(MONO_CLIP_BOX / 2);
			}
            else 
            {
				// Otherwise center the ink in the X direction
				scaleBy = MONO_CLIP_BOX / dY;
				offY = 0;
				offX = (int) ( MONO_CLIP_BOX - dX * scaleBy ) / 2;
			}
		}

		// Scan through the strokes
		p = pGlyph;
		while (p != NULL) 
        {
			// For each point in the stroke
			for (iPoint = 0; iPoint < (int) p->frame->info.cPnt; iPoint++)
			{
				// Scale the point
				int iX = ( offX + MONO_CLIP_MARGIN ) + (int) ((p->frame->rgrawxy[iPoint].x - minX) * scaleBy);
				int iY = ( offY + MONO_CLIP_MARGIN ) + (int) ((p->frame->rgrawxy[iPoint].y - minY) * scaleBy);
                // Clip to the allowed range
                if (iX < 0) 
                {
                    iX = 0;
                }
                if (iX > 255)
                {
                    iX = 255;
                }
                if (iY < 0)
                {
                    iY = 0;
                }
                if (iY > 255)
                {
                    iY = 255;
                }
                // Store it
                p->frame->rgrawxy[iPoint].x = iX;
                p->frame->rgrawxy[iPoint].y = iY;
			}
			p = p->next;
		}
	}
}

///////////////////////////////////////
//
// FuguRenderNoScale
//
// Renders a glyph to an image, each pixel has a value from 0 to FUGU_ACTIVATION_SCALE.
// Unlike FuguRender, this function does not scale the ink to the image, but rather
// assumes the ink is already in scaled form as produced by FuguScaleGlyph().
//
// Parameters:
//      pGlyph:  [in]  Pointer to the ink to render
//      aiInput: [out] Array that will be used as input to Fugu
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguRenderNoScale(GLYPH *pGlyph, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT])
{

	// Min coordinate for rendering; should probably be 8 but using this 
	// value for compatibility with Dave's code.
	const int MONO_CLIP_MARGIN = 16 + 8;

	// Max coordinate for rendering; should probably be 29 * 8 - 8 * 2, but
	// using this value for compatibility with Dave's code
	const int MONO_CLIP_BOX = 232 - 32;

    // Initialize the guide box to the box that the ink is already scaled to.
    RECT rGuide;
    rGuide.left = rGuide.top = MONO_CLIP_MARGIN;
    rGuide.right = rGuide.bottom = MONO_CLIP_MARGIN + MONO_CLIP_BOX;

    // Render the ink
    return FuguRender(pGlyph, &rGuide, aiInput);
}

///////////////////////////////////////
//
// FuguForwardPassFloat
//
// Run a forward pass of the floating point network
//
// Parameters:
//      pFugu:    [in] Fugu network
//      aflInput: [in] Input image to work from
//
// Return values:
//      Array of output activations, or NULL if an error occurs
//
//////////////////////////////////////
float *FuguForwardPassFloat(FUGU_FLOAT_WEIGHTS *pFugu, 
                            float aflInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT])
{
	int i, j, ip, jp, a, b;

    // Activations of the hidden units after the first and second convolutional layers
    float *pflStates1 = (float *) ExternAlloc(sizeof(float) * FUGU_KERNELS1 * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1);
    float *pflStates2 = (float *) ExternAlloc(sizeof(float) * FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2);

    // Activations of the fully connected hidden layer
	float *pflStates_fc = (float *) ExternAlloc(sizeof(float) * pFugu->pArch->nHiddens);

    // Activations of the fully connected output layer (which will be returned)
	float *pflOutput = (float *) ExternAlloc(sizeof(float) * pFugu->pArch->nOutputs);

    // Pointer into the weights
	float *pflWeight = pFugu->pflWeights;

    // Temporary pointer to the weights for a convolution kernel
    float *pflKernel;

    // Temporary pointer to the outputs from a layer
    float *pflStateOut;

	// Check memory allocation, clean up and exit on failure
    if (pflOutput == NULL || pflStates_fc == NULL || pflStates1 == NULL || pflStates2 == NULL) 
    {
        ExternFree(pflOutput);
        pflOutput = NULL;
        goto cleanup;
	}

    // For each hidden unit in the first convolutional layer
    pflStateOut = pflStates1;
	for (b = 0; b < FUGU_KERNELS1; b++) 
    {
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH1; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT1; jp++) 
            {
                // Total up the weighted sum for this unit
				float flTotal = 0;
				pflKernel = pflWeight;
				for (i = 0; i < FUGU_KERNEL_WIDTH1; i++) 
                {
					for (j = 0; j < FUGU_KERNEL_HEIGHT1; j++) 
                    {
						flTotal +=
                            aflInput[i + ip * FUGU_KERNEL_SUBSAMPLE1][j + jp * FUGU_KERNEL_SUBSAMPLE1] * 
                            *(pflKernel++);
					}
				}
                // Add in the bias term
				flTotal += *(pflKernel++);
				*(pflStateOut++) = (float) tanh(flTotal);
			}
		}
        // Move on to the next kernel
		pflWeight = pflKernel;
	}

    // For each unit in the second convolutional layer
    pflStateOut = pflStates2;
	for (b = 0; b < FUGU_KERNELS2; b++) {
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
            {
                // Total up the weighted sum for this unit
				float flTotal = 0;
				pflKernel = pflWeight;
				for (a = 0; a < FUGU_KERNELS1; a++) 
                {
                    float *pflStateIn =
                        pflStates1 
                        + (a * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1)
                        + (ip * FUGU_KERNEL_SUBSAMPLE2 * FUGU_HIDDEN_HEIGHT1) 
                        + (jp * FUGU_KERNEL_SUBSAMPLE2);
					for (i = 0; i < FUGU_KERNEL_WIDTH2; i++) 
                    {
						for (j = 0; j < FUGU_KERNEL_HEIGHT2; j++) 
                        {
							flTotal += *(pflStateIn++) * *(pflKernel++);
						}
                        pflStateIn += FUGU_HIDDEN_HEIGHT1 - FUGU_KERNEL_HEIGHT2;
					}
				}
                // Add in the bias term
				flTotal += *(pflKernel++);
				*(pflStateOut++) = (float) tanh(flTotal);
			}
		}
        // Move on to the next kernel
		pflWeight = pflKernel;
	}

    // For each unit in the first fully connected layer
    pflStateOut = pflStates_fc;
	for (i = 0; i < pFugu->pArch->nHiddens; i++) {
        // Total up the weighted sum for this unit
		float flTotal = 0;
        float *pflStateIn = pflStates2;
		for (b = 0; b < FUGU_KERNELS2; b++) {
			for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) {
				for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) {
					flTotal += *(pflStateIn++) * *(pflWeight++);
				}
			}
		}
        // Add in the bias term
		flTotal += *(pflWeight++);
		*(pflStateOut++) = (float) tanh(flTotal);
	}

    // For each unit in the output layer
    pflStateOut = pflOutput;
	for (i = 0; i < pFugu->pArch->nOutputs; i++) {
        // Add up the weighted sum from all the hidden units
		float flTotal = 0;
		for (j = 0; j < pFugu->pArch->nHiddens; j++) {
			flTotal += pflStates_fc[j] * *(pflWeight++);
		}
        // Add in the bias term
		flTotal += *(pflWeight++);
        // Note that the output layer uses a sigmoid activation function,
        // unlike the previous layers.  This activation function ensures
        // that the output is between 0 and 1, and can be treated like
        // a probability.
		*(pflStateOut++) = Sigmoid(flTotal);
	}

    // Clean up and exit
cleanup:
    ExternFree(pflStates1);
    ExternFree(pflStates2);
	ExternFree(pflStates_fc);
	return pflOutput;
}

///////////////////////////////////////
//
// FuguForwardBackwardFloat
//
// Run a training pass of the floating point network
//
// Parameters:
//      pFugu:          [in] Fugu network
//      aflInput:       [in] Input image to train on 
//      iDesiredOutput: [in] The training output
//      pflPrevUpdate:  [in] Pointer to an array of previous weight updates
//                           for momentum, or NULL if there was no previous update.
//      flRate:         [in] Learning rate
//      flMomentum:     [in] Momentum
//
// Return values:
//      Returns NULL if there was an error.
//      Otherwise, if pflPrevUpdate was non-NULL, it is returned.  If
//      pflPrevUpdate was NULL, an array of updates is allocated and 
//      returned, and it should be passed in on the next call.
//
//////////////////////////////////////
float *FuguForwardBackwardFloat(
    FUGU_FLOAT_WEIGHTS *pFugu, 
    float aflInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT], 
	int iDesiredOutput,
    float *pflPrevUpdate,
    float flRate,
    float flMomentum)
{
	int i, j, ip, jp, a, b;

    // Activations of the hidden units after the first and second convolutional layers
    float *pflStates1 = (float *) ExternAlloc(sizeof(float) * FUGU_KERNELS1 * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1);
    float *pflStates2 = (float *) ExternAlloc(sizeof(float) * FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2);

    // Activations of the fully connected hidden layer
	float *pflStates_fc = (float *) ExternAlloc(sizeof(float) * pFugu->pArch->nHiddens);

    // Activations of the fully connected output layer (which will be returned)
    float *pflOutput = (float *) ExternAlloc(sizeof(float) * pFugu->pArch->nOutputs);

    // Delta values for the first and second convolutional layers
    float *pflStates1_delta = (float *) ExternAlloc(sizeof(float) * FUGU_KERNELS1 * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1);
    float *pflStates2_delta = (float *) ExternAlloc(sizeof(float) * FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2);

    // Delta values for the fully connected hidden layer
	float *pflStates_fc_delta = (float *) ExternAlloc(sizeof(float) * pFugu->pArch->nHiddens);
    
    // Pointer to the current weight
	float *pflWeight = pFugu->pflWeights;

    // Temporary pointer for weights in the current convolution kernel
    float *pflKernel;

    // Pointer to the update for the current weight
	float *pflUpdate;
    // Temporary pointer for updates in the current convolution kernel
    float *pflKernelUpdate;

    // Total number of weights in the network
	int nWeights = FuguNumberWeights(pFugu->pArch);
	
    // Pointer to the first weight in the second convolutional layer
	float *pflKernel2Weights;

    // Pointer to the first weight in the fully connected hidden layer
	float *pflHiddenWeights;

    // Pointer to the first weight in the output layer
	float *pflOutputWeights;

    // Pointer to states that are outputs for a layer of connections
    float *pflStateOut, *pflStateDeltaOut;

    // If the updates from the previous iteration were not passed in, 
    // then allocate space for them.
	if (pflPrevUpdate == NULL) 
    {
		pflPrevUpdate = (float *) ExternAlloc(sizeof(float) * nWeights);
		if (pflPrevUpdate == NULL) 
        {
            goto cleanup;
            return NULL;
        }
		// Zero out the weight updates
		for (i = 0; i < nWeights; i++) 
        {
            pflPrevUpdate[i] = 0;
        }
	}

	// Check memory allocation
    if (pflOutput == NULL || pflStates_fc == NULL || pflStates_fc_delta == NULL ||
        pflStates1 == NULL || pflStates1_delta == NULL ||
        pflStates2 == NULL || pflStates2_delta == NULL) 
    {
        ExternFree(pflPrevUpdate);
        pflPrevUpdate = NULL;
        goto cleanup;
    }

    // Zero out the deltas for each layer
    // (the deltas for the output layer are computed on 
    // the fly, so are not stored and do not need to be zeroed).
	for (b = 0; b < FUGU_KERNELS1 * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1; b++)
    {
        pflStates1_delta[b] = 0;
    }
	for (b = 0; b < FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2; b++)
    {
        pflStates2_delta[b] = 0;
    }
	for (i = 0; i < pFugu->pArch->nHiddens; i++) 
    {
        pflStates_fc_delta[i] = 0;
    }

	// Apply momentum scaling to the previous updates
	for (i = 0; i < nWeights; i++)
    {
        pflPrevUpdate[i] *= flMomentum;
    }

    // Forward pass for the first convolutional layer, for each kernel
    pflStateOut = pflStates1;
	for (b = 0; b < FUGU_KERNELS1; b++) 
    {
        // For each position of the kernel
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH1; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT1; jp++) 
            {
                // Total up the weighted sum for this location
				float flTotal = 0;
				pflKernel = pflWeight;
				for (i = 0; i < FUGU_KERNEL_WIDTH1; i++) 
                {
					for (j = 0; j < FUGU_KERNEL_HEIGHT1; j++) 
                    {
						flTotal += 
                            aflInput[i + ip * FUGU_KERNEL_SUBSAMPLE1][j + jp * FUGU_KERNEL_SUBSAMPLE1] * 
                            *(pflKernel++);
					}
				}
                // Add in the bias term
				flTotal += *(pflKernel++);
				*(pflStateOut++) = (float) tanh(flTotal);
			}
		}
        // Move on to the next kernel
		pflWeight = pflKernel;
	}

    // Store away the pointer to the first weight in the second convolutional layer
	pflKernel2Weights = pflWeight;

    // Forward pass for the second convolutional layer, for each kernel
    pflStateOut = pflStates2;
	for (b = 0; b < FUGU_KERNELS2; b++) 
    {
        // For each location of the kernel
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
            {
                // Add up the weighted sum for this location
				float flTotal = 0;
				pflKernel = pflWeight;
				for (a = 0; a < FUGU_KERNELS1; a++) 
                {
                    float *pflStateIn =
                        pflStates1 
                        + (a * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1)
                        + (ip * FUGU_KERNEL_SUBSAMPLE2 * FUGU_HIDDEN_HEIGHT1) 
                        + (jp * FUGU_KERNEL_SUBSAMPLE2);
					for (i = 0; i < FUGU_KERNEL_WIDTH2; i++) 
                    {
						for (j = 0; j < FUGU_KERNEL_HEIGHT2; j++) 
                        {
							flTotal += *(pflStateIn++) * *(pflKernel++);
						}
                        pflStateIn += FUGU_HIDDEN_HEIGHT1 - FUGU_KERNEL_HEIGHT2;
					}
				}
                // Add in the bias term
				flTotal += *(pflKernel++);
				*(pflStateOut++) = (float) tanh(flTotal);
			}
		}
        // Move on to the next kernel
		pflWeight = pflKernel;
	}

    // Store away a pointer to the first weight in the fully connected hidden layer
	pflHiddenWeights = pflWeight;

    // For each unit in the fully connected hidden layer
    pflStateOut = pflStates_fc;
	for (i = 0; i < pFugu->pArch->nHiddens; i++) 
    {
        // Add up the weighted sum for this unit
		float flTotal = 0;
        float *pflStateIn = pflStates2;
		for (b = 0; b < FUGU_KERNELS2; b++) 
        {
			for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
            {
				for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
                {
					flTotal += *(pflStateIn++) * *(pflWeight++);
				}
			}
		}
        // Add in the bias term
		flTotal += *(pflWeight++);
		*(pflStateOut++) = (float) tanh(flTotal);
	}

    // Store away a pointer to the first weight in the output layer
	pflOutputWeights = pflWeight;

    // For each unit in the output layer
    pflStateOut = pflOutput;
	for (i = 0; i < pFugu->pArch->nOutputs; i++) 
    {
        // Add up the weighted sum for this unit
		float flTotal = 0;
		for (j = 0; j < pFugu->pArch->nHiddens; j++) 
        {
			flTotal += pflStates_fc[j] * *(pflWeight++);
		}
        // Add in the bias term
		flTotal += *(pflWeight++);
		*(pflStateOut++) = Sigmoid(flTotal);
	}

    // Start at the output layer again
	pflWeight = pflOutputWeights;
    // Get a pointer to the update for the output connections
	pflUpdate = pflPrevUpdate + (pflWeight - pFugu->pflWeights);

    // Compute deltas and updates for the output layer
	for (i = 0; i < pFugu->pArch->nOutputs; i++) 
    {
        // First compute the delta for the output, which 
        // is the difference between the actual output and
        // the desired output.
		float flDelta;
		if (i == iDesiredOutput) 
        {
			flDelta = pflOutput[i] - 1;
		}
        else 
        {
			flDelta = pflOutput[i];
		}

        // The delta gets multiplied by the learning rate. 
        // In theory, the learning rate is multiplied by the 
        // weight updates, but this has the same effect because
        // the updates are a linear combination of the deltas.  
        // Also, this way is faster, because there are many 
        // fewer output units than weights.
		flDelta *= -flRate;

        // Normally we would now need to take into account
        // the derivative of the output unit's activation function.
        // However, we are using the cross entropy error metric 
        // with a sigmoid output unit, which cancel each other 
        // out, leaving the above delta as the correct one to use.
        
        // Propogate the delta back along each connection.
		for (j = 0; j < pFugu->pArch->nHiddens; j++) 
        {
			*(pflUpdate++) += pflStates_fc[j] * flDelta;
			pflStates_fc_delta[j] += *(pflWeight++) * flDelta;
		}

        // This is the update for the bias; the bias is simply
        // a connection with a constant input of 1, so this update
        // has the same form as the one in the loop above.
		*(pflUpdate++) += flDelta;
		pflWeight++;
	}

    // Select the weights and updates for the fully connected hidden layer
	pflWeight = pflHiddenWeights; 
	pflUpdate = pflPrevUpdate + (pflWeight - pFugu->pflWeights);

	// Compute deltas and updates for the fully-connected hidden layer
	for (i = 0; i < pFugu->pArch->nHiddens; i++) 
    {
        // First compute the delta, which will be the delta propogated from the
        // outputs, multiplied by the derivative of the tanh activation function
        // for this unit.
		float flDelta = pflStates_fc_delta[i] * (1 - pflStates_fc[i] * pflStates_fc[i]);

        // Propogate the delta back along all the connections
        float *pflStateIn = pflStates2;
        float *pflStateDeltaIn = pflStates2_delta;
		for (b = 0; b < FUGU_KERNELS2; b++) 
        {
			for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
            {
				for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
                {
					*(pflUpdate++) += *(pflStateIn++) * flDelta;
				    *(pflStateDeltaIn++) += *(pflWeight++) * flDelta;
				}
			}
		}
        // Also do the update for the 
		*(pflUpdate++) += flDelta;
		pflWeight++;
	}
	
    // Select the weights and updates for the second convolutional layer
	pflWeight = pflKernel2Weights;
	pflUpdate = pflPrevUpdate + (pflWeight - pFugu->pflWeights);

	// Compute the deltas and updates for the second convolution layer
    pflStateOut = pflStates2;
    pflStateDeltaOut = pflStates2_delta;
	for (b = 0; b < FUGU_KERNELS2; b++) 
    {
        // For each location at which the kernel is applied
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
            {
                // Compute the delta, taking into account the derivative of the
                // activation function for this unit.
				float flDelta = *(pflStateDeltaOut++) * (1 - *pflStateOut * *pflStateOut);
                pflStateOut++;

                // Use temporary pointers to the weights and updates for this kernel
				pflKernel = pflWeight;
				pflKernelUpdate = pflUpdate;

                // Now propogate the delta and updates for each connection.
                // Note that because this is a convolution kernel, we are
                // effectively sharing weights across multiple connections.
                // The outer loops over ip and jp cause multiple updates to
                // each weight.
				for (a = 0; a < FUGU_KERNELS1; a++) 
                {
                    float *pflStateIn =
                        pflStates1 
                        + (a * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1)
                        + (ip * FUGU_KERNEL_SUBSAMPLE2 * FUGU_HIDDEN_HEIGHT1) 
                        + (jp * FUGU_KERNEL_SUBSAMPLE2);
                    float *pflStateDeltaIn =
                        pflStates1_delta 
                        + (a * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1)
                        + (ip * FUGU_KERNEL_SUBSAMPLE2 * FUGU_HIDDEN_HEIGHT1) 
                        + (jp * FUGU_KERNEL_SUBSAMPLE2);
					for (i = 0; i < FUGU_KERNEL_WIDTH2; i++) 
                    {
						for (j = 0; j < FUGU_KERNEL_HEIGHT2; j++) 
                        {
							*(pflKernelUpdate++) += *(pflStateIn++) * flDelta;
							*(pflStateDeltaIn++) += *(pflKernel++) * flDelta;
						}
                        pflStateIn += FUGU_HIDDEN_HEIGHT1 - FUGU_KERNEL_HEIGHT2;
                        pflStateDeltaIn += FUGU_HIDDEN_HEIGHT1 - FUGU_KERNEL_HEIGHT2;
					}
				}
                // Also update the bias weight
				*(pflKernelUpdate++) += flDelta;
                pflKernel++;
			}
		}
        // Move on to the next kernel
		pflWeight = pflKernel;
		pflUpdate = pflKernelUpdate;
	}

    // Select the updates in the first convolutional layer
	pflUpdate = pflPrevUpdate;
    pflStateOut = pflStates1;
    pflStateDeltaOut = pflStates1_delta;
	// Compute the deltas and updates for the first convolution layer
	for (b = 0; b < FUGU_KERNELS1; b++) 
    {
        // For each location at which the kernel is applied
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH1; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT1; jp++) 
            {
                // Compute the delta for this unit taking into account
                // the derivative of its activation function
				float flDelta = *(pflStateDeltaOut++) * (1 - *pflStateOut * *pflStateOut);
                pflStateOut++;

                // Get a temporary pointer to the updates for this kernel
				pflKernelUpdate = pflUpdate;
				for (i = 0; i < FUGU_KERNEL_WIDTH1; i++) 
                {
					for (j = 0; j < FUGU_KERNEL_HEIGHT1; j++) 
                    {
						*(pflKernelUpdate++) += 
                            aflInput[i + ip * FUGU_KERNEL_SUBSAMPLE1][j + jp * FUGU_KERNEL_SUBSAMPLE1] * 
                            flDelta;
                    }
				}
                // The update for the bias weight
				*(pflKernelUpdate++) += flDelta;
			}
		}
        // Move on to the next kernel
		pflUpdate = pflKernelUpdate;
	}

	// Apply the accumulated weight updates to each weight
	for (i = 0; i < nWeights; i++) 
    {
		pFugu->pflWeights[i] += pflPrevUpdate[i];
    }

    // Clean up
cleanup:
	ExternFree(pflStates_fc_delta);
	ExternFree(pflStates_fc);
	ExternFree(pflOutput);
    ExternFree(pflStates1_delta);
    ExternFree(pflStates2_delta);
    ExternFree(pflStates1);
    ExternFree(pflStates2);

    // Return the update for use as momentum in the next iteration
	return pflPrevUpdate;
}

///////////////////////////////////////
//
// FuguSaveFloatWeights
//
// Write out a floating point weights database
//
// Parameters:
//      wszFileName: [in] File name to write to
//      pFugu:       [in] Pointer to Fugu data structure which is written
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguSaveFloatWeights(wchar_t *wszFileName, FUGU_FLOAT_WEIGHTS *pFugu)
{
	FILE *f = _wfopen(wszFileName, L"wb");
	if (f == NULL) return FALSE;
	if (fwrite(pFugu->pArch, sizeof(FUGU_ARCHITECTURE_HEADER), 1, f) < 1) 
    {
        return FALSE;
    }
	if (fwrite(pFugu->pflWeights, sizeof(FLOAT), FuguNumberWeights(pFugu->pArch), f) < (size_t) FuguNumberWeights(pFugu->pArch)) 
    {
        return FALSE;
    }
	if (fwrite(pFugu->pfdchMapping, sizeof(WCHAR), pFugu->pArch->nOutputs, f) < (size_t) pFugu->pArch->nOutputs) 
    {
        return FALSE;
    }
	if (fclose(f) < 0) 
    {
        return FALSE;
    }
	return TRUE;
}

///////////////////////////////////////
//
// FuguSaveIntegerWeights
//
// Write out an integer weights database
//
// Parameters:
//      wszFileName: [in] File name to write to
//      pFugu:       [in] Pointer to Fugu data structure which is written
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguSaveIntegerWeights(wchar_t *wszFileName, FUGU_INTEGER_WEIGHTS *pFugu)
{
	FILE *f = _wfopen(wszFileName, L"wb");
	if (f == NULL) return FALSE;
	if (fwrite(pFugu->pHeader, sizeof(FUGU_INTEGER_WEIGHTS_HEADER), 1, f) < 1)
    {
        return FALSE;
    }
	if (fwrite(pFugu->pfdchMapping, sizeof(WCHAR), pFugu->pHeader->arch.nOutputs, f) < (size_t) pFugu->pHeader->arch.nOutputs) 
    {
        return FALSE;
    }
	if (fwrite(pFugu->pbWeights, sizeof(BYTE), FuguNumberWeights(&pFugu->pHeader->arch), f) <
        (size_t) FuguNumberWeights(&pFugu->pHeader->arch)) 
    {
        return FALSE;
    }
	if (fclose(f) < 0) 
    {
        return FALSE;
    }
	return TRUE;
}

///////////////////////////////////////
//
// FuguLoadFloatWeights
//
// Read in a floating point weights database
//
// Parameters:
//      wszFileName: [in] File name to read from
//      pFugu:       [in] Pointer to structure which gets filled in
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadFloatWeights(wchar_t *wszFileName, FUGU_FLOAT_WEIGHTS *pFugu)
{
	struct _stat buf;
	BYTE *pbBuffer;
	FILE *f = _wfopen(wszFileName, L"rb");
	if (f == NULL) 
    {
        return FALSE;
    }
	if (_wstat(wszFileName, &buf) < 0) 
    {
        return FALSE;
    }
	pbBuffer = (unsigned char *) ExternAlloc(buf.st_size);
	if (pbBuffer == NULL || fread(pbBuffer, buf.st_size, 1, f) < 1) 
    {
        return FALSE;
    }
	fclose(f);
	pFugu->pArch = (FUGU_ARCHITECTURE_HEADER *) pbBuffer;
	pFugu->pflWeights = (FLOAT *) (pbBuffer + sizeof(FUGU_ARCHITECTURE_HEADER));
	pFugu->pfdchMapping = (WCHAR *) (pbBuffer + sizeof(FUGU_ARCHITECTURE_HEADER) + 
		sizeof(FLOAT) * FuguNumberWeights(pFugu->pArch));
	return TRUE;
}

///////////////////////////////////////
//
// FuguSaveBitmap
//
// Write out an image to a .bmp file, for debugging
//
// Parameters:
//      wszFileName: [in] File to write to
//      pBitmap:     [in] Pointer to the bitmap header structure
//      pvBitBuf:    [in] Pointer to the actual bits
//
// Return values:
//
//////////////////////////////////////
void FuguSaveBitmap(wchar_t *wszFileName, BITMAPINFOHEADER *pBitmap, void *pvBitBuf)
{
	DWORD err;
	BOOL ret;
 
    BITMAPFILEHEADER hdr;       // bitmap file-header 
    DWORD dwTotal;              // total count of bytes 
    DWORD cb;                   // incremental count of bytes 
    DWORD dwTmp; 

	// Create the .BMP file. 
    HANDLE hf = CreateFile(
					wszFileName,
					GENERIC_READ | GENERIC_WRITE, 
					(DWORD) 0, 
					NULL, 
					CREATE_ALWAYS, 
					FILE_ATTRIBUTE_NORMAL, 
					(HANDLE) NULL); 
    if (hf == INVALID_HANDLE_VALUE) 
	{
		err = GetLastError(); 
		ASSERT(FALSE);
	}
    hdr.bfType = 0x4d42;        // 0x42 = "B" 0x4d = "M" 
    // Compute the size of the entire file. 
    hdr.bfSize = (DWORD) ( sizeof(BITMAPFILEHEADER) + 
                 pBitmap->biSize + 
				 2 /* hack; pbih->biClrUsed*/ * sizeof(RGBQUAD) + 
				 pBitmap->biSizeImage ); 
    hdr.bfReserved1 = 0; 
    hdr.bfReserved2 = 0; 

    // Compute the offset to the array of color indices. 
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + 
                    pBitmap->biSize + 
					2 /* hack; pbih->biClrUsed*/ * sizeof (RGBQUAD); 

    // Copy the BITMAPFILEHEADER into the .BMP file. 
    if (!WriteFile(hf, (LPVOID) &hdr, sizeof(BITMAPFILEHEADER), 
        (LPDWORD) &dwTmp,  NULL)) 
    {
		err = GetLastError(); 
		ASSERT(FALSE);
    }

    // Copy the BITMAPINFOHEADER and RGBQUAD array into the file. 
    ret = WriteFile(
				hf, 
				(LPVOID) pBitmap, 
				sizeof(BITMAPINFOHEADER) 
                  + 2 /* hack; pbih->biClrUsed*/ * sizeof (RGBQUAD), 
				(LPDWORD) &dwTmp, 
				NULL
				);
	if( !ret )
	{
		err = GetLastError(); 
		ASSERT(FALSE);
	}

    // Copy the array of color indices into the .BMP file. 
    dwTotal = cb = pBitmap->biSizeImage; 
    ret = WriteFile(
				hf, 
				(LPSTR) pvBitBuf, 
				(int) cb, 
				(LPDWORD) &dwTmp,
				NULL
				); 
	if( !ret )
	{
		err = GetLastError(); 
		ASSERT(FALSE);
	}

    // Close the .BMP file. 
	CloseHandle(hf); 
}

///////////////////////////////////////
//
// FuguSaveNetworkInput
//
// Write out the network's input image to a .pgm file, for debugging
//
// Parameters:
//      wszFileName: [in] File to write to
//      aiInput:     [in] Image to write out, in fixed point format
//
// Return values:
//
//////////////////////////////////////
void FuguSaveNetworkInput(wchar_t *wszFileName, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT])
{
    int i, j;
    FILE *f = _wfopen(wszFileName, L"wb");
    fprintf(f, "P5\n%d %d\n255\n", FUGU_INPUT_WIDTH, FUGU_INPUT_HEIGHT);
    for (i = 0; i < FUGU_INPUT_WIDTH; i++) 
        for (j = 0; j < FUGU_INPUT_HEIGHT; j++) {
            BYTE b = (BYTE) ((aiInput[i][j] * 255) / FUGU_ACTIVATION_SCALE);
            fwrite(&b, sizeof(b), 1, f);
        }
    fclose(f);
}

///////////////////////////////////////
//
// ApplyFuguFloat
//
// Apply the floating point version of the Fugu net (for testing)
// The weights are loaded from the specified file.
//
// Parameters:
//      wszFileName: [in] File name to read the database from
//      aiInput:     [in] Input image to process, in fixed point format
//
// Return values:
//      An array of output activations in fixed point format, or NULL on error
//
//////////////////////////////////////
int *ApplyFuguFloat(wchar_t *wszFileName, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT])
{
	int x, y, i;
	float aflInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT];
	float *pflOutput;
	FUGU_FLOAT_WEIGHTS fugu;
	int *piOutput;

	// Scale the input image to the range 0 to 1
	for (x = 0; x < FUGU_INPUT_WIDTH; x++)
		for (y = 0; y < FUGU_INPUT_HEIGHT; y++) 
			aflInput[x][y] = aiInput[x][y] / (float)FUGU_ACTIVATION_SCALE;

	// Load the floating point network
	FuguLoadFloatWeights(wszFileName, &fugu);

	// Try quantizing the weights
	for (i = 0; i < FuguNumberWeights(fugu.pArch); i++) {
		fugu.pflWeights[i] = (float) (floor(fugu.pflWeights[i] * 16.0 + 0.5) / 16.0);
	}

	// Apply the network
	pflOutput = FuguForwardPassFloat(&fugu, aflInput);

	// Copy the results out
	piOutput = (int *) ExternAlloc(sizeof(int) * fugu.pArch->nOutputs);
	for (i = 0; i < fugu.pArch->nOutputs; i++) 
		piOutput[i] = (int)(FUGU_ACTIVATION_SCALE * pflOutput[i]);
	ExternFree(pflOutput);

	// Free up the network by calling free on the header, which comes first.
	ExternFree(fugu.pArch);

	return piOutput;
}

// Update the score of the given character in the alternate list, and keep track of the highest
// scoring character so far.
static void AddChar(wchar_t *pwchTop1, float *pflTop1, ALT_LIST *pAltList, wchar_t dch, float flProb,
                    LOCRUN_INFO *pLocRunInfo, CHARSET *pCS)
{
    int j;
	// Only update the score if this is an allowed result
    if (!IsAllowedChar(pLocRunInfo, pCS, dch))
    {
        return;
    }
	// Search the alternate list for the character, and update the score.
    for (j = 0; j < (int) pAltList->cAlt; j++) 
    {
        if (pAltList->awchList[j] == dch)
        {
            pAltList->aeScore[j] = flProb;
			break;
        }
    }
    if (flProb > 0)
    {
		// Check whether the character (or folding set) passes the filter, 
		// if so see if it is the new top 1.
        if (*pwchTop1 == 0xFFFE || flProb > *pflTop1) 
        {
            *pflTop1 = flProb;
            *pwchTop1 = dch;
        }
    }
}

///////////////////////////////////////
//
// FuguMatchRescore
//
// Invoke Fugu on a character.  Returns the top 1 result, and
// also rewrites the scores for the topN alternates returned by 
// another recognizer (say Otter).
//
// Parameters:
//      pFugu:       [in]  Fugu database to use
//      pwchTop1:    [out] Top one result
//      pflTop1:     [out] Top one score
//      pAltList:    [in/out] Alt list to rewrite the scores of
//      cAlt:        [in]  The maximum number of alternates to return
//      pGlyph:      [in]  The ink to recognize
//      pGuide:      [in]  Guide to scale ink to, or NULL to use the ink bounds
//      pCharSet:    [in]  Filter for the characters to be returned
//      pLocRunInfo: [in]  Pointer to the locale database
//
// Return values:
//      Returned the number of items in the alt list, or -1 if there is an error
//
//////////////////////////////////////
int FuguMatchRescore(
              FUGU_INTEGER_WEIGHTS *pFugu,  // Fugu recognizer
              wchar_t *pwchTop1,            // Top one result
              float *pflTop1,               // Top one score
              ALT_LIST *pAltList,			// Alt list where the results are returned
			  int cAlt,						// Maximum number of results requested
			  GLYPH *pGlyph,				// Pointer to the strokes
              RECT *pGuide,                 // Guide to scale ink to
			  CHARSET *pCharSet,			// Filters to apply to the results
			  LOCRUN_INFO *pLocRunInfo) 	// Locale database
{
	int i, j;
	int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT];
	int *piOutput;
    BOOL fFirst = TRUE;

    // No answer for the top 1
    *pflTop1 = 0;
    *pwchTop1 = 0xFFFE;

	// First convert the ink to 29x29 input region
	if (!FuguRender(pGlyph, pGuide, aiInput)) 
    {
		return -1;
    }

	// Apply the recognizer
//	piOutput = ApplyFuguFloat(aiInput);
	piOutput = ApplyFuguInteger(pFugu, aiInput);
	if (piOutput == NULL)
    {
		return -1;
    }

    // First set all the scores to zero.  This is because some code points Otter
    // supports may not be supported by Fugu.  This implicitly says Fugu gives
    // them a score of zero.
    for (j = 0; j < (int) pAltList->cAlt; j++) 
    {
        pAltList->aeScore[j] = 0;
    }

	// This is the version for Fugu trained on dense codes, which will usually be
	// what we use.  Loops over the outputs
	for (i = 0; i < pFugu->pHeader->arch.nOutputs; i++) 
    {
		wchar_t fdch = pFugu->pfdchMapping[i];
        float flProb = ((float) piOutput[i]) / FUGU_ACTIVATION_SCALE;
#if 0
        AddChar(pwchTop1, pflTop1, pAltList, fdch, flProb, pLocRunInfo, pCharSet);
#else
        if (LocRunIsFoldedCode(pLocRunInfo, fdch))
        {
			// If it is a folded code, look up the folding set
			wchar_t *pFoldingSet = LocRunFolded2FoldingSet(pLocRunInfo, fdch);

			// Run through the folding set, adding non-NUL items to the output list
			for (j = 0; j < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[j] != 0; j++)
            {
                AddChar(pwchTop1, pflTop1, pAltList, pFoldingSet[j], flProb, pLocRunInfo, pCharSet);
			}
        }
        else
        {
            AddChar(pwchTop1, pflTop1, pAltList, fdch, flProb, pLocRunInfo, pCharSet);
        }
#endif
	}

	// Clean up and return
	ExternFree(piOutput);
	return pAltList->cAlt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\factoid\src\strtable.c ===
// strtable.c
// Angshuman Guha
// aguha
// Dec 1, 2000

/*
These are a bunch of functions for saving and accessing unique strings.
*/

#include <stdio.h>
#include <string.h>
#include <common.h>
#include "strtable.h"
#include "regexp.h"

/******************************Private*Routine******************************\
* MakeStringNode
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
STRINGNODE *MakeStringNode(void)
{
	STRINGNODE *node = (STRINGNODE *) ExternAlloc(sizeof(STRINGNODE));
	if (!node)
	{
		SetErrorMsgSD("Malloc failure %d", sizeof(STRINGNODE));
		return NULL;
	}

	node->left = node->right = NULL;
	node->wsz = NULL;
	node->value = -1;
	return node;
}

/******************************Public*Routine******************************\
* InsertSymbol
*
* Insert a new symbol into a table.  The table is really a binary tree.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int InsertSymbol(WCHAR *wszSrc, int length, STRINGTABLE *strtable)
{
	WCHAR *wsz;
	STRINGNODE *node = strtable->root;

	wsz = (WCHAR *) ExternAlloc((length+1)*sizeof(WCHAR));
	wcsncpy(wsz, wszSrc, length);
	wsz[length] = L'\0';

	while (node)
	{
		int n;

		n = wcscmp(node->wsz, wsz);
		if (n == 0)
			break;
		if (n < 0)
		{
			if (node->left)
				node = node->left;
			else
			{
				node->left = MakeStringNode();
				if (!node->left)
					return -1;
				node = node->left;
				break;
			}
		}
		else 
		{
			if (node->right)
				node = node->right;
			else
			{
				node->right = MakeStringNode();
				if (!node->right)
					return -1;
				node = node->right;
				break;
			}
		}
	}

	if (!node)
	{
		node = MakeStringNode();
		if (!node)
			return -1;
	}

	if (node->value < 0)
	{
		node->wsz = wsz;
		node->value = strtable->count++;
		if (!strtable->root)
			strtable->root = node;
	}
	else
	{
		ASSERT(!wcscmp(node->wsz, wsz));
		ExternFree(wsz);
	}

	return node->value;
}

/******************************Private*Routine******************************\
* FillFlatTable
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void FillFlatTable(STRINGNODE *node, WCHAR **awszName)
{
	if (!node)
		return;
	awszName[node->value] = node->wsz;
	FillFlatTable(node->left, awszName);
	FillFlatTable(node->right, awszName);
}

/******************************Public*Routine******************************\
* FlattenSymbolTable
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
WCHAR **FlattenSymbolTable(STRINGTABLE *strtable)
{
	WCHAR **awszName = (WCHAR **) ExternAlloc(strtable->count * sizeof(WCHAR *));

	if (!awszName)
		return NULL;

	FillFlatTable(strtable->root, awszName);
	return awszName;
}

/******************************Public*Routine******************************\
* DestroySymbolTable
*
* Note that the wsz field of STRINGNODE is not free'd.
*
* History:
*  19-Jan-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroySymbolTable(STRINGNODE *root, BOOL bStringsToo)
{
	if (!root)
		return;
	DestroySymbolTable(root->left, bStringsToo);
	DestroySymbolTable(root->right, bStringsToo);
	if (bStringsToo)
		ExternFree(root->wsz);
	ExternFree(root);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\inc\fugu.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      fugu.h
//
// Description:
//      Declarations for the Fugu recognizer
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#pragma once
#include <limits.h>
#include "common.h"

// How many strokes Fugu processes
#define	FUGU_MIN_STROKES		1
#define	FUGU_MAX_STROKES		2

// How wide the pen is when rendering the characters to a bitmap
#define FUGU_PEN_WIDTH 5

// Dimensions of the input
#define FUGU_INPUT_WIDTH 29
#define FUGU_INPUT_HEIGHT 29

// Dimensions of the first layer of convolution kernels
#define FUGU_KERNEL_WIDTH1 5
#define FUGU_KERNEL_HEIGHT1 5
#define FUGU_KERNELS1 5
#define FUGU_KERNEL_SUBSAMPLE1 2

// Dimensions of the image after the first convolutional layer
#define FUGU_HIDDEN_WIDTH1 13
#define FUGU_HIDDEN_HEIGHT1 13

// Dimensions of the second layer of convolution kernels
#define FUGU_KERNEL_WIDTH2 5
#define FUGU_KERNEL_HEIGHT2 5
#define FUGU_KERNELS2 50
#define FUGU_KERNEL_SUBSAMPLE2 2

// Dimensions of the image after the second convolutional layer
#define FUGU_HIDDEN_WIDTH2 5
#define FUGU_HIDDEN_HEIGHT2 5

// For the fixed point math used at runtime, this specifies how much
// the activation values are shifted to the left.
#define FUGU_ACTIVATION_SHIFT 11

// Similarly, this is the multiplicative factor
#define FUGU_ACTIVATION_SCALE (1 << FUGU_ACTIVATION_SHIFT)

// Given the scaling of the activations above, this is the largest number
// which can be multiplied by an activation (between -1 and 1) and still
// have the result fit in a 32 bit signed integer.
#define FUGU_WEIGHT_SCALE (INT_MAX >> FUGU_ACTIVATION_SHIFT)

// The structure is used to specify the architecture of the Fugu network.
// Currently it only has the number of fully connected hidden and output
// nodes, but it may eventually be generalized.
typedef struct FUGU_ARCHITECTURE_HEADER 
{
    INT nHiddens;						// Number of hidden units
	INT nOutputs;						// Number of output units
} FUGU_ARCHITECTURE_HEADER;

// The integer version of the fugu database requires some extra fields.
typedef struct FUGU_INTEGER_WEIGHTS_HEADER 
{
    FUGU_ARCHITECTURE_HEADER	arch;				    // Architecture
	INT							iScale;				    // Scale factor applied to weights to make them be integers
	INT 						aiWeightLookup[256];    // Lookup table to map bytes to weights
} FUGU_INTEGER_WEIGHTS_HEADER;

// This structure represents the fugu database
typedef struct FUGU_INTEGER_WEIGHTS 
{
	FUGU_INTEGER_WEIGHTS_HEADER *pHeader;		// Pointer to the above header
	WCHAR						*pfdchMapping;	// Pointer to the mapping from outputs to code points
	BYTE						*pbWeights;		// Pointer to the weights
} FUGU_INTEGER_WEIGHTS;

// This structure is used to represent a fugu databased mapped from a file or resource.
typedef struct FUGU_LOAD_INFO
{
    FUGU_INTEGER_WEIGHTS fugu;
    LOAD_INFO info;
} FUGU_LOAD_INFO;

// Magic key the identifies the fugu NN bin file
#define	FUGU_FILE_TYPE				0xF040F040

// Version information for file.
#define	FUGU_MIN_FILE_VERSION		0		// First version of code that can read this file
#define	FUGU_OLD_FILE_VERSION		0		// Oldest file version this code can read.
#define FUGU_CUR_FILE_VERSION		0		// Current version of code.

// Magic key the identifies the fugu NN bin file
#define	CHARDET_FILE_TYPE			0xC3A8DE7C

// Version information for file.
#define	CHARDET_MIN_FILE_VERSION	0		// First version of code that can read this file
#define	CHARDET_OLD_FILE_VERSION	0		// Oldest file version this code can read.
#define CHARDET_CUR_FILE_VERSION	0		// Current version of code.

///////////////////////////////////////
//
// FuguNumberWeights
//
// Calculate the number of weights in a Fugu net given its architecture
//
// Parameters:
//      pArch: [in] Pointer to the architecture description header
//
// Return values:
//      Number of weights in the Fugu network
//
//////////////////////////////////////
int FuguNumberWeights(FUGU_ARCHITECTURE_HEADER *pArch);

///////////////////////////////////////
//
// FuguRender
//
// Renders a glyph to an image, each pixel has a value from 0 to FUGU_ACTIVATION_SCALE
//
// Parameters:
//      pGlyph:  [in]  Pointer to the ink to render
//      pGuide:  [in]  Guide to scale ink to, or NULL to use the ink bounds
//      aiInput: [out] Array that will be used as input to Fugu
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguRender(GLYPH *pGlyph, RECT *pGuide, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT]);

///////////////////////////////////////
//
// ApplyFuguInteger
//
// Apply the integer version of the Fugu network to an input image (fixed point format),
// and return an array of outputs (also in fixed point).  Return NULL if there is an
// error in allocating memory for the output.
//
// Parameters:
//      pFugu:   [in] Pointer to the fugu database to use
//      aiInput: [in] Input image to process, in fixed point format
//
// Return values:
//      An array of output activations in fixed point format, or NULL on error
//
//////////////////////////////////////
int *ApplyFuguInteger(FUGU_INTEGER_WEIGHTS *pFugu, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT]);

///////////////////////////////////////
//
// FuguLoadPointer
//
// Set up the Fugu database using a pointer to the data itself
//
// Parameters:
//      pInfo: [in]     Structure with mapping information.
//             [out]    Returns with the pointers to the fugu database set
//      pLocRunInfo: [in] Locale database to check header on file
//		iSize: [in]		Size of database in bytes
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadPointer(FUGU_LOAD_INFO *pInfo, LOCRUN_INFO *pLocRunInfo, int iSize);

///////////////////////////////////////
//
// FuguLoadRes
//
// Load an integer Fugu database from a resource
//
// Parameters:
//      pInfo:      [out] Structure where information for unloading is stored
//      hInst:      [in] Handle to the DLL containing the recognizer
//      iResNumber: [in] Number of the resource (ex RESID_FUGU)
//      iResType:   [in] Number of the recognizer (ex VOLCANO_RES)
//      pLocRunInfo: [in] Locale database to check header on file
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadRes(FUGU_LOAD_INFO *pFugu, HINSTANCE hInst, int iResNumber, int iResType, LOCRUN_INFO *pLocRunInfo);

///////////////////////////////////////
//
// FuguLoadFile
//
// Load an integer Fugu database from a file
//
// Parameters:
//      pInfo:   [out] Structure where information for unloading is stored
//      wszPath: [in]  Path to load the database from
//      pLocRunInfo: [in] Locale database to check header on file
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadFile(FUGU_LOAD_INFO *pInfo, wchar_t *wszPath, LOCRUN_INFO *pLocRunInfo);

///////////////////////////////////////
//
// FuguUnLoadFile
//
// Unload a Fugu database loaded from a file
//
// Parameters:
//      pInfo: [in] Load information for unloading
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguUnLoadFile(FUGU_LOAD_INFO *pInfo);

///////////////////////////////////////
//
// FuguMatch
//
// Invoke Fugu on a character
//
// Parameters:
//      pFugu:       [in]  Fugu database to use
//      pAltList:    [out] Alt list
//      cAlt:        [in]  The maximum number of alternates to return
//      pGlyph:      [in]  The ink to recognize
//      pGuide:      [in]  Guide to scale ink to, or NULL to use the ink bounds
//      pCharSet:    [in]  Filter for the characters to be returned
//      pLocRunInfo: [in]  Pointer to the locale database
//
// Return values:
//      Returned the number of items in the alt list, or -1 if there is an error
//
//////////////////////////////////////
int FuguMatch(FUGU_INTEGER_WEIGHTS *pFugu,  // Fugu database
              ALT_LIST *pAltList,			// Alt list where the results are returned
			  int cAlt,						// Maximum number of results requested
			  GLYPH *pGlyph,				// Pointer to the strokes
              RECT *pGuide,                 // Guide to scale ink to
			  CHARSET *pCharSet,			// Filters to apply to the results
			  LOCRUN_INFO *pLocRunInfo);	// Locale database

///////////////////////////////////////
//
// FuguMatchRescore
//
// Invoke Fugu on a character.  Returns the top 1 result, and
// also rewrites the scores for the topN alternates returned by 
// another recognizer (say Otter).
//
// Parameters:
//      pFugu:       [in]  Fugu database to use
//      pwchTop1:    [out] Top one result
//      pflTop1:     [out] Top one score
//      pAltList:    [in/out] Alt list to rewrite the scores of
//      cAlt:        [in]  The maximum number of alternates to return
//      pGlyph:      [in]  The ink to recognize
//      pGuide:      [in]  Guide to scale ink to, or NULL to use the ink bounds
//      pCharSet:    [in]  Filter for the characters to be returned
//      pLocRunInfo: [in]  Pointer to the locale database
//
// Return values:
//      Returned the number of items in the alt list, or -1 if there is an error
//
//////////////////////////////////////
int FuguMatchRescore(
              FUGU_INTEGER_WEIGHTS *pFugu,  // Fugu recognizer
              wchar_t *pwchTop1,            // Top one result
              float *pflTop1,               // Top one score
              ALT_LIST *pAltList,			// Alt list where the results are returned
			  int cAlt,						// Maximum number of results requested
			  GLYPH *pGlyph,				// Pointer to the strokes
              RECT *pGuide,                 // Guide to scale ink to
			  CHARSET *pCharSet,			// Filters to apply to the results
			  LOCRUN_INFO *pLocRunInfo);	// Locale database

// The following declarations are used at training time
#ifndef HWX_PRODUCT

// An entry in the index file used during training
typedef struct FUGU_INDEX 
{
	SHORT fdch;						// Folded dense code
	USHORT usFile;					// The file number which this sample is in
	union 
    {
		UINT uiOffset;				// Offset of stroke data in file.
		BYTE *pbData;				// The offset gets converted to a pointer to the
									// stroke data in the training program
	};
} FUGU_INDEX;

// Data structure to access floating point weight database
typedef struct FUGU_FLOAT_WEIGHTS {
    FUGU_ARCHITECTURE_HEADER *pArch;	// Pointer to the architecture description
	WCHAR *pfdchMapping;				// Pointer to the mapping from outputs to folded dense codes
	FLOAT *pflWeights;					// Pointer to the array of weights
} FUGU_FLOAT_WEIGHTS;

///////////////////////////////////////
//
// FuguForwardPassFloat
//
// Run a forward pass of the floating point network
//
// Parameters:
//      pFugu:    [in] Fugu network
//      aflInput: [in] Input image to work from
//
// Return values:
//      Array of output activations, or NULL if an error occurs
//
//////////////////////////////////////
float *FuguForwardPassFloat(
    FUGU_FLOAT_WEIGHTS *pFugu,
    float aflInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT]);

///////////////////////////////////////
//
// FuguForwardBackwardFloat
//
// Run a training pass of the floating point network
//
// Parameters:
//      pFugu:          [in/out] Fugu network, which is updated for this sample
//      aflInput:       [in] Input image to train on 
//      iDesiredOutput: [in] The training output
//      pflPrevUpdate:  [in] Pointer to an array of previous weight updates
//                           for momentum, or NULL if there was no previous update.
//      flRate:         [in] Learning rate
//      flMomentum:     [in] Momentum
//
// Return values:
//      Returns NULL if there was an error.
//      Otherwise, if pflPrevUpdate was non-NULL, it is returned with the
//      updates for this sample.  If
//      pflPrevUpdate was NULL, an array of updates is allocated and 
//      returned, and it should be passed in on the next call.
//
//////////////////////////////////////
float *FuguForwardBackwardFloat(
    FUGU_FLOAT_WEIGHTS *pFugu, 
    float aflInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT], 
	int iDesiredOutput,
    float *pflPrevUpdate,
    float flRate,
    float flMomentum);

///////////////////////////////////////
//
// FuguSaveIntegerWeights
//
// Write out an integer weights database
//
// Parameters:
//      wszFileName: [in] File name to write to
//      pFugu:       [in] Pointer to Fugu data structure which is written
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguSaveIntegerWeights(wchar_t *wszFileName, FUGU_INTEGER_WEIGHTS *pFugu);

///////////////////////////////////////
//
// FuguSaveFloatWeights
//
// Write out a floating point weights database
//
// Parameters:
//      wszFileName: [in] File name to write to
//      pFugu:       [in] Pointer to Fugu data structure which is written
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguSaveFloatWeights(wchar_t *wszFileName, FUGU_FLOAT_WEIGHTS *pFugu);

///////////////////////////////////////
//
// FuguLoadFloatWeights
//
// Read in a floating point weights database
//
// Parameters:
//      wszFileName: [in] File name to read from
//      pFugu:       [in] Pointer to structure which gets filled in
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadFloatWeights(wchar_t *wszFileName, FUGU_FLOAT_WEIGHTS *pFugu);

///////////////////////////////////////
//
// FuguSaveBitmap
//
// Write out an image to a .bmp file, for debugging
//
// Parameters:
//      wszFileName: [in] File to write to
//      pBitmap:     [in] Pointer to the bitmap header structure
//      pvBitBuf:    [in] Pointer to the actual bits
//
// Return values:
//
//////////////////////////////////////
void FuguSaveBitmap(wchar_t *wszFileName, BITMAPINFOHEADER *pBitmap, void *pvBitBuf);

///////////////////////////////////////
//
// FuguSaveNetworkInput
//
// Write out the network's input image to a .pgm file, for debugging
//
// Parameters:
//      wszFileName: [in] File to write to
//      aiInput:     [in] Image to write out, in fixed point format
//
// Return values:
//
//////////////////////////////////////
void FuguSaveNetworkInput(wchar_t *wszFileName, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT]);

///////////////////////////////////////
//
// FuguScaleGlyph
//
// Scales the coordinate values in the glyph to fit in a 256x256 range.
//
// Parameters:
//      pGlyph: [in]  Ink to be scaled 
//              [out] Scaled version of Ink
//      pGuide:  [in]  Guide to scale ink to, or NULL to use the ink bounds
//
// Return values:
//
//////////////////////////////////////
void FuguScaleGlyph(GLYPH *pGlyph, RECT *pGuide);

///////////////////////////////////////
//
// FuguRenderNoScale
//
// Renders a glyph to an image, each pixel has a value from 0 to FUGU_ACTIVATION_SCALE.
// Unlike FuguRender, this function does not scale the ink to the image, but rather
// assumes the ink is already in scaled form as produced by FuguScaleGlyph().
//
// Parameters:
//      pGlyph:  [in]  Pointer to the ink to render
//      aiInput: [out] Array that will be used as input to Fugu
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguRenderNoScale(GLYPH *pGlyph, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT]);

// This was the structure used to read the weights from Dave's trainer
/*
typedef struct tagFuguFloatWeights {
	float _weights1[FuguKernels1][FuguKernelWidth1][FuguKernelHeight1];
	float _tweights1[FuguKernels1];
	float _weights2[FuguKernels2][FuguKernels1][FuguKernelWidth2][FuguKernelHeight2];
	float _tweights2[FuguKernels2];
	float _weights_fc[200][FuguKernels2][FuguHiddenWidth2][FuguHiddenHeight2];
	float _tweights_fc[200];
	float _weights_out[462][200];
	float _tweights_out[462];
	wchar_t mapping[462];
} FuguFloatWeights;
*/

#endif // !defined(HWX_PRODUCT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\minifugu.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      minifugu.c
//
// Description:
//      Fugu runtime code
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include "common.h"
#include "score.h"
#include "glyph.h"
#include "sigmoid.h"
#include "fugu.h"
#include "nnet.h"

// validates the header of the fugu net
BOOL CheckFuguNetHeader(void *pData, LOCRUN_INFO *pLocRunInfo, int iSize)
{
	NNET_HEADER		*pHeader	=	(NNET_HEADER *)pData;

	// Make sure there is enough space for the header
	if (sizeof(NNET_HEADER) > iSize) 
	{
		return FALSE;
	}

	// wrong magic number
	ASSERT (pHeader->dwFileType == FUGU_FILE_TYPE);
	if (pHeader->dwFileType != FUGU_FILE_TYPE)
	{
		return FALSE;
	}

	// check version
	ASSERT(pHeader->iFileVer >= FUGU_OLD_FILE_VERSION);
    ASSERT(pHeader->iMinCodeVer <= FUGU_CUR_FILE_VERSION);

	// Check that it matches the locale database
	ASSERT	(	!memcmp (	pHeader->adwSignature, 
							pLocRunInfo->adwSignature, 
							sizeof (pHeader->adwSignature)
						)
			);

	// Make sure there's only one net in the file
	ASSERT (pHeader->cSpace == 1);

    if	(	pHeader->iFileVer >= FUGU_OLD_FILE_VERSION &&
			pHeader->iMinCodeVer <= FUGU_CUR_FILE_VERSION &&
			!memcmp (	pHeader->adwSignature, 
						pLocRunInfo->adwSignature, 
						sizeof (pHeader->adwSignature)
					) &&
			pHeader->cSpace == 1
		)
    {
        return TRUE;
    }
	else
	{
		return FALSE;
	}
}

///////////////////////////////////////
//
// FuguNumberWeights
//
// Calculate the number of weights in a Fugu net given its architecture
//
// Parameters:
//      pArch: [in] Pointer to the architecture description header
//
// Return values:
//      Number of weights in the Fugu network
//
//////////////////////////////////////
int FuguNumberWeights(FUGU_ARCHITECTURE_HEADER *pHeader)
{
	return 
		// The first convolutional layer
		FUGU_KERNELS1 * (FUGU_KERNEL_WIDTH1 * FUGU_KERNEL_HEIGHT1 + 1) +
		// Second convolutional layer
		FUGU_KERNELS2 * (FUGU_KERNELS1 * FUGU_KERNEL_WIDTH2 * FUGU_KERNEL_HEIGHT2 + 1) +
		// First fully connected hidden layer
		(FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2 + 1) * pHeader->nHiddens +
		// Second fully connected hidden layer
		(pHeader->nHiddens + 1) * pHeader->nOutputs;
}

///////////////////////////////////////
//
// FuguLoadPointer
//
// Set up the Fugu database using a pointer to the data itself
//
// Parameters:
//      pInfo: [in]     Structure with mapping information.
//             [out]    Returns with the pointers to the fugu database set
//      pLocRunInfo: [in] Locale database to check header on file
//		iSize: [in]		Size of database in bytes
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadPointer(FUGU_LOAD_INFO *pInfo, LOCRUN_INFO *pLocRunInfo, int iSize)
{
	BYTE				*pb = pInfo->info.pbMapping;
	NNET_SPACE_HEADER	*pSpaceHeader;

	// check the header
	if (!CheckFuguNetHeader(pb, pLocRunInfo, iSize))
	{
		return FALSE;
	}

	// point to the one and only space that we have
	pSpaceHeader	=	(NNET_SPACE_HEADER *)(pb + sizeof (NNET_HEADER));

	// Make sure there is space for the Fugu header
	if (pSpaceHeader->iDataOffset + sizeof(FUGU_INTEGER_WEIGHTS_HEADER) > (unsigned int) iSize) 
	{
		return FALSE;
	}
	pb					+=	pSpaceHeader->iDataOffset;
	pInfo->fugu.pHeader = (FUGU_INTEGER_WEIGHTS_HEADER *) pb;

	// Make sure the Fugu header is valid
	if (pInfo->fugu.pHeader->iScale == 0)
	{
		return FALSE;
	}

	// Make sure there is space for the mapping table and weights
	if (pSpaceHeader->iDataOffset + 
		sizeof(FUGU_INTEGER_WEIGHTS_HEADER) +
		sizeof(WCHAR) * pInfo->fugu.pHeader->arch.nOutputs +
		sizeof(unsigned char) * FuguNumberWeights(&pInfo->fugu.pHeader->arch) > 
			(unsigned int) iSize)
	{
		return FALSE;
	}

	pInfo->fugu.pfdchMapping = (WCHAR *) (pb + sizeof(FUGU_INTEGER_WEIGHTS_HEADER));
	pInfo->fugu.pbWeights = pb + sizeof(FUGU_INTEGER_WEIGHTS_HEADER) + 
		sizeof(WCHAR) * pInfo->fugu.pHeader->arch.nOutputs;
	return TRUE;
}

///////////////////////////////////////
//
// IntegerSigmoid
//
// Compute sigmoid (1 / (1 + exp(-x))), in which the inputs and outputs are 
// both the actual values scaled by FuguActivationScale.
//
// Parameters:
//      iAct: [in] Activation in fixed point format
//
// Return values:
//      Output activation, also in fixed point format.
//
//////////////////////////////////////
int IntegerSigmoid(int iAct)
{
	int iIndex, iBase, iDelta;

    // Negative activations are handled by mapping to positive values
	if (iAct < 0) 
    {
		iAct = -iAct;
		iIndex = iAct >> SIGMOID_SHIFT;

		// Large negative activations result in an output of 0
		if (iIndex >= SIGMOID_RANGE) 
        {
            return 0;
        }

		// Do linear interpolation between table entries
		// Table has indices ranging from 0 to SIGMOID_RANGE, so
		// the above tests keep iIndex and iIndex + 1 in that range.
		iBase = c_aiSigmoidLookup[iIndex];
		iDelta = c_aiSigmoidLookup[iIndex + 1] - iBase;
		iDelta = (iDelta * (iAct & SIGMOID_MASK)) >> SIGMOID_SHIFT;

		// Return 1 - sigmoid(-act)
		return c_aiSigmoidLookup[SIGMOID_RANGE] - (iBase + iDelta);
	}
    else
    {
		iIndex = iAct >> SIGMOID_SHIFT;

		// Large positive activaitons result in an output of 1
		if (iIndex >= SIGMOID_RANGE) 
        {
            return c_aiSigmoidLookup[SIGMOID_RANGE];
        }

		// Do linear interpolation
		// Table has indices ranging from 0 to SIGMOID_RANGE, so
		// the above tests keep iIndex and iIndex + 1 in that range.
		iBase = c_aiSigmoidLookup[iIndex];
		iDelta = c_aiSigmoidLookup[iIndex + 1] - iBase;
		iDelta = (iDelta * (iAct & SIGMOID_MASK)) >> SIGMOID_SHIFT;
		return iBase + iDelta;
	}
}

///////////////////////////////////////
//
// IntegerTanh
//
// Compute tanh, in which the inputs and outputs are both the actual
// values scaled by FuguActivationScale.
//
// Parameters:
//      iAct: [in] Activation in fixed point format
//
// Return values:
//      Output activation, also in fixed point format.
//
//////////////////////////////////////
int IntegerTanh(int iAct)
{
	int iIndex, iBase, iDelta;

    // Negative activations are handled by mapping to positive values
	if (iAct < 0) {
		iAct = -iAct;
		iIndex = iAct >> TANH_SHIFT;

		// Large negative activations result in an output of -1
		if (iIndex >= TANH_RANGE) 
        {
            return -c_aiTanhLookup[TANH_RANGE];
        }

		// Linear interpolation
		// Table has indices ranging from 0 to TANH_RANGE, so
		// the above tests keep iIndex and iIndex + 1 in that range.
		iBase = c_aiTanhLookup[iIndex];
		iDelta = c_aiTanhLookup[iIndex + 1] - iBase;
		iDelta = (iDelta * (iAct & TANH_MASK)) >> TANH_SHIFT;

		// Return -tanh(act)
		return -(iBase + iDelta);
	}
    else
    {
		iIndex = iAct >> TANH_SHIFT;

		// Large positive activations result in an output of 1
		if (iIndex >= TANH_RANGE) 
        {
            return c_aiTanhLookup[TANH_RANGE];
        }

		// Linear interpolation
		// Table has indices ranging from 0 to TANH_RANGE, so
		// the above tests keep iIndex and iIndex + 1 in that range.
		iBase = c_aiTanhLookup[iIndex];
		iDelta = c_aiTanhLookup[iIndex + 1] - iBase;
		iDelta = (iDelta * (iAct & TANH_MASK)) >> TANH_SHIFT;
		return iBase + iDelta;
	}
}

///////////////////////////////////////
//
// FuguRender
//
// Renders a glyph to an image, each pixel has a value from 0 to FUGU_ACTIVATION_SCALE
//
// Parameters:
//      pGlyph:  [in]  Pointer to the ink to render
//      pGuide:  [in]  Guide to scale ink to, or NULL to use the ink bounds
//      aiInput: [out] Array that will be used as input to Fugu
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguRender(GLYPH *pGlyph, RECT *pGuide, int input[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT])
{
	GLYPH *p;
	int iPoint;

	// Min coordinate for rendering; should probably be 8 but using this 
	// value for compatibility with Dave's code.
	const int MONO_CLIP_MARGIN = 16 + 8;

	// Max coordinate for rendering; should probably be 29 * 8 - 8 * 2, but
	// using this value for compatibility with Dave's code
	const float MONO_CLIP_BOX = 232.0 - 32.0;

	// Rectangle in ink space which will be scaled to fill the range above
	int minX = INT_MAX;
	int minY = INT_MAX;
	int maxX = INT_MIN;
	int maxY = INT_MIN;

	// How much to scale the ink by
	float scaleBy = 1.0;

	// How much to shift the ink by
	int offX = 0;
	int offY = 0;

	// Declare the color map
	struct 
    {
		BITMAPINFO  info;
		RGBQUAD     bmiColors[2];
	} myinfo;

	// Buffer to hold a 256x256 image with 1 bit per pixel
	unsigned char _bitbuf[256 * 32];
	int nScanLines;

	int *optr = (int*) &(input[0][0]);
	int row, col;

	HBITMAP bmp;
	HBITMAP bmpOld;
	RECT rect;
	HPEN pen, penOld;

	// Drawing context for rendering the ink
	HDC hdibdc = CreateCompatibleDC( 0 );	// 0 implies screen
	if (!hdibdc)
    {
        return FALSE;
    }

	// Set up the bitmap structure
	memset(&myinfo, 0, sizeof(myinfo));
	myinfo.info.bmiHeader.biSize = sizeof(myinfo.info);
	myinfo.info.bmiHeader.biHeight = 256;				// Dimensions of the bitmap
	myinfo.info.bmiHeader.biWidth = 256;
	myinfo.info.bmiHeader.biPlanes = 1;					// reqd
	myinfo.info.bmiHeader.biBitCount = 1;				// want monochrome...?
	myinfo.info.bmiHeader.biCompression = BI_RGB;		// no comp
	myinfo.info.bmiHeader.biSizeImage = 256 * 256 / 8;
	myinfo.info.bmiHeader.biXPelsPerMeter = 10000;
	myinfo.info.bmiHeader.biYPelsPerMeter = 10000;
	myinfo.info.bmiHeader.biClrUsed = 2;

	// Set up the color table with only black and white
	myinfo.info.bmiColors[0].rgbBlue = 0;
	myinfo.info.bmiColors[0].rgbGreen = 0;
	myinfo.info.bmiColors[0].rgbRed = 0;
	myinfo.info.bmiColors[0].rgbReserved = 0;
	myinfo.info.bmiColors[1].rgbBlue = 255;
	myinfo.info.bmiColors[1].rgbGreen = 255;
	myinfo.info.bmiColors[1].rgbRed = 255;
	myinfo.info.bmiColors[1].rgbReserved = 0;

	// Create a monochrome bitmap
	bmp = CreateCompatibleBitmap(
						hdibdc,			// handle to DC
						256,			// width of bitmap, in pixels
						256				// height of bitmap, in pixels
						);
	if (!bmp)
    {
		goto allocated_dc;
    }

	// have to select bmp into dc, or no action
	bmpOld = (HBITMAP)SelectObject( hdibdc, bmp );
	if( !bmpOld )
    {
		goto allocated_bmp;
    }

	// Fill the bitmap with black
	SetRect(&rect, 0, 0, 256, 256);
	if (!FillRect(hdibdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH))) 
	{
		goto selected_bmp;
	}

	// Create a pen with the desired width
	pen = CreatePen(PS_SOLID, FUGU_PEN_WIDTH,	RGB(255,255,255));
	if (pen == NULL) 
	{
		goto selected_bmp;
	}
	penOld = (HPEN) SelectObject(hdibdc, pen); 
	if (penOld == NULL)
	{
		goto allocated_pen;
	}

    if (pGuide != NULL) 
    {
        // Scale according to the guide
        minX = pGuide->left;
        minY = pGuide->top;
        maxX = pGuide->right;
        maxY = pGuide->bottom;
    }
    else
    {
	    // Compute the bounding box of the ink.
	    p = pGlyph;
	    while (p != NULL) 
        {
		    for (iPoint = 0; iPoint < (int) p->frame->info.cPnt; iPoint++)
		    {
			    int x = p->frame->rgrawxy[iPoint].x;
			    int y = p->frame->rgrawxy[iPoint].y;
			    if( x < minX )
				    minX = x;
			    if( x > maxX )
				    maxX = x;
			    if( y < minY )
				    minY = y;
			    if( y > maxY )
				    maxY = y;
		    }
		    p = p->next;
	    }
    }

	// This test will fail if the guide is scrambled or if we are passed no ink.
	// Either way, inside the then clause we can assume there is at least one 
	// point of ink.
	if (minX <= maxX && minY <= maxY) 
    {
		// scale to fit the larger dimension. also determine 
		// the amounts to add to each point before scaling.
		int dX = maxX - minX;
		int dY = maxY - minY;

		if( dX > dY )
		{
			// If the ink is larger in the X direction, center in the Y direction
			scaleBy = MONO_CLIP_BOX / dX;
			offX = 0;
			offY = (int) ( MONO_CLIP_BOX - dY * scaleBy ) / 2;
		}
		else
		{
			if (dY == 0) 
            {
				// If the ink is just a point, then center it
				scaleBy = 0;
				offY = (int)(MONO_CLIP_BOX / 2);
				offX = (int)(MONO_CLIP_BOX / 2);
			}
            else 
            {
				// Otherwise center the ink in the X direction
				scaleBy = MONO_CLIP_BOX / dY;
				offY = 0;
				offX = (int) ( MONO_CLIP_BOX - dX * scaleBy ) / 2;
			}
		}

		// Scan through the strokes
		p = pGlyph;
		while (p != NULL) 
        {
// According to the documentation of PolylineTo, depending on the 
// OS on which the program is run, there are limits on the number 
// of points which can be passed to PolylineTo.  1000 is a safe limit.
#define POINT_MAX 1000
			POINT points[POINT_MAX];
			int iPtr = 0;

			// For each point in the stroke
			for (iPoint = 0; iPoint < (int) p->frame->info.cPnt; iPoint++)
			{
				// Copy the point to the array to be rendered, and scale
				// down to the 256x256 bitmap
				points[iPtr].x = (offX + MONO_CLIP_MARGIN) + (int) ((p->frame->rgrawxy[iPoint].x - minX) * scaleBy);
				points[iPtr].y = (offY + MONO_CLIP_MARGIN) + (int) ((p->frame->rgrawxy[iPoint].y - minY) * scaleBy);
                // Clip the point the allowed range
                if (points[iPtr].x < 0) 
                {
                    points[iPtr].x = 0;
                }
                if (points[iPtr].y < 0)
                {
                    points[iPtr].y = 0;
                }
                if (points[iPtr].x > 255)
                {
                    points[iPtr].x = 255;
                }
                if (points[iPtr].y > 255)
                {
                    points[iPtr].y = 255;
                }
				iPtr++;
				// If we are at the first point, move the drawing coordinates there
				// Note that we don't zero out iPtr here, because for a stroke with 1
				// point, we want to make sure PolylineTo gets called.
				if (iPoint == 0) 
                {
					MoveToEx(hdibdc, points[0].x, points[0].y, NULL);
				} 
				// If we have the maximum safe number of points, render them
				if (iPtr == POINT_MAX) 
                {
					if (!PolylineTo(hdibdc, points, POINT_MAX))
                    {
						goto selected_pen;
                    }
					iPtr = 0;
				}
			}
			// Any left over points are rendered here.
			if (iPtr > 0) 
            {
				if (!PolylineTo(hdibdc, points, iPtr))
                {
					goto selected_pen;
                }
			}
			p = p->next;
		}
	}

	// Copy the bitmap data to an array where we can play with it
	nScanLines = GetDIBits(
						hdibdc,				// handle to DC
						bmp,				// handle to bitmap
						0,					// first scan line to set
						256,				// number of scan lines to copy
						_bitbuf,			// bits go here
						&(myinfo.info),		// bitmap data buffer
						DIB_RGB_COLORS		// RGB or palette index
						);
	if ( !nScanLines )
    {
		goto selected_pen;
    }

	//FuguSaveBitmap(L"c:/temp/train.bmp", &myinfo.info.bmiHeader, _bitbuf);

	// The input here is a 256x256 bitmap, or 32x32 blocks of 8x8 pixels.  
	// We crop 2 blocks from the bottom and right, and 1 block from the top and left.
	for (row = 8; row < 8 + 29*8; row += 8 )
	{
		for (col = 8; col < 8 + 29*8; col += 8 )
		{
			int i;
			int val = 0;
			BYTE *pstart = _bitbuf + 32 * (255 - row) + col / 8;	// integer div
			// sum 8 bytes
			for (i = 0; i < 8; ++i )
			{
				// use the old geek trick to count bits set.
				// this works because x & (x-1) always results in
				// x with its least significant set bit cleared.
				BYTE b = *pstart;
				while ( b != 0 ) 
				{
    				val++;
					b = b & (b - 1);
				}
				pstart -= 32;	// next row down
			}
			// val now has the number of pixels turned on in the 8x8 block.
			// The following converts this to a value between 0 and 1 (using the
			// fixed point representation of activations in the network).
			*(optr++) = val * (FUGU_ACTIVATION_SCALE / 64);
		}
	}

    //FuguSaveNetworkInput(L"c:/temp/train.pgm", input);

selected_pen:
	SelectObject(hdibdc, penOld); 
allocated_pen:
    DeleteObject(pen);
selected_bmp:
	SelectObject(hdibdc, bmpOld);
allocated_bmp:
	DeleteObject(bmp);
allocated_dc:
	DeleteObject(hdibdc);
	
	return TRUE;
}

///////////////////////////////////////
//
// ApplyFuguInteger
//
// Apply the integer version of the Fugu network to an input image (fixed point format),
// and return an array of outputs (also in fixed point).  Return NULL if there is an
// error in allocating memory for the output.
//
// Parameters:
//      pFugu:   [in] Pointer to the fugu database to use
//      aiInput: [in] Input image to process, in fixed point format
//
// Return values:
//      An array of output activations in fixed point format, or NULL on error
//
//////////////////////////////////////
int *ApplyFuguInteger(FUGU_INTEGER_WEIGHTS *pFugu, int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT])
{
	int i, j, ip, jp, a, b;
    int *piStates1 = (int *) ExternAlloc(sizeof(int) * FUGU_KERNELS1 * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1);
    int *piStates2 = (int *) ExternAlloc(sizeof(int) * FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2);
	int *piOutput = (int *) ExternAlloc(sizeof(int) * pFugu->pHeader->arch.nOutputs);
	int *piStates_fc = (int *) ExternAlloc(sizeof(int) * pFugu->pHeader->arch.nHiddens);

	// Convenience pointers for the NN
	BYTE *pbWeight = pFugu->pbWeights;
	WCHAR *pfdchMapping = pFugu->pfdchMapping;
	INT *piLookup = pFugu->pHeader->aiWeightLookup;

    // Used as a temporary pointer into the weights for a convolution kernel
    BYTE *pbKernel;

    // Temporary pointer to outputs of a layer
    int *piStateOut;

	// Check memory allocation
	if (piOutput == NULL || piStates_fc == NULL || piStates1 == NULL || piStates2 == NULL) 
    {
        ExternFree(piOutput);
        piOutput = NULL;
        goto cleanup;
	}

	// First layer of convolutional weights

	// For each kernel
    piStateOut = piStates1;
	for (b = 0; b < FUGU_KERNELS1; b++) 
    {
		// For each position of the kernel
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH1; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT1; jp++) 
            {
				int iTotal = 0;
				// Get a temporary pointer to the weights in the kernel
				pbKernel = pbWeight;
				
				// Convolve the kernel with the input
				for (i = 0; i < FUGU_KERNEL_WIDTH1; i++) 
                {
					for (j = 0; j < FUGU_KERNEL_HEIGHT1; j++) 
                    {
						iTotal += 
							aiInput[i + ip * FUGU_KERNEL_SUBSAMPLE1][j + jp * FUGU_KERNEL_SUBSAMPLE1] * 
							(int)piLookup[*(pbKernel++)];
					}
				}

				// Add in the bias (a weight with an constant input of 1, which is FUGU_ACTIVATION_SCALE
				// in the fixed point format).
				iTotal += piLookup[*(pbKernel++)] * FUGU_ACTIVATION_SCALE;

				// Store the result.
				// Note that the three outer loops add up to 
				// FUGU_KERNELS1 * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1 iterations, which
				// is the size allocated for the following output array.
				*(piStateOut++) = IntegerTanh(iTotal / pFugu->pHeader->iScale);
			}
		}
		// Move on to the next kernel
		pbWeight = pbKernel;
	}

	// Second layer of convolutional weights

	// For each kernel
    piStateOut = piStates2;
	for (b = 0; b < FUGU_KERNELS2; b++) 
    {
		// For each position of the kernel
		for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
        {
			for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
            {
				int iTotal = 0;
				// Get a temporary pointer to the weights in the kernel
				pbKernel = pbWeight;

				// Convolve with the previous layer of results
				for (a = 0; a < FUGU_KERNELS1; a++) 
                {
                    int *piStateIn =
                        piStates1 
                        + (a * FUGU_HIDDEN_WIDTH1 * FUGU_HIDDEN_HEIGHT1)
                        + (ip * FUGU_KERNEL_SUBSAMPLE2 * FUGU_HIDDEN_HEIGHT1) 
                        + (jp * FUGU_KERNEL_SUBSAMPLE2);
					for (i = 0; i < FUGU_KERNEL_WIDTH2; i++) 
                    {
						for (j = 0; j < FUGU_KERNEL_HEIGHT2; j++) 
                        {
							iTotal += *(piStateIn++) * piLookup[*(pbKernel++)];
						}
                        piStateIn += FUGU_HIDDEN_HEIGHT1 - FUGU_KERNEL_HEIGHT2;
					}
				}

				// Add the bias (multiplied by a constant input of 1).
				iTotal += piLookup[*(pbKernel++)] * FUGU_ACTIVATION_SCALE;

				// Store the result.
				// Note that the three outer loops add up to 
				// FUGU_KERNELS2 * FUGU_HIDDEN_WIDTH2 * FUGU_HIDDEN_HEIGHT2 iterations, which
				// is the size allocated for the following output array.
				*(piStateOut++) = IntegerTanh(iTotal / pFugu->pHeader->iScale);
			}
		}

		// Move on to the next kernel
		pbWeight = pbKernel;
	}

	// First fully connected layer

	// For each hidden unit in this layer
    piStateOut = piStates_fc;
	for (i = 0; i < pFugu->pHeader->arch.nHiddens; i++) 
    {
		int iTotal = 0;

		// Multiply the weights for each unit in the previous layer
        int *piStateIn = piStates2;
		for (b = 0; b < FUGU_KERNELS2; b++) 
        {
			for (ip = 0; ip < FUGU_HIDDEN_WIDTH2; ip++) 
            {
				for (jp = 0; jp < FUGU_HIDDEN_HEIGHT2; jp++) 
                {
					iTotal += *(piStateIn++) * piLookup[*(pbWeight++)];
				}
			}
		}
		
		// Add the bias connection
		iTotal += piLookup[*(pbWeight++)] * FUGU_ACTIVATION_SCALE;

		// Store the result.
		// Note that the outer loop has nHiddens iterations, which is the
		// size of the following array.
		*(piStateOut++) = IntegerTanh(iTotal / pFugu->pHeader->iScale);
	}

	// Second fully connected layer

	// For each output unit
    piStateOut = piOutput;
	for (i = 0; i < pFugu->pHeader->arch.nOutputs; i++) 
    {
		int iTotal = 0;

		// Multiply the weights by all the hidden units in the previous layer
		for (j = 0; j < pFugu->pHeader->arch.nHiddens; j++) 
        {
			iTotal += piStates_fc[j] * piLookup[*(pbWeight++)];
		}
		// Add the bias
		iTotal += piLookup[*(pbWeight++)] * FUGU_ACTIVATION_SCALE;

		// Store the result.  Note that this layer uses a different 
		// activation function than the previous layers, to ensure
		// the output is between 0 and 1.
		// Note that the outer loop has nOutputs iterations, which is the
		// size of the following array.
		*(piStateOut++) = IntegerSigmoid(iTotal / pFugu->pHeader->iScale);
	}

	// Free up the storage for the hidden units
cleanup:
	ExternFree(piStates_fc);
    ExternFree(piStates1);
    ExternFree(piStates2);

	// Return the arry of output activations, which the caller must free.
	return piOutput;
}

// An element of an alternate list
typedef struct ALT 
{
	int iProb;			// The probability of this alternate, in fixed point form
	wchar_t fdch;		// The folded dense code with this probability
} ALT;

///////////////////////////////////////
//
// CompareAlts
//
// Comparison function used to sort ALT alternates
//
// Parameters:
//      pv1: [in] Pointer to alternate 1
//      pv2: [in] Pointer to alternate 2
//
// Return values:
//      Return -1 if alternate 1 has a higher probability that alternate 2, 
//      1 if alternate 2 has a higher probability.  In case of a tie, return -1
//      if alternate 1 has a lower folded dense code, or 1 if alternate 2 has
//      a lower folded dense code.  In case the alternates are identical, returns 0.
//
//////////////////////////////////////
int __cdecl CompareAlts(const void *pv1, const void *pv2)
{
	ALT *pAlt1 = (ALT *) pv1;
	ALT *pAlt2 = (ALT *) pv2;

	// First sort based on probability
	if (pAlt1->iProb > pAlt2->iProb) 
    {
        return -1;
    }
	if (pAlt1->iProb < pAlt2->iProb) 
    {
        return 1;
    }

	// Within a given probability, sort by folded dense code value
	if (pAlt1->fdch < pAlt2->fdch) 
    {
        return -1;
    }
	if (pAlt1->fdch > pAlt2->fdch) 
    {
        return 1;
    }
	return 0;
}

///////////////////////////////////////
//
// FuguMatch
//
// Invoke Fugu on a character
//
// Parameters:
//      pFugu:       [in]  Fugu database to use
//      pAltList:    [out] Alt list
//      cAlt:        [in]  The maximum number of alternates to return
//      pGlyph:      [in]  The ink to recognize
//      pGuide:      [in]  Guide to scale ink to, or NULL to use the ink bounds
//      pCharSet:    [in]  Filter for the characters to be returned
//      pLocRunInfo: [in]  Pointer to the locale database
//
// Return values:
//      Returned the number of items in the alt list, or -1 if there is an error
//
//////////////////////////////////////
int FuguMatch(FUGU_INTEGER_WEIGHTS *pFugu,  // Fugu database
              ALT_LIST *pAltList,			// Alt list where the results are returned
			  int cAlt,						// Maximum number of results requested
			  GLYPH *pGlyph,				// Pointer to the strokes
              RECT *pGuide,                 // Guide to scale ink to
			  CHARSET *pCharSet,			// Filters to apply to the results
			  LOCRUN_INFO *pLocRunInfo)		// Locale database
{
	int i;
	int aiInput[FUGU_INPUT_WIDTH][FUGU_INPUT_HEIGHT];
	int *piOutput;
	int nAlts = 0;
	ALT *pAlts;

	// Check the parameters
	if (IsBadReadPtr(pFugu, sizeof(*pFugu)) || 
		IsBadWritePtr(pAltList, sizeof(*pAltList)) ||
		cAlt <= 0 || 
		(pGlyph != NULL && IsBadReadPtr(pGlyph, sizeof(*pGlyph))) ||
		(pGuide != NULL && IsBadReadPtr(pGuide, sizeof(*pGuide))) ||
		IsBadReadPtr(pCharSet, sizeof(*pCharSet)) ||
		IsBadReadPtr(pLocRunInfo, sizeof(*pLocRunInfo)))
	{
		return -1;
	}

	// Set the number of results to zero in case we do an error exit.
	pAltList->cAlt = 0;

	// First convert the ink to 29x29 input region
	if (!FuguRender(pGlyph, pGuide, aiInput)) 
    {
		return -1;
    }

	// Apply the recognizer
//	piOutput = ApplyFuguFloat(aiInput);
	piOutput = ApplyFuguInteger(pFugu, aiInput);
	if (piOutput == NULL)
    {
		return -1;
    }

	// Allocate space for an array that can store all the results
	pAlts = (ALT *) ExternAlloc(pFugu->pHeader->arch.nOutputs * sizeof(ALT));
	if (pAlts == NULL)
    {
		ExternFree(piOutput);
		return -1;
    }

#if 1
	// This is the version for Fugu trained on dense codes, which will usually be
	// what we use.  Loops over the outputs
	for (i = 0; i < pFugu->pHeader->arch.nOutputs; i++) 
    {
		// If the probability is non-zero
		if (piOutput[i] > 0) 
        {
			wchar_t fdch = pFugu->pfdchMapping[i];
			// Check whether the character (or folding set) passes the filter, 
			// if so add it to the array of outputs.
            if (IsAllowedChar(pLocRunInfo, pCharSet, fdch))
            {
				pAlts[nAlts].fdch = fdch;
				pAlts[nAlts].iProb = piOutput[i];
				nAlts++;
			} 
		}
	}
#else
	// This is the version for Dave's sashimi, which returned unicode.  Loop over the outputs
	for (i = 0; i < pFugu->pHeader->arch.nOutputs; i++) 
    {
		if (piOutput[i] > 0) 
        {
			// Convert the output number to a dense code
			wchar_t dch = LocRunUnicode2Dense(pLocRunInfo, pFugu->pfdchMapping[i]);

			// Keep only those characters which are supported in the recognizer
			if (dch != 0 && dch != LOC_TRAIN_NO_DENSE_CODE) 
            {
				// Check if it is a folded code
				wchar_t fdch = LocRunDense2Folded(pLocRunInfo, dch);
				if (fdch != 0) 
                {
					// If folded, check to see if it passes the ALC filter
                    if (IsAllowedChar(pLocRunInfo, pCharSet, fdch))
                    {
						// If it does, then check to see that the folded code it not already 
						// present.  If it is not, then add it to the list; if it is there,
						// keep the higher of the two probabilities
						int j;
						for (j = 0; j < nAlts; j++) 
                        {
							if (pAlts[j].fdch == fdch) 
                            {
								pAlts[j].iProb = __max(pAlts[j].iProb, piOutput[i]);
								break;
							}
						}
						if (j == nAlts) 
                        {
							pAlts[j].fdch = fdch;
							pAlts[j].iProb = piOutput[i];
							nAlts++;
						}
					}
				} 
                else 
                {
					// If it is not a folded code, check the ALC filter and add it to the list.
                    if (IsAllowedChar(pLocRunInfo, pCharSet, fdch))
                    {
						pAlts[nAlts].fdch = dch;
						pAlts[nAlts].iProb = piOutput[i];
						nAlts++;
					}
				}
			}
		}
	}
#endif

	// Sort the alternates into decreasing order by probability
	qsort(pAlts, nAlts, sizeof(ALT), CompareAlts);

	// Copy the top cAlt alternates to the output
	for (i = 0; i < cAlt && i < nAlts; i++) 
    {
		pAltList->awchList[i] = pAlts[i].fdch;
		// Probabilities are converted to scores using 256 * log_2(prob)
//		pAltList->aeScore[i] = -(float)ProbToScore(pAlts[i].iProb / (float)FUGU_ACTIVATION_SCALE);
        pAltList->aeScore[i] = pAlts[i].iProb / (float) FUGU_ACTIVATION_SCALE;
	}
	pAltList->cAlt = i;

	// Clean up and return
	ExternFree(pAlts);
	ExternFree(piOutput);
	return pAltList->cAlt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\cheby.h ===
#define IMAXCHB 10

#ifdef __cplusplus
extern "C" {
#endif

//int solve(double m[IMAXCHB][IMAXCHB], double c[IMAXCHB], long n);
int LSCheby(int* y, int n, int *c, int cfeats);
//void ReconCheby(long* xy, long n, double c[IMAXCHB], long cfeat);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\cheby.c ===
#include "common.h"
#include "math16.h"
#include "cheby.h"

static int
solve2(int m[][(IMAXCHB+1)/2], int c[], int n)
{
	int i, j, k, t, tmp;

	for (i=0; i<n; ++i)
	{
		t = m[i][i];

		// punt:
		if (t == 0)
		{
			memset(c, 0, n*sizeof(*c));
			return 0;
		}

		for (j=0; j<n; ++j)
			m[i][j] = Div16(m[i][j], t);
		c[i] = Div16(c[i], t);

		for (k=i+1; k<n; ++k)
		{
			t = m[k][i];

			for (j=0; j<n; ++j)
			{
				Mul16(t, m[i][j], tmp)
				m[k][j] -= tmp;
			}
			Mul16(t, c[i], tmp)
			c[k] -= tmp;
		}
	}

	for (i=(n-1); i>=0; --i)
	{
		for (k=i-1; k>=0; --k)
		{
			t = m[k][i];

			for (j=0; j<n; ++j)
			{
				Mul16(t, m[i][j], tmp)
				m[k][j] -= tmp;
			}
			Mul16(t, c[i], tmp)
			c[k] -= tmp;
		}
	}

	return 1;
}

static int
solve(int m[IMAXCHB][IMAXCHB], int *c, int n)
{
	int i, j, i2, j2;
	int mEven[((IMAXCHB+1))/2][((IMAXCHB+1)/2)];
	int mOdd[(IMAXCHB/2)][((IMAXCHB+1)/2)];	// # of cols is bigger than needed so that solve2() works
	int cEven[((IMAXCHB+1)/2)];
	int cOdd[(IMAXCHB/2)];

	for (i = 0, i2 = 0; i2 < n; ++i, i2 += 2)
	{
		for (j = 0, j2 = 0; j2 < n; ++j, j2 += 2)
		{
			mEven[i][j] = m[i2][j2];
		}
		cEven[i] = c[i2];
	}
	for (i = 0, i2 = 1; i2 < n; ++i, i2 += 2)
	{
		for (j = 0, j2 = 1; j2 < n; ++j, j2 += 2)
		{
			mOdd[i][j] = m[i2][j2];
		}
		cOdd[i] = c[i2];
	}
	if (!solve2(mEven, cEven, (n+1)/2)) return 0;
	if (!solve2(mOdd, cOdd, n/2)) return 0;

	for (i = 0, i2 = 0; i2 < n; ++i, i2 += 2)
	{
		c[i2] = cEven[i];
	}
	for (i = 0, i2 = 1; i2 < n; ++i, i2 += 2)
	{
		c[i2] = cOdd[i];
	}

	return 1;
}

// Assumptions:
//    c has size atleast cfeats
//    cfeats is at most IMAXCHB
//    c is uninitialized
int LSCheby(int* y, int n, int *c, int cfeats)
{
	int i, j, t, x, dx, n2, nMin;
	int meanGuess, tmp;
	int T[IMAXCHB], m[IMAXCHB][IMAXCHB];

	if (cfeats > IMAXCHB  || cfeats <= 0)
		return 0;

	memset(c, 0, cfeats*sizeof(*c));

	n2 = n+n;
	nMin = cfeats + 2;

    if (n < nMin && n > 4)
    {
        cfeats = n - 2;
        nMin = cfeats + 2;
    }

	if (n < nMin)	// approximate the stroke by a straight line
	{
		*c++ = (y[0] + y[n2-2]) >> 1;
		*c   = (y[n2-2] - y[0]) >> 1;
		return 2;
	}

	memset(T, 0, sizeof(T));
	memset(m, 0, sizeof(m));

	meanGuess = y[0];

	x = LSHFT(-1);
	dx = LSHFT(2)/(n-1);

	for (t = 0; t < n2; t += 2)
	{
		T[0] = LSHFT(1);
		T[1] = x;
		for (i = 2; i < cfeats; ++i)
		{
			Mul16(x, T[i-1], tmp)
			T[i] = (tmp<<1) - T[i-2];
		}

		for (i = 0; i < cfeats; ++i)
		{
			for (j = 0; j < cfeats; ++j)
			{
				Mul16(T[i], T[j], tmp)
				m[i][j] += tmp;
			}

			Mul16(T[i], y[t] - meanGuess, tmp)
			c[i] += tmp;
			//c[i] += T[i]*(y[t] - meanGuess);		
		}
		
		x += dx;
	}

	if (!solve(m, c, cfeats)) 
		return 0;

	c[0] += meanGuess;

	return cfeats;
}

/*
void ReconCheby(long* y, long n, double c[IMAXCHB], long cfeat)
{
	long i, t;
	double T[IMAXCHB];
	double x, dx;
	long n2;

	n2 = n+n;

	x = -1.0;
	dx = 2.0/((double)(n-1));

	for (i = 0; i < cfeat; ++i)
		T[i] = 0.0;

	for (t = 0; t < n2; t += 2)
	{
		double yt;

		T[0] = 1.0;
		T[1] = x;
		for (i = 2; i < cfeat; ++i)
			T[i] = 2*x*T[i-1] - T[i-2];

		yt = 0.0;
		for (i = 0; i < cfeat; ++i)
			yt += c[i]*T[i];
	
		y[t] = (long)(yt + 0.5);
		x += dx;
	}
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\sources.inc ===
TARGETNAME=fugu
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\fugu\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\minifugu.c \
         ..\minifugurs.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\minifugurs.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      minifugurs.c
//
// Description:
//      Function to map fugu databases from resources
//
// Author:
//      hrowley
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include "fugu.h"

///////////////////////////////////////
//
// FuguLoadRes
//
// Load an integer Fugu database from a resource
//
// Parameters:
//      pInfo:      [out] Structure where information for unloading is stored
//      hInst:      [in] Handle to the DLL containing the recognizer
//      iResNumber: [in] Number of the resource (ex RESID_FUGU)
//      iResType:   [in] Number of the recognizer (ex VOLCANO_RES)
//      pLocRunInfo: [in] Locale database to check header on file
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL FuguLoadRes(
    FUGU_LOAD_INFO *pInfo,
	HINSTANCE	hInst, 
	int			iResNumber, 
	int			iResType,
    LOCRUN_INFO *pLocRunInfo) 
{
	BYTE		*pb;

	if (IsBadWritePtr(pInfo, sizeof(*pInfo)) || 
		IsBadReadPtr(pLocRunInfo, sizeof(*pLocRunInfo)) ||
		hInst == NULL)
	{
		return FALSE;
	}

	// Load the fugu database resource
	pb	= DoLoadResource(&pInfo->info, hInst, iResNumber, iResType);
	if (!pb) 
    {
		return FALSE;
	}

	// Check the format of the resource
	return FuguLoadPointer(pInfo, pLocRunInfo, pInfo->info.iSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\fugu\src\sigmoid.h ===
// Automatically generated by mksigmoid, please do not modify.

#define FUGU_ACTIVATION_SHIFT 11

#define TANH_RANGE 289
#define TANH_SHIFT 5
#define TANH_MASK 31
const int c_aiTanhLookup[TANH_RANGE + 1] = 
{
        0,    32,    64,    96,   128,   160,   191,   223, 
      255,   286,   317,   349,   380,   410,   441,   471, 
      502,   532,   561,   591,   620,   649,   678,   706, 
      734,   762,   789,   816,   843,   869,   895,   921, 
      946,   971,   996,  1020,  1044,  1068,  1091,  1113, 
     1136,  1158,  1179,  1201,  1221,  1242,  1262,  1282, 
     1301,  1320,  1338,  1356,  1374,  1392,  1409,  1425, 
     1442,  1458,  1473,  1488,  1503,  1518,  1532,  1546, 
     1560,  1573,  1586,  1599,  1611,  1623,  1635,  1646, 
     1657,  1668,  1679,  1689,  1699,  1709,  1719,  1728, 
     1737,  1746,  1755,  1763,  1771,  1779,  1787,  1795, 
     1802,  1809,  1816,  1823,  1829,  1836,  1842,  1848, 
     1854,  1859,  1865,  1870,  1876,  1881,  1886,  1890, 
     1895,  1900,  1904,  1908,  1912,  1917,  1920,  1924, 
     1928,  1932,  1935,  1938,  1942,  1945,  1948,  1951, 
     1954,  1957,  1959,  1962,  1965,  1967,  1970,  1972, 
     1974,  1977,  1979,  1981,  1983,  1985,  1987,  1989, 
     1990,  1992,  1994,  1995,  1997,  1999,  2000,  2002, 
     2003,  2004,  2006,  2007,  2008,  2009,  2011,  2012, 
     2013,  2014,  2015,  2016,  2017,  2018,  2019,  2020, 
     2021,  2021,  2022,  2023,  2024,  2025,  2025,  2026, 
     2027,  2027,  2028,  2029,  2029,  2030,  2030,  2031, 
     2031,  2032,  2032,  2033,  2033,  2034,  2034,  2035, 
     2035,  2035,  2036,  2036,  2037,  2037,  2037,  2038, 
     2038,  2038,  2038,  2039,  2039,  2039,  2040,  2040, 
     2040,  2040,  2041,  2041,  2041,  2041,  2041,  2042, 
     2042,  2042,  2042,  2042,  2043,  2043,  2043,  2043, 
     2043,  2043,  2043,  2044,  2044,  2044,  2044,  2044, 
     2044,  2044,  2044,  2045,  2045,  2045,  2045,  2045, 
     2045,  2045,  2045,  2045,  2045,  2046,  2046,  2046, 
     2046,  2046,  2046,  2046,  2046,  2046,  2046,  2046, 
     2046,  2046,  2046,  2046,  2046,  2046,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2048
};

#define SIGMOID_RANGE 267
#define SIGMOID_SHIFT 6
#define SIGMOID_MASK 63
const int c_aiSigmoidLookup[SIGMOID_RANGE + 1] = 
{
     1024,  1040,  1056,  1072,  1088,  1104,  1120,  1136, 
     1151,  1167,  1183,  1198,  1214,  1229,  1244,  1260, 
     1275,  1290,  1305,  1319,  1334,  1348,  1363,  1377, 
     1391,  1405,  1419,  1432,  1445,  1459,  1472,  1485, 
     1497,  1510,  1522,  1534,  1546,  1558,  1569,  1581, 
     1592,  1603,  1614,  1624,  1635,  1645,  1655,  1665, 
     1674,  1684,  1693,  1702,  1711,  1720,  1728,  1737, 
     1745,  1753,  1761,  1768,  1776,  1783,  1790,  1797, 
     1804,  1811,  1817,  1823,  1829,  1836,  1841,  1847, 
     1853,  1858,  1863,  1869,  1874,  1879,  1883,  1888, 
     1893,  1897,  1901,  1906,  1910,  1914,  1918,  1921, 
     1925,  1929,  1932,  1935,  1939,  1942,  1945,  1948, 
     1951,  1954,  1956,  1959,  1962,  1964,  1967,  1969, 
     1972,  1974,  1976,  1978,  1980,  1982,  1984,  1986, 
     1988,  1990,  1992,  1993,  1995,  1996,  1998,  1999, 
     2001,  2002,  2004,  2005,  2006,  2008,  2009,  2010, 
     2011,  2012,  2013,  2014,  2015,  2016,  2017,  2018, 
     2019,  2020,  2021,  2022,  2023,  2023,  2024,  2025, 
     2025,  2026,  2027,  2027,  2028,  2029,  2029,  2030, 
     2030,  2031,  2031,  2032,  2032,  2033,  2033,  2034, 
     2034,  2035,  2035,  2036,  2036,  2036,  2037,  2037, 
     2037,  2038,  2038,  2038,  2039,  2039,  2039,  2039, 
     2040,  2040,  2040,  2040,  2041,  2041,  2041,  2041, 
     2042,  2042,  2042,  2042,  2042,  2042,  2043,  2043, 
     2043,  2043,  2043,  2043,  2044,  2044,  2044,  2044, 
     2044,  2044,  2044,  2044,  2045,  2045,  2045,  2045, 
     2045,  2045,  2045,  2045,  2045,  2045,  2045,  2046, 
     2046,  2046,  2046,  2046,  2046,  2046,  2046,  2046, 
     2046,  2046,  2046,  2046,  2046,  2046,  2046,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2047,  2047,  2047,  2047,  2047, 
     2047,  2047,  2047,  2048
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\cowmath.h ===
// cowmath.h

#ifndef __INC_COWMATH_H
#define __INC_COWMATH_H

#ifdef __cplusplus
extern "C" {
#endif

int WArctan2(int, int);
//int AverageDeviation(int *rg, int c);
int ISqrt(int x);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\cowmath.c ===
// mathx.c from \greco\feature\arcs

#include "cowmath.h"

#define MATHX_NUMINCS 100L

/*	array of angles in degrees associated with arctan values
static char arctan_array[] =
	{
    0,1,1,2,2,3,3,4,5,5,
	6,6,7,7,8,9,9,10,10,11,
	11,12,12,13,13,14,15,15,16,16,
	17,17,18,18,19,19,20,20,21,21,
	22,22,23,23,24,24,25,25,26,26,
	27,27,27,28,28,29,29,30,30,31,
	31,31,32,32,33,33,33,34,34,35,
	35,35,36,36,37,37,37,38,38,38,
	39,39,39,40,40,40,41,41,41,42,
	42,42,43,43,43,44,44,44,44,45
	};

// 	Rough integer approximation (fast) of arctan2 based on table for 0-45 degrees
//	Return degrees, base on integer y and x inputs to arctan
int WArctan2(int y, int x)
	{
	int xneg=0,yneg=0;
	int index,angle;

    if (x < 0)
		{ 
        xneg = 1;
        x = -x;
    	}

    if (y < 0)
		{
        yneg = 1;
        y = -y;
    	}

    if (x == 0 && y == 0) return 0;

    if (y == 0)
        return(xneg ? 180 : 0);

    if (x == 0)
        return(yneg ? 270 : 90);

    if (x == y)
        angle = 45;
    else if (x > y)
		{
        index = (int)(((long)y * MATHX_NUMINCS) / (long)x);
        angle = arctan_array[index];
    	}
	else if (y > x)
		{
        index = (int)(((long)x * MATHX_NUMINCS) / (long)y);
        angle = 90 - arctan_array[index];
    	}
    
    if (xneg)
        if (yneg) 
            return(180 + angle);
        else
            return(180 - angle);
    else
        if (yneg) 
            return(360 - angle);
        else
            return(angle);
        
}

int AverageDeviation(int *rg, int c)
{
   int i, tmp;
   int mean;
   long sum = 0;

   for (i = 0; i < c; i++)
      sum += (long) rg[i];
   mean = (int)(sum/c);

   sum = 0;
   for (i = 0; i < c; i++) {
      tmp = rg[i] - mean;
      sum += (tmp < 0 ? -tmp : tmp);
   }
   return (int) (sum/c);
}
*/

int ISqrt(int x)
{
	int n, lastN;

	if (x <= 0)
		return 0;
	if (x==1)
		return 1;

	n = x >> 1;
	do 
	{
		lastN = n;
		n = (n + x/n) >> 1;
	}
	while (n < lastN);

	return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\nfeature.c ===
// nfeature.c
// Angshuman Guha, aguha
// Last modified Jan 3, 2000

/* 
These functions constitute the core featurization algorithm for cursive English.

The ink is broken into segments at points half-way between a y-bottom and the next y-top.
Each segment is featurized into Chebychev shape features, a size feature, 
a terminal x-velocity feature, a delta-x value of start point from previous segment's
"reference" point and the y-distance of the top of the segment from the baseline.

The reference point of a segment is its local y-top, if it exists.  Otherwise, it
the first point.  Note:  a local y-top exists in all segments except sometimes for 
the first segment of a stroke.

There is a second set of features for each segment which are empty most of the time and
occasionally contains information about delayed/overlapping ink.  These are called 
secondary features and the ink that generates them is said to be the secondary strokes.
The main ink stream is said to be the primary strokes.

As we process the ink one stroke after another, we maintain a linked list
of the segments generated so far.  When we get a new stroke, we compute the following:
	l = the left end of the new stroke's bounding rect
	r = the right end of the new stroke's bounding rect
	r2 = the right end of all previously processed primary strokes
	r1 = same as r2 except the last primary segment is excluded
If l >= r1, 
	we decide that the new stroke should simply continue the stream of primary segments.
Otherwise, we decide that the new stroke starts out as a secondary stream.
If r <= r2,
	we don't even segment the new stroke.  We generate exactly one secondary segment.
Otherwise, we segment the new stroke.  These segments start out being secondary segments.
If and when we reach the end of the primary segment stream, we upgrade the secondary
stream of segments to be primary segments (i.e. new elements are added to the linked list
of segments).

A secondary segment is attached to a primary segment using the following rules:
1.  If the secondary segment has an x-overlap with some primary segment, we take the first such
	primary segment.
2.  Otherwise, we take the last primary segment appearing to the left of the secondary segment.
3.  If the primary segment found in step 1 or 2 already has a secondary segment attached to it,
	we simply follow the linked list to find the first "free" primary segment.

The secondary features include Chebychev shape features, a size feature, a delta-x value
of start point from corresponding primary segment's ref point and the y-distance of the top of 
the segment from the baseline.
*/ 

/*
An analysis of the featurization code suggests that if the data satisfies the following conditions
there will be no over-/under- flow.
	1. for each stroke, diagonal of bounding rect < sqrt(INT_MAX)/2
	2. arc length of each stroke < INT_MAX/2
	3. for each stroke, Sum((x - xmin)*(x - xmin)) + Sum((y - ymin)*(y - ymin)) < INT_MAX

-Angshuman Guha,  aguha
March 16, 1999
*/

#include "common.h"
#include "math16.h"
#include "cowmath.h"
#include "nfeature.h"
#include "cheby.h"

typedef struct
{
	int *xy;
	int cPoint;
	int cPointMax;
	int iStepSize;
	int iStepSizeSqr;
	int hysteresis;
	int iyDev;
	int delayedThreshold;
} POINTINFO;

#define ABS(a) ((a) > 0 ? (a) : -(a))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define ONE_D_DISJOINT(min1, max1, min2, max2) (((min2) > (max1)) || ((min1) > (max2)))
#define ONE_D_OVERLAP(min1, max1, min2, max2) (!ONE_D_DISJOINT(min1, max1, min2, max2))
#define RECT_OVERLAP(r1, r2) (ONE_D_OVERLAP((r1).left, (r1).right, (r2).left, (r2).right) && ONE_D_OVERLAP((r1).top, (r1).bottom, (r2).top, (r2).bottom))
#define RECT_X_DISTANCE(r1, r2) MAX((r2).left - (r1).right, (r1).left - (r2).right)

#ifdef RECONSTRUCTION_ERROR
double gxError = 0;
double gyError = 0;

double ReconError(int *y, int n, int *c, int cfeat)
{
	long i, t;
	double T[IMAXCHB];
	double x, dx;
	long n2;
	double error;
	int iError;

	n2 = n+n;

	x = -1.0;
	dx = 2.0/((double)(n-1));
	error = 0;

	for (i = 0; i < cfeat; ++i)
		T[i] = 0.0;

	for (t = 0; t < n2; t += 2)
	{
		double yt;

		T[0] = 1.0;
		T[1] = x;
		for (i = 2; i < cfeat; ++i)
			T[i] = 2*x*T[i-1] - T[i-2];

		yt = 0.0;
		for (i = 0; i < cfeat; ++i)
			yt += c[i]*T[i];

		iError = y[t] - (long)(yt + 0.5);
		if (iError < 0)
			iError = -iError;
		error += iError/65536.0;
		//y[t] = (long)(yt + 0.5);
		x += dx;
	}
	return (double)error/n;
}
#endif

/******************************Public*Routine******************************\
* DestroyNFEATURESET
*
* Function to release a NFEATURESET.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyNFEATURESET(NFEATURESET *p)
{
	NFEATURE *q, *r;

	if (!p)
		return;
	q = p->head;
	while (q)
	{
		r = q->next;
		ExternFree(q);
		q = r;
	}
	ExternFree(p);
}

/******************************Public*Routine******************************\
* CreateNFEATURESET
*
* Function to allocate and initialize a NFEATURESET.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
NFEATURESET *CreateNFEATURESET(void)
{
	NFEATURESET *p = (NFEATURESET *) ExternAlloc(sizeof(NFEATURESET));
	if (!p)
		return NULL;
	p->head = NULL;
	p->cSegment = 0;
	p->cPrimaryStroke = 0;
	return p;
}


/******************************Private*Routine******************************\
* AddPoint
*
* Function to re-sample ink for a stroke.  The pointinfo structure should
* be initialized so that cPointMax is atleast 1, xy has been allocated
* with size atleast 2*cPointMax, iStepSize is the resampling interval
* and iStepSizeSqr is its square.  This function is called once for each
* raw point.
*
* Returns TRUE on success.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL AddPoint(POINTINFO *pPointinfo, int x, int y)
{
	int dx, dy, dist2, dist;
	int x0, y0;

	if (!pPointinfo->cPoint)
	{
		pPointinfo->xy[0] = x;
		pPointinfo->xy[1] = y;
		pPointinfo->cPoint = 1;
		return TRUE;
	}

	x0 = pPointinfo->xy[2*pPointinfo->cPoint-2];
	y0 = pPointinfo->xy[2*pPointinfo->cPoint-1];
	for (;;)
	{
		dx = x - x0;
		dy = y - y0;
		dist2 = dx*dx + dy*dy;
		if (dist2 < pPointinfo->iStepSizeSqr)
			break;

		// It is always guaranteed that iStepSizeSqr >= 4.
		// That implies that dist2 >= 4 here.
		// That in turn implies that dist = ISqrt(dist2) >= 2

		// add a point at given step size
		dist = ISqrt(dist2);
		ASSERT(dist > 0);
		x0 += pPointinfo->iStepSize*dx/dist;
		y0 += pPointinfo->iStepSize*dy/dist;
		// a minimum iStepSize of 2 and the fact that ((float)dx/dist)^2 + ((float)dy/dist)^2 = 1 guarantees that
		// the previous two assignments change atleast one of x0 and y0 i.e. its not an infinite loop
		if (pPointinfo->cPoint == pPointinfo->cPointMax)
		{
			// need more space
			// hopefully we don't come here too often
			pPointinfo->cPointMax *= 2;
			pPointinfo->xy = (int *) ExternRealloc(pPointinfo->xy, 2*pPointinfo->cPointMax*sizeof(int));
			ASSERT(pPointinfo->xy);
			if (!pPointinfo->xy)
				return FALSE;
		}
		pPointinfo->xy[2*pPointinfo->cPoint] = x0;
		pPointinfo->xy[2*pPointinfo->cPoint+1] = y0;
		pPointinfo->cPoint++;
	}
	return TRUE;
}

/******************************Private*Routine******************************\
* bContinuedStroke
*
* Function to detect a pen-skip.
*
* ppGlyph is the current glyph
* iStepSizeSqr is the square of the resampling step-size
* 
* Returns TRUE if the specified stroke is followed by a another stroke
* which is really part of the same stroke and exists separately because
* of a pen-skip. In that case, ppGlyph is modified to point to the next glyph 
* in the pen-skipped stroke.
* Returns FALSE otherwise.
*
* History:
*  6-Mar-1998 -by- Angshuman Guha aguha
* Wrote it.
*  7-Aug-1998 -by- Angshuman Guha aguha
* Modified it.
\**************************************************************************
BOOL bContinuedStroke(GLYPH **ppGlyph, int iStepSizeSqr)
{
	XY *rgXY;
	int cXY, a, b;
	FRAME *frame;
	GLYPH *pGlyph;

	// last point of this stroke
	ASSERT(ppGlyph);
	pGlyph = *ppGlyph;
	ASSERT(pGlyph);
	frame = pGlyph->frame;
	ASSERT(IsVisibleFRAME(frame));
	rgXY = RgrawxyFRAME(frame);
	cXY = CrawxyFRAME(frame);
	ASSERT(cXY > 0);
	rgXY += cXY - 1;
	a = rgXY->x;
	b = rgXY->y;

	// first point of next stroke
	pGlyph = pGlyph->next;
	while (pGlyph && !IsVisibleFRAME(pGlyph->frame))
		pGlyph = pGlyph->next;
	if (!pGlyph)
		return FALSE;
	frame = pGlyph->frame;
	ASSERT(IsVisibleFRAME(frame));
	rgXY = RgrawxyFRAME(frame);
	cXY = CrawxyFRAME(frame);
	ASSERT(cXY > 0);
	a -= rgXY->x;
	b -= rgXY->y;

	// is the distance between the two points too short?
	if (a*a+b*b <= iStepSizeSqr)
	{
		*ppGlyph = pGlyph;
		return TRUE;
	}
	return FALSE;
}
*/

/******************************Private*Routine******************************\
* cPenSkip
*
* Function to count the total number of points in any subsequent "continued"
* strokes (strokes that exist because of pen-skips), if any.
*
* History:
*  06-Mar-1998 -by- Angshuman Guha aguha
* Wrote it.
*  06-Aug-1998 -by- Angshuman Guha aguha
* Modified it.
\**************************************************************************
int cPenSkip(GLYPH *glyph, int iStepSizeSqr)
{
	int c;
	FRAME *frame;
	GLYPH *head = glyph;

	ASSERT(glyph);
	ASSERT(IsVisibleFRAME(glyph->frame));

	if (!bContinuedStroke(&glyph, iStepSizeSqr))
		return 0;
	
	glyph = head;
	frame = glyph->frame;
	c = CrawxyFRAME(frame);

	for (; glyph; )
	{
		if (!bContinuedStroke(&glyph, iStepSizeSqr))
			break;

		frame = glyph->frame;
		ASSERT(IsVisibleFRAME(frame));
		c += CrawxyFRAME(frame);
	}	

	ASSERT(c > (int)CrawxyFRAME(head->frame));
	return c;
}
*/


/******************************Private*Routine******************************\
* AddChebyFeatures
*
* Function to normalize the X- and Y- Chebychev coefficients.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
*  07-Aug-1998 -by- Angshuman Guha aguha
* Modified it.
*  02-Sep-1999 -by- Angshuman Guha aguha
* X and Y coeeficients normalized independently.  No return value.
\**************************************************************************/
void AddChebyFeatures(unsigned short *rgFeat, int *chebyX, int cChebyX, int *chebyY, int cChebyY)
{
	int norm;
	int dT, i;

	// X
	for (norm=0, i = 1; i < cChebyX; ++i)  // 1st X coeff skipped
	{
		Mul16(chebyX[i], chebyX[i], dT)
        norm += dT;
	}
	norm = ISqrt(norm) << 8;
	if (norm < LSHFT(1))
		norm = LSHFT(1);
	for (i=1; i<cChebyX; i++)
	{
		dT = Div16(chebyX[i], norm) + LSHFT(1);  // now between 0 and 2
		dT >>= 1;  // now between 0 and 1
		if (dT >= 0x10000)
			dT = 0xFFFF;
		else if (dT < 0)
			dT = 0;
		*rgFeat++ = (unsigned short)dT;
	}

	// Y
	for (norm=0, i = 1; i < cChebyY; ++i)  // 1st Y coeff skipped
	{
		Mul16(chebyY[i], chebyY[i], dT)
        norm += dT;
	}
	norm = ISqrt(norm) << 8;
	if (norm < LSHFT(1))
		norm = LSHFT(1);
	for (i=1; i<cChebyY; i++)
	{
		dT = Div16(chebyY[i], norm) + LSHFT(1);
		dT >>= 1;
		if (dT >= 0x10000)
			dT = 0xFFFF;
		else if (dT < 0)
			dT = 0;
		*rgFeat++ = (unsigned short)dT;
	}
}

/******************************Private*Routine******************************\
* FeaturizeSegment
*
* Function to featurize one segment.  The pointinfo->xy array has the 
* the resampled points for the current stroke.  The indices iStart and iStop
* define the current segment.  pHead and pTail define the linked list of featurized
* segments until now.  All features are essentially computed here except the
* delta-x feature.
* 
* Returns TRUE on success.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
*  07-Aug-1998 -by- Angshuman Guha aguha
* Modified it.
*  29-Nov-1999 -by- Angshuman Guha aguha
* Switched to guide-independent featurization.
*  03-Feb-2000 -by- Angshuman Guha aguha
* Modified to accomodate change in segmentation from y-bottoms to points
* half-way between a bottom and the next top.
\**************************************************************************/
BOOL FeaturizeSegment(POINTINFO *pPointinfo, int iStart, int iStop, int iRef, NFEATURE **pHead, NFEATURE **pTail, int iStroke)
{
	// in the process of featurization, it modifies all points in pPointinfo->xy 
	// from iStart..iStop except the last one
	int *xy;
	NFEATURE *p;
	int chebyX[XCHEBY], chebyY[YCHEBY];
	int m, n, xvel, i, x, y, sumX, sumY, isumX, isumY, xVar, yVar;
	unsigned short *rgFeat;

	ASSERT(0 <= iStart);
	ASSERT(iStart <= iStop);
	ASSERT(iStop < pPointinfo->cPoint);

	// allocate space
	p = (NFEATURE *) ExternAlloc(sizeof(NFEATURE));
	ASSERT(p);
	if (!p)
		return FALSE;
	p->next = NULL;
	p->iStroke = (short)iStroke;
	p->iSecondaryStroke = -1;

	// start and stop points
	xy = pPointinfo->xy + iStart*2;
	p->startPoint.x = *xy++;
	p->startPoint.y = *xy;
	xy = pPointinfo->xy + iStop*2;
	p->stopPoint.x = *xy++;
	p->stopPoint.y = *xy;

	// rect
	xy = pPointinfo->xy + iStart*2;
	p->rect.left = p->rect.right = *xy++;
	p->rect.top = p->rect.bottom = *xy++;
	for (i=1; i<iStop-iStart+1; i++)
	{
		x = *xy++;
		if (x < p->rect.left)
			p->rect.left = x;
		else if (x > p->rect.right)
			p->rect.right = x;
		y = *xy++;
		if (y < p->rect.top)
		{
			p->rect.top = y;
		}
		else if (y > p->rect.bottom)
			p->rect.bottom = y;
	}
	ASSERT(iRef >= iStart);
	ASSERT(iRef <= iStop);
	p->refX = pPointinfo->xy[2*iRef];

	// compute x-velocity-at-end-of-segment feature
	if (iStop+2 < pPointinfo->cPoint)
		n = iStop+2;
	else
		n = pPointinfo->cPoint-1;
	if (iStop-2 >= iStart)
		m = iStop-2;
	else
		m = iStart;
	ASSERT(n >= m);
	xy = pPointinfo->xy + n*2;
	xvel = *xy;
	xy = pPointinfo->xy + 2*m;
	xvel -= *xy;
	if (n > m)
		xvel /= (n-m);

	// compute Chebychev features

    // compute X-mean and Y-mean
	xy = pPointinfo->xy + iStart*2;
    sumX = sumY = 0;
	for (i=iStop-iStart+1; i; i--)
	{
		sumX += (*xy++) - p->rect.left;
		sumY += (*xy++) - p->rect.top;
	}
	isumX = (sumX / (iStop-iStart+1)) + p->rect.left;
	isumY = (sumY / (iStop-iStart+1)) + p->rect.top;

    // shift points by means
	xy = pPointinfo->xy + iStart*2;
	for (i=iStop-iStart+1; i; i--)
	{
		*xy++ -= isumX;
		*xy++ -= isumY;
	}

	// compute variances
	xVar = yVar = 0;
	xy = pPointinfo->xy + iStart*2;
	for (i=iStop-iStart+1; i; i--)
	{
		if (*xy < 0)
			xVar -= *xy;
		else
			xVar += *xy;
		xy++;
		ASSERT(xVar >= 0);
		if (*xy < 0)
			yVar -= *xy;
		else
			yVar += *xy;
		xy++;
		ASSERT(yVar >= 0);
	}
	if ((xVar < 0) || (yVar < 0))
	{
		ExternFree(p);
		return FALSE;
	}
	xVar = xVar/(iStop-iStart+1);
	yVar = yVar/(iStop-iStart+1);
	if (xVar < 1)
		xVar = 1;
	if (yVar < 1)
		yVar = 1;

    // scale points by stndard deviation
	xy = pPointinfo->xy + iStart*2;
	for (i=iStop-iStart+1; i; i--)
	{
		*xy = LSHFT(*xy)/xVar;
		xy++;
		*xy = LSHFT(*xy)/yVar;
		xy++;
	}

    // X chebychev
	if (!LSCheby(pPointinfo->xy+2*iStart, iStop-iStart+1, chebyX, XCHEBY))
	{
		ExternFree(p);
		return FALSE;
	}

    // Y chebychev
	if (!LSCheby(pPointinfo->xy+2*iStart+1, iStop-iStart+1, chebyY, YCHEBY))
	{
		ExternFree(p);
		return FALSE;
	}

#ifdef RECONSTRUCTION_ERROR
	gxError += ReconError(pPointinfo->xy+2*iStart, iStop-iStart+1, chebyX, XCHEBY);
	gyError += ReconError(pPointinfo->xy+2*iStart+1, iStop-iStart+1, chebyY, YCHEBY);
#endif

	// restore the last point (it is shared by the next stroke)
	xy = pPointinfo->xy + iStop*2;
	*xy++ = p->stopPoint.x;
	*xy   = p->stopPoint.y;

	// now normalize and fill in the neural feature structure
	rgFeat = p->rgFeat;
	AddChebyFeatures(rgFeat, chebyX, XCHEBY, chebyY, YCHEBY);
	
	// height
	x = p->rect.bottom - p->rect.top + 1;
	x = LSHFT(x)/(6*pPointinfo->iyDev);  // between 0 and 1 98% of the time
	if (x > 0xFFFF)
		x = 0xFFFF;
	rgFeat[F_INDEX_HEIGHT] = (unsigned short)x;

	// width
	x = p->rect.right - p->rect.left + 1;
	x = LSHFT(x)/(6*pPointinfo->iyDev);  // between 0 and 1 99% of the time
	if (x > 0xFFFF)
		x = 0xFFFF;
	rgFeat[F_INDEX_WIDTH] = (unsigned short)x;

	// x-velocity
	xvel = LSHFT(xvel)/pPointinfo->iStepSize; // between -1 and +1 100% of the time
	xvel = (xvel + LSHFT(1)) >> 1;         // between 0 and 1
	if (xvel > 0xFFFF)
		xvel = 0xFFFF;
	else if (xvel < 0)
		xvel = 0;
	rgFeat[F_INDEX_XVELOCITY] = (unsigned short) xvel;

	// is this the first segment?
	rgFeat[F_INDEX_BOOLFIRSTSEG] = (iStart == 0) ? 0xFFFF : 0;

	// ratio of length-from-beginning-to-top over total-length
	if (iStop > iStart)
	{
		x = iRef - iStart;
		x = LSHFT(x)/(iStop-iStart);
		if (x > 0xFFFF)
			x = 0xFFFF;
		else if (x < 0)
			x = 0;
	}
	else
		x = 0x8000; // half
	rgFeat[F_INDEX_UPOVERTOTAL] = (unsigned short) x;

	//  remaining features (secondary segments)
	memset(rgFeat+CMAINFEATURE, 0, CSECONDARYFEATURE*sizeof(unsigned short));

	// compute maxRight (cumulative right-end for all segments so far) and
	// add new segment to linked list
	p->maxRight = p->rect.right;
	if (*pHead)
	{
		ASSERT(*pTail);
		if ((*pTail)->maxRight > p->maxRight)
			p->maxRight = (*pTail)->maxRight;
		(*pTail)->next = p;
	}
	else
		*pHead = p;
	*pTail = p;

	return TRUE;
}

/******************************Private*Routine******************************\
* FeaturizeSecondarySegment
*
* Function to featurize one secondary segment (delayed).
* Returns TRUE on success.
*
* History:
*  07-Aug-1998 -by- Angshuman Guha aguha
* Wrote it.
*  29-Nov-1999 -by- Angshuman Guha aguha
* Switched to guide-independent featurization.
*  03-Feb-2000 -by- Angshuman Guha aguha
* Modified to accomodate change in segmentation from y-bottoms to points
* half-way between a bottom and the next top.
\**************************************************************************/
BOOL FeaturizeSecondarySegment(POINTINFO *pPointinfo, RECT *pRect, NFEATURE *pDestination, int iStroke)
{
	// in the process of featurization, it modifies all points in pPointinfo->xy 
	int *xy;
	int chebyX[XCHEBY2], chebyY[YCHEBY2];
	int i, x, y, sumX, sumY, isumX, isumY, xVar, yVar, centerX, centerY;
	unsigned short *rgFeat;

	ASSERT(pDestination);
	ASSERT(!HAS_SECONDARY_SEGMENT(pDestination));

	// compute Chebychev features

    // compute X-mean and Y-mean
	xy = pPointinfo->xy;
    sumX = sumY = 0;
	for (i=pPointinfo->cPoint; i; i--)
	{
		sumX += (*xy++) - pRect->left;
		sumY += (*xy++) - pRect->top;
	}
	isumX = (sumX / pPointinfo->cPoint) + pRect->left;
	isumY = (sumY / pPointinfo->cPoint) + pRect->top;

    // shift points by means
	xy = pPointinfo->xy;
	for (i=pPointinfo->cPoint; i; i--)
	{
		*xy++ -= isumX;
		*xy++ -= isumY;
	}

	// compute variances
	xVar = yVar = 0;
	xy = pPointinfo->xy;
	for (i=pPointinfo->cPoint; i; i--)
	{
		if (*xy < 0)
			xVar -= *xy;
		else
			xVar += *xy;
		xy++;
		ASSERT(xVar >= 0);
		if (*xy < 0)
			yVar -= *xy;
		else
			yVar += *xy;
		xy++;
		ASSERT(yVar >= 0);
	}
	if ((xVar < 0) || (yVar < 0))
		return FALSE;
	xVar = xVar/pPointinfo->cPoint;
	if (xVar < 1)
		xVar = 1;
	yVar = yVar/pPointinfo->cPoint;
	if (yVar < 1)
		yVar = 1;

    // scale points by stndard deviation
	xy = pPointinfo->xy;
	for (i=pPointinfo->cPoint; i; i--)
	{
		*xy = LSHFT(*xy)/xVar;
		xy++;
		*xy = LSHFT(*xy)/yVar;
		xy++;
	}

    // X chebychev
	if (!LSCheby(pPointinfo->xy, pPointinfo->cPoint, chebyX, XCHEBY2))
		return FALSE;

    // Y chebychev
	if (!LSCheby(pPointinfo->xy+1, pPointinfo->cPoint, chebyY, YCHEBY2))
		return FALSE;

	// now normalize and fill in the neural feature structure
	rgFeat = pDestination->rgFeat;
	rgFeat[F_INDEX_BOOLSECONDARY] = 0xFFFF;
	AddChebyFeatures(rgFeat+F_INDEX_SECONDARYCHEBY, chebyX, XCHEBY2, chebyY, YCHEBY2);

	// width
	x = pRect->right - pRect->left + 1;
	x = LSHFT(x)/(6*pPointinfo->iyDev);  // between 0 and 1 99% of the time
	if (x > 0xFFFF)
		x = 0xFFFF;
	rgFeat[F_INDEX_SECONDARYWIDTH] = (unsigned short)x;

	// height
	y = pRect->bottom - pRect->top + 1;
	y = LSHFT(y)/(3*pPointinfo->iyDev);  // between 0 and 1 98% of the time
	if (y > 0xFFFF)
		y = 0xFFFF;
	rgFeat[F_INDEX_SECONDARYHEIGHT] = (unsigned short)y;

	pDestination->secondaryX = centerX = (pRect->left + pRect->right)/2;
	pDestination->secondaryY = centerY = (pRect->top + pRect->bottom)/2;

	// delta-x
	i = 2*(pDestination->rect.bottom - pDestination->rect.top + 1);
	x = centerX - pDestination->refX;
	x = LSHFT(x)/i;  // between -1 and 1 98% of the time
	x = (x + LSHFT(1)) >> 1;
	if (x > 0xFFFF)
		x = 0xFFFF;
	else if (x < 0)
		x = 0;
	rgFeat[F_INDEX_SECONDARYDX] = (unsigned short)x;

	// delta-y
	x = centerY - pDestination->rect.top;
	i *= 2;
	x = LSHFT(x)/i;  // between -1 and 1 97% of the time
	x = (x + LSHFT(1)) >> 1;
	if (x > 0xFFFF)
		x = 0xFFFF;
	else if (x < 0)
		x = 0;
	rgFeat[F_INDEX_SECONDARYDY] = (unsigned short)x;

	pDestination->iSecondaryStroke = (short)iStroke;

	return TRUE;
}

/******************************Private*Routine******************************\
* bIntersectingLineSegments
*
* Function to detect intersection of two straight line segments.
*
* History:
\**************************************************************************/
BOOL bIntersectingLineSegments(int x0, int y0, int x1, int y1,
							   int x2, int y2, int x3, int y3)
{
	// the basic idea is:
	// assume the line segments intersect at point (x,y)
	// then we have x = m*x0+(1-m)*x1 = n*x2+(1-n)*x3
	//          and y = m*y0+(1-m)*y1 = n*y2+(1-n)*y3
	// where 0 <= m,n <= 1
	// Solving the two equations for m and n we get:
	// m = (y32*x31-x32*y31)/(y32*x01-x32*y01)
	// n = (y01*x31-x01*y31)/(y01*x32-x01*y32)
	// where xij is xi - xj
	int numerator, denominator;

	// doing m
	denominator = (y3-y2)*(x0-x1)-(x3-x2)*(y0-y1);
	if (denominator == 0)
		return FALSE;
	numerator   = (y3-y2)*(x3-x1)-(x3-x2)*(y3-y1);
	if (numerator < 0)
	{
		if (denominator < 0)
		{
			numerator = -numerator;
			denominator = -denominator;
		}
		else
			return FALSE;
	}
	else if (numerator > 0)
	{
		if (denominator < 0)
			return FALSE;
	}
	ASSERT(numerator == 0 || (numerator > 0 && denominator > 0));
	if (numerator && (numerator > denominator))
		return FALSE;

	// doing n
	denominator = (y0-y1)*(x3-x2)-(x0-x1)*(y3-y2);
	if (denominator == 0)
		return FALSE;
	numerator   = (y0-y1)*(x3-x1)-(x0-x1)*(y3-y1);
	if (numerator < 0)
	{
		if (denominator < 0)
		{
			numerator = -numerator;
			denominator = -denominator;
		}
		else
			return FALSE;
	}
	else if (numerator > 0)
	{
		if (denominator < 0)
			return FALSE;
	}
	ASSERT(numerator == 0 || (numerator > 0 && denominator > 0));
	if (numerator && (numerator > denominator))
		return FALSE;

	return TRUE;
}

/******************************Private*Routine******************************\
* bIntersectingSegments
*
* Function to detect intersection of a straight line with an already 
* featurized segment.
*
* History:
*  03-Feb-2000 -by- Angshuman Guha aguha
* Modified to accomodate change in segmentation from y-bottoms to points
* half-way between a bottom and the next top.
\**************************************************************************/
BOOL bIntersectingSegments(NFEATURE *nfeat, int startx, int starty, int stopx, int stopy)
{
	// we approximate the segment with two straight lines:
	// start->ref and ref->stop
	if (bIntersectingLineSegments(nfeat->startPoint.x, nfeat->startPoint.y, nfeat->refX, nfeat->rect.top,
								  startx, starty, stopx, stopy)
		|| bIntersectingLineSegments(nfeat->refX, nfeat->rect.top, nfeat->stopPoint.x, nfeat->stopPoint.y,
									 startx, starty, stopx, stopy))
		return TRUE;

	return FALSE;
}

/******************************Private*Routine******************************\
* FindSecondaryPlace
*
* Function to identify an already featurized segment where a secondary segment
* will be attached.
*
* History:
*  07-Aug-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
NFEATURE *FindSecondaryPlace(NFEATURE *head, POINTINFO *pPointinfo, RECT *pRect)
{
	NFEATURE *nfeat;
	int startx, starty, stopx, stopy, *xy;

	// find first, if any, segment intersecting the secondary segment
	xy = pPointinfo->xy;
	startx = *xy++;
	starty = *xy;
	xy = pPointinfo->xy + pPointinfo->cPoint*2 - 2;
	stopx = *xy++;
	stopy = *xy;
	nfeat = head;
	while (nfeat && !bIntersectingSegments(nfeat, startx, starty, stopx, stopy))
		nfeat = nfeat->next;
	if (nfeat)
		// there is an overlap
		return nfeat;

	// find first, if any, segment X-overlapping the secondary segment
	nfeat = head;
	while (nfeat && !ONE_D_OVERLAP(nfeat->rect.left, nfeat->rect.right, pRect->left, pRect->right))
		nfeat = nfeat->next;
	if (nfeat)
		// there is an X-overlap
		return nfeat;

	return NULL;
}

/******************************Private*Routine******************************\
* FindSecondaryPlaceAgain
*
* History:
*  04-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
NFEATURE *FindSecondaryPlaceAgain(NFEATURE *head, RECT *pRect)
{
	NFEATURE *nfeat=head, *pDst=NULL;
	int mindist=0, dist;

	while (nfeat)
	{
		if (!HAS_SECONDARY_SEGMENT(nfeat))
		{
			dist = RECT_X_DISTANCE(nfeat->rect, *pRect);
			if (!pDst || (dist < mindist))
			{
				mindist = dist;
				pDst = nfeat;
			}
		}
		nfeat = nfeat->next;
	}

	if (!pDst)
		return NULL;  // all secondary segment slots are occupied!

	ASSERT(pDst);
	ASSERT(!HAS_SECONDARY_SEGMENT(pDst));

	return pDst;
}

/******************************Private*Routine******************************\
* bComplexStroke
*
* Function to determine whether a given (resampled) stroke is complex enough
* to be disqualified as one or more secondary segments.
*
* History:
*  07-Aug-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL bComplexStroke(POINTINFO *pPointinfo)
{
	int *xy, cPoint;
	int a, b, c, d, maxd, minx, miny;

	// is the stroke "complex"? roughly, we are trying to rule out st. lines and points
	// We will contruct a st. line equation joining the first and last points 
	// and compute the maximum deviation from it.
	// We will shift all points by (minx, miny) so as to avoid numerical overflow.
	// Let ax+by+c=0 be the st. line
	xy = pPointinfo->xy;
	cPoint = pPointinfo->cPoint-1;
	minx = *xy;
	miny = *++xy;
	for (; cPoint; cPoint--)
	{
		if (*++xy < minx)
			minx = *xy;
		if (*++xy < miny)
			miny = *xy;
	}
	// xy currently points to last y
	a = *xy - pPointinfo->xy[1];     //last y - first y
	b = pPointinfo->xy[0] - *(xy-1); //first x - last x
	c = -(pPointinfo->xy[0]-minx)*a - (pPointinfo->xy[1]-miny)*b;  // -a*(first x - minx) - b*(first y - miny)
	maxd = 0;
	xy = pPointinfo->xy;
	for (cPoint=pPointinfo->cPoint; cPoint; cPoint--)
	{
		d = a*(*xy++ - minx);
		d += b*(*xy++ - miny);
		d += c;
		if (d < 0)
			d = -d;
		if (d > maxd)  // LEFT FOR A RAINY DAY: can sometimes short-circuit computation right here
			maxd = d;
	}
	// normalize a, b, c to get correct distance
	d = ISqrt(a*a + b*b);
	if (d > 0)
		maxd /= d;
	if (maxd > 2*pPointinfo->iStepSize)
		return TRUE; // not simple enough
	return FALSE;
}

/******************************Private*Routine******************************\
* IsSecondaryStroke
*
* Function to determine whether a stroke (already resampled) is a secondary
* (delayed) one or not.  If it is, determines the previous segment that it
* is to attach to and then featurizes it.
*
* Returns 1 if it is a secondary stroke, 0 if it is not, -1 on error.
*
* History:
*  07-Aug-1998 -by- Angshuman Guha aguha
* Wrote it.
*  04-Sep-1998 -by- Angshuman Guha aguha
* Modified it.
*  21-Feb-2000 -by- Angshuman Guha aguha
* Changed Boolean return to int return.
\**************************************************************************/
int IsSecondaryStroke(POINTINFO *pPointinfo, NFEATURE **pHead, NFEATURE **pTail, int iStroke)
{
	int c, *xy;
	NFEATURE *lastButOne, *pDst;
	RECT rect;

	// to be a secondary stroke, it has to satisfy the following conditions:
	// 1. left-end is to the left of the right-end of the last segment
	// 2. left-end is to the left of the right-end of ink so far excluding the last segment
	// 3. if right-end is too far right, it is a simple stroke
	ASSERT(pPointinfo);
	ASSERT(pHead);
	ASSERT(pTail);

	// first stroke?
	if (!(*pTail))
		return 0;

	// one way this stroke is going to be primary is if it
	// is completely to the right of the ink-so-far excluding the 
	// the last segment
	ASSERT(*pHead);
	if (!((*pHead)->next))
		return 0;	// only one segment so far

	// find bounding rect of given stroke
	ASSERT(pPointinfo->cPoint > 0);
	xy = pPointinfo->xy;
	rect.left = rect.right = *xy++;
	rect.top = rect.bottom = *xy++;
	for (c=pPointinfo->cPoint-1; c; c--)
	{
		int x, y;
		x = *xy++;
		if (x < rect.left)
			rect.left = x;
		else if (x > rect.right)
			rect.right = x;
		y = *xy++;
		if (y < rect.top)
			rect.top = y;
		else if (y > rect.bottom)
			rect.bottom = y;
	}

	// condition 1
	if (rect.left >= (*pTail)->rect.right)
		return 0;

	// find the last-but-one segment (one exists!)
	lastButOne = *pHead;
	ASSERT(lastButOne);
	ASSERT(lastButOne->next);
	while (lastButOne->next->next)
	{
		lastButOne = lastButOne->next;
		ASSERT(lastButOne);
		ASSERT(lastButOne->next);
	}
	ASSERT(lastButOne);
	ASSERT(lastButOne->next == *pTail);

	// condition 2
	if (rect.left >= lastButOne->maxRight)
		return 0;

	// condition 3
	// another way this stroke can be primary is
	// if it extends beyond the segments so far and is complex enough
	if (rect.right > (*pTail)->maxRight + pPointinfo->delayedThreshold)
	{
		if (bComplexStroke(pPointinfo))
			return 0;
	}

	// at this point we know, this stroke is a secondary stroke

	pDst = FindSecondaryPlace(*pHead, pPointinfo, &rect);
	if (pDst && !pDst->next)
		return 0;  // since it is at the very end, we will consider it a primary feature
	if (!pDst || HAS_SECONDARY_SEGMENT(pDst))
		pDst = FindSecondaryPlaceAgain(*pHead, &rect);
	//if (pDst && pDst->next)
	if (pDst)
	{
		if (!FeaturizeSecondarySegment(pPointinfo, &rect, pDst, iStroke))
			return -1;
		else
			return 1;
	}
	else
		return 0;
}

/******************************Private*Routine******************************\
* FeaturizeStroke
*
* Function to re-sample, segment and featurize a single stroke.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
*  03-Feb-2000 -by- Angshuman Guha aguha
* Changed segmentation from y-bottoms 
* to points half-way between a bottom and the next top.
\**************************************************************************/
BOOL FeaturizeStroke(FRAME *frame, NFEATURESET *pFeatSet, NFEATURE **pTail, POINTINFO *pPointinfo, int iStroke, int iStrokeLength)
{
	int iLastSeg, y, iLastBottom, iLastTop;
	int *rgY, c, ymin, ymax, yprevious, hysteresis;
	int imax, imin, itoggle, diff, i, iXY, cXY;
	XY *rgXY;
	NFEATURE		**pHead = &pFeatSet->head;

	// estimate count of points after re-sampling
	pPointinfo->cPointMax = 1 + iStrokeLength/pPointinfo->iStepSize;

	// allocate space for resampling
	pPointinfo->xy = (int *) ExternAlloc(2*pPointinfo->cPointMax*sizeof(int));
	ASSERT(pPointinfo->xy);
	if (!pPointinfo->xy)
	{
		return FALSE;
	}

	// re-sample points
	rgXY = RgrawxyFRAME(frame);
	cXY = CrawxyFRAME(frame);
	ASSERT(cXY > 0);
	pPointinfo->cPoint = 0;
	for (iXY=0; iXY<cXY; iXY++)
	{
		if (!AddPoint(pPointinfo, rgXY[iXY].x, rgXY[iXY].y))
		{
			ExternFree(pPointinfo->xy);
			return FALSE;
		}
	}

	// is this a secondary stroke (delayed) ?
	switch(IsSecondaryStroke(pPointinfo, pHead, pTail, iStroke))
	{
	case -1:
		ExternFree(pPointinfo->xy);
		return FALSE;
	case 1:
		ExternFree(pPointinfo->xy);
		return TRUE;
	case 0:
		break;
	default:
		ASSERT(0);
	}

	++pFeatSet->cPrimaryStroke;

	// segment stroke at y-optima and featurize each segment
	c = pPointinfo->cPoint;
	ASSERT(c > 0);
	if (c <= 0)
	{
		ExternFree(pPointinfo->xy);
		return FALSE;
	}
	rgY = pPointinfo->xy + 1;
	yprevious = ymin = ymax = *rgY;
	imax = imin = 0;
	itoggle = 0;
	hysteresis = pPointinfo->hysteresis;
	iLastSeg = 0;
	iLastBottom = -1;
	iLastTop = 0;
	for (i=1, rgY+=2; i<c; i++, rgY+=2)
	{
		y = *rgY;
		if (y < ymin)
		{
			ymin = y;
			imin = i;
		}
		if (y > ymax)
		{
			ymax = y;
			imax = i;
		}
		if (y > yprevious)
		{
			// y is currently increasing
			diff = y - ymin;
			if ((itoggle < 0) && (diff > hysteresis))
			{
				// we found a top!
				if (iLastBottom >= 0)
				{
					int iSeg = (iLastBottom + imin)/2;
					if (!FeaturizeSegment(pPointinfo, iLastSeg, iSeg, iLastTop, pHead, pTail, iStroke))
					{
						ExternFree(pPointinfo->xy);
						return FALSE;
					}
					(*pTail)->pMyFrame = frame;
					iLastSeg = iSeg;
				}
				itoggle = 1;
				ymax = y;
				imax = i;
				iLastTop = imin;
			}
			else if ((!itoggle) && (diff > hysteresis))
				itoggle = 1;
		}
		else
		{
			// y is currently decreasing
			diff = ymax - y;
			if ((itoggle > 0) && (diff > hysteresis))
			{
				// we found a bottom!
				iLastBottom = imax;
				itoggle = -1;
				ymin = y;
				imin = i;
			}
			else if ((!itoggle) && (diff > hysteresis))
				itoggle = -1;
		}
		yprevious = y;
	}
	if (!FeaturizeSegment(pPointinfo, iLastSeg, c-1, iLastTop, pHead, pTail, iStroke))
	{
		ExternFree(pPointinfo->xy);
		return FALSE;
	}
	(*pTail)->pMyFrame = frame;
	ExternFree(pPointinfo->xy);
	return TRUE;
}

/******************************Private*Routine******************************\
* DistanceToGhost
*
* Function to find the closest secondary segment from a primary segment which
* has no secondary segment attached to it.
*
* History:
*  09-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
*  29-Nov-1999 -by- Angshuman Guha aguha
* Modified to switch to guide-independent featurization.
*  03-Feb-2000 -by- Angshuman Guha aguha
* Modified to accomodate change in segmentation from y-bottoms to points
* half-way between a bottom and the next top.
\**************************************************************************/
int DistanceToGhost(NFEATURE *node, NFEATURE *head, int *py)
{
	while (head)
	{
		if (HAS_SECONDARY_SEGMENT(head))
			break;
		head = head->next;
	}
	if (!head)
	{
		*py = 0;
		return 2*(node->rect.bottom - node->rect.top + 1);
	}
	*py = head->secondaryY - node->rect.top;
	return head->secondaryX - node->refX;
}

/******************************Private*Routine******************************\
* AddGhostSecondary
*
* Function to record delta-x and delta-y values the closest secondary segment
* from a primary segment which has no secondary segment attached to it.
*
* History:
*  09-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
*  29-Nov-1999 -by- Angshuman Guha aguha
* Modified to switch to guide-independent featurization.
\**************************************************************************/
void AddGhostSecondary(NFEATURE *node, int x, int y)
{
	int scale = 2*(node->rect.bottom - node->rect.top + 1);

	x = LSHFT(x)/scale;  // between -1 and +1 76% of the time
	x = (x + LSHFT(1)) >> 1;
	if (x > 0xFFFF)
		x = 0xFFFF;
	else if (x < 0)
		x = 0;
	node->rgFeat[F_INDEX_SECONDARYDX] = (unsigned short)x;

	scale *= 2;
	y = LSHFT(y)/scale;  // between -1 and +1 97% of the time
	y = (y + LSHFT(1)) >> 1;
	if (y > 0xFFFF)
		y = 0xFFFF;
	else if (y < 0)
		y = 0;
	node->rgFeat[F_INDEX_SECONDARYDY] = (unsigned short)y;
}

/******************************Private*Routine******************************\
* DoGhostSecondaryPositions
*
* Function to do a scan through the segments to define secondary segment delta-x
* and delta-y positions on empty slots.  The idea is that if a primary segment 
* does not have a secondary segment attached to it, it atleast knows the delta-x
* and delta-y for the delayed stroke closest to it.
*
* History:
*  09-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
*  29-Nov-1999 -by- Angshuman Guha aguha
* Modified to switch to guide-independent featurization.
\**************************************************************************/
void DoGhostSecondaryPositions(NFEATURE *head, POINTINFO *pPointinfo)
{
	// do one final scan through the segments to define the secondary segment X positions on
	// empty slots;   the idea is that 

	NFEATURE *node, *left, *right;

	// we traverse the singly linked list in such a way that when we are at any particular node
	// we have a pointer to the left-part of the list (reversed)
	// and a pointer to the right-part of the list
	if (!head)
		return;

	left = NULL;
	node = head;
	while (node)
	{
		right = node->next;
		if (!HAS_SECONDARY_SEGMENT(node))
		{
			int x1, x2, y1, y2;
			x1 = DistanceToGhost(node, left, &y1);
			x2 = DistanceToGhost(node, right, &y2);
			if (ABS(x1) < ABS(x2))
				AddGhostSecondary(node, x1, y1);
			else
				AddGhostSecondary(node, x2, y2);
		}
		node->next = left;
		left = node;
		node = right;
	}

	// now we have to undo the reversal of the the linked list
	node = left;
	left = NULL;
	while (node)
	{
		right = node->next;
		node->next = left;
		left = node;
		node = right;
	}

	ASSERT(left == head);
}

/******************************Public*Routine******************************\
* YDeviation
*
* Function to compute average deviation of the y values in a sequence of 
* strokes (frames).
* This is not exactly standard deviation.  But it is a lot cheaper and
* close enough.  (See analysis and comments in Numerical Recipes in C).
*
* History:
*  02-Sep-1999 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int YDeviation(GLYPH *pGlyph)
{
	int count, ymin, sum, ymean;
	GLYPH *glyph;
	FRAME *frame;

	if (pGlyph && pGlyph->frame && RgrawxyFRAME(pGlyph->frame))
	{
		ymin = RgrawxyFRAME(pGlyph->frame)->y;
		count = 0;
		sum = 0;
	}
	else
		return 1;

	// find min and mean in one scan
	for (glyph=pGlyph; glyph; glyph=glyph->next)
	{
		XY *xy;
		int cxy;

		frame = glyph->frame;
		xy = RgrawxyFRAME(frame);
		cxy = CrawxyFRAME(frame);

		for (; cxy; xy++, cxy--)
		{
			int y;

			y = xy->y;
			if (y < ymin)
			{
				sum += count*(ymin - y);
				ymin = y;
			}
			sum += y - ymin;
			count++;
		}
	}
	ASSERT(count > 0);
	ymean = sum/count + ymin;

	// find average deviation
	sum = 0;
	for (glyph=pGlyph; glyph; glyph=glyph->next)
	{
		XY *xy;
		int cxy;

		frame = glyph->frame;
		xy = RgrawxyFRAME(frame);
		cxy = CrawxyFRAME(frame);

		for (; cxy; xy++, cxy--)
		{
			int diff;

			diff = xy->y - ymean;
			if (diff < 0)
				sum -= diff;
			else
				sum += diff;
		}
	}

	sum = sum/count;
	if (sum < 1)
		sum = 1;
	return sum;
}

/******************************Private*Routine******************************\
* StrokeLength
*
* Function to estimate the length of a stroke.  It computes an over-estimate
* as cheaply as possibly (no squaring or square-rooting).
*
* History:
*  02-Dec-1999 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int StrokeLength(FRAME *frame)
{
	int sum, dx, dy;
	int iXY, cXY;
	XY *rgXY;

	rgXY = RgrawxyFRAME(frame);
	cXY = CrawxyFRAME(frame);
	ASSERT(cXY > 0);
	sum = 0;
	for (iXY=1; iXY<cXY; iXY++)
	{
		// Manhattan (aka city-block) distance
		dx = rgXY[iXY].x - rgXY[iXY-1].x;
		if (dx < 0)
			sum -= dx;
		else
			sum += dx;
		dy = rgXY[iXY].y - rgXY[iXY-1].y;
		if (dy < 0)
			sum -= dy;
		else
			sum += dy;
	}
	return sum; // an overestimate of length
}

/******************************Private*Routine******************************\
* AdjustStepSize
*
* Function to increase the resampling step size if the given step size 
* results in a blowup of the number of points.
*
* History:
*  02-Dec-1999 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int AdjustStepSize(FRAME *frame, int iStepSize, int iStrokeLength)
{
	int cPointOld, cPointNew;

	cPointOld = CrawxyFRAME(frame);
	cPointNew = 1 + iStrokeLength/iStepSize;
	if (cPointNew > 10*cPointOld)
	{
		int iNewStep;

		iNewStep = iStrokeLength/(10*cPointOld);
		ASSERT(iNewStep >= iStepSize);
		return iNewStep;
	}
	return iStepSize;
}

/******************************Public*Routine******************************\
* FeaturizeLine
*
* Function to featurize an ink sample.  This is the top-level featurization 
* function called by the recognizer.
* Most of the real work is done by sub-functions called here.  The computation
* of delta-x position feature for each segment is done here.
*
* History:
*  03-Nov-1997 -by- Angshuman Guha aguha
* Wrote it.
*  06-Mar-1998 -by- Angshuman Guha aguha
* Modified it.
*  06-Aug-1998 -by- Angshuman Guha aguha
* Major modificaton.  Added secondary segments (delayed).
*  01-Sep-1999 -by- Angshuman Guha aguha
* Added capability to featurize multi-line data.
*  28-Nov-1999 -by- Angshuman Guha aguha
* Removed multi-line capability.  
* Featurization now completely independent of guide.
* Renamed from FeaturizeSample to FeaturizeLine.
*  03-Feb-2000 -by- Angshuman Guha aguha
* Modified to accomodate change in segmentation from y-bottoms to points
* half-way between a bottom and the next top.
\**************************************************************************/
NFEATURESET *FeaturizeLine(GLYPH *pGlyph, int yDev)
{
	int iStroke, cStroke;
	GLYPH *glyph;
	NFEATURESET *nfeatureset = NULL;
	NFEATURE *tail;
	FRAME *frame;
	int x, lastRefX, height, lastHeight, width, lastWidth, lastRight, midY, lastMidY;
	NFEATURE *p;
	POINTINFO pointinfo;
	int *rgStrokeLength;

	// compute cStroke
	for (cStroke=0, glyph=pGlyph; glyph; glyph=glyph->next)
	{
		if (!IsVisibleFRAME(glyph->frame))
			continue;
		cStroke++;
	}
	if (cStroke < 1)
		return NULL;

	// alloc FEATURESET
	nfeatureset = CreateNFEATURESET();
	ASSERT(nfeatureset);
	if (!nfeatureset)
		return NULL;
	tail = NULL;

	// This y-deviation value was emperically found to lie between 3% and 12% of the
	// guide box height (cyBox) for 50 randomly selected files out of curall02.ste.
	// The average value was about 7.7% of the guide box height.
	// At the time of writing this comment, we are switching from a guide-box-height-dependent
	// featurization to using the y-deviation.
	// -Angshuman Guha, aguha, 9/2/99

	// compute step size
	pointinfo.iyDev = yDev < 0 ? YDeviation(pGlyph) : yDev;
	if (pointinfo.iyDev < 1)
		pointinfo.iyDev = 1;  // a "-" or a "."
	pointinfo.iStepSize =  pointinfo.iyDev/5;  // pGuide->cyBox*3/200; // 1.5% of box height
	if (pointinfo.iStepSize < 2)
		pointinfo.iStepSize = 2;
	x = pointinfo.iStepSize;
	rgStrokeLength = (int *) ExternAlloc(cStroke*sizeof(int));
	if (!rgStrokeLength)
	{
		DestroyNFEATURESET(nfeatureset);
		return NULL;
	}
	for (iStroke=0, glyph=pGlyph; glyph; glyph=glyph->next)
	{
		if (!IsVisibleFRAME(glyph->frame))
			continue;
		rgStrokeLength[iStroke] = StrokeLength(glyph->frame);
		pointinfo.iStepSize = AdjustStepSize(glyph->frame, pointinfo.iStepSize, rgStrokeLength[iStroke]);
		iStroke++;
	}
	ASSERT(pointinfo.iStepSize >= x);
	if (pointinfo.iStepSize > x)
	{
		pointinfo.iyDev = 5*pointinfo.iStepSize;
	}
	pointinfo.iStepSizeSqr = pointinfo.iStepSize * pointinfo.iStepSize;
	nfeatureset->iyDev = (unsigned short)pointinfo.iyDev;

	// compute hysteresis, guide values and threshold for detecting delayed strokes
	pointinfo.hysteresis = pointinfo.iyDev/4;  // pGuide->cyBox/50;  // 2% of box height
	// pointinfo.cBoxHeight = pGuide->cyBox;
	pointinfo.delayedThreshold = pointinfo.iyDev; // pGuide->cyBox*2/25; // 8% of box height
	// pointinfo.cBoxBaseline = pGuide->yOrigin + iLine*pointinfo.cBoxHeight + pGuide->cyBase;

	// featurize all strokes
	for (iStroke=0, glyph=pGlyph; glyph; glyph=glyph->next)
	{
		frame = glyph->frame;
		if (!IsVisibleFRAME(frame))
			continue;
		// just use the current frame
		if (!FeaturizeStroke(frame, nfeatureset, &tail, &pointinfo, frame->iframe, rgStrokeLength[iStroke]))
		{
			DestroyNFEATURESET(nfeatureset);
			ExternFree(rgStrokeLength);
			return NULL;
		}
		iStroke++;
	}
	ExternFree(rgStrokeLength);

	// compute some of the features and count of segment
	p = nfeatureset->head;
	ASSERT(p);
	p->rgFeat[F_INDEX_DELTAX] = 0xFFFF;
	lastHeight = -1;
	while (p)
	{
		nfeatureset->cSegment++;
		height = p->rect.bottom - p->rect.top + 1;
		width = p->rect.right - p->rect.left + 1;
		midY = (p->rect.bottom + p->rect.top)/2;

		if (lastHeight < 0)
		{
			// first segment
			p->rgFeat[F_INDEX_DELTAX] = 0xFFFF;
			p->rgFeat[F_INDEX_DELTAY] = 0xFFFF;
			p->rgFeat[F_INDEX_PREVHEIGHT] = 0;
			p->rgFeat[F_INDEX_PREVWIDTH] = 0;
			p->rgFeat[F_INDEX_XOVERLAP] = 0;
		}
		else
		{
			// delta-x
			x = p->refX - lastRefX;
			x = LSHFT(x)/(3*(lastHeight+height));  // between -1 and +1 94% of the time
			x = (x + LSHFT(1))>>1;          // between 0 and 1
			if (x > 0xFFFF)
				x = 0xFFFF;
			else if (x < 0)
				x = 0;
			p->rgFeat[F_INDEX_DELTAX] = (unsigned short)x;

			// delta-y
			x = midY - lastMidY;
			x = LSHFT(x)/(3*(lastHeight+height));  // between -1 and +1 94% of the time
			x = (x + LSHFT(1))>>1;          // between 0 and 1
			if (x > 0xFFFF)
				x = 0xFFFF;
			else if (x < 0)
				x = 0;
			p->rgFeat[F_INDEX_DELTAY] = (unsigned short)x;

			// height of prev seg
			x = LSHFT(lastHeight)/(lastHeight+height);  // between 0 and 1 by definition 
														// distribution is a gaussian superimposed on a uniform
			p->rgFeat[F_INDEX_PREVHEIGHT] = (unsigned short)x;

			// width of prev seg
			x = LSHFT(lastWidth)/(lastWidth+width);  // between 0 and 1 by definition 
													 // gaussian + uniform (more gaussian than above)
			p->rgFeat[F_INDEX_PREVWIDTH] = (unsigned short)x;

			// x overlap with prev segment
			if (p->rect.left <= lastRight)
			{
				x = LSHFT(lastRight - p->rect.left + 1)/(2*width);  // between 0 and 1 92% of the time
				if (x > 0xFFFF)
					x = 0xFFFF;
				p->rgFeat[F_INDEX_XOVERLAP] = (unsigned short)x;
			}
			else
			{
				p->rgFeat[F_INDEX_XOVERLAP] = 0;
			}
		}

		// height and width of next seg
		if (p->next)
		{
			int nextHeight = p->next->rect.bottom - p->next->rect.top + 1;
			int nextWidth = p->next->rect.right - p->next->rect.left + 1;

			x = LSHFT(nextHeight)/(height+nextHeight);  // between 0 and 1 by definition 
													// distribution is a gaussian superimposed on a uniform
			p->rgFeat[F_INDEX_NEXTHEIGHT] = (unsigned short)x;

			x = LSHFT(nextWidth)/(width+nextWidth);  // between 0 and 1 by definition 
												 // gaussian + uniform (more gaussian than above)
			p->rgFeat[F_INDEX_NEXTWIDTH] = (unsigned short)x;
		}
		else
		{
			p->rgFeat[F_INDEX_NEXTHEIGHT] = 0;
			p->rgFeat[F_INDEX_NEXTWIDTH] = 0;
		}

		// go to next segment
		lastRefX = p->refX;
		lastHeight = height;
		lastWidth = width;
		lastRight = p->rect.right;
		lastMidY = midY;
		p = p->next;
	}

	// do one final scan through the segments to define the secondary X positions on
	// empty slots;   the idea is that if a primary segment does not have a secondary segment
	// attached to it, it atleast knows the delta-x for the delayed stroke
	// closest to it
	DoGhostSecondaryPositions(nfeatureset->head, &pointinfo);

	return nfeatureset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\panlfeat.h ===
// panlfeat.h

#ifndef _PANELFEAT_H
#define _PANELFEAT_H

#include "nfeature.h"

#ifdef __cplusplus
extern "C" {
#endif

NFEATURESET *FeaturizePanel(GLYPH *pGlyph, const GUIDE *pGuide);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\nfeature.h ===
#ifndef _NFEATURE_H
#define _NFEATURE_H

#ifdef __cplusplus
extern "C" {
#endif

#define XCHEBY 10
#define YCHEBY 6
#define XCHEBY2 4
#define YCHEBY2 4
#define CMAINFEATURE (XCHEBY - 1 + YCHEBY - 1 + 12)
#define CSECONDARYFEATURE (XCHEBY2 - 1 + YCHEBY2 - 1 + 5)
#define CNEURALFEATURE (CMAINFEATURE + CSECONDARYFEATURE)

typedef struct tagNFEATURE {
	unsigned short rgFeat[CNEURALFEATURE];
	// the CNEURALFEATURE features are
	// 00. the first XCHEBY-1 are the normlized x-Chebychev coefficients
	// 08. ...
	// 09  the next YCHEBY-1 are the normalized y-Chebychev coefficients
	// 13. ...
	// 14. height: h/(6*yDev)
	// 15. height of i-1'th segment: h(i-1)/[h(i-1) + h(i)]
	// 16. height of i+1'th segment: h(i+1)/[h(i) + h(i+1)]
	// 17. width:  w/(6*yDev)
	// 18. width of i-1'th segment: w(i-1)/[w(i-1) + w(i)]
	// 19. width of i+1'th segment: w(i+1)/[w(i) + w(i+1)]
	// 20. x-velocity at end of segment (signed)
	// 21. delta-x of ref from previous ref: dx/(3*(h(i-1)+h(i)))  (signed)
	// 22. delta-y of mid-y from previous mid-y: dy/(3*(h(i-1)+h(i)))  (signed)
	// 23. Boolean: 1 if first segment of a stroke, 0 otherwise
	// 24. ratio of length-from-beginning-to-top to total-length: computed by counting resampled points
	// 25. x-overlap with previous segment over twice the width
	//
	// 26. Boolean: presence of a secondary segment (delayed)
	// 27. XCHEBY2-1 x-Chebychev coefficients for the secondary segment
	// 29. ...
	// 30. YCHEBY2-1 y-Chebychev coefficients for the secondary segment
	// 32. ...
	// 33. height of secondary segment: h/(3*yDev)
	// 34. width of secondary segment: w/(6*yDev)
	// 35. delta-x of secondary segment's midx from primary segment's ref: dx/(2*primary h) (signed)
	// 36. delta-y of secondary segment's midy from primary segment's ref: dy/(4*primary h) (signed)

	// all unsigned features take values in the range 0<= .. <=1
	// all signed features take values in the range -1<= .. <=1 and are then scaled and shifted to 0<= .. <=1

	// the following fields are used only during featurization
	int refX;  // usually the x value for the local y-top; if no local y-top, it is the first x
	RECT rect;
	int maxRight;
	int secondaryX;
	int secondaryY;
	short iStroke;
	short iSecondaryStroke;
	POINT startPoint;
	POINT stopPoint;

	// next segment
	FRAME	*pMyFrame;			// Who gave me life
	struct tagNFEATURE *next;
} NFEATURE;

typedef struct {
	NFEATURE *head;
	unsigned short cSegment;
	unsigned short cPrimaryStroke;		// Number of Primary strokes
	unsigned short iPrint;				// Likelihood of ink being print
	unsigned short iyDev;
	// can put global features here
} NFEATURESET;

#define F_INDEX_HEIGHT 14
#define F_INDEX_PREVHEIGHT 15
#define F_INDEX_NEXTHEIGHT 16
#define F_INDEX_WIDTH 17
#define F_INDEX_PREVWIDTH 18
#define F_INDEX_NEXTWIDTH 19
#define F_INDEX_XVELOCITY 20
#define F_INDEX_DELTAX 21
#define F_INDEX_DELTAY 22
#define F_INDEX_BOOLFIRSTSEG 23
#define F_INDEX_UPOVERTOTAL 24
#define F_INDEX_XOVERLAP 25
#define F_INDEX_BOOLSECONDARY 26
#define F_INDEX_SECONDARYCHEBY 27
#define F_INDEX_SECONDARYHEIGHT 33
#define F_INDEX_SECONDARYWIDTH 34
#define F_INDEX_SECONDARYDX 35
#define F_INDEX_SECONDARYDY 36

#define HAS_SECONDARY_SEGMENT(nfeature) ((nfeature)->rgFeat[F_INDEX_BOOLSECONDARY])
#define IS_FIRST_SEGMENT(nfeature) ((nfeature)->rgFeat[F_INDEX_BOOLFIRSTSEG])

NFEATURESET *FeaturizeLine(GLYPH *pGlyph, int yDev);
void DestroyNFEATURESET(NFEATURESET *p);
NFEATURESET *CreateNFEATURESET(void);
int YDeviation(GLYPH *pGlyph);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\cacorder.c ===
#include <float.h>
#include "common.h"
#include "score.h"
#include "math16.h"
#include "hound.h"
#include "houndp.h"

//Assumes that a stroke is four subsequent features.	 
double lLogDensityStroke(
	const BYTE		* const pSampleVector,
	int				iFeatBegin,
	HOUND_MATCH		*pHoundMatch,
	HOUND_PER_FEAT	*pPerFeature,
	HOUND_DEPEND	*pHoundDepend)
{
	double		eLogDensity;

	int iFeat;
	int iFeatEnd	= iFeatBegin + 4;

	// The precomputed part of the gaussian cannot be used here, due to the fact that not all variables
	// are considered. So we will have to compute this part.
	// JOHN: If speedup needed, ask how! One possibility is to save a pre-computed value
	// associated with each stroke in the model, another possibility would be to pre-compute these
	// values before any CAC takes place.
	eLogDensity = 0.0;

	for (iFeat = iFeatBegin; iFeat < iFeatEnd; iFeat++)
	{
		double	eMeanOffset;
		double	eTemp;

		// The Gaussian mean, computed as the unconditional mean plus
		// contribution from dependors...

		// The unconditional mean offset
		eMeanOffset	= pPerFeature[iFeat].eMeanOffset;
		ASSERT(eMeanOffset > -16.0 && eMeanOffset < 16.0);

		// While dependency is for the current feature ...
		// WARNING: This requires that the dependencies are ordered
		// by the depende of each!!!!
		while (pHoundDepend->iDepende == iFeat)
		{
			// The contribution to mean from single dependor. 
			// Ex: coeff_ab * (x_b - mean_b)
			eMeanOffset		-= pHoundDepend->eWeight 
				* pPerFeature[pHoundDepend->iDependor].eMeanOffset;

			// Now fetch next dependency.
			FetchDepend(pHoundMatch, pHoundDepend);
		}

		//  The normalization for the Gaussian. This correspond to the otherwise precomputed part
		// -1/2 * log(2*pi*variance)
		 eTemp	= -0.5 * log(2.0 * 3.141592654 * pPerFeature[iFeat].eVariance);
		 eLogDensity	+= eTemp;

		// Add log-density contribution for variable to the component log-density
		 eTemp = lGaussianExponent(
			eMeanOffset, pPerFeature[iFeat].eVariance
		);
		 eLogDensity	+= eTemp;
	}

	ASSERT(eLogDensity > -1e100);
	ASSERT(eLogDensity < 0.0);
	return eLogDensity;
}

// Fetch the values for the diagonal. Special version for CAC preporder
void FetchDiagonalCacPreOrder(
	int				numFeatSample,
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch,
	HOUND_PER_FEAT	*pPerFeature
)
{
	LONG			temp;
	int				iVariable;
	RECT			BBoxSample;
	RECT			BBoxModel;
	double			offset1X, offset1Y;
	double			offset2X, offset2Y;
	double			scaleX, scaleY;

	// To scale ink to match part of character, we need BBox of both sample and the
	// matching strokes in the model.
	BBoxSample.top		= 256;
	BBoxSample.left		= 256;
	BBoxSample.bottom	= 0;
	BBoxSample.right	= 0;
	BBoxModel.top		= 256;
	BBoxModel.left		= 256;
	BBoxModel.bottom	= 0;
	BBoxModel.right		= 0;

	for (iVariable = 0; iVariable < numFeatSample; ++iVariable)
	{
		// Table to decode variances:	
		static const double	aDecodeVariance[8]	= {
//			0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0	// Org
//			1.0, 1.5, 2.0, 3.0, 5.0, 8.0, 16.0, 32.0	// V1
			0.5, 0.75, 1.5, 2.5, 4.0, 8.0, 16.0, 32.0	// V2
//			1.5, 2.0, 2.5, 3.0, 5.0, 8.0, 16.0, 32.0	// V3
		};

		// Each mean has 4.1 bits and each variance is encoded in 3.
		temp	= (DWORD)(*pHoundMatch->pScanData++);

		// Save the mean until we can do our scaling.
		pPerFeature[iVariable].eMeanOffset	= FixNToFloat(temp & 0x1F, 1);

		// Top 3 bits control the variance.
		pPerFeature[iVariable].eVariance	= aDecodeVariance[temp >> 5];

		// Do BBox computations.
		if (iVariable & 0x0001)
		{
			// Y value (times 2) 
			BBoxModel.top		= min(BBoxModel.top, temp & 0x1F);
			BBoxModel.bottom	= max(BBoxModel.bottom, temp & 0x1F);
			BBoxSample.top		= min(BBoxSample.top, pSampleVector[iVariable] << 1);
			BBoxSample.bottom	= max(BBoxSample.bottom, pSampleVector[iVariable] << 1);
		}
		else
		{
			// X value (times 2)
			BBoxModel.left		= min(BBoxModel.left, (temp & 0x1F));
			BBoxModel.right		= max(BBoxModel.right, (temp & 0x1F));
			BBoxSample.left		= min(BBoxSample.left, pSampleVector[iVariable] << 1);
			BBoxSample.right	= max(BBoxSample.right, pSampleVector[iVariable] << 1);
		}
	}

	// Skip unmatched features.
	for (; iVariable < pHoundMatch->numFeat; ++iVariable)
	{
		++pHoundMatch->pScanData;
	}

	// Compute offset and scaling for data values.
	offset1X	= FixNToFloat(-BBoxSample.left, 1);
	offset2X	= FixNToFloat(BBoxModel.left, 1);
	if (BBoxModel.right == BBoxModel.left || BBoxSample.right == BBoxSample.left)
	{
		// Degenerate scaling, just use 1.0
		scaleX		= 1.0;
	}
	else
	{
		scaleX		= FixNToFloat((BBoxModel.right - BBoxModel.left), 1)
					/ FixNToFloat((BBoxSample.right - BBoxSample.left), 1);

	}
	offset1Y	= FixNToFloat(-BBoxSample.top, 1);
	offset2Y	= FixNToFloat(BBoxModel.top, 1);
	if (BBoxModel.bottom == BBoxModel.top || BBoxSample.bottom == BBoxSample.top)
	{
		// Degenerate scaling, just use 1.0
		scaleY		= 1.0;
	}
	else
	{
		scaleY		= FixNToFloat((BBoxModel.bottom - BBoxModel.top), 1)
					/ FixNToFloat((BBoxSample.bottom - BBoxSample.top), 1);
	}

	// Rescale and convert means to mean offsets.
	for (iVariable = 0; iVariable < numFeatSample; iVariable += 2)
	{
		double	eTemp;
		// Subtract mean from actual to	compute the offset.
		eTemp	= ((double)pSampleVector[iVariable] + offset1X) * scaleX + offset2X
				- pPerFeature[iVariable].eMeanOffset;
		ASSERT(eTemp > -16.0 && eTemp < 16.0);
		pPerFeature[iVariable].eMeanOffset		= eTemp;	
		eTemp	= ((double)pSampleVector[iVariable + 1] + offset1Y) * scaleY + offset2Y
				- pPerFeature[iVariable + 1].eMeanOffset;
		ASSERT(eTemp > -16.0 && eTemp < 16.0);
		pPerFeature[iVariable + 1].eMeanOffset	= eTemp;	
	}
}

// Compute log density for multivariate Gaussian as the sum of log densities
// for each variable in the model. The density for a single variable 'depende'
// is a linear regression on 'dependors'.
//
// Example: Let variable 'a' depend on variable 'b' and 'c'. Then the log
// density for this variable will be the Gaussian log density 
// log p(x_a | mean, variance), where
//		x_a is the observation for variable a
//		mean is computed as mean_a + coeff_ab * (x_b - mean_b) 
//			+ coeff_ac * (x_c - mean_c)
//		variance is variance_a
//		mean_a is the (unconditional) mean for variable a
//		variance_a is the (conditional) variance for a
//		coeff_ab is linear regression coefficient for a given b
double lLogDensityComponentCacPreOrder(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch,
	int				numFeatSample
) {
	double			eLogDensity;
	int				iVariable;
	HOUND_DEPEND	houndDepend;
	HOUND_PER_FEAT	aPerFeature[MAX_HOUND_FEATURES];
	UNALIGNED short	*pFetchShort;

	// Comp. factor is stored in signed 10.6 format in two bytes.
	// We want it int 16.16 format in a LONG.
	// Don't use for prefix mode.
	pFetchShort	= (short *)pHoundMatch->pScanData;
	//eLogDensity = FixNToFloat((LONG)*pFetchShort, 6);
	pHoundMatch->pScanData	+= 2;

	eLogDensity	= 0.0;

	// Fetch the values for the diagonal.
	FetchDiagonalCacPreOrder(numFeatSample, pSampleVector, pHoundMatch, aPerFeature);

	// Prefetch first dependency.
	FetchDepend(pHoundMatch, &houndDepend);

	// For each stroke (assuming a stroke is four subsequent features)...
	ASSERT(numFeatSample % 4 == 0);

	// The Gaussian mean, computed as the unconditional mean plus
	// contribution from dependors...
	for (iVariable = 0; iVariable < numFeatSample; iVariable += 4)
	{
		eLogDensity += lLogDensityStroke(pSampleVector, iVariable, pHoundMatch, aPerFeature, &houndDepend);

	}

	// Skip any unused dependencies.
	while (houndDepend.iDepende != -1)
	{
		FetchDepend(pHoundMatch, &houndDepend);
	}


	return eLogDensity;	
}

// Compute log density for mixture model: 
//		log p(x|model) = \sum_i ( log(weight_i) + log p(x|component_i) )
//		i is a component index
//		weight_i is the weight for mixture component i
//		p(x|component_i) is the multivariate Gaussian density for component i		
double lLogDensityMixtureCacPreOrder(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch,
	BYTE			numFeat
) {
	WORD			iComponent;
	WORD			cComponent;
	double	aeComponents[MAX_HOUND_COMPONENTS + 1];

	// Extract the number of components in the model.
	cComponent	= *pHoundMatch->pScanData++;
	ASSERT(cComponent <= MAX_HOUND_COMPONENTS);

	// For each mixture component...
	for (iComponent = 0; iComponent < cComponent; ++iComponent)
	{
		double			eLogComponentWeight;
		UNALIGNED short	*pFetchShort;

		// We have a component weight only if we have more than one model.
		// Otherwise we have a value of 0.0 (prob 1.0).
		if (cComponent == 1)
		{
			eLogComponentWeight	= 0.0;
		}
		else
		{
			// Comp. weight is stored in 4.12 format in two bytes.
			pFetchShort			= (short *)pHoundMatch->pScanData;
			eLogComponentWeight	= FixNToFloat((LONG)*pFetchShort, 12);
			pHoundMatch->pScanData	+= 2;
		}

		ASSERT(eLogComponentWeight <= 0.0);

		// log(weight_i) + log(p(x|component_i))
		aeComponents[iComponent]	= eLogComponentWeight + 
			lLogDensityComponentCacPreOrder(pSampleVector, pHoundMatch, numFeat);
		ASSERT(aeComponents[iComponent] > -1e100);
	}
	
	// Sum the probabilities of the components.	 Since this is in log-prob
	// space, it is hard.
	return DblLogSumArray(aeComponents, cComponent);
}

// Find the most likely model (code point) given a case with numFeatSample / 4 strokes
//	log p(model|x) = log p(x|model) - normalization value
//	normalization constant = log( \sum_i p(x|model_i) * p(model_i) )
// We are only interested in ranking models, and it is therefore not necessary to normalize.
// This would not be the case if we want to return the actualy probability for model(s)

// Notice: If bounding boxes didn't change (too much) each time a new stroke is added
// there is a HUGE possibility for improving computational efficiency for this function.
// In this case most of the computations from previous strokes can be re-used.
BOOL HoundCacPreOrderMatch(
	UINT			iSpace,
	const BYTE *	pSampleVector,
	BYTE			numFeatSample,
	ALT_LIST		*pAltList,
	const DWORD		*pdwAbort,		// Address of abort parameter
	DWORD			cstrk,			// Number of strokes in character
	double			*peSum,
	double			*peRawScore
)
{
	HOUND_MATCH		houndMatch;
	unsigned int	ii, jj;
	double			eJoint;

	if (!HoundMatchSequenceInit(iSpace, &houndMatch)
		|| houndMatch.numFeat < numFeatSample)
	{
		return FALSE;
	}

	// Loop until end of space.
	while (houndMatch.pScanData[0] != 0x00 || houndMatch.pScanData[1] != 0x00)
	{
		UNALIGNED wchar_t	*pFetchWChar;
		wchar_t				dchLabel;

		// Extract the Code point.
		pFetchWChar				= (wchar_t *)houndMatch.pScanData;
		dchLabel				= *pFetchWChar;
		houndMatch.pScanData	+= 2;

		// log p(x|model)
		eJoint		= lLogDensityMixtureCacPreOrder(pSampleVector, &houndMatch, numFeatSample);

		// Sum probabilities P(x|m) for all m (in log space) to generate normalization value.
		*peSum		= DblLogSum(*peSum, eJoint);

		//////////////////////////////////////////////////////////////////////////////////
		// Optomize for the next version: alt list should be checked from back to front,
		// as evaluations for most code points are bad! This will speed up the code
		// - guaranteed!
		//////////////////////////////////////////////////////////////////////////////////
		// Update alt list
		// First find the place to insert at.
		for (ii = 0; ii < pAltList->cAlt; ++ii)
		{
			// Compare using full precision score.
			if (eJoint > peRawScore[ii])
			{
				break;
			}
		}

		// Do we want to do insert?
		if (ii < MAX_ALT_LIST)
		{
			// Still room to expand list?
			if (pAltList->cAlt < MAX_ALT_LIST)
			{
				++pAltList->cAlt;
			}

			// Move rest of list down to make space.
			for (jj = pAltList->cAlt - 1; jj > ii; --jj)
			{
				peRawScore[jj]			= peRawScore[jj - 1];	// Keep full precision score.
				pAltList->aeScore[jj]	= pAltList->aeScore[jj - 1];
				pAltList->awchList[jj]	= pAltList->awchList[jj - 1];
			}

			// Insert new item.
			peRawScore[ii]			= eJoint;		// Keep full precision score.
			pAltList->aeScore[ii]	= (float)eJoint;
			pAltList->awchList[ii]	= dchLabel;
		}
	}

	return TRUE;
}

// Do all spaces from current length up.
void HoundStartMatch(
	const BYTE *	pSampleVector,
	BYTE			numFeatSample,
	ALT_LIST		*pAltList,
	const DWORD		*pdwAbort,		// Address of abort parameter
	DWORD			cstrk			// Number of strokes in character
)
{
	unsigned		ii;
	int				iSpace;
	double			eNoise;
	double			eSum;
	double			aeRawScore[MAX_ALT_LIST];

	// Try each space from smallest that sample fits in, to max.
	ASSERT(numFeatSample % 4 == 0);
	iSpace = numFeatSample / 4;
	if (iSpace < 3)
	{
		iSpace	= 3;
	}

	pAltList->cAlt	= 0;			// Make sure we start with an empty list.
	eSum			= MIN_DOUBLE;	// Normalization sum must be initialized.

	for (; iSpace < 30; ++iSpace)
	{
		// Fill in new alt list with this spaces results.
		if (!HoundCacPreOrderMatch(
			iSpace, pSampleVector, numFeatSample, pAltList, pdwAbort, cstrk, &eSum, aeRawScore)
		)
		{
			return;
		}
	}

	// Compute noise component.
	eNoise		= -log(15.0) * numFeatSample;

	// Normalize the entries in the alt list.
	for (ii = 0; ii < pAltList->cAlt; ++ii)
	{
		// Notice that we are adding in the noise component - only to things that are in 
		// the final alt list. This is ok because we only use the noise to get better
		// normalization/probabilities. Adding the noise component or not, does not have
		// any effect on choosing the right alt list.
		// Since we only compute it for things in the alt list,
		// we have fewer calls to DblLogSum and hence the code is faster.
		pAltList->aeScore[ii]	= (float)(DblLogSum(aeRawScore[ii], eNoise) - eSum);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\inc\hound.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      hound.h
//
// Description:
//      Definitions for the hound project.
//
// Author:
//      jbenn
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#ifndef __INCLUDE_HOUND
#define __INCLUDE_HOUND

#include "common.h"

#ifdef __cplusplus
extern "C" 
{
#endif

////
//// Structures to hold the Hound database.
////

// Limit we force on the number of components in one model.  Most models have
// a much smaller number of components.
#define	MAX_HOUND_COMPONENTS	20

// Limit on the number of features in a single feature vector.  Currently
// the max strokes Zilla allows times the # of features per stroke.
#define MAX_HOUND_FEATURES		(29 * 4)

// MAx stroke count at which we use the midpoints of each stroke.
#define	MAX_HOUND_STROKES_USE_MIDPOINT	4

// Pair of features referenced by dependency.
typedef struct	tagDEPEND_PAIR
{
	BYTE	dependor;
	BYTE	depende;
} DEPEND_PAIR;

// Weight structure used for dependencies.
typedef struct	tagDEPEND_WEIGHT
{
	signed char	weight;
	BYTE		scale;
} DEPEND_WEIGHT;

// Per space information.
// Store size of space as two WORDs so we only have to have WORD alignment,
// instead of DWORD alignment.	This data is in the resource, and is read-
// only as a result.
typedef struct tagHOUND_SPACE {
	WORD	spaceSizeLow;	// Space size, low word.
	WORD	spaceSizeHigh;	// Space size, high word.
	BYTE	spaceNumber;	// Space number (stroke count, after cracking)
	BYTE	numFeat;		// Number of features per sample.
	BYTE	spare;
	BYTE	maxComponents;	// Max components in any model in the space.
	WORD	maxDependancy;	// Max dependencies in any model in the space.
	WORD	cPairOneByte;	// Count of 1 byte dependency pair table entries.
	WORD	cPairTable;		// Count of all dependency pair table entries.
	WORD	cWeightOneByte;	// Count of 1 byte dependency weight table entries.
	WORD	cWeightTable;	// Count of all dependency weight table entries.
	BYTE	modelData[2];	// Variable size array containing model tables and data.
} HOUND_SPACE;

// The main header.
typedef struct tagHOUND_DB {
	int			cSpaces;				// Number of spaces loaded.
	UINT		minSpace;				// Min and Max space numbers loaded
	UINT		maxSpace;				//		(minSpace - maxSpace) + 1 == cSpaces
	HOUND_SPACE	**ppSpaces;				// Data on each space loaded.
	BYTE		**appModelIndex[30];	// Index for each model in each space (set when used).
} HOUND_DB;

// Global holding information to access loaded hound database.
extern HOUND_DB	g_houndDB;

////
//// Functions for handling Hound DB.
////

// Load the resource file with the hound data.
BOOL HoundLoadRes(HINSTANCE hInst, int resNumber, int resType, 
	LOCRUN_INFO *pLocRunInfo);

// Unload the resource file with the hound data.  Actually just frees allocated memory, but if we
// ever need to actually unload the resources, this is where it will go.
BOOL HoundUnLoadRes();

// Load hound data from a file.
BOOL HoundLoadFile(
	LOCRUN_INFO		*pLocRunInfo,
	LOAD_INFO		*pLoadInfo,
	wchar_t			*pwchPathName
);

// Unload hound data loaded from a file.
BOOL HoundUnLoadFile(LOAD_INFO *pInfo);

#ifndef HWX_PRODUCT

// Load hound data for a single space from a file.
extern HOUND_SPACE *HoundSpaceLoadFile(wchar_t *pwchFileName);

// Parse a Hound space and record the location of each model in it.
extern BOOL ParseHoundSpace(HOUND_SPACE *pSpace);

// Print out each code point supported and the number of models it has.
extern BOOL HoundPrintModelList(FILE *pFile);

// Variables set by ParseHoundSpace.
extern int		g_maxModelsPerCP;
extern int		g_iMinModelHead;
extern int		g_iMaxModelHead;

// Given a data sample and a code point, give the score for each model for
// that code point.	 This fills in the scores in order of the models in
// the DB.  The array must be big enough to hold all the scores.  The return
// value give the number of entries filled in.
extern int	HoundMatchCodePoint(
	wchar_t		dchLabel,
	const BYTE	* const pSampleVector,
	double		*pScores
);

// Copy one of the loaded models to an output file.
extern int HoundCopyModelToFile(FILE *pFile, wchar_t dchLabel, int iModel);

#endif

// Find the most likely model (code point) given a case
extern BOOL HoundMatch(UINT iSpace, const BYTE * const pSampleVector, ALT_LIST *pAltList);

// Find the most likely model (code point) given a case with numFeatSample / 4 strokes
//	log p(model|x) = log p(x|model) - normalization value
//	normalization constant = log( \sum_i p(x|model_i) * p(model_i) )
// We are only interested in ranking models, and it is therefore not necessary to normalize.
// This would not be the case if we want to return the actualy probability for model(s)

// Notice: If bounding boxes didn't change (too much) each time a new stroke is added
// there is a HUGE possibility for improving computational efficiency for this function.
// In this case most of the computations from previous strokes can be re-used.

// Do all spaces from current length up.
extern VOID HoundStartMatch(
	const BYTE *	pSampleVector,
	BYTE			numFeatSample,
	ALT_LIST		*pAltList,
	const DWORD		*pdwAbort,		// Address of abort parameter
	DWORD			cstrk			// Number of strokes in character
);

// Given a data sample and a code point, give the score for that model.
extern BOOL HoundMatchSingle(
	UINT		iSpace,
	wchar_t		dchLabel,
	const BYTE	* const pSampleVector,
	double		*pScore
);

#ifdef __cplusplus
};
#endif

#endif // !__INCLUDE_HOUND
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\holycow\src\panlfeat.c ===
// panlfeat.c

#include "common.h"
#include <nfeature.h>
#include <engine.h>
#include <linebrk.h>
#include "panlfeat.h"


/******************************Private*Routine******************************\
* AppendFeatures
*
* Function to append the featurizations of two lines together.
*
* History:
*  22-Dec-1999 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
NFEATURESET *AppendFeatures(NFEATURESET *n1, NFEATURESET *n2)
{
	NFEATURE *nfeat;

	if (!n1)
		return n2;
	n1->cPrimaryStroke += n2->cPrimaryStroke;
	n1->cSegment += n2->cSegment;
	nfeat = n1->head;
	while (nfeat->next)
		nfeat = nfeat->next;
	nfeat->next = n2->head;
	n2->head = NULL;
	DestroyNFEATURESET(n2);
	return n1;
}

/******************************Public*Routine******************************\
* FeaturizePanel
*
* Function to featurize a panel.  The guide is used to break into lines.
*
* History:
*  22-Dec-1999 -by- Angshuman Guha aguha
* Wrote it.  Resurrected from old nfeature.c and modified.
*
* 20 Mar 2001 - mrevow 
* Extend to handle fff files that do not have a guide
\**************************************************************************/
NFEATURESET *FeaturizePanel(GLYPH *pGlyph, const GUIDE *pGuide)
{
	int			cStroke, iLine, cLine;
	GLYPH		*glyph;
	NFEATURESET *nfeatureset = NULL, *tmpnfeatureset;
	LINEBRK		lineBrk;

	// compute cStroke
	for (cStroke=0, glyph=pGlyph; glyph; glyph=glyph->next)
	{
		if (!IsVisibleFRAME(glyph->frame))
			continue;
		cStroke++;
	}
	if (cStroke < 1)
		return NULL;

	if (pGuide->cVertBox > 0 && pGuide->cHorzBox > 0)
	{
		cLine = GuideLineSep(pGlyph, (GUIDE *)pGuide, &lineBrk);
	}
	else
	{
		cLine = NNLineSep ((GLYPH *)pGlyph, &lineBrk);
	}

	for (iLine = 0 ; iLine < cLine ; ++iLine)
	{
		if (lineBrk.pLine[iLine].cStroke <= 0)
		{
			continue;
		}
		if (!(tmpnfeatureset = FeaturizeLine(lineBrk.pLine[iLine].pGlyph, -1)))
		{
			goto fail;
		}

		// merge
		nfeatureset = AppendFeatures(nfeatureset, tmpnfeatureset);
	}

	FreeLines (&lineBrk);
	return nfeatureset;

fail:
	if (nfeatureset)
	{
		DestroyNFEATURESET(nfeatureset);
	}
	FreeLines (&lineBrk);
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\houndfl.c ===
////////////////////////////////////////////////////////////////////////////////
// FILE: houndfl.c
//
// Code to load hound data from a file.

#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "score.h"
#include "math16.h"
#include "hound.h"
#include "houndp.h"

///////////////////////////////////////
//
// HoundLoadFile
//
// Load an integer Fugu database from a file
//
// Parameters:
//      pInfo:   [out] Structure where information for unloading is stored
//      wszPath: [in]  Path to load the database from
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL HoundLoadFile(
	LOCRUN_INFO		*pLocRunInfo,
	LOAD_INFO		*pInfo,
	wchar_t			*wszPath)
{
	wchar_t	wszFile[_MAX_PATH];

	// Generate path to file.
	FormatPath(wszFile, wszPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"hound.dat");

    if (!DoOpenFile(pInfo, wszFile)) 
    {
        return FALSE;
    }

	if (!HoundLoadFromPointer(pLocRunInfo, pInfo->pbMapping, pInfo->iSize)) {
		DoCloseFile(pInfo);
		return FALSE;
	}

	return TRUE;
}

///////////////////////////////////////
//
// HoundUnLoadFile
//
// Unload a Hound database loaded from a file
//
// Parameters:
//      pInfo: [in] Load information for unloading
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL HoundUnLoadFile(LOAD_INFO *pInfo)
{
	// Free allocated memory.
	HoundUnLoad();

	// Close the file.
	return DoCloseFile(pInfo);
}

// Load hound data for a single space from a file.
HOUND_SPACE *HoundSpaceLoadFile(wchar_t *pwchFileName)
{
	HANDLE			hFile, hMap;
	BYTE			*pByte;
	HOUND_SPACE		*pSpace;

	hFile = CreateMappingCall(
		pwchFileName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (BYTE *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if ( !pByte ) {
		goto error4;
	}

	// Verify space is valid.
	pSpace	= (HOUND_SPACE *)pByte;
	if (pSpace->spaceNumber >= HOUND_NUM_SPACES)
	{
		ASSERT(pSpace->spaceNumber < HOUND_NUM_SPACES);
		goto error3;
	}

	return pSpace;

	// Error handling
error4:
	UnmapViewOfFile(pByte);
	pByte = NULL;

error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	return (HOUND_SPACE *)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\hmatch.c ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      hMatch.c
//
// Description:
//      Main hound matching code.
//
// Author:
//      jbenn
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#include <float.h>
#include "common.h"
#include "score.h"
#include "math16.h"
#include "hound.h"
#include "houndp.h"

#include <stdio.h>

// NOTE: Since the decoding of the Bayes net models is an extremly performence critical, and we
// believe that the signing of the data DLL prevents corruption, we do not check that the decoding
// passes the end of the data block it is processing.


extern LOCRUN_INFO	g_locRunInfo;

// Global holding information to access loaded hound database.
HOUND_DB	g_houndDB;

// Given image of hound database in memory parse it and fill in the hound info
// structure.
BOOL HoundLoadFromPointer(LOCRUN_INFO *pLocRunInfo, BYTE *pRes, int cbRes)
{
	const HOUNDDB_HEADER	*pHeader	= (HOUNDDB_HEADER *)pRes;
	HOUND_SPACE				*pSpaces[HOUND_NUM_SPACES];
	int						cSpaces, minSpace, maxSpace;
	BYTE					*pScan;
	int						cbScan;	// Keep track of how much of resource is left unscanned.
	int						size;

	// Verify valid file.
	if (cbRes < sizeof(HOUNDDB_HEADER))
	{
		ASSERT(cbRes >= sizeof(HOUNDDB_HEADER));

		return FALSE;
	}
	if ((pHeader->fileType != HOUNDDB_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > HOUNDDB_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < HOUNDDB_OLD_FILE_VERSION) 
		|| memcmp (pHeader->adwSignature, pLocRunInfo->adwSignature,
			sizeof(pHeader->adwSignature))
		|| (pHeader->cSpaces < 1)
	) {
		ASSERT(pHeader->fileType == HOUNDDB_FILE_TYPE);
		ASSERT(pHeader->headerSize >= sizeof(*pHeader));
		ASSERT(pHeader->minFileVer <= HOUNDDB_CUR_FILE_VERSION);
		ASSERT(pHeader->curFileVer >= HOUNDDB_OLD_FILE_VERSION);
		ASSERT(memcmp(pHeader->adwSignature, pLocRunInfo->adwSignature,
			sizeof(pHeader->adwSignature)) == 0);
		ASSERT(pHeader->cSpaces >= 1);

		return FALSE;
	}

	// Scan out the spaces.
	memset(pSpaces, 0, sizeof(pSpaces));
	pScan		= pRes + sizeof(HOUNDDB_HEADER);
	cbScan		= cbRes - sizeof(HOUNDDB_HEADER);
	minSpace	= HOUND_NUM_SPACES;
	maxSpace	= 0;
	for (cSpaces = 0; cSpaces < pHeader->cSpaces; ++cSpaces) {
		HOUND_SPACE		*pSpace;
		int				cbSpace;

		// Verify space is valid and not a duplicate.
		if (cbScan < sizeof(HOUND_SPACE))
		{
			ASSERT(cbScan >= sizeof(HOUND_SPACE));
			return FALSE;
		}
		pSpace	= (HOUND_SPACE *)pScan;
		cbSpace	= (pSpace->spaceSizeHigh << 16) + pSpace->spaceSizeLow;
		if (pSpace->spaceNumber >= HOUND_NUM_SPACES
			|| (cbScan < cbSpace)
			|| pSpaces[pSpace->spaceNumber]
		) {
			ASSERT(pSpace->spaceNumber < HOUND_NUM_SPACES);
			ASSERT(cbScan < cbSpace);
			ASSERT(!pSpaces[pSpace->spaceNumber]);
			return FALSE;
		}

		// Expand range if needed.
		if (minSpace > pSpace->spaceNumber) {
			minSpace	= pSpace->spaceNumber;
		}
		if (maxSpace < pSpace->spaceNumber) {
			maxSpace	= pSpace->spaceNumber;
		}

		// Add pointer.
		pSpaces[pSpace->spaceNumber]	= pSpace;

		// Point to next space.
		pScan	+= cbSpace;
		cbScan	-= cbSpace;
	}

	// Did we read all of the data?
	if (cbScan != 0)
	{
		ASSERT(cbScan == 0);
		return FALSE;
	}

	// Fill in hound DB structure.
	g_houndDB.minSpace	= minSpace;
	g_houndDB.maxSpace	= maxSpace;
	g_houndDB.cSpaces	= maxSpace - minSpace + 1;
	size				= sizeof(HOUND_SPACE *) * g_houndDB.cSpaces;
	g_houndDB.ppSpaces	= (HOUND_SPACE **)ExternAlloc(size);
	if (!g_houndDB.ppSpaces) {
		ASSERT(g_houndDB.ppSpaces);
		return FALSE;
	}
	memcpy(g_houndDB.ppSpaces, pSpaces + minSpace, size);

	return TRUE;
}

///////////////////////////////////////
//
// HoundLoadRes
//
// Load an Hound database from a resource
//
// Parameters:
//      hInst:			[in] Handle to the DLL containing the recognizer
//      iResNumber:		[in] Number of the resource (ex RESID_HOUND)
//      iResType:		[in] Number of the recognizer (ex VOLCANO_RES)
//      pLocRunInfo:	[in] Locale information used to verify version of this resource
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL HoundLoadRes(
	HINSTANCE	hInst, 
	int			iResNumber, 
	int			iResType,
	LOCRUN_INFO	*pLocRunInfo
) 
{
	BYTE		*pb;
	LOAD_INFO	info;

	if (!pLocRunInfo)
	{
		ASSERT(pLocRunInfo);
		return FALSE;
	}

	// Load the prob database
	pb	= DoLoadResource(&info, hInst, iResNumber, iResType);
	if (!pb) 
    {
		return FALSE;
	}
	return HoundLoadFromPointer(pLocRunInfo, pb, info.iSize);
}

///////////////////////////////////////
//
// HoundUnload
//
// Unload hound.  This frees the allocated memory.
//
// Parameters:
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
void HoundUnLoad(void)
{
	UINT		ii;

	// Free any model index tables that were allocated
	for (ii = g_houndDB.minSpace; ii <= g_houndDB.maxSpace; ++ii)
	{
        if (g_houndDB.appModelIndex[ii])
		{
			ExternFree(g_houndDB.appModelIndex[ii]);
		}
	}

	// Free the space table.
	ExternFree(g_houndDB.ppSpaces);
}

///////////////////////////////////////
//
// HoundLoadRes
//
// Unload a Hound database from a resource.  Well actually you don't unload resources, but we do still need
// to free allocated memory.
//
// Parameters:
//      hInst:			[in] Handle to the DLL containing the recognizer
//
// Return values:
//      TRUE:  Finished without errors
//      FALSE: An error occured
//
//////////////////////////////////////
BOOL HoundUnLoadRes() 
{
	// Free memory.
	HoundUnLoad();

	// Always works.
	return TRUE;
}

// Given an array {log(p_1), ... , log(p_n)}, return log(p_1 + ... + p_n)
double	DblLogSumArray(double* rgdblLog, UINT celem)
{

	// log(p_1 + ... + p_n) = log( exp(log(p_1)) + ... + exp(log(p_n)) )
	//						= - log(k) + log(k) + log( exp(log(p_1)) + ... + exp(log(p_n)) )
	//					    = - log(k) + log( k*exp(log(p_1)) + ... + k*exp(log(p_n)) )
	//						= - log(k) + log( exp(log(p_1)+log(k)) + ... + exp(log(p_n)+log(k)))
	
	// Choosing log(k) to ensure as much accuracy as possible w/out overflow:

	// Shift the terms so that exp(log(p_m)+log(k)) = MAX_DBL / n, where n is the
	// number of terms and log(p_m) is maximum
	
	double	dblLogK;
	double	dblLogMax = MIN_DOUBLE;
	double	dblSum;
	double	dbl;
	UINT ielem;
	
	// Shortcut for only one item.
	if (celem == 1)
	{
		return rgdblLog[0];
	}

	// Find max element
	for (ielem = 0; ielem < celem; ielem++)
		if (rgdblLog[ielem] > dblLogMax)
			dblLogMax = rgdblLog[ielem];

	// If the best is the smallest number, that is going to be our answer.
	ASSERT(dblLogMax > MIN_DOUBLE);

	// 	Optimize this next time around: Pre-compute (log(DBL_MAX) - log((double)celem+1))!!!!	  Use highest celem 
	dblLogK = log(DBL_MAX) - log((double)celem+1) - dblLogMax; 

	dblSum = 0;
	
	for (ielem = 0; ielem < celem; ielem++)
		dblSum += exp(rgdblLog[ielem] + dblLogK);
	
	dbl = -dblLogK + log(dblSum);
	
	return -dblLogK + log(dblSum);
}		 

// Given two log-probs sum the probabilities and return its log-prob
double	DblLogSum(double dblLog1, double dblLog2)
{
	// log(p_1 + p_2)	= log( exp(log(p_1)) + exp(log(p_2)) )
	//					= - log(k) + log(k) + log( exp(log(p_1)) + exp(log(p_2)) )
	//					= - log(k) + log( k*exp(log(p_1)) + k*exp(log(p_2)) )
	//					= - log(k) + log( exp(log(p_1)+log(k)) + exp(log(p_2)+log(k)))

	// Choosing log(k) to ensure as much accuracy as possible w/out overflow:

	// Shift the terms so that exp(log(p_m)+log(k)) = MAX_DBL / 2,
	// and log(p_m) is maximum
	
	double 	dblLogMax 	= (dblLog1 > dblLog2) ? dblLog1 : dblLog2;
	// 	Optimize this next time around: Pre-compute (log(DBL_MAX) - log(2.0001))!!!!
	double	dblLogK		= log(DBL_MAX) - log(2.0001) - dblLogMax; 
	double	dblSum		= exp(dblLog1 + dblLogK) + exp(dblLog2 + dblLogK);

	return -dblLogK + log(dblSum);
}		 

// Computes the exponent part of a one dimensional Gaussian.
// That is, -1/2 * (x - mean)^2 / variance
// The numbers are in 16.16 format.

// NOTICE: ANY IMPROVEMENTS TO THIS FUNCTION WILL HAVE A HUGE IMPACT!

// jbenn:	I originally wanted this (and the functions that call it) to use
//			16.16 math, but it turns out to be hard to do.  Since double is
//			fine for the desktop, I will punt the optimization for when we
//			port to CE.

double lGaussianExponent(double eMeanOffset, double eVariance)
{
	double		eSqrResidual;
	double		eExponent;
	
	// jbenn: Hack to avoid divide by zero.  We should tune this!
	if (eVariance == 0.0)	
		eVariance	= 0.00023;

	// part2 = (x - mean)^2 / variance
	eSqrResidual	= eMeanOffset * eMeanOffset;	// (x - mean)^2	
	eExponent		= eSqrResidual / eVariance;		// (x - mean)^2 / variance

	// -1/2 * eExponent
	return -(eExponent / 2.0);
}

// Extract the next dependency from the data file.  If we hit the end of
// the dependency list, set the depende value to -1.
void FetchDepend(HOUND_MATCH *pHoundMatch, HOUND_DEPEND *pDepend)
{
	int				index1, index2;
	DEPEND_PAIR		pair;
	DEPEND_WEIGHT	weight;
	LONG			temp;

	// Extract dependor and depende values.
	index1		= *pHoundMatch->pScanData++;
	if (index1 == 0)
	{
		// End of list.
		pDepend->iDepende	= -1;

		// Don't set other fields because speed is important and they are
		// not used.
		// pDepend->iDependor	= -1;
		// pDepend->eWeight		= 0.0;
		return;
	}
	else if (index1 < pHoundMatch->cPairOneByte)
	{
		pair	= pHoundMatch->pPairOneByte[index1];
	}
	else
	{
		index1	-= pHoundMatch->cPairOneByte;
		index2	= *pHoundMatch->pScanData++;
		pair	= pHoundMatch->pPairTwoByte[index1 * 256 + index2];
	}

	// Copy values into output structure.
	pDepend->iDependor	= pair.dependor;
	pDepend->iDepende	= pair.depende;

	// Fetch the dependency weight.
	index1		= *pHoundMatch->pScanData++;
	if (index1 < pHoundMatch->cWeightOneByte)
	{
		weight	= pHoundMatch->pWeightOneByte[index1];
	}
	else
	{
		index1	-= pHoundMatch->cWeightOneByte;
		index2	= *pHoundMatch->pScanData++;
		weight	= pHoundMatch->pWeightTwoByte[index1 * 256 + index2];
	}

	// Convert to 16.16 format.
	temp	= (LONG)weight.weight << (16 - weight.scale);

	// Then convert to floating point.
	pDepend->eWeight	= Fix16ToFloat(temp);
}

// Fetch the values for the diagonal.
void FetchDiagonal(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch,
	HOUND_PER_FEAT	*pPerFeature)
{
	LONG			temp;
	int				iVariable;

	for (iVariable = 0; iVariable < pHoundMatch->numFeat; ++iVariable)
	{
		// Table to decode variances:	
		static const double	aDecodeVariance[8]	= {
			0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0
		};

		// Each mean has 4.1 bits and each variance is encoded in 3.
		temp	= (DWORD)(*pHoundMatch->pScanData++);

		// Subtract mean from actual to	compute the offset.
		pPerFeature[iVariable].eMeanOffset	
				= (double)pSampleVector[iVariable] - FixNToFloat(temp & 0x1F, 1);

		// Top 3 bits control the variance.
		pPerFeature[iVariable].eVariance	= aDecodeVariance[temp >> 5];
	}
}

// Compute log density for multivariate Gaussian as the sum of log densities
// for each variable in the model. The density for a single variable 'depende'
// is a linear regression on 'dependors'.
//
// Example: Let variable 'a' depend on variable 'b' and 'c'. Then the log
// density for this variable will be the Gaussian log density 
// log p(x_a | mean, variance), where
//		x_a is the observation for variable a
//		mean is computed as mean_a + coeff_ab * (x_b - mean_b) 
//			+ coeff_ac * (x_c - mean_c)
//		variance is variance_a
//		mean_a is the (unconditional) mean for variable a
//		variance_a is the (conditional) variance for a
//		coeff_ab is linear regression coefficient for a given b
double lLogDensityComponent(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch
) {
	double			eLogDensity;
	int				iVariable;
	LONG			temp;
	HOUND_DEPEND	houndDepend;
	HOUND_PER_FEAT	aPerFeature[MAX_HOUND_FEATURES];
	UNALIGNED short	*pFetchShort;

	// Comp. factor is stored in signed 10.6 format in two bytes.
	// We want it int 16.16 format in a LONG.
	pFetchShort	= (short *)pHoundMatch->pScanData;
	temp		= (LONG)*pFetchShort << 10;
	eLogDensity = Fix16ToFloat(temp);
	pHoundMatch->pScanData	+= 2;

	// Until we fix computation of component factor, make sure it is <= 0.
	if (eLogDensity > 0.0)
	{
		eLogDensity	= 0.0;
	}

	// Fetch the values for the diagonal.
	FetchDiagonal(pSampleVector, pHoundMatch, aPerFeature);

	// Prefetch first dependency.
	FetchDepend(pHoundMatch, &houndDepend);

	// The Gaussian mean, computed as the unconditional mean plus
	// contribution from dependors...
	for (iVariable = 0; iVariable < pHoundMatch->numFeat; ++iVariable)
	{
		double	eMeanOffset;

		eMeanOffset	= aPerFeature[iVariable].eMeanOffset;

		// While dependency is for the current variable ...
		// WARNING: This requires that the dependencies are ordered
		// by the depende of each!!!!
		while (houndDepend.iDepende == iVariable)
		{
			// The contribution to mean from single dependor. 
			// Ex: coeff_ab * (x_b - mean_b)
			eMeanOffset		-= houndDepend.eWeight 
				* aPerFeature[houndDepend.iDependor].eMeanOffset;

			// Now fetch next dependency.
			FetchDepend(pHoundMatch, &houndDepend);
		}

		// Add log-density contribution for variable to the component log-density
		eLogDensity += lGaussianExponent(
			eMeanOffset, aPerFeature[iVariable].eVariance
		);
		ASSERT(eLogDensity <= 0.0);
	}

	return eLogDensity;	
}

// Compute log density for mixture model: 
//		log p(x|model) = \sum_i ( log(weight_i) + log p(x|component_i) )
//		i is a component index
//		weight_i is the weight for mixture component i
//		p(x|component_i) is the multivariate Gaussian density for component i		
double lLogDensityMixture(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch
) {
	WORD			iComponent;
	WORD			cComponent;
	double			aeComponents[MAX_HOUND_COMPONENTS + 1];
	
	// Extract the number of components in the model.
	cComponent	= *pHoundMatch->pScanData++;
	ASSERT(cComponent <= MAX_HOUND_COMPONENTS);

	// For each mixture component...
	for (iComponent = 0; iComponent < cComponent; ++iComponent)
	{
		LONG			temp;
		double			eLogComponentWeight;
		UNALIGNED short	*pFetchShort;

		// We have a component weight only if we have more than one model.
		// Otherwise we have a value of 0.0 (prob 1.0).
		if (cComponent == 1)
		{
			eLogComponentWeight	= 0.0;
		}
		else
		{
			// Comp. weight is stored in 4.12 format in two bytes.  We want
			// it in 16.16 format in a LONG.
			pFetchShort			= (short *)pHoundMatch->pScanData;
			temp				= (LONG)*pFetchShort << 4;
			eLogComponentWeight	= Fix16ToFloat(temp);
			pHoundMatch->pScanData	+= 2;
			ASSERT(eLogComponentWeight <= 0.0);
		}

		// log(weight_i) + log(p(x|component_i))
		aeComponents[iComponent]	= eLogComponentWeight + 
			lLogDensityComponent(pSampleVector, pHoundMatch);
		ASSERT(aeComponents[iComponent] <= 0.0);
	}
	
	// Sum the probabilities of the components.	 Since this is in log-prob
	// space, it is hard.
	return DblLogSumArray(aeComponents, cComponent);
}

// Get ready to scan a Hound space.  This will fill in all the
// fields in the HOUND_SEQUENCE structure.  Return success or failure.
BOOL HoundMatchSequenceInit(UINT iSpace, HOUND_MATCH *pMatch)
{
	HOUND_SPACE	*pSpace;

	// Verify that we got a structure to fill in.
	if (!pMatch)
	{
		ASSERT(pMatch);
		return FALSE;
	}

	// Verify that space is in supported range.
	if (iSpace < g_houndDB.minSpace || g_houndDB.maxSpace < iSpace)
	{
		ASSERT(iSpace >= g_houndDB.minSpace);
		ASSERT(iSpace <= g_houndDB.maxSpace);
		return FALSE;
	}

	// Get space pointer, and verify is not a skipped space.
	pSpace	= g_houndDB.ppSpaces[iSpace - g_houndDB.minSpace];
	if (!pSpace)
	{
		ASSERT(pSpace);
		return FALSE;
	}

	// Fill in the sequence structure.
	pMatch->numFeat			= pSpace->numFeat;
	pMatch->cPairOneByte	= pSpace->cPairOneByte;
	pMatch->cPairTable		= pSpace->cPairTable;
	pMatch->pPairOneByte	= (DEPEND_PAIR *)pSpace->modelData;
	pMatch->pPairTwoByte	= pMatch->pPairOneByte + pSpace->cPairOneByte;
	pMatch->cWeightOneByte	= pSpace->cWeightOneByte;
	pMatch->cWeightTable	= pSpace->cWeightTable;
	pMatch->pWeightOneByte	= (DEPEND_WEIGHT *)(pMatch->pPairOneByte + pSpace->cPairTable);
	pMatch->pWeightTwoByte	= pMatch->pWeightOneByte + pSpace->cWeightOneByte;
	pMatch->pScanData		= (BYTE *)(pMatch->pWeightOneByte + pSpace->cWeightTable);

	return TRUE;
}

// Find the most likely model (code point) given a case
//	log p(model|x) = log p(x|model) - normalization value
//	normalization constant = log( \sum_i p(x|model_i) * p(model_i) )
// We are only interested in ranking models, and it is therefore not necessary to normalize.
// This is would not be the case if we want to return the actualy probability for model(s)
BOOL HoundMatch(UINT iSpace, const BYTE * const pSampleVector, ALT_LIST *pAltList)
{
	HOUND_MATCH		houndMatch;
	unsigned int	ii, jj;
	double			eJoint, eJointNoise;
	double			eSum;
	double			eNoise, eNoiseDelta, eGoodThresh;
	BOOL			fHaveGood;
	double			aeRawScore[MAX_ALT_LIST];

	// Check parameters.
	if (!pSampleVector || !pAltList)
	{
		ASSERT(pSampleVector);
		ASSERT(pAltList);
		return FALSE;
	}

	if (!HoundMatchSequenceInit(iSpace, &houndMatch))
	{
		return FALSE;
	}

	// Compute noise component.
	eNoise		= -log(15.0) * houndMatch.numFeat;
	eNoiseDelta	= eNoise + 1e-10;
	ASSERT((float)eNoise < (float)eNoiseDelta);
	eGoodThresh	= eNoise + (houndMatch.numFeat / 2.0);

	eSum	= MIN_DOUBLE;

	pAltList->cAlt	= 0;
	fHaveGood		= FALSE;
	// Loop until end of space.
	while (houndMatch.pScanData[0] != 0x00 || houndMatch.pScanData[1] != 0x00)
	{
		UNALIGNED wchar_t	*pFetchWChar;
		wchar_t				dchLabel, fch;

		// Extract the Code point.
		pFetchWChar				= (wchar_t *)houndMatch.pScanData;
		dchLabel				= *pFetchWChar;
		houndMatch.pScanData	+= 2;

		// We want folded, but DB is currently unfolded.
		fch	= LocRunDense2Folded(&g_locRunInfo, dchLabel);
		if (fch)
		{ 
			dchLabel	= fch;
		}

		// log p(x|model)
		eJoint		= lLogDensityMixture(pSampleVector, &houndMatch);

		// Compute the probability after adding noise component.
		eJointNoise	= DblLogSum(eNoise, eJoint);

		// Sum probabilities P(x|m) for all m (in log space) to generate normalization value.
		eSum		= DblLogSum(eSum, eJointNoise);

		// How we add to the list changes once we find a good score.
		if (fHaveGood)
		{
			// If we already have a good score, and this is not a good score, we ignore it.
			if (eJointNoise <= eNoiseDelta) 
			{
				continue;
			}
		}
		else 
		{
			// If we this is the first good score, we flag this and clean up the alt list.
			if (eJoint > eGoodThresh)
			{
				fHaveGood	= TRUE;

				// Convert scores in list to eJointNoise list.
				for (ii = 0; ii < pAltList->cAlt; ++ii)
				{
					aeRawScore[ii]			= DblLogSum(eNoise, aeRawScore[ii]);
					pAltList->aeScore[ii]	= (float)aeRawScore[ii];
				}

				// Prune nose level samples out.
				while (pAltList->cAlt > 0 
					&& aeRawScore[pAltList->cAlt - 1] <= eNoiseDelta)
				{
					--pAltList->cAlt;
				}
			}
			else
			{
				// Use raw eJoint if we haven't seen any good samples, this
				// way we can tell something about how good a match items are.
				eJointNoise	= eJoint;
			}
		}

		// Update alt list
		// First find the place to insert at.
		for (ii = 0; ii < pAltList->cAlt; ++ii)
		{
			// Compare using full precision score.
			if (eJointNoise > aeRawScore[ii])
			{
				break;
			}
		}

		// Do we want to do insert?
		if (ii < MAX_ALT_LIST)
		{
			// Still room to expand list?
			if (pAltList->cAlt < MAX_ALT_LIST)
			{
				++pAltList->cAlt;
			}

			// Move rest of list down to make space.
			for (jj = pAltList->cAlt - 1; jj > ii; --jj)
			{
				aeRawScore[jj]			= aeRawScore[jj - 1];	// Keep full precision score.
				pAltList->aeScore[jj]	= pAltList->aeScore[jj - 1];
				pAltList->awchList[jj]	= pAltList->awchList[jj - 1];
			}

			// Insert new item.
			aeRawScore[ii]			= eJointNoise;		// Keep full precision score.
			pAltList->aeScore[ii]	= (float)eJointNoise;
			pAltList->awchList[ii]	= dchLabel;
		}
	}

	// Normalize the entries in the alt list.
	for (ii = 0; ii < pAltList->cAlt; ++ii)
	{
		pAltList->aeScore[ii]	-= (float)eSum;
	}

	// bestLogProb = eJointBest - lSum;
	return TRUE;
}

// Code to parse a Hound space and record the location of each model in it.
BOOL SetModelIndexs(HOUND_SPACE *pSpace)
{
	int		count;
	BYTE	**ppModelIndex;
	BYTE	*pScan;

	// Check parameter
	if (!pSpace)
	{
		ASSERT(pSpace);
		return FALSE;
	}

	// Check if we have processed this space.
	if (g_houndDB.appModelIndex[pSpace->spaceNumber])
	{
		// Already parsed and ready to go.
		return TRUE;
	}

	// Allocate and clear the array.  This is very wasteful of memory, but it is simple to code.
	// May want to come back and optimize this.
	count			= g_locRunInfo.cCodePoints + g_locRunInfo.cFoldingSets;
	ppModelIndex	= (BYTE **)ExternAlloc(sizeof(BYTE *) * count);
	if (!ppModelIndex)
	{
		return FALSE;
	}
	memset(ppModelIndex, 0, sizeof(BYTE *) * count);
	g_houndDB.appModelIndex[pSpace->spaceNumber]	= ppModelIndex;

	// Skip tables.
	pScan	= pSpace->modelData;
	pScan	+= sizeof(DEPEND_PAIR) * pSpace->cPairTable;
	pScan	+= sizeof(DEPEND_WEIGHT) * pSpace->cWeightTable;

	// Scan the data for the models.
	for (; pScan[0] != 0x00 || pScan[1] != 0x00; ) {
		UNALIGNED wchar_t	*pdchLabel;

		BYTE		*pModel;
		wchar_t		dchLabel;
		WORD		iComponent;
		WORD		cComponent;
		
		// Remember where model starts.
		pModel		= pScan;

		// Extract the Code point.
		pdchLabel	= (wchar_t *)pScan;
		dchLabel	= *pdchLabel;
		pScan		+= 2;

		//// Skip the model

		// Extract the number of components in the model.
		cComponent	= *pScan++;
		ASSERT(cComponent <= MAX_HOUND_COMPONENTS);

		// Skip each mixture component...
		for (iComponent = 0; iComponent < cComponent; ++iComponent)
		{
			// Skip Comp. weight & factor.
			if (cComponent > 1)
			{
				pScan	+= 2;
			}
			pScan	+= 2;

			// Skip the diagonal.
			pScan	+= pSpace->numFeat;

			// Skip dependencies.
			while (*pScan != 0)
			{
				pScan += (*pScan < pSpace->cPairOneByte) ? 1 : 2;
				pScan += (*pScan < pSpace->cWeightOneByte) ? 1 : 2;
			}
			++pScan;
		}

		// OK, have model, record it.
		ppModelIndex[dchLabel]	= pModel;
	}

	return TRUE;
}

// Given a data sample and a code point, give the score for that model.
BOOL
HoundMatchSingle(UINT iSpace, wchar_t dchLabel, const BYTE * const pSampleVector, double *pScore)
{
	extern LOCRUN_INFO	g_locRunInfo;

	BYTE		*pScan;
	HOUND_MATCH	houndMatch;
	HOUND_SPACE	*pSpace;

	// Check parameters.
	if (!pSampleVector || !pScore)
	{
		ASSERT(pSampleVector);
		ASSERT(pScore);
		return FALSE;
	}

	// Default score.
	*pScore	= MIN_FLOAT;

	// Is this a folded code?
	if (LocRunIsFoldedCode(&g_locRunInfo, dchLabel))
	{
		wchar_t		*pFoldingSet;
		int			ii;

		// Yes, we need to find best score in folding set.
		pFoldingSet	= LocRunFolded2FoldingSet(&g_locRunInfo, dchLabel);
		for (ii = 0; ii < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[ii] != 0; ii++)
		{
			double		newScore;

			// Call back on each, checkin new best score.
			if (!HoundMatchSingle(iSpace, pFoldingSet[ii], pSampleVector, &newScore))
			{
				return FALSE;
			}
			if (*pScore < newScore)
			{
				*pScore	= newScore;
			}
		}

		return TRUE;
	}

	// Verify that space is in supported range.
	if (iSpace < g_houndDB.minSpace || g_houndDB.maxSpace < iSpace)
	{
		ASSERT(iSpace >= g_houndDB.minSpace);
		ASSERT(iSpace <= g_houndDB.maxSpace);
		return FALSE;
	}

	// Get space pointer, and verify is not a skipped space.
	pSpace	= g_houndDB.ppSpaces[iSpace - g_houndDB.minSpace];
	if (!pSpace)
	{
		ASSERT(pSpace);
		return FALSE;
	}

	// Make sure space has been parsed.
	if (!SetModelIndexs(pSpace))
	{
		return FALSE;
	}

	// Find the model
	pScan	= g_houndDB.appModelIndex[iSpace][dchLabel];
	if (!pScan)
	{
		return TRUE;
	}

	// Set up match structure.
	houndMatch.numFeat			= pSpace->numFeat;
	houndMatch.cPairOneByte		= pSpace->cPairOneByte;
	houndMatch.cPairTable		= pSpace->cPairTable;
	houndMatch.pPairOneByte		= (DEPEND_PAIR *)pSpace->modelData;
	houndMatch.pPairTwoByte		= houndMatch.pPairOneByte + pSpace->cPairOneByte;
	houndMatch.cWeightOneByte	= pSpace->cWeightOneByte;
	houndMatch.cWeightTable		= pSpace->cWeightTable;
	houndMatch.pWeightOneByte	= (DEPEND_WEIGHT *)(houndMatch.pPairOneByte + pSpace->cPairTable);
	houndMatch.pWeightTwoByte	= houndMatch.pWeightOneByte + pSpace->cWeightOneByte;
	houndMatch.pScanData		= pScan + 2;  // Skip label

	// Score the model.
	*pScore		= lLogDensityMixture(pSampleVector, &houndMatch);;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\ifelang3\os\jpn\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\houndtrain.c ===
#include <float.h>
#include <stdlib.h>
#include "common.h"
#include "score.h"
#include "math16.h"
#include "hound.h"
#include "houndp.h"

//// Data structures to hold access information on Hound space.  We keep a linked list
//// for each dense code of the models for the at dense code.

#define	MAX_DENSE_CODES	(64 * 1024)

// List element.
typedef struct tagMODEL_ITEM {
	BYTE					*pModel;
	int						sizeModel;	// Size in bytes.
	struct tagMODEL_ITEM	*pNext;
} MODEL_ITEM;

// Array to hold head of list for each dense code.
HOUND_SPACE	*g_pHoundSpace;
int			g_maxModelsPerCP;
int			g_iMinModelHead;
int			g_iMaxModelHead;
MODEL_ITEM	*apModelHead[MAX_DENSE_CODES];

// Find max models for one code point.
int	MaxHoundModelsPerCP()
{
	int		ii;
	int		max;

	// Check each code point.
	max	= 0;
	for (ii = g_iMinModelHead; ii < g_iMaxModelHead; ++ii)
	{
		int			count;
		MODEL_ITEM	*pModel;

		// Count models for code point.
		count	= 0;
		for (pModel = apModelHead[ii]; pModel; pModel = pModel->pNext)
		{
			++count;
		}

		// Is it a new max?
		if (max < count) 
		{
			max	= count;
		}
	}

	return max;
}

// Code to parse a Hound space and record the location of each model in it.
BOOL ParseHoundSpace(HOUND_SPACE *pSpace)
{
	BYTE		*pScan;

	// Initialize limits so we can set them as we go.
	g_iMinModelHead	= MAX_DENSE_CODES;
	g_iMaxModelHead	= 0;

	// Clear the array.
	memset(apModelHead, 0, sizeof(apModelHead));

	// Save the space pointer.
	g_pHoundSpace	= pSpace;

	// Skip tables.
	pScan	= g_pHoundSpace->modelData;
	pScan	+= sizeof(DEPEND_PAIR) * g_pHoundSpace->cPairTable;
	pScan	+= sizeof(DEPEND_WEIGHT) * g_pHoundSpace->cWeightTable;

	// Scan the data for the models.
	for (; pScan[0] != 0x00 || pScan[1] != 0x00; ) {
		UNALIGNED wchar_t	*pdchLabel;

		BYTE		*pModel;
		wchar_t		dchLabel;
		WORD		iComponent;
		WORD		cComponent;
		MODEL_ITEM	*pModelItem;
		MODEL_ITEM	**ppScanEnd;
		
		// Remember where model starts.
		pModel		= pScan;

		// Extract the Code point.
		pdchLabel	= (wchar_t *)pScan;
		dchLabel	= *pdchLabel;
		pScan		+= 2;

		//// Skip the model

		// Extract the number of components in the model.
		cComponent	= *pScan++;
		ASSERT(cComponent <= MAX_HOUND_COMPONENTS);

		// Skip each mixture component...
		for (iComponent = 0; iComponent < cComponent; ++iComponent)
		{
			// Skip Comp. weight & factor.
			if (cComponent > 1)
			{
				pScan	+= 2;
			}
			pScan	+= 2;

			// Skip the diagonal.
			pScan	+= pSpace->numFeat;

			// Skip dependencies.
			while (*pScan != 0)
			{
				pScan += (*pScan < g_pHoundSpace->cPairOneByte) ? 1 : 2;
				pScan += (*pScan < g_pHoundSpace->cWeightOneByte) ? 1 : 2;
			}
			++pScan;
		}

		//// OK, have model, record it.

		// Allocate space.
		pModelItem	= (MODEL_ITEM *)malloc(sizeof(MODEL_ITEM));
		if (!pModelItem) {
			ASSERT(pModelItem);
			return FALSE;
		}

		// Fill in structure.
		pModelItem->pModel		= pModel;
		pModelItem->sizeModel	= (BYTE *)pScan - (BYTE *)pModel;
		pModelItem->pNext		= (MODEL_ITEM *)0;

		// Add to end of list list
		ppScanEnd	= apModelHead + dchLabel;
		while (*ppScanEnd)
		{
			ppScanEnd	= &((*ppScanEnd)->pNext);
		}
		*ppScanEnd	= pModelItem;

		// And keep track of min and max labels.
		if (g_iMinModelHead > dchLabel)
		{
			g_iMinModelHead	= dchLabel;
		}
		
		if (g_iMaxModelHead < dchLabel)
		{
			g_iMaxModelHead	= dchLabel;
		}
	}

	// Figure out max models per code point.
	g_maxModelsPerCP	= MaxHoundModelsPerCP();

	return TRUE;
}

// Print out each code point supported, the number of models it has, and the
// size of each.
BOOL HoundPrintModelList(FILE *pFile)
{
	wchar_t		dch;

	// Process each interesting code point.
	for (dch = (wchar_t)g_iMinModelHead; dch <= g_iMaxModelHead; ++dch)
	{
		int			cModels;
		MODEL_ITEM	*pScan;

		// Count the models.
		cModels		= 0;
		for (pScan = apModelHead[dch]; pScan; pScan = pScan->pNext)
		{
			++cModels;
		}

		if (cModels > 0) 
		{
			if (fwprintf(pFile, L"+ %04X %d", dch, cModels) < 0)
			{
				return FALSE;
			}
			for (pScan = apModelHead[dch]; pScan; pScan = pScan->pNext)
			{
				if (fwprintf(pFile, L" %d", pScan->sizeModel) < 0)
				{
					return FALSE;
				}
			}
			if (fwprintf(pFile, L"\n") < 0)
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}

// Given a data sample and a code point, give the score for each model for
// that code point.	 This fills in the scores in order of the models in
// the DB.  The array must be big enough to hold all the scores.  The return
// value give the number of entries filled in.
int	HoundMatchCodePoint(wchar_t dchLabel, const BYTE * const pSampleVector, double *pScores)
{
	int			iModel;
	MODEL_ITEM	*pScan;

	// Process each model in the list.
	iModel	= 0;
	for (pScan = apModelHead[dchLabel]; pScan; pScan = pScan->pNext)
	{
		HOUND_MATCH		houndMatch;

		// Set up match structure.
		houndMatch.numFeat			= g_pHoundSpace->numFeat;
		houndMatch.cPairOneByte		= g_pHoundSpace->cPairOneByte;
		houndMatch.cPairTable		= g_pHoundSpace->cPairTable;
		houndMatch.pPairOneByte		= (DEPEND_PAIR *)g_pHoundSpace->modelData;
		houndMatch.pPairTwoByte		= houndMatch.pPairOneByte + g_pHoundSpace->cPairOneByte;
		houndMatch.cWeightOneByte	= g_pHoundSpace->cWeightOneByte;
		houndMatch.cWeightTable		= g_pHoundSpace->cWeightTable;
		houndMatch.pWeightOneByte	= (DEPEND_WEIGHT *)(houndMatch.pPairOneByte + g_pHoundSpace->cPairTable);
		houndMatch.pWeightTwoByte	= houndMatch.pWeightOneByte + g_pHoundSpace->cWeightOneByte;
		houndMatch.pScanData		= pScan->pModel + 2;  // Skip label

		// Score the model.
		pScores[iModel]		= lLogDensityMixture(pSampleVector, &houndMatch);;

		// Finished this model.
		++iModel;
	}

	return iModel;
}

// Copy one of the loaded models to an output file.
int
HoundCopyModelToFile(FILE *pFile, wchar_t dchLabel, int iModel)
{
	int			ii;
	MODEL_ITEM	*pModelItem;

	// Find model.
	pModelItem	= apModelHead[dchLabel];
	for (ii = 0; pModelItem && ii < iModel; ++ii, pModelItem = pModelItem->pNext)
		;

	// Make sure model exists.
	if (!pModelItem)
	{
		return 0;
	}

	// Write it out.
	if (fwrite(pModelItem->pModel, pModelItem->sizeModel, 1, pFile) < 1)
	{
		return -1;
	}

	return pModelItem->sizeModel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\sources.inc ===
TARGETNAME=hound
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\hound\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
	 ..\hMatch.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\hound\src\houndp.h ===
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// Copyright (c) 2001 Microsoft Corporation.  All rights reserved.
// 
// Module:
//      houndp.h
//
// Description:
//      Private definitions for the hound project.
//
// Author:
//      jbenn
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#ifndef HOUNDP_H
#define HOUNDP_H 1

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif

// Some constants.
//#define	PI			((double) 3.1415926535898)
#define	MIN_DOUBLE		(-DBL_MAX)
#define MIN_FLOAT		(-FLT_MAX)

// Array size to hold all hound spaces directly indexed by space number.
#define	HOUND_NUM_SPACES	30

// Magic keys the identifies hawk.dat file
#define	HOUNDDB_FILE_TYPE	0xF002DDB1

// Version information for each file type.
#define	HOUNDDB_MIN_FILE_VERSION		1	// First version of code that can read this file
#define HOUNDDB_CUR_FILE_VERSION		1	// Current version of code.
#define	HOUNDDB_OLD_FILE_VERSION		1	// Oldest file version this code can read.

// The header of the costcalc.bin file
typedef struct tagHOUNDDB_HEADER
{
	DWORD		fileType;		// This should always be set to HOUNDDB_FILE_TYPE.
	WORD		headerSize;		// Size of the header.
	BYTE		minFileVer;		// Earliest version of code that can read this file
	BYTE		curFileVer;		// Current version of code that wrote the file.
	DWORD		adwSignature[3];// Locale signature
	BYTE		cSpaces;		// Number of spaces in file.
	BYTE		reserved1[3];
	DWORD		reserved2[2];
} HOUNDDB_HEADER;

// Structure to hold state while matching each model in a Hound space.
typedef struct tagHOUND_MATCH
{
	int				numFeat;			// Number of features to match
	WORD			cPairOneByte;		// Count of 1 byte dependency pair table entries.
	WORD			cPairTable;			// Count of all dependency pair table entries.
	DEPEND_PAIR		*pPairOneByte;		// Pointer to one byte dependency pair table.
	DEPEND_PAIR		*pPairTwoByte;		// Pointer to two byte dependency pair table.
	WORD			cWeightOneByte;		// Count of 1 byte dependency weight table entries.
	WORD			cWeightTable;		// Count of all dependency weight table entries.
	DEPEND_WEIGHT	*pWeightOneByte;	// Pointer to one byte dependency weight table.
	DEPEND_WEIGHT	*pWeightTwoByte;	// Pointer to two byte dependency weight table.
	BYTE			*pScanData;			// Current position in space array.
} HOUND_MATCH;

// Load & unload fundtions.
extern BOOL HoundLoadFromPointer(LOCRUN_INFO *pLocRunInfo, BYTE *pbRes, int cRes);
extern void HoundUnLoad();

// Hold per feature information we need to keep while doing match.
// We need the offset from the mean and the variance for the feature.
typedef struct tagHOUND_PER_FEAT {
	double		eMeanOffset;
	double		eVariance;
} HOUND_PER_FEAT;

// Structure to hold one dependency.
typedef struct tagHOUND_DEPEND {
	int		iDepende;
	int		iDependor;
	double	eWeight;
} HOUND_DEPEND;

// Match functions.
extern double lLogDensityMixture(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch
);

// Get ready to scan a Hound space.  This will fill in all the
// fields in the HOUND_SEQUENCE structure.  Return success or failure.
extern BOOL HoundMatchSequenceInit(UINT iSpace, HOUND_MATCH *pMatch);

// Given an array {log(p_1), ... , log(p_n)}, return log(p_1 + ... + p_n)
extern double	DblLogSumArray(double* rgdblLog, UINT celem);

// Given two log-probs sum the probabilities and return its log-prob
extern double	DblLogSum(double dblLog1, double dblLog2);

// Fetch the values for the diagonal.
extern void FetchDiagonal(
	const BYTE		* const pSampleVector,
	HOUND_MATCH		*pHoundMatch,
	HOUND_PER_FEAT	*pPerFeature
);

// Extract the next dependency from the data file.  If we hit the end of
// the dependency list, set the depende value to -1.
extern void FetchDepend(HOUND_MATCH *pHoundMatch, HOUND_DEPEND *pDepend);

// Computes the exponent part of a one dimensional Gaussian.
// That is, -1/2 * (x - mean)^2 / variance
// The numbers are in 16.16 format.
extern double lGaussianExponent(double eMeanOffset, double eVariance);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\ifelang3\inc\imlang.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for imlang.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imlang_h__
#define __imlang_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IIMLanguage_FWD_DEFINED__
#define __IIMLanguage_FWD_DEFINED__
typedef interface IIMLanguage IIMLanguage;
#endif 	/* __IIMLanguage_FWD_DEFINED__ */


#ifndef __IMLanguage_FWD_DEFINED__
#define __IMLanguage_FWD_DEFINED__

#ifdef __cplusplus
typedef class IMLanguage IMLanguage;
#else
typedef struct IMLanguage IMLanguage;
#endif /* __cplusplus */

#endif 	/* __IMLanguage_FWD_DEFINED__ */


#ifndef __IIMLanguageComponent_FWD_DEFINED__
#define __IIMLanguageComponent_FWD_DEFINED__
typedef interface IIMLanguageComponent IIMLanguageComponent;
#endif 	/* __IIMLanguageComponent_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_imlang_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// imlang.h


// IIMLanguage interface.

//=--------------------------------------------------------------------------=
// (C) Copyright 1999-2001 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

//Tuning parameter for Language model
typedef struct IMLANGUAGE_LM_PARAM
    {
    GUID guid;
    DWORD dwSize;
    /* [size_is] */ BYTE *pbData;
    } 	IMLANGUAGE_LM_PARAM;

typedef struct IMLANGUAGE_LM_PARAM *LPIMLANGUAGE_LM_PARAM;

//Language model item
typedef struct tagIMLANGUAGE_LM
    {
    GUID guid;
    IMLANGUAGE_LM_PARAM *pParam;
    } 	IMLANGUAGE_LM;

typedef struct tagIMLANGUAGE_LM *LPIMLANGUAGE_LM;

//IMLanguageComponent Application GUID
DEFINE_GUID( CLSID_CHS_IMELM_BBO,      0xd8b9f621, 0x3c24, 0x11d4, 0x97, 0xc2, 0x00, 0x80, 0xc8, 0x82, 0x68, 0x7e );
DEFINE_GUID( CLSID_CHT_IMELM_BBO,      0xd8b9f622, 0x3c24, 0x11d4, 0x97, 0xc2, 0x00, 0x80, 0xc8, 0x82, 0x68, 0x7e );
DEFINE_GUID( CLSID_KOR_IMELM_BBO,      0x254d975e, 0xacc9, 0x478b, 0xa0, 0x7b, 0x38, 0x5d, 0xaf, 0xaa, 0x4f, 0xb2 );
DEFINE_GUID( CLSID_JPN_IMELM_BBO,      0x4e3ac8a1, 0xbcb4, 0x4d2d, 0x83, 0x9b, 0xb1, 0x56, 0x0a, 0x11, 0x0d, 0x67 );
DEFINE_GUID( CLSID_MakeLatticeForChar, 0x258941B5, 0x9E27, 0x11d3, 0xB6, 0xD0, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );
DEFINE_GUID( CLSID_AttachNGram,        0x258941B6, 0x9E27, 0x11d3, 0xB6, 0xD0, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );
DEFINE_GUID( CLSID_SearchBestPath,     0x258941B7, 0x9E27, 0x11d3, 0xB6, 0xD0, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );
//IMLanguageComponent OS GUID
DEFINE_GUID( CLSID_CHS_IMELM_BBO_OS,   0x3acd1d47, 0xe067, 0x429c, 0xac, 0x6d, 0x47, 0xc6, 0x7e, 0x6c, 0x8d, 0xac);
DEFINE_GUID( CLSID_CHT_IMELM_BBO_OS,   0x84999b88, 0x25d2, 0x4648, 0xbb, 0xa7, 0x1e, 0x35, 0xa7, 0xc7, 0x4e, 0x16);
DEFINE_GUID( CLSID_KOR_IMELM_BBO_OS,   0xe09ace0d, 0x6eea, 0x4be9, 0x8d, 0xb8, 0xf8, 0x75, 0xc2, 0xd0, 0xde, 0xca);
DEFINE_GUID( CLSID_JPN_IMELM_BBO_OS,   0x9c7e214c, 0x5709, 0x4457, 0xac, 0x4c, 0x19, 0x30, 0xb3, 0x68, 0x6c, 0x81);
DEFINE_GUID( CLSID_MakeLatticeForChar_OS, 0x61991eb2, 0xca2e, 0x4c53, 0x83, 0x5f, 0xd7, 0x1d, 0x34, 0x35, 0x4b, 0x8f);
DEFINE_GUID( CLSID_AttachNGram_OS,     0xfa786731, 0xb396, 0x4124, 0xa6, 0x25, 0x6c, 0xc9, 0x47, 0xcc, 0x27, 0x38);
DEFINE_GUID( CLSID_SearchBestPath_OS,  0x3f9cc862, 0x58a3, 0x4a9a, 0xa4, 0x1b, 0x1d, 0xb8, 0xca, 0xf7, 0x5b, 0x20);

//Data area for lattice element
typedef struct tagIMLANGUAGE_INFO
    {
    GUID guid;
    DWORD dwSize;
    /* [size_is] */ BYTE *pbData;
    } 	IMLANGUAGE_INFO;

typedef struct tagIMLANGUAGE_INFO *LPIMLANGUAGE_INFO;

//Lattice element
typedef struct tagIMLANGUAGE_ELEMENT
    {
    DWORD dwFrameStart;
    DWORD dwFrameLen;
    DWORD dwTotalInfo;
    /* [size_is] */ IMLANGUAGE_INFO *pInfo;
    } 	IMLANGUAGE_ELEMENT;

typedef struct tagIMLANGUAGE_ELEMENT *LPIMLANGUAGE_ELEMENT;

//Data type for IMLANGUAGE_INFO
DEFINE_GUID( GUID_IMLANGUAGE_INFO_NEUTRAL1, 0x77d576f4, 0x7713, 0x11d3, 0xb6, 0xb9, 0x0, 0xc0, 0x4f, 0x7a, 0x2, 0xad );
typedef struct tag_IMLANGUAGE_INFO_NEUTRAL1
    {
    DWORD dwUnigram;
    struct 
        {
        BOOL fHypothesis	: 1;
        DWORD reserved	: 31;
        } 	;
    WCHAR wsz[ 1 ];
    } 	IMLANGUAGE_INFO_NEUTRAL1;


//
//
//
//Interface IIMLanguage
//
//
DEFINE_GUID( IID_IMLanguage,   0x258941B1, 0x9E27, 0x11d3, 0xB6, 0xD0, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );
DEFINE_GUID( LIBID_IMLanguage, 0x258941B2, 0x9E27, 0x11d3, 0xB6, 0xD0, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );
DEFINE_GUID( CLSID_IMLanguage, 0x258941B3, 0x9E27, 0x11d3, 0xB6, 0xD0, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );
DEFINE_GUID( CLSID_IMLanguage_OS, 0xefa75289, 0x66e, 0x4a8f, 0xa9, 0x78, 0x74, 0x9b, 0x1d, 0xd2, 0x38, 0x58);


extern RPC_IF_HANDLE __MIDL_itf_imlang_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imlang_0000_v0_0_s_ifspec;

#ifndef __IIMLanguage_INTERFACE_DEFINED__
#define __IIMLanguage_INTERFACE_DEFINED__

/* interface IIMLanguage */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IIMLanguage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("258941B1-9E27-11d3-B6D0-00C04F7A02AD")
    IIMLanguage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLatticeMorphResult( 
            /* [in] */ DWORD dwNumLMITEM,
            /* [size_is][in] */ IMLANGUAGE_LM aIMLANGUAGE_LM[  ],
            /* [in] */ DWORD dwTotalElemIn,
            /* [size_is][in] */ IMLANGUAGE_ELEMENT aElemIn[  ],
            /* [out] */ DWORD *pdwTotalElemOut,
            /* [size_is][size_is][out] */ IMLANGUAGE_ELEMENT **ppElemOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMLanguageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIMLanguage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIMLanguage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIMLanguage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatticeMorphResult )( 
            IIMLanguage * This,
            /* [in] */ DWORD dwNumLMITEM,
            /* [size_is][in] */ IMLANGUAGE_LM aIMLANGUAGE_LM[  ],
            /* [in] */ DWORD dwTotalElemIn,
            /* [size_is][in] */ IMLANGUAGE_ELEMENT aElemIn[  ],
            /* [out] */ DWORD *pdwTotalElemOut,
            /* [size_is][size_is][out] */ IMLANGUAGE_ELEMENT **ppElemOut);
        
        END_INTERFACE
    } IIMLanguageVtbl;

    interface IIMLanguage
    {
        CONST_VTBL struct IIMLanguageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMLanguage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIMLanguage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIMLanguage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIMLanguage_GetLatticeMorphResult(This,dwNumLMITEM,aIMLANGUAGE_LM,dwTotalElemIn,aElemIn,pdwTotalElemOut,ppElemOut)	\
    (This)->lpVtbl -> GetLatticeMorphResult(This,dwNumLMITEM,aIMLANGUAGE_LM,dwTotalElemIn,aElemIn,pdwTotalElemOut,ppElemOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIMLanguage_GetLatticeMorphResult_Proxy( 
    IIMLanguage * This,
    /* [in] */ DWORD dwNumLMITEM,
    /* [size_is][in] */ IMLANGUAGE_LM aIMLANGUAGE_LM[  ],
    /* [in] */ DWORD dwTotalElemIn,
    /* [size_is][in] */ IMLANGUAGE_ELEMENT aElemIn[  ],
    /* [out] */ DWORD *pdwTotalElemOut,
    /* [size_is][size_is][out] */ IMLANGUAGE_ELEMENT **ppElemOut);


void __RPC_STUB IIMLanguage_GetLatticeMorphResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIMLanguage_INTERFACE_DEFINED__ */



#ifndef __IMLanguage_LIBRARY_DEFINED__
#define __IMLanguage_LIBRARY_DEFINED__

/* library IMLanguage */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_IMLanguage;

EXTERN_C const CLSID CLSID_IMLanguage;

#ifdef __cplusplus

class DECLSPEC_UUID("258941B3-9E27-11d3-B6D0-00C04F7A02AD")
IMLanguage;
#endif
#endif /* __IMLanguage_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_imlang_0009 */
/* [local] */ 

//
//
//
//Interface of IIMLanguageComponent
//(only for those who make language components)
//
DEFINE_GUID( IID_IMLanguageComponent, 0x5F4FCFB0, 0xF961, 0x11d2, 0xB6, 0x13, 0x00, 0xC0, 0x4F, 0x7A, 0x02, 0xAD );



extern RPC_IF_HANDLE __MIDL_itf_imlang_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imlang_0009_v0_0_s_ifspec;

#ifndef __IIMLanguageComponent_INTERFACE_DEFINED__
#define __IIMLanguageComponent_INTERFACE_DEFINED__

/* interface IIMLanguageComponent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IIMLanguageComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F4FCFB0-F961-11d2-B613-00C04F7A02AD")
    IIMLanguageComponent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLatticeMorphResult( 
            /* [in] */ IMLANGUAGE_LM_PARAM *pTuneParam,
            /* [in] */ DWORD dwTotalElemIn,
            /* [size_is][in] */ IMLANGUAGE_ELEMENT aElemIn[  ],
            /* [out] */ DWORD *pdwTotalElemOut,
            /* [size_is][size_is][out] */ IMLANGUAGE_ELEMENT **ppElemOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMLanguageComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIMLanguageComponent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIMLanguageComponent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIMLanguageComponent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatticeMorphResult )( 
            IIMLanguageComponent * This,
            /* [in] */ IMLANGUAGE_LM_PARAM *pTuneParam,
            /* [in] */ DWORD dwTotalElemIn,
            /* [size_is][in] */ IMLANGUAGE_ELEMENT aElemIn[  ],
            /* [out] */ DWORD *pdwTotalElemOut,
            /* [size_is][size_is][out] */ IMLANGUAGE_ELEMENT **ppElemOut);
        
        END_INTERFACE
    } IIMLanguageComponentVtbl;

    interface IIMLanguageComponent
    {
        CONST_VTBL struct IIMLanguageComponentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMLanguageComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIMLanguageComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIMLanguageComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIMLanguageComponent_GetLatticeMorphResult(This,pTuneParam,dwTotalElemIn,aElemIn,pdwTotalElemOut,ppElemOut)	\
    (This)->lpVtbl -> GetLatticeMorphResult(This,pTuneParam,dwTotalElemIn,aElemIn,pdwTotalElemOut,ppElemOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIMLanguageComponent_GetLatticeMorphResult_Proxy( 
    IIMLanguageComponent * This,
    /* [in] */ IMLANGUAGE_LM_PARAM *pTuneParam,
    /* [in] */ DWORD dwTotalElemIn,
    /* [size_is][in] */ IMLANGUAGE_ELEMENT aElemIn[  ],
    /* [out] */ DWORD *pdwTotalElemOut,
    /* [size_is][size_is][out] */ IMLANGUAGE_ELEMENT **ppElemOut);


void __RPC_STUB IIMLanguageComponent_GetLatticeMorphResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIMLanguageComponent_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\inc\privdefs.h ===
// privdefs.h
// Angshuman Guha
// aguha
// April 30, 2001

#ifndef __INC_PRIVDEFS_H
#define __INC_PRIVDEFS_H

#define RECOFLAG_NNONLY		0x80000000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\baseline.h ===
#ifndef H_BASELINE_H
#define H_BASELINE_H


BOOL ComputeLatinLayoutMetrics(RECT *pBoundingRect, NFEATURESET *nfeatureset, int iStartSeg, int cCol, int *aNeuralCost, unsigned char *szWord, LATINLAYOUT *pll);
BOOL insertLatinLayoutMetrics(XRC *pxrc, ALTERNATES *pAlt, GLYPH *pGlyph);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\ifelang3\inc\fel3user.h ===
// *****************************************************************************
//  Microsoft Intelligent IME
//
//  Microsoft Confidential.
//  Copyright 1996-2000 Microsoft Corporation. All Rights Reserved.
// 
//	Project:	IME 2000
//  Component:  IFELang3 component entry
//	Module:		fel3user.h
//	Notes:		Define CLSIDs for PRC and TC IFELang3 language model.
//              This header will be exposed to IFELang3 clients
//	Owner:		donghz@microsoft.com
//	Platform:	Win32
//	Revise:		6/7/2000    create
//              8/9/2000    update names and add normalize factor
// *****************************************************************************
#ifndef _FEL3USER_H_
#define _FEL3USER_H_


// GUID for client parameter of Chinese ImeLM
DEFINE_GUID(GUID_CHINESE_IMELM_PARAM, 0xff6e52b3, 0x6de6, 0x11d4, 0x97, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// This is a LicenseId, the LM component uses this ID to identify
// whether the client is valid and legal
#define CHINESE_IMELM_LICENSEID    0x00000200

// HW TIP pass this paramter via one of tuning parameters in the
// IIMLanguage::GetLatticeMorphResult() call. imlang.dll passes it 
// to the above IMLanguageComponent.
struct SImeLMParam
{
    // LicenseId must be CHINESE_IMELM_LICENSEID for GUID_CLIENT_HWTIP1
    DWORD   dwLicenseId;

    // normalize factor multiply on the log_e(prob) exposed from dwUnigram
    // in NeutralData. Pass 0.0 to disable score/cost merging
    FLOAT   flWeight;
};


#endif // _FEL3USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\inc\privapi.h ===
// privapi.h
// Angshuman Guha, aguha
// April 13, 2000

// These are private API which the recognizer DLL usually exports if built
// with the "HWX_INTERNAL", "HWX_PENWINDOWS"  and "HWX_PRIVAPI" flags on.  

int WINAPI HwxGetWordResults(HRC hrc, UINT cAlt, char *buffer, UINT buflen);
int WINAPI HwxGetCosts(HRC hrc, UINT cAltMax, int *rgCost);
int WINAPI HwxGetNeuralOutput(HRC hrc, void *buffer, UINT buflen);
int WINAPI HwxGetInputFeatures(HRC hrc, unsigned short *rgFeat, UINT cWidth);
int WINAPI HwxSetAnswer(char *sz);
DWORD WINAPI HwxGetTiming(void *pVoid, BOOL bReset);


// Extra user Dictionary API's always available
int WINAPI AddWordsHWLW(HWL hwl, wchar_t *pwsz, UINT uType);
HWL WINAPI CreateHWLW(HREC hrec, wchar_t * pwsz, UINT uType, DWORD dwReserved);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\ifelang3\os\chs\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml .ife .imd

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

{}.imd{}.ife:
	copy $*.imd $*.ife

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\baseline.c ===
#include <common.h>
#include "nfeature.h"
#include "engine.h"
#include "nnet.h"
#include "fforward.h"
#include "charmap.h"
#include "charcost.h"
#include "probcost.h"
#include <lookuptable.h>

#define DIR_ROOT 0
#define DIR_NULL 1
#define DIR_LEFT 2
#define DIR_LTDN 3
#define DESCENDER_SUPPORTED 0
#define ASCENDER_SUPPORTED 0

const short int gaCharBaseline[4*256] = {
	// each line is a number between 0 and 100 (relative to ink rect height)
	// zero means bottom, 100 means top
	// Order is Baseline, Midline, Descender, Ascender
	// we use some special values 101-106 to make "weak" estimates which are
	// used only if we have no strong estimate; see HandleWeakEstimate()
	255, 255,  255,  255,   //0x00
	255, 255,  255,  255,   //0x01
	255, 255,  255,  255,   //0x02
	255, 255,  255,  255,   //0x03
	255, 255,  255,  255,   //0x04
	255, 255,  255,  255,   //0x05
	255, 255,  255,  255,   //0x06
	255, 255,  255,  255,   //0x07
	255, 255,  255,  255,	//0x08
	255, 255,  255,  255,	//0x09
	255, 255,  255,  255,	//0x0A
	255, 255,  255,  255,	//0x0B
	255, 255,  255,  255,	//0x0C
	255, 255,  255,  255,	//0x0D
	255, 255,  255,  255,   //0x0E
	255, 255,  255,  255,   //0x0F
	255, 255,  255,  255,   //0x10
	255, 255,  255,  255,   //0x11
	255, 255,  255,  255,	//0x12
	255, 255,  255,  255,   //0x13
	255, 255,  255,  255,   //0x14
	255, 255,  255,  255,   //0x15
	255, 255,  255,  255,   //0x16
	255, 255,  255,  255,   //0x17
	255, 255,  255,  255,   //0x18
	255, 255,  255,  255,   //0x19
	255, 255,  255,  255,   //0x1A
	255, 255,  255,  255,   //0x1B
	255, 255,  255,  255,   //0x1C
	255, 255,  255,  255,   //0x1D
	255, 255,  255,  255,   //0x1E
	255, 255,  255,  255,   //0x1F
	255, 255,  255,  255,   //0x20
	  0,  50,  255,	 ASCENDER_SUPPORTED,       // 0x21 
	103, 255,  255,  ASCENDER_SUPPORTED,       // " 0x22
	  0,  50,  255,  ASCENDER_SUPPORTED,       // # 0x23
	  0,  50,  255,	 ASCENDER_SUPPORTED,       // $ 0x24
	  0,  50,  255,  ASCENDER_SUPPORTED,       // % 0x25
	  0,  50,  255,  ASCENDER_SUPPORTED,       // & 0x26
	103, 255,  255,  ASCENDER_SUPPORTED,       // ' 0x27
	  0,  50,  255,  ASCENDER_SUPPORTED,       // (  0x28
	  0,  50,  255,  ASCENDER_SUPPORTED,       // )  0x29
	  0, 100,  255,  ASCENDER_SUPPORTED,       // *  0x2A
	  0, 100,  255,  ASCENDER_SUPPORTED,       // +  0x2B
	100, 255,  255,  255,       // ,  0x2C
	104, 255,  255,  255,       // -  0x2D
	100, 255,  255,  255,       // .  0x2E
	  0,  50,  255,  ASCENDER_SUPPORTED,       // /  0x2F
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 0  0x30
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 1  0x31
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 2  0x32
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 3  0x33
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 4  0x34
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 5  0x35
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 6  0x36
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 7  0x37
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 8  0x38
	  0,  50,  255,  ASCENDER_SUPPORTED,       // 9  0x39
	  0, 100,  255,  255,       // :  0x3A
	  0, 100,  255,  255,       // ;  0x3B
	  0, 100,  255,  ASCENDER_SUPPORTED,       // <  0x3C
	104, 255,  255,  255,       // =  0x3D
	  0, 100,  255,	 ASCENDER_SUPPORTED,       // >  0x3E
	  0,  50,  255,  ASCENDER_SUPPORTED,       // ?  0x3F
	101, 102,  255,  ASCENDER_SUPPORTED,       // @  0x40
	  0,  50,  255,  ASCENDER_SUPPORTED,       // A  0x41
	  0,  50,  255,  ASCENDER_SUPPORTED,       // B  0x42
	  0,  50,  255,  ASCENDER_SUPPORTED,       // C  0x43
	  0,  50,  255,  ASCENDER_SUPPORTED,       // D  0x44
	  0,  50,  255,  ASCENDER_SUPPORTED,       // E  0x45
	  0,  50,  255,  ASCENDER_SUPPORTED,       // F  0x46
	  0,  50,  255,  ASCENDER_SUPPORTED,       // G  0x47
	  0,  50,  255,  ASCENDER_SUPPORTED,       // H  0x48
	  0,  50,  255,  ASCENDER_SUPPORTED,       // I  0x49
	  0,  50,  255,  ASCENDER_SUPPORTED,       // J  0x4A
	  0,  50,  255,  ASCENDER_SUPPORTED,       // K  0x4B
	  0,  50,  255,  ASCENDER_SUPPORTED,       // L  0x4C
	  0,  50,  255,  ASCENDER_SUPPORTED,       // M  0x4D
	  0,  50,  255,  ASCENDER_SUPPORTED,       // N  0x4E
	  0,  50,  255,  ASCENDER_SUPPORTED,       // O  0x4F
	  0,  50,  255,  ASCENDER_SUPPORTED,       // P  0x50
	  0,  50,  255,  ASCENDER_SUPPORTED,       // Q  0x51
	  0,  50,  255,  ASCENDER_SUPPORTED,       // R  0x52
	  0,  50,  255,  ASCENDER_SUPPORTED,       // S  0x53
	  0,  50,  255,  ASCENDER_SUPPORTED,       // T  0x54
	  0,  50,  255,  ASCENDER_SUPPORTED,       // U  0x55
	  0,  50,  255,  ASCENDER_SUPPORTED,       // V  0x56
	  0,  50,  255,  ASCENDER_SUPPORTED,       // W  0x57
	  0,  50,  255,  ASCENDER_SUPPORTED,       // X  0x58
	  0,  50,  255,  ASCENDER_SUPPORTED,       // Y  0x59
	  0,  50,  255,  ASCENDER_SUPPORTED,       // Z  0x5A
	  0,  50,  255,  ASCENDER_SUPPORTED,       // [  0x5B
	  0,  50,  255,  ASCENDER_SUPPORTED,       // \  0x5C
	  0,  50,  255,  ASCENDER_SUPPORTED,       // ]  0x5D
	103, 255,  255,  ASCENDER_SUPPORTED,       // ^  0x5E
	100, 255,  DESCENDER_SUPPORTED,  255,       // _  0x5F
	103, 255,  255,  ASCENDER_SUPPORTED,       // `  0x60
	  0, 100,  255,  255,       // a  0x61
	  0,  50,  255,  ASCENDER_SUPPORTED,       // b  0x62
	  0, 100,  255,  255,       // c  0x63
	  0,  50,  255,  ASCENDER_SUPPORTED,       // d  0x64
	  0, 100,  255,  255,       // e  0x65
	 33,  66,  255,  ASCENDER_SUPPORTED,       // f  0x66
	 50, 100,  DESCENDER_SUPPORTED,  255,       // g  0x67
	  0,  50,  255,  ASCENDER_SUPPORTED,        // h  0x68
	  0, 100,  255,  255,       // i   0x69
	 50, 100,  DESCENDER_SUPPORTED ,  255,       // j   0x6A
	  0,  50,  255,  ASCENDER_SUPPORTED,       // k   0x6B
	  0,  50,  255,  ASCENDER_SUPPORTED,       // l   0x6C
	  0, 100,  255,  255,       // m   0x6D
	  0, 100,  255,  255,       // n   0x6E
	  0, 100,  255,  255,       // o   0x6F
	 50, 100,  DESCENDER_SUPPORTED,  255,       // p   0x70
	 50, 100,  DESCENDER_SUPPORTED,  255,       // q   0x71
	  0, 100,  255,  255,       // r   0x72
	  0, 100,  255,  255,       // s   0x73
	  0,  50,  255,  ASCENDER_SUPPORTED,       // t   0x74
	  0, 100,  255,  255,       // u   0x75
	  0, 100,  255,  255,       // v   0x76
	  0, 100,  255,  255,       // w   0x77
	  0, 100,  255,  255,       // x   0x78
	 50, 100,  DESCENDER_SUPPORTED,  255,       // y   0x79
	101, 100,  255,  255,       // z   0x7A
	  0,  50,  255,  ASCENDER_SUPPORTED,       // {   0x7B
	  0,  50,  255,  ASCENDER_SUPPORTED,       // |   0x7C
	  0,  50,  255,  ASCENDER_SUPPORTED,       // }   0x7D
	104, 255,  255,  ASCENDER_SUPPORTED,       // ~   0x7E
	255, 255,  255,  255,       //     0x7F                             
	255, 255,  255,  255,       //		0x80
	255, 255,  255,  255,		//		0x81
	255, 255,  255,  255,		//		0x82
	255, 255,  255,  255,		//		0x83
	255, 255,  255,  255,		//		0x84
	255, 255,  255,  255,		//		0x85
	255, 255,  255,  255,		//		0x86
	255, 255,  255,  255,		//		0x87
	255, 255,  255,  255,		//		0x88
	255, 255,  255,  255,		//		0x89
	255, 255,  255,  255,		//		0x8A
	255, 255,  255,  255,		//		0x8B
	255, 255,  255,  255,		//		0x8C
	255, 255,  255,  255,		//		0x8D
	255, 255,  255,  255,		//		0x8E
	255, 255,  255,  255,		//		0x8F
	255, 255,  255,  255,		//		0x90
	255, 255,  255,  255,		//		0x91
	255, 255,  255,  255,		//		0x92
	255, 255,  255,  255,		//		0x93
	255, 255,  255,  255,		//		0x94
	255, 255,  255,  255,		//		0x95
	255, 255,  255,  255,		//		0x96
	255, 255,  255,  255,		//		0x97
	255, 255,  255,  255,		//		0x98
	255, 255,  255,  255,		//		0x99
	255, 255,  255,  255,		//		0x9A
	255, 255,  255,  255,		//		0x9B
	255, 255,  255,  255,		//		0x9C
	255, 255,  255,  255,		//		0x9D
	255, 255,  255,  255,		//		0x9E
	255, 255,  255,  255,		//		0x9F
	255, 255,  255,  255,		//		0xA0
	255, 255,  255,  255,		//		0xA1
	255, 255,  255,  255,		//		0xA2
	  0,  50,  255,  ASCENDER_SUPPORTED,		//		0xA3
	255, 255,  255,  255,		//		0xA4
	255, 255,  255,  255,		//		0xA5
	255, 255,  255,  255,		//		0xA6
	255, 255,  255,  255,		//		0xA7
	255, 255,  255,  255,		//		0xA8
	255, 255,  255,  255,		//		0xA9
	255, 255,  255,  255,		//		0xAA
	255, 255,  255,  255,		//		0xAB
	255, 255,  255,  255,		//		0xAC
	255, 255,  255,  255,		//		0xAD
	255, 255,  255,  255,		//		0xAE
	255, 255,  255,  255,		//		0xAF
	255, 255,  255,  255,		//		0xB0
	255, 255,  255,  255,		//		0xB1
	255, 255,  255,  255,		//		0xB2
	255, 255,  255,  255,		//		0xB3
	255, 255,  255,  255,		//		0xB4
	255, 255,  255,  255,		//		0xB5
	255, 255,  255,  255,		//		0xB6
	255, 255,  255,  255,		//		0xB7
	255, 255,  255,  255,		//		0xB8
	255, 255,  255,  255,		//		0xB9
	255, 255,  255,  255,		//		0xBA
	255, 255,  255,  255,		//		0xBB
	255, 255,  255,  255,		//		0xBC
	255, 255,  255,  255,		//		0xBD
	255, 255,  255,  255,		//		0xBE
	255, 255,  255,  255,		//		0xBF
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC0 
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC1 
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC2                 
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC3	
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC4   
	255, 255,  255,  ASCENDER_SUPPORTED,		//		0xC5    
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC6   
	 10,  60,  255,  ASCENDER_SUPPORTED,		//		0xC7   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC8   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xC9   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xCA   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xCB   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xCC   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xCD  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xCE  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xCF  
	255, 255,  255,  255,		//		0xD0  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD1  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD2  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD3  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD4  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD5  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD6  
	255, 255,  255,  255,		//		0xD7  
	255, 255,  255,  255,		//		0xD8  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xD9   
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xDA  
	  0, 105,  255,  ASCENDER_SUPPORTED,		//		0xDB  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xDC  
	  0, 106,  255,  ASCENDER_SUPPORTED,		//		0xDD  
	255, 255,  255,  255,		//		0xDE  
	  0,  50,  255,  ASCENDER_SUPPORTED,		//		0xDF  
	  0, 105,  255,  255,		//		0xE0  
	  0, 105,  255,  255,		//		0xE1  
	  0, 105,  255,  255,		//		0xE2  
	  0, 105,  255,  255,		//		0xE3  
	  0, 105,  255,  255,		//		0xE4  
	255, 255,  255,  255,		//		0xE5  
	  0, 100,  255,  255,		//		0xE6  
	 10, 100,  255,  255,		//		0xE7  
	  0, 105,  255,  255,		//		0xE8  
	  0, 105,  255,  255,		//		0xE9  
	  0, 105,  255,  255,		//      0xEA  
	  0, 105,  255,  255,		//		0xEB  
	  0, 105,  255,  255,		//		0xEC  
	  0, 105,  255,  255,		//		0xED  
	  0, 105,  255,  255,		//		0xEE  
	  0, 105,  255,  255,		//		0xEF  
	255, 255,  255,  255,		//		0xF0  
	  0, 105,  255,  255,		//		0xF1  
	  0, 105,  255,  255,		//		0xF2  
	  0, 105,  255,  255,		//		0xF3  
	  0, 105,  255,  255,		//		0xF4  
	  0, 105,  255,  255,		//		0xF5  
      0, 105,  255,  255,		//		0xF6  
	255, 255,  255,  255,		//		0xF7  
	255, 255,  255,  255,		//		0xF8   
	  0, 105,  255,  255,		//		0xF9  
	  0, 105,  255,  255,		//		0xFA 
	  0, 105,  255,  255,		//		0xFB  
	  0, 105,  255,  255,		//		0xFC  
	 40, 105,  255,  255,		//		0xFD  
	255, 255,  255,  255,		//		0xFE  
	 40, 105,  255,  255		//		0xFF  
};

typedef struct {
	int cBaseline;
	int cSumBaseline;
	int cMidline;
	int cSumMidline;
	int cAscender;
    int cSumAscender;
    int cDescender;
    int cSumDescender;

	int cBaselineWeak;
	int cSumBaselineWeak;
	int cMidlineWeak;
	int cSumMidlineWeak;


	int cTopline;
	int cSumTopline;
	int cDashline;
	int cSumDashline;
} BaselineEstimate;

void HandleWeakEstimate(int iCode, BaselineEstimate *pEstimate, RECT *pRect)
{
	switch(iCode)
	{
	case 101:
		// baseline from @z
		pEstimate->cBaselineWeak++;
		pEstimate->cSumBaselineWeak += pRect->bottom;
		break;
	case 102:
		// midline from @
		pEstimate->cMidlineWeak++;
		pEstimate->cSumMidlineWeak += pRect->top;
		break;
	case 103:
		// top line from "'`^
		pEstimate->cTopline++;
		pEstimate->cSumTopline += pRect->top;
		break;
	case 104:
		// "dash" line from -=~
		pEstimate->cDashline++;
		pEstimate->cSumDashline += (pRect->top + pRect->bottom)/2;
		break;
	case 105:
		//Weak estimates for the midline for the small case characters for the European Accent
		pEstimate->cMidlineWeak++;
		pEstimate->cSumMidlineWeak+=pRect->bottom -(pRect->bottom-pRect->top)*80/100;	
		
		break;

	case 106:
		//Weak estimate for the midline for the capital characters for the European accents 
		pEstimate->cMidlineWeak++;
		pEstimate->cSumMidlineWeak+=pRect->bottom -(pRect->bottom-pRect->top)*40/100;
		
		break;
	default:
		break;
	}
}

unsigned char GuessBaselineFromTwo(unsigned char bMidline, int midline, unsigned char bTopline, int topline, unsigned char bDashline, int dashline, int *piBaseline)
{
	int cBaseline=0, cSumBaseline=0;

	if (bMidline && bTopline)
	{
		cSumBaseline += 2*midline - topline;
		cBaseline++;
	}
	if (bMidline && bDashline)
	{
		cSumBaseline += 2*dashline - midline;
		cBaseline++;
	}
	if (bDashline && bTopline)
	{
		cSumBaseline += dashline + (dashline - topline)/3;
		cBaseline++;
	}
	if (cBaseline)
	{
		*piBaseline = cSumBaseline/cBaseline;
		return TRUE;
	}
	else
		return FALSE;
}

unsigned char GuessMidlineFromTwo(unsigned char bBaseline, int baseline, unsigned char bTopline, int topline, unsigned char bDashline, int dashline, int *piMidline)
{
	int cMidline=0, cSumMidline=0;

	if (bBaseline && bTopline)
	{
		cSumMidline += (baseline + topline)/2;
		cMidline++;
	}
	if (bBaseline && bDashline)
	{
		cSumMidline += 2*dashline - baseline;
		cMidline++;
	}
	if (bTopline && bDashline)
	{
		cSumMidline += dashline - (dashline - topline)/3;
		cMidline++;
	}
	if (cMidline)
	{
		*piMidline = cSumMidline/cMidline;
		return TRUE;
	}
	else
		return FALSE;
}

void GuessBaselineMidlineFromOne(unsigned char *pbBaselineValid, int *piBaseline, unsigned char *pbMidlineValid, int *piMidline, unsigned char bTopline, int topline, unsigned char bDashline, int dashline, int size)
{
	if (size <= 1)
		size = 2;

	if (*pbBaselineValid)
	{
		// estimate midline
		*piMidline = *piBaseline - 3*size/2;
		*pbMidlineValid = TRUE;
	}
	else if (*pbMidlineValid)
	{
		// estimate baseline
		*piBaseline = *piMidline + 3*size/2;
		*pbBaselineValid = TRUE;
	}
	else if (bTopline)
	{
		// estimate baseline and midline
		*piMidline = topline + 3*size/2;
		*piBaseline = topline + 3*size;
		*pbBaselineValid = TRUE;
		*pbMidlineValid = TRUE;
	}
	else if (bDashline)
	{
		// estimate baseline and midline
		*piMidline = dashline - 3*size/4;
		*piBaseline = dashline + 3*size/4;
		*pbBaselineValid = TRUE;
		*pbMidlineValid = TRUE;
	}
}

/******************************Private*Routine******************************\
* EstimateCharBaseline
*
* Function to estimate baseline and midline from a single recognized char.
*
* History:
*  15-May-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void EstimateCharBaseline(unsigned char ch, NFEATURESET *nfeatureset, int iStartCol, int iStopCol, BaselineEstimate *pEstimate)
{
	NFEATURE *nfeature = nfeatureset->head;
	int iCol, iBaseline, iMidline,iDescender,iAscender;
	RECT rect;

	ASSERT(0 <= iStartCol);
	ASSERT(iStartCol <= iStopCol);
	ASSERT(iStopCol < nfeatureset->cSegment);

	iBaseline = gaCharBaseline[4*ch];
	iMidline = gaCharBaseline[4*ch+1];
	iDescender = gaCharBaseline[4*ch+2];
	iAscender = gaCharBaseline[4*ch+3];

	// does this char support any estimation?
	if ((iBaseline == 255) && (iMidline == 255) && (iDescender == 255) && (iAscender == 255))
		return;

	// compute bounding rect of char

	for (iCol=0; iCol<iStartCol; iCol++)
		nfeature = nfeature->next;

	rect = nfeature->rect;
	for (iCol=iStartCol+1, nfeature=nfeature->next; iCol<=iStopCol; iCol++)
	{
		RECT *pRect = &nfeature->rect;

		if (pRect->top < rect.top)
			rect.top = pRect->top;
		if (pRect->bottom > rect.bottom)
			rect.bottom = pRect->bottom;
	}

	// given bounding rect of char, estimate baseline if possible
	if (iBaseline <= 100)
	{
		ASSERT(iBaseline >= 0);
		pEstimate->cBaseline++;
		pEstimate->cSumBaseline += rect.bottom - (rect.bottom-rect.top)*iBaseline/100;
	}
	else if (iBaseline < 255)
		HandleWeakEstimate(iBaseline, pEstimate, &rect);

	// given bounding rect of char, estimate midline if possible
	if (iMidline <= 100)
	{
		ASSERT(iMidline >= 0);
		pEstimate->cMidline++;
		pEstimate->cSumMidline += rect.bottom - (rect.bottom-rect.top)*iMidline/100;
	}
	else if (iMidline < 255)
		HandleWeakEstimate(iMidline, pEstimate, &rect);

	if (DESCENDER_SUPPORTED == iDescender)
	{
		ASSERT(iDescender == DESCENDER_SUPPORTED);
		pEstimate->cDescender++ ;
		pEstimate->cSumDescender+=rect.bottom;
	}
	if (ASCENDER_SUPPORTED == iAscender)

	{
		ASSERT(iAscender == ASCENDER_SUPPORTED);
		pEstimate->cAscender++;
		pEstimate->cSumAscender+=rect.top;
	}

}


/******************************Private*Routine******************************\
* ComputeLatinLayoutMetrics
*
* Function to estimate baseline, midline etc from a recognized string/word.
*
* History:
*  20-Mar-2002 -by- Angshuman Guha aguha
* Wrote it.
* In its previous incarnation it used to be called ComputeBaseline() and was
* called from the API compute the baseline stuff on the fly.  Now it is called
* at recognition time and the results are cached.
\**************************************************************************/
BOOL ComputeLatinLayoutMetrics(RECT *pBoundingRect, NFEATURESET *nfeatureset, int iStartSeg, int cCol, int *aNeuralCost, unsigned char *szWord, LATINLAYOUT *pll)
{
	NFEATURE *nfeature=NULL;
	int *pNeuralCost=NULL;
	BOOL bUsingGivenWord = TRUE;
	unsigned char *sz=NULL, thisChar;
	int	cRow;
	unsigned char *aDirection=NULL, *pDirection=NULL;
	int *aCost=NULL, *pCost=NULL, col, row;
	BaselineEstimate estimate;
	int iBaseline=0, iMidline=0, iAscenderline=0, iDescenderline=0;

	if (!nfeatureset || (nfeatureset->cSegment <= 0) || iStartSeg < 0 || iStartSeg + cCol > nfeatureset->cSegment)
	{
		return FALSE;
	}


	// punt if any unsupported characters
	sz = szWord;
	while (*sz && IsSupportedChar(*sz))
		sz++;
	if (*sz)
		return FALSE;

	// delete spaces from word, if any
	sz = szWord;
	while (*sz && !isspace1252(*sz))
		sz++;
	if (*sz)
	{
		// there is atleast one space
		unsigned char *szGiven = szWord;
		szWord = (unsigned char *) ExternAlloc(strlen(szGiven)*sizeof(unsigned char)); // we need atleast one char less
		if (!szWord)
			goto fail;
		sz = szWord;
		while (*szGiven)
		{
			if (!isspace1252(*szGiven))
				*sz++ = *szGiven++;
			else
				szGiven++;
		}
		*sz = '\0';
		bUsingGivenWord = FALSE;
	}
	cRow = strlen(szWord);

	// sanity check
	if (cRow > cCol)
	{	
		if (!bUsingGivenWord)
			ExternFree(szWord);
		pll->bBaseLineSet = FALSE;
		pll->bMidLineSet = FALSE;
		pll->bAscenderLineSet = FALSE;
		pll->bDescenderLineSet = FALSE;
		return TRUE;
	}
	
	// do dtw with given word
	pDirection = aDirection = (unsigned char *) ExternAlloc(cRow*cCol*sizeof(unsigned char));
	aCost = (int *) ExternAlloc(cCol*sizeof(int));  // re-used for each row
	if (!aDirection || !aCost)
		goto fail;

	// row 0
	sz = szWord;
	pCost = aCost;
	thisChar = *sz++;
	pNeuralCost = aNeuralCost;
	*pCost = NetFirstActivation(pNeuralCost, thisChar);
	*pDirection++ = DIR_ROOT;
	for (col=1; col<cCol; col++)
	{
		int leftcost;

		pNeuralCost += C_CHAR_ACTIVATIONS;
		leftcost = *pCost++ + NetContActivation(pNeuralCost, thisChar);
		*pCost = leftcost;
		*pDirection++ = DIR_LEFT;
	}

	// all other rows
	for (row=1; row<cRow; row++)
	{
		int saveCost;

		pCost = aCost;
		thisChar = *sz++;
		pNeuralCost = aNeuralCost;
		saveCost = *pCost;
		*pCost = INFINITY_COST;
		*pDirection++ = DIR_NULL;
		for (col=1; col<row; col++)
		{
			pNeuralCost += C_CHAR_ACTIVATIONS;
			saveCost = *++pCost;
			*pCost = INFINITY_COST;
			*pDirection++ = DIR_NULL;
		}
		for (; col<cCol; col++)
		{
			int leftcost, leftdowncost;

			pNeuralCost += C_CHAR_ACTIVATIONS;
			leftcost = *pCost + NetContActivation(pNeuralCost, thisChar);
			leftdowncost = saveCost + NetFirstActivation(pNeuralCost, thisChar);
			saveCost = *++pCost;
			if (leftcost < leftdowncost)
			{
				*pCost = leftcost;
				*pDirection++ = DIR_LEFT;
			}
			else
			{
				*pCost = leftdowncost;
				*pDirection++ = DIR_LTDN;
			}
		}

	}

	ASSERT(pDirection - aDirection == cRow*cCol);
	ASSERT(sz - szWord == cRow);

	ExternFree(aCost);

	// backtrack to segment ink into chars
	memset(&estimate, 0, sizeof(estimate));
	szWord += cRow;
	col = cCol;
	for (row=cRow-1; row>=0; row--)
	{
		int lastCol = --col;

		while ((col >= 0) && (aDirection[row*cCol+col] == DIR_LEFT))
			col--;
		if (col < 0)
		{
			ASSERT(0);
			return HRCR_ERROR;
		}
		// sanity check
		if (row)
		{
			if ((aDirection[row*cCol+col] != DIR_LTDN) || (col == 0))
			{
				ASSERT(0);
				return HRCR_ERROR;
			}
		}
		else
		{
			if ((aDirection[row*cCol+col] != DIR_ROOT) || (col != 0))
			{
				ASSERT(0);
				return HRCR_ERROR;
			}
		}
		EstimateCharBaseline(*--szWord, nfeatureset, col + iStartSeg, lastCol + iStartSeg, &estimate);
	}

	if (!bUsingGivenWord)
		ExternFree(szWord);
	ExternFree(aDirection);

	// compute baseline
	if (estimate.cBaseline)
	{
		pll->bBaseLineSet = TRUE;
		iBaseline = estimate.cSumBaseline/estimate.cBaseline;
	}
	else if (estimate.cBaselineWeak)
	{
		pll->bBaseLineSet = TRUE;
		iBaseline = estimate.cSumBaselineWeak/estimate.cBaselineWeak;
	}
	else
		pll->bBaseLineSet = FALSE;

	// compute midline
	if (estimate.cMidline)
	{
		pll->bMidLineSet = TRUE;
		iMidline = estimate.cSumMidline/estimate.cMidline;
	}
	else if (estimate.cMidlineWeak)
	{
		pll->bMidLineSet = TRUE;
		iMidline = estimate.cSumMidlineWeak/estimate.cMidlineWeak;
	}
	else
		pll->bMidLineSet = FALSE;

	// Compute descender line
	if (estimate.cDescender)
	{
		pll->bDescenderLineSet = TRUE;
		iDescenderline = estimate.cSumDescender/estimate.cDescender;
	}
	else 
		pll->bDescenderLineSet = FALSE;

    // Compute Ascender Line
	if (estimate.cAscender)
	{
		pll->bAscenderLineSet = TRUE;
		iAscenderline = estimate.cSumAscender/estimate.cAscender;
	}
	else 
		pll->bAscenderLineSet = FALSE;

	// if we still don't have baseline and/or midline estimates,
	// we are going to try to use the other (viz. topline and dashline)
	// estimates to save our bacon
	if (!pll->bBaseLineSet || !pll->bMidLineSet)
	{
		int topline=0, dashline=0;
		unsigned char bTopline, bDashline;

		if (estimate.cTopline)
		{
			topline = estimate.cSumTopline/estimate.cTopline;
			bTopline = TRUE;
		}
		else
			bTopline = FALSE;

		if (estimate.cDashline)
		{
			dashline = estimate.cSumDashline/estimate.cDashline;
			bDashline = TRUE;
		}
		else
			bDashline = FALSE;

		if (!pll->bBaseLineSet)
			pll->bBaseLineSet = GuessBaselineFromTwo(pll->bMidLineSet, iMidline, bTopline, topline, bDashline, dashline, &iBaseline);
		if (!pll->bMidLineSet)
			pll->bMidLineSet = GuessMidlineFromTwo(pll->bBaseLineSet, iBaseline, bTopline, topline, bDashline, dashline, &iMidline);

		// okay, here is the last straw!
		if (!pll->bBaseLineSet || ! pll->bMidLineSet)
			GuessBaselineMidlineFromOne(&pll->bBaseLineSet, &iBaseline, 
										&pll->bMidLineSet, &iMidline, 
										bTopline, topline, bDashline, dashline, 
										pBoundingRect->right-pBoundingRect->left+pBoundingRect->bottom-pBoundingRect->top);
	}

	// convert all lines to relative coordinates
	if (pll->bAscenderLineSet)
		pll->iAscenderLine = AbsoluteToLatinLayout(iAscenderline, pBoundingRect);
	else
		pll->iAscenderLine = 0;
	if (pll->bBaseLineSet)
		pll->iBaseLine = AbsoluteToLatinLayout(iBaseline, pBoundingRect);
	else
		pll->iBaseLine = 0;
	if (pll->bDescenderLineSet)
		pll->iDescenderLine = AbsoluteToLatinLayout(iDescenderline, pBoundingRect);
	else
		pll->iDescenderLine = 0;
	if (pll->bMidLineSet)
		pll->iMidLine = AbsoluteToLatinLayout(iMidline, pBoundingRect);
	else
		pll->iMidLine = 0;

	if (pll->bBaseLineSet && pll->bMidLineSet && (pll->iBaseLine <= pll->iMidLine))
	{
		pll->iBaseLine = AbsoluteToLatinLayout(pBoundingRect->bottom, pBoundingRect);
		pll->iMidLine = AbsoluteToLatinLayout(pBoundingRect->top, pBoundingRect);
		ASSERT(pll->iBaseLine >= pll->iMidLine);
	}

	return TRUE;

fail:
	if (!bUsingGivenWord)
			ExternFree(szWord);
	ExternFree(aDirection);
	ExternFree(aCost);
	return FALSE;
}

// Locate the start segment and number of segments corresponding to a word map
int locateSegments(
WORDMAP		*pMap,			// IN: Input map
int			*piStartSeg,	// Out: Starting Segmentr for the map
int			*cPrimStroke,	// Out: # Primary strokes
NFEATURE	*pFeat,			// IN: Start of Feat Linked list
NFEATURE	**ppFeatList	// Out: Feature linked list root
)
{
	int		i, cSeg, iStroke;
	
	*cPrimStroke = *piStartSeg = 0;
	cSeg = 0;

	if (pMap->cStrokes > 0)
	{
		iStroke = *pMap->piStrokeIndex;

		while(pFeat && pFeat->pMyFrame->iframe < iStroke)
		{
			if (pFeat->iSecondaryStroke == iStroke)
			{
				// Start with a secondary stroke ??? Bail out
				return cSeg;
			}

			++(*piStartSeg);
			pFeat = pFeat->next;
		}
	}

	*ppFeatList = pFeat;

	for (i = 0 ; i < pMap->cStrokes && pFeat ; ++i)
	{
		int		bFound = 0;
		iStroke = pMap->piStrokeIndex[i];

		//ASSERT(iStroke <= pFeat->pMyFrame->iframe);

		while(pFeat && pFeat->pMyFrame->iframe == iStroke)
		{
			++cSeg;
			++bFound;
			pFeat = pFeat->next;
		}

		if (bFound > 0)
		{
			(*cPrimStroke)++;
		}
		//ASSERT(!pFeat || pFeat->pMyFrame->iframe > iStroke);
	}

	return cSeg;
}

// Insert Layout Metrics into an alt list
// The Alt list should be a single word (not panel alt list)
// This is a general purpose function. It sometimes gets called
// with an xrc whose atrenaytes is exacatly pAlt. It can also
// be called with pxrc being a superset of pAlt. 
// 
// If pInGlyph is non NULL then it is assumed to be exactly the glyph for the alt.
// If it is NULL then extract the portion of the glyph from the xrc
//
BOOL insertLatinLayoutMetrics(XRC *pxrc, ALTERNATES *pAlt, GLYPH *pInGlyph)
{
	GLYPH		*pGlyph = NULL;
	WORDMAP		*pWordMap;

	if (pAlt->aAlt->cWords != 1)
	{
		return FALSE;
	}

	pWordMap = pAlt->aAlt->pMap;
	if (NULL == pWordMap)
	{
		return FALSE;
	}

	if (NULL == pInGlyph)
	{
		pGlyph	=	GlyphFromWordMap (pxrc->pGlyph, pWordMap);
	}
	else
	{
		pGlyph = pxrc->pGlyph;
	}


	// compute baseline stuff if possible
	if (pAlt->cAlt > 0)
	{
		RECT		rect;
		int			i, cCol;
		int			*aNeuralCost;
		int			iStartSeg, cPrimStroke;
		NFEATURE	*pFeat;

		ASSERT(pxrc->nfeatureset);
		ASSERT(pxrc->nfeatureset->cSegment > 0);
		ASSERT(pxrc->NeuralOutput);

		GetRectGLYPH(pGlyph, &rect);

		cCol = locateSegments(pWordMap, &iStartSeg, &cPrimStroke, pxrc->nfeatureset->head, &pFeat);

		// convert the neural output from probs to costs 
		aNeuralCost = (int *) ExternAlloc(cCol*C_CHAR_ACTIVATIONS*sizeof(int));
		if (!aNeuralCost)
		{
			for (i=0; i<(int)pAlt->cAlt; i++)
			{
				memset(&pAlt->all[i], 0, sizeof(LATINLAYOUT));
			}
		}
		else
		{
			REAL *pReal;
			int *pCost = aNeuralCost;
			
			pReal =  pxrc->NeuralOutput + iStartSeg;

			for (i = cCol; i ; i--)
			{
				InitColumn(pCost,pReal);
				pReal += gcOutputNode;
				pCost += C_CHAR_ACTIVATIONS;
			}

			for (i = 0 ; i < (int)pAlt->cAlt ; i++)
			{
				if (!ComputeLatinLayoutMetrics(&rect, pxrc->nfeatureset, iStartSeg, cCol, aNeuralCost, pAlt->aAlt[i].szWord, &pAlt->all[i]))
				{
					memset(&pAlt->all[i], 0, sizeof(LATINLAYOUT));
				}
			}

			ExternFree(aNeuralCost);
		}
	}

	if (NULL == pInGlyph && NULL != pGlyph)
	{
		DestroyGLYPH (pGlyph);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\beam.c ===
// Beam.c
// James A. Pittman
// Feb 4, 1998

// Altered Patrick Haluptzok.

// Altered again (Pittman) for use in inferno.dll

// Based on algorithm description by Fil Alleva, lunch meeting of Feb 3.

// At least for the moment we follow the theory that a row cannot be culled
// unless the row under it is culled.

// This code follows the convention that a threshold must be beaten, not just tied.
// If a cost matches a threshold, it is culled, or not allowed to breed, or not inserted
// into the top N list.
//
// ---------------------------------------------------------------------------------
//  October 2001 (mrevow) - Modifications to allow a space to be proposed by the LM
//
//  We call these types of spaces 'FactoidSpaces' to distinguish them from spaces which
//  appear between LM words.
//  The general idea is the same as for between word spaces. If we insert a 'Factoid
//  Space' between two chars then:
//      cost = parent + WithinFactoidSpaceCost + NextCharacterCost
//  On the other hand if no Factoid Space is inserted then the cost is
//       cost = parent + NothWithinFactoidSpace + NextCharacterCost
//  Previously the former situation never existed and the latter cost was simply
//       cost = parent + NextCharacterCost
//  Therefor all costs have changed regardlesss if a 'Factoid Space' was added
//  or not. To minimize the impact of this additional cost, we attempt to restore the old
//  style cost by subtracting from all alternates the difference: 
//      NewStyleCost - OldStyleCost  of the winning alternate (see subtractSpaceCost())
//
//  Special consideration is necessary when both a 'Factoid' and regular space are 
//  proposed on the same segment. The regular space accounting runs first during FindBestValidWord()
//  then the 'Factoid Space' accounting runs. It must undo the impact of the rgular
//  space accounting before considering its update using the global structure member iNotBetweenFactoidSpace
//  in both mkChildren() and update(). The mkChildren code will break if the LM can generate more than
// a single sequential 'Factoid Space' - this should never happen
// 
#include <stdlib.h>
#include <limits.h>

#include <common.h>
#include "nfeature.h"
#include "engine.h"
#include "langmod.h"
#include "nnet.h"

#include "Beam.h"
#include "charmap.h"
#include "charcost.h"
#include "probcost.h"
#include "factoid.h"

#define BS_UNBREEDABLE	1
#define BS_BREEDABLE	2
#define BS_BRED			3


#if CULLFACTOR < BREEDFACTOR
#error Breed factor is bigger than Cull factor - this does not make sense.
#endif

typedef struct tagCELL CELL;

// This struct, CELL, represents the hypothesis that the current segment is in a section of the
// ink that is a drawing of this letter.
// This is engineered to have a total length that is a multiple of 4.

typedef struct tagCELL
{
    short cReferenced;              // How many cells point here (including this cell).
    short iStart;                   // Which column this CELL's word started in.
	CELL *pParent;					// Needed to put together the whole answer.
    CELL *pSibling;                 // pointer to siblings.
    CELL *pChildren;                // pointer to children.
    unsigned char ch;               // 1252 codepage character
	char padding;
	char fInvalid;					// position in NN outputs for this character
	char BreedStatus;
	int cost;						// Cost to this point
    LMSTATE state;					// Language Model State representing this letter
} CELL;
				
// When a cell is culled its children are removed from their current place in the tree
// and placed into the next available spot in a linked list "roots".


// The threshold for culling.  A cell will be culled if the cell below it is culled
// and its own cost is not better than this.  The threshold is computed for
// a column by adding the CULLFACTOR to the best prob in the column.
//static int CullThreshold = INFINITY_COST;

// The threshold for breeding (allocating an array of children).  The cost
// of a cell must be better than this before it is allowed to produce children.
// The threshold is computed for a column by adding the BREEDFACTOR to the best
// prob in the column.

// The functions Update() and UpdateCull() assume that the culling threshold is more lax
// (a higher unsigned log prob) than the breeding threshold, or perhaps is equivalemt.
// This means that CULLFACTOR should be more than or equal to BREEDFACTOR.
// This way anything culled would not have bred in the same column.

#define INIT_CELL_ALLOCS 256

struct tagCELLALLOC;

typedef struct tagCELLALLOC
{
    struct tagCELLALLOC *pAllocNext;    
    CELL *pFreeCell;
    CELL aCells[INIT_CELL_ALLOCS];
} CELLALLOC;


// Keep what used to be static global to this file in a single struct
// that can be passed around so as to make code re-entrant.

typedef struct tagBEAM_GL
{
	CELLALLOC	*pAlloc;
	int			cTotalCell;			// Total number of cells alloced.
	int			gcReferenced;		// Total number of cells culled but not yet freed because they are pointed to

									// When a cell is culled its children are removed from their current place in the tree
	CELL		*pRootBegin;		// and placed into the next available spot in a linked list "roots".
	CELL		*pRootEnd;

	int			iBestCost;			// Best Cost used for computing Thresholds

	CELL		*pCellBest;

									// The threshold for culling.  A cell will be culled if the cell below it is culled
									// and its own cost is not better than this.  The threshold is computed for
									// a column by adding the CULLFACTOR to the best prob in the column.
	int			CullThreshold;


									// The functions Update() and UpdateCull() assume that the culling threshold is more lax
									// (a higher unsigned log prob) than the breeding threshold, or perhaps is equivalemt.
									// This means that CULLFACTOR should be more than or equal to BREEDFACTOR.
									// This way anything culled would not have bred in the same column.

	int			BreedThreshold;

	int			*aActivations;

	REAL		aCharProb[256];
	REAL		aCharBeginProb[256];
	REAL		aCharProbLong[256];
	REAL		aCharBeginProbLong[256];

	REAL		iNotWithinFactoidSpace;	// Cost of not allowing a space within a LM generated sequence
	REAL		iNotBetweenFactoidSpace;// Compensate for having a regular between word space

	LMINFO		lminfo;			// Language model stuff
} BEAM_GL;


void ComputeThresh(BEAM_GL *pBeamGL);

CELL *AllocCell(BEAM_GL *pBeamGL)
{
    CELL *pReturn;
    int iIndex;

    if (pBeamGL->pAlloc && (pReturn = pBeamGL->pAlloc->pFreeCell))
    {
        pBeamGL->pAlloc->pFreeCell = pReturn->pSibling;
    }
    else
    {
        //
        // Need another pBeamGL->pAlloc
        //

        CELLALLOC *newAlloc = ExternAlloc(sizeof(CELLALLOC));

        if (!newAlloc)
            return NULL;

        newAlloc->pAllocNext = pBeamGL->pAlloc;  // Put new block at the head of the block list.
        pBeamGL->pAlloc = newAlloc;

        pReturn = pBeamGL->pAlloc->aCells;

        pBeamGL->pAlloc->pFreeCell = &(pBeamGL->pAlloc->aCells[1]);

        for (iIndex = 1; iIndex < (INIT_CELL_ALLOCS - 1); iIndex++)
        {
            pBeamGL->pAlloc->aCells[iIndex].pSibling = &(pBeamGL->pAlloc->aCells[iIndex + 1]);
        }

        pBeamGL->pAlloc->aCells[INIT_CELL_ALLOCS - 1].pSibling = NULL;
    }

	pBeamGL->cTotalCell++;
    return(pReturn);
}


void FreeCell(BEAM_GL *pBeamGL, CELL *pCell)
{
    pCell->pSibling = pBeamGL->pAlloc->pFreeCell;
    pBeamGL->pAlloc->pFreeCell = pCell;
	pBeamGL->cTotalCell--;
}

void UnReferenceCell(BEAM_GL *pBeamGL, CELL *pCell)
{
    pCell->cReferenced--;

    ASSERT(pCell->cReferenced >= 0);

    if (pCell->cReferenced == 0)
    {
        if (pCell->pParent)
        {
            if (!pCell->pParent->fInvalid)
            {
                // A new word gets added to the end of the list so it's
                // parent may still be alive even when it gets culled away.

                ASSERT(pCell->pParent->cReferenced > 1);
            }

            ASSERT(pCell->pParent->cReferenced > 0);
            UnReferenceCell(pBeamGL, pCell->pParent);
        }

        pBeamGL->gcReferenced--;
        FreeCell(pBeamGL, pCell);
    }
}

void UnReferenceCellFirst(BEAM_GL *pBeamGL, CELL *pCell)
{
    ASSERT(pCell->cost >= 0);
    ASSERT(pCell->cReferenced >= 0);
    ASSERT(!pCell->fInvalid);

    pCell->fInvalid = 1;
    pBeamGL->gcReferenced++;

    #if 0
    {
        TCHAR szDebug[128];
        wsprintf(szDebug, TEXT("cActive = %d ch = %d pos = %d cost = %d\n"), pBeamGL->cTotalCell - pBeamGL->gcReferenced, (int) (pCell->ch), (int) pCell->pos, pCell->cost);
        WriteToLogFile(szDebug);
    }
    #endif

    UnReferenceCell(pBeamGL, pCell);
}

void FreeAllAlloc(BEAM_GL *pBeamGL)
{
    while (pBeamGL->pAlloc)
    {
        CELLALLOC *pDel = pBeamGL->pAlloc;

        pBeamGL->pAlloc = pBeamGL->pAlloc->pAllocNext;

        ExternFree(pDel);
    }

    pBeamGL->cTotalCell = 0;
    pBeamGL->gcReferenced = 0;
}

static int NotInfinite(BEAM_GL *pBeamGL, CELL *pCell)
{
    int i;
    CELL *pTemp;

    pTemp = pBeamGL->pRootBegin;

    if (pTemp)
    {        
        for (i = 0; i < 500000; i++)
        {
            if (pTemp->pSibling)
                pTemp = pTemp->pSibling;
            else
            {
                ASSERT(pTemp == pBeamGL->pRootEnd);
                break;
            }
        }
    }

    if (pCell == NULL)
        return 1;

    for (i = 0; i < 500000; i++)
    {
        if (pCell->pSibling == NULL)
            return 1;

        pCell = pCell->pSibling;
    }

    return 0;
}

// Initializes a linked list of sibling cells.  These cells represent the
// alternative letters that follow a particular letter.
// Only those characters actually handled by the neural net are included.
// The cost in this cell is computed from the parent's cost in the previous column.
// This means we do NOT want to call Update() or UpdateCull() on these cells
// for this column, as the work has already been done.

// For top-level cells (first letter position), the correct value to
// pass in for parent is 0 (probability of 1.0) for the very first call
// (representing the first column).  For all other columns, every call
// should a real parent (and thus a real cost to pass in as 'parent').
// This function should not be called to create root cells after the first
// column, after the search has started.

// Note that state is passed by value (unusual for a struct) to preserve
// the caller's scan.

static int MkChildren(BEAM_GL *pBeamGL, int iStart, CELL *pParent, LMSTATE state, unsigned char lastChar, int parent, CELL **ppChildren)
{
	int iBest = INFINITY_COST;
	CELL *pLastCell = NULL;
	LMCHILDREN lmchildren;
	int cChildren, i;
	REAL saveProb, *aCharProb, *aCharBeginProb;

	InitializeLMCHILDREN(&lmchildren);

	if (lastChar && IsDictState(state))

	{
		ASSERT(pParent);
		aCharProb = pBeamGL->aCharProbLong;
		aCharBeginProb = pBeamGL->aCharBeginProbLong;
	}
	else
	{
		aCharProb = pBeamGL->aCharProb;
		aCharBeginProb = pBeamGL->aCharBeginProb;
	}
	saveProb = aCharProb[lastChar];
	aCharProb[lastChar] = aCharBeginProb[lastChar];

	cChildren = GetChildrenLM(&state, &pBeamGL->lminfo, aCharProb, &lmchildren);

	// This is a 'Factoid Space' Efficiency hack 
	// Assume there is no space in the children bred (True most of the time)
	// so we can move this addition out of the loop.
	parent += pBeamGL->iNotWithinFactoidSpace;

	for (i=0; i<cChildren; i++)
	{
		CELL *pCell;
		unsigned char ch = NthChar(lmchildren, i);
		LMSTATE myState = NthState(lmchildren, i);
		int cost;


		if (!IsSupportedChar(ch))
			continue;

		// Check if LM tries to deliver 2 consecutive spaces
		if ((unsigned char)' ' == ch && (unsigned char)WITHIN_FACTOID_SPACE == lastChar)
		{
			continue;
		}

		pCell	= AllocCell(pBeamGL);
		if (!pCell) 
		{
			ASSERT(pCell);
			return iBest;
		}

		pCell->cReferenced	= 1;
		pCell->iStart		= (short)iStart;					
		pCell->pParent		= pParent;
		if (pParent) 
		{
			ASSERT(pParent->cReferenced > 0);
			ASSERT(pParent->cost >= 0);					    						
			pParent->cReferenced++;
		}						
		pCell->pChildren	= NULL;

		pCell->ch			= ch;                    
		pCell->fInvalid		= 0;

		cost = NetFirstActivation(pBeamGL->aActivations, pCell->ch);
		pCell->cost			= parent + cost;
		if (pCell->cost < iBest)
			iBest = pCell->cost;
		pCell->state		= myState;

		if (IsDictState(myState))
			pCell->BreedStatus = BS_BREEDABLE;
		else if ((aCharProb[ch] >= MIN_CHAR_PROB) 
			&& (cost > MIN_CHAR_PROB_COST) && (NetContActivation(pBeamGL->aActivations, pCell->ch) > MIN_CHAR_PROB_COST))
			pCell->BreedStatus = BS_UNBREEDABLE;
		else
			pCell->BreedStatus = BS_BREEDABLE;

		pCell->pSibling		= pLastCell;
		pLastCell	= pCell;

		// Check for a 'Factoid Space' The LM proposes
		// a 1252 regular space. We turn it into a
		// WITHIN_FACTOID_SPACE character (Currentl a Non Breaking Space)
		if (' ' == ch)
		{
			int	iBestChild;

			// This wierd update compensates for 2 issues:
			// (1) Reverse the efficieny hack we did before the for loop at the top
			//  when we assumend no factoid generated space will occur (Subtract pBeamGL->iNotWithinFactoidSpace)
			// (2) Reverse a possible 'Regular' space cost, if any (Subtract pBeamGL->iNotBetweenFactoidSpace)
			pCell->cost -= pBeamGL->iNotBetweenFactoidSpace + pBeamGL->iNotWithinFactoidSpace;
			ch = (unsigned char)WITHIN_FACTOID_SPACE;
			pCell->ch = ch;

			// Pre reverse the efficiency hack for the next pass through MkChildren 
			// by subtracting pBeamGL->iNotWithinFactoidSpace from the parent)
			// NOTE: This will break work if the LM generates more than 1 space sequentially
			iBestChild = MkChildren(pBeamGL, iStart, pCell, myState, ch, pCell->cost - pBeamGL->iNotWithinFactoidSpace, &(pCell->pChildren));
			if (iBestChild < iBest)
			{
				iBest = iBestChild;
			}
		}
		
	}
	DestroyLMCHILDREN(&lmchildren);
	aCharProb[lastChar] = saveProb;

	if (pLastCell)
        ComputeThresh(pBeamGL);

	*ppChildren = pLastCell;

    return iBest;
}

// Updates a set of sibling cells with the parent's cost from the
// previous column (called 'parent').
// Returns the best prob in the column.

// This function (and UpdateCull() below) should not be called for the
// first column, since in that column all cells will be newly created
// using MkChildren, and MkChildren() computes the cost for the column
// we are in at the time the cells are created.

// When this function (or UpdateCull() below) is called for top-level
// calls (ie, for the members of the root list), the correct value to
// pass in for parent is INFINITY_COST (probability of 0.0).
// This allows the bottom row to be computed special without special code,
// and also garantees that when we start above the bottom row (due to
// previous culling of rows) we will not use a transition probability
// in the computation.

static int Update(BEAM_GL *pBeamGL, CELL *pCell, const int parent)
{
    int best = INFINITY_COST;

    while (pCell)
	{
		int old, cost, trans, thisContCost, thisTransCost;

        ASSERT(pCell->cost >= 0);
        ASSERT(pCell->cReferenced >= 0);
        ASSERT(!pCell->fInvalid);

		old = pCell->cost;

		thisContCost = NetContActivation(pBeamGL->aActivations, pCell->ch);

		// Cost of continuing must include not using a 'Factoid Space' at this point
		cost = old + thisContCost + pBeamGL->iNotWithinFactoidSpace;

		// Transition to a new character - 2 cases
		// (1) Special case of a 'Factoid Space'
		// (2) Regular case
		if (WITHIN_FACTOID_SPACE == pCell->ch)
		{
			// Compensate for a 'Regular Space' (Subtract pBeamGL->iNotBetweenFactoidSpace)
			thisTransCost = NetFirstActivation(pBeamGL->aActivations, pCell->ch) - pBeamGL->iNotBetweenFactoidSpace;

			// Pre subtract iNotWithinFactoidSpace - because if we end up making children we 
			// will add it in and we don't want it added because this path has the SpaceCost
			// added (not notSpaceCost)
			old = parent + thisTransCost - pBeamGL->iNotWithinFactoidSpace;
		}
		else
		{
			// The Normal situation - No factoid space Must add in a NotSpace 
			// case when transitioning to next character
			thisTransCost = NetFirstActivation(pBeamGL->aActivations, pCell->ch) + pBeamGL->iNotWithinFactoidSpace;
		}
		trans = parent + thisTransCost;
		if (trans < cost)
			cost = trans;

		pCell->cost = cost;

		if (cost < best)
			best = cost;

		if (pCell->pChildren)
		{
			int bestChild = Update(pBeamGL, pCell->pChildren, old);

			if (bestChild < best)
				best = bestChild;
		}
        else if ((pCell->BreedStatus == BS_BREEDABLE) && (old < pBeamGL->BreedThreshold))
		{
			int bestChild	= MkChildren(pBeamGL, pCell->iStart, pCell, pCell->state, pCell->ch, old, &(pCell->pChildren));

			pCell->BreedStatus = BS_BRED;
			if (bestChild < best)
				best = bestChild;
		}
		else if (pCell->BreedStatus == BS_UNBREEDABLE)
		{
			if ((thisContCost <= MIN_CHAR_PROB_COST) || (NetFirstActivation(pBeamGL->aActivations, pCell->ch) <= MIN_CHAR_PROB_COST))
				pCell->BreedStatus = BS_BREEDABLE;
		}

        pCell = pCell->pSibling;
    }

	return best;
}

static int UpdateCull(BEAM_GL *pBeamGL, CELL *pCell)
{
    CELL *pLastGood = NULL; // Last Cell that wasn't pruned.
    int best = INFINITY_COST;

	ASSERT(pCell == pBeamGL->pRootBegin);

    while (pCell)
	{
		ASSERT(pCell->cost >= 0);
        ASSERT(pCell->cReferenced >= 0);
        ASSERT(!pCell->fInvalid);

        ASSERT((pCell->pSibling == NULL) || (pCell->pSibling != pCell->pChildren));

        if (pCell->cost >= pBeamGL->CullThreshold)
        {
            CELL *pNext;

            // Nuke this guy, first we need to unhook him from
            // the linked list, taking care if he is the first
            // or last guy.

            if (pCell == pBeamGL->pRootEnd)
            {
                ASSERT(pCell->pSibling == NULL);

                if (pCell == pBeamGL->pRootBegin)  // Special Case to catch.
                {
                    ASSERT(pLastGood == NULL);
                    ASSERT(pCell->pChildren);

                    pBeamGL->pRootBegin = pBeamGL->pRootEnd = pCell->pChildren;

                    UnReferenceCellFirst(pBeamGL, pCell);

                    while (pBeamGL->pRootEnd->pSibling)
                        pBeamGL->pRootEnd = pBeamGL->pRootEnd->pSibling;

                    pCell = pBeamGL->pRootBegin;

                    continue;
                }
                else
                {
                    ASSERT(pLastGood);
                    pBeamGL->pRootEnd = pLastGood;

                    ASSERT(pCell->pSibling == NULL);
                    pLastGood->pSibling = NULL;

                    pNext = pCell->pChildren;
                }
            }
            else if (pCell == pBeamGL->pRootBegin)
            {
                ASSERT(pCell->pSibling);
                pBeamGL->pRootBegin = pCell->pSibling;
                pNext = pCell->pSibling;
            }
            else
            {
				// Feb 2002 - Prefix flags access of pLastGood as a potential
				// NULL pointer access. This is a prefix bug as explained here:
				//
				// It is a bug if pLastGood is NULL at this point
				// The reason is pLastGood is the last non-Root cell not culled
				// out in this path (i.e. pCell->cost < pBeamGL->CullThreshold)
				// The case of not having yet seen an unculled cell (pLastGood == NULL)
				// means that we are at pRootBegin which is handled by the
				// else part immediatly above this else
				ASSERT(pLastGood);
                ASSERT(pCell->pSibling);
                pLastGood->pSibling = pCell->pSibling;
                pNext = pCell->pSibling;
            }

            // Ok stick the children at the end of the root list.

            if (pCell->pChildren)
            {
                ASSERT(pBeamGL->pRootEnd->pSibling == NULL);

                pBeamGL->pRootEnd->pSibling = pCell->pChildren;

                while (pBeamGL->pRootEnd->pSibling)
                    pBeamGL->pRootEnd = pBeamGL->pRootEnd->pSibling;
            }

            UnReferenceCellFirst(pBeamGL, pCell);
            pCell = pNext;
        }
        else
        {
            int old, cost, thisCost;

            pLastGood = pCell;

            old = pCell->cost;

			thisCost = NetContActivation(pBeamGL->aActivations, pCell->ch) + pBeamGL->iNotWithinFactoidSpace;
            cost = old + thisCost;

            pCell->cost = cost;

            if (cost < best)
                best = cost;

		    if (pCell->pChildren)
		    {
                int bestChild;

				bestChild = Update(pBeamGL, pCell->pChildren, old);

			    if (bestChild < best)
				    best = bestChild;
            }
			else if ((pCell->BreedStatus == BS_BREEDABLE) && (old < pBeamGL->BreedThreshold))
			{
				int bestChild	= MkChildren(pBeamGL, pCell->iStart, pCell, pCell->state, pCell->ch, old, &(pCell->pChildren));

				pCell->BreedStatus = BS_BRED;
				if (bestChild < best)
					best = bestChild;
			}
			else if (pCell->BreedStatus == BS_UNBREEDABLE)
			{
				if ((thisCost <= MIN_CHAR_PROB_COST) || (NetFirstActivation(pBeamGL->aActivations, pCell->ch) <= MIN_CHAR_PROB_COST))
					pCell->BreedStatus = BS_BREEDABLE;
			}

            pCell = pCell->pSibling;
        }
    }

	return best;
}

/************************************************************
 *
 * InsertStrokes - Insert stroke ids (or frame ids) into the WORDMAP
 * data structure. Lookup the strokes used in each neural net segment
 * and add to the list.
 *
 * Do not add more than cMaxStrokes
 *
 ************************************************************/
int InsertStrokes(XRC *pXrc, WORDMAP *pMap, int iStart, int	iEnd, int cMaxStroke)
{
	int			i, *piStrkIdx, iLastIdx, iLastSecondary;
	NFEATURE	*pNfeature;

	pNfeature = pXrc->nfeatureset->head;

	ASSERT(pNfeature);
	ASSERT(iStart <= iEnd);
	ASSERT(iStart >= 0);
	ASSERT(iEnd <= pXrc->nfeatureset->cSegment);

	pMap->cStrokes = 0;
	i = iStart;
	// Go to starting segment
	for (; i > 0 ; --i)
	{
		pNfeature = pNfeature->next;
		ASSERT(pNfeature);
	}

	i = iEnd - iStart;
	iLastIdx = -1;
	iLastSecondary = -1;

	piStrkIdx = pMap->piStrokeIndex;
	ASSERT(piStrkIdx);

	for ( ; i > 0 && pNfeature ; --i, pNfeature = pNfeature->next )
	{

		if (iLastIdx < 0 || iLastIdx != pNfeature->iStroke )
		{
			if (pMap->cStrokes >= cMaxStroke)
			{
				ASSERT(pMap->cStrokes <= cMaxStroke);
				return HRCR_ERROR;
			}

			AddThisStroke(pMap, pNfeature->iStroke);
			iLastIdx = pNfeature->iStroke;
		}

		ASSERT(pNfeature);

		// Check for secondary strokes
		if (pNfeature->iSecondaryStroke > 0 && iLastSecondary != pNfeature->iSecondaryStroke)
		{
			if (pMap->cStrokes >= cMaxStroke)
			{
				ASSERT(pMap->cStrokes <= cMaxStroke);
				return HRCR_ERROR;
			}
			
			AddThisStroke(pMap, pNfeature->iSecondaryStroke);
			iLastSecondary = pNfeature->iSecondaryStroke;
		}

	}

	return HRCR_OK;
}

// Construct the ink maps for the alt list of cell candidates

int MakeStrokeMaps(XRC *pxrc, CELL **pAltCell)
{
	BOOL			bEndOfList = FALSE;		// Checks for missing members in the alt list
	XRCRESULT		*pRes = pxrc->answer.aAlt;
	int				cStrokeGlyph;
	unsigned int	cAlt;
	int				iRet = HRCR_OK;

	ASSERT(pxrc);
	if (!pxrc)
	{
		return HRCR_ERROR;
	}

	cAlt = pxrc->answer.cAlt;
	ASSERT(cAlt <= pxrc->answer.cAltMax);
	cStrokeGlyph = CframeGLYPH(pxrc->pGlyph);

	ASSERT(pAltCell);
	if (!pAltCell)
	{
		return HRCR_ERROR;
	}

	// Run through all the alternates, making a stroke map for each
	for ( ; cAlt > 0 ; --cAlt, ++pAltCell, ++pRes)
	{
		WORDMAP			*pWordMap;
		int				*piStrokeIndexStart;
		int				cWord = pRes->cWords;
		CELL			*pCellBack;
		int				cLenBack, iEnd;
		int				cMaxStroke = cWord * cStrokeGlyph;		// Handles a new NNet featurization that allows 
																// different words to use the same strokes
		
		ASSERT(*pAltCell);
		ASSERT(cMaxStroke);

		pCellBack = *pAltCell;
		
		if (!pCellBack)
		{
			// End of list ??
			bEndOfList = TRUE;
			continue;
		}

		ASSERT(!bEndOfList);
		ASSERT(pRes->szWord);
		ASSERT(!pRes->pMap);
			
		pRes->iLMcomponent = pCellBack->state.iAutomaton;
		pRes->pMap = (WORDMAP *)ExternAlloc(sizeof(*pRes->pMap) * cWord);
		ASSERT(pRes->pMap);
		
		if (!pRes->pMap)
		{
			return HRCR_MEMERR;
		}
		memset(pRes->pMap, 0, sizeof(*pRes->pMap) * cWord);
		
		// Allocate the stroke index array big enough for the whole glyph. Note
		// We work backwards down the phrase so put the pointer
		// in the last map
		pRes->pMap[cWord - 1].piStrokeIndex = (int *)ExternAlloc(sizeof(*pRes->pMap->piStrokeIndex) * cMaxStroke);
		ASSERT(pRes->pMap[cWord - 1].piStrokeIndex);
		if (!pRes->pMap[cWord - 1].piStrokeIndex)
		{
			return HRCR_MEMERR;
		}
		
		iEnd = (pCellBack) ? pxrc->nfeatureset->cSegment : 0;
		pWordMap = pRes->pMap + cWord - 1;
		pWordMap->start = pWordMap->len = pWordMap->cStrokes = 0;
		piStrokeIndexStart = pWordMap->piStrokeIndex;
		cLenBack = strlen(pRes->szWord) - 1;


		// Fill in the words and alternate Maps
		while (pCellBack)
		{
			ASSERT(pRes->szWord[cLenBack] == (unsigned char) pCellBack->ch);
			++pWordMap->len;
			cLenBack--;
			
			
			if (pCellBack->pParent)
			{
				if (pCellBack->pParent->iStart != pCellBack->iStart)
				{
					ASSERT(cLenBack >= 0);

					ASSERT(pRes->szWord[cLenBack] == ' ');
					pWordMap->start = cLenBack + 1;
					cLenBack--;
					--cWord;
					
					ASSERT(cWord >= 0);
					
					iRet = InsertStrokes(pxrc, pWordMap, pCellBack->iStart, iEnd, cMaxStroke - (pWordMap->piStrokeIndex - piStrokeIndexStart));

					if (iRet != HRCR_OK)
					{
						return iRet;
					}
					iEnd = pCellBack->iStart;
					--pWordMap;
					memset(pWordMap, 0, sizeof(*pWordMap));
					pWordMap->piStrokeIndex = pWordMap[1].piStrokeIndex + pWordMap[1].cStrokes;
					pWordMap->cStrokes = pWordMap->len = 0;
					ASSERT(pWordMap->piStrokeIndex < piStrokeIndexStart + cMaxStroke);
				}
			}
			
			if (!pCellBack->pParent)
			{
				// Reached the end - Insert strokes for first word in phrase

				iRet = InsertStrokes(pxrc, pWordMap, pCellBack->iStart, iEnd, cMaxStroke - (pWordMap->piStrokeIndex - piStrokeIndexStart));
				if (iRet != HRCR_OK)
				{
					return iRet;
				}

				pWordMap->start = cLenBack + 1;
				ASSERT(pWordMap->piStrokeIndex < piStrokeIndexStart + cMaxStroke);
				ASSERT(pWordMap->cStrokes > 0);
			}
			
			pCellBack = pCellBack->pParent;
		}

		ASSERT(cWord == 1);
		ASSERT(cLenBack == -1);
	}
	return iRet;
}

int GetWordPath(unsigned char *pWordBack, CELL *pCell, int *pcWord)
{
	int				cLenBack;
	unsigned int	cWord;

    cLenBack = BEAM_MAX_WORD_LEN - 1;
	cWord = 1;

    //
    // Count the number of characters
    //
    while (pCell && cLenBack >= 0)
    {
		pWordBack[cLenBack--] = (unsigned char)pCell->ch;

        if (pCell->pParent)
        {
            if (pCell->pParent->iStart != pCell->iStart && cLenBack >= 0)
            {
				pWordBack[cLenBack--] = ' ';
				++cWord;
            }
        }

        pCell = pCell->pParent;
    }

	ASSERT(cLenBack != BEAM_MAX_WORD_LEN - 1);

	*pcWord = cWord;
	return cLenBack;
}

CELL *FindBestCELL(CELL *pCell, CELL *pBest)
{
    while (pCell)
	{
        if (pCell->cost < pBest->cost)
            pBest = pCell;

        if (pCell->pChildren)
            pBest = FindBestCELL(pCell->pChildren, pBest);

        pCell = pCell->pSibling;
	}

	return pBest;
}

// Backtrace through surviving cells to find top-N words
// cStrokes is  the maximum number of strokes that were seen
int Harvest(XRC *pxrc, BEAM_GL *pBeamGL)
{
    int				Threshold = INT_MAX;
	int				iRet;
	int				cAltMax = (int)pxrc->answer.cAltMax;	
	CELL			**pAltCell = NULL;
	CELL			*pCell = pBeamGL->pRootBegin;
    unsigned char	*pWordBack;

	pxrc->answer.cAlt = 0;
	memset(pxrc->answer.aAlt, 0, sizeof(pxrc->answer.aAlt));

	pAltCell = (CELL **)ExternAlloc(sizeof(*pAltCell) * cAltMax);
	ASSERT(pAltCell);
	if (!pAltCell)
	{
		return HRCR_MEMERR;
	}
	memset(pAltCell, 0, sizeof(*pAltCell) * cAltMax);

	pWordBack = (unsigned char *)ExternAlloc(sizeof(*pWordBack) * (BEAM_MAX_WORD_LEN + 1));
	ASSERT(pWordBack);
	if (!pWordBack)
	{
		iRet = HRCR_MEMERR;
		goto fail;
	}
	pWordBack[BEAM_MAX_WORD_LEN] = '\0';

    while (pCell)
    {
        if ((pCell->cost < Threshold) && IsValidLMSTATE(&pCell->state, &pBeamGL->lminfo, pxrc->szSuffix))
        {
            int				cLenBack, iPos;
			unsigned int	cWord;


			ASSERT(pCell->cost >= 0);

			cLenBack = GetWordPath(pWordBack, pCell, &cWord);
			if (cLenBack < 0)
			{
				iRet = HRCR_MEMERR;
				goto fail;
			}

			ASSERT(pCell->cost >= 0);

			// attemp to insert the alternate
            iPos = InsertALTERNATES(&(pxrc->answer), pCell->cost, pWordBack + cLenBack + 1, pxrc);

			// if the alternate inserted in the list, update the path and # of words
			if (iPos >= 0 && iPos < ((int)pxrc->answer.cAltMax))
			{
				memmove(pAltCell + iPos + 1, pAltCell + iPos,  (cAltMax - iPos - 1) * sizeof(*pAltCell));
				pAltCell[iPos] = pCell;
				pxrc->answer.aAlt[iPos].cWords = cWord;
			}

            if (pxrc->answer.cAlt == pxrc->answer.cAltMax) //!!! Init costs to INT_MAX so we can just grab it.
            {
                int last = pxrc->answer.aAlt[pxrc->answer.cAltMax-1].cost;
                if (last < Threshold)
                    Threshold = last;
            }
        }

        if (pCell->pChildren)
		{
			//
			// Can't recurse, throw sibling on the end of the children
			// and run through the children.
			//

			if (pCell->pSibling)
			{
				CELL *pCellNew = pCell->pChildren;

				while (pCellNew->pSibling)
				{
					pCellNew = pCellNew->pSibling;
				}

				pCellNew->pSibling = pCell->pSibling;
				pCell->pSibling = NULL;
			}
            
			pCell = pCell->pChildren;
		}
		else
			pCell = pCell->pSibling;
	}

	// in case no alternate was added above, and we are not in Coerce mode,
	// we'll add the best alternate that we have even if it not valid
	if ((pxrc->answer.cAlt <= 0) && !(pxrc->flags & RECOFLAG_COERCE))
	{
		// this is when there was no valid word alive
        int				cLenBack;
		unsigned int	cWord;
		int				iPos;

		pCell = FindBestCELL(pBeamGL->pRootBegin, pBeamGL->pRootBegin);  // pick the best "prefix"

		ASSERT(pCell->cost >= 0);

		cLenBack = GetWordPath(pWordBack, pCell, &cWord);
			
		if (cLenBack < 0)
		{
			iRet = HRCR_MEMERR;
			goto fail;
		}

		ASSERT(pCell->cost >= 0);

        iPos = InsertALTERNATES(&(pxrc->answer), pCell->cost, pWordBack + cLenBack + 1, pxrc);
		ASSERT(iPos == 0);

		// if the alternate was inserted at a valid pos
		if (iPos >= 0 && iPos < ((int)pxrc->answer.cAltMax))
		{
			memmove(pAltCell + iPos + 1, pAltCell + iPos,  (cAltMax - iPos - 1) * sizeof(*pAltCell));
			pAltCell[iPos] = pCell;
			pxrc->answer.aAlt[iPos].cWords = cWord;
		}
	}

	iRet = MakeStrokeMaps(pxrc, pAltCell);

fail:
	if(pAltCell)
	{
		ExternFree(pAltCell);
	}

	if (pWordBack)
	{
		ExternFree(pWordBack);
	}

	// if we did not succeed, then free the alt list
	if (iRet != HRCR_OK)
	{
		ClearALTERNATES (&pxrc->answer);
	}

	return iRet;
}

/*
CELL *gpCellBest;
int gCostBest;
*/
int FindBestValidWord(BEAM_GL *pBeamGL, CELL *pCell, int iCost, int gCostBest)
{
    while (pCell)
	{
		if (IsValidLMSTATE(&pCell->state, &pBeamGL->lminfo, NULL))
        {            
            if (pCell->cost < gCostBest)
            {
                pBeamGL->pCellBest = pCell;
                gCostBest = pCell->cost;
            }
        }

        pCell->cost += iCost;

        if (pCell->pChildren)
            gCostBest = FindBestValidWord(pBeamGL, pCell->pChildren, iCost, gCostBest);

        pCell = pCell->pSibling;
	}

	return gCostBest;
}

BOOL IsSpacePossible(NFEATURE *head, int col)
{
	int i = 0;
	while (i < col)
	{
		head = head->next;
		i++;
	}

	return IS_FIRST_SEGMENT(head);
}


int xSpaceFromColumn(NFEATURE *head, int col)
{
	int i = 0;
	NFEATURE *prev = head;

	ASSERT(col >= 1);

	while (i < col)
	{
		prev = head;
		head = head->next;
		i++;
	}

	//return head->rect.left - prev->maxRight;
	return head->pMyFrame->rect.left - prev->maxRight;
}



void ComputeThresh(BEAM_GL *pBeamGL)
{
    int cActive = pBeamGL->cTotalCell - pBeamGL->gcReferenced;

    if (cActive < 1 * TARGET_CELLS)
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + CULLFACTOR;
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + BREEDFACTOR;
    }
    else if (cActive < (5 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR * 9 / 10);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR * 9 / 10);
    }
    else if (cActive < (7 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR * 3 / 4);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR * 3 / 4);
    }
    else if (cActive < (8 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 2);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 2);
    }
    else if (cActive < (9 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 4);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 4);
    }
    else if (cActive < (10 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 8);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 8);
    }
    else if (cActive < (11 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 16);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 16);
    }
    else if (cActive < (12 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 32);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 32);
    }
    else if (cActive < (13 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 64);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 64);
    }
    else if (cActive < (14 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 128);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 128);
    }
    else if (cActive < (15 * TARGET_CELLS))
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 256);
        pBeamGL->BreedThreshold = pBeamGL->iBestCost + (BREEDFACTOR / 256);
    }
    else
    {
        pBeamGL->CullThreshold = pBeamGL->iBestCost + (CULLFACTOR / 512);
        pBeamGL->BreedThreshold = 0;  // Sorry no more breeding.
    }
}

//#define DUMPBEAM

#ifdef DUMPBEAM

static void DumpCell(FILE *pfi, int level, CELL *pCell)
{
	static char *Auto[] = {"NONE", "SDict", "UDict", "Email", "Web", "Num", "LPunc", "TPunc", "Punc", "Hyphen"};
	int			cAuto = sizeof(Auto) / sizeof(Auto[0]);

	while (pCell)
	{
		fprintf(pfi, "%p %d ", pCell, level);

		{
			char word[BEAM_MAX_WORD_LEN+1];
			int c, cW;
			word[BEAM_MAX_WORD_LEN] = '\0';
			c = GetWordPath(word, pCell, &cW);
			fprintf(pfi, "[%s] %d words", word + c + 1, cW);
		}

		fprintf(pfi, " %d refs %d iSt ", pCell->cReferenced, pCell->iStart);
		fprintf(pfi, " %s %s cost: %d ",
				pCell->fInvalid ? "Invalid" : "Valid",
				pCell->BreedStatus == BS_UNBREEDABLE ? "unbreedable" : pCell->BreedStatus == BS_BREEDABLE ? "breedable" : "bred",
				pCell->cost);
		if (pCell->state.iAutomaton < cAuto)
		{
		fprintf(pfi, "%s ", Auto[pCell->state.iAutomaton]);
		}
		fprintf(pfi, "%d %d\n", pCell->state.TopLevelState, pCell->state.AutomatonState);
		if (pCell->pChildren)
			DumpCell(pfi, level+1, pCell->pChildren);
		pCell = pCell->pSibling;
	}
}

static void Dump(BEAM_GL *pBeamGL, char *pre, int i)
{
	FILE *pfi;
	char sz[100];
	int k;

	sprintf(sz, "%s%03d.txt", pre, i);
	pfi = fopen(sz, "w");
	fprintf(pfi, "Cull %d Breed %d cCell %d bestcost %d\n\n", pBeamGL->CullThreshold, pBeamGL->BreedThreshold, pBeamGL->cTotalCell, pBeamGL->iBestCost);
	fprintf(pfi, "ActiveChars: [");
	for (k=0; k<256; k++)
		if (pBeamGL->aCharProb[k] > MIN_CHAR_PROB)
			fprintf(pfi, "%c", k);
	fprintf(pfi, "]\n");
	DumpCell(pfi, 0, pBeamGL->pRootBegin);
	fclose(pfi);
}

#endif

/*************************************************************
 *
 * NAME: getTDNNCostforString
 *
 * INPUTS:
 *	
 *  pxrc - current XRC
 *  pStr - String to evaluate
 *  iStartSeg/ iEndSeg - Start end segments in featureset
 *  pSegmentation - OUT returns the character segmentation (Can be NULL)
 *
 * DESCRIPTION:
 *
 * Extract the lowest cost of the top 1 string in the xrc
 * excluding the cost
 * of Factoid type spaces, but including the cost of between/
 * within words. This is achieved by finding the lowest cost
 * path through the string ignoring factoid type spaces
 * using standard dynamic programming
 *
 * If pSegmentation is not NULL it is assumed
 * to be of length cSeg+1 and on return will be populated 
 * by the segmentation
 *
 ************************************************************/
int  getTDNNCostforString(XRC *pxrc, unsigned char *pStr, int iStartSeg, int iEndSeg, int *pSegmentation)
{
	REAL			*pNetOut;
	int				cSeg;
	int				iCost;
	int				aActivations[512], *pState, *pNext, *pCurr, *pTmp, *pBackTrack, *pBack;
	int				iSeg, iLen, iState, cState, iChar, iMaxReach;
	unsigned char	*pch;
	int				iMaxXOverlap = pxrc->nfeatureset->iyDev * MAX_STROKE_OVERLAP;

	pNetOut		= pxrc->NeuralOutput;
	if (iStartSeg >= pxrc->nfeatureset->cSegment || iStartSeg <= -1 || iEndSeg < iStartSeg)
		return -1;

	// now move to the 1st segment
	pNetOut	= pxrc->NeuralOutput + iStartSeg * gcOutputNode;
	
	cSeg	=	iEndSeg	- iStartSeg + 1;

	iLen = strlen((char *)pStr);
	if (iLen < 0)
	{
		return 0;
	}

	cState = iLen * 2;

	for (iChar = 0 ; iChar < 512 ; ++iChar)
	{
		aActivations[iChar] = 2 * ZERO_PROB_COST;
	}

	InitColumn(aActivations, pNetOut);
	pCurr = pState = (int *)ExternAlloc(sizeof(*pState) * cState *2);
	if (!pState)
	{
		return -1;
	}

	pBack = pBackTrack = (int *)ExternAlloc(sizeof(*pBackTrack) * cState * cSeg);
	if (!pBackTrack)
	{
		ExternFree (pState);
		return -1;
	}

	pNext = pCurr + cState;
	pBack = pBackTrack + cState;

	
	memset(pState, 0x7F, sizeof(*pState) * cState * 2);
	*pCurr = NetFirstActivation(aActivations, *pStr);
	pCurr[1] = *pCurr;
	iState = 0;
	for (iSeg = 1; iSeg < cSeg ; ++iSeg)
	{
		int		iSpaceCost = 2*ZERO_PROB_COST;
		int		iNotSpaceCost = 0;
		int		iAddSpace;			// Cost added to account for Space/NoSpace

		pNetOut += gcOutputNode;

		InitColumn(aActivations, pNetOut);
		pch		= pStr;
		*pNext = 0x7FFFF;
		pNext[1] = pCurr[1] + NetContActivation(aActivations, *pch);

		// Must start at Begin of first character
		pBack[1] = (iSeg > 1) ? 1 : 0;


		iMaxReach = min(iLen, iSeg+1);

        // Check for possible between / within word space
		if (!(pxrc->flags & RECOFLAG_WORDMODE) && IsSpacePossible(pxrc->nfeatureset->head, iSeg))
        {			
			int xWidth = xSpaceFromColumn(pxrc->nfeatureset->head, iSeg);

			if (xWidth > -iMaxXOverlap)
			{

				int iXThresh = 11 * pxrc->nfeatureset->iyDev / 2;

				if (xWidth >= iXThresh)
				{
					iSpaceCost = 0;
                    iNotSpaceCost = CULLFACTOR * 4;  // Kill them
				}
				else
				{
					// look up neural net output
					iSpaceCost = NetFirstActivation(aActivations, ' ');
					iNotSpaceCost = PROB_TO_COST(65535 - pNetOut[BeginChar2Out(' ')]);

					// scale costs
					iNotSpaceCost = NOT_SPACE_NUM * iNotSpaceCost / NOT_SPACE_DEN;
					iSpaceCost = IS_SPACE_NUM * iSpaceCost / IS_SPACE_DEN;
				}
			}
		}

		for (iChar = 1, iState = 0, ++pch ; iChar < iMaxReach ; ++iChar, ++pch)
		{

			if (WITHIN_FACTOID_SPACE == *pch)
			{
				// Ignore the space factoid 
				continue;
			}

			if (' ' == *pch)
			{
				// Account for a space between 'words'
				iAddSpace = iSpaceCost;
				++pch;
				++iChar;
				iMaxReach++;
				iMaxReach = min(iMaxReach, iLen);
			}
			else
			{
				iAddSpace = iNotSpaceCost;
			}

			ASSERT(*pch != ' ');

			// Start a new Character
			if (pCurr[iState] <= pCurr[iState+1])
			{
				pNext[iState+2] = pCurr[iState];
				pBack[iState+2] = iState;
			}
			else
			{
				pNext[iState+2] = pCurr[iState+1];
				pBack[iState+2] = iState+1;
			}
			pNext[iState+2] +=  NetFirstActivation(aActivations, *pch) + iAddSpace;


			++iState;
			// Character Continuation
			if (pCurr[iState+1] < pCurr[iState+2])
			{
				pNext[iState+2] = pCurr[iState+1];
				pBack[iState+2] = iState+1;
			}
			else
			{
				pNext[iState+2] = pCurr[iState+2];
				pBack[iState+2] = iState+2;
			}
			pNext[iState+2] += NetContActivation(aActivations, *pch) + iNotSpaceCost;

			++iState;
		}

		pTmp = pCurr;
		pCurr = pNext;
		pNext = pTmp;
		pBack += cState;
	}

	iCost = min(pCurr[iState], pCurr[iState+1]);

	// Backtrack to get the segmentation
	if (pSegmentation)
	{
		int					iBest, iAccent;
		unsigned char		ch;

		iBest = (pCurr[iState] <= pCurr[iState+1]) ? iState : iState + 1;

		iSeg = cSeg-1;
		for ( ; iSeg >= 0 ; --iSeg)
		{
			pBack -= cState;
			ASSERT(iBest < 2 * iLen);
			ch = pStr[iBest/2];
			
			if (0 != IsVirtualChar(ch) )
			{
				iAccent = AccentVirtualChar(ch) << 16 ;
				ch = BaseVirtualChar(ch);
			}
			else
			{
				iAccent = 0;
			}

			pSegmentation[iSeg] = (iBest % 2 == 0) ? BeginChar2Out(ch) : ContinueChar2Out(ch);
			pSegmentation[iSeg] += iAccent;
			iBest = pBack[iBest];
		}
		pSegmentation[cSeg] = '\0';
	}

	ExternFree(pState);
	ExternFree(pBackTrack);

	return iCost;
}


/*************************************************************
 *
 * NAME: subtractSpaceCost
 *
 * INPUTS:
 *	
 *  pxrc - current XRC
 *
 * DESCRIPTION:
 *
 * Attempt to restore the costs for each member of the alt list
 * when the impact of the "Within Factoid Spaces" is removed
 * This is done by doing a DTW of the top 1 alternate against the 
 * NN outputs to get the lowest cost when we ignore the 
 * "within Factoid Space". The diffenece betwen this 'pure '
 * and current top1 cost is subtracted from all members of the alt
 * list
 *
 ************************************************************/
void subtractSpaceCost(XRC *pxrc)
{
	int		i, iExtraSpaceCost;

	if (pxrc->answer.cAlt < 1)
	{
		//Nothing to do
		return;
	}

	iExtraSpaceCost = getTDNNCostforString(pxrc, pxrc->answer.aAlt[0].szWord, 0, pxrc->nfeatureset->cSegment-1, NULL);
	//iExtraSpaceCost = getBestCostMinusSpaceOLD(pxrc);

	// The difference between the 'pure' and cost including
	// the "Within Factoid  Space" cost of top 1 choice will
	// be subtracted from all the alternates
	iExtraSpaceCost = pxrc->answer.aAlt[0].cost - iExtraSpaceCost;

	if ( iExtraSpaceCost > 0)
	{
		for (i = 0 ; i < (int)pxrc->answer.cAlt ; ++i)
		{
			ASSERT(pxrc->answer.aAlt[i].cost >= iExtraSpaceCost);
			pxrc->answer.aAlt[i].cost -= iExtraSpaceCost;
		}
	}
}

/*************************************************************
 *
 * NAME: SlideSpaceOutputOneSegmentFwd
 *
 * INPUTS:
 *	
 *  pNetOut - buffer of NN outputs - size cSeg * cOutPerSeg
 *  cSeg	- Number of segments
 *  cOutPerSeg	- Number NN outputs per segment
 *
 * DESCRIPTION:
 *
 * The "Within Factoid space" accounting is implemented much easier
 * if the space node refers to the prob of a space occurring
 * BEFORE the cureent character. Unfortunatly the convention is that
 * the node gives the prob of a space after the current char.
 * This function simply slides the space outputs one segment
 * later in time. This of course mean that the last segment's
 * spae output node is lost, but we never need it because we never
 * insert a space at the end of a piece of ink. The space
 * output is replicated in the first 2 segements, but this is also OK
 * since we also never consider putting a space before the ink
 *
 ************************************************************/
void SlideSpaceOutputOneSegmentFwd(REAL *pNetOut, int cSeg, int cOutPerSeg)
{
	REAL	*pPrev, *pCurr;

	--cSeg;
	pCurr = pNetOut + cOutPerSeg * cSeg;
	pPrev = pCurr - cOutPerSeg;

	for (; cSeg > 0 ; --cSeg)
	{
		*pCurr = *pPrev;

		pCurr -= cOutPerSeg;
		pPrev -= cOutPerSeg;
	}

	ASSERT(pCurr == pNetOut);
}

/*************************************************************
 *
 * NAME: SlideSpaceOutputOneSegmentBack
 *
 * INPUTS:
 *	
 *  pNetOut - buffer of NN outputs - size cSeg * cOutPerSeg
 *  cSeg	- Number of segments
 *  cOutPerSeg	- Number NN outputs per segment
 *
 * DESCRIPTION:
 *
 * This function undoes the action of the previous function
 * (SlideSpaceOutputOneSegmentFwd) - slides the spaces
 * outputs one segment backward. Note it does not completely
 * restore it because the last 2 segments have the same 
 * space outputs - but this is OK since we never look at the last 
 * segment's space output.
 *
 ************************************************************/
void SlideSpaceOutputOneSegmentBack(REAL *pNetOut, int cSeg, int cOutPerSeg)
{
	REAL	*pPrev, *pCurr;

	pCurr = pNetOut + cOutPerSeg;
	pPrev = pNetOut;

	for (--cSeg; cSeg > 0 ; --cSeg)
	{
		*pPrev = *pCurr;

		pCurr += cOutPerSeg;
		pPrev += cOutPerSeg;
	}

}

void Beam(XRC *pxrc)
{
	LMSTATE		state;
	int			cSegments = pxrc->nfeatureset->cSegment;
	int			i;
	REAL		*pColumn;	// points to the top of the current column, in the neural network outputs.
	int			cStroke = CframeGLYPH(pxrc->pGlyph);
	int			iPrint = pxrc->nfeatureset->iPrint;
	int			s_iMaxProb = 1000;
	int			gCostBest;
	BEAM_GL		BeamGL;				// Keeps data that must be passed around. These used to be static globals
	REAL SpaceProb;
	int iMaxXOverlap = pxrc->nfeatureset->iyDev * MAX_STROKE_OVERLAP;
	DWORD flags;

#ifdef HWX_TIMING
#include <madTime.h>
	extern void setMadTiming(DWORD, int);
	TCHAR aDebugString[256];
	DWORD	iStartTime, iEndTime;
	iStartTime = GetTickCount();
#endif

	memset(&BeamGL, 0, sizeof(BeamGL));

	BeamGL.aActivations = (int *)ExternAlloc(sizeof(*BeamGL.aActivations) * C_CHAR_ACTIVATIONS);
	ASSERT(BeamGL.aActivations);
	if (!BeamGL.aActivations)
		return;

	BeamGL.CullThreshold = INFINITY_COST;
	BeamGL.BreedThreshold = INFINITY_COST;

	// Note that this turns off culling (and breed inhibition), for the first
	// column, and for the second (since we ignore the best cost from the first
	// column).  

    ASSERT(BeamGL.cTotalCell == 0);
    ASSERT(BeamGL.gcReferenced == 0);

	flags = LMINFO_FIRSTCAP|LMINFO_ALLCAPS;
	if (pxrc->iSpeed >= 50)
		flags |= LMINFO_WEAKDICT;

	InitializeLMINFO(&BeamGL.lminfo, flags, pxrc->hwl, pxrc->pvFactoid);

	// Create the first (top level) nodes, and update them (compute their costs)
	// for the first column.
	pColumn = pxrc->NeuralOutput;

	// Move of the space outputs 1 time slice forward (Makes accounting
	// of 'Factoid Spaces' easier)
	SlideSpaceOutputOneSegmentFwd(pColumn, cSegments, gcOutputNode);

	InitColumn(BeamGL.aActivations, pColumn);
	ComputeCharacterProbs(pColumn, cSegments, BeamGL.aCharProb, BeamGL.aCharBeginProb, BeamGL.aCharProbLong, BeamGL.aCharBeginProbLong);

	InitializeLMSTATE(&state);

	if (pxrc->szPrefix)
	{
		// If we have a prefix, the initial state is not unique.
		// I.e. there is a set of possible initial states.
		LMSTATELIST lmstatelist;
		LMSTATENODE *plmstatenode;
		int iCost;
		
		BeamGL.iBestCost = INFINITY_COST;
		
		// Make a list of states, initially containing only the root state.
		InitializeLMSTATELIST(&lmstatelist, NULL);
		// Update the list of states to contain states that are reachable
		// from the root state through the "path" pxrc->szPrefix.
		// Note that the resulting state list may be empty.
		ExpandLMSTATELIST(&lmstatelist, &BeamGL.lminfo, pxrc->szPrefix, FALSE);
		plmstatenode = lmstatelist.head;
		// Now consider each initial state and produce "beam cells".
		while (plmstatenode)
		{
			iCost = MkChildren(&BeamGL, 0, NULL, plmstatenode->lmstate, 0, 0, &BeamGL.pRootBegin);
			if (iCost < BeamGL.iBestCost)
				BeamGL.iBestCost = iCost;
			plmstatenode = plmstatenode->next;
		}
		// clean up
		DestroyLMSTATELIST(&lmstatelist);
	}

	if (!BeamGL.pRootBegin)
		BeamGL.iBestCost = MkChildren(&BeamGL, 0, NULL, state, 0, 0, &BeamGL.pRootBegin);

	// jbenn: with new prune, sometimes nothing proposed. In that case, we try
	// again, allowing everything.
	if (!BeamGL.pRootBegin) 
	{
		int	ii;

		ASSERT(!BeamGL.pRootBegin);
		for (ii = 0; ii < 256; ++ii)
			BeamGL.aCharProb[ii] = BeamGL.aCharBeginProb[ii] = 0xFFFF;
		BeamGL.iBestCost = MkChildren(&BeamGL, 0, NULL, state, 0, 0, &BeamGL.pRootBegin);

		// If we still have nothing with no pruning, we have to return an empty list.
		// If we let the code continue it will fault.
		if (!BeamGL.pRootBegin) 
		{
			ASSERT(!BeamGL.pRootBegin);
			pxrc->answer.cAlt	= 0;
			memset(pxrc->answer.aAlt, 0, sizeof(pxrc->answer.aAlt));
			goto errorOut;
		}
	}
    BeamGL.pRootEnd = BeamGL.pRootBegin;
    while (BeamGL.pRootEnd->pSibling)
        BeamGL.pRootEnd = BeamGL.pRootEnd->pSibling;

    ComputeThresh(&BeamGL);

    //
    // Now update the costs for each additional column.
    //

	for (i = 1; i < cSegments; i++)
	{
		REAL	*pSpaceThisCol;
		int		iWithinFactoidSpace;			// Cost of inserting a 'Factoid Space'
		REAL	SpaceProbRestore;				// What will be restored in the output array - it can change 
		int		iIsSpace;						// Does the ink allow a space at this point

#ifdef DUMPBEAM
		Dump(&BeamGL, "cells", i);
#endif

		iIsSpace = IsSpacePossible(pxrc->nfeatureset->head, i);

		// By default we restore no activity in the space node (e.g wod mode or no space is possible)
		SpaceProbRestore = 0;

		pColumn += gcOutputNode;
		pSpaceThisCol = &pColumn[BeginChar2Out(' ')];
		SpaceProb = *pSpaceThisCol;

		// Handle 'Factoid Space' Cost of allowing or not a space
		if (iIsSpace > 0)
		{
			iWithinFactoidSpace = (REAL)SpaceProb * FACTOID_SPACE_FUDGE + MIN_CHAR_PROB;		// Fudge this to bias towards these spaces
			iWithinFactoidSpace = min(0xFFFF, iWithinFactoidSpace);
		}
		else
		{
			iWithinFactoidSpace = 0;
		}

		// Save globably 'Not Factoid Space' cost
		BeamGL.iNotWithinFactoidSpace = (REAL)PROB_TO_COST(0xFFFF - iWithinFactoidSpace);

		// Insert the fudged activity into the 'Space Output'
		*pSpaceThisCol = (REAL)iWithinFactoidSpace;

		// Compensate for a 'Regular' space
		BeamGL.iNotBetweenFactoidSpace = 0;

        InitColumn(BeamGL.aActivations, pColumn);

		ComputeCharacterProbs(pColumn, cSegments-i, BeamGL.aCharProb, BeamGL.aCharBeginProb, BeamGL.aCharProbLong, BeamGL.aCharBeginProbLong);

		//
        // Can this guy have a preceding space (Is he a new segment ?)
        //
        if (!(pxrc->flags & RECOFLAG_WORDMODE) && (iIsSpace > 0))
        {			
			int xWidth = xSpaceFromColumn(pxrc->nfeatureset->head, i);

			if (xWidth > -iMaxXOverlap)
			{
				int iSpaceCost;
				int iNotSpaceCost;

				int iXThresh = 11 * pxrc->nfeatureset->iyDev / 2;

				SpaceProbRestore = (REAL)SpaceProb;

				if (xWidth >= iXThresh)
				{
					iSpaceCost = 0;
                    iNotSpaceCost = CULLFACTOR * 4;  // Kill them
					SpaceProbRestore = 65535;
				}
				else
				{
					// look up neural net output
					iSpaceCost = PROB_TO_COST(SpaceProb);
#ifdef FIXEDPOINT
					iNotSpaceCost = PROB_TO_COST(65535 - SpaceProb);
#else
					iNotSpaceCost = PROB_TO_COST((float)1 - SpaceProb);
#endif
					// scale costs
					iNotSpaceCost = NOT_SPACE_NUM * iNotSpaceCost / NOT_SPACE_DEN;
					iSpaceCost = IS_SPACE_NUM * iSpaceCost / IS_SPACE_DEN;
				}

				ASSERT(iSpaceCost >= 0);
				ASSERT(iNotSpaceCost >= 0);

				//
				// Run through whole trie.  Add iNotSpaceCost to
				// everyone.  Find the best valid word guy.  He's
				// the one we will extend with a space.
				//

                BeamGL.pCellBest = NULL;
                gCostBest = INT_MAX;

				// This is debatable _ What we are doing here is deferring the cost
				// of not inserting a space to the cost of not inserting a 'Regular
				// Space' We cannot use both. One argument in favour of doing this
				// is that we often come back in word mode over thsi ink, then
				// this question goes away
				BeamGL.iNotWithinFactoidSpace = 0;

                gCostBest = FindBestValidWord(&BeamGL, BeamGL.pRootBegin, iNotSpaceCost, gCostBest);

                if (BeamGL.pCellBest)
				{
					int iCost;

					//
					// Take this guys score, subtract out the NotSpace,
					// add in the Space, and generate the begin dictionary
					// nodes into the existing nodes.  They go at the root.
					//

					iCost = BeamGL.pCellBest->cost - iNotSpaceCost + iSpaceCost;

					if (iNotSpaceCost > CULLFACTOR)
                    {
                        int iTemp = 0;

						//
						// Kill all existing paths, make children from the
						// best choice so far.
						//

						BeamGL.pCellBest->cReferenced++;  // Just in case
						BeamGL.pCellBest->cost -= iNotSpaceCost;  // So everyone else gets culled

                        iTemp = BeamGL.CullThreshold = BeamGL.pCellBest->cost + 1; // So it doesn't get culled
                        BeamGL.BreedThreshold = BeamGL.pCellBest->cost - 1; // So it doesn't breed

                        UpdateCull(&BeamGL, BeamGL.pRootBegin);

						// This ASSERT was here because original intention is that the UpdateCull()
						// above should kill everything except best word found. However 
						// non valid words having a cost < iNotSpaceCost (= CULLFACTOR*4)
						// x the best valid word will survive. The current thinking (May 2001)
						// is that this is probably a good idea
						//ASSERT(iTemp == BeamGL.CullThreshold);

						// Add NotSpaceCost to BeamGL.pCellBest and all it's children
						// who got updated in UpdateCull 

						gCostBest = FindBestValidWord(&BeamGL, BeamGL.pRootBegin, iNotSpaceCost, gCostBest);
																		
                        BeamGL.iBestCost = MkChildren(&BeamGL, 
										  i,
                                          BeamGL.pCellBest,
                                          state,
										  0,
                                          iCost,
                                          &(BeamGL.pRootEnd->pSibling));

						BeamGL.pCellBest->cReferenced--;						

                        //
                        // Crazy, but no Cull is done here because next time
                        // through everybody who didn't get a space will die,
                        // so why bother.
                        //

						while (BeamGL.pRootEnd->pSibling)
							BeamGL.pRootEnd = BeamGL.pRootEnd->pSibling;

                        goto Past_Cull;
					}
					else
                    {
						// Set this here because all cells have iNotSpace added - we need to compensate in update() & mkChildren()
						BeamGL.iNotBetweenFactoidSpace = (REAL)iNotSpaceCost;   
						BeamGL.iBestCost += iNotSpaceCost;
						BeamGL.CullThreshold += iNotSpaceCost;
                        BeamGL.BreedThreshold += iNotSpaceCost;

                        BeamGL.pCellBest->cReferenced++;

                        BeamGL.iBestCost = UpdateCull(&BeamGL, BeamGL.pRootBegin);

                        ASSERT(BeamGL.pCellBest->cReferenced > 0);

                        BeamGL.iBestCost = min(BeamGL.iBestCost,
							       MkChildren(&BeamGL, 
								   i,
                                   BeamGL.pCellBest,
                                   state,
								   0,
								   iCost,
								   &(BeamGL.pRootEnd->pSibling)));

                        BeamGL.pCellBest->cReferenced--;
					}

					while (BeamGL.pRootEnd->pSibling)
						BeamGL.pRootEnd = BeamGL.pRootEnd->pSibling;

					goto Past_Cull;
				}
				else
				{
                    BeamGL.iBestCost += iNotSpaceCost;
					BeamGL.CullThreshold += iNotSpaceCost;
                    BeamGL.BreedThreshold += iNotSpaceCost;
				}

			}
        }

        BeamGL.iBestCost = UpdateCull(&BeamGL, BeamGL.pRootBegin);

Past_Cull:

		// Restore the actual Space probs for current and last columns
		*pSpaceThisCol = SpaceProbRestore;

        ComputeThresh(&BeamGL);
		
        #if 0
		{
			TCHAR szDebug[128];
			int cActive = BeamGL.cTotalCell - BeamGL.gcReferenced;
			wsprintf(szDebug, TEXT("cActive = %d iColumn = %d cTotal = %d gcReferenced = %d\n"), cActive, i, BeamGL.cTotalCell, BeamGL.gcReferenced);
			WriteToLogFile(szDebug);
		}		
		#endif
	}


#ifdef HWX_TIMING
	iEndTime = GetTickCount();

	_stprintf(aDebugString, TEXT("Beam LM Walk %d\n"), iEndTime - iStartTime); 
	OutputDebugString(aDebugString);
	setMadTiming(iEndTime - iStartTime, MM_BEAM_LM_WALK);
	iStartTime = GetTickCount();
#endif

#ifdef DUMPBEAM
		Dump(&BeamGL, "cells", cSegments);
#endif

    //
    // Get the answers.
    //
    if (Harvest(pxrc, &BeamGL) != HRCR_OK)
	{
		goto errorOut;
	}

	subtractSpaceCost(pxrc);
	

#ifdef HWX_TIMING
	iEndTime = GetTickCount();

	_stprintf(aDebugString, TEXT("Beam Harvest %d\n"), iEndTime - iStartTime); 
	OutputDebugString(aDebugString);
	setMadTiming(iEndTime - iStartTime, MM_BEAM_HARVEST);
#endif

    //
    // Release all the beam memory efficiently.
    //
errorOut:

	SlideSpaceOutputOneSegmentBack(pxrc->NeuralOutput, cSegments, gcOutputNode);

    FreeAllAlloc(&BeamGL);
	ExternFree(BeamGL.aActivations);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\beam.h ===
// HMMTRIE.h
// James A. Pittman
// Oct 30, 1997

#ifndef __INC_BEAM_
#define __INC_BEAM_

#include "engine.h"

#ifdef __cplusplus
extern "C" {
#endif

// Performs a beam search of the dictionary trie, and whatever else is included by the language
// model.
extern void Beam(XRC *pxrc);
extern int InsertStrokes(XRC *pXrc, WORDMAP *pMap, int iStart, int	iEnd, int cMaxStroke);

// The CULLFACTOR is the log prob that is added to the best log prob in a column to compute
// the culling threshold for that column.

#define CULLFACTOR 16000

// The BREEDFACTOR is the log prob that is added to the best log prob in a column to compute
// the breeding threshold for that column.

#define BREEDFACTOR 8000

#define TARGET_CELLS 1000

		// Maximum word length allowed in beam 
#define BEAM_MAX_WORD_LEN		255

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\dict.h ===
// dict.h
// Angshuman Guha, aguha
// Sep 17, 1998

#ifndef __INC_DICT_H
#define __INC_DICT_H

#include "langmod.h"

#ifdef __cplusplus
extern "C" {
#endif

void GetChildrenDICT(LMSTATE *pState, LMINFO *pLminfo, REAL *aCharProb, LMCHILDREN *pLmchildren);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\bullet.c ===
// bullet.c
// Angshuman Guha
// aguha
// Feb 7, 2001

#include "common.h"
#include "bullet.h"

// text generated by re2fsa at Wed Feb 07 10:41:11 2001

// the input-file of rules:
// digit = "0123456789"
// num = digit [digit [digit]]
// name = num | "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
// bullet = name ["." name ["." name]]
// = bullet

// 12 states

static const unsigned char gaSBULLET[] = 
	/* gaStringBULLET+0 */	"0123456789\000"
	/* gaStringBULLET+11 */	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\000"
	/* gaStringBULLET+64 */	".\000"
;

static const STATE_TRANSITION gaTBULLET[] = {
	{gaSBULLET+0,	1}, // +0: state 0 transitions
	{gaSBULLET+11,	2},
	{gaSBULLET+64,	3}, // +2: state 1 transitions
	{gaSBULLET+0,	11},
	{gaSBULLET+64,	3}, // +4: state 2 transitions
	{gaSBULLET+0,	4}, // +5: state 3 transitions
	{gaSBULLET+11,	5},
	{gaSBULLET+64,	6}, // +7: state 4 transitions
	{gaSBULLET+0,	10},
	{gaSBULLET+64,	6}, // +9: state 5 transitions
	{gaSBULLET+0,	7}, // +10: state 6 transitions
	{gaSBULLET+11,	8},
	{gaSBULLET+0,	9}, // +12: state 7 transitions
	{gaSBULLET+0,	8}, // +13: state 9 transitions
	{gaSBULLET+0,	5}, // +14: state 10 transitions
	{gaSBULLET+64,	6},
	{gaSBULLET+0,	2}, // +16: state 11 transitions
	{gaSBULLET+64,	3},
};

const STATE_DESCRIPTION aStateDescBULLET[12] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTBULLET+0},
	/*   1 */ {1, 2, gaTBULLET+2},
	/*   2 */ {1, 1, gaTBULLET+4},
	/*   3 */ {0, 2, gaTBULLET+5},
	/*   4 */ {1, 2, gaTBULLET+7},
	/*   5 */ {1, 1, gaTBULLET+9},
	/*   6 */ {0, 2, gaTBULLET+10},
	/*   7 */ {1, 1, gaTBULLET+12},
	/*   8 */ {1, 0, NULL},
	/*   9 */ {1, 1, gaTBULLET+13},
	/*  10 */ {1, 2, gaTBULLET+14},
	/*  11 */ {1, 2, gaTBULLET+16},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\email.h ===
// email.h
// Angshuman Guha
// aguha
// Jan 10, 2001

#ifndef __INC_EMAIL_H
#define __INC_EMAIL_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescEMAIL[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\dllmain.c ===
#include "common.h"

#include "nfeature.h"
#include "engine.h"

BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {        
        return(!!InitRecognition(hDll));
    }
    
    if (dwReason == DLL_PROCESS_DETACH)
    {
        CloseRecognition();
    }

    return((int)TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\bullet.h ===
// bullet.h
// Angshuman Guha
// aguha
// Feb 7, 2001

#ifndef __INC_BULLET_H
#define __INC_BULLET_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescBULLET[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\email.c ===
// email.c
// Angshuman Guha
// aguha
// Dec 15, 2000

#include "common.h"
#include "email.h"
#include "fsa.h"

static unsigned char gpchEmailChar[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";

static int cState = 6;

static STATE_TRANSITION State00Trans[1] = { {gpchEmailChar, 1} };
static STATE_TRANSITION State01Trans[3] = { {gpchEmailChar, 1}, {"@", 2}, {".", 4} };
static STATE_TRANSITION State02Trans[1] = { {gpchEmailChar, 3} };
static STATE_TRANSITION State03Trans[2] = { {gpchEmailChar, 3}, {".", 5} };
static STATE_TRANSITION State04Trans[1] = { {gpchEmailChar, 1} };
static STATE_TRANSITION State05Trans[1] = { {gpchEmailChar, 3} };

const STATE_DESCRIPTION aStateDescEMAIL[6] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, State00Trans },
	/*  1 */ { 0, 3, State01Trans },
	/*  2 */ { 0, 1, State02Trans },
	/*  3 */ { 1, 2, State03Trans },
	/*  4 */ { 0, 1, State04Trans },
	/*  5 */ { 0, 1, State05Trans }
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\dict.c ===
// dict.c
// Angshuman Guha, aguha
// April 17,2001

#include "common.h"
#include "sysdict.h"
#include "wl.h"
#include "fsa.h"
#include "prefix.h"
#include "suffix.h"
#include "factoid.h"

// this file contains a wrapper around the system dictionary and the user dictionary
// to deal with prefixes and suffixes

/******************************Private*Routine******************************\
* GetChildrenPrefix
*
* Function to walk the Prefix pseudo-factoid.  Its pseudo because the outside
* world doesn't know aboiut its existence.  Its really part of the SYSDICT
* and USERDICT factoids.
*
* This function is a copy of GetChildrenGENERIC() except
* that it uses LMSTATE_PREFIX_VALID instead of LMSTATE_ISVALIDSTATE_MASK
* to mark a state as being valid, and always sets LMSTATE_HASCHILDREN_MASK.
*
* History:
* 17-Apr-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void GetChildrenPrefix(LMSTATE *pState,
					   LMINFO *pLminfo,
					   REAL *aCharProb,  // array of size 256
					   LMCHILDREN *pLmchildren)
{
	DWORD state = pState->AutomatonState;
	const STATE_TRANSITION *pTrans;
	int cTrans, i;
	LMSTATE newState;

	//ASSERT(state < (DWORD)cState);
	pTrans = aStateDescPrefix[state].pTrans;
	cTrans = aStateDescPrefix[state].cTrans;
	newState = *pState;

	for (i=0; i<cTrans; i++, pTrans++)
	{
		const unsigned char *pch;
		
		pch = pTrans->pch;
		state = pTrans->state;

		newState.AutomatonState = state;
		newState.flags |= LMSTATE_HASCHILDREN_MASK;

		if (aStateDescPrefix[state].bValid)
			newState.flags |= LMSTATE_PREFIX_VALID;
		else
			newState.flags &= ~LMSTATE_PREFIX_VALID;

		while (*pch)
		{
			unsigned char ch = *pch++;

			if (aCharProb && (aCharProb[ch] < MIN_CHAR_PROB))
				continue;
			if (!AddChildLM(&newState, ch, 0, 0, pLmchildren))
				break;
		}
	}
}

/******************************Private*Routine******************************\
* GetChildrenDictCore
*
* This is the function through which calls to the System Dictionary and the 
* User Dictionary are routed.  
* This function also deals with generating "FIRSTCAP" and "ALLCAPS"
* versions of the native words.
*
+-------------------+-----------+-----------+
| parent state      |           |           |
| L | U | UL | root | native LC | native UC |
+---+---+----+------+-----------+-----------+
|   |   |    | yes  | LC  -  L  | UC  -  UL |
|   |   |    |      | UC  -  UL |           |
+---+---+----+------+-----------+-----------+
| x |   |    |  no  | LC  -  L  | UC  -  L  |
+---+---+----+------+-----------+-----------+
|   | x |    |  no  | LC  -  U  | UC  -  U  |
+---+---+----+------+-----------+-----------+
|   |   | x  |  no  | LC  -  L  | UC  -  UL |
|   |   |    |      | UC  -  U  |           |
+---+---+----+------+-----------+-----------+
 "native LC" means the character appears as a lowercase in the dictionary
 "native UC" means the character appears as a uppercase in the dictionary
 LC = lowercase char generated
 UC = uppercase char generated
*
*
* History:
* 24-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void GetChildrenDictCore(LMSTATE *pState, LMINFO *pLminfo, REAL *aCharProb, LMCHILDREN *pLmchildren)
{
	int iChild = pLmchildren->c, cChildren;
	BOOL bRoot = !pState->AutomatonState;
	LMNODE *pLmnode;
	LMSTATE lmstate;

	// relay the call to the appropriate dictionary
	if (IsSysdictState(*pState))
		GetChildrenSYSDICT(pState, pLminfo, aCharProb, pLmchildren);
	else
		GetChildrenUDICT(pState, pLminfo, aCharProb, pLmchildren);

	cChildren = pLmchildren->c;

	// now deal with "FIRSTCAP" and "ALLCAPS" issues
	//pLmnode = pLmchildren->almnode + iChild;
	if (bRoot)
	{
		BOOL bAllcaps = LMINFO_IsAllcapsEnabled(pLminfo);
		BOOL bFirstcap = bAllcaps | LMINFO_IsFirstcapEnabled(pLminfo);

		for (; iChild<cChildren; iChild++)
		{
			unsigned char uch;
			
			pLmnode = pLmchildren->almnode + iChild;
			uch = toupper1252(pLmnode->ch);
			pLmnode->lmstate.flags |= LMSTATE_DICTLITERAL;
			if (uch != pLmnode->ch)
			{
				pLmnode->lmstate.flags &= ~LMSTATE_DICTUPCASE;
				if (bFirstcap)
				{
					// generate an uppercase version
					lmstate = pLmnode->lmstate;
					if (bAllcaps)
						lmstate.flags |= LMSTATE_DICTUPCASE;
					AddChildLM(&lmstate, uch, pLmnode->CalligTag, 1, pLmchildren);
				}
			}
			else
			{
				if (bAllcaps)
					pLmnode->lmstate.flags |= LMSTATE_DICTUPCASE;
				else
					pLmnode->lmstate.flags &= ~LMSTATE_DICTUPCASE;
			}
		}
	}
	else
	{
		BOOL bLiteral = pState->flags & LMSTATE_DICTLITERAL;
		BOOL bUpcase = pState->flags & LMSTATE_DICTUPCASE;

		if (bLiteral && bUpcase)
		{
			// not at root: case 1
			for (; iChild<cChildren; iChild++)
			{
				unsigned char uch;
				
				pLmnode = pLmchildren->almnode + iChild;
				uch = toupper1252(pLmnode->ch);
				pLmnode->lmstate.flags |= LMSTATE_DICTLITERAL;
				if (uch != pLmnode->ch)
				{
					lmstate = pLmnode->lmstate;
					pLmnode->lmstate.flags &= ~LMSTATE_DICTUPCASE;
					// generate an uppercase version
					lmstate.flags |= LMSTATE_DICTUPCASE;
					lmstate.flags &= ~LMSTATE_DICTLITERAL;
					AddChildLM(&lmstate, uch, pLmnode->CalligTag, 1, pLmchildren);
				}
				else
				{
					pLmnode->lmstate.flags |= LMSTATE_DICTUPCASE;
				}
			}
		}
		else if (bLiteral)
		{
			// not at root: case 2
			ASSERT(!bUpcase);
			pLmnode = pLmchildren->almnode + iChild;
			for (; iChild<cChildren; iChild++, pLmnode++)
			{
				pLmnode->lmstate.flags |= LMSTATE_DICTLITERAL;
				pLmnode->lmstate.flags &= ~LMSTATE_DICTUPCASE;
			}
		}
		else if (bUpcase)
		{
			// not at root: case 3
			ASSERT(!bLiteral);
			pLmnode = pLmchildren->almnode + iChild;
			for (; iChild<cChildren; iChild++, pLmnode++)
			{
				pLmnode->ch = toupper1252(pLmnode->ch);
				pLmnode->lmstate.flags |= LMSTATE_DICTUPCASE;
				pLmnode->lmstate.flags &= ~LMSTATE_DICTLITERAL;
			}
		}
		else
		{
			ASSERT(0);
		}
	}
}


/******************************Public*Routine******************************\
* GetChildrenDICT
*
* This is the top-level function called from with the language model to walk
* either the system or the user dictionary.  It encapsulates the dictionary
* and the prefix and suffix pseudo-factoids.
*
* History:
* 17-Apr-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void GetChildrenDICT(LMSTATE *pState,
					 LMINFO *pLminfo,
					 REAL *aCharProb,  
					 LMCHILDREN *pLmchildren)
{
	LMSTATE newState = *pState;

	// the following four valid cases are listed in an order designed
	// the minimize the prefix- and suffix- overhead when a recognizer's
	// prefix or suffix lists are empty

	// case 1: we are inside the dictionary
	if (pState->flags & LMSTATE_COREDICT)
	{
		if (aStateDescSuffix && (newState.flags & LMSTATE_ISVALIDSTATE_MASK))
		{
			newState.flags &= ~LMSTATE_COREDICT;
			newState.flags |= LMSTATE_SUFFIX;
			newState.AutomatonState = 0;
			GetChildrenGENERIC(&newState, pLminfo, aCharProb, pLmchildren, aStateDescSuffix);
		}
		newState = *pState;
		GetChildrenDictCore(&newState, pLminfo, aCharProb, pLmchildren);
	}

	// case 2: this is the very first call into GetChildrenDICT
	// i.e. we are in the initial state
	else if (newState.flags == 0)
	{
		ASSERT(newState.AutomatonState == 0);
		if (aStateDescPrefix)
		{
			newState.flags = LMSTATE_PREFIX;
			GetChildrenPrefix(&newState, pLminfo, aCharProb, pLmchildren);
		}
		newState.flags = LMSTATE_COREDICT;
		GetChildrenDictCore(&newState, pLminfo, aCharProb, pLmchildren);
	}

	// case 3: we are in the prefix machine
	else if (newState.flags & LMSTATE_PREFIX)
	{
		if (newState.flags & LMSTATE_PREFIX_VALID)
		{
			newState.flags &= ~LMSTATE_PREFIX;
			newState.flags |= LMSTATE_COREDICT;
			newState.AutomatonState = 0;
			GetChildrenDictCore(&newState, pLminfo, aCharProb, pLmchildren);
		}
		newState = *pState;
		GetChildrenPrefix(&newState, pLminfo, aCharProb, pLmchildren);
	}

	// case 4: we are in the suffix machine
	else if (pState->flags & LMSTATE_SUFFIX)
	{
		GetChildrenGENERIC(&newState, pLminfo, aCharProb, pLmchildren, aStateDescSuffix);
	}

	// this case should never happen
	else
	{
		ASSERT(0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\engine.h ===
// engine.h

#ifndef __INC_ENGINE_H
#define __INC_ENGINE_H

#include "infernop.h"
#include "recdefs.h"


#ifdef __cplusplus
extern "C" {
#endif

	
typedef struct
{
	DWORD				dwReserved;
	int					cFrames;
	GLYPH				*pGlyph;
	NFEATURESET			*nfeatureset;
	BOOL				bGuide;
	GUIDE				guide;
	REAL				*NeuralOutput;
	void				*pvFactoid;
	unsigned char		*szPrefix;
	unsigned char		*szSuffix;

    // recognition result
    ALTERNATES			answer;

	// neural output (symbolic)
    unsigned char		*szNeural;
    int					cNeural;

	HWL					hwl;
	DWORD				flags;
	BOOL				bEndPenInput;		// ink input has stopped
	BOOL				bProcessCalled;		// processing has started
	int					iProcessRet;		// Returned code
	int					iSpeed;				// User setable Speed / accuracy  tradeoff [HWX_MIN_SPEED: HWX_MAX_SPEED]

	LINEBRK				*pLineBrk;			// Line breaking information for all the ink that has been seen so far
} XRC;


typedef struct tagFFINFO
{
	NFEATURESET *nfeatureset;
	REAL *NeuralOutput;
	int iSpeed;

} FFINFO;


#define IsFlagSetXRC(xrc, flag) ((xrc)->flags & flag)
#define SetFlagXRC(xrc, flag) (xrc)->flags |= flag
#define ResetFlagXRC(xrc, flag) (xrc)->flags &= ~flag

#define bOutdictEnabledXRC(xrc) (!IsFlagSetXRC(xrc, RECOFLAG_COERCE))
#define EnableOutdictXRC(xrc) ResetFlagXRC(xrc, RECOFLAG_COERCE)
#define DisableOutdictXRC(xrc) SetFlagXRC(xrc, RECOFLAG_COERCE)

#define bNnonlyEnabledXRC(xrc) (IsFlagSetXRC(xrc, RECOFLAG_NNONLY))
#define EnableNnonlyXRC(xrc) SetFlagXRC(xrc, RECOFLAG_NNONLY)
#define DisableNnonlyXRC(xrc) ResetFlagXRC(xrc, RECOFLAG_NNONLY)

int InitRecognition(HINSTANCE);
void CloseRecognition(void);
void PerformRecognition(XRC *pxrc, int yDev);
void MakeNeuralOutput(XRC *pxrc);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\filename.h ===
// filename.h
// Angshuman Guha
// aguha
// Nov 16, 2001

#ifndef __INC_FILENAME_H
#define __INC_FILENAME_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescFILENAME[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\filename.c ===
// filename.c
// Angshuman Guha
// aguha
// Nov 16, 2001

#include "common.h"
#include "filename.h"
#include "fsa.h"

/* The windows help topic "file names, forbidden characters in file names" lists forbidden characters as

\ / : * ? " < > |

*/

// text generated by re2fsa at Tue Apr 09 09:56:45 2002

// the input-file of rules:
// filenamechar = "!#$%&'()+,-.0123456789;=@[]^_`{}~";
// alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
// wildchar = "*?";
// start = "\\" "\\";
// start = [alpha ":"] ["\\"];
// filename = start ( (filenamechar | alpha)+ "\\")* (filenamechar | alpha | wildchar)*;
// = filename

// 5 states

static const unsigned char gaSFILENAME[] = 
	/* gaStringFILENAME+0 */	"!#$%&'()+,-.0123456789;=@[\\]^_`{}~\000"
	/* gaStringFILENAME+37 */	"*?\000"
	/* gaStringFILENAME+40 */	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\000"
	/* gaStringFILENAME+160 */	"!#$%&'()+,-.0123456789;=@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{}~\000"
	/* gaStringFILENAME+315 */	"\\\000"
	/* gaStringFILENAME+317 */	"!#$%&'()*+,-.0123456789;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{}~\000"
	/* gaStringFILENAME+474 */	"!#$%&'()+,-.0123456789:;=@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{}~\000"
;

static const STATE_TRANSITION gaTFILENAME[] = {
	{gaSFILENAME+0,	1}, // +0: state 0 transitions
	{gaSFILENAME+37,	2},
	{gaSFILENAME+40,	3},
	{gaSFILENAME+160,	1}, // +3: state 1 transitions
	{gaSFILENAME+37,	2},
	{gaSFILENAME+315,	4},
	{gaSFILENAME+317,	2}, // +6: state 2 transitions
	{gaSFILENAME+474,	1}, // +7: state 3 transitions
	{gaSFILENAME+37,	2},
	{gaSFILENAME+315,	4},
	{gaSFILENAME+160,	1}, // +10: state 4 transitions
	{gaSFILENAME+37,	2},
};

const STATE_DESCRIPTION aStateDescFILENAME[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {1, 3, gaTFILENAME+0},
	/*   1 */ {1, 3, gaTFILENAME+3},
	/*   2 */ {1, 1, gaTFILENAME+6},
	/*   3 */ {1, 3, gaTFILENAME+7},
	/*   4 */ {1, 2, gaTFILENAME+10},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\hwxapi.c ===
// hwxapi.c

#include <stdlib.h>
#include <limits.h>

#include "common.h"
#include "nfeature.h"
#include "engine.h"
#include "resource.h"
#include "langmod.h"
#include "nnet.h"
#include "wl.h"
#include "privdefs.h"
#include "re_api.h"
#include "factoid.h"

# if !defined(BEAR_RECOG)
#include "baseline.h"
#endif
/******************************Public*Routine******************************\
* CreateCompatibleHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
HRC WINAPI CreateCompatibleHRC(HRC hrc, HREC hrec)
{
	XRC *pxrc, *pxrcOld;
	
	pxrc = (XRC *) ExternAlloc(sizeof(XRC));
	if (!pxrc)
		return NULL;

	pxrcOld = (XRC *) hrc;

	if (pxrcOld)
	{
		*pxrc = *pxrcOld;
		pxrc->pvFactoid = CopyCompiledFactoid(pxrc->pvFactoid);
	}
	else
	{
		pxrc->pvFactoid = NULL;
		pxrc->bGuide = FALSE;
		memset(&pxrc->guide, 0, sizeof(GUIDE));
		pxrc->answer.cAltMax = MAXMAXALT;
		pxrc->answer.iConfidence=RECOCONF_NOTSET;
		pxrc->hwl = NULL;
		
		pxrc->flags	= 0;
		
		pxrc->iSpeed	= HWX_DEFAULT_SPEED;
	}

	pxrc->cFrames			= 0;
	pxrc->pGlyph			= NULL;
	pxrc->nfeatureset		= NULL;
	pxrc->szNeural			= NULL;
	pxrc->cNeural			= 0;
	pxrc->answer.cAlt		= 0;
	pxrc->NeuralOutput		= NULL;
	pxrc->bEndPenInput		= FALSE;
	pxrc->bProcessCalled	= FALSE;
	pxrc->iProcessRet		= HRCR_OK;
	pxrc->szPrefix			= NULL;
	pxrc->szSuffix			= NULL;
	pxrc->pLineBrk			= NULL;

	/* Make sure that current copy of user dictionary is loaded.
	{
		extern HWL			LoadUserDictionary(void);
		extern int WINAPI	SetWordlistHRC(HRC hrc, HWL hwl);

		HWL		hwl;

		hwl	= LoadUserDictionary();
		if (hwl) {
			SetWordlistHRC((HRC)pxrc, hwl);
		}
	}
	*/

	return (HRC)pxrc;
}

/******************************Public*Routine******************************\
* SetAlphabetHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI SetAlphabetHRC(HRC hrc, ALC alc, LPBYTE pbUnused)
{
	XRC *pxrc = (XRC *)hrc;

	if (!pxrc)
		return HRCR_ERROR;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;

	if (alc & ALC_WHITE)
		pxrc->flags &= ~RECOFLAG_WORDMODE;
	else
		pxrc->flags |= RECOFLAG_WORDMODE;

	return HRCR_OK;
}

/******************************Private*Routine******************************\
* Cleanup
*
* Cleans up an xrc. 
\**************************************************************************/
int CleanupHRC(HRC hrc)
{
	XRC *pxrc = (XRC *) hrc;

	if (!pxrc)
		return HRCR_ERROR;

	if (pxrc->nfeatureset)
	{
		DestroyNFEATURESET(pxrc->nfeatureset);
		pxrc->nfeatureset	=	NULL;
	}

	if (pxrc->szNeural)
	{
		ExternFree(pxrc->szNeural);
		pxrc->szNeural	=	NULL;
	}

	ClearALTERNATES(&(pxrc->answer));

	if (pxrc->NeuralOutput)
	{
		ExternFree(pxrc->NeuralOutput);
		pxrc->NeuralOutput	=	NULL;
	}
		
	return HRCR_OK;
}



/******************************Public*Routine******************************\
* DestroyHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI DestroyHRC(HRC hrc)
{
	XRC *pxrc = (XRC *) hrc;

	if (!pxrc)
		return HRCR_ERROR;

	CleanupHRC (hrc);

	if (pxrc->pGlyph)
	{
		DestroyFramesGLYPH(pxrc->pGlyph);
		DestroyGLYPH(pxrc->pGlyph);
	}

	if (pxrc->szPrefix)
		ExternFree(pxrc->szPrefix);

	if (pxrc->szSuffix)
		ExternFree(pxrc->szSuffix);

	// free the line breaking info
	if (pxrc->pLineBrk)
	{
		FreeLines (pxrc->pLineBrk);

		ExternFree (pxrc->pLineBrk);
	}

	if (pxrc->pvFactoid)
		ExternFree(pxrc->pvFactoid);

	ExternFree(pxrc);

	return HRCR_OK;
}


/******************************Public*Routine******************************\
* AddPenInputHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI AddPenInputHRC(HRC hrc, POINT *rgPoint, LPVOID lpvUnused, UINT uiUnused, STROKEINFO *pSi)
{
	XY *rgXY;
	XRC *pxrc;
	FRAME *frame;
	int cPoint;
	
	// check pointers
	pxrc = (XRC *)hrc;
	if (!pxrc)
		return HRCR_ERROR;

	// Presently must add all ink before doing EndPenInput
	if (TRUE == pxrc->bEndPenInput)
	{
		return HRCR_ERROR;
	}

	if (pxrc && rgPoint && pSi && pSi->cPnt > 0)
	{
		// Skip strokes that dont have the visible flag set
		if (!IsVisibleSTROKE(pSi))
		{
			return HRCR_OK;
		}

		if (32767 < pSi->cPnt)
               return HRCR_ERROR;

		// allocate space
		cPoint = pSi->cPnt;
		rgXY = (XY *) ExternAlloc(cPoint * sizeof(XY));
		if (rgXY)
		{
			// make new frame
			if (frame = NewFRAME())
			{
				frame->info = *pSi;
				RgrawxyFRAME(frame) = rgXY;
				if (!pxrc->pGlyph)
					pxrc->pGlyph = NewGLYPH();

				if (pxrc->pGlyph)
				{
					if (AddFrameGLYPH(pxrc->pGlyph, frame))
					{
						frame->iframe = pxrc->cFrames;
						pxrc->cFrames++;

						// copy points

						for (cPoint=pSi->cPnt; cPoint; cPoint--)
							*rgXY++ = *rgPoint++;

						return HRCR_OK;
					}
				}

				RgrawxyFRAME(frame) = NULL;
				DestroyFRAME(frame);  // on error
			}

			ExternFree(rgXY);  // on error

		}
	}

	return HRCR_ERROR;
}

/******************************Public*Routine******************************\
* EndPenInputHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI EndPenInputHRC(HRC hrc)
{
	XRC *pxrc = (XRC *) hrc;
	if (!pxrc)
		return HRCR_ERROR;

	pxrc->bEndPenInput = TRUE;
	return HRCR_OK;
}

/******************************Public*Routine******************************\
* SetGuideHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI SetGuideHRC(HRC hrc, LPGUIDE lpguide,  UINT nFirstVisible)
{
	XRC *pxrc;
	BOOL bGuide;
	int	xAvail, yAvail;

	pxrc = (XRC *)hrc;
	if (!pxrc)
		return HRCR_ERROR;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;

	if (lpguide)
	{
		if ((lpguide->cVertBox < 0) || (lpguide->cHorzBox < 0))
			return HRCR_ERROR;

		if ((lpguide->cVertBox == 0) && (lpguide->cHorzBox == 0))  // free mode
			bGuide = FALSE;
		else if (lpguide->cVertBox == 0)	// vertical line mode
			return HRCR_ERROR;
		else if (lpguide->cHorzBox == 0)	// horizontal line mode
			bGuide = TRUE;
		else							// boxed mode
			return HRCR_ERROR;
	}
	else
		bGuide = FALSE;

	if (bGuide)
	{
		// Get space between INT_MAX and last guide box
		if (lpguide->xOrigin >= 0)
			xAvail = INT_MAX - lpguide->xOrigin;
		else
			xAvail = INT_MAX;

		if (lpguide->yOrigin >= 0)
			yAvail = INT_MAX - lpguide->yOrigin;
		else
			yAvail = INT_MAX;

		if ((lpguide->cxBox < 0) || (xAvail < lpguide->cxBox) ||
			(lpguide->cyBox <= 0) || ((yAvail / lpguide->cVertBox) < lpguide->cyBox) ||
			(lpguide->cxBase < 0) || (lpguide->cxBox < lpguide->cxBase) ||
			(lpguide->cyBase < 0) || (lpguide->cyBox < lpguide->cyBase) ||
			(lpguide->cyMid < 0) || (lpguide->cyBase < lpguide->cyMid))
			return HRCR_ERROR;
	}

	pxrc->bGuide = bGuide;
	if (bGuide)
		pxrc->guide = *lpguide;
	else
		memset(&pxrc->guide, 0, sizeof(GUIDE));

	return HRCR_OK;
}
/******************************Public*Routine******************************\
* AddWordsHWL
*
* PenWindows recognizer API.
*
* History:
*  June 2001 mrevow
* 
\**************************************************************************/
int WINAPI AddWordsHWL(HWL hwl, LPSTR lpsz, UINT uType)
{
	BOOL		iRet;

	if (!hwl || !lpsz)
	{
		return HRCR_ERROR;
	}

	// Merge two lists
	if (WLT_WORDLIST == uType)
	{
		iRet = MergeListsHWL((HWL)lpsz, (HWL)hwl);
	}
	else
	{
		iRet = addWordsHWL((HWL)hwl, lpsz, NULL, uType);
	}

	if (TRUE == iRet)
	{
		return HRCR_OK;
	}
	else
	{
		return HRCR_ERROR;
	}
}

/******************************Public*Routine******************************\
* AddWordsHWLW
*
* PenWindows recognizer API, unicode extension
*
* History:
*  June 2001 mrevow
* 
\**************************************************************************/
int WINAPI AddWordsHWLW(HWL hwl, wchar_t *pwsz, UINT uType)
{
	BOOL		iRet;

	if (!hwl || !pwsz)
	{
		return HRCR_ERROR;
	}

	// Merge two lists
	if (WLT_WORDLIST == uType)
	{
		iRet = MergeListsHWL((HWL)hwl, (HWL)pwsz);
	}
	else
	{
		iRet = addWordsHWL((HWL)hwl, NULL, pwsz, uType);
	}

	if (TRUE == iRet)
	{
		return HRCR_OK;
	}
	else
	{
		return HRCR_ERROR;
	}
}


/******************************Public*Routine******************************\
* CreateHWL
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
HWL WINAPI CreateHWL(HREC hrec, LPSTR lpsz, UINT uType, DWORD dwReserved)
{

	return (HWL)CreateHWLInternal(lpsz, NULL, uType);
}
/******************************Public*Routine******************************\
* CreateHWLW
*
* PenWindows recognizer API extension for unicode
*
* History:
*  June 2001 mrevow
* 
\**************************************************************************/
HWL WINAPI CreateHWLW(HREC hrec, wchar_t * pwsz, UINT uType, DWORD dwReserved)
{

	return (HWL)CreateHWLInternal(NULL, pwsz, uType);
}

/******************************Public*Routine******************************\
* DestroyHWL
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI DestroyHWL(HWL hwl)
{
	if (!DestroyHWLInternal(hwl))
		return HRCR_ERROR;
	return HRCR_OK;
}
/******************************Public*Routine******************************\
* GetWordlistHRC
*
* PenWindows recognizer API.
*
* History:
*  June 2001 mrevow
* 
\**************************************************************************/
int WINAPI GetWordlistHRC(HRC hrc, LPHWL lphwl)
{
	XRC		*pxrc;

	pxrc = (XRC *)hrc;
	if (!pxrc || ! lphwl)
	{
		return HRCR_ERROR;
	}

	*lphwl = pxrc->hwl;

	return HRCR_OK;
}

/******************************Public*Routine******************************\
* SetWordlistCoercionHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI SetWordlistCoercionHRC(HRC hrc, UINT uCoercion)
{
	XRC *pxrc;

	pxrc = (XRC *) hrc;
	if (!pxrc)
		return HRCR_ERROR;
	
	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;
	
	switch(uCoercion)
	{
	case SCH_ADVISE:
	case SCH_NONE:
		pxrc->flags = 0;
		break;
	case SCH_FORCE:
		pxrc->flags |= RECOFLAG_COERCE;
		break;
	default:
		return HRCR_ERROR;
	}

	return HRCR_OK;
}

/******************************Public*Routine******************************\
* SetWordlistHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI SetWordlistHRC(HRC hrc, HWL hwl)
{
	XRC *pxrc;

	pxrc = (XRC *) hrc;
	if (!pxrc)
		return HRCR_ERROR;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;

	pxrc->hwl = hwl;
	return HRCR_OK;
}

/******************************Public*Routine******************************\
* EnableSystemDictionaryHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
*  15-March-2001 -by- Angshuman Guha aguha
* The new API SetHwxContext() makes it obsolete.
\**************************************************************************/
int WINAPI EnableSystemDictionaryHRC(HRC hrc, BOOL fEnable)
{
	XRC	*pxrc	=	(XRC *)hrc;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;

	return HRCR_OK;
}

/******************************Public*Routine******************************\
* EnableLangModelHRC
*
* PenWindows recognizer API.  Penwin32.h.  Currently not supported.
*
* History:
*  20-March-2001 -by- Angshuman Guha aguha
* Added back because shipped Office 10 code calls it.
\**************************************************************************/
int WINAPI EnableLangModelHRC(HRC hrc, BOOL fEnable)
{
	XRC	*pxrc	=	(XRC *)hrc;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;

	return HRCR_OK;
}

/******************************Public*Routine******************************\
* GetMaxResultsHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetMaxResultsHRC(HRC hrc)
{
	XRC *pxrc;

	pxrc = (XRC *) hrc;
	if (!pxrc)
		return HRCR_ERROR;
	return pxrc->answer.cAltMax;
}

/******************************Public*Routine******************************\
* SetMaxResultsHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI SetMaxResultsHRC(HRC hrc, UINT cAltMax)
{
	XRC *pxrc;

	pxrc = (XRC *) hrc;
	if (!pxrc)
		return HRCR_ERROR;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_ERROR;

	if (cAltMax <= 0)
		return HRCR_ERROR;

	if (cAltMax > MAXMAXALT)
		cAltMax = MAXMAXALT;

	pxrc->answer.cAltMax = cAltMax;
	return HRCR_OK;
}

/******************************Public*Routine******************************\
* GetResultsHRC
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetResultsHRC(HRC hrc, UINT uType, HRCRESULT *pResults, UINT cResults)
{
    ALTERNATES *pAlt;

	if (!hrc || !pResults || !cResults)
		return HRCR_ERROR;

	if (uType == GRH_GESTURE)
		return 0;

	pAlt = &(((XRC *)hrc)->answer);

	if (pAlt->cAlt < cResults)
		cResults = pAlt->cAlt;

	if (cResults)
	{
		XRCRESULT *p = pAlt->aAlt;
		int c = cResults;

		for (; c; c--, pResults++, p++)
			*pResults = (HRCRESULT)p;
	}

	return cResults;
}

/******************************Public*Routine******************************\
* GetAlternateWordsHRCRESULT
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetAlternateWordsHRCRESULT(HRCRESULT hrcresult, UINT iSyv, UINT cSyv,
										 HRCRESULT *pResults, UINT cResults)
{
	XRCRESULT *pRes = (XRCRESULT *)hrcresult;

	if (!pRes || !pResults)
		return HRCR_ERROR;

	if (!(pRes->cWords))
	{
		XRC *pxrc = (XRC *)(pRes->pXRC);

		if ((iSyv != 0) || (cSyv != strlen(pRes->szWord)))
			return 0;
		if (pxrc && (pxrc->answer.aAlt <= pRes) && (pRes < (pxrc->answer.aAlt + pxrc->answer.cAlt)))
			return GetResultsHRC((HRC)pxrc, GRH_ALL, pResults, cResults);
		else
			return 0;
	}
	else
		return RCRESULTWords(pRes, iSyv, cSyv, (XRCRESULT **)pResults, cResults);
}

/******************************Public*Routine******************************\
* GetSymbolCountHRCRESULT
*
* PenWindows recognizer API.
*
* This does NOT include a null symbol at the end.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetSymbolCountHRCRESULT(HRCRESULT hrcresult)
{
	if (!hrcresult)
		return 0;

	return strlen(((XRCRESULT *)hrcresult)->szWord);
}

/******************************Public*Routine******************************\
* GetSymbolsHRCRESULT
*
* PenWindows recognizer API.
*
* This does NOT include a null symbol at the end.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetSymbolsHRCRESULT(HRCRESULT hrcresult, UINT iSyv, SYV *pSyv, UINT cSyv)
{
	if (!cSyv || !hrcresult || !pSyv)
		return 0;

	return RCRESULTSymbols((XRCRESULT *)hrcresult, iSyv, pSyv, cSyv);
}

/******************************Public*Routine******************************\
* SymbolToCharacter
*
* PenWindows recognizer API.
*
* This stops after converting a null symbol to the null character.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL WINAPI SymbolToCharacter(SYV *pSyv, int cSyv, char *sz, int *pConv)
{
	if (!pSyv || !sz)
	{
		return HRCR_ERROR;
	}

	return SymbolToANSI((unsigned char *)sz, pSyv, cSyv, pConv);
}

/******************************Public*Routine******************************\
* SymbolToCharacterW
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL WINAPI SymbolToCharacterW(SYV *pSyv, int cSyv, WCHAR *wsz, int *pConv)
{
	if (!pSyv || !wsz)
	{
		return HRCR_ERROR;
	}

	return SymbolToUnicode(wsz, pSyv, cSyv, pConv);
}

/******************************Public*Routine******************************\
* GetCostHRCRESULT
*
* PenWindows recognizer API (penwin32.h).
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetCostHRCRESULT(HRCRESULT hrcresult)
{
	if (!hrcresult)
	{
		return HRCR_ERROR;
	}

	return ((XRCRESULT *)hrcresult)->cost;
}

/******************************Public*Routine******************************\
* DestroyHRCRESULT
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI DestroyHRCRESULT(HRCRESULT hrcresult)
{
	return HRCR_OK;
}

/******************************Public*Routine******************************\
* CreateInksetHRCRESULT
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
HINKSET WINAPI CreateInksetHRCRESULT(HRCRESULT hrcresult, unsigned int iSyv, unsigned int cSyv)
{
	XRC *pxrc;
	XRCRESULT *pres = (XRCRESULT *)hrcresult;

	if (!pres)
		return NULL;
	
	pxrc = (XRC *)pres->pXRC;
	if (!pxrc)
		return NULL;

	if ((pxrc->answer.aAlt <= pres) && (pres < (pxrc->answer.aAlt + pxrc->answer.cAlt)))
		return (HINKSET)mkInkSetPhrase(pxrc->pGlyph, pres, iSyv, cSyv);
	else
	{
		if ((iSyv == 0) && (cSyv == strlen(pres->szWord)))
		{
			XRCRESULT *p = pxrc->answer.aAlt;
			int c = pxrc->answer.cAlt;

			for (; c; c--, p++)
			{
				WORDMAP *pM = findResultInWORDMAP(p, pres);
				if (pM)
					return (HINKSET)mkInkSetWORDMAP(pxrc->pGlyph, pM);
			}
		}
		return NULL;
	}
}

/******************************Public*Routine******************************\
* DestroyInkset
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL WINAPI DestroyInkset(HINKSET hInkset)
{
	free((XINKSET *)hInkset);
	return 1;
}

/******************************Public*Routine******************************\
* GetInksetInterval
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetInksetInterval(HINKSET hInkset, unsigned int uIndex, INTERVAL *pI)
{
	XINKSET *pInk = (XINKSET *)hInkset;

	if (!pInk || !pI)
		return ISR_ERROR;

	if (5460 < pInk->count)
		return ISR_BADINKSET;

	if (uIndex == IX_END)
	{
		if (!(pInk->count))
			return ISR_BADINDEX;
		*pI = pInk->interval[pInk->count - 1];
	}
	else
	{
		if (pInk->count <= uIndex)
			return ISR_BADINDEX;
		*pI = pInk->interval[uIndex];
	}

	return pInk->count;
}

/******************************Public*Routine******************************\
* GetInksetIntervalCount
*
* PenWindows recognizer API.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI GetInksetIntervalCount(HINKSET hInkset)
{
	XINKSET *pInk = (XINKSET *)hInkset;

	if (!pInk)
		return ISR_ERROR;

	if ( 5460 < pInk->count )
		return ISR_BADINKSET;

	return pInk->count;
}

/******************************Public*Routine******************************\
* IsStringSupportedHRC
*
* PenWindows recognizer API (penwin32.h).
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
*  11-May-2001 -by- Angshuman Guha aguha
* Pass prefix and suffix on to IsStringSupportedLM.
\**************************************************************************/
BOOL WINAPI IsStringSupportedHRC(HRC hrc, unsigned char *sz)
{
	LMINFO		lminfo;
	XRC *pxrc;

	pxrc = (XRC *) hrc;
	if (!pxrc || !sz)
		return FALSE;

	InitializeLMINFO(&lminfo, LMINFO_FIRSTCAP|LMINFO_ALLCAPS, pxrc->hwl, pxrc->pvFactoid);

	return IsStringSupportedLM(!(pxrc->flags & RECOFLAG_WORDMODE), &lminfo, pxrc->szPrefix, pxrc->szSuffix, sz);

	/*
	if (!(pxrc->flags & RECOFLAG_WORDMODE))
	{
		for (;;)
		{
			char *s = strchr(sz, ' ');
			if (!s)
				break;

			*s = '\0';

			if (!IsStringSupportedLM(&lminfo, pxrc->szPrefix, pxrc->szSuffix, sz))
			{
				*s = ' ';
				return 0;
			}
			*s = ' ';
			sz = s + 1;
		}
	}

	// lack of "else" here is intentional
	return IsStringSupportedLM(&lminfo, pxrc->szPrefix, pxrc->szSuffix, sz);
	*/
}

/******************************Public*Routine******************************\
* SetRecogSpeedHRC
*
* PenWindows recognizer API (penwin32.h).
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI SetRecogSpeedHRC(HRC hrc, int iSpeed)
{
	XRC *pxrc = (XRC *) hrc;
	int	iRet;

	if (!pxrc)
		return -1;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return -1;

	iSpeed = min(iSpeed, HWX_MAX_SPEED);
	iSpeed = max(iSpeed, HWX_MIN_SPEED);

	iRet = pxrc->iSpeed;
	pxrc->iSpeed = iSpeed;
	return iRet;
}

/******************************Public*Routine******************************\
* GetBaselineHRCRESULT
*
* New API.
*
* History:
*  11-May-2000 -by- Angshuman Guha aguha
* Wrote it.
*  20-Mar-2002 -by- Angshuman Guha aguha
* Modified to use the cached baseline info instead of computing it on the fly.
\**************************************************************************/
int WINAPI GetBaselineHRCRESULT(HRCRESULT hrcresult, RECT *pRect, BOOL *pbBaselineValid, BOOL *pbMidlineValid)
{
#if defined(BEAR_RECOG) 
	return HRCR_ERROR;
#else
	XRCRESULT *pxrcresult = (XRCRESULT *) hrcresult;
	XRC *pxrc;
	LATINLAYOUT ll;
	WORDMAP *pMap = NULL;
	int iAlt;
	RECT rect;
	GLYPH *pGlyph;

	if (!pxrcresult || !pRect || !pbBaselineValid || !pbMidlineValid)
		return HRCR_ERROR;

	pxrc = (XRC *)pxrcresult->pXRC;
	if (!pxrc)
		return HRCR_ERROR;

	if ((pxrc->answer.aAlt <= pxrcresult) && (pxrcresult < (pxrc->answer.aAlt + pxrc->answer.cAlt)))
	{
		if (pxrc->flags & RECOFLAG_WORDMODE)
		{
			int iAlt1 = pxrcresult - pxrc->answer.aAlt;
			ll = pxrc->answer.all[iAlt1];
		}
		else
			return HRCR_ERROR;
	}
	else
	{
		XRCRESULT *pPhrase = pxrc->answer.aAlt;
		int c = pxrc->answer.cAlt;

		for (; c; c--, pPhrase++)
		{
			pMap = findResultAndIndexInWORDMAP(pPhrase, pxrcresult, &iAlt);
			if (pMap)
				break;
		}
		if (!pMap)
			return HRCR_ERROR;
		ll = pMap->alt.all[iAlt];
	}

	pGlyph = pMap ? GlyphFromWordMap(pxrc->pGlyph, pMap) : pxrc->pGlyph;
	GetRectGLYPH(pGlyph, &rect);
	if (pMap)
		DestroyGLYPH(pGlyph);

	*pRect = rect;
	pRect->bottom = LatinLayoutToAbsolute(ll.iBaseLine, &rect);
	pRect->top = LatinLayoutToAbsolute(ll.iMidLine, &rect);
	*pbBaselineValid = ll.bBaseLineSet;
	*pbMidlineValid = ll.bMidLineSet;
	return HRCR_OK;
#endif
}

/******************************Public*Routine******************************\
* SetHwxFactoid
*
* New API for factoids.
*
* Return values:
*    HRCR_OK          success
*    HRCR_ERROR       failure
*    HRCR_CONFLICT    ProcessHRC has already been called, cannot call me now
*    HRCR_UNSUPPORTED don't support this factoid string
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
*  06-Dec-2001 -by- Angshuman Guha aguha
* Changed return value from BOOL to int.
\**************************************************************************/
int WINAPI SetHwxFactoid(HRC hrc, WCHAR* pwcFactoid)
{
	XRC *pxrc = (XRC *) hrc;
	DWORD aFactoidID[3];
	int cFactoid, iFactoid;
	void *pv;

	if (!pxrc)
		return HRCR_ERROR;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return HRCR_CONFLICT;

	// the default case
	if (!pwcFactoid)
	{
		if (pxrc->pvFactoid)
			ExternFree(pxrc->pvFactoid);
		pxrc->pvFactoid = NULL;
		return HRCR_OK;
	}

	// parse a string
	// for V1 we are only supporting "OR"
	cFactoid = ParseFactoidString(pwcFactoid, 3, aFactoidID);
	if (cFactoid <= 0)
		return HRCR_UNSUPPORTED;
	// are the factoids supported?
	for (iFactoid=0; iFactoid<cFactoid; iFactoid++)
	{
		if (!IsSupportedFactoid(aFactoidID[iFactoid]))
			return HRCR_UNSUPPORTED;
	}
	// for V1 we are actually only supporting three specific OR's
	if (cFactoid == 2)
	{
		// web|wordlist or email|wordlist
		DWORD aAllowed1[2] = {FACTOID_WEB, FACTOID_WORDLIST};
		DWORD aAllowed2[2] = {FACTOID_EMAIL, FACTOID_WORDLIST};

		SortFactoidLists(aFactoidID, 2);
		SortFactoidLists(aAllowed1, 2);
		SortFactoidLists(aAllowed2, 2);
		if ((aFactoidID[0] != aAllowed1[0]) || (aFactoidID[1] != aAllowed1[1]))
		{
			if (aFactoidID[0] != aAllowed2[0])
				return HRCR_UNSUPPORTED;
			if (aFactoidID[1] != aAllowed2[1])
				return HRCR_UNSUPPORTED;
		}
	}
	else if (cFactoid == 3)
	{
		// filename|web|wordlist
		DWORD aAllowed3[3] = {FACTOID_WEB, FACTOID_WORDLIST, FACTOID_FILENAME};
		SortFactoidLists(aFactoidID, 3);
		SortFactoidLists(aAllowed3, 3);
		if (aFactoidID[0] != aAllowed3[0])
			return HRCR_UNSUPPORTED;
		if (aFactoidID[1] != aAllowed3[1])
			return HRCR_UNSUPPORTED;
		if (aFactoidID[2] != aAllowed3[2])
			return HRCR_UNSUPPORTED;
	}
	else if (cFactoid > 3)
		return HRCR_UNSUPPORTED;

	// we will now try to "compile" the factoid list
	pv = CompileFactoidList(aFactoidID, cFactoid);
	if (!pv)
		return HRCR_ERROR;
	if (pxrc->pvFactoid)
		ExternFree(pxrc->pvFactoid);
	pxrc->pvFactoid = pv;
	return HRCR_OK;
}

/******************************Public*Routine******************************\
* SetHwxFlags
*
* History:
*  30-Apr-2001 -by- Angshuman Guha aguha
* Wrote it.
*  21-Aug-2001 -by- Angshuman Guha aguha
* Added check for unsupported bits in the flags dword.
\**************************************************************************/
BOOL WINAPI SetHwxFlags(HRC hrc, DWORD flags)
{
	XRC *pxrc = (XRC *) hrc;
	DWORD dwSupportedFlags;

	if (!pxrc)
		return FALSE;

	dwSupportedFlags = RECOFLAG_WORDMODE | RECOFLAG_COERCE | RECOFLAG_SINGLESEG;
#if defined(HWX_INTERNAL) && defined(HWX_MADCOW)
	dwSupportedFlags |= RECOFLAG_NNONLY;
#endif

	if (flags & ~dwSupportedFlags)
		return FALSE;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return FALSE;

	pxrc->flags = flags;
	return TRUE;
}

/******************************Public*Routine******************************\
* SetHwxCorrectionContext
*
* wszPrefix: sub-word character string corresponding to the left context
* wszSuffix: sub-word character string corresponding to the right context
* Forces the RECOFLAG_WORDMODE flag ON.
*
* History:
*  30-Apr-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL WINAPI SetHwxCorrectionContext(HRC hrc, WCHAR *wszPrefix, WCHAR *wszSuffix)
{
	XRC *pxrc = (XRC *) hrc;
	unsigned char *szPrefix = NULL, *szSuffix = NULL;
	WCHAR *wsz;

	if (!pxrc)
		return FALSE;

	// cannot change settings after calling process
	if (pxrc->bProcessCalled)
		return FALSE;

	if (wszPrefix && *wszPrefix)
	{
		// currently we can only use the part after the last whitespace
		while (wsz = wcspbrk(wszPrefix, L" \t\r\n"))
		{
			wszPrefix = wsz+1;
		}
		if (*wszPrefix)
		{
			if (!(szPrefix = UnicodeToCP1252String(wszPrefix)))
				return FALSE;
		}
	}

	if (wszSuffix && *wszSuffix)
	{
		// currently we can only use the part before the first whitespace
		WCHAR wch = 0;
		if (wsz = wcspbrk(wszSuffix, L" \t\r\n"))
		{
			wch = *wsz;
			*wsz = 0;
		}
		if (*wszSuffix)
		{
			if (!(szSuffix = UnicodeToCP1252String(wszSuffix)))
			{
				ExternFree(szPrefix);
				if (wch)
					*wsz = wch;
				return FALSE;
			}
		}
		if (wch)
			*wsz = wch;
	}

	if (pxrc->szPrefix)
	{
		ExternFree(pxrc->szPrefix);
	}
	pxrc->szPrefix = szPrefix;

	if (pxrc->szSuffix)
	{
		ExternFree(pxrc->szSuffix);
	}
	pxrc->szSuffix = szSuffix;
	
	return TRUE;
}

/******************************Public*Routine******************************\
* GetWordConfLevel
*
* 
* 
* 
*
* History 25th May,2001
*  Written by Manish Goyal  mango
* .
\**************************************************************************/



int WINAPI GetWordConfLevel(HRC hrc,UINT iSyv,UINT cSyv)
{
	XRC			*pxrc;
	WORDMAP		*pMap;
	UINT		cChar, iWord = 0;
//	char		asz[256];

	pxrc	=	(XRC *)hrc;
	if (!pxrc)
		return HRCR_ERROR;

	pMap = pxrc->answer.aAlt[0].pMap;

	if (!pMap)
		return HRCR_ERROR;

//	sprintf (asz, "iSyv = %d, cSyv = %d, cWords = %d\n", iSyv, cSyv, pxrc->answer.aAlt[0].cWords);
//	OutputDebugString (asz);

	cChar	=	0;

	while (cChar < iSyv && iWord < pxrc->answer.aAlt[0].cWords)
	{
		if (pMap->alt.cAlt < 1)
			return 0;

		cChar	+=	(strlen (pMap->alt.aAlt[0].szWord) + 1);
		pMap	++;
		iWord	++;

//		sprintf (asz, "cChar = %d, iWord = %d\n", cChar, iWord);
//		OutputDebugString (asz);
	}

	if (iWord >= pxrc->answer.aAlt[0].cWords || cChar != iSyv)
		return 0;

//	sprintf (asz, "iConfidence = %d\n", pMap->alt.iConfidence);
//	OutputDebugString (asz);

	return (pMap->alt.iConfidence);
}





/******************************Private*Routine******************************\
* InfProcessHRC
*
* This is a private version of the Pen Windows API, ProcessHRC.
* This is used internally to recognize small phrases.
*
* History:
*  11-April-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WINAPI InfProcessHRC(HRC hrc, int yDev)
{
	XRC *pxrc = (XRC *) hrc;
	if (!pxrc || !pxrc->pGlyph || CframeGLYPH(pxrc->pGlyph) <= 0)
		return HRCR_ERROR;

	PerformRecognition(pxrc, yDev);

	// PerformRecognition does not return a value;
	pxrc->iProcessRet = HRCR_OK;

	return pxrc->iProcessRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\engine.c ===
#include "common.h"
#include <limits.h>
#include "nfeature.h"
#include "engine.h"
#include "fforward.h"
#include "nnet.h"
#include "linebrk.h"
#include "charmap.h"
#include <lookupTable.h>
#include "langmod.h"
#include <GeoFeats.h>

#ifdef PRODUCELOG
#include <time.h>
#define MAXLOGFILENAME 100
#define LOGFILENAME TEXT("hwx.log")
#endif

#ifdef PRODUCELOG
void WriteToLogFile(TCHAR *str)
{
	static TCHAR szLogFile[MAXLOGFILENAME] = TEXT("");
	FILE *f;

	if (!szLogFile[0])  // first call
	{
		if (GetTempPath(MAXLOGFILENAME, szLogFile) >= MAXLOGFILENAME)
			lstrcpy(szLogFile, TEXT("c:\\"));
		lstrcat(szLogFile, LOGFILENAME);
		f = _tfopen(szLogFile, TEXT("w"));
		if (f)
		{
			time_t aclock;
			aclock = time(NULL);
			_ftprintf(f, TEXT("log started at %s"), _tasctime(localtime(&aclock)));
		}
	}
	else
		f = _tfopen(szLogFile, TEXT("a"));

	if (f)
	{
		_ftprintf(f, TEXT("%s"), str);
		fclose(f);
	}
}
#endif

extern BOOL InitializeOD(HINSTANCE hInst);
extern BOOL InitInferno(HINSTANCE hInst);
extern BOOL loadCharNets();

int InitRecognition(HINSTANCE hInst)
{
	if (!InitializeLM(hInst))
	{
		return FALSE;
	}

	if (!InitializeOD(hInst))
	{
		return FALSE;
	}


	if (!InitInferno(hInst))
	{
		return FALSE;
	}

#ifndef BEAR_RECOG
	if (FALSE == loadCharNets(hInst))
	{
		return FALSE;
	}
#endif

	return TRUE;
}


void CloseRecognition(void)
{
	CloseLM();

#if defined(PRODUCELOG) && defined(DBG)
	{
    TCHAR szDebug[128];    
    wsprintf(szDebug, TEXT("cAlloc = %d  cAllocMem = %d cAllocMaxMem = %d \r\n"), 
		     cAlloc, cAllocMem, cAllocMaxMem);
    OutputDebugString(szDebug);
	WriteToLogFile(szDebug);
	}
#endif
}

void Beam(XRC *pxrc);

extern int AddOutDict(XRC *pxrc);

// The nexzt 2 defines are used to decide if we should use the guide 
// (when available) to update yDev. We only want to use the guide in cases
// where there is only a little data
#define STROKE_COMPLEX_THRESHOLD	15000
#define CSTROKE_MAX_UPDATE_YDEV		3

/**********************************************
* UpdateYDev
*
* Updates the yDev parameter by using the guide if
* available and there are less than 3 simple strokes
*
**********************************************/
int UpdateYDev(XRC *pXrc, int yDev)
{
	int				cFrame;
	GLYPH			*pGlyph = pXrc->pGlyph;
	RECT			rect;

	ASSERT(pGlyph);
	if (!pGlyph)
	{
		return yDev;
	}

	cFrame	=	CframeGLYPH(pGlyph);

	if (pXrc->bGuide &&  cFrame < CSTROKE_MAX_UPDATE_YDEV && cFrame > 0)
	{
		int			i;
		BOOL		bSimpleStrokes = TRUE;

		for (i = 0 ; pGlyph && i < CSTROKE_MAX_UPDATE_YDEV ; ++i, pGlyph = pGlyph->next)
		{
			rect		=	*(RectFRAME (pGlyph->frame));
			rect.right--;
			rect.bottom--;

			if (IsComplexStroke(pGlyph->frame->info.cPnt, pGlyph->frame->rgrawxy, &rect) > STROKE_COMPLEX_THRESHOLD)
			{
				bSimpleStrokes = FALSE;
				break;
			}

		}

		if (TRUE == bSimpleStrokes)
		{
			int		yBase = pXrc->guide.cyBase / 13;
			yBase = ((cFrame - 1) * yDev + yBase) / cFrame;
			yDev = max(yDev, yBase);
		}
	}

	return yDev;
}


extern void FeedForwardDoit(FFINFO *ffinfo, int idx);

void  PerformRecognition(XRC *pxrc, int yDev)
{
	unsigned short	cSegment;
	FFINFO ffinfo;

#ifdef HWX_TIMING
#include <madTime.h>
	extern void setMadTiming(DWORD, int);
	TCHAR aDebugString[256];
	DWORD	iStartTime, iEndTime;

#endif

	if (!pxrc)
		return;

	// already featurized?

	if (pxrc->nfeatureset)
	   return;

	// featurize
#ifdef HWX_TIMING
	iStartTime = GetTickCount();
#endif

	if (TRUE == pxrc->bGuide)
	{
		yDev = UpdateYDev(pxrc, yDev);
	}
	pxrc->nfeatureset = FeaturizeLine(pxrc->pGlyph, yDev);
#ifdef HWX_TIMING
	iEndTime = GetTickCount();

	_stprintf(aDebugString, TEXT("Net Featurize %d\n"), iEndTime - iStartTime); 
	OutputDebugString(aDebugString);
	setMadTiming(iEndTime - iStartTime, MM_FEAT);
#endif

	if (!pxrc->nfeatureset)
	{
		pxrc->answer.cAlt = 0;
		pxrc->answer.aAlt[0].szWord = NULL;
		pxrc->answer.aAlt[0].cost = INT_MAX;
		pxrc->answer.aAlt[0].cWords = 0;
		pxrc->answer.aAlt[0].pMap = NULL;
		return;
	}

	// forward feed
	cSegment = pxrc->nfeatureset->cSegment;
	//pxrc->NeuralOutput = (REAL *) ExternAlloc(cSegment*gcOutputNode*sizeof(REAL));
	pxrc->NeuralOutput = (REAL *) ExternAlloc(cSegment*(gcOutputNode+1)*sizeof(REAL));
	if (!pxrc->NeuralOutput)
		return;


	pxrc->nfeatureset->iPrint = (unsigned short)PrintStyleCost(pxrc->nfeatureset->cPrimaryStroke, cSegment);

	ASSERT(pxrc->nfeatureset->iPrint >= 0);
	ASSERT(pxrc->nfeatureset->iPrint <= 1000);

#ifdef HWX_TIMING
	iStartTime = GetTickCount();
#endif

	//FeedForward(pxrc->nfeatureset, pxrc->NeuralOutput, pxrc->nfeatureset->iPrint);
	ffinfo.nfeatureset=pxrc->nfeatureset;
	ffinfo.NeuralOutput=pxrc->NeuralOutput;
	ffinfo.iSpeed=pxrc->iSpeed;

	FeedForward(&ffinfo);

#ifdef HWX_TIMING
	iEndTime = GetTickCount();

	_stprintf(aDebugString, TEXT("Net Run %d\n"), iEndTime - iStartTime); 
	OutputDebugString(aDebugString);
	setMadTiming(iEndTime - iStartTime, MM_NET);
	iStartTime = GetTickCount();
#endif

	// form words off of the neural output

    Beam(pxrc);
#ifdef HWX_TIMING
	iEndTime = GetTickCount();

	_stprintf(aDebugString, TEXT("Beam Walk %d\n"), iEndTime - iStartTime); 
	OutputDebugString(aDebugString);
	setMadTiming(iEndTime - iStartTime, MM_BEAM);
#endif

	if (bOutdictEnabledXRC(pxrc))
	{
#ifdef HWX_TIMING
		iStartTime = GetTickCount();
#endif

		AddOutDict(pxrc);

#ifdef HWX_TIMING
		iEndTime = GetTickCount();

		_stprintf(aDebugString, TEXT("Out of dict%d\n"), iEndTime - iStartTime); 
		OutputDebugString(aDebugString);
		setMadTiming(iEndTime - iStartTime, MM_OUTDICT);
#endif
	}
	//checkAns(pxrc);

}


int GetMax(REAL *rg, int c)
{
   int max, i;

   max = 0;
   for (i = 1; i < c; i++)
      if (rg[i] > rg[max]) 
         max = i;
   return max;
}

#define NO_CHAR '_'

void MakeNeuralOutput(XRC *pxrc)
{
	REAL rgconf[C_CHAR_ACTIVATIONS];
	int row, c, i, j, k;
	REAL *mat = pxrc->NeuralOutput;
	int cWidth = pxrc->nfeatureset->cSegment;

	if (pxrc->szNeural)
		return;

	pxrc->cNeural = (2*cWidth+1)*NEURALTOPN;
	pxrc->szNeural = (char *) ExternAlloc(pxrc->cNeural*sizeof(char));
	if (!pxrc->szNeural)
	{
		pxrc->cNeural = 0;
		pxrc->szNeural = NULL;
		return;
	}

	memset(pxrc->szNeural, NO_CHAR, pxrc->cNeural);
	for (row=0; row<NEURALTOPN; row++)
	{
		for (i=1; i<2*cWidth+1; i+=2)
			pxrc->szNeural[(2*cWidth+1)*row+i] = ' ';
		pxrc->szNeural[(2*cWidth+1)*(row+1)-1] = '\0';
	}

	for (c = 0; c < cWidth; c++) 
	{
		for (i = 0; i < gcOutputNode; i++)
			rgconf[i] = *mat++;
		// pick TOPN values
		for (i = 0; i < NEURALTOPN; i++) 
		{
			k = GetMax(rgconf, gcOutputNode);
#ifdef FIXEDPOINT
			j = (NEURALTOPN*rgconf[k]+32768)/65536;
#else
			j = (int)(NEURALTOPN*rgconf[k]+0.5f);
#endif
			if (j > NEURALTOPN) 
				j = NEURALTOPN;
			j = NEURALTOPN - j;
			while (j < NEURALTOPN && pxrc->szNeural[j*(2*cWidth+1)+2*c] != NO_CHAR)
				j++;
			if (j >= NEURALTOPN) 
				break;

			pxrc->szNeural[j*(2*cWidth+1)+2*c] = Out2Char(k);
			// MR: Hack to get around font problem in demo
			if (136 == pxrc->szNeural[j*(2*cWidth+1)+2*c])
				pxrc->szNeural[j*(2*cWidth+1)+2*c]='^';

			if (IsOutputBegin(k))
				pxrc->szNeural[j*(2*cWidth+1)+2*c+1] = '*';
			rgconf[k] = (REAL)0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fsa.c ===
// fsa.c  (a generic Finite State Machine routine)
// Angshuman Guha
// aguha
// Nov 16, 2000

// an FSA is a count of states and an array of STATE_DESCRIPTIONs
#include "common.h"
#include "fsa.h"

/******************************Public*Routine******************************\
* GetChildrenGENERIC
*
* Function to generate children from a supplied finite state automaton.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void GetChildrenGENERIC(LMSTATE *pState,
					   LMINFO *pLminfo,
					   REAL *aCharProb,  // array of size 256
					   LMCHILDREN *pLmchildren,
					   const STATE_DESCRIPTION *aStateDesc)
{
	DWORD state = pState->AutomatonState;
	const STATE_TRANSITION *pTrans;
	int cTrans, i;
	LMSTATE newState;

	//ASSERT(state < (DWORD)cState);
	pTrans = aStateDesc[state].pTrans;
	cTrans = aStateDesc[state].cTrans;
	newState = *pState;

	for (i=0; i<cTrans; i++, pTrans++)
	{
		const unsigned char *pch;
		
		pch = pTrans->pch;
		state = pTrans->state;

		//ASSERT(state < (DWORD)cState);

		newState.AutomatonState = state;
		if (aStateDesc[state].cTrans)
			newState.flags |= LMSTATE_HASCHILDREN_MASK;
		else
			newState.flags &= ~LMSTATE_HASCHILDREN_MASK;
		if (aStateDesc[state].bValid)
			newState.flags |= LMSTATE_ISVALIDSTATE_MASK;
		else
			newState.flags &= ~LMSTATE_ISVALIDSTATE_MASK;

		while (*pch)
		{
			unsigned char ch = *pch++;

			if (aCharProb && (aCharProb[ch] < MIN_CHAR_PROB))
				continue;
			if (!AddChildLM(&newState, ch, 0, 0, pLmchildren))
				break;
		}
	}
}

/******************************Public*Routine******************************\
* GetChildrenLiteral
*
* Function to generate exactly one child from a "literal" finite state 
* automaton i.e. a 2-state machine with one transition from state 0 to
* state 1 on a literal, state 1 being the only valid (final) state.
*
* History:
* 19-Jul-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void GetChildrenLiteral(LMSTATE *pState, 
						LMINFO *pLminfo, 
						REAL *aCharProb, 
						LMCHILDREN *pLmchildren, 
						WORD Literal)
{
	LMSTATE newState = *pState;
	unsigned char uch;
	
	newState.AutomatonState = 1;  // don't really care
	newState.flags &= ~LMSTATE_HASCHILDREN_MASK;
	newState.flags |= LMSTATE_ISVALIDSTATE_MASK;

	if (UnicodeToCP1252(Literal, &uch))
	{
		if (aCharProb && (aCharProb[uch] < MIN_CHAR_PROB))
			return;
		AddChildLM(&newState, uch, 0, 0, pLmchildren);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fsa.h ===
// fsa.h
// Angshuman Guha
// aguha
// Jan 8, 2001

#ifndef __INC_FSA_H
#define __INC_FSA_H

#include "langmod.h"

#ifdef __cplusplus
extern "C" {
#endif

/* LEFT FOR A RAINY DAY:
		It may be worthwhile one day to use smaller structs than below.
		For example, STATE_TRANSITION can have a short index to the string table instead of unsigned char *
		And state is probably never going to be more than a short for any factoid.
		STATE_DESCRIPTION can use BYTE bValid, BYTE cTrans and a short index to the transition table instead of pTrans.
*/

typedef struct {
	const unsigned char *pch;
	const DWORD state;
} STATE_TRANSITION;

typedef struct {
	const short bValid;
	const short cTrans;
	const STATE_TRANSITION *pTrans;
} STATE_DESCRIPTION;

void GetChildrenGENERIC(LMSTATE *pState,
					   LMINFO *pLminfo,
					   REAL *aCharProb,  // array of size 256
					   LMCHILDREN *pLmchildren,
					   const STATE_DESCRIPTION *aStateDesc);

void GetChildrenLiteral(LMSTATE *pState, 
						LMINFO *pLminfo, 
						REAL *aCharProb, 
						LMCHILDREN *pLmchildren, 
						WORD Literal);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\hwxapip.c ===
// hwxapip.c

#if defined(HWX_INTERNAL) && defined(HWX_PENWINDOWS) && defined(HWX_PRIVAPI)

#include <limits.h>

#include "common.h"
#include "nfeature.h"
#include "engine.h"
#include "resource.h"
#include "langmod.h"
#include "nnet.h"


# if !defined(BEAR_RECOG)
#include "baseline.h"
#endif

__declspec(dllexport) int WINAPI HwxGetWordResults(HRC hrc, UINT cAlt, char *buffer, UINT buflen)
{
	XRC *pxrc = (XRC *) hrc;
	if (!pxrc)
		return -1;
	return (ALTERNATESString(&(pxrc->answer), buffer, buflen, cAlt));
}

__declspec(dllexport) int WINAPI HwxGetCosts(HRC hrc, UINT cAltMax, int *rgCost)
{
	XRC *pxrc = (XRC *) hrc;
	if (!pxrc)
		return -1;
	return ALTERNATESCosts(&(pxrc->answer), cAltMax, rgCost);
}

__declspec(dllexport) int WINAPI HwxGetNeuralOutput(HRC hrc, void *buffer, UINT buflen)
{
	XRC *pxrc;
	char *szSrc, *szDst;
	int i, j;

	pxrc = (XRC *)hrc;
	if (!pxrc)
		return -1;

	if (!pxrc->nfeatureset)
		return 0;  // in case we are running madcow with ALC_WHITE

	if (!pxrc->szNeural)
	{
		MakeNeuralOutput(pxrc);
		if (!pxrc->szNeural)
			return -1;
	}


	if (buflen == 0)
		return pxrc->cNeural;
	if (buflen < (UINT)pxrc->cNeural)
		return -1;

	szDst = (char *) buffer;
	szSrc = pxrc->szNeural;
	for (i=0; i<NEURALTOPN; i++)
	{
		strcpy(szDst, szSrc);
		j = strlen(szSrc)+1;
		szDst += j;
		szSrc += j;
	}

	return pxrc->cNeural;
}

__declspec(dllexport) int WINAPI HwxGetInputFeatures(HRC hrc, unsigned short *rgFeat, UINT cWidth)
{
	int i, j;
	XRC *pxrc = (XRC *)hrc;
	unsigned short cSegment;
	NFEATURE *nfeature;
	unsigned short *rg;

	if (!pxrc)
		return -1;
	if (!pxrc->nfeatureset)
		return 0;  // in case we are running madcow with ALC_WHITE

	cSegment = pxrc->nfeatureset->cSegment;
	if (cWidth==0)
		return cSegment;

	if (cWidth<cSegment)
		return -1;

	nfeature = pxrc->nfeatureset->head;
	for (i=cSegment; i; i--)
	{
		ASSERT(nfeature);
		rg = nfeature->rgFeat;
		for (j=CNEURALFEATURE; j; j--)
			*rgFeat++ = *rg++;
		nfeature = nfeature->next;
	}
	return cSegment;
}

__declspec(dllexport) int WINAPI HwxSetAnswer(char *sz)
{
	return 0;
}



/******************************Private**Routine******************************\
* GetLatinLayoutHRCRESULT
*
* New API.
*
* History:
* 19-June-2001 -by-Manish Goyal mango
* Original version by AGuha.Mostly a copied version of that API
*  Original Version :11-May-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
_declspec(dllexport) int WINAPI GetLatinLayoutHRCRESULT(HRCRESULT hrcresult, 
														RECT *pInnerRect, BOOL *pbBaselineValid, BOOL *pbMidlineValid,
														RECT *pOuterRect, BOOL *pbDescenderlineValid, BOOL *pbAscenderlineValid)
{
#if defined(BEAR_RECOG) 
	return HRCR_ERROR;
#else
	XRCRESULT *pxrcresult = (XRCRESULT *) hrcresult;
	XRC *pxrc;
	LATINLAYOUT ll;
	WORDMAP *pMap = NULL;
	int iAlt;
	RECT rect;
	GLYPH *pGlyph;

	if (!pxrcresult)
		return HRCR_ERROR;

	pxrc = (XRC *)pxrcresult->pXRC;
	if (!pxrc)
		return HRCR_ERROR;

	if ((pxrc->answer.aAlt <= pxrcresult) && (pxrcresult < (pxrc->answer.aAlt + pxrc->answer.cAlt)))
	{
		if (pxrc->flags & RECOFLAG_WORDMODE)
		{
			int iAlt = pxrcresult - pxrc->answer.aAlt;
			ll = pxrc->answer.all[iAlt];
		}
		else
			return HRCR_ERROR;
	}
	else
	{
		XRCRESULT *pPhrase = pxrc->answer.aAlt;
		int c = pxrc->answer.cAlt;

		for (; c; c--, pPhrase++)
		{
			pMap = findResultAndIndexInWORDMAP(pPhrase, pxrcresult, &iAlt);
			if (pMap)
				break;
		}
		if (!pMap)
			return HRCR_ERROR;
		ll = pMap->alt.all[iAlt];
	}

	pGlyph = pMap ? GlyphFromWordMap(pxrc->pGlyph, pMap) : pxrc->pGlyph;
	GetRectGLYPH(pGlyph, &rect);
	if (pMap)
		DestroyGLYPH(pGlyph);

	if (pInnerRect)
	{
		*pInnerRect = rect;
		pInnerRect->bottom = LatinLayoutToAbsolute(ll.iBaseLine, &rect);
		pInnerRect->top = LatinLayoutToAbsolute(ll.iMidLine, &rect);
	}
	if (pbBaselineValid)
		*pbBaselineValid = ll.bBaseLineSet;
	if (pbMidlineValid)
		*pbMidlineValid = ll.bMidLineSet;
	if (pOuterRect)
	{
		*pOuterRect = rect;
		pOuterRect->bottom = LatinLayoutToAbsolute(ll.iDescenderLine, &rect);
		pOuterRect->top = LatinLayoutToAbsolute(ll.iAscenderLine, &rect);
	}
	if (pbAscenderlineValid)
		*pbAscenderlineValid = ll.bAscenderLineSet;
	if (pbDescenderlineValid)
		*pbDescenderlineValid = ll.bDescenderLineSet;
	return HRCR_OK;
#endif
}




#endif // #if defined(HWX_INTERNAL) && defined(HWX_PENWINDOWS) && defined(HWX_PRIVAPI)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\hyphen.h ===
// hyphen.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_HYPHEN_H
#define __INC_HYPHEN_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescHYPHEN[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\hyphen.c ===
// hyphen.c (hyphen or slash)
// Angshuman Guha
// aguha
// Nov 15, 2000

#include "common.h"
#include "hyphen.h"

// 2 states

static const STATE_TRANSITION State0Trans[1] = { {"-/", 1} };
//static STATE_TRANSITION State1Trans[0];

const STATE_DESCRIPTION aStateDescHYPHEN[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, State0Trans },
	/*  1 */ { 1, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\infernop.h ===
// infernop.h

#ifndef __INC_INFERNOP_H
#define __INC_INFERNOP_H

#ifdef __cplusplus
extern "C" {
#endif

#define NEURALTOPN 10

#define FIXEDPOINT

#ifdef FIXEDPOINT
typedef unsigned short REAL;
#else
typedef float REAL;
#endif

#define MIN_CHAR_PROB 655
#define MIN_CHAR_PROB_COST 1700

#define ZERO_PROB_COST 4091


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\inferno.h ===
#ifndef __INC_INFERNO_H
#define __INC_INFERNO_H

#ifdef __cplusplus
extern "C" {
#endif

int WINAPI InfProcessHRC(HRC hrc, int yDev);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\loadtdnnbin.h ===
/********************************************
*
* loadTDNNbin.h
*
* Load binary versions of the TDNN
*
* March 2001 mrevow
********************************************/
#ifndef H_loadTDNNbin_H
#define H_loadTDNNbin_H

#include <nnet.h>
#define NET_BIN_HEADER "TDNN Bin File V 0.0"
#define NET_BIN_HEADER_SIZE	32

// Structure loaded from binary image of the net 
// Everyting in here is read only, once loaded
typedef struct 
{
	unsigned char			*pszComment;		// COmment stored with weight file
	ROMMABLE  INP_BIAS		*pInBias;			// 'Bias' for inputs
	ROMMABLE  HID_BIAS		*pHidBias;			// Input Biases
	ROMMABLE  OUT_BIAS		*pOutBias;			// Output Bias
	ROMMABLE  INP_HID_WEIGHT *pIn2HidWgt;		//  Input -> hidden weights
	ROMMABLE  HID_OUT_WEIGHT *pHid2Out;			// Hidden -> output weights
	int						cInput;				// Number of units per input time slice
	int						cHidden;			// Number of units per hidden time slice
	int						cOutput;			// Number of units per output time slice
	int						cHidSpan;			// hidden layer span (Number of input layer time slices seen by hidden layer)
	int						cOutSpan;			// Output layer span (Number of hidden layer time slices seen by output layer)
} NET_DESC;

// Encapsulation of entire TDNN
typedef struct tagTDNNnet
{
	int						cWidth;				// Number of time slices in inputs and outputs
	int						cWidthHid;			// Number of time slices hidden layer
	NET_DESC				*pNetDesc;			// Net architecture
} TDNN_NET;

extern NET_DESC  * LoadTDNNFromFp(NET_DESC	*pNet, char * fname);
extern NET_DESC  *LoadTDNNFromResource(HINSTANCE hInst, int iKey, NET_DESC *pNet);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\lookuptable.c ===
/***********************************************************
 * 
 * Function to return costs of
 * Print/Cursive tradeoff
 *
 ***********************************************************/

#include <common.h>
#include <lookupTable.h>
#include <lookupTableDat.ci>

// Return Cost of Being Print
int PrintStyleCost(int cPrimaryStroke, int cSegment)
{
	int		iRet = s_iMaxProb;

	if (cPrimaryStroke > 0)
	{
		int		idx;
		idx = cPrimaryStroke * s_iMaxProb / cSegment ;
		idx = (idx + s_iMaxProb / (2 * s_cPrintTable)) * s_cPrintTable  / s_iMaxProb;
		idx = min(idx, s_cPrintTable);
		iRet = s_PrintTable[idx];
	}

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\langmod.h ===
// langmod.h
// Language Model
// Angshuman Guha, aguha
// Sep 25, 1998
// Last modified: Jan 20, 1999
// Major modificiation Jan 8, 2001

#ifndef __INC_LANGMOD_H
#define __INC_LANGMOD_H

#include "infernop.h"

#ifdef __cplusplus
extern "C" {
#endif

// Non Breaking Space
// NOTE Using NBSP here is not arbitary, charmap.c aliases
// NBSP to a regular space
#define WITHIN_FACTOID_SPACE	(unsigned char)0xa0		

// Result generated from out-of-Dictionary 
// Ensure that this value cannot be confused with regular LM factoid values
#define FACTOID_OUT_OF_DICTIONARY	(0x100)

typedef struct {
	WORD TopLevelState;
	BYTE iAutomaton;
	BYTE flags;
	DWORD AutomatonState;
} LMSTATE;

typedef struct tag_LMSTATENODE {
	LMSTATE lmstate;
	struct tag_LMSTATENODE *next;
} LMSTATENODE;

typedef struct tag_LMSTATELIST {
	LMSTATENODE *head;
	LMSTATENODE *pool;
} LMSTATELIST;

// LMSTATE flags
#define LMSTATE_ISVALIDSTATE_MASK 0x01
#define LMSTATE_HASCHILDREN_MASK  0x02
#define LMSTATE_PREFIX			  0x04
#define LMSTATE_COREDICT		  0x08
#define LMSTATE_SUFFIX			  0x10
#define LMSTATE_PREFIX_VALID	  0x20
#define LMSTATE_DICTLITERAL       0x40
#define LMSTATE_DICTUPCASE        0x80

// the list of low-level machines
typedef struct LowLevelMachine_tag {
	DWORD dwFactoid;
	int bTable;
	void *p;
} LowLevelMachine;
extern const LowLevelMachine gaLowLevelMachine[];

// LMSTATE macros
#define IsSysdictState(state) (gaLowLevelMachine[(state).iAutomaton].dwFactoid == FACTOID_SYSDICT)
#define IsUserdictState(state) (gaLowLevelMachine[(state).iAutomaton].dwFactoid == FACTOID_WORDLIST)
#define IsDictState(state) (IsSysdictState(state) || IsUserdictState(state))

typedef struct {
	DWORD	flags;
	HWL		hwl;
	void	*aStateDesc;
} LMINFO;

// LMINFO flags
#define LMINFO_FIRSTCAP    0x01
#define LMINFO_ALLCAPS     0x02
#define LMINFO_WEAKDICT    0x04

typedef struct {
	LMSTATE lmstate;
	unsigned char ch;
	unsigned char CalligTag;
	unsigned char bUpcasedFirstLetter;
} LMNODE;

typedef struct {
	LMNODE *almnode;
	int cMax;
	int c;
} LMCHILDREN;

// macros for LMCHILDREN
#define NthChar(lmchildren, n) (((lmchildren).almnode)[n].ch)
#define NthState(lmchildren, n) (((lmchildren).almnode)[n].lmstate)
#define NthCalligTag(lmchildren, n) (((lmchildren).almnode)[n].CalligTag)
#define NthBUpcasedFL(lmchildren, n) (((lmchildren).almnode)[n].bUpcasedFirstLetter)

// macros for LMINFO
#define LMINFO_IsFirstcapEnabled(plminfo) ((plminfo)->flags & LMINFO_FIRSTCAP)
#define LMINFO_IsAllcapsEnabled(plminfo) ((plminfo)->flags & LMINFO_ALLCAPS)
#define LMINFO_IsWeakDict(plminfo) ((plminfo)->flags & LMINFO_WEAKDICT)

// prototypes
void *InitializeLM(HINSTANCE hInst);
void CloseLM(void);

void InitializeLMINFO(LMINFO *pLminfo, DWORD flags, HWL hwl, void *aStateDesc);

void InitializeLMSTATELIST(LMSTATELIST *plmstatelist, LMSTATE *pState);
void ExpandLMSTATELIST(LMSTATELIST *plmstatelist, LMINFO *plminfo, unsigned char *sz, BOOL bPanelMode);
void DestroyLMSTATELIST(LMSTATELIST *plmstatelist);
BOOL IsValidLMSTATELIST(LMSTATELIST *plmstatelist, LMINFO *plminfo);

void InitializeLMSTATE(LMSTATE *pState);
BOOL IsValidLMSTATE(LMSTATE *pstate, LMINFO *plminfo, unsigned char *szSuffix);
BOOL HasChildrenLMSTATE(LMSTATE *pState, LMINFO *plminfo);

int GetChildrenLM(LMSTATE *pstate, LMINFO *plminfo, REAL *aCharProb, LMCHILDREN *plmchildren);

void InitializeLMCHILDREN(LMCHILDREN *p);
void DestroyLMCHILDREN(LMCHILDREN *p);

BOOL IsStringSupportedLM(BOOL bPanelmode, LMINFO *plminfo, unsigned char *szPrefix, unsigned char *szSuffix, unsigned char *sz);

BOOL AddChildLM(LMSTATE *plmstate, unsigned char ch, unsigned char CalligTag, unsigned char bUpcasedFirstLetter, LMCHILDREN *pchildren);
BOOL deleteFactoidSpaces(unsigned char *pInStr);
BOOL IsSupportedFactoid(DWORD factoid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\langmod.c ===
// langmod.c
// Language Model
// John Bennett, jbenn
// May 1999
// Major Modification: Jan 8, 2001, Angshuman Guha, aguha


#include "common.h"
#include "sysdict.h"
#include "dict.h"
#include "hyphen.h"
#include "number.h"
#include "lpunc.h"
#include "tpunc.h"
#include "punc.h"
#include "email.h"
#include "web.h"
#include "singlech.h"
#include "shrtlist.h"
#include "bullet.h"
#include "resource.h"
#include "re_api.h"
#include "factoid.h"
#include "filename.h"

#define		MAX_PARSE_STATES		32

#define		IsDigit(wch)	(L'0' <= (wch) && (wch) <= L'9')
#define		IsLower(wch)	(L'a' <= (wch) && (wch) <= L'z')
#define		IsUpper(wch)	(L'A' <= (wch) && (wch) <= L'Z')
#define		IsAlpha(wch)	(IsLower(wch) || IsUpper(wch))

typedef LCID (WINAPI *FNOS0) (void);

static WORD *aStateDescDefault = NULL;  // real initialization is in InitializeLM() called at load time

/******************************Public**************************************\
* Declaration of an array of low-level machines.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
// The following table HAS TO BE SORTED by the dwFactoid field
// because the FactoidToAutomaton function does a binary search.
// There is a sanity check for this in the InitializeLM() function called at load-time.
// The index to this table is the "iAutomaton" value used in an LMSTATE.
// The index 0 is not used because iAutomaton==0 means something special (initial state or no autmaton).
const LowLevelMachine gaLowLevelMachine[40] = {
	{0,						0, NULL},	// the zero value is special for iAutomaton
	{FACTOID_SYSDICT,		0, GetChildrenDICT},
	{FACTOID_WORDLIST,		0, GetChildrenDICT},
	{FACTOID_EMAIL,			1, (void *)aStateDescEMAIL},
	{FACTOID_WEB,			1, (void *)aStateDescWEB},
	{FACTOID_NUMBER,		1, (void *)aStateDescNUMBER},
	{FACTOID_LPUNC,			1, (void *)aStateDescLPUNC},
	{FACTOID_TPUNC,			1, (void *)aStateDescTPUNC},
	{FACTOID_PUNC,			1, (void *)aStateDescPUNC},
	{FACTOID_HYPHEN,		1, (void *)aStateDescHYPHEN},
	{FACTOID_NUMSIMPLE,		1, (void *)aStateDescNUMSIMPLE},
	{FACTOID_NUMNTH,		1, (void *)aStateDescNUMNTH},
	{FACTOID_NUMUNIT,		1, (void *)aStateDescNUMUNIT},
	{FACTOID_NUMNUM,		1, (void *)aStateDescNUMNUM},
	{FACTOID_NUMPERCENT,	1, (void *)aStateDescNUMPERCENT},
	{FACTOID_NUMDATE,		1, (void *)aStateDescNUMDATE},
	{FACTOID_NUMTIME,		1, (void *)aStateDescNUMTIME},
	{FACTOID_NUMCURRENCY,	1, (void *)aStateDescNUMCURRENCY},
	{FACTOID_NUMPHONE,		1, (void *)aStateDescNUMPHONE},
	{FACTOID_NUMMATH,		1, (void *)aStateDescNUMMATH},
	{FACTOID_UPPERCHAR,		1, (void *)aStateDescUPPERCHAR},
	{FACTOID_LOWERCHAR,		1, (void *)aStateDescLOWERCHAR},
	{FACTOID_DIGITCHAR,		1, (void *)aStateDescDIGITCHAR},
	{FACTOID_PUNCCHAR,		1, (void *)aStateDescPUNCCHAR},
	{FACTOID_ONECHAR,		1, (void *)aStateDescONECHAR},
	{FACTOID_ZIP,			1, (void *)aStateDescZIP},
	{FACTOID_CREDITCARD,	1, (void *)aStateDescCREDITCARD},
	{FACTOID_DAYOFMONTH,	1, (void *)aStateDescDAYOFMONTH},
	{FACTOID_MONTHNUM,		1, (void *)aStateDescMONTHNUM},
	{FACTOID_YEAR,			1, (void *)aStateDescYEAR},
	{FACTOID_SECOND,		1, (void *)aStateDescSECOND},
	{FACTOID_MINUTE,		1, (void *)aStateDescMINUTE},
	{FACTOID_HOUR,			1, (void *)aStateDescHOUR},
	{FACTOID_SSN,			1, (void *)aStateDescSSN},
	{FACTOID_DAYOFWEEK,		1, (void *)aStateDescDAYOFWEEK},
	{FACTOID_MONTH,			1, (void *)aStateDescMONTH},
	{FACTOID_GENDER,		1, (void *)aStateDescGENDER},
	{FACTOID_BULLET,		1, (void *)aStateDescBULLET},
	{FACTOID_FILENAME,		1, (void *)aStateDescFILENAME},
	{FACTOID_NONE,			1, NULL}
};

/**************************Private Routine*********************************\
* FactoidToAutomaton
*
* Function to convert from the DWORD factoid to a BYTE automaton#.
* Returns zero on failure (zero is not a valid automaton#).
*
* History:
*  14-Nov-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BYTE FactoidToAutomaton(DWORD dwFactoid)
{
	int lo, hi;

	lo = 1;
	hi = sizeof(gaLowLevelMachine)/sizeof(gaLowLevelMachine[0]) - 1;

	while (lo <= hi)
	{
		int mid = (lo + hi) >> 1;
		int n = (int)dwFactoid - (int)gaLowLevelMachine[mid].dwFactoid;
		if (!n)
			return (BYTE)mid;
		if (n < 0)
			hi = mid-1;
		else
			lo = mid+1;
	}
	return 0;
}

/******************************Public*Routine******************************\
* getLANGSupported
*
* Function to get the Primary and secondary languages supported by the Dll
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote the comment.
\**************************************************************************/
int getLANGSupported(HINSTANCE hInst, LANGID **ppPrimLang, LANGID **ppSecLang)
{
	HGLOBAL		hglb;
	HRSRC		hres;
	int			cRes = -1;;


	hres = FindResource(hInst, (LPCTSTR)MAKELONG(RESID_HWXLANGID, 0), (LPCTSTR)TEXT("HWXLANGID"));
	if (!hres)
	{
		return cRes;
	}
	hglb = LoadResource(hInst, hres);
	if (!hglb)
	{
		return cRes;
	}

	*ppPrimLang = (LANGID *)LockResource(hglb);
	ASSERT(*ppPrimLang);
	if (!*ppPrimLang)
	{
		return cRes;
	}

	if ( (cRes = (int)SizeofResource(hInst, hres)) > 0)
	{
		cRes /= sizeof(**ppPrimLang);
		// Subtract 1 for the primary Language
		cRes--;
		*ppSecLang = (*ppPrimLang) + 1;
	}

	return cRes;
}
/******************************Public*Routine******************************\
* InitializeLM
*
* Function to initialize the Language Model.
*
* History:
*  29-Sep-1998 -by- Angshuman Guha aguha
*  April 2002 mrevow 
*		Locale information: (Hack for V1 shipping)
*		UK recognizer is hard coded to use UK,CAN and AUS dialects

\**************************************************************************/
void *InitializeLM(HINSTANCE hInst)
{
	DWORD			dwLocale = 0;
	HGLOBAL			hglb;
	HRSRC			hres;
	LPBYTE			lpByte;
	int				c;
	LCID			lid;
	LANGID			primLangOs, secLangOS, *pSecLangDll, *pPrimLangDll = 0;
	int				cSecLang;

	// sanity check that the gaLowLevelMachine array is sorted by dwFactoid (first field)
	c = sizeof(gaLowLevelMachine)/sizeof(gaLowLevelMachine[0]);
	while (c-- > 2)
	{
		ASSERT(c > 1);
		if (gaLowLevelMachine[c].dwFactoid <= gaLowLevelMachine[c-1].dwFactoid)
			return NULL;
	}

	// February 2002: Previously we used to do a load libray
	// on kernel32 and do a getProcAdrress because some CE may not support
	// GetThreadLocale - The load library was touted (maybe mistakedly as a security
	// threat so it has been removed - Here is the essence of what used to be done
	//
	//  hDLL = LoadLibrary(TEXT("kernel32.dll"));
	//	FNOS0		pfnGetThreadLocale;    // Function pointer
		// FUTURE HEADACHE: GetProcAddress() for CE requires the function name to be a UNICODE string
		// In the current implmentation, the GetProcAddress() call is going to fail in CE.
	//	pfnGetThreadLocale = (FNOS0)GetProcAddress( hDLL, (LPCSTR)"GetThreadLocale");
	//	if (pfnGetThreadLocale)
	//	{
	//		LCID	lid;
	//		lid = pfnGetThreadLocale();


	// Find the system primary and secondary languages
	// If the system primary language matches that of the recognizer
	// Then check if the secondary language ID matches any supported in the recognizer
	// If there are no secondary lang ID's or the primary lanuage ID don't match
	// then enable all secondary languages


	// Get the primary and secondary languages supported by the DLL
	cSecLang = getLANGSupported(hInst, &pPrimLangDll, &pSecLangDll);
	//lid = GetThreadLocale();							// System locale
	lid = (LCID)GetKeyboardLayout(0) & 0xFFFF;			// Keyboard lang ID
	secLangOS = SUBLANGID(lid);
	primLangOs = PRIMARYLANGID(lid);

	// April 2002 - DCR #18916 - Hack to accomodate having english US and english UK
	// The plan is as follows.
	// The UK english Reco engine will be hardcoded to use the UK, AUS, and CAN dictionaries 
	// 
	// All other languages follow the system locale (but in fact
	// only english has local flags in the wordlist)
	//

	if (   cSecLang > 0 
		&& MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK) == MAKELANGID(*pPrimLangDll, *pSecLangDll))
	{
		// Hard code to UK, CAN and AUS dielects
		dwLocale = 0x0E;
	}
	else if (   cSecLang > 0
			&& primLangOs == *pPrimLangDll
			&& secLangOS > 0  )
	{
		// Only enable dialects if we are the correct language
		// and the locale is one supported
		// NOTE: Currently this will only impact English Recognizers

		int		i;


		for (i = 0 ; i < cSecLang ; ++i)
		{
			if (secLangOS == pSecLangDll[i])
			{
				dwLocale = 1 << (secLangOS-1);
				break;
			}
		}
	}

	hres = FindResource(hInst, (LPCTSTR)MAKELONG(RESID_LANGMOD_TOPLEVEL, 0), (LPCTSTR)TEXT("LANGMOD"));
	if (!hres)
		return NULL;
	hglb = LoadResource(hInst, hres);
	if (!hglb)
		return NULL;
	lpByte = LockResource(hglb);
	aStateDescDefault = (WORD *) lpByte;

	return LoadDictionary(hInst, dwLocale);
}

/******************************Public*Routine******************************\
* CloseLM
*
* Function to close the Language Model.
*
* History:
*  29-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void CloseLM(void)
{
    FreeDictionary();
}

/******************************Public*Routine******************************\
* InitializeLMSTATE
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void InitializeLMSTATE(LMSTATE *pState)
{
	memset(pState, 0, sizeof(LMSTATE));
}

/******************************Public*Routine******************************\
* InitializeLMSTATELIST
*
* Make a list of states consisting of one state.
* If a state is specified, that is the one included in the list.
* Otherwise, the root state is included in the list.
*
* History:
*  10-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void InitializeLMSTATELIST(LMSTATELIST *plmstatelist, LMSTATE *pState)
{
	LMSTATENODE *node;

	ASSERT(plmstatelist);
	node = (LMSTATENODE *) ExternAlloc(sizeof(LMSTATENODE));
	if (node)
	{
		node->next = NULL;
		if (pState)
			node->lmstate = *pState;
		else
			InitializeLMSTATE(&node->lmstate);
	}
	plmstatelist->head = node;
	plmstatelist->pool = NULL;
}

/******************************Public*Routine******************************\
* ExpandLMSTATELIST
*
* Given a list of states and a string, generate a new list of states (in place)
* such that the string can take the language model from one of the states in
* the given list to one of the states in the returned list.
* 
* History:
*  10-May-2001 -by- Angshuman Guha aguha
* Wrote it.
* LEFT FOR A RAINY DAY: handle malloc failures more gracefully
\**************************************************************************/
void ExpandLMSTATELIST(LMSTATELIST *plmstatelist, LMINFO *plminfo, unsigned char *sz, BOOL bPanelMode)
{
	LMCHILDREN lmchildren;

	ASSERT(plmstatelist);

	if (!sz)
		return;

	InitializeLMCHILDREN(&lmchildren);

	while (*sz)
	{
		LMSTATENODE *old, *head = NULL, *pool;
		unsigned char uch = *sz++;
		BOOL		bPanelModeLocal = bPanelMode;		// Used to only extend words once

		old = plmstatelist->head;
		if (!old)
			break;
		pool = plmstatelist->pool;

		while (old)
		{
			int i, c;
			LMSTATE state = old->lmstate;
			LMSTATENODE *tmp;

			tmp = old;
			old = old->next;
			tmp->next = pool;
			pool = tmp;

			// X: InitializeLMCHILDREN(&lmchildren);
			lmchildren.c = 0;  // doing this instead of code marked "X:" to reduce cost of DestroyLMCHILDREN everytime
			c = GetChildrenLM(&state, plminfo, NULL, &lmchildren);
			for (i=0; i<c; i++)
			{
				if (NthChar(lmchildren, i) == uch)
				{
					LMSTATENODE *newNode;
					// get new node
					if (pool)
					{
						newNode = pool;
						pool = pool->next;
					}
					else
					{
						newNode = (LMSTATENODE *) ExternAlloc(sizeof(LMSTATENODE));
						if (!newNode)
						{
							ASSERT(0);
						}
					}
					if (newNode)
					{
						newNode->lmstate = NthState(lmchildren, i);
						newNode->next = head;
						head = newNode;
					}
				}
			}
			// X: DestroyLMCHILDREN(&lmchildren);

			// in panel mode, allow going back to root at a space/valid-state
			// May 2002 - mrevow - Only allow this going back to root once per space to
			// prevent exponential explosions of paths
			if (bPanelModeLocal && (uch == ' ') && IsValidLMSTATE(&state, plminfo, NULL))
			{
				// produce the "root" state
				LMSTATENODE *newNode;
				// get new node
				if (pool)
				{
					newNode = pool;
					pool = pool->next;
				}
				else
				{
					newNode = (LMSTATENODE *) ExternAlloc(sizeof(LMSTATENODE));
					if (!newNode)
					{
						ASSERT(0);
					}
				}
				if (newNode)
				{
					InitializeLMSTATE(&newNode->lmstate);
					newNode->next = head;
					head = newNode;
				}

				// Only need to extend in word mode once
				bPanelModeLocal = FALSE;
			}
		}

		plmstatelist->head = head;
		plmstatelist->pool = pool;

	}
	DestroyLMCHILDREN(&lmchildren);
}

/******************************Private*Routine******************************\
* DestroyLMSTATENODES
*
* Function to destroy a linked list of states.
*
* History:
*  10-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyLMSTATENODES(LMSTATENODE *plmstatenode)
{
	while (plmstatenode)
	{
		LMSTATENODE *tmp = plmstatenode->next;
		ExternFree(plmstatenode);
		plmstatenode = tmp;
	}
}

/******************************Public*Routine******************************\
* DestroyLMSTATELIST
*
* Function to destroy a LMSTATELIST structure.
*
* History:
*  10-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyLMSTATELIST(LMSTATELIST *plmstatelist)
{
	ASSERT(plmstatelist);
	DestroyLMSTATENODES(plmstatelist->head);
	plmstatelist->head = NULL;
	DestroyLMSTATENODES(plmstatelist->pool);
	plmstatelist->pool = NULL;
}

/******************************Public*Routine******************************\
* IsValidLMSTATELIST
*
* Given a list of states, return TRUE if at least one of the states in the
* list is a valid state.  Otherwise, return FALSE.
*
* History:
*  10-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsValidLMSTATELIST(LMSTATELIST *plmstatelist, LMINFO *plminfo)
{
	LMSTATENODE *node;

	ASSERT(plmstatelist);
	node = plmstatelist->head;

	while (node)
	{
		if (IsValidLMSTATE(&node->lmstate, plminfo, NULL))
			return TRUE;
		node = node->next;
	}

	return FALSE;
}

/******************************Public*Routine******************************\
* InitializeLMINFO
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void InitializeLMINFO(LMINFO *pLminfo, DWORD flags, HWL hwl, void *aStateDesc)
{
	pLminfo->flags = flags;
	pLminfo->hwl = hwl;
	pLminfo->aStateDesc = aStateDesc ? aStateDesc : aStateDescDefault;
}

/******************************Private*Routine******************************\
* GetChildrenLowLevel
*
* Function to handle low-level "factoid" machines.  This is only called from 
* the top-level language model function, GetChildrenLM.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void GetChildrenLowLevel(LMSTATE *pState, LMINFO *pLminfo, REAL *aCharProb, LMCHILDREN *pLmchildren)
{
	typedef void (*GetChildrenFunc)(LMSTATE *pState, LMINFO *pLminfo, REAL *aCharProb, LMCHILDREN *pLmchildren);

	//ASSERT(gaLowLevelMachine[pState->iAutomaton].p);
	if (!gaLowLevelMachine[pState->iAutomaton].p)
		return;

	if (gaLowLevelMachine[pState->iAutomaton].bTable)
		GetChildrenGENERIC(pState, pLminfo, aCharProb, pLmchildren, gaLowLevelMachine[pState->iAutomaton].p);
	else
		((GetChildrenFunc)gaLowLevelMachine[pState->iAutomaton].p)(pState, pLminfo, aCharProb, pLmchildren);
}

/******************************Public*Routine******************************\
* GetChildrenLM
*
* Top-level language model function.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int GetChildrenLM(LMSTATE *pState, LMINFO *pLminfo, REAL *aCharProb, LMCHILDREN *pLmchildren)
{
	if (!pState->iAutomaton // if we are the beginning of the top-level machine
		|| (pState->flags & LMSTATE_ISVALIDSTATE_MASK))
	{
		// generate next state in top-level machine
		int iTrans, cTrans;

		cTrans = CountOfTransitionsFACTOID(pLminfo->aStateDesc, pState->TopLevelState);

		for (iTrans=0; iTrans<cTrans; iTrans++)
		{
			LMSTATE newState;
			WORD FactoidID;
			BOOL bLiteral;

			bLiteral = GetTransitionFACTOID(pLminfo->aStateDesc, pState->TopLevelState, iTrans, &FactoidID, &newState.TopLevelState);

			newState.flags = 0;
			newState.AutomatonState = 0;
			if (bLiteral)
			{
				newState.iAutomaton = 0;
				GetChildrenLiteral(&newState, pLminfo, aCharProb, pLmchildren, FactoidID);
			}
			else
			{
				newState.iAutomaton = FactoidToAutomaton(FactoidID);
				ASSERT(newState.iAutomaton);
				ASSERT(gaLowLevelMachine[newState.iAutomaton].dwFactoid == FactoidID);
				if (newState.iAutomaton)
					GetChildrenLowLevel(&newState, pLminfo, aCharProb, pLmchildren);
			}
		}
	}

	// generate next state in low-level automaton
	if (pState->iAutomaton)
		GetChildrenLowLevel(pState, pLminfo, aCharProb, pLmchildren);

	return pLmchildren->c;
}

/******************************Public*Routine******************************\
* HasChildrenLMSTATE
*
* Top-level function to check whether a state has children.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL HasChildrenLMSTATE(LMSTATE *pState, LMINFO *plminfo)
{
	if (pState->flags & LMSTATE_HASCHILDREN_MASK)
		return TRUE;
	if (pState->flags & LMSTATE_ISVALIDSTATE_MASK)
		return CountOfTransitionsFACTOID(plminfo->aStateDesc, pState->TopLevelState) ? TRUE : FALSE;

	// the only way we can be here is if one of the low-level machines had a dead state
	// i.e. a non-valid state with no transitions out
	ASSERT(FALSE);

	return FALSE;
}

/******************************Public*Routine******************************\
* InitializeLMCHILDREN
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void InitializeLMCHILDREN(LMCHILDREN *p)
{
	memset(p, 0, sizeof(LMCHILDREN));
}

/******************************Public*Routine******************************\
* DestroyLMCHILDREN
*
* Note that the LMCHILDREN pointer passed in is NOT free'd.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void DestroyLMCHILDREN(LMCHILDREN *p)
{
	if (p->almnode)
		ExternFree(p->almnode);
	memset(p, 0, sizeof(LMCHILDREN));
}

/******************************Private*Routine******************************\
* AddChildLM
*
* Function to add a child to an LMCHILDREN list.  This is the only legal way
* to add a child to an LMCHIDLREN structure.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL AddChildLM(LMSTATE *pState, 
			    unsigned char ch,
				unsigned char CalligTag,
				unsigned char bUpcasedFirstLetter,
			    LMCHILDREN *pLmchildren)
{
	const int ReallocIncrement = 64;

	if (pLmchildren->c >= pLmchildren->cMax)
	{
		int size = pLmchildren->cMax + ReallocIncrement;
		LMNODE *plmnode = (LMNODE *) ExternRealloc(pLmchildren->almnode, size*sizeof(LMNODE));
		if (!plmnode)
		{
			ASSERT(0);
			return FALSE;
		}
		pLmchildren->almnode = plmnode;
		pLmchildren->cMax = size;
	}

	ASSERT(pLmchildren->c < pLmchildren->cMax);
	pLmchildren->almnode[pLmchildren->c].lmstate = *pState;
	pLmchildren->almnode[pLmchildren->c].ch = ch;
	pLmchildren->almnode[pLmchildren->c].bUpcasedFirstLetter = bUpcasedFirstLetter;
	pLmchildren->almnode[pLmchildren->c++].CalligTag = CalligTag;
	return TRUE;
}

/******************************Public*Routine******************************\
* IsValidLMSTATE
*
* Top-level function to check whether a state is final (valid).
*
* This is in some sense two functions.
* Given a state and a suffix string, you can generate all states that can
* be reached from the initial state through the string and check whether
* any of them is a final state.
* Or given a state, you can check whether it is a valid state.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsValidLMSTATE(LMSTATE *pState, LMINFO *pLminfo, unsigned char *szSuffix)
{
	if (szSuffix)
	{
		BOOL b;
		LMSTATELIST lmstatelist;

		InitializeLMSTATELIST(&lmstatelist, pState);
		ExpandLMSTATELIST(&lmstatelist, pLminfo, szSuffix, FALSE);
		b = IsValidLMSTATELIST(&lmstatelist, pLminfo);
		DestroyLMSTATELIST(&lmstatelist);
		return b;
	}

	if (!(pState->flags & LMSTATE_ISVALIDSTATE_MASK))
		return FALSE;

	return IsValidStateFACTOID(pLminfo->aStateDesc, pState->TopLevelState) ? TRUE : FALSE;
}


/******************************Public*Routine******************************\
* IsStringSupportedLM
*
* Top-level function to determine whether a string is supported by the 
* language model. or not.
*
* History:
*  05-Feb-2001 -by- Angshuman Guha aguha
* Wrote it.
*  11-May-2001 -by- Angshuman Guha aguha
* Added suffix and prefix.
\**************************************************************************/
BOOL IsStringSupportedLM(BOOL bPanelMode, LMINFO *pLminfo, unsigned char *szPrefix, unsigned char *szSuffix, unsigned char *szGiven)
{
	LMSTATELIST lmstatelist;
	BOOL b;
	unsigned char *szTmp, *sz, *szDst, uch;

	ASSERT(szGiven);

	// let's deal with leading spaces first
	while (*szGiven && isspace1252(*szGiven))
		szGiven++;
	if (!*szGiven)
		return FALSE;  // empty string not supported (is this what we want?)

	// let's make a copy of the string
	sz = Externstrdup(szGiven);
	if (!sz)
		return FALSE;

	// deal with trailing spaces
	ASSERT(*sz);
	ASSERT(!isspace1252(*sz));
	szTmp = sz + strlen(sz);
	while (isspace1252(*--szTmp));
	ASSERT(!isspace1252(*szTmp));
	*++szTmp = '\0';

	// deal with multiple consecutive spaces in the middle and convert non-blank white space into blank
	szTmp = sz;
	szDst = sz;
	while (uch = *szTmp++)
	{
		if (isspace1252(uch))
		{
			if (*(szDst-1) != ' ')
				*szDst++ = ' ';
		}
		else
			*szDst++ = uch;
	}
	*szDst = '\0';

	//
	InitializeLMSTATELIST(&lmstatelist, NULL);
	if (szPrefix)
		ExpandLMSTATELIST(&lmstatelist, pLminfo, szPrefix, FALSE);
	ASSERT(sz);
	if (sz)
		ExpandLMSTATELIST(&lmstatelist, pLminfo, sz, bPanelMode);
	if (szSuffix)
		ExpandLMSTATELIST(&lmstatelist, pLminfo, szSuffix, FALSE);
	b = IsValidLMSTATELIST(&lmstatelist, pLminfo);
	DestroyLMSTATELIST(&lmstatelist);

	ExternFree(sz);
	return b;
}

/******************************Public*Routine******************************
* deleteFactoidSpaces
*
* Deletes in place any occurences of WITHIN_FACTOID_SPACE within a string
*
* RETURNS
*  TRUE if Factoid spaces were deleted - FALSE otherwise
* History:
*  Oct 2001 mrevow
**************************************************************************/ 
BOOL deleteFactoidSpaces(unsigned char *pInStr)
{
	unsigned char *pOutStr = pInStr;
	BOOL			bRet = FALSE;

	if (pInStr)
	{
		do
		{
			if (WITHIN_FACTOID_SPACE != *pInStr)
			{
				*pOutStr = *pInStr;
				++pOutStr;
			}
			else
			{
				bRet = TRUE;
			}
		} while ('\0' != *pInStr++);
	}

	return bRet;
}

/******************************Public*Routine******************************\
* IsSupportedFactoid
*
* Whether a factoid is externally supported i.e. exposed.
* This list is a proper subset of the list specified in 
* hwx\factoid\src\factoid.c\gaStringToFactoid[].
*
* History:
* 13-Nov-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsSupportedFactoid(DWORD factoid)
{
	switch(factoid)
	{
	case FACTOID_NUMCURRENCY:
	case FACTOID_NUMDATE:
	case FACTOID_DIGITCHAR:
	case FACTOID_EMAIL:
	case FACTOID_FILENAME:
	case FACTOID_LOWERCHAR:
	case FACTOID_NONE:
	case FACTOID_NUMBER:
	case FACTOID_NUMSIMPLE:
	case FACTOID_ONECHAR:
	case FACTOID_NUMPERCENT:
	case FACTOID_PUNCCHAR:
	case FACTOID_SYSDICT:
	case FACTOID_NUMPHONE:
	case FACTOID_NUMTIME:
	case FACTOID_UPPERCHAR:
	case FACTOID_WEB:
	case FACTOID_WORDLIST:
	case FACTOID_ZIP:
		return TRUE;
	default:
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\lookuptable.h ===
#ifndef H_LOOKUP_TABLES_H
#define H_LOOKUP_TABLES_H

#ifdef __cplusplus
extern "C" {
#endif

int PrintStyleCost(int cPrimaryStroke, int cSegment);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\loadtdnnbin.c ===
/**************************************************************************
 *
 * loadTDNNbin.c
 *
 * Functions to load a bin TDNN file 
 * Format of the Bin file
 *  Header  (NET_BIN_HEADER_SIZE bytes) 
 *  (int)  cLayer   (2 for now)
 *   Layer 0   (Hidden)  
 *   Layer 1   (Output)  
 *   Input Bias
 *
 * The format of Layer information is:
 *
 *  (int) Layer # (0, Hidden 1 Output)
 *  (int) cNode
 *  (int) Height
 *  (int) Width
 *  (int) Scale
 *  (short) BiasWeights
 *  (int)  Sizeof(IncomingWeight)  (e.g. 2 or 1)
 *         Weights  (padded to a 4 byte boundary
 *
 *************************************************************************/
#include <common.h>
#include <stdio.h>
#include <runNet.h>
#include "loadTDNNbin.h"

// Adjust pBuf to ensure it is an integral multiple of size offset from pStart. 
#define SYNC_BUFF_PNT(pStart, pBuf, size, type) {int cRem; ASSERT((BYTE *)pBuf > (BYTE *)pStart); \
						 if ( (cRem = (((BYTE *)pBuf - (BYTE *)pStart)%size)) > 0) 	pBuf = (type)((BYTE *)pBuf + (size - cRem));	}

BYTE *ReadBinHeader(NET_DESC *pNet, BYTE *pBuf)
{
	const char *pHead = NET_BIN_HEADER;
	int			iRestSize;
	BYTE		*pb = pBuf;

	if (!pb)
	{
		return NULL;
	}

	if ( 0!= strncmp(pHead, (char *)pBuf, strlen(pHead)) )
	{
		return NULL;
	}

	pBuf				+= NET_BIN_HEADER_SIZE;
	iRestSize			= *(int *)pBuf;
	pBuf				+= sizeof(iRestSize);

	pNet->pszComment	= pBuf;
	pBuf				+= iRestSize;

	ASSERT( (pb - pBuf) % sizeof(int) == 0);
	return pBuf;
}

BOOL ReadNetBin(BYTE *pBuf, int cBuf, NET_DESC *pNet)
{
	BOOL	bRet = FALSE;
	BYTE	*pb = pBuf, *pMax;
	int		*cLayer, *piDatSize, cFileLoad;

	if (!pb)
	{
		return FALSE;
	}

	pMax = pb + cBuf;

	if (! (pb = ReadBinHeader(pNet, pb)) )
	{
		return FALSE;
	}

	// Number of Inputs
	pNet->cInput = *(int *)pb;
	pb += sizeof(pNet->cInput);

	// Number of Hidden Layers
	cLayer = (int *)pb;
	if (1 != *cLayer)
	{
		return FALSE;
	}
	pb += sizeof(*cLayer);
	
	// Number of Hidden Units
	pNet->cHidden = *(int *)pb;
	pb += sizeof(pNet->cHidden);

	// Number of output units
	pNet->cOutput = *(int *)pb;
	pb += sizeof(pNet->cOutput);

	// Hidden field of view
	pNet->cHidSpan = *(int *)pb;
	pb += sizeof(pNet->cHidSpan);

	// Output field of view
	pNet->cOutSpan = *(int *)pb;
	pb += sizeof(pNet->cOutSpan);


	// Input Bias Values
	piDatSize = (int *)pb;
	pb += sizeof(*piDatSize);
	ASSERT (*piDatSize == sizeof(*pNet->pInBias) && "Warning TDNN Input Bias Data size Mismatch");
	if (*piDatSize != sizeof(*pNet->pInBias))
	{
		return FALSE;
	}

	pNet->pInBias = (INP_BIAS *)pb;
	pb += sizeof(*pNet->pInBias) * pNet->cInput;
	SYNC_BUFF_PNT(pBuf, pb, sizeof(int), BYTE*)
	
	// Hidden Bias Values
	piDatSize = (int *)pb;
	pb += sizeof(*piDatSize);
	ASSERT (*piDatSize == sizeof(*pNet->pHidBias) && "Warning TDNN Hidden Bias Data size Mismatch");
	if (*piDatSize != sizeof(*pNet->pHidBias))
	{
		return FALSE;
	}

	pNet->pHidBias = (HID_BIAS *)pb;
	pb += sizeof(*pNet->pHidBias) * pNet->cHidden * pNet->cHidSpan;
	ASSERT(pb < pMax);
	SYNC_BUFF_PNT(pBuf, pb, sizeof(int), BYTE*)


	// Output Bias Values
	piDatSize = (int *)pb;
	pb += sizeof(*piDatSize);
	ASSERT (*piDatSize == sizeof(*pNet->pOutBias) && "Warning TDNNOutput Bias Data size Mismatch");
	if (*piDatSize != sizeof(*pNet->pOutBias))
	{
		return FALSE;
	}

	pNet->pOutBias = (OUT_BIAS *)pb;
	pb += sizeof(*pNet->pOutBias) * pNet->cOutput;
	ASSERT(pb < pMax);
	SYNC_BUFF_PNT(pBuf, pb, sizeof(int), BYTE*)

	// Input -> Hidden
	piDatSize = (int *)pb;
	pb += sizeof(*piDatSize);
	ASSERT (*piDatSize == sizeof(*pNet->pIn2HidWgt) && "Warning TDNN Input -> Hidden Data size Mismatch");
	if (*piDatSize != sizeof(*pNet->pIn2HidWgt))
	{
		return FALSE;
	}

	pNet->pIn2HidWgt = (INP_HID_WEIGHT *)pb;
	pb += sizeof(*pNet->pIn2HidWgt) * pNet->cHidden * pNet->cInput * pNet->cHidSpan;
	SYNC_BUFF_PNT(pBuf, pb, sizeof(int), BYTE*)

	// Hidden -> Output
	piDatSize = (int *)pb;
	pb += sizeof(*piDatSize);
	ASSERT (*piDatSize == sizeof(*pNet->pHid2Out) && "Warning TDNN Hidden -> Output Data size Mismatch");
	if (*piDatSize != sizeof(*pNet->pHid2Out))
	{
		return FALSE;
	}

	pNet->pHid2Out = (HID_OUT_WEIGHT *)pb;
	pb += sizeof(*pNet->pHid2Out) * pNet->cHidden * pNet->cOutput * pNet->cOutSpan;
	SYNC_BUFF_PNT(pBuf, pb, sizeof(int), BYTE*)


	// Finally read the checkSum which is the size of the dtaa loaded
	cFileLoad = *(int *)pb;
	pb += sizeof(cFileLoad);

	ASSERT(cFileLoad == cBuf);

	return ( (pMax == pb) && (cFileLoad == cBuf) ) ? TRUE : FALSE;
}

NET_DESC  * LoadTDNNFromResource(HINSTANCE hInst, int iKey, NET_DESC *pNet)
{
	void		*pRes = NULL;
	int			iResSize;

	
	pRes = loadNetFromResource(hInst, iKey, &iResSize);

	if ( NULL == pRes || FALSE == ReadNetBin(pRes, iResSize, pNet) )
	{
		return NULL;
	}

	return pNet;
}

#ifdef HWX_INTERNAL
// Convenient debugging function to load a net directly from a file
NET_DESC  * LoadTDNNFromFp(NET_DESC	*pNet, char * fname)
{
	FILE		*fp;
	BYTE		*pBuf = NULL;
	int			iBufSize, iRead;

	if ( (fp = fopen(fname, "rb")) )
	{
		fseek(fp, 0, SEEK_END);
		iBufSize = ftell(fp);
		rewind(fp);
		pBuf = ExternAlloc(iBufSize);
		if (!pBuf)
		{
			return NULL;
		}

		if (   iBufSize != (iRead = (int)fread(pBuf, 1, iBufSize, fp))
			|| FALSE == ReadNetBin(pBuf, iBufSize, pNet) )
		{
			goto fail;
		}

		fclose(fp);
	}
	else
	{
		pNet = NULL;
	}

	return pNet;

fail:
	fclose(fp);
	ExternFree(pBuf);
	return NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\probcost.h ===
// probcost.h
// March 11, 1999
// Angshuman Guha,   aguha

#ifndef __INC_PROBCOST_H
#define __INC_PROBCOST_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef FIXEDPOINT

int PROB_TO_COST(int p);
#define QUOTIENT_TO_COST(x,y) PROB_TO_COST((unsigned short)(65536 * (x) / (y)))

#else

int PROB_TO_COST(float p);
#define QUOTIENT_TO_COST(x,y) PROB_TO_COST(((float) x) / ((float) y))

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\outdict.c ===
/****************************************************************
 * OutDict.c
 *
 * Support for out of dictionary words
 *
 ***************************************************************/
#include <stdlib.h>
#include <common.h>
#include "nfeature.h"
#include <engine.h>
#include "nnet.h"
#include <outDict.h>
#include <charmap.h>
#include <charcost.h>
#include <viterbi.h>
#include <langmod.h>
#include "resource.h"

// #include <viterbi.ci>

static OD_LOGA s_CursLogA = {0};
static OD_LOGA s_PrintLogA = {0};

int loadSparseMat(LPBYTE lpByte, OD_LOGA *pLogA)
{
	pLogA->id = *(UINT *)(lpByte);
	lpByte += sizeof(pLogA->id);

	if (pLogA->id != HEADER_ID)
	{
		return 0;
	}

	pLogA->iSize = *(UINT *)(lpByte);
	lpByte += sizeof(pLogA->iSize);

	pLogA->cDim = *(UINT *)(lpByte);
	lpByte += sizeof(pLogA->cDim);
	ASSERT(pLogA->cDim == C_CHAR_ACTIVATIONS);

	if (  pLogA->cDim != C_CHAR_ACTIVATIONS)
	{
		return 0;
	}

	pLogA->pRowCnt = (unsigned short *)lpByte;
	lpByte += sizeof(*pLogA->pRowCnt) * pLogA->cDim;

	pLogA->pRowOffset = (unsigned short *)lpByte;
	lpByte += sizeof(*pLogA->pRowOffset) * pLogA->cDim;

	pLogA->pData = lpByte;

	return pLogA->iSize;
}

// Lookup entry (i,j) int the transition matrix
LOGA_TYPE lookupLogA(OD_LOGA *pLogA, int i, int j)
{
	LOGA_TYPE			iRet;
	unsigned short		iCnt;
	OD_ROW				odRow;
	LOGA_IDX			*pRowId;
	int					k;


	iRet = OD_DEFAULT_VALUE;

	ASSERT(pLogA);
	ASSERT(pLogA->cDim == C_CHAR_ACTIVATIONS);
	ASSERT((UINT)i < pLogA->cDim);
	ASSERT((UINT)j < pLogA->cDim);

	odRow.pColId = (LOGA_IDX *)(pLogA->pData + pLogA->pRowOffset[i]);
	iCnt = pLogA->pRowCnt[i];

	//Linear search
	if ((UINT)j < pLogA->cDim / 2)
	{
		//Start at the beginning
		pRowId = odRow.pColId;

		for (k = 0 ; k < iCnt ; ++k, ++pRowId)
		{
			if ( *pRowId == j)
			{
				iRet = *((LOGA_TYPE *)(odRow.pColId + iCnt) + k);
				break;
			}
			else if (*pRowId > j)
			{
				// Did no find it
				break;
			}
		}
	}
	else
	{
		// Work backwards from the end
		pRowId = odRow.pColId + iCnt - 1;

		for (k = iCnt-1 ; k >= 0 ; --k, --pRowId)
		{
			if ( *pRowId == j)
			{
				iRet = *((LOGA_TYPE *)(odRow.pColId + iCnt) + k);
				break;
			}
			else if (*pRowId < j)
			{
				// Did no find it
				break;
			}
		}
	}

	return iRet;
}

BOOL InitializeOD(HINSTANCE hInst)
{
	HGLOBAL hglb;
	HRSRC hres;
	LPBYTE lpByte;
	int		iInc;


	hres = FindResource(hInst, (LPCTSTR)MAKELONG(RESID_MAD_OUT_DICT, 0), (LPCTSTR)TEXT("DICT"));

	if (!hres)
	{
		return FALSE;
	}

	hglb = LoadResource(hInst, hres);

	if (!hglb)
	{
		return FALSE;
	}

	lpByte = LockResource(hglb);
	ASSERT(lpByte);
	if (!lpByte)
	{
		return FALSE;
	}
	iInc = loadSparseMat(lpByte, &s_CursLogA);

	if (iInc < sizeof(s_CursLogA))
	{
		memset(&s_CursLogA, 0, sizeof(s_CursLogA));
		return FALSE;
	}

	lpByte += iInc;
	iInc = loadSparseMat(lpByte, &s_PrintLogA);

	if (iInc < sizeof(s_PrintLogA))
	{
		memset(&s_PrintLogA, 0, sizeof(s_PrintLogA));
		return FALSE;
	}

	return TRUE;
}


int AddOutDict(XRC *pxrc)
{
	unsigned char	*pBestString;
	int				iBestCost;
	XRCRESULT		*pResInsert = NULL, *pRes, *pRes1;;


	pBestString = (unsigned char *)ExternAlloc(sizeof(*pBestString) * (2 * pxrc->nfeatureset->cSegment + 1));
	if (!pBestString)
	{
		return -1;
	}

	// assumption:  same number of output nodes in print and cursive
	if (pxrc->nfeatureset->iPrint > 500)
	{
		iBestCost = VbestPath(pxrc, &s_PrintLogA, pBestString, &pResInsert, gcOutputNode);
	}
	else
	{
		iBestCost = VbestPath(pxrc, &s_CursLogA, pBestString, &pResInsert, gcOutputNode);
	}


	// Does the out of dictionary fit in the al list
	if (pResInsert)
	{
		XRCRESULT	pResSave;

		ASSERT(pResInsert - pxrc->answer.aAlt >= 0);
		ASSERT(pResInsert - pxrc->answer.aAlt <= (int)pxrc->answer.cAlt);

		// Either make space for the out of dictionary entry by pushing all entries
		// down or if the alt list is not full just insert it it into the list
		if (pxrc->answer.cAlt < pxrc->answer.cAltMax)
		{
			++pxrc->answer.cAlt;
		}

		pRes1 = pxrc->answer.aAlt + pxrc->answer.cAlt - 1;
		pRes = pRes1 - 1;

		// Free the one pushed off the bottom or do nop if we are just adding to the alt list
		ExternFree(pRes1->szWord);

		// vbestPath updated the last pMap in the alt list for the word
		// So save it now and insert it in its proper place. after all the
		// other alternates have been adjusted
		pResSave = pxrc->answer.aAlt[pxrc->answer.cAltMax-1];

		for (  ; pRes1 > pResInsert ; --pRes, --pRes1)
		{
			pRes1->cost = pRes->cost;
			pRes1->pMap = pRes->pMap;
			pRes1->szWord = pRes->szWord;
			pRes1->cWords = pRes->cWords;
			pRes1->pXRC = pRes->pXRC;
		}

		// Addin the outDict Word
		pResInsert->szWord = pBestString;
		pResInsert->cost = iBestCost;
		pResInsert->iLMcomponent = FACTOID_OUT_OF_DICTIONARY;

		// OK restore the pmap that was built by vbestPath()
		pResInsert->pMap	= pResSave.pMap;
		pResInsert->cWords	= pResSave.cWords;
		pResInsert->pXRC = pxrc;

		return pResInsert - pxrc->answer.aAlt;
	}

	ExternFree(pBestString);
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\outdict.h ===
/*******************************************************
 *
 * outDict.h
 *
 * Defines data structures for out of dictionary
 * search
 *
 ******************************************************/

#ifndef H_OUT_DICT_H
#define H_OUT_DICT_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The transition matrix is a sparse square matrix. We store
 * only the non-default entries in a simple fashion. The header contains
 * offsets to each row in the table. Each row then only keeps
 * the non-default values
 */
#define	HEADER_ID			0xFDFDFD01

// Default type used by the viterbi algorithm
typedef int		VTYPE;

//  Transition matrix type
typedef unsigned short LOGA_TYPE;

// transition matrix index type
typedef unsigned short LOGA_IDX;

// Default value in the sparse represenatation of the transition matrix
#define OD_DEFAULT_VALUE		4096


// Describes a row of the sparse matrix. Keeps a table of which columns
// are present in the row

typedef struct tagOD_ROW
{
	LOGA_IDX		*pColId;			// List of column entries present
	LOGA_TYPE		*pVals;				// Values at each columns position
} OD_ROW;

// Describes the sparse form of the (nxn) transition
// probability matrix

typedef struct tagOD_LOGA
{
	UINT			id;				// Header id string 
	UINT			iSize;			// Total size of the stored matrix
	UINT			cDim;			// Full matrix is cDim x cDim
	unsigned short	*pRowCnt;		// Count at each row
	unsigned short	*pRowOffset;	// Offsets in data to each of the cDim rows
	BYTE			*pData;			// Rows of sparse matrix data. Each row is of type OD_ROW
} OD_LOGA;

#ifdef __cplusplus
}
#endif

#endif // H_OUT_DICT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\viterbi.h ===
#ifndef H_VITERBI_H
#define H_VITERBI_H

#include <nnet.h>

#ifdef __cplusplus
extern "C" {
#endif

// Maximum number of active characters allowed for this ink
#define OD_MAX_ACTIVE_CHAR		60

// Bit set to mark space following a charcter in bestpath
#define	SPACE_MARK		0x100000

void BuildActiveMap(const REAL *pActivation, int cSegments, int cOutput, BYTE rgbActiveChar[C_CHAR_ACTIVATIONS]);

extern int VbestPath(XRC *pXrc, OD_LOGA * pLogA, unsigned char *pBestString,  XRCRESULT **ppResInsert, int cNode);

LOGA_TYPE lookupLogA(OD_LOGA *pLogA, int i, int j);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\probcost.c ===
// probcost.c
// created by extracting code from beam.c
// March 11, 1999
// Angshuman Guha,   aguha

#include "infernop.h"
#include "probcost.h"

#ifdef FIXEDPOINT

static const unsigned short grgProbToCost[101] = { // -256*log(prob) (log uses base 2)
	4000, 1700, 1444, 1295, 1188, 1106, 1039, 982, 932, 889, 850, 815,
	783, 753, 726, 700, 676, 654, 633, 613, 594, 576, 559, 542, 527,
	512, 497, 483, 470, 457, 444, 432, 420, 409, 398, 387, 377, 367,
	357, 347, 338, 329, 320, 311, 303, 294, 286, 278, 271, 263, 256,
	248, 241, 234, 227, 220, 214, 207, 201, 194, 188, 182, 176, 170,
	164, 159, 153, 147, 142, 137, 131, 126, 121, 116, 111, 106, 101,
	96, 91, 87, 82, 77, 73, 68, 64, 60, 55, 51, 47, 43, 38, 34, 30,
	26, 22, 18, 15, 11, 7, 3, 0
};

int PROB_TO_COST(int p)
{
	int b, result = 0;

	if (!p)
		return ZERO_PROB_COST;
	p *= 100;
	b = (int)(p/65536) + 1;
	if (b > 100)
		return 0;
	while (b < 100)
	{
		result += grgProbToCost[b];
		p = 100*p/b;
		b = (int)(p/65536) + 1;
	}
	return result;
}

#else

//  prob-to-cost using the system log() function:
#include <math.h>

// MMM is -256/log(2)
#define MMM ((float)(-369.3299304676))

int PROB_TO_COST(float p)
{
	if (p < 1e-6)
		p = (float)(1e-6);
	return (int)(MMM*(float)log((double)p));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\sysdict.c ===
// dict.c
// Angshuman Guha, aguha
// Sep 17, 1998

#include "common.h"
#include "cestubs.h"
#include "resource.h"
#include "cp1252.h"
#include "sysdict.h"
#include "fsa.h"

#define AddressToState(address) (DWORD)((address) ? (address) - gTrieAddress : ~FLAG_MASK)

static LPTRIECTRL glpTrieCtrl = NULL;
static LPBYTE gTrieAddress = NULL;

// Language dialect got from system when LM is initialized
static DWORD		s_dwLocale = 0;

/******************************Private*Routine******************************\
* LoadDictionary
*
* Function to load the dictionary as a resource and then initializing it.
*
* History:
*  29-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void *LoadDictionary(HINSTANCE hInst, DWORD dwLocale)
{
	HGLOBAL hglb;
	HRSRC hres;
	LPBYTE lpByte;

	s_dwLocale = dwLocale;

	hres = FindResource(hInst, (LPCTSTR)MAKELONG(RESID_MAD_DICT, 0), (LPCTSTR)TEXT("DICT"));
	if (!hres)
	{
		return NULL;
	}

	hglb = LoadResource(hInst, hres);
	if (!hglb)
		return NULL;
	lpByte = LockResource(hglb);

    glpTrieCtrl = TrieInit(lpByte);

	if (NULL != glpTrieCtrl)
	{
		gTrieAddress = glpTrieCtrl->lpbTrie;
	}

    return (void *)glpTrieCtrl;
}

/******************************Private*Routine******************************\
* FreeDictionary
*
* Function to unload the dictionary.
*
* History:
*  29-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
void FreeDictionary(void)
{
	TrieFree(glpTrieCtrl);
}


/******************************Private*Routine******************************\
* Word2TRIESCAN
*
* Look up a word as passed in and fill the terminal node TRIESCAN struct.
*  11-Mar-1999 -by- Jay Pittman jpittman
* Arg pWord points to a CodePage 1252 string, and is translated to Unicode
* before comparison.
\***************************************************************************/
BOOL Word2Tag(unsigned char *pWord, DWORD *pTag)
{
	TRIESCAN	triescan;

	// Try to find word.
	memset(&triescan, 0, sizeof(TRIESCAN));
	while (*pWord)
	{
		WCHAR wch;

		if (!CP1252ToUnicode(*pWord, &wch))
			return FALSE;

		// Go to next level in trie.
		if (!TrieGetNextState(glpTrieCtrl, &triescan))
			return FALSE;

		// See if we found the correct character.

		while (wch != triescan.wch)
		{
			if (!TrieGetNextNode(glpTrieCtrl, &triescan))
				return FALSE;
		}

		// Ready for next letter.
		++pWord;
	}

	// If we got here, we match all the characters, is this a valid end of word?
	if (   (triescan.wFlags & TRIE_NODE_VALID)
		&& (triescan.wFlags & TRIE_NODE_TAGGED)
		&& (triescan.wMask & TRIE_UNIGRAM_MASK))
	{
		// We found the word, save tag value
		*pTag	= triescan.aTags[TRIE_UNIGRAM_TAG].dwData;

		return TRUE;
	} else {
		return FALSE;
	}
}

/******************************Public*Routine******************************\
* TrieFindWord
*
* Finds a word in the trie and fills up the correspoding triescan struct only if the word is a valid one
* Other wise return FALSE.
*  17-Apr-2000 -by- Ahmad abdulKader ahmadab
\**************************************************************************/

BOOL TrieFindWord (unsigned char *pWord, TRIESCAN *pTrieScan)
{
	// Try to find word.
	memset(pTrieScan, 0, sizeof(TRIESCAN));

	while (*pWord)
	{
		WCHAR wch;

		if (!CP1252ToUnicode(*pWord, &wch))
			return FALSE;

		// Go to next level in trie.
		if (!TrieGetNextState(glpTrieCtrl, pTrieScan))
			return FALSE;

		// See if we found the correct character.
		while (wch != pTrieScan->wch)
		{
			if (!TrieGetNextNode(glpTrieCtrl, pTrieScan))
				return FALSE;
		}

		// Ready for next letter.
		++pWord;
	}

	return TRUE;
}

#define CALLIGTAG(scan) ((unsigned char)(scan.aTags[0].dwData >> 16))

void GetChildrenSYSDICT(LMSTATE *pState,
					    LMINFO *pLminfo,
					    REAL *aCharProb,  
					    LMCHILDREN *pLmchildren)
{
	WORD wFlags;
	TRIESCAN triescan;
	WCHAR wch;
	DWORD state = pState->AutomatonState;
	BOOL bRoot = (state == 0);
	unsigned char uch;
	LMSTATE newState;

	memset(&triescan, 0, sizeof(TRIESCAN));
	if (!bRoot)
	{
		wFlags = StateToFlags(state);
		if (wFlags & TRIE_NODE_DOWN)
		{
			triescan.wFlags = wFlags;
			triescan.lpbDown = StateToAddress(state);
			triescan.lpbNode = triescan.lpbDown;
			triescan.lpbSRDown = 0;
		}
		else
			return;
	}

	if (TrieGetNextState(glpTrieCtrl, &triescan))
	{
		state = AddressToState(triescan.lpbDown) | FlagsToState(triescan.wFlags);
		wch = triescan.wch;
	}
	else
		wch = 0;

	newState = *pState;
	while (wch)
	{
		newState.AutomatonState = state;
		if (triescan.wFlags & TRIE_NODE_DOWN)
			newState.flags |= LMSTATE_HASCHILDREN_MASK;
		else
			newState.flags &= ~LMSTATE_HASCHILDREN_MASK;

		if ((triescan.wFlags & TRIE_NODE_VALID)
			&& !(s_dwLocale
				 && (triescan.wFlags & TRIE_NODE_TAGGED)
				 && (triescan.wMask & TRIE_DIALECT_MASK)
				 && !(triescan.aTags[TRIE_DIALECT_TAG].dwData & s_dwLocale)))
			newState.flags |= LMSTATE_ISVALIDSTATE_MASK;
		else
			newState.flags &= ~LMSTATE_ISVALIDSTATE_MASK;

		if (UnicodeToCP1252(wch, &uch) && !(LMINFO_IsWeakDict(pLminfo) && aCharProb && (aCharProb[uch] < MIN_CHAR_PROB)))
		{
			unsigned char CalligTag;

			if ((triescan.wFlags & TRIE_NODE_VALID) && (triescan.wFlags & TRIE_NODE_TAGGED))
				CalligTag = CALLIGTAG(triescan);
			else
				CalligTag = 0;
			if (!AddChildLM(&newState, uch, CalligTag, 0, pLmchildren))
				break;
		}

		// next sibling
		if (TrieGetNextNode(glpTrieCtrl, &triescan))
		{
			state = AddressToState(triescan.lpbDown) | FlagsToState(triescan.wFlags);
			wch = triescan.wch;
		}
		else
			wch = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\viterbi.c ===
/******************************************
 * Viterbi.c
 *
 * Do a best path viterbi search
 *
 ******************************************/
#include <common.h>
#include <limits.h>
#include "nfeature.h"
#include <engine.h>
#include "nnet.h"
#include <beam.h>
#include <infernop.h>
#include "charmap.h"
#include <charcost.h>
#include <probcost.h>
#include <lookupTable.h>
#include <outDict.h>
#include <viterbi.h>


// Choose a value to ensure will not pick a path to srt with this value
static VTYPE	s_InvalidStartValid = OD_DEFAULT_VALUE * 3;

/*********************************
* Vforward
*
* Standard forward phase of viterbi algorithm.
* Use standard notation of Rabiner et. al.
* To conserve memory dont allocate an alpha array of full
* size (T * cState. Only need 2 arrays of size 2 cState
* and swap between these 2 alpha_t and alphat1
*
***************************************/
static BOOL Vforward(
int			T,				// Number of time slices
REAL		*pB,			// Output distributions 
int			cB,				// Size of Output Distr at each time Slice
int			*pActive,		// List of active Characters
int			cState,			// Number of active characters (states)
LOGA_TYPE	*pLogA,			// Transition Probabilities
VTYPE		*alpha,			// P(O_1, O_2.. O_t | S_i = i)
int			*pSi			// Psi array for backtracking (T * cStat)
)
{
	BOOL		bRet = FALSE;
	int			t, i, j;
	VTYPE		*alpha_t;						// Max(Prob|states) at time t
	VTYPE		*alpha_t1, *pAlphTmp;			// Max(Prob|states) at t+1
	int			*pAct;

	ASSERT(cState <= cB);

	alpha_t = alpha;
	pAlphTmp = alpha_t1 = (VTYPE *)ExternAlloc(cState * sizeof(*alpha_t1));
	pAct = (int *)ExternAlloc(sizeof(*pAct) * C_CHAR_ACTIVATIONS);

	ASSERT(pAct);
	ASSERT(alpha_t1);
	if (!alpha_t1 || !pAct)
	{
		goto fail;
	}

	// Initialize recursion
	t = 0;
	InitColumn(pAct, pB);

	for (i = 0 ; i < cState ; ++i)
	{
		if (IsOutputBeginAct(pActive[i]))
		{
			alpha_t[i] = pAct[pActive[i]];
		}
		else
		{
			alpha_t[i] = s_InvalidStartValid;
		}

	}

	// Recurse over all time steps
	for (t = 1 ; t < T ; ++t)
	{
		LOGA_TYPE		*pLa = pLogA;
		VTYPE			*pAlphSav;
		
		pB += cB;
		InitColumn(pAct, pB);

		for (j = 0 ; j < cState ; ++j, ++pLa, ++pSi)
		{
			VTYPE		minA;
			
			minA = *alpha_t + *pLa;

			*pSi = 0;

			for (i = 1 ; i < cState ; ++i)
			{
				VTYPE		tmp;
				
				++pLa;
				tmp = alpha_t[i] + *pLa;
			
				if ( tmp < minA)
				{
					minA = tmp;
					*pSi = i;
				}
			}

			alpha_t1[j] = minA + pAct[pActive[j]];
		}

		// Exhchange the alpha arrays so effectively overwrite 
		// alpha_t-2 on next iteration
		pAlphSav = alpha_t;
		alpha_t = alpha_t1;
		alpha_t1 = pAlphSav;
	}

	// Make sure that the last time step is in alpha. It may
	// be already there depending if there are an even or odd number
	// of time steps
	if (alpha_t != alpha)
	{
		for (i = 0 ; i < cState ; ++i)
		{
			alpha[i] = alpha_t[i];
		}
	}

	bRet = TRUE;

fail:
	ExternFree(pAlphTmp);
	ExternFree(pAct);

	return bRet;
}

static VTYPE Vbackward(
int			T,				// Number of time slices
int			cState,			// Number of characters (states)
VTYPE		*alpha,			// P(O_1, O_2.. O_t | S_i = i)
int			*pPsi,			// Psi array for backtracking (T * cStat)
int			*bestPath		// OUT: the best path (t=0.. T-1)
)
{
	int			i, t = T - 1;
	VTYPE		minP;
	int			*pPsiT;

	ASSERT(alpha);
	minP = *alpha;

	bestPath[t] = 0;

	for (i = 1, ++alpha ; i < cState ; ++i, ++alpha)
	{
		if (*alpha < minP)
		{
			minP = *alpha;
			bestPath[t] = i;
		}
	}

	pPsiT = pPsi + (t-1) * cState;

	for(  ; t > 0 ; --t, pPsiT -= cState)
	{
		bestPath[t-1] = pPsiT[bestPath[t]];
	}

	return minP;
}

/***************************************************************
* Build a list of the active charatcers from the active map
* Also build a 'compressed' (transposed) transition prob matrix
* having only those active characters. We use the transpose
* matrix (a_ji) because this is the order we access it during the
* forward pass
*
* NOTE:
*  This routines 2 arrays that the caller MUST free
*****************************************************************/
static int VbuildActiveFromMap(
BYTE		*pActiveMap,	// Boolean map of which characters are active
int			cTotChar,		// Total Number of characters
OD_LOGA		*pFullLogA,		// IN; Full transition matrix
int			**ppActive,		// OUT: list of active characters (Caller must free)
LOGA_TYPE	**ppLogA		// OUT: compressed transition probs (caller must free)
)
{
	int			i, j, cActive = 0;
	BYTE		*pMap;
	int			*pActive;
	LOGA_TYPE	*pLogA;

	pMap = pActiveMap;

	for (i = 0 ; i < cTotChar ; ++i, ++pMap)
	{
		if (*pMap)
		{
			++cActive;
		}
	}

	pActive = *ppActive		= (int *)ExternAlloc(sizeof(**ppActive) * cActive);
	pLogA	= *ppLogA		= (LOGA_TYPE *)ExternAlloc(sizeof(**ppLogA) * cActive * cActive);

	if (!*ppActive || !*ppLogA)
	{
		return -1;
	}

	pMap = pActiveMap;

	for (i = 0 ; i < cTotChar ; ++i, ++pMap)
	{
		if (*pMap)
		{
			*pActive++ = i;
		}
	}

	pActive = *ppActive;

	for (i = 0 ; i < cActive ; ++i, ++pActive)
	{
		int		*pActj = *ppActive;

		for (j = 0 ; j < cActive ; ++j, ++pLogA, ++pActj)
		{
			// Insert the transpose of the transition matrix
			// Makes access during the forward pass easier
			//*pLogA = pFullLogA[*pActive + *pActj * cTotChar];
			*pLogA = lookupLogA(pFullLogA, *pActj, *pActive);
		}
	}

	return cActive;
}
/***************************************************************
 * VxlatePath
 *
 * Translate a best path to get a best sequence of symbols. ie remove
 * repeated charatcters and do the translation from indices to charchters
 *
 * The bestString will have at most 2T symbols
 * Spaces are inserted when the space cost is less than within
 * word space. The location of space breaks are marked in the bestPath
 * by negative values
 * 
 * Returns additional cost from potential space break
 **************************************************************/
static int VxlatePath(
int				T,				// Number of time slices
int				*pActive,		// Table for looking up active characters
int				*pBestPath,		// Best Path for Translatiion
unsigned char	*pBestString,	// OUT: Returned best String
int				cState,			// Number of active states
REAL			*pB,			// Output distributions
int				cB,				// Total out states
OD_LOGA			*pLogAFull		// Full Transition matrix
)
{
	int				i, iChar, iLastChar;
	int				iSpaceCost;
	int				iNotSpaceCost;
	int				iRet = 0;
	REAL			SpaceProb;

	ASSERT(*pBestPath >= 0);
	*pBestString = Out2CharAct(pActive[*pBestPath]);
	iChar = pActive[*pBestPath];
	pBestPath++;

	//pB += cB;
	for (i = 1 ; i < T ; ++i, ++pBestPath, pB += cB)
	{

		ASSERT(*pBestPath >= 0);
		ASSERT(*pBestPath  < cState);

		iLastChar = iChar;
		iChar = pActive[*pBestPath];

		// Check if space is possible
		SpaceProb = pB[BeginChar2Out(' ')];
		if (SpaceProb > 0 && IsOutputBegin(iChar))
		{
			// look up neural net output
			iSpaceCost = PROB_TO_COST(SpaceProb);
#ifdef FIXEDPOINT
			iNotSpaceCost = PROB_TO_COST(65535 - SpaceProb);
#else
			iNotSpaceCost = PROB_TO_COST((float)1 - SpaceProb);
#endif
			// scale costs
			iNotSpaceCost = NOT_SPACE_NUM * iNotSpaceCost / NOT_SPACE_DEN;
			iSpaceCost = IS_SPACE_NUM * iSpaceCost / IS_SPACE_DEN;

			if (iSpaceCost + lookupLogA(pLogAFull, BeginChar2OutAct(' '), iChar) < iNotSpaceCost + lookupLogA(pLogAFull, iLastChar, iChar))
			{
				++pBestString;
				*pBestString = ' ';

				*pBestPath |= SPACE_MARK;		// Mark that a space occurs here

				iRet += iSpaceCost;
			}
			else
			{
				iRet += iNotSpaceCost;
			}

		}

		if (IsOutputBeginAct(iChar))
		{
			++pBestString;
			*pBestString = Out2CharAct(iChar);
		}
	}

	++pBestString;
	*pBestString = '\0';

	return iRet;
}

static BOOL updateXRCRESULT(
int				T,				// Number of time slices
int				*pActive,		// Table for looking up active characters
int				*pBestPath,		// Best Path for Translatiion
XRCRESULT		*pRes,			// What to update
unsigned char	*pBestString	// Returned best String
)
{
	int				t, tEnd, cChar = 0;
	UINT			cWord = 0;
	int				cMaxStroke, cStrokeGlyph;
	WORDMAP			*pMap;

	// Count number of words seperated by spaces
	for (t = 0 ; t < T ; ++t, ++pBestPath)
	{
		int				iChar;

		iChar = *pBestPath;
		if (iChar & SPACE_MARK)
		{
			++cWord;
			iChar &= ~SPACE_MARK;
			++cChar;
		}

		if (IsOutputBeginAct(pActive[iChar]))
		{
			++cChar;
		}
	}

	// Add in the first word if any
	cWord += (cChar > 0);

	ASSERT(cChar == (int)strlen((const char *)pBestString));
	ASSERT(pRes->pXRC);
	cStrokeGlyph = CframeGLYPH( ((XRC *)pRes->pXRC)->pGlyph);
	cMaxStroke = cWord * cStrokeGlyph;		// Handles a new NNet featurization that allows 
	

	if (cWord != pRes->cWords)
	{
		FreeIdxWORDMAP(pRes);
		if (pRes->pMap)
		{
			ExternFree(pRes->pMap);
		}

		pRes->cWords = cWord;
		pRes->pMap = (WORDMAP *)ExternAlloc(sizeof(*pRes->pMap) * cWord);
		ASSERT(pRes->pMap);
		
		if (!pRes->pMap)
		{
			return FALSE;
		}
		memset(pRes->pMap, 0, sizeof(*pRes->pMap) * cWord);

		// By convention the stroke index is put in the last map
		pMap = pRes->pMap + cWord - 1;
		pMap->piStrokeIndex = (int *)ExternAlloc(sizeof(*pRes->pMap->piStrokeIndex) * cMaxStroke);
		ASSERT(pMap->piStrokeIndex);
		if (!pMap->piStrokeIndex)
		{
			return FALSE;
		}
	}
	else
	{
		pMap = pRes->pMap + cWord - 1;
	}

	// Work Backwards
	tEnd = T;			// Ending segment
	pMap->len = 0;

	for (t = T, --pBestPath ; t > 0 ; --t, --pBestPath)
	{
		int		iChar;

		iChar = *pBestPath;

		if (iChar & SPACE_MARK)
		{
			// Space After this character
			iChar &= ~SPACE_MARK;

			if (IsOutputBeginAct(pActive[iChar]))
			{
				--cChar;
				++pMap->len;
			}

			if (InsertStrokes(pRes->pXRC, pMap, t-1, tEnd, cMaxStroke) != HRCR_OK)
			{
				return FALSE;
			}
			
			--cWord;
			cMaxStroke -= pMap->cStrokes;
			tEnd = t-1;
			ASSERT(cChar >=0 );
			pMap->start = (unsigned short)cChar;
			--pMap;
			pMap->piStrokeIndex = pMap[1].piStrokeIndex + pMap[1].cStrokes;
			pMap->len = 0; 
			pMap->cStrokes = 0;
			--cChar;
		}
		else
		{
			if (IsOutputBeginAct(pActive[iChar]))
			{
				--cChar;
				++pMap->len;
			}
		}
	}

	ASSERT(pMap == pRes->pMap);
	ASSERT(cWord == 1);
	ASSERT(cChar == 0);
	ASSERT(t == 0);
	pMap->start = (unsigned short)cChar;

	if (InsertStrokes(pRes->pXRC, pMap, t, tEnd, cMaxStroke) != HRCR_OK)
	{
		return FALSE;
	}


	return TRUE;
}
/***************************************************************
 * vBestPath
 *
 * External callable routine for finding the best path using the viterbi  algorithm
 *
 * Takes as input the Output prob distributions (Assumed to be logP)
 * the transition logP are include in the viterbi.ci
 *
 * Returns the best path cost or -1 if an error occurred
 ****************************************************************/
int VbestPath(
XRC				*pXrc,			// Use this to change the map stucture if it is to be inserted
OD_LOGA			*pLogAFull,		// Full Transition matrix
unsigned char	*pBestString,	// Returned best String
XRCRESULT		**ppResInsert,	// Where it should be inserted
int				cOutNode		// Number of net output nodes per time slice
)
{
	int				T;				// Number of time slices
	REAL			*pb;			// Output distributions 
	int				cTotChar;		// Total Number of character activations supported (includes virtual char activations)
	int				iRet = -1;		// Default
	int				*alpha, *pSi, *pActive;
	int				cActive;
	LOGA_TYPE		*pLogA;			// Transition log Probs
	int				*pBestPath = NULL;
	BYTE			rgbActiveMap[C_CHAR_ACTIVATIONS];
	int				iAlt;			// Last  alternalte ID in ALT list

	ASSERT(pXrc);
	ASSERT(pBestString);

	T = pXrc->nfeatureset->cSegment;
	pb = pXrc->NeuralOutput;
	cTotChar = pLogAFull->cDim;

	ASSERT(cOutNode <= cTotChar);
	ASSERT(cTotChar <= C_CHAR_ACTIVATIONS);

	if (cTotChar > C_CHAR_ACTIVATIONS)
	{
		return -1;
	}

	alpha		= NULL;
	pSi			= NULL;
	pActive		= NULL;
	pLogA		= NULL;
	pBestPath	= NULL;

	BuildActiveMap(pb, T, cOutNode, rgbActiveMap);

	cActive = VbuildActiveFromMap(rgbActiveMap, cTotChar, pLogAFull, &pActive, &pLogA);

	//ASSERT (cActive <= OD_MAX_ACTIVE_CHAR);

	if (T > 0 && cActive > 0)
	{
		int		nState = T * cActive;

		alpha		= (int  *)ExternAlloc(sizeof(*alpha) * cActive);
		pSi			= (int  *)ExternAlloc(sizeof(*pSi) * nState);
		pBestPath	= (int *)ExternAlloc(sizeof(*pBestPath) * T);

		ASSERT(alpha);
		ASSERT(pSi);
		ASSERT(pBestPath);

		if (!alpha || !pSi || !pBestPath)
		{
			goto exit;
		}

		if (!Vforward(T, pb, cOutNode, pActive, cActive, pLogA, alpha, pSi))
		{
			goto exit;
		}

		iRet = Vbackward(T, cActive, alpha, pSi, pBestPath);
		if (iRet < 0)
		{
			goto exit;
		}

		// Translate the best path indices to characters and insert spaces if necessary
		iRet += VxlatePath(T, pActive, pBestPath, pBestString, cActive, pb, cOutNode, pLogAFull);


		// Check if we will be inserting this into the XRC
		iAlt = pXrc->answer.cAltMax - 1;
		if (pXrc->answer.cAlt < pXrc->answer.cAltMax || iRet < pXrc->answer.aAlt[iAlt].cost)
		{
			XRCRESULT		*pResInsert;
			UINT			i;

			pResInsert = pXrc->answer.aAlt;

			// Check if it is already in the list
			for (i = 0 ; i < pXrc->answer.cAlt ; ++i, ++pResInsert)
			{
				if (0 == strcmp(pBestString, pResInsert->szWord))
				{
					pResInsert = NULL;
					break;
				}

				if (iRet < pResInsert->cost)
				{
					break;
				}
			}
		
			*ppResInsert = pResInsert;

			if (!pXrc->answer.aAlt[iAlt].pXRC)
			{
				pXrc->answer.aAlt[iAlt].pXRC = pXrc;
			}

			if (pResInsert)
			{
				if (pXrc->answer.cAlt <= 0)
				{
					// The alt list is empty - ensure the insert is clear
					memset((void *)pResInsert, 0, sizeof(*pResInsert));
				}

				if (!pResInsert->pXRC)
				{
					pResInsert->pXRC = pXrc;
				}

				if (!updateXRCRESULT(T, pActive, pBestPath, &pXrc->answer.aAlt[iAlt], pBestString) )
				{
					iRet = -1;
					goto exit;
				}
			}
		}
	}

exit:

	ExternFree(alpha);
	ExternFree(pSi);
	ExternFree(pActive);
	ExternFree(pLogA);
	ExternFree(pBestPath);

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\sysdict.h ===
// sysdict.h
// Angshuman Guha, aguha
// Sep 17, 1998

#ifndef __INC_SYSDICT_H
#define __INC_SYSDICT_H

#include "trie.h"
#include "langmod.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	TRIESCAN scan;
	BYTE bRoot;
	BYTE spare[3];
} DICTSTATE_INFO;

void *LoadDictionary(HINSTANCE hInst, DWORD dwLocale);
void FreeDictionary(void);

#define	FLAG_MASK	0xff800000
#define	FLAG_SHIFT	23
#define TRIE_UNIGRAM_TAG		0
#define TRIE_DIALECT_TAG		1
#define TRIE_UNIGRAM_MASK		(1 << TRIE_UNIGRAM_TAG)
#define TRIE_DIALECT_MASK		(1 << TRIE_DIALECT_TAG)

#define StateToFlags(state) ((WORD) ((FLAG_MASK & state) >> FLAG_SHIFT))
#define StateToAddress(state) ((LPBYTE)(gTrieAddress + (DWORD)(state & ~FLAG_MASK)))
#define FlagsToState(flags) ((DWORD)((flags) << FLAG_SHIFT))


// Get the Dialect tag information if present
#define DIALECT_TAG(info) (((info).scan.wMask & TRIE_DIALECT_MASK) ? info.scan.aTags[TRIE_DIALECT_TAG].dwData : 0)

BOOL Word2Tag(unsigned char *pWord, DWORD *pTag);
BOOL TrieFindWord (unsigned char *pWord, TRIESCAN *pTrieScan);
void GetChildrenSYSDICT(LMSTATE *pState, LMINFO *pLminfo, REAL *aCharProb, LMCHILDREN *pLmchildren);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\web.h ===
// web.h
// Angshuman Guha
// aguha
// Jan 10, 2001

#ifndef __INC_WEB_H
#define __INC_WEB_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescWEB[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\web.c ===
// web.c
// Angshuman Guha
// aguha
// Jan 10, 2001
//
// added https
// Dec 11, 2001

#include "common.h"
#include "web.h"
#include "fsa.h"

// text generated by re2fsa at Fri Mar 29 16:23:11 2002

// the input-file of rules:
// begin = "h" "t" "t" "p" ["s"] ":" slashes;
// begin = "w" "w" "w" dot;
//  
// slashes = "\\" "\\";
// slashes = "/" "/";
//  
// dot = ".";
// notdot = "abcdefghijklmnopqrstuivwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
//  
// html = "h" "t" "m" ["l"];
// html = "a" "s" "p";
// 
// web = begin (notdot+ dot)+ com [ "\\/" [ notdot+ dot html ]];
// 
// # the following two rules were added as valid addresses in response to ;
// # bkeely's suggestion ;
// # it is supposed to help in entering parts of a web address ;
// web = "/" "/";
// web = ":" "/" "/";
// 
// # 252 domain names;
// com = "c" "o" "m";
// com = "n" "e" "t";
// com = "e" "d" "u";
// com = "j" "p";
// com = "c" "a";
// com = "u" "k";
// com = "u" "s";
// com = "d" "e";
// com = "m" "i" "l";
// com = "i" "t";
// com = "a" "u";
// com = "n" "l";
// com = "o" "r" "g";
// com = "f" "r";
// com = "t" "w";
// com = "b" "r";
// com = "g" "o" "v";
// com = "f" "i";
// com = "s" "e";
// com = "e" "s";
// com = "m" "x";
// com = "n" "o";
// com = "a" "t";
// com = "c" "h";
// com = "d" "k";
// com = "b" "e";
// com = "k" "r";
// com = "p" "l";
// com = "n" "z";
// com = "r" "u";
// com = "a" "r";
// com = "h" "k";
// com = "z" "a";
// com = "i" "l";
// com = "p" "t";
// com = "s" "g";
// com = "a" "r" "p" "a";
// com = "h" "u";
// com = "c" "z";
// com = "g" "r";
// com = "u" "n" "k" "n" "o" "w" "n";
// com = "t" "r";
// com = "i" "e";
// com = "c" "l";
// com = "c" "n";
// com = "m" "y";
// com = "t" "h";
// com = "u" "y";
// com = "c" "o";
// com = "i" "s";
// com = "r" "o";
// com = "e" "e";
// com = "u" "a";
// com = "s" "k";
// com = "i" "n";
// com = "a" "e";
// com = "i" "d";
// com = "h" "r";
// com = "s" "i";
// com = "s" "u";
// com = "p" "h";
// com = "l" "v";
// com = "l" "t";
// com = "b" "g";
// com = "v" "e";
// com = "p" "a";
// com = "y" "u";
// com = "n" "u";
// com = "l" "u";
// com = "p" "e";
// com = "i" "n" "t";
// com = "c" "c";
// com = "c" "y";
// com = "d" "o";
// com = "c" "r";
// com = "t" "t";
// com = "p" "k";
// com = "e" "g";
// com = "l" "b";
// com = "g" "t";
// com = "s" "a";
// com = "t" "o";
// com = "b" "n";
// com = "k" "z";
// com = "b" "m";
// com = "k" "w";
// com = "m" "u";
// com = "n" "a";
// com = "c" "x";
// com = "m" "k";
// com = "z" "w";
// com = "e" "c";
// com = "w" "s";
// com = "b" "w";
// com = "g" "l";
// com = "l" "k";
// com = "k" "g";
// com = "g" "e";
// com = "m" "d";
// com = "k" "e";
// com = "a" "c";
// com = "f" "o";
// com = "p" "r";
// com = "p" "f";
// com = "j" "m";
// com = "t" "v";
// com = "a" "m";
// com = "m" "t";
// com = "n" "i";
// com = "c" "i";
// com = "b" "o";
// com = "p" "y";
// com = "a" "s";
// com = "b" "y";
// com = "b" "h";
// com = "n" "p";
// com = "s" "z";
// com = "b" "a";
// com = "j" "o";
// com = "z" "m";
// com = "a" "d";
// com = "n" "g";
// com = "g" "i";
// com = "t" "z";
// com = "b" "t";
// com = "s" "t";
// com = "l" "i";
// com = "i" "r";
// com = "o" "m";
// com = "s" "n";
// com = "c" "u";
// com = "t" "m";
// com = "s" "m";
// com = "s" "v";
// com = "g" "p";
// com = "k" "y";
// com = "f" "j";
// com = "m" "g";
// com = "h" "m";
// com = "k" "h";
// com = "f" "m";
// com = "m" "c";
// com = "p" "g";
// com = "b" "f";
// com = "s" "b";
// com = "r" "w";
// com = "m" "a";
// com = "m" "q";
// com = "a" "z";
// com = "a" "i";
// com = "v" "i";
// com = "a" "g";
// com = "s" "h";
// com = "b" "z";
// com = "a" "w";
// com = "u" "z";
// com = "m" "v";
// com = "t" "c";
// com = "m" "s";
// com = "t" "j";
// com = "g" "s";
// com = "v" "u";
// com = "d" "m";
// com = "m" "o";
// com = "v" "n";
// com = "n" "c";
// com = "m" "n";
// com = "u" "g";
// com = "n" "e";
// com = "t" "g";
// com = "g" "u";
// com = "g" "f";
// com = "a" "l";
// com = "h" "n";
// com = "c" "k";
// com = "m" "r";
// com = "m" "z";
// com = "n" "f";
// com = "a" "n";
// com = "l" "s";
// com = "b" "b";
// com = "j" "e";
// com = "a" "q";
// com = "v" "g";
// com = "i" "m";
// com = "s" "l";
// com = "t" "n";
// com = "m" "l";
// com = "e" "t";
// com = "c" "d";
// com = "t" "f";
// com = "g" "y";
// com = "y" "e";
// com = "g" "n";
// com = "k" "m";
// com = "g" "a";
// com = "d" "z";
// com = "g" "g";
// com = "l" "c";
// com = "q" "a";
// com = "p" "n";
// com = "l" "y";
// com = "g" "h";
// com = "b" "s";
// com = "g" "w";
// com = "k" "i";
// com = "g" "b";
// com = "v" "a";
// com = "e" "r";
// com = "g" "m";
// com = "c" "m";
// com = "m" "p";
// com = "m" "w";
// com = "i" "o";
// com = "s" "r";
// com = "s" "c";
// com = "a" "o";
// com = "c" "f";
// com = "t" "p";
// com = "c" "g";
// com = "t" "d";
// com = "k" "n";
// com = "m" "m";
// com = "b" "d";
// com = "g" "d";
// com = "l" "a";
// com = "a" "f";
// com = "c" "v";
// com = "m" "h";
// com = "n" "r";
// com = "p" "m";
// com = "v" "c";
// com = "d" "j";
// com = "h" "t";
// com = "i" "q";
// com = "p" "w";
// com = "r" "e";
// com = "s" "o";
// com = "t" "k";
// com = "b" "i";
// com = "b" "j";
// com = "b" "v";
// com = "f" "k";
// com = "g" "q";
// com = "l" "r";
// com = "s" "d";
// com = "s" "j";
// com = "s" "y";
// com = "u" "m";
// com = "w" "f";
// com = "y" "t";
// com = "z" "r";
// 
// # 7 soon to be domain names;
// com = "a" "e" "r" "o";
// com = "b" "i" "z";
// com = "c" "o" "o" "p";
// com = "i" "n" "f" "o";
// com = "m" "u" "s" "e" "u" "m";
// com = "n" "a" "m" "e";
// com = "p" "r" "o";
// 
// = web

// 76 states

static const unsigned char gaSWEB[] = 
	/* gaStringWEB+0 */	"/\000"
	/* gaStringWEB+2 */	":\000"
	/* gaStringWEB+4 */	"h\000"
	/* gaStringWEB+6 */	"w\000"
	/* gaStringWEB+8 */	"t\000"
	/* gaStringWEB+10 */	"p\000"
	/* gaStringWEB+12 */	".\000"
	/* gaStringWEB+14 */	"s\000"
	/* gaStringWEB+16 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\000"
	/* gaStringWEB+81 */	"\\\000"
	/* gaStringWEB+83 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_x\000"
	/* gaStringWEB+123 */	"a\000"
	/* gaStringWEB+125 */	"b\000"
	/* gaStringWEB+127 */	"c\000"
	/* gaStringWEB+129 */	"d\000"
	/* gaStringWEB+131 */	"e\000"
	/* gaStringWEB+133 */	"f\000"
	/* gaStringWEB+135 */	"g\000"
	/* gaStringWEB+137 */	"i\000"
	/* gaStringWEB+139 */	"j\000"
	/* gaStringWEB+141 */	"k\000"
	/* gaStringWEB+143 */	"l\000"
	/* gaStringWEB+145 */	"m\000"
	/* gaStringWEB+147 */	"n\000"
	/* gaStringWEB+149 */	"o\000"
	/* gaStringWEB+151 */	"q\000"
	/* gaStringWEB+153 */	"r\000"
	/* gaStringWEB+155 */	"u\000"
	/* gaStringWEB+157 */	"v\000"
	/* gaStringWEB+159 */	"y\000"
	/* gaStringWEB+161 */	"z\000"
	/* gaStringWEB+163 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abhjkpvxy\000"
	/* gaStringWEB+211 */	"cdfgilmnoqstuwz\000"
	/* gaStringWEB+227 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_cklpqux\000"
	/* gaStringWEB+273 */	"abdefghjmnorstvwyz\000"
	/* gaStringWEB+292 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bejpqstw\000"
	/* gaStringWEB+339 */	"acdfghiklmnruvxyz\000"
	/* gaStringWEB+357 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdfghilnpqrstuvwxy\000"
	/* gaStringWEB+416 */	"ejkmoz\000"
	/* gaStringWEB+423 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abfhijklmnopquvwxyz\000"
	/* gaStringWEB+481 */	"cegrst\000"
	/* gaStringWEB+488 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghlnpqstuvwxyz\000"
	/* gaStringWEB+547 */	"ijkmor\000"
	/* gaStringWEB+554 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_cjkvxz\000"
	/* gaStringWEB+599 */	"abdefghilmnpqrstuwy\000"
	/* gaStringWEB+619 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijlopqsvwxyz\000"
	/* gaStringWEB+678 */	"kmnrtu\000"
	/* gaStringWEB+685 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcfghijkpuvwxyz\000"
	/* gaStringWEB+740 */	"delmoqrst\000"
	/* gaStringWEB+750 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdfghijklnqrstuvwxyz\000"
	/* gaStringWEB+811 */	"emop\000"
	/* gaStringWEB+816 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdfjklopqstuvx\000"
	/* gaStringWEB+871 */	"eghimnrwyz\000"
	/* gaStringWEB+882 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_defghjlmnopqwxz\000"
	/* gaStringWEB+936 */	"abcikrstuvy\000"
	/* gaStringWEB+948 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_befj\000"
	/* gaStringWEB+991 */	"acdghklmnopqrstvwxyz\000"
	/* gaStringWEB+1012 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bdhjkmnqstvwxy\000"
	/* gaStringWEB+1065 */	"cfgilopruz\000"
	/* gaStringWEB+1076 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklnopqstuvwxyz\000"
	/* gaStringWEB+1139 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bcdijopqsuvxz\000"
	/* gaStringWEB+1191 */	"aefghklmntwy\000"
	/* gaStringWEB+1204 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bcdefghijklmnopqrstuvwxyz\000"
	/* gaStringWEB+1268 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdfghijklmnpqrstvxyz\000"
	/* gaStringWEB+1329 */	"eouw\000"
	/* gaStringWEB+1334 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_fpqswx\000"
	/* gaStringWEB+1379 */	"abcdeghijklmnortuvyz\000"
	/* gaStringWEB+1400 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abeilqsuxy\000"
	/* gaStringWEB+1449 */	"cdfghjkmnoprtvwz\000"
	/* gaStringWEB+1466 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bcdefhijlopqrtuvwx\000"
	/* gaStringWEB+1523 */	"agkmsyz\000"
	/* gaStringWEB+1531 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bdfhjklmopqrstvwxyz\000"
	/* gaStringWEB+1589 */	"aceginu\000"
	/* gaStringWEB+1597 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdeghijklmnopqrtuvwxyz\000"
	/* gaStringWEB+1660 */	"fs\000"
	/* gaStringWEB+1663 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdfghijklmnopqrsvwxyz\000"
	/* gaStringWEB+1725 */	"etu\000"
	/* gaStringWEB+1729 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bcdefghijklnopqstuvxyz\000"
	/* gaStringWEB+1790 */	"amrw\000"
	/* gaStringWEB+1795 */	"/\\\000"
	/* gaStringWEB+1798 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqstuvwxyz\000"
	/* gaStringWEB+1862 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnoqrstuvwxyz\000"
	/* gaStringWEB+1926 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxy\000"
	/* gaStringWEB+1990 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklnpqrstuvwxyz\000"
	/* gaStringWEB+2053 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstvwxyz\000"
	/* gaStringWEB+2117 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuwxyz\000"
	/* gaStringWEB+2181 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdeghijklmnopqrsuvwxyz\000"
	/* gaStringWEB+2244 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijkmnopqrstuvwxyz\000"
	/* gaStringWEB+2308 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrtuvwxyz\000"
	/* gaStringWEB+2372 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklnopqrstuvwxyz\000"
	/* gaStringWEB+2436 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrsuvwxyz\000"
	/* gaStringWEB+2500 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefhijklmnopqrstuvwxyz\000"
	/* gaStringWEB+2564 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnpqrstuvwxyz\000"
	/* gaStringWEB+2628 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijlmnopqrstuvwxyz\000"
	/* gaStringWEB+2692 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdfghijklmnopqrstuvwxyz\000"
	/* gaStringWEB+2756 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmopqrstuvwxyz\000"
	/* gaStringWEB+2820 */	"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvxyz\000"
;

static const STATE_TRANSITION gaTWEB[] = {
	{gaSWEB+0,	1}, // +0: state 0 transitions
	{gaSWEB+2,	2},
	{gaSWEB+4,	3},
	{gaSWEB+6,	4},
	{gaSWEB+0,	5}, // +4: state 1 transitions
	{gaSWEB+0,	1}, // +5: state 2 transitions
	{gaSWEB+8,	6}, // +6: state 3 transitions
	{gaSWEB+6,	7}, // +7: state 4 transitions
	{gaSWEB+8,	8}, // +8: state 6 transitions
	{gaSWEB+6,	9}, // +9: state 7 transitions
	{gaSWEB+10,	10}, // +10: state 8 transitions
	{gaSWEB+12,	11}, // +11: state 9 transitions
	{gaSWEB+2,	12}, // +12: state 10 transitions
	{gaSWEB+14,	13},
	{gaSWEB+16,	14}, // +14: state 11 transitions
	{gaSWEB+0,	15}, // +15: state 12 transitions
	{gaSWEB+81,	16},
	{gaSWEB+2,	12}, // +17: state 13 transitions
	{gaSWEB+16,	14}, // +18: state 14 transitions
	{gaSWEB+12,	17},
	{gaSWEB+0,	11}, // +20: state 15 transitions
	{gaSWEB+81,	11}, // +21: state 16 transitions
	{gaSWEB+83,	14}, // +22: state 17 transitions
	{gaSWEB+123,	18},
	{gaSWEB+125,	19},
	{gaSWEB+127,	20},
	{gaSWEB+129,	21},
	{gaSWEB+131,	22},
	{gaSWEB+133,	23},
	{gaSWEB+135,	24},
	{gaSWEB+4,	25},
	{gaSWEB+137,	26},
	{gaSWEB+139,	27},
	{gaSWEB+141,	28},
	{gaSWEB+143,	29},
	{gaSWEB+145,	30},
	{gaSWEB+147,	31},
	{gaSWEB+149,	32},
	{gaSWEB+10,	33},
	{gaSWEB+151,	34},
	{gaSWEB+153,	35},
	{gaSWEB+14,	36},
	{gaSWEB+8,	37},
	{gaSWEB+155,	38},
	{gaSWEB+157,	39},
	{gaSWEB+6,	40},
	{gaSWEB+159,	41},
	{gaSWEB+161,	42},
	{gaSWEB+163,	14}, // +48: state 18 transitions
	{gaSWEB+12,	17},
	{gaSWEB+211,	43},
	{gaSWEB+131,	44},
	{gaSWEB+153,	45},
	{gaSWEB+227,	14}, // +53: state 19 transitions
	{gaSWEB+12,	17},
	{gaSWEB+273,	43},
	{gaSWEB+137,	46},
	{gaSWEB+292,	14}, // +57: state 20 transitions
	{gaSWEB+12,	17},
	{gaSWEB+339,	43},
	{gaSWEB+149,	47},
	{gaSWEB+357,	14}, // +61: state 21 transitions
	{gaSWEB+12,	17},
	{gaSWEB+416,	43},
	{gaSWEB+423,	14}, // +64: state 22 transitions
	{gaSWEB+12,	17},
	{gaSWEB+481,	43},
	{gaSWEB+129,	48},
	{gaSWEB+488,	14}, // +68: state 23 transitions
	{gaSWEB+12,	17},
	{gaSWEB+547,	43},
	{gaSWEB+554,	14}, // +71: state 24 transitions
	{gaSWEB+12,	17},
	{gaSWEB+599,	43},
	{gaSWEB+149,	49},
	{gaSWEB+619,	14}, // +75: state 25 transitions
	{gaSWEB+12,	17},
	{gaSWEB+678,	43},
	{gaSWEB+685,	14}, // +78: state 26 transitions
	{gaSWEB+12,	17},
	{gaSWEB+740,	43},
	{gaSWEB+147,	50},
	{gaSWEB+750,	14}, // +82: state 27 transitions
	{gaSWEB+12,	17},
	{gaSWEB+811,	43},
	{gaSWEB+816,	14}, // +85: state 28 transitions
	{gaSWEB+12,	17},
	{gaSWEB+871,	43},
	{gaSWEB+882,	14}, // +88: state 29 transitions
	{gaSWEB+12,	17},
	{gaSWEB+936,	43},
	{gaSWEB+948,	14}, // +91: state 30 transitions
	{gaSWEB+12,	17},
	{gaSWEB+991,	43},
	{gaSWEB+137,	51},
	{gaSWEB+155,	52},
	{gaSWEB+1012,	14}, // +96: state 31 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1065,	43},
	{gaSWEB+123,	53},
	{gaSWEB+131,	54},
	{gaSWEB+1076,	14}, // +101: state 32 transitions
	{gaSWEB+12,	17},
	{gaSWEB+145,	43},
	{gaSWEB+153,	55},
	{gaSWEB+1139,	14}, // +105: state 33 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1191,	43},
	{gaSWEB+153,	56},
	{gaSWEB+1204,	14}, // +109: state 34 transitions
	{gaSWEB+12,	17},
	{gaSWEB+123,	43},
	{gaSWEB+1268,	14}, // +112: state 35 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1329,	43},
	{gaSWEB+1334,	14}, // +115: state 36 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1379,	43},
	{gaSWEB+1400,	14}, // +118: state 37 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1449,	43},
	{gaSWEB+1466,	14}, // +121: state 38 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1523,	43},
	{gaSWEB+147,	57},
	{gaSWEB+1531,	14}, // +125: state 39 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1589,	43},
	{gaSWEB+1597,	14}, // +128: state 40 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1660,	43},
	{gaSWEB+1663,	14}, // +131: state 41 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1725,	43},
	{gaSWEB+1729,	14}, // +134: state 42 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1790,	43},
	{gaSWEB+16,	14}, // +137: state 43 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1795,	58},
	{gaSWEB+1798,	14}, // +140: state 44 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1795,	58},
	{gaSWEB+153,	59},
	{gaSWEB+1862,	14}, // +144: state 45 transitions
	{gaSWEB+12,	17},
	{gaSWEB+10,	34},
	{gaSWEB+1795,	58},
	{gaSWEB+1926,	14}, // +148: state 46 transitions
	{gaSWEB+12,	17},
	{gaSWEB+161,	43},
	{gaSWEB+1795,	58},
	{gaSWEB+1990,	14}, // +152: state 47 transitions
	{gaSWEB+12,	17},
	{gaSWEB+145,	43},
	{gaSWEB+1795,	58},
	{gaSWEB+149,	60},
	{gaSWEB+2053,	14}, // +157: state 48 transitions
	{gaSWEB+12,	17},
	{gaSWEB+155,	43},
	{gaSWEB+2117,	14}, // +160: state 49 transitions
	{gaSWEB+12,	17},
	{gaSWEB+157,	43},
	{gaSWEB+2181,	14}, // +163: state 50 transitions
	{gaSWEB+12,	17},
	{gaSWEB+8,	43},
	{gaSWEB+1795,	58},
	{gaSWEB+133,	59},
	{gaSWEB+2244,	14}, // +168: state 51 transitions
	{gaSWEB+12,	17},
	{gaSWEB+143,	43},
	{gaSWEB+2308,	14}, // +171: state 52 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1795,	58},
	{gaSWEB+14,	61},
	{gaSWEB+2372,	14}, // +175: state 53 transitions
	{gaSWEB+12,	17},
	{gaSWEB+1795,	58},
	{gaSWEB+145,	62},
	{gaSWEB+2436,	14}, // +179: state 54 transitions
	{gaSWEB+12,	17},
	{gaSWEB+8,	43},
	{gaSWEB+1795,	58},
	{gaSWEB+2500,	14}, // +183: state 55 transitions
	{gaSWEB+12,	17},
	{gaSWEB+135,	43},
	{gaSWEB+2564,	14}, // +186: state 56 transitions
	{gaSWEB+12,	17},
	{gaSWEB+149,	43},
	{gaSWEB+1795,	58},
	{gaSWEB+2628,	14}, // +190: state 57 transitions
	{gaSWEB+12,	17},
	{gaSWEB+141,	63},
	{gaSWEB+16,	64}, // +193: state 58 transitions
	{gaSWEB+2564,	14}, // +194: state 59 transitions
	{gaSWEB+12,	17},
	{gaSWEB+149,	43},
	{gaSWEB+1862,	14}, // +197: state 60 transitions
	{gaSWEB+12,	17},
	{gaSWEB+10,	43},
	{gaSWEB+2692,	14}, // +200: state 61 transitions
	{gaSWEB+12,	17},
	{gaSWEB+131,	65},
	{gaSWEB+2692,	14}, // +203: state 62 transitions
	{gaSWEB+12,	17},
	{gaSWEB+131,	43},
	{gaSWEB+2756,	14}, // +206: state 63 transitions
	{gaSWEB+12,	17},
	{gaSWEB+147,	66},
	{gaSWEB+16,	64}, // +209: state 64 transitions
	{gaSWEB+12,	67},
	{gaSWEB+2053,	14}, // +211: state 65 transitions
	{gaSWEB+12,	17},
	{gaSWEB+155,	68},
	{gaSWEB+2564,	14}, // +214: state 66 transitions
	{gaSWEB+12,	17},
	{gaSWEB+149,	69},
	{gaSWEB+123,	70}, // +217: state 67 transitions
	{gaSWEB+4,	71},
	{gaSWEB+2372,	14}, // +219: state 68 transitions
	{gaSWEB+12,	17},
	{gaSWEB+145,	43},
	{gaSWEB+2820,	14}, // +222: state 69 transitions
	{gaSWEB+12,	17},
	{gaSWEB+6,	72},
	{gaSWEB+14,	73}, // +225: state 70 transitions
	{gaSWEB+8,	74}, // +226: state 71 transitions
	{gaSWEB+2756,	14}, // +227: state 72 transitions
	{gaSWEB+12,	17},
	{gaSWEB+147,	43},
	{gaSWEB+10,	5}, // +230: state 73 transitions
	{gaSWEB+145,	75}, // +231: state 74 transitions
	{gaSWEB+143,	5}, // +232: state 75 transitions
};

const STATE_DESCRIPTION aStateDescWEB[76] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTWEB+0},
	/*   1 */ {0, 1, gaTWEB+4},
	/*   2 */ {0, 1, gaTWEB+5},
	/*   3 */ {0, 1, gaTWEB+6},
	/*   4 */ {0, 1, gaTWEB+7},
	/*   5 */ {1, 0, NULL},
	/*   6 */ {0, 1, gaTWEB+8},
	/*   7 */ {0, 1, gaTWEB+9},
	/*   8 */ {0, 1, gaTWEB+10},
	/*   9 */ {0, 1, gaTWEB+11},
	/*  10 */ {0, 2, gaTWEB+12},
	/*  11 */ {0, 1, gaTWEB+14},
	/*  12 */ {0, 2, gaTWEB+15},
	/*  13 */ {0, 1, gaTWEB+17},
	/*  14 */ {0, 2, gaTWEB+18},
	/*  15 */ {0, 1, gaTWEB+20},
	/*  16 */ {0, 1, gaTWEB+21},
	/*  17 */ {0, 26, gaTWEB+22},
	/*  18 */ {0, 5, gaTWEB+48},
	/*  19 */ {0, 4, gaTWEB+53},
	/*  20 */ {0, 4, gaTWEB+57},
	/*  21 */ {0, 3, gaTWEB+61},
	/*  22 */ {0, 4, gaTWEB+64},
	/*  23 */ {0, 3, gaTWEB+68},
	/*  24 */ {0, 4, gaTWEB+71},
	/*  25 */ {0, 3, gaTWEB+75},
	/*  26 */ {0, 4, gaTWEB+78},
	/*  27 */ {0, 3, gaTWEB+82},
	/*  28 */ {0, 3, gaTWEB+85},
	/*  29 */ {0, 3, gaTWEB+88},
	/*  30 */ {0, 5, gaTWEB+91},
	/*  31 */ {0, 5, gaTWEB+96},
	/*  32 */ {0, 4, gaTWEB+101},
	/*  33 */ {0, 4, gaTWEB+105},
	/*  34 */ {0, 3, gaTWEB+109},
	/*  35 */ {0, 3, gaTWEB+112},
	/*  36 */ {0, 3, gaTWEB+115},
	/*  37 */ {0, 3, gaTWEB+118},
	/*  38 */ {0, 4, gaTWEB+121},
	/*  39 */ {0, 3, gaTWEB+125},
	/*  40 */ {0, 3, gaTWEB+128},
	/*  41 */ {0, 3, gaTWEB+131},
	/*  42 */ {0, 3, gaTWEB+134},
	/*  43 */ {1, 3, gaTWEB+137},
	/*  44 */ {1, 4, gaTWEB+140},
	/*  45 */ {1, 4, gaTWEB+144},
	/*  46 */ {1, 4, gaTWEB+148},
	/*  47 */ {1, 5, gaTWEB+152},
	/*  48 */ {0, 3, gaTWEB+157},
	/*  49 */ {0, 3, gaTWEB+160},
	/*  50 */ {1, 5, gaTWEB+163},
	/*  51 */ {0, 3, gaTWEB+168},
	/*  52 */ {1, 4, gaTWEB+171},
	/*  53 */ {1, 4, gaTWEB+175},
	/*  54 */ {1, 4, gaTWEB+179},
	/*  55 */ {0, 3, gaTWEB+183},
	/*  56 */ {1, 4, gaTWEB+186},
	/*  57 */ {0, 3, gaTWEB+190},
	/*  58 */ {1, 1, gaTWEB+193},
	/*  59 */ {0, 3, gaTWEB+194},
	/*  60 */ {0, 3, gaTWEB+197},
	/*  61 */ {0, 3, gaTWEB+200},
	/*  62 */ {0, 3, gaTWEB+203},
	/*  63 */ {0, 3, gaTWEB+206},
	/*  64 */ {0, 2, gaTWEB+209},
	/*  65 */ {0, 3, gaTWEB+211},
	/*  66 */ {0, 3, gaTWEB+214},
	/*  67 */ {0, 2, gaTWEB+217},
	/*  68 */ {0, 3, gaTWEB+219},
	/*  69 */ {0, 3, gaTWEB+222},
	/*  70 */ {0, 1, gaTWEB+225},
	/*  71 */ {0, 1, gaTWEB+226},
	/*  72 */ {0, 3, gaTWEB+227},
	/*  73 */ {0, 1, gaTWEB+230},
	/*  74 */ {0, 1, gaTWEB+231},
	/*  75 */ {1, 1, gaTWEB+232},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\wl.h ===
// wl.h  [wordlists]
// Angshuman Guha, aguha
// Sep 15, 1998
//
// Switched to real UDICT
// John Bennett, jbenn
// March 19, 1999
//
// Major mod.  Angshuman Guha, aguha.  1/9/2001.

#ifndef __INC_WORDLIST_H
#define __INC_WORDLIST_H

#include "langmod.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL addWordsHWL(HWL hwl, UCHAR *lpsz, wchar_t *pwsz, UINT uType);
HWL		CreateHWLInternal(UCHAR *lpsz, wchar_t *pwchar, UINT uType);
BOOL	DestroyHWLInternal(HWL hwl);
BOOL	MergeListsHWL(HWL pSrc, HWL pDest);

void GetChildrenUDICT(LMSTATE *pState,
					  LMINFO *pLminfo,
					  REAL *aCharProb,  
					  LMCHILDREN *pLmchildren);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\charmap.c ===
// charmap.c (FRA vesrion)
// Angshuman Guha, aguha
// Jan 12, 1999
// Modifed Jan 2000 (mrevow)
//  - moved accent marks to front of list
//  - Cleaned up missing characters, added the the Br pound and Euro
//
// Nov 2000
//   - Synch with usa with respect to continuation chars
// Sept 2001
//   - Synch with LM spec dated 9/8/2001 to use the supported chars

#include "common.h"
#include "charmap.h"

const unsigned char g_charMapDesc[] = "German Charmap Last updated 19 Oct 2001 - matches LM spec of 10/11/2001";

#define COUTPUT 185

const BYTE rgCharToOutputNode[2*256] = {
	// the first number is the beginning-activation node
	// the second number is the continuing-activation node
	// the value 255 means there is no output node
	// space ' ( ) , - . / < > [ \ ] ^ _ ` { | }  dont have continuation nodes
	// and accents    (0xa8)   dont have continuation nodes

	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	  0, 255, //   0x20 ( 32)
	  2,   3, // ! 0x21 ( 33)
	  4,   5, // " 0x22 ( 34)
	 31,  32, // # 0x23 ( 35)
	 23,  24, // $ 0x24 ( 36)
	 33,  34, // % 0x25 ( 37)
	 35,  36, // & 0x26 ( 38)
	  6, 255, // ' 0x27 ( 39)
	  7, 255, // ( 0x28 ( 40)
	  8, 255, // ) 0x29 ( 41)
	 37,  38, // * 0x2a ( 42)
	 39,  40, // + 0x2b ( 43)
	  9, 255, // , 0x2c ( 44)
	 10, 255, // - 0x2d ( 45)
	 11, 255, // . 0x2e ( 46)
	 12, 255, // / 0x2f ( 47)
	 55,  56, // 0 0x30 ( 48)
	 57,  58, // 1 0x31 ( 49)
	 59,  60, // 2 0x32 ( 50)
	 61,  62, // 3 0x33 ( 51)
	 63,  64, // 4 0x34 ( 52)
	 65,  66, // 5 0x35 ( 53)
	 67,  68, // 6 0x36 ( 54)
	 69,  70, // 7 0x37 ( 55)
	 71,  72, // 8 0x38 ( 56)
	 73,  74, // 9 0x39 ( 57)
	 13,  14, // : 0x3a ( 58)
	 15,  16, // ; 0x3b ( 59)
	 41, 255, // < 0x3c ( 60)
	 42,  43, // = 0x3d ( 61)
	 44, 255, // > 0x3e ( 62)
	 17,  18, // ? 0x3f ( 63)
	 45,  46, // @ 0x40 ( 64)
	127, 128, // A 0x41 ( 65)
	129, 130, // B 0x42 ( 66)
	131, 132, // C 0x43 ( 67)
	133, 134, // D 0x44 ( 68)
	135, 136, // E 0x45 ( 69)
	137, 138, // F 0x46 ( 70)
	139, 140, // G 0x47 ( 71)
	141, 142, // H 0x48 ( 72)
	143, 144, // I 0x49 ( 73)
	145, 146, // J 0x4a ( 74)
	147, 148, // K 0x4b ( 75)
	149, 150, // L 0x4c ( 76)
	151, 152, // M 0x4d ( 77)
	153, 154, // N 0x4e ( 78)
	155, 156, // O 0x4f ( 79)
	157, 158, // P 0x50 ( 80)
	159, 160, // Q 0x51 ( 81)
	161, 162, // R 0x52 ( 82)
	163, 164, // S 0x53 ( 83)
	165, 166, // T 0x54 ( 84)
	167, 168, // U 0x55 ( 85)
	169, 170, // V 0x56 ( 86)
	171, 172, // W 0x57 ( 87)
	173, 174, // X 0x58 ( 88)
	175, 176, // Y 0x59 ( 89)
	177, 178, // Z 0x5a ( 90)
	 47, 255, // [ 0x5b ( 91)
	 19, 255, // \ 0x5c ( 92)
	 48, 255, // ] 0x5d ( 93)
	 49, 255, // ^ 0x5e ( 94)
	 20, 255, // _ 0x5f ( 95)
	255, 255,
	 75,  76, // a 0x61 ( 97)
	 77,  78, // b 0x62 ( 98)
	 79,  80, // c 0x63 ( 99)
	 81,  82, // d 0x64 (100)
	 83,  84, // e 0x65 (101)
	 85,  86, // f 0x66 (102)
	 87,  88, // g 0x67 (103)
	 89,  90, // h 0x68 (104)
	 91,  92, // i 0x69 (105)
	 93,  94, // j 0x6a (106)
	 95,  96, // k 0x6b (107)
	 97,  98, // l 0x6c (108)
	 99, 100, // m 0x6d (109)
	101, 102, // n 0x6e (110)
	103, 104, // o 0x6f (111)
	105, 106, // p 0x70 (112)
	107, 108, // q 0x71 (113)
	109, 110, // r 0x72 (114)
	111, 112, // s 0x73 (115)
	113, 114, // t 0x74 (116)
	115, 116, // u 0x75 (117)
	117, 118, // v 0x76 (118)
	119, 120, // w 0x77 (119)
	121, 122, // x 0x78 (120)
	123, 124, // y 0x79 (121)
	125, 126, // z 0x7a (122)
	 50, 255, // { 0x7b (123)
	 51, 255, // | 0x7c (124)
	 52, 255, // } 0x7d (125)
	 53,  54, // ~ 0x7e (126)
	255, 255,
	 27,  28, //  0x80 (128)
	255, 255,
	255, 255,
	255, 255,
	 21,  22, //  0x84 (132)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	 25,  26, //  0xa3 (163)
	255, 255,
	 29,  30, //  0xa5 (165)
	255, 255,
	179, 180, //  0xa7 (167)
	  1, 255, //  0xa8 (168)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	181, 182, //  0xb0 (176)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	183, 184, //  0xdf (223)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255
};

const BYTE rgOutputNodeToChar[2*COUTPUT] = {
	// the first number is 0 for char-continuation node, 1 for char-beginning node
	// the second number is the character
// A) Space Node	
	1, ' ',  //  0

// B) Accent characters
	1, '', //  1
	
// C) common punc
	1, '!', //  2
	0, '!', //  3
	1, '"', //  4
	0, '"', //  5
	1, '\'', // 6
	1, '(', //  7
	1, ')', //  8
	1, ',', //  9
	1, '-', // 10
	1, '.', // 11
	1, '/', // 12
	1, ':', // 13
	0, ':', // 14
	1, ';', // 15
	0, ';', // 16
	1, '?', // 17
	0, '?', // 18
	1, '\\', //19
	1, '_', // 20
	1, '', // 21
	0, '', // 22

// D) Currency
	1, '$', // 23
	0, '$', // 24
	1, '', // 25
	0, '', // 26
	1, '', // 27
	0, '', // 28
	1, '', // 29
	0, '', // 30

// D) rare punc
	1, '#', // 31
	0, '#', // 32
	1, '%', // 33
	0, '%', // 34
	1, '&', // 35
	0, '&', // 36
	1, '*', // 37
	0, '*', // 38
	1, '+', // 39
	0, '+', // 40
	1, '<', // 41
	1, '=', // 42
	0, '=', // 43
	1, '>', // 44
	1, '@', // 45
	0, '@', // 46
	1, '[', // 47
	1, ']', // 48
	1, '^', // 49
	1, '{', // 50
	1, '|', // 51
	1, '}', // 52
	1, '~', // 53
	0, '~', // 54

// E) digits
	1, '0', // 55
	0, '0', // 56
	1, '1', // 57
	0, '1', // 58
	1, '2', // 59
	0, '2', // 60
	1, '3', // 61
	0, '3', // 62
	1, '4', // 63
	0, '4', // 64
	1, '5', // 65
	0, '5', // 66
	1, '6', // 67
	0, '6', // 68
	1, '7', // 69
	0, '7', // 70
	1, '8', // 71
	0, '8', // 72
	1, '9', // 73
	0, '9', // 74

// F) lowercase alphabets
	1, 'a', // 75
	0, 'a', // 76
	1, 'b', // 77
	0, 'b', // 78
	1, 'c', // 79
	0, 'c', // 80
	1, 'd', // 81
	0, 'd', // 82
	1, 'e', // 83
	0, 'e', // 84
	1, 'f', // 85
	0, 'f', // 86
	1, 'g', // 87
	0, 'g', // 88
	1, 'h', // 89
	0, 'h', // 90
	1, 'i', // 91
	0, 'i', // 92
	1, 'j', // 93
	0, 'j', // 94
	1, 'k', // 95
	0, 'k', // 96
	1, 'l', // 97
	0, 'l', // 98
	1, 'm', // 99
	0, 'm', // 100
	1, 'n', // 101
	0, 'n', // 102
	1, 'o', // 103
	0, 'o', // 104
	1, 'p', // 105
	0, 'p', // 106
	1, 'q', // 107
	0, 'q', // 108
	1, 'r', // 109
	0, 'r', // 110
	1, 's', // 111
	0, 's', // 112
	1, 't', // 113
	0, 't', // 114
	1, 'u', // 115
	0, 'u', // 116
	1, 'v', // 117
	0, 'v', // 118
	1, 'w', // 119
	0, 'w', // 120
	1, 'x', // 121
	0, 'x', // 122
	1, 'y', // 123
	0, 'y', // 124
	1, 'z', // 125
	0, 'z', // 126

//  G) uppercase alphabets
	1, 'A', // 127
	0, 'A', // 128
	1, 'B', // 129
	0, 'B', // 130
	1, 'C', // 131
	0, 'C', // 132
	1, 'D', // 133
	0, 'D', // 134
	1, 'E', // 135
	0, 'E', // 136
	1, 'F', // 137
	0, 'F', // 138
	1, 'G', // 139
	0, 'G', // 140
	1, 'H', // 141
	0, 'H', // 142
	1, 'I', // 143
	0, 'I', // 144
	1, 'J', // 145
	0, 'J', // 146
	1, 'K', // 147
	0, 'K', // 148
	1, 'L', // 149
	0, 'L', // 150
	1, 'M', // 151
	0, 'M', // 152
	1, 'N', // 153
	0, 'N', // 154
	1, 'O', // 155
	0, 'O', // 156
	1, 'P', // 157
	0, 'P', // 158
	1, 'Q', // 159
	0, 'Q', // 160
	1, 'R', // 161
	0, 'R', // 162
	1, 'S', // 163
	0, 'S', // 164
	1, 'T', // 165
	0, 'T', // 166
	1, 'U', // 167
	0, 'U', // 168
	1, 'V', // 169
	0, 'V', // 170
	1, 'W', // 171
	0, 'W', // 172
	1, 'X', // 173
	0, 'X', // 174
	1, 'Y', // 175
	0, 'Y', // 176
	1, 'Z', // 177
	0, 'Z', // 178

//	H) Euro chars
	1, '', // 179
	0, '', // 180
	1, '', // 181
	0, '', // 182
	1, '', // 183
	0, ''  // 184
};


const BYTE rgVirtualChar[2*256] = 
{
	// these are European accented characters which we currently represent as the
	// simultaneous occurrence of a base character and an accent character
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0x9f) == Y  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0xc0) == A ` 
	0x00, 0x00, //  (0xc1) == A  
	0x00, 0x00, //  (0xc2) == A  
	0x00, 0x00, //  (0xc3) == A ~ 
	0x41, 0xa8, //  (0xc4) == A  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0xc8) == E ` 
	0x00, 0x00, //  (0xc9) == E  
	0x00, 0x00, //  (0xca) == E  
	0x00, 0x00, //  (0xcb) == E  
	0x00, 0x00, //  (0xcc) == I ` 
	0x00, 0x00, //  (0xcd) == I  
	0x00, 0x00, //  (0xce) == I  
	0x00, 0x00, //  (0xcf) == I  
	0x00, 0x00,
	0x00, 0x00, //  (0xd1) == N ~ 
	0x00, 0x00, //  (0xd2) == O ` 
	0x00, 0x00, //  (0xd3) == O  
	0x00, 0x00, //  (0xd4) == O  
	0x00, 0x00, //  (0xd5) == O ~ 
	0x4f, 0xa8, //  (0xd6) == O  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0xd9) == U ` 
	0x00, 0x00, //  (0xda) == U  
	0x00, 0x00, //  (0xdb) == U  
	0x55, 0xa8, //  (0xdc) == U  
	0x00, 0x00, //  (0xdd) == Y  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0xe0) == a ` 
	0x00, 0x00, //  (0xe1) == a  
	0x00, 0x00, //  (0xe2) == a  
	0x00, 0x00, //  (0xe3) == a ~ 
	0x61, 0xa8, //  (0xe4) == a  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0xe8) == e ` 
	0x00, 0x00, //  (0xe9) == e  
	0x00, 0x00, //  (0xea) == e  
	0x00, 0x00, //  (0xeb) == e  
	0x00, 0x00, //  (0xec) == i ` 
	0x00, 0x00, //  (0xed) == i  
	0x00, 0x00, //  (0xee) == i  
	0x00, 0x00, //  (0xef) == i  
	0x00, 0x00,
	0x00, 0x00, //  (0xf1) == n ~ 
	0x00, 0x00, //  (0xf2) == o ` 
	0x00, 0x00, //  (0xf3) == o  
	0x00, 0x00, //  (0xf4) == o  
	0x00, 0x00, //  (0xf5) == o ~ 
	0x6f, 0xa8, //  (0xf6) == o  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0xf9) == u ` 
	0x00, 0x00, //  (0xfa) == u  
	0x00, 0x00, //  (0xfb) == u  
	0x75, 0xa8, //  (0xfc) == u  
	0x00, 0x00, //  (0xfd) == y  
	0x00, 0x00,
	0x00, 0x00  //  (0xff) == y  
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\wl.c ===
// wl.c  [wordlists]
// Angshuman Guha, aguha
// Sep 15, 1998

/*****************************************************
	Currently only one-word wordlists are supported.  
	Capitalization of that word is not supported.

	When we begin to support capitalization of words in 
	the wordlist, the batch-separation code needs to
	change in \hwx\inferno\tools\separate.
******************************************************/

#include "common.h"
#include "wl.h"
#include "udict.h"		// The real user dictionary code.
#include "udictP.h"

BOOL addWordsHWL(HWL hwl, UCHAR *lpsz, wchar_t *pwInsz, UINT uType)
{
	WCHAR		*pwsz = NULL;
	BOOL		bAllocWStr = FALSE;
	int			iLen = 0;
	int			status;
	BOOL		iRet = FALSE;

	if (WLT_EMPTY == uType || (! lpsz && !pwInsz))
	{
		return TRUE;
	}

	// Multi thread synchro
	UDictGetLock(hwl, WRITER);


	if (WLT_STRING == uType)
	{
		// Add word.
		if (lpsz)
		{
			ASSERT(!pwInsz);
			pwsz = CP1252StringToUnicode(lpsz, pwsz, &iLen);
			if (!pwsz)
			{
				goto cleanup;
			}

			bAllocWStr = TRUE;
		}
		else if (pwInsz)
		{
			ASSERT(!lpsz);
			pwsz = pwInsz;
		}

		if (!pwsz)
		{
			status = udFail;
			goto cleanup;
		}

		status	= UDictAddWord(hwl, pwsz, (wchar_t *)0);
	}
	else if (WLT_STRINGTABLE == uType)
	{
		while ( (lpsz && *lpsz) || (pwInsz && *pwInsz))
		{
			int		len;

			if (lpsz)
			{
				ASSERT(!pwInsz);
				len = strlen(lpsz);
				pwsz = CP1252StringToUnicode(lpsz, pwsz, &iLen);
				if (!pwsz)
				{
					goto cleanup;
				}
				lpsz += len + 1;

			}
			else if (pwInsz)
			{
				ASSERT(!lpsz);
				len = wcslen(pwInsz);
				pwsz = pwInsz;
				pwInsz += len + 1;
			}

			if (!pwsz)
			{
				status = udFail;
				goto cleanup;
			}

			status	= UDictAddWord(hwl, pwsz, (wchar_t *)0);
			if (status <  udSuccess) 
			{
				// LEFT FOR A RAINY DAY: What should we do here? Delete the list? skip the word?
				// Currently fails the whole list
				goto cleanup;
			}

		}
	}
	else
	{
		goto cleanup;
	}

	if (udSuccess <= status)
	{
		iRet = TRUE;
	}
cleanup:

	UDictReleaseLock((HWL)hwl, WRITER);
	if (bAllocWStr)
	{
		ASSERT(!pwInsz);
		ExternFree(pwsz);
	}
	return iRet;
}
/******************************Public*Routine******************************\
* CreateHWL
*
* Function to create a HWL struct.
*
* History:
*  29-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
* June 2001 added extra parameter to handle unicode
\**************************************************************************/
HWL CreateHWLInternal(UCHAR *lpsz, wchar_t *pwchar, UINT uType)
{
	HWL hwl;


	// Create the udict.
	hwl		= UDictCreate();
	if (!hwl) 
	{
		return NULL;
	}

	if (TRUE == addWordsHWL(hwl, lpsz, pwchar, uType))
	{
		return hwl;
	}

	// else failure do cleanup
	UDictDestroy(hwl);
	return NULL;

}

/******************************Public*Routine******************************\
* DestroyHWL
*
* Function to destroy a HWL.
*
* History:
*  29-Sep-1998 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL DestroyHWLInternal(HWL hwl)
{
	if (!hwl)
		return FALSE;
	return UDictDestroy(hwl) == udSuccess;
}

void GetChildrenUDICT(LMSTATE *pState,
					  LMINFO *pLminfo,
					  REAL *aCharProb,  
					  LMCHILDREN *pLmchildren)
{
	DWORD trieState;
	LMSTATE newState;
	int status;
	HWL		hwl;

	if (!(hwl = pLminfo->hwl))
		return;

	// Note that the UDICT state numbers are off by one from what we are passed.
	// E.g. -1 is the start state not 0.
	trieState = pState->AutomatonState - 1;

	if (trieState == -1)
		status	= UDictRootNode(hwl, (void **)&trieState);
	else
		status	= UDictDownNode(hwl, (void **)&trieState);

	newState = *pState;
	while (status == udSuccess)
	{
		WCHAR wch;
		unsigned char uch;
		UD_NODE_INFO	info;
		DWORD tmpState;

		newState.AutomatonState = trieState + 1;

		tmpState = trieState;
		if (UDictDownNode(hwl, (void **)&tmpState) == udSuccess)
			newState.flags |= LMSTATE_HASCHILDREN_MASK;
		else
			newState.flags &= ~LMSTATE_HASCHILDREN_MASK;

		UDictGetNode(hwl, (void *)trieState, &info);
		if (info.flags & UDNIF_VALID)
			newState.flags |= LMSTATE_ISVALIDSTATE_MASK;
		else
			newState.flags &= ~LMSTATE_ISVALIDSTATE_MASK;

		wch = UDictNodeLabel(hwl, (void *) trieState);
		if (UnicodeToCP1252(wch, &uch))
		{
			if (!AddChildLM(&newState, uch, 0, 0, pLmchildren))
				return;
		}

		// next child
		status	= UDictRightNode(hwl, (void **)&trieState);
	}
}


BOOL MergeListsHWL(HWL pSrc, HWL pDest)
{
	BOOL		iRet = FALSE;

	// Multi thread synchro
	UDictGetLock(pDest, WRITER);
	if (UDictMerge(pSrc, pDest) >= 0)
	{
		iRet = TRUE;
	}

	UDictReleaseLock(pDest, WRITER);

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\charcost.c ===
// charcost.c
// created by extracting code from beam.c
// March 11, 1999
// Angshuman Guha,  aguha

#include <limits.h>
#include "common.h"
#include "charmap.h"
#include "infernop.h"
#include "nnet.h"
#include "probcost.h"

// Global data containing the log probs of the neural network outputs, for the
// current column.
// NetContActivation() and NetFirstActivation() are macros for fetching the 2 log-probs
// associated with a particular letter.

// Initializes the log-probs of the neural network outputs in the current column,
// and recomputes the best drops for this column.

void InitColumn(int *aActivations, const REAL *pProb)
{
	int		c;
	int		iMin = INT_MAX;  // The smallest cost for this column
	const	REAL *pAct;
	int		*pLog;
	int		iNotAccentSum, iNotAccent[C_ACCENT];

	// initialize
	for (c=C_CHAR_ACTIVATIONS, pLog=aActivations; c; c--, pLog++)
	{
		*pLog = ZERO_PROB_COST;
	}

	iNotAccentSum = 0;
	pAct = pProb + FIRST_ACCENT;
	for (c = 0 ; c < C_ACCENT ; ++c, ++pAct)
	{	
		iNotAccent[c] = PROB_TO_COST(65536 - *pAct);
		iNotAccentSum += iNotAccent[c];
	}


	// scan through all outputs
	for (c = 0, pAct=pProb; c < gcOutputNode; c++, pAct++)
	{
		int iNew = PROB_TO_COST(*pAct);

		if (iNew < iMin)
			iMin = iNew;

		iNew += iNotAccentSum;

		if (IsOutputBegin(c))
			aActivations[Out2Char(c)] = iNew;
		else
			aActivations[256+Out2Char(c)] = iNew;
	}

	// deal with virtual characters
	for (c=0; c<256; c++)
	{
		if (IsVirtualChar(c))
		{
			BYTE o1, o2;

			//o1 = BeginChar2Out(BaseVirtualChar(c));
			o1 = BaseVirtualChar(c);
			o2 = BeginChar2Out(AccentVirtualChar(c));
			
			// 2/9/00 Version (f)
			//aActivations[c] = PROB_TO_COST((pProb[o1]+pProb[o2])/2);

			ASSERT(o2 >= FIRST_ACCENT);
			ASSERT(o2 < C_ACCENT + FIRST_ACCENT);

			// 2/9/00 Version (a)
			aActivations[c] = aActivations[o1] - iNotAccent[o2-FIRST_ACCENT] + PROB_TO_COST(pProb[o2]);

			// 2/9/00  (Version (c)
			//aActivations[c] = aActivations[o1] - iNotAccentSum + PROB_TO_COST(pProb[o2]);

			//ASSERT(aActivations[c] >= iMin);

			//o1 = ContinueChar2Out(BaseVirtualChar(c));
			//if (o1 < 255)
			if (ContinueChar2Out(o1) < 255)
			{
				// 2/9/00 Version (f)
				//aActivations[256+c] = PROB_TO_COST((pProb[o1]+pProb[o2])/2);
	
				// 2/9/00 Version (a)
				aActivations[256+c] = aActivations[256 + o1] - iNotAccent[o2-FIRST_ACCENT] + PROB_TO_COST(pProb[o2]);
	
				// 2/9/00  (Version (c)
				//aActivations[256+c] = aActivations[256 + o1] - iNotAccentSum + PROB_TO_COST(pProb[o2]);
				//ASSERT(aActivations[c+256] >= iMin);
			}
		}
	}
}

void ComputeCharacterProbs(const REAL *pActivation, int cSegment, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong)
{
	int			row, col;
	int			thisChar;
	const int	ShortWidth = 4;
	const int	LongWidth = 7;

	// short window
	memset(aCharProb, 0, 256*sizeof(REAL));
	memset(aCharBeginProb, 0, 256*sizeof(REAL));
	col = cSegment;
	if (col > ShortWidth)
		col = ShortWidth;
	for (; col; col--)
	{
		for (row=0; row<gcOutputNode; row++, pActivation++)
		{
			thisChar = Out2Char(row);
			if (*pActivation > aCharProb[thisChar])
				aCharProb[thisChar] = *pActivation;
			if (IsOutputBegin(row))
			{
				if (*pActivation > aCharBeginProb[thisChar])
					aCharBeginProb[thisChar] = *pActivation;
			}
		}
	}

	// long window
	if (aCharProbLong && aCharBeginProbLong)
	{
		memcpy(aCharProbLong, aCharProb, 256*sizeof(REAL));
		memcpy(aCharBeginProbLong, aCharBeginProb, 256*sizeof(REAL));

		col = cSegment - ShortWidth;
		if (col <= 0)
			return;
		if (col > LongWidth - ShortWidth)
			col = LongWidth - ShortWidth;
		for (; col; col--)
		{
			for (row=0; row<gcOutputNode; row++, pActivation++)
			{
				thisChar = Out2Char(row);
				if (*pActivation > aCharProbLong[thisChar])
					aCharProbLong[thisChar] = *pActivation;
				if (IsOutputBegin(row))
				{
					if (*pActivation > aCharBeginProbLong[thisChar])
						aCharBeginProbLong[thisChar] = *pActivation;
				}
			}
		}
	}

	// deal with virtual chars
	for (thisChar=0; thisChar<256; thisChar++)
	{
		if (IsVirtualChar(thisChar))
		{
			unsigned char baseChar, accentChar;

			baseChar = BaseVirtualChar(thisChar);
			accentChar = AccentVirtualChar(thisChar);
			aCharProb[thisChar] = aCharProb[baseChar] < aCharProb[accentChar] ? aCharProb[baseChar] : aCharProb[accentChar];
			aCharBeginProb[thisChar] = aCharBeginProb[baseChar] < aCharBeginProb[accentChar] ? aCharBeginProb[baseChar] : aCharBeginProb[accentChar];
			if (aCharProbLong && aCharBeginProbLong)
			{
				aCharProbLong[thisChar] = aCharProbLong[baseChar] < aCharProbLong[accentChar] ? aCharProbLong[baseChar] : aCharProbLong[accentChar];
				aCharBeginProbLong[thisChar] = aCharBeginProbLong[baseChar] < aCharBeginProbLong[accentChar] ? aCharBeginProbLong[baseChar] : aCharBeginProbLong[accentChar];
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\charcost.h ===
// charcost.h
// March 11, 1999
// Angshuman Guha,  aguha

// Language specific tuning constants which help with word breaking decisions in beam.c

// 1) Maximum overlap of strokes within a wordgap
#define MAX_STROKE_OVERLAP (0)

// 2) Tuning factor that turns for space node Cost (numerator and denominator)
#define IS_SPACE_NUM	(3)
#define IS_SPACE_DEN	(1)

// 3) Tuning factor  for Not space cost
#define NOT_SPACE_NUM	(2)
#define NOT_SPACE_DEN	(3)

// 4) Tuning factor to for allowing a 'Factoid Space' based on space output
#define FACTOID_SPACE_FUDGE		(90)

#define INFINITY_COST 999999999

//#define NetContActivation(aActivations, ch) (ContinueChar2Out(ch) < 255 ? aActivations[ContinueChar2Out(ch)]: INFINITY_COST)
//#define NetFirstActivation(aActivations, ch) aActivations[BeginChar2Out(ch)]
#define NetContActivation(aActivations, ch) (ch < 255 ? aActivations[256 + ch]: ZERO_PROB_COST*4)
#define NetFirstActivation(aActivations, ch) aActivations[ch]

// Macros that work on the activation state index
#define IsOutputBeginAct(si) (si < 256)
#define Out2CharAct(si) (si < 256 ? si : si - 256)
#define BeginChar2OutAct(si) (si)

//void InitColumn(int * aActivations, const REAL *pAct);
void InitColumn(int * aActivations, const REAL *pAct);
void ComputeCharacterProbs(const REAL *pActivation, int cSegment, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\wispapis.c ===
// FILE: WispApis.c
//

#include <stdlib.h>
#include <search.h>
#include <common.h>
#include <limits.h>
#include "RecTypes.h"
#include "RecApis.h"
#include "PenWin.h"
#include <privapi.h>

#include "nfeature.h"
#include "engine.h"
#include "xrcreslt.h"

#include "baseline.h"
#include "recoutil.h"

#include "TpcError.h"
#include <TpgHandle.h>
#include <udictP.h>
#include <strsafe.h>
#include "resource.h"

extern HINSTANCE g_hInstanceDll;

#define NUMBER_OF_ALTERNATES 10
#define MAX_ALTERNATE_NUMBER 100
#define TAB_STROKE_INC 30


#define TPG_HRECOCONTEXT		(1)
#define TPG_HRECOALT			(2)
#define TPG_HRECOGNIZER			(3)
#define TPG_HRECOLATTICE		(4)
#define TPG_HRECOWORDLIST		(5)

// If we are in the US version we have Levels of Confidence, but in the Euro (including UK)
// versions we do not.  Slight problem: the FOR_ENGLISH #define is for both US and UK.

#ifdef FOR_US
#define CONFIDENCE
#else
#undef CONFIDENCE
#endif

// {DBF29F2C-5289-4be8-B3D8-6EF63246253E}
static const GUID GUID_LINENUMBER = 
{ 0xdbf29f2c, 0x5289, 0x4be8, { 0xb3, 0xd8, 0x6e, 0xf6, 0x32, 0x46, 0x25, 0x3e } };

// {B3C0FE6C-FB51-4164-BA2F-844AF8F983DA}
static const GUID GUID_SEGMENTATION = 
{ 0xb3c0fe6c, 0xfb51, 0x4164, { 0xba, 0x2f, 0x84, 0x4a, 0xf8, 0xf9, 0x83, 0xda } };

#ifdef CONFIDENCE
// {7DFE11A7-FB5D-4958-8765-154ADF0D833F}
static const GUID GUID_CONFIDENCELEVEL = 
{ 0x7dfe11a7, 0xfb5d, 0x4958, { 0x87, 0x65, 0x15, 0x4a, 0xdf, 0x0d, 0x83, 0x3f } };
#endif

// {8CC24B27-30A9-4b96-9056-2D3A90DA0727}
static const GUID GUID_LINEMETRICS =
{ 0x8cc24b27, 0x30a9, 0x4b96, { 0x90, 0x56, 0x2d, 0x3a, 0x90, 0xda, 0x07, 0x27 } };

struct WispRec
{
    long unused;
};

struct WispLattice
{
    ULONG ulNumberOfColumns;
    RECO_RANGE *pRecoRange;
};

struct WispContext
{
    HRC hrc;
    RECO_GUIDE *pGuide;
    ULONG uiGuideIndex;
    BOOL bIsDirty;
    ULONG ulCurrentStrokeCount;
    // Lattice information
    struct WispLattice Lattice;
    // External Lattice structure
    RECO_LATTICE *pRecoLattice;
    WCHAR *pLatticeStringBuffer;
    RECO_LATTICE_PROPERTY *pLatticeProperties;
    BYTE *pLatticePropertyValues;
};

//
// New types using the new segmentation
///////////////////////////////////////////////////////
typedef struct tagWordPath
{
    ULONG ulLineSegmentationIndex;  // Index in the line segmentation array
    ULONG ulSegColIndex;            // index in the segmentation collection array 
    ULONG ulSegmentationIndex;      // index in the segmentation array
    ULONG ulWordMapIndex;           // index in the word map array
    ULONG ulIndexInWordMap;         // index of the alternate in the word map
    ULONG ulIndexInString;          // index in the string (used for reco ranges)
} WordPath;

typedef struct tagWispSegAlternate
{
    struct WispContext	*wisphrc;               // The handle to the Recognition Context
    ULONG				ulElementCount;         // Number of wordmaps in this alternate
    WordPath			*pElements;             // Array of WordPaths representing the WordMap paths
    ULONG				ulLength;               // Length of the alternate string
    RECO_RANGE			ReplacementRecoRange;   // The original range this alternate was queried for
    int                 iInfernoScore;          // The inferno score for this alternate
    // this score is used to determine order for alternate
    // from different segmentations
} WispSegAlternate;

/////////////////////////////////////////////////////
// Declare the GUIDs and consts of the Packet description
/////////////////////////////////////////////////////
const GUID g_guidx ={ 0x598a6a8f, 0x52c0, 0x4ba0, { 0x93, 0xaf, 0xaf, 0x35, 0x74, 0x11, 0xa5, 0x61 } };
const GUID g_guidy = { 0xb53f9f75, 0x04e0, 0x4498, { 0xa7, 0xee, 0xc3, 0x0d, 0xbb, 0x5a, 0x90, 0x11 } };
const PROPERTY_METRICS g_DefaultPropMetrics = { LONG_MIN, LONG_MAX, PROPERTY_UNITS_DEFAULT, 1.0 };


HRESULT DestroyInternalAlternate(WispSegAlternate *wisphrcalt);

/////////////////////////////////////////////////////
// Helper function to bubble sort an array
/////////////////////////////////////////////////////
static BOOL SlowSort(ULONG *pTab, const ULONG ulSize)
{
    ULONG i, j, temp;
    BOOL bPermut;
    // Stupid bubble sort
    for (i = 0; i<ulSize; i++)
    {
        bPermut = FALSE;
        for (j = 0; j < ulSize-1-i; j++)
        {
            if (pTab[j] > pTab[j+1])
            {
                bPermut = TRUE;
                temp = pTab[j];
                pTab[j] = pTab[j+1];
                pTab[j+1] = temp;
            }
        }
        if (!bPermut) 
			return TRUE;
    }
    return TRUE;
}

HRESULT FreeNewRecoLattice(RECO_LATTICE *pRecoLattice, WCHAR *pLatticeStringBuffer, RECO_LATTICE_PROPERTY *pLatticeProperties, BYTE *pLatticePropertyValues);

/////////////////////////////////////////////////////
// Implementation of the Wisp Reco Apis
/////////////////////////////////////////////////////


// CreateRecognizer
//      Returns a recognizer handle to the recognizer 
//      corresponding to the passed CLSID. In the case
//      of this dll, we only support one CLSID so we will
//      not even check for the value of the clsid
//      (even if the clsid is null)
//
// Parameter:
//      pCLSID [in] : The pointer to the CLSID 
//                    that determines what recognizer we want
//      phrec [out] : The address of the returned recognizer
//                    handle.
//////////////////////////////////////////////////////////////////////
HRESULT WINAPI CreateRecognizer(CLSID *pCLSID, HRECOGNIZER *phrec)
{
	struct WispRec		*pRec;

    if (IsBadWritePtr(phrec, sizeof(HRECOGNIZER))) 
        return E_POINTER;
    // We only have one CLSID per recognizer so always return an hrec...

	pRec = (struct WispRec*)ExternAlloc(sizeof(*pRec));

	if (NULL == pRec)
	{
		return E_OUTOFMEMORY;
	}

	*phrec = (HRECOGNIZER)CreateTpgHandle(TPG_HRECOGNIZER, pRec);
	
	if (0 == *phrec)
	{
		ExternFree(pRec);
        return E_OUTOFMEMORY;
	}

    return S_OK;
}

// DestroyRecognizer
//      Destroys a recognizer handle. Free the associate memory
//
// Parameter:
//      hrec [in] : handle to the recognizer
/////////////////////////////////////////////////////////////
HRESULT WINAPI DestroyRecognizer(HRECOGNIZER hrec)
{
	struct WispRec		*pRec; 

	if (NULL == (pRec = (struct WispRec*)DestroyTpgHandle((HANDLE)hrec, TPG_HRECOGNIZER)) )
	{
        return E_POINTER;
	}

    if (!IsBadWritePtr(pRec, sizeof(*pRec)))
    {
        ExternFree(pRec);
    }

    return S_OK;
}

int getLANGSupported(HINSTANCE hInst, LANGID **ppPrimLang, LANGID **ppSecLang);

// GetRecoAttributes
//      This function returns the reco attributes corresponding 
//      to a given recognizer. Since we only have one recognizer 
//      type we always return the same things.
//
// Parameters:
//      hrc [in] :         The handle to the recognizer we want the
//                         the attributes for.
//      pRecoAttrs [out] : Address of the user allocated buffer
//                         to hold the reco attributes.
///////////////////////////////////////////////////////////////////////////
HRESULT WINAPI GetRecoAttributes(HRECOGNIZER hrec, RECO_ATTRS* pRecoAttrs)
{

    HRESULT                 hr = S_OK;
    HRSRC                   hrsrc = NULL;
    HGLOBAL                 hg = NULL;
    LPBYTE                  pv = NULL;
    WORD                    wCurrentCount = 0;
    WORD                    wRecognizerCount = 0;
    DWORD                   dwRecoCapa;
    WORD                    wLanguageCount;
    WORD                    *aLanguages;
    WORD                    iLang;

    if (IsBadWritePtr(pRecoAttrs, sizeof(RECO_ATTRS))) 
        return E_POINTER;
    
    ZeroMemory(pRecoAttrs, sizeof(RECO_ATTRS));

    // Load the recognizer friendly name
    if (0 == LoadStringW(g_hInstanceDll,                            // handle to resource module
                RESID_WISP_FRIENDLYNAME,                            // resource identifier
                pRecoAttrs->awcFriendlyName,                        // resource buffer
                sizeof(pRecoAttrs->awcFriendlyName) / sizeof(WCHAR) // size of buffer
                ))
    {
        hr = E_FAIL;
    }
    // Load the recognizer vendor name
    if (0 == LoadStringW(g_hInstanceDll,                           // handle to resource module
                RESID_WISP_VENDORNAME,                            // resource identifier
                pRecoAttrs->awcVendorName,                        // resource buffer
                sizeof(pRecoAttrs->awcVendorName) / sizeof(WCHAR) // size of buffer
                ))
    {
        hr = E_FAIL;
    }
    if (SUCCEEDED(hr))
    {
        // Load the resources
        hrsrc = FindResource(g_hInstanceDll, // module handle
                    (LPCTSTR)RESID_WISP_DATA,  // resource name
                    (LPCTSTR)RT_RCDATA   // resource type
                    );
        if (NULL == hrsrc)
        {
            // The resource is not found!
            ASSERT(NULL != hrsrc);
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        hg = LoadResource(
                g_hInstanceDll, // module handle
                hrsrc   // resource handle
                );
        if (NULL == hg)
        {
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        pv = (LPBYTE)LockResource(
            hg   // handle to resource
            );
        if (NULL == pv)
        {
            hr = E_FAIL;
        }
    }
    dwRecoCapa = *((DWORD*)pv);
    pv += sizeof(dwRecoCapa);
    wLanguageCount = *((WORD*)pv);
    pv += sizeof(wLanguageCount);
    aLanguages = (WORD*)pv;
    pv += wLanguageCount * sizeof(WORD);


    // Fill the reco attricute structure for this recognizer
    // Add the languages
    ASSERT(wLanguageCount < 64);
    for (iLang = 0; iLang < wLanguageCount; iLang++)
    {
        pRecoAttrs->awLanguageId[iLang] = aLanguages[iLang];
    }
    // End the list with a NULL
    pRecoAttrs->awLanguageId[wLanguageCount] = 0;
    // Add the recocapability flag
    pRecoAttrs->dwRecoCapabilityFlags = dwRecoCapa;
    return hr;

}

// CreateRecoContext
//      This function creates a reco context for a given recognizer
//      Since we only have one type of recognizers in this dll, 
//      always return the same kind of reco context.
//
// Parameters:
//      hrec [in] :  Handle to the recognizer we want to create a
//                   reco context for.
//      phrc [out] : Pointer to the returned reco context's handle
////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CreateContext(HRECOGNIZER hrec, HRECOCONTEXT *phrc)
{
    struct WispContext *pWispContext = NULL;
    
    if (!phrc) 
        return E_POINTER;

	if (IsBadWritePtr(phrc, sizeof(HRECOCONTEXT))) 
		return E_POINTER;
    
    pWispContext = (struct WispContext*)ExternAlloc(sizeof(struct WispContext));
    if (!pWispContext) 
        return E_OUTOFMEMORY;
    
    pWispContext->hrc = CreateCompatibleHRC(NULL, NULL);
    pWispContext->bIsDirty = FALSE;
    pWispContext->pGuide = NULL;
    // Set the Stroke array information
    pWispContext->ulCurrentStrokeCount = 0;
    pWispContext->pRecoLattice = NULL;
    pWispContext->Lattice.ulNumberOfColumns = 0;
    pWispContext->Lattice.pRecoRange = NULL;
    pWispContext->pLatticePropertyValues = NULL;
    pWispContext->pLatticeProperties = NULL;
    pWispContext->pLatticeStringBuffer = NULL;

    if ( pWispContext->hrc) 
    {
		*phrc = (HRECOCONTEXT)CreateTpgHandle(TPG_HRECOCONTEXT, pWispContext);

		if (*phrc != 0)
		{
			return S_OK;
		}
		else
		{
			DestroyHRC(pWispContext->hrc);
			ExternFree(pWispContext);
			return E_OUTOFMEMORY;
		}
    }
    // The WispContext is bad
    ExternFree(pWispContext);
    return E_FAIL;
}

// DestroyContext
//      Destroy a reco context and free the associated memory.
//
// Parameters:
//      hrc [in] : handle to the reco context to destroy
//////////////////////////////////////////////////////////////
HRESULT WINAPI DestroyContext(HRECOCONTEXT hrc)
{
    struct WispContext		*wisphrc;
	HRESULT					hr;
	
	if (NULL != (wisphrc = (struct WispContext*)DestroyTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
    {
        DestroyHRC(wisphrc->hrc);
        if (wisphrc->pGuide) 
            ExternFree(wisphrc->pGuide);
        if (wisphrc->Lattice.pRecoRange) 
            ExternFree(wisphrc->Lattice.pRecoRange);
        if (wisphrc->pRecoLattice) 
        {
            hr = FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
            wisphrc->pRecoLattice = NULL;
            wisphrc->pLatticeStringBuffer = NULL;
            wisphrc->pLatticePropertyValues = NULL;
            wisphrc->pLatticeProperties = NULL;
            ASSERT(SUCCEEDED(hr));
        }
        ExternFree(wisphrc);
        return S_OK;
    }

    return E_INVALIDARG;
}

// IRecognizer::GetResultPropertyList
const ULONG PROPERTIES_COUNT = 2;
HRESULT WINAPI GetResultPropertyList(HRECOGNIZER hrec, ULONG* pPropertyCount, GUID* pPropertyGuid)
{
    HRESULT hr = S_OK;
    
    if (IsBadWritePtr(pPropertyCount, sizeof(ULONG)))
    {
        return E_POINTER;
    }
    if (!pPropertyGuid)
    {
        *pPropertyCount = PROPERTIES_COUNT; // For now we support only two GUID properties
    }
    else
    {
        // Check the array
        if (PROPERTIES_COUNT > *pPropertyCount)
        {
            return TPC_E_INSUFFICIENT_BUFFER;
        }
        if (IsBadWritePtr(pPropertyGuid, sizeof(GUID)*(*pPropertyCount)))
        {
            return E_POINTER;
        }
        pPropertyGuid[0] = GUID_SEGMENTATION;
        pPropertyGuid[1] = GUID_LINENUMBER;
        *pPropertyCount = PROPERTIES_COUNT;
    }

    return hr;
}

// GetPreferredPacketDescription
//      Returns the preferred packet description for the recognizer
//      This is going to be x, y only for this recognizer
//
// Parameters:
//      hrec [in]                : The recognizer we want the preferred 
//                                 packet description for
//      pPacketDescription [out] : The packet description
/////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI GetPreferredPacketDescription(HRECOGNIZER hrec , PACKET_DESCRIPTION* pPacketDescription)
{
    if (IsBadWritePtr(pPacketDescription, sizeof(PACKET_DESCRIPTION)))
    {
        return E_POINTER;
    }
    
    // We can be called the first time with pPacketProperies
    // equal to NULL, just to get the size of those buffer
    // The second time we get called thoses buffers are allocated, so 
    // we can fill them with the data.
    if (pPacketDescription->pPacketProperties)
    {
        // Set the packet size to the size of x and y
        pPacketDescription->cbPacketSize = 2 * sizeof(LONG);
        
        // We are only setting 2 properties (X and Y)
		if (pPacketDescription->cPacketProperties < 2)
			return TPC_E_INSUFFICIENT_BUFFER;
        pPacketDescription->cPacketProperties = 2;
        
        // We are not setting buttons
        pPacketDescription->cButtons = 0;
        
        // Make sure that the pPacketProperties is of a valid size
        if (IsBadWritePtr(pPacketDescription->pPacketProperties, 2 * sizeof(PACKET_PROPERTY)))
            return E_POINTER;
        
        // Fill in pPacketProperies
        // Add the GUID_X
        pPacketDescription->pPacketProperties[0].guid = g_guidx;
        pPacketDescription->pPacketProperties[0].PropertyMetrics = g_DefaultPropMetrics;
        
        // Add the GUID_Y
        pPacketDescription->pPacketProperties[1].guid = g_guidy;
        pPacketDescription->pPacketProperties[1].PropertyMetrics = g_DefaultPropMetrics;
    }
    else
    {
        // Just fill in the PacketDescription structure leaving NULL
        // pointers for the pguidButtons and pPacketProperies
        
        // Set the packet size to the size of x and y
        pPacketDescription->cbPacketSize = 2*sizeof(LONG);
        
        // We are only setting 2 properties (X and Y)
        pPacketDescription->cPacketProperties = 2;
        
        // We are not setting buttons
        pPacketDescription->cButtons = 0;
        
        // There are not guid buttons
        pPacketDescription->pguidButtons = NULL;
    }
    return S_OK;
}

int _cdecl CompareWCHAR(const void *arg1, const void *arg2)
{
    return (int)(*(WCHAR*)arg1) - (int)(*(WCHAR*)arg2);
}

// GetUnicodeRanges
//
// Parameters:
//		hrec [in]			:	Handle to the recognizer
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
GetUnicodeRanges(HRECOGNIZER hrec,
				 ULONG	*pcRanges,
				 CHARACTER_RANGE *pcr)
{
	WCHAR aw[256], *pw;
	int cChar, i;
	ULONG cRange;
	HRESULT hr = S_OK;

	/* the following two externs are language dependent and defined in Avalanche (charSupport.c) */
	extern const unsigned char g_supportChar[] ;
	extern const int g_cSupportChar ;
	
	if ( IsBadWritePtr(pcRanges, sizeof(ULONG)) )
        return E_POINTER;

	// convert the array of supported characters from codepage 1252 to Unicode
	ASSERT(g_cSupportChar);
	for (pw=aw, i=0; i<g_cSupportChar; i++)
	{
		if (CP1252ToUnicode(g_supportChar[i], pw))
			pw++;
	}
	cChar = pw - aw;
	if (cChar <= 0)
	{
		*pcRanges = 0;
		return S_OK;
	}
    qsort((void*)aw, (size_t)cChar, sizeof(WCHAR), CompareWCHAR);

	// count the ranges
	cRange = 1;
	for (i=1; i<cChar; i++)
	{
		if (aw[i] > aw[i-1]+1)
			cRange++;
	}

	if (!pcr)	// Need only a count of ranges
	{
		*pcRanges = cRange;
		return S_OK;
	}
	
	if (*pcRanges < cRange)
	{
		if (*pcRanges == 0)
			return TPC_S_TRUNCATED;
		hr = TPC_S_TRUNCATED;
		cRange = *pcRanges;
	}

	if ( IsBadWritePtr(pcr, cRange * sizeof(CHARACTER_RANGE)) )
		return E_POINTER;

	// convert the array of Unicode values to an array of CHARACTER_RANGEs
	*pcRanges = cRange;
	pcr->wcLow = aw[0];
	pcr->cChars = 1;
	cRange--;  // how many more ranges does pcr have space for?
	for (i=1; i<cChar; i++)
	{
		if (aw[i] == aw[i-1]+1)
			pcr->cChars++;
		else if (cRange <= 0)
			break;
		else
		{
			pcr++;
			pcr->wcLow = aw[i];
			pcr->cChars = 1;
			cRange--;  // how many more ranges does pcr have space for?
		}
	}
	ASSERT(cRange==0);

	return hr;
}

// GetEnabledUnicodeRanges
//
// Parameters:
//		hrc [in]			:	Handle to the recognition context
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
GetEnabledUnicodeRanges(HRECOCONTEXT hrc,
						ULONG	*pcRanges,
						CHARACTER_RANGE *pcr)
{
	// for now just return the default
	return GetUnicodeRanges((HRECOGNIZER)NULL, pcRanges, pcr);
}


// SetEnabledUnicodeRanges
//
// Parameters:
//		hrc [in]			:	Handle to the recognition context
//		pcRanges [in/out]	:	Count of ranges
//		pcr [out]			:	Array of character ranges
////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
SetEnabledUnicodeRanges(HRECOCONTEXT hrc,
						ULONG	cRanges,
						CHARACTER_RANGE *pcr)
{
	return E_NOTIMPL;
}

/**********************************************************************/
// Convert double to int
#define FUZZ_GEN	(1e-9)		// general fuzz - nine decimal digits
int RealToInt(
	double dbl
	){
	/* Add in the rounding threshold.  
	 *
	 * NOTE: The MAXWORD bias used in the floor function
	 * below must not be combined with this line. If it
	 * is combined the effect of FUZZ_GEN will be lost.
	 */
	dbl += 0.5 + FUZZ_GEN;
	
	/* Truncate
	 *
	 * The UINT_MAX bias in the floor function will cause
	 * truncation (rounding toward minuse infinity) within
	 * the range of a short.
	 */
	dbl = floor(dbl + UINT_MAX) - UINT_MAX;
	
	/* Clip the result.
	 */
	return 	dbl > INT_MAX - 7 ? INT_MAX - 7 :
			dbl < INT_MIN + 7 ? INT_MIN + 7 :
			(int)dbl;
	}
/**********************************************************************/
// Transform POINT array in place
static void Transform(const XFORM *pXf, POINT * pPoints, ULONG cPoints)
{
    ULONG iPoint = 0;
    LONG xp = 0;

    if(NULL != pXf)
    {
		ASSERT((cPoints == 0) || pPoints);
        for(iPoint = 0; iPoint < cPoints; ++iPoint)
        {
	        xp =  RealToInt(pPoints[iPoint].x * pXf->eM11 + pPoints[iPoint].y * pXf->eM21 + pXf->eDx);
	        pPoints[iPoint].y = RealToInt(pPoints[iPoint].x * pXf->eM12 + pPoints[iPoint].y * pXf->eM22 + pXf->eDy);
	        pPoints[iPoint].x = xp;
        }
    }
}

HRESULT WINAPI AddStroke(HRECOCONTEXT hrc, const PACKET_DESCRIPTION* pPacketDesc, ULONG cbPacket, const BYTE *pPacket, const XFORM *pXForm)
{
    HRESULT					hr = S_OK;
    ULONG					ulPointCount = 0;
    STROKEINFO				stInfo;
    POINT					*ptArray = NULL;
    struct WispContext		*wisphrc;
    ULONG					ulXIndex = 0, ulYIndex = 0;
    BOOL					bXFound = FALSE, bYFound = FALSE;
    ULONG					ulPropIndex = 0;
    ULONG					index = 0;
    
    const LONG* pLongs = (const LONG *)(pPacket);
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if(IsBadReadPtr(pPacket, cbPacket))
        return E_POINTER;
    
    wisphrc->bIsDirty = TRUE;
    // Get the number of packets
    if (pPacketDesc)
    {
		if(IsBadReadPtr(pPacketDesc, sizeof(PACKET_DESCRIPTION)))
			return E_POINTER;
        ASSERT(!(cbPacket%(pPacketDesc->cbPacketSize)));
        ulPointCount = (cbPacket)/(pPacketDesc->cbPacketSize);
    }
    else
    {
        ulPointCount = (cbPacket)/(2*sizeof(LONG));
    }
    
    // Fill in the stroke info stucture
    // Should check it does not exceed the size of a UINT
    stInfo.cPnt = ulPointCount;
    // PLEASE FIND ANOTHER WAY TO STORE THE STROKE INDEX!!!
    stInfo.dwTick = wisphrc->ulCurrentStrokeCount*60*1000;
    stInfo.wPdk = 0x0001;
    stInfo.cbPnts = ulPointCount*sizeof(POINT);
    
    wisphrc->ulCurrentStrokeCount++;
    
    // Find the index of GUID_X and GUID_Y
    if (pPacketDesc)
    {
        for (ulPropIndex = 0; ulPropIndex < pPacketDesc->cPacketProperties; ulPropIndex++)
        {
            if (IsEqualGUID(&(pPacketDesc->pPacketProperties[ulPropIndex].guid), &g_guidx))
            {
                bXFound = TRUE;
                ulXIndex = ulPropIndex;
            }
            else
                if (IsEqualGUID(&(pPacketDesc->pPacketProperties[ulPropIndex].guid), &g_guidy))
                {
                    bYFound = TRUE;
                    ulYIndex = ulPropIndex;
                }
                if (bXFound && bYFound) 
                    break;
        }
        if (!bXFound || !bYFound)
        {
            // The coordinates are not part of the packet!
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            return TPC_E_INVALID_PACKET_DESCRIPTION;
        }
		if (pXForm && IsBadReadPtr(pXForm, sizeof(XFORM)))
			return E_POINTER;
        // Allocate the memory for the stroke
        // Do it very poorly first (we could reuse the buffer)
        ptArray = (POINT*)ExternAlloc(ulPointCount*sizeof(POINT));
        if (!ptArray)
        {
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            return E_OUTOFMEMORY;
        }
        // Get the points from the packets
        for (index = 0; index < ulPointCount; index++, pLongs += (pPacketDesc->cbPacketSize)/sizeof(long))
        {
            // Feed the ptArray (array of points)
            ptArray[index].x = *(pLongs+ulXIndex);
            ptArray[index].y = *(pLongs+ulYIndex);
        }

        // TO DO, for now I transform the points so they
        // they are in the ink coordinates. It is up to
        // the recognizer team to decide what they should
        // use: raw ink or transformed ink
		// The pXForm pointer has been validated above.
        Transform(pXForm, ptArray, ulPointCount);
        
        if (AddPenInputHRC(wisphrc->hrc, ptArray, NULL, 0, &stInfo) != HRCR_OK)
        {
            hr = E_FAIL;
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            ExternFree(ptArray);
            return hr;
        }
        ExternFree(ptArray);
    }
    else
    {
        if (AddPenInputHRC(wisphrc->hrc, (POINT*)pPacket, NULL, 0, &stInfo) != HRCR_OK)
        {
            hr = E_FAIL;
            // Remove the last stroke from the stroke array
            wisphrc->ulCurrentStrokeCount--;
            return hr;
        }
    }
    ptArray = NULL;
    return hr;
}

HRESULT WINAPI GetBestResultString(HRECOCONTEXT hrc, ULONG *pcwSize, WCHAR* pszBestResult)
{
    struct WispContext		*wisphrc;
    HRCRESULT				aRes = 0;
    HRESULT					hr = S_OK;
    XRCRESULT				*xrcresult = NULL;
    XRC						*xrc;
    
    int						iLineSeg = 0, iSegCol = 0, iWordMap = 0, i;
    LINE_SEGMENTATION		*pLineSeg = NULL;
    SEGMENTATION			*pSeg = NULL;
    unsigned char			*szResult = NULL, *sz = NULL;
    ULONG					cwResultSize = 0;
    ULONG                            ulMaxLength = 0;
	WCHAR					*wsz;

	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (!pcwSize) 
        return E_POINTER;
    if (IsBadWritePtr(pcwSize, sizeof(ULONG))) 
        return E_POINTER;
    
    // Get the xrc out of the hwx hrc
    xrc = (XRC*)wisphrc->hrc;   // assumption: the internal handle HRC is simply a typecast of a pointer
    if (IsBadReadPtr(xrc, sizeof(XRC))) 
        return E_POINTER;
    
    // Do we have anything to return?
    if (!xrc->pLineBrk || !xrc->pLineBrk->cLine)
    {
        *pcwSize = 0;
        return S_OK;
    }
    
    // Are we looking for the size only?
    if (!pszBestResult)
    {
        *pcwSize = 0;
        // Go through each line segmentation
        for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
        {
            pLineSeg = xrc->pLineBrk->pLine[iLineSeg].pResults;
            // for each line segmentation get go through each columns segmentation
            for (iSegCol = 0; iSegCol < pLineSeg->cSegCol; iSegCol++)
            {
                ASSERT(xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg);
                pSeg = pLineSeg->ppSegCol[iSegCol]->ppSeg[0];
                // For each acolumn segmentation look into each wordmap
                for (iWordMap = 0; iWordMap < pSeg->cWord; iWordMap++)
                {
                    ASSERT(pSeg->ppWord[iWordMap]->pFinalAltList->cAlt);
                    (*pcwSize) += strlen(pSeg->ppWord[iWordMap]->pFinalAltList->pAlt[0].pszStr) + 1;
                    // The 1 is added for the space between words
                }
            }
        }
        if (*pcwSize)
        {
			(*pcwSize)--; // Remove the very last space
        }
        return S_OK;
    }
    
    // We are looking for the string as well
    // Go through each line segmentation
	if (IsBadWritePtr(pszBestResult, (*pcwSize)*sizeof(WCHAR)))
		return E_POINTER;
    cwResultSize = 0;
    for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
    {
        pLineSeg = xrc->pLineBrk->pLine[iLineSeg].pResults;
        // for each line segmentation get go through each columns segmentation
        for (iSegCol = 0; iSegCol < pLineSeg->cSegCol; iSegCol++)
        {
            ASSERT(xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg);
            pSeg = pLineSeg->ppSegCol[iSegCol]->ppSeg[0];
            // For each acolumn segmentation look into each wordmap
            for (iWordMap = 0; iWordMap < pSeg->cWord; iWordMap++)
            {
                ASSERT(pSeg->ppWord[iWordMap]->pFinalAltList->cAlt);
                szResult = pSeg->ppWord[iWordMap]->pFinalAltList->pAlt[0].pszStr;
                ulMaxLength = *pcwSize - cwResultSize;
                if (strlen(szResult) <= ulMaxLength)
                    ulMaxLength = strlen(szResult);
                else
                	hr = TPC_S_TRUNCATED;

				// convert 1252 to Unicode
				sz = szResult;
				wsz = pszBestResult + cwResultSize;
				for (i=ulMaxLength; i; i--)
				{
					if (!CP1252ToUnicode(*sz++, wsz++))
					{
						ASSERT(0);
						return E_FAIL;
					}
				}
				cwResultSize += ulMaxLength;
                // Add the final space if there is room
                if (*pcwSize - cwResultSize && 
                    !(iWordMap==pSeg->cWord-1 && iSegCol == pLineSeg->cSegCol-1 && iLineSeg == xrc->pLineBrk->cLine-1))
                {
					pszBestResult[cwResultSize++] = L' ';
                }
                // if we do not have a buffer big enough set the hr to a relevant value
                if (*pcwSize == cwResultSize &&
                    !(iWordMap==pSeg->cWord-1 && iSegCol == pLineSeg->cSegCol-1 && iLineSeg == xrc->pLineBrk->cLine-1))
                {
                    hr = TPC_S_TRUNCATED;
                }
            }
        }
    }
    *pcwSize = cwResultSize;
    return hr;
}

// UpdateLatticeInformation
// This function is used to update (if needed) the lattice information
// store in the wisp context
HRESULT UpdateLatticeInformation(HRECOCONTEXT hrc, ULONG *pulLength)
{
    struct WispContext		*wisphrc;
    ULONG 					ulSize = 0;
    WCHAR					*szBestResult = NULL;
    ULONG					ulCount = 0;
    WCHAR					*szTemp = NULL, *szT = NULL;
    ULONG					index = 0, ulCurrent = 0;
    HRESULT					hr = S_OK;
    
    // First get the size of the best result
    hr = GetBestResultString(hrc, &ulSize, NULL);
    if (FAILED(hr)) 
        return hr;
    if (!ulSize) 
        return S_OK;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

	if (IsBadWritePtr(pulLength, sizeof(ULONG)))
		return E_POINTER;

    // Get the Best result string
    *pulLength = ulSize;
    // is it needed?
    if (wisphrc->Lattice.pRecoRange) 
		return S_OK;
    
    szBestResult = (WCHAR*)ExternAlloc((ulSize+1)*sizeof(WCHAR));
    if (!szBestResult) 
        return E_OUTOFMEMORY;
    
    ZeroMemory(szBestResult, (ulSize+1)*sizeof(WCHAR));
    hr = GetBestResultString(hrc, &ulSize, szBestResult);
    if (FAILED(hr) || !ulSize)
    {
        ExternFree(szBestResult);
        return hr;
    }
    // Now parse the string to find the spaces
    // First get the number of spaces
    szTemp = szBestResult;
    ulCount = 1;
    // Let us not count the spaces as relevant columns
    while(szTemp = wcschr(szTemp, L' '))
    {
        ulCount++;
        szTemp++;
    }
    // Now fill the information in the lattice
    wisphrc->Lattice.pRecoRange = (RECO_RANGE*)ExternAlloc(ulCount * sizeof(RECO_RANGE));
    if (!wisphrc->Lattice.pRecoRange)
    {
        ExternFree(szBestResult);
        return E_OUTOFMEMORY;
    }
    
    szTemp = szBestResult;
    ulCurrent = 0;
    for (index = 0; index <ulCount-1; index++)
    {
        wisphrc->Lattice.pRecoRange[index].iwcBegin = ulCurrent;
        szT = szTemp;
        szTemp = wcschr(szTemp, L' ');
        wisphrc->Lattice.pRecoRange[index].cCount = ((ULONG)(szTemp-szT)) ;//-1; // minus the space
        ulCurrent += (ULONG)(szTemp-szT);
        szTemp++;
        ulCurrent++;
    }
    // Let us do the last
    wisphrc->Lattice.pRecoRange[ulCount -1 ].iwcBegin = ulCurrent;
    wisphrc->Lattice.pRecoRange[ulCount -1 ].cCount = ulSize-ulCurrent;	
    wisphrc->Lattice.ulNumberOfColumns = ulCount;
    
    ExternFree(szBestResult);
    return S_OK;
}
    
HRESULT WINAPI SetGuide(HRECOCONTEXT hrc, const RECO_GUIDE* pGuide, ULONG iIndex)
{
    struct WispContext      *wisphrc;
    BOOL                    bIsGuideAlreadySet = FALSE;
    RECO_GUIDE              rgOldGuide;
    ULONG                   uiOldGuideIndex = 0;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    
	// pGuide can be NULL, meaning change to free mode
    if (pGuide && IsBadReadPtr(pGuide, sizeof(RECO_GUIDE))) 
        return E_POINTER;
    
    // Save the old values in case the call to the
    // recognizer fails
    if (wisphrc->pGuide)
    {
        bIsGuideAlreadySet = TRUE;
        rgOldGuide = *(wisphrc->pGuide);
        uiOldGuideIndex = wisphrc->uiGuideIndex;
    }
    
	if (pGuide != NULL)
	{ 
		if ((pGuide->cHorzBox < 0 || pGuide->cVertBox < 0) ||    // invalid
			(pGuide->cHorzBox > 0 && pGuide->cVertBox > 0) ||	 // boxed mode
			(pGuide->cHorzBox > 0 && pGuide->cVertBox == 0))     // vertical lined mode
		{
			return E_INVALIDARG;
		}
	}     
         
    // If there was no guide already present, allocate one
    if (!wisphrc->pGuide) 
        wisphrc->pGuide = ExternAlloc(sizeof(RECO_GUIDE));
    if (!wisphrc->pGuide) 
        return E_OUTOFMEMORY;

	if (pGuide)
    *(wisphrc->pGuide) = *pGuide;
	else
		ZeroMemory(wisphrc->pGuide, sizeof(RECO_GUIDE));
    wisphrc->uiGuideIndex = iIndex;
    
    // Other wise use as normal
    if (HRCR_OK == SetGuideHRC(wisphrc->hrc, (GUIDE*)pGuide, iIndex))
        return S_OK;
    
    // We could not set the guide correctly
    // Put back things as they were
    if (bIsGuideAlreadySet)
    {
        *(wisphrc->pGuide) = rgOldGuide;
        wisphrc->uiGuideIndex = uiOldGuideIndex;
    }
    else
    {
        ExternFree(wisphrc->pGuide);
        wisphrc->pGuide = NULL;
    }
    return E_INVALIDARG;
}

HRESULT WINAPI GetGuide(HRECOCONTEXT hrc, RECO_GUIDE* pGuide, ULONG *piIndex)
{
    struct WispContext		*wisphrc;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pGuide, sizeof(RECO_GUIDE))) 
        return E_POINTER;
    if (IsBadWritePtr(piIndex, sizeof(ULONG))) 
        return E_POINTER;

    if (!wisphrc->pGuide) 
        return S_FALSE;

    if (wisphrc->pGuide) 
        *pGuide = *(wisphrc->pGuide);
    if (piIndex) 
        *piIndex = wisphrc->uiGuideIndex;

    return S_OK;
}
HRESULT WINAPI AdviseInkChange(HRECOCONTEXT hrc, BOOL bNewStroke)
{
    // Kludge for now
    return S_OK;
}
HRESULT WINAPI SetCACMode(HRECOCONTEXT hrc, int iMode)
{
    return E_NOTIMPL;
}

HRESULT WINAPI EndInkInput(HRECOCONTEXT hrc)
{
    struct WispContext		*wisphrc;

	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (HRCR_OK == EndPenInputHRC(wisphrc->hrc))
        return S_OK;
    return E_FAIL;
}

HRESULT WINAPI CloneContext(HRECOCONTEXT hrc, HRECOCONTEXT* pCloneHrc)
{
    struct WispContext		*pWispContext = NULL;
    struct WispContext		*wisphrc;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pCloneHrc, sizeof(HRECOCONTEXT))) 
        return E_POINTER;
    
    pWispContext = (struct WispContext*)ExternAlloc(sizeof(struct WispContext));
    if (!pWispContext) 
        return E_OUTOFMEMORY;
    
    pWispContext->hrc = CreateCompatibleHRC(wisphrc->hrc, NULL);
    if (!pWispContext->hrc)
    {
        ExternFree(pWispContext);
        return E_FAIL;
    }
    
    pWispContext->bIsDirty = FALSE;
    pWispContext->pGuide = NULL;
    if (wisphrc->pGuide)
    {
        pWispContext->pGuide = ExternAlloc(sizeof(RECO_GUIDE));
        if (!pWispContext->pGuide)
        {
            DestroyHRC(pWispContext->hrc);
            ExternFree(pWispContext);
            return E_OUTOFMEMORY;
        }
        *(pWispContext->pGuide) = *(wisphrc->pGuide);
        pWispContext->uiGuideIndex = wisphrc->uiGuideIndex;
    }
    // Set the Stroke array information
    pWispContext->ulCurrentStrokeCount = 0;
    pWispContext->pRecoLattice = NULL;
    pWispContext->Lattice.ulNumberOfColumns = 0;
    pWispContext->Lattice.pRecoRange = NULL;
    // Lattice related stuff
    pWispContext->pLatticeStringBuffer= NULL;
    pWispContext->pLatticeProperties= NULL;
    pWispContext->pLatticePropertyValues= NULL;

	*pCloneHrc = (HRECOCONTEXT)CreateTpgHandle(TPG_HRECOCONTEXT, pWispContext);

	if (0 == *pCloneHrc)
	{
		DestroyHRC(pWispContext->hrc);
		ExternFree(pWispContext);
		return E_OUTOFMEMORY;
	}
 
    return S_OK;
}

HRESULT WINAPI ResetContext(HRECOCONTEXT hrc)
{
    HRESULT hr = S_OK;
    struct WispContext		*wisphrc;
    HRC						hrctemp = NULL;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    
    wisphrc->bIsDirty = FALSE;
    if (wisphrc->Lattice.pRecoRange)
        ExternFree(wisphrc->Lattice.pRecoRange);
    wisphrc->Lattice.pRecoRange = NULL;
    wisphrc->Lattice.ulNumberOfColumns = 0;
    
    wisphrc->ulCurrentStrokeCount = 0;
    
    if (wisphrc->pRecoLattice) 
    {
        hr = FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
        ASSERT(SUCCEEDED(hr));
        hr = S_OK;
        wisphrc->pRecoLattice = NULL;
        wisphrc->pLatticeStringBuffer = NULL;
        wisphrc->pLatticeProperties = NULL;
        wisphrc->pLatticePropertyValues = NULL;
    }
    
    hrctemp = CreateCompatibleHRC(wisphrc->hrc, NULL);
    if (!hrctemp) 
    {
        // Clean the hrc
        if (wisphrc->pGuide) 
			ExternFree(wisphrc->pGuide);
        wisphrc->pGuide = NULL;
        hr = E_FAIL;
    }
    DestroyHRC(wisphrc->hrc);
    wisphrc->hrc = hrctemp;
    return hr;
}

HRESULT WINAPI SetTextContext(HRECOCONTEXT hrc, ULONG cwcBefore, const WCHAR*pwcBefore, ULONG cwcAfter, const WCHAR*pwcAfter)
{
    HRESULT hr = S_OK;
    WCHAR *pszPrefix = NULL, *pszSuffix = NULL;
    struct WispContext		*wisphrc;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (cwcBefore && IsBadReadPtr(pwcBefore, sizeof(WCHAR)*cwcBefore))
        return E_POINTER;
    if (cwcAfter && IsBadReadPtr(pwcAfter, sizeof(WCHAR)*cwcAfter))
        return E_POINTER;
    
    if (cwcBefore)
    {
        pszPrefix = (WCHAR*)ExternAlloc(sizeof(WCHAR)*(cwcBefore+1));
        if (!pszPrefix)
		{
            return E_OUTOFMEMORY;
		}
		memcpy(pszPrefix, pwcBefore, cwcBefore * sizeof(*pszPrefix));
		pszPrefix[cwcBefore] = L'\0';
    }

    if (cwcAfter)
    {
        pszSuffix = (WCHAR*)ExternAlloc(sizeof(WCHAR)*(cwcAfter+1));
        if (!pszSuffix)
        {
            ExternFree(pszPrefix);
            return E_OUTOFMEMORY;
        }
		memcpy(pszSuffix, pwcAfter, cwcAfter * sizeof(*pszSuffix));
		pszSuffix[cwcAfter] = L'\0';
    }
    if (!SetHwxCorrectionContext(wisphrc->hrc, pszPrefix, pszSuffix))
        hr = E_FAIL;
    if (pszPrefix) 
		ExternFree(pszPrefix);
    if (pszSuffix) 
		ExternFree(pszSuffix);
    return hr;
}

HRESULT WINAPI Process(HRECOCONTEXT hrc, BOOL *pbPartialProcessing)
{
    struct WispContext		*wisphrc;
    XRC						*xrc = NULL;
	DWORD					dwRecoMode;
	int						iRet;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (!wisphrc->hrc) 
        return E_POINTER;
    if (IsBadWritePtr(pbPartialProcessing, sizeof(BOOL)))
        return E_POINTER;
    
    // Kludge for now
    xrc = (XRC*)wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC)))
        return E_POINTER;
    
    wisphrc->bIsDirty = FALSE;
    if (!xrc->pGlyph) // There is no ink yet
    {
        (*pbPartialProcessing)	=	FALSE;
        return S_OK;
    }

	if (*pbPartialProcessing)
	{
		dwRecoMode	=	RECO_MODE_INCREMENTAL;
	}
	else
	{
		dwRecoMode	=	RECO_MODE_REMAINING;
	}

	iRet = ProcessHRC(wisphrc->hrc, dwRecoMode);

	// success
	if (iRet == HRCR_OK || iRet == HRCR_INCOMPLETE)
    {
        // Free the lattice information since it is now invalid
        if (wisphrc->Lattice.pRecoRange)
        {
            ExternFree(wisphrc->Lattice.pRecoRange);
            wisphrc->Lattice.pRecoRange = NULL;
            wisphrc->Lattice.ulNumberOfColumns = 0;
        }
    }
	// do we have any un recognized ink
	if (iRet == HRCR_OK || iRet == HRCR_COMPLETE || iRet == HRCR_NORESULTS)
	{
		(*pbPartialProcessing)	=	FALSE;
        return S_OK;
	}
	if (iRet == HRCR_INCOMPLETE)
	{
		(*pbPartialProcessing)	=	TRUE;
        return S_OK;
	}
    return E_FAIL;
}

HRESULT WINAPI SetFactoid(HRECOCONTEXT hrc, ULONG cwcFactoid, const WCHAR* pwcFactoid)
{
	WCHAR *awcFactoid = NULL;
    struct WispContext		*wisphrc;
    HRESULT hr = S_OK;

	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
		return E_POINTER;
	}

    if (cwcFactoid)
    {
		if (IsBadReadPtr(pwcFactoid, cwcFactoid * sizeof(*pwcFactoid)))
		{
			return E_POINTER;
		}

        awcFactoid = (WCHAR*)ExternAlloc(sizeof(WCHAR)*(cwcFactoid+1));
        if (!awcFactoid)
            return E_OUTOFMEMORY;

		memcpy(awcFactoid, pwcFactoid, cwcFactoid * sizeof(*awcFactoid));
		awcFactoid[cwcFactoid] = L'\0';
	}

    switch(SetHwxFactoid(wisphrc->hrc, awcFactoid))
	{
	case HRCR_OK:
		break;
	case HRCR_UNSUPPORTED:
		hr = TPC_E_INVALID_PROPERTY;
		break;
	case HRCR_CONFLICT:
		hr = TPC_E_OUT_OF_ORDER_CALL;
		break;
	case HRCR_ERROR:
	default:
		hr = E_FAIL;
		break;
	}

    if (awcFactoid) 
		ExternFree(awcFactoid);

    return hr;
}

HRESULT WINAPI SetFlags(HRECOCONTEXT hrc, DWORD dwFlags)
{
    struct WispContext		*wisphrc;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
    
    if (SetHwxFlags(wisphrc->hrc, dwFlags))
        return S_OK;
    else
        return E_INVALIDARG;
}

HRESULT WINAPI IsStringSupported(HRECOCONTEXT hrc, ULONG cwcString, const WCHAR *pwcString)
{
    struct WispContext		*wisphrc;
    unsigned char           *tempBuffer, *pszTmp;
	const WCHAR				*pwTmp, *pwMax;
    ULONG                   ulSize = 0;
    HRESULT                 hr = S_OK;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (NULL == pwcString) 
	{
        return E_POINTER;
	}

    if (0 == cwcString)
	{
        return E_INVALIDARG;
	}

	if (IsBadReadPtr(pwcString, cwcString * sizeof(*pwcString)))
	{
        return E_POINTER;
	}

    tempBuffer = (unsigned char*)ExternAlloc(cwcString+1);
    if (!tempBuffer)
        return E_OUTOFMEMORY;

	// Use internal conversion that does not do unwanted mapping
	pwTmp = pwcString;
	pwMax = pwcString + cwcString;
	pszTmp = tempBuffer;

	while (pwTmp < pwMax && *pwTmp)
	{
		if (!UnicodeToCP1252(*pwTmp++, pszTmp++))
		{
			ExternFree(tempBuffer);
			return S_FALSE;
		}
	}

	*pszTmp = '\0';

    if (IsStringSupportedHRC(wisphrc->hrc, tempBuffer))
	{
        hr = S_OK;
	}
    else
	{
        hr = S_FALSE;
	}

    ExternFree(tempBuffer);
    return hr;
}

// Definition of structures used in the GetAllBreaksAlt function:
typedef struct tagLineSegAlt
{
    ULONG           cWM;                // Count of WordMaps in this alternate
    WordPath        *aWordPaths;        // Array of elements defining the alternate
    // for this line seg
    int             score;              // Score for this alternate
} LineSegAlt;

//
// Declaration of the helper functions for the
// new segmentation
////////////////////////////////////////////////////////
HRESULT GetIndexesFromRange(WispSegAlternate *wispalt, RECO_RANGE *pRecoRange, ULONG *pulStartIndex, ULONG *pulEndIndex);
HRESULT GetSameBreakAlt(WispSegAlternate *wispbestalt, RECO_RANGE *pOriginalRecoRange, ULONG ulStartIndex, ULONG ulEndIndex, ULONG *pSize, HRECOALT *phrcalt);
HRESULT GetAllBreaksAlt(WispSegAlternate *wispbestalt, RECO_RANGE *pOriginalRecoRange, ULONG ulStartIndex, ULONG ulEndIndex, ULONG *pSize, HRECOALT *phrcalt);
HRESULT GetDiffBreaksAlt(WispSegAlternate *wispbestalt, RECO_RANGE *pOriginalRecoRange, ULONG ulStartIndex, ULONG ulEndIndex, ULONG *pSize, HRECOALT *phrcalt);
HRESULT CreateSpaceAlternate(struct WispContext *wisphrc, RECO_RANGE *pRecoRange, HRECOALT *pRecoAlt);
void FreeSegColAltArray(LineSegAlt *aSegColCurrentAlts, const int cElements);
HRESULT MergeLineSegAltArrays(LineSegAlt **paAlts, ULONG *pcAlts, LineSegAlt **paNewAlts, const ULONG cNewAlts);
int _cdecl CompareInfernoAlt(const void *arg1, const void *arg2);
BOOL IsAltPresentInThisSegmentation(const XRC *xrc, const LineSegAlt *aAlts, ULONG ulAlt);
BOOL CombineAlternates(HRECOALT *aFinalAlt, 
                       ULONG *pFinalAltCount, 
                       const ULONG ulMaxCount, 
                       const HRECOALT *aAddAlt, 
                       const ULONG ulAddAltCount,
                       HRECOALT *aBufferAlt);


HRESULT WINAPI GetPropertyRanges(HRECOALT hrcalt, const GUID *pPropertyGuid, ULONG* pcRanges, RECO_RANGE* pRecoRange)
{
    // The implementation is going to be significantly different for
    // each property we are going to try to expose
    HRESULT             hr = S_OK;
    WispSegAlternate	*wispalt;
    ULONG               ulRangeCount = 0;
    ULONG               ulCurrentRange = 0, iElem = 0;
    

	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
    {
        return E_POINTER;
    }
    if (IsBadReadPtr(pPropertyGuid, sizeof(GUID)))
    {
        return E_POINTER;
    }

    // Let us expose the line number
    if (IsEqualGUID(pPropertyGuid, &GUID_LINENUMBER))
    {
        ULONG     ulCurrentLineNumber = 0;

        ulRangeCount = wispalt->pElements[wispalt->ulElementCount-1].ulLineSegmentationIndex - 
            wispalt->pElements[0].ulLineSegmentationIndex + 1;
        // Do we want the ranges or the number of ranges?
        if (pRecoRange)
        {
            // We want the ranges. Do we have enough in the buffer?
            if (ulRangeCount != *pcRanges)
                return TPC_E_INSUFFICIENT_BUFFER;
            if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)*ulRangeCount))
                return E_POINTER;
            // Let's get to it
            ulCurrentRange = 0;
            ulCurrentLineNumber = wispalt->pElements[0].ulLineSegmentationIndex;
            pRecoRange[ulCurrentRange].iwcBegin = 0;
            for (iElem = 1; iElem < wispalt->ulElementCount; iElem++)
            {
                if (wispalt->pElements[iElem].ulLineSegmentationIndex !=
                    ulCurrentLineNumber)
                {
                    ulCurrentLineNumber = wispalt->pElements[iElem].ulLineSegmentationIndex;
                    pRecoRange[ulCurrentRange].cCount = wispalt->pElements[iElem].ulIndexInString -
                        pRecoRange[ulCurrentRange].iwcBegin;
                    ulCurrentRange++;
                    pRecoRange[ulCurrentRange].iwcBegin = 
                        wispalt->pElements[iElem].ulIndexInString;
                }
            }
            pRecoRange[ulCurrentRange].cCount = wispalt->ulLength - 
                pRecoRange[ulCurrentRange].iwcBegin;
        }
        else
        {
            // We just want the number
            *pcRanges = ulRangeCount;
        }
    }
    else
    {
        if (IsEqualGUID(pPropertyGuid, &GUID_SEGMENTATION))
        {
            // We are asking for the segmentation for this ink
            // We are going to add the spaces in between the
            // hwx segments
            ulRangeCount = 2 * wispalt->ulElementCount - 1;
            if (pRecoRange)
            {
                ULONG       ulCurrentPosition = 0;
                // We want the ranges. Do we have enough in the buffer?
                if (ulRangeCount != *pcRanges)
                    return TPC_E_INSUFFICIENT_BUFFER;
                if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)*ulRangeCount))
                    return E_POINTER;
                // Let's get to it
                ulCurrentRange = 0;
                ulCurrentPosition = 0;
                for(iElem = 1; iElem < wispalt->ulElementCount - 1; iElem++)
                {
                    // Add the segment
                    pRecoRange[ulCurrentRange].iwcBegin = ulCurrentPosition;
                    ulCurrentPosition = wispalt->pElements[iElem].ulIndexInString;
                    pRecoRange[ulCurrentRange].cCount = ulCurrentPosition -
                        pRecoRange[ulCurrentRange].iwcBegin - 1;
                    ulCurrentRange++;

                    // Add the space segment:
                    pRecoRange[ulCurrentRange].iwcBegin = ulCurrentPosition - 1;
                    pRecoRange[ulCurrentRange].cCount = 1;
                    ulCurrentRange++;
                }
                pRecoRange[ulCurrentRange].iwcBegin = ulCurrentPosition;
                pRecoRange[ulCurrentRange].cCount = wispalt->ulLength - ulCurrentPosition;
                ASSERT(ulCurrentRange == *pcRanges);
            }
            else
            {
                // We are just asking for the count of segments
                // Add the segments and the "space segments" in between!
                *pcRanges = ulRangeCount;
            }
        }
        else
        {
            hr = TPC_E_INVALID_PROPERTY;
        }
    }

    return hr;
}

HRESULT WINAPI GetRangePropertyValue(HRECOALT hrcalt, const GUID *pPropertyGuid, RECO_RANGE* pRecoRange, ULONG*pcbSize, BYTE* pProperty)
{
    HRESULT             hr = S_OK;
    WispSegAlternate	*wispalt;
    ULONG               ulRangeCount = 0;
    ULONG               ulStartIndex = 0, ulEndIndex = 0;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }
    if (IsBadReadPtr(pPropertyGuid, sizeof(GUID)))
    {
        return E_POINTER;
    }
    if (IsBadWritePtr(pcbSize, sizeof(ULONG)))
    {
        return E_POINTER;
    }

    // Check the validity of the reco range
    if (!pRecoRange->cCount) 
    {
        return E_INVALIDARG;
    }
    if (pRecoRange->iwcBegin + pRecoRange->cCount > wispalt->ulLength)
    {
        return E_INVALIDARG;
    }

    // Let us expose the line number
    if (IsEqualGUID(pPropertyGuid, &GUID_LINENUMBER))
    {
        if (!pProperty)
        {
            // We just want the size
            *pcbSize = sizeof(ULONG);
        }
        else
        {
            ULONG iElem = 0, iElemStart = 0;
            ULONG ulLineNumber = 0;
            // We want the value and the right range
            // Well it is quite simple for the value, but
            // we should still check the size of the buffer:
            if (IsBadWritePtr(pProperty, sizeof(ULONG)))
            {
                return E_POINTER;
            }
            // Now fill in the size
            // Get the right RECO_RANGE and the indexes
            hr = GetIndexesFromRange(wispalt, pRecoRange, &ulStartIndex, &ulEndIndex);
            if (FAILED(hr))
                return hr;
            if (hr == S_FALSE)
            {
                // Only a space has been selected
                return TPC_E_NOT_RELEVANT;
                // This might not be really true... 
                // We could actually find the real number any way
                // Either by taking the segment before or after...
            }
            ulLineNumber = wispalt->pElements[ulStartIndex].ulLineSegmentationIndex;
            *((ULONG*)pProperty) = ulLineNumber + 1;

            // Now get the real reco range for this line
            // First get the start
            for (iElem = 0; iElem < wispalt->ulElementCount; iElem++)
            {
                if (wispalt->pElements[iElem].ulLineSegmentationIndex == ulLineNumber)
                {
                    pRecoRange->iwcBegin = wispalt->pElements[iElem].ulIndexInString;
                    break;
                }
            }
            iElemStart = iElem;
            pRecoRange->cCount = 0;
            // Find the end
            for (iElem = iElemStart; iElem < wispalt->ulElementCount; iElem++)
            {
                if (wispalt->pElements[iElem].ulLineSegmentationIndex != ulLineNumber)
                {
                    pRecoRange->cCount = wispalt->pElements[iElem].ulIndexInString -
                        pRecoRange->iwcBegin;
                    break;
                }
            }
            if (0 == pRecoRange->cCount)
            {
                // the line finishes at the end of the alternate
                pRecoRange->cCount = wispalt->ulLength - pRecoRange->iwcBegin;
            }
        }
    }
    else
    {
        if (IsEqualGUID(pPropertyGuid, &GUID_SEGMENTATION))
        {
            return TPC_E_NOT_RELEVANT;
        }
        else
        {
            hr = TPC_E_INVALID_PROPERTY;
        }
    }
    return hr;
}

// GetGuideIndex
//
// Description: This method returns the index of the line
// corresponding to the first segment in the range for the 
// selected alternate
HRESULT WINAPI GetGuideIndex(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *piIndex)
{
    WispSegAlternate	*wispalt;
    ULONG               ulIndex = 0;
    ULONG               ulStartIndex = 0, ulEndIndex = 0;
    HRESULT             hr = S_OK;
    ULONG               i = 0, ulLineIndex = 0;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }

    if (IsBadWritePtr(piIndex, sizeof(ULONG)))
    {
        return E_POINTER;
    }

    // Check the validity of the reco range
    if (!pRecoRange->cCount) 
    {
        return E_INVALIDARG;
    }
    if (pRecoRange->iwcBegin + pRecoRange->cCount > wispalt->ulLength)
    {
        return E_INVALIDARG;
    }

    // Do we have a guid defined?
    if (wispalt->wisphrc->pGuide)
    {
        // Yes, then we start at the given number for the first line
        ulIndex = wispalt->wisphrc->uiGuideIndex-1;
    }
    else
    {
        return TPC_E_NOT_RELEVANT;
    }

    // Get the first segment corresponding to the range
    // Get the right RECO_RANGE and the indexes
    hr = GetIndexesFromRange(wispalt, pRecoRange, &ulStartIndex, &ulEndIndex);
    if (FAILED(hr))
        return hr;
    if (hr == S_FALSE)
    {
        // Only a space has been selected
        return TPC_E_NOT_RELEVANT;
    }

    ulLineIndex = wispalt->pElements[ulStartIndex].ulLineSegmentationIndex;
    ulIndex += ulLineIndex + 1;

    *piIndex = ulIndex;
    // Modify the range to reflect that we go to the end of the line or 
    // the end of the range.

    // First do we have more than one line?
    if (ulLineIndex == wispalt->pElements[ulEndIndex].ulLineSegmentationIndex)
    {
        return hr;
    }

    // We have more than one line, we need to trucate the recorange.
    // First find the last segment that is on the same line:
    for (i = ulStartIndex + 1; i <= ulEndIndex; i++)
    {
        // Is this element on the same line??
        if (ulLineIndex != wispalt->pElements[i].ulLineSegmentationIndex)
            break;
    }
    ulEndIndex = i - 1;

    // Now get the Reco Range for that new index
    pRecoRange->iwcBegin = wispalt->pElements[ulStartIndex].ulIndexInString;
    if (wispalt->ulElementCount > ulEndIndex + 1)
    {
        pRecoRange->cCount =  wispalt->pElements[ulEndIndex+1].ulIndexInString
            - pRecoRange->iwcBegin - 1; // -1 to remove the space
    }
    else
    {
        pRecoRange->cCount = wispalt->ulLength -
            pRecoRange->iwcBegin;
    }

    return hr;
}

//
// GetLatticeMetrics
//
// Returns the lattice metrics for that word in the wordmap
static HRESULT GetLatticeMetrics(RECT *pRect, WORD_MAP *pWordMap, ULONG iElem, LATTICE_METRICS *plmTemp)
{
    HRESULT             hr = S_OK;
    LATINLAYOUT			ll;
	int					iMidline, iBaseline;

	ll = pWordMap->pFinalAltList->pAlt[iElem].ll;

	// convert the relative baseline/midline measures to absolute terms
	iBaseline = LatinLayoutToAbsolute(ll.iBaseLine, pRect);
	iMidline = LatinLayoutToAbsolute(ll.iMidLine, pRect);

    // Create the lattice metric from the latin layout metric structure
	plmTemp->lsBaseline.PtA.x = pRect->left;
	plmTemp->lsBaseline.PtA.y = iBaseline;
	plmTemp->lsBaseline.PtB.x = pRect->right;
	plmTemp->lsBaseline.PtB.y = iBaseline;
    plmTemp->iMidlineOffset = (short)(iMidline - iBaseline);
    return hr;
}

//
// GetLatticePtr
//
// Description: This method creates a Lattice structure for 
// the recognition context and returns a pointer to it. The
// structure is going to be freed when the recognition
// context is destoyed or when a new call to GetLatticePtr
// is issued.
HRESULT WINAPI GetLatticePtr(HRECOCONTEXT hrc, RECO_LATTICE **ppLattice)
{
    HRESULT                 hr = S_OK, hRes = S_OK;
    struct WispContext      *wisphrc;
    XRC                     *xrc = NULL;
    int                     iLineSeg = 0, iSegCol = 0, iSeg = 0, iWord = 0;
    ULONG                   ulElementCount = 0, ulStrokeArraySize = 0;
    RECO_LATTICE_ELEMENT    *pCurrentElement = NULL;
    RECO_LATTICE_COLUMN     *pCurrentColumn = NULL, *pColumnAfterThisSegCol = NULL;
    ULONG                   *pCurrentStroke = NULL;
    ULONG                   iIncrement = 1;
    ULONG                   iElement = 0;
    ULONG                   iFirstRealLine = 0;
    ULONG                   ulStringBufferSize = 0;
    WCHAR                   *pCurrentString = NULL, *wsz = NULL;
    unsigned char           *strAlt = NULL, *sz = NULL;
    int                     iStroke = 0, iElem = 0, iAlt = 0;
    WORD_MAP                *pWordMap = NULL;
    ULONG                   ulCurrentBestColumn = 0;
    int                     i = 0;
    BYTE                    *pCurrentPropertyValue = NULL;
#ifdef CONFIDENCE
    RECO_LATTICE_PROPERTY   *pCFPropStart = NULL;
#endif
    RECO_LATTICE_PROPERTY   *pLMPropStart = NULL;
    ULONG                   ulRealElementsCount = 0;
    ULONG                   ulCurrentLineMetricsIndex = 0;
    LATTICE_METRICS         lmTemp;
    BOOL                    bFirstLineFound = FALSE;


	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(ppLattice, sizeof(RECO_LATTICE*))) 
        return E_POINTER;
    xrc = (XRC*)wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC)))  // assuming HRC is a typecast of XRC*
        return E_POINTER;

    // Free the existing lattice information
    if (wisphrc->pRecoLattice)
    {
        hRes = FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
        ASSERT(SUCCEEDED(hRes));
    }
    wisphrc->pRecoLattice = NULL;
    wisphrc->pLatticeStringBuffer = NULL;
    wisphrc->pLatticeProperties = NULL;
    wisphrc->pLatticePropertyValues = NULL;

    // Check if there is an alternate
    if (!xrc->pLineBrk || !xrc->pLineBrk->cLine)
        return TPC_E_NOT_RELEVANT;

    // Allocate the new Lattice
    wisphrc->pRecoLattice = (RECO_LATTICE*)ExternAlloc(sizeof(RECO_LATTICE));
    if (!wisphrc->pRecoLattice)
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(wisphrc->pRecoLattice, sizeof(RECO_LATTICE));

    // Initialize the string buffer to Zero
    wisphrc->pLatticeStringBuffer = NULL;


    // Calculate the number of columns: the space columns 
    // + the number of wordmaps for each segmentation
    // Add the space column between line segmentations
    // Add the space columns between the line segmentations
    
    wisphrc->pRecoLattice->ulColumnCount = 1; // For the first branching column 
    // Add the space column between the lines
    wisphrc->pRecoLattice->ulColumnCount += xrc->pLineBrk->cLine -1;
    // Add the branching column between the lines
    wisphrc->pRecoLattice->ulColumnCount += xrc->pLineBrk->cLine -1;

    for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
    {
        if (xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol > 0)
        {
            // Add the space columns between the segcols
            wisphrc->pRecoLattice->ulColumnCount += xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol - 1;

            // Add the branching columns betweent the segcols
            // Later on we will remove the branching columns if they are not needed (if there is only
            // one segcol in the line seg
            wisphrc->pRecoLattice->ulColumnCount += xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol - 1;

            for (iSegCol = 0; iSegCol < xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol; iSegCol++)
            {
                // Add the space columns between the segmentations
                wisphrc->pRecoLattice->ulColumnCount += 
                    xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg - 1;

                for (iSeg = 0; iSeg < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;
                    iSeg++)
                {
                    // Add the space columns between the wordmaps
                    // and for each column
                    wisphrc->pRecoLattice->ulColumnCount += 
                        2 * xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord - 1;
                    // LEFT FOR A RAINY DAY we could probably optimize here since the same wordmap could potentially be used
                    // in different segmentation. For now we are duplicating the wordmap
                    for (iWord = 0; iWord < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord; iWord++)
                    {
                        // Count the number of (real) elements
                        pWordMap = xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                            ppSeg[iSeg]->ppWord[iWord];
                        // We need to get the final alt list if it is not already computed
                        if (!pWordMap->pFinalAltList)
                        {
                            // The Final Alt List has not been computed for this Word map
                            // because it is not part of the best segmentation
                            // Compute it

                            if (!WordMapRecognizeWrap(xrc, NULL, xrc->pLineBrk->pLine[iLineSeg].pResults, pWordMap, NULL))
                            {
                                // Something went wrong in the computation of the Final Alt List
                                // We should maybe recover nicely, but I won't
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_FAIL;
                            }
                        }

                        ulRealElementsCount += pWordMap->pFinalAltList->cAlt;
                    }
                }
            }
        }
    }


    // Initialize the RECO_LATTICE structure
    // For now we have only three properties: the GUID_LINENUMBER, GUID_CONFIDENCELEVEL, GUID_LINEMETRICS
	// And the presence of GUID_CONFIDENCELEVEL depends on a compile-time flag.
#ifdef CONFIDENCE
    wisphrc->pRecoLattice->ulPropertyCount = 3;
#else
    wisphrc->pRecoLattice->ulPropertyCount = 2;
#endif
    wisphrc->pRecoLattice->pGuidProperties = (GUID*)ExternAlloc(wisphrc->pRecoLattice->ulPropertyCount*sizeof(GUID));
    // Let's do the line numbers and the confidence level
    wisphrc->pLatticeProperties = 
#ifdef CONFIDENCE
		// The 3 is for the 3 different values that a confidence property can have.
        (RECO_LATTICE_PROPERTY*)ExternAlloc((xrc->pLineBrk->cLine + 3 + ulRealElementsCount) * sizeof(RECO_LATTICE_PROPERTY));
#else
        (RECO_LATTICE_PROPERTY*)ExternAlloc((xrc->pLineBrk->cLine + ulRealElementsCount) * sizeof(RECO_LATTICE_PROPERTY));
#endif

	// There are only three different confidence level values
    // And their values
    wisphrc->pLatticePropertyValues = (BYTE*)ExternAlloc(xrc->pLineBrk->cLine * sizeof(ULONG) +
#ifdef CONFIDENCE
        3 * sizeof(CONFIDENCE_LEVEL) +
#endif
        ulRealElementsCount * sizeof(LATTICE_METRICS));

    if (!wisphrc->pRecoLattice->pGuidProperties || !wisphrc->pLatticeProperties || !wisphrc->pLatticePropertyValues)
    {
        FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
        wisphrc->pRecoLattice = NULL;
        wisphrc->pLatticeStringBuffer = NULL;
        wisphrc->pLatticeProperties = NULL;
        wisphrc->pLatticePropertyValues = NULL;
        return E_OUTOFMEMORY;
    }
    // Fill in the values
    // There is only one property for now and it is the GUID_LINENUMBER
    wisphrc->pRecoLattice->pGuidProperties[0] = GUID_LINENUMBER;
    // Actually there is another one now and that is the lattice Metrics!
    wisphrc->pRecoLattice->pGuidProperties[1] = GUID_LINEMETRICS;
#ifdef CONFIDENCE
    // Actually there is another one now and that is the confidence level!
    wisphrc->pRecoLattice->pGuidProperties[2] = GUID_CONFIDENCELEVEL;
#endif

    // Fill in the RECO_LATTICE_PROPERTY to contain all the line number:
    for (i = 0; i < xrc->pLineBrk->cLine; i++)
    {
        wisphrc->pLatticeProperties[i].guidProperty = GUID_LINENUMBER;
        wisphrc->pLatticeProperties[i].cbPropertyValue = sizeof(ULONG);
        wisphrc->pLatticeProperties[i].pPropertyValue = (BYTE*)( ((ULONG*)wisphrc->pLatticePropertyValues) + i );
        *(((ULONG*)wisphrc->pLatticePropertyValues) + i) = i + 1;
    }
    pCurrentPropertyValue = wisphrc->pLatticePropertyValues + xrc->pLineBrk->cLine * sizeof(ULONG*);

#ifdef CONFIDENCE
    // Fill the RECO_LATTICE_PROPERTY array to contain the confidence level
    pCFPropStart = &wisphrc->pLatticeProperties[i];
    wisphrc->pLatticeProperties[i].guidProperty = GUID_CONFIDENCELEVEL;
    wisphrc->pLatticeProperties[i].cbPropertyValue = sizeof(CONFIDENCE_LEVEL);
    wisphrc->pLatticeProperties[i].pPropertyValue = pCurrentPropertyValue;
    *( (CONFIDENCE_LEVEL*)pCurrentPropertyValue) = CFL_STRONG;
    i++;
    // next value
    pCurrentPropertyValue += sizeof(CONFIDENCE_LEVEL);
    wisphrc->pLatticeProperties[i].guidProperty = GUID_CONFIDENCELEVEL;
    wisphrc->pLatticeProperties[i].cbPropertyValue = sizeof(CONFIDENCE_LEVEL);
    wisphrc->pLatticeProperties[i].pPropertyValue = pCurrentPropertyValue;
    *( (CONFIDENCE_LEVEL*)pCurrentPropertyValue) = CFL_INTERMEDIATE;
    i++;
    // next value
    pCurrentPropertyValue += sizeof(CONFIDENCE_LEVEL);
    wisphrc->pLatticeProperties[i].guidProperty = GUID_CONFIDENCELEVEL;
    wisphrc->pLatticeProperties[i].cbPropertyValue = sizeof(CONFIDENCE_LEVEL);
    wisphrc->pLatticeProperties[i].pPropertyValue = pCurrentPropertyValue;
    *( (CONFIDENCE_LEVEL*)pCurrentPropertyValue) = CFL_POOR;
    pCurrentPropertyValue += sizeof(CONFIDENCE_LEVEL);
    i++;
#endif

    // Set the start of the array of RECO_LATTICE_PROPERTY
    // for the Line Metrics
    pLMPropStart = &wisphrc->pLatticeProperties[i];
    
    // Calculate the number of columns in the best result: It should 
    // be equal to the number of wordmap in the best segmentation for each
    // segmentation collection + the space columns
    wisphrc->pRecoLattice->ulBestResultColumnCount = 0;
    for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
    {
        for (iSegCol = 0; iSegCol < xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol; iSegCol++)
        {
            // Add the count of wordmaps for this line segmentation
            wisphrc->pRecoLattice->ulBestResultColumnCount += 
                xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[0]->cWord;
        }
    }
    // Add the space columns they should be -1 less than the current count
    if (wisphrc->pRecoLattice->ulBestResultColumnCount)
    {
        wisphrc->pRecoLattice->ulBestResultColumnCount *= 2;
        wisphrc->pRecoLattice->ulBestResultColumnCount--;
    }

    // Add the branching columns (the ones before each the seg col)
    for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
    {
        wisphrc->pRecoLattice->ulBestResultColumnCount += xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol;
    }

    // Allocate the different buffers for the columns.

    // First the array for the lattice columns
    wisphrc->pRecoLattice->pLatticeColumns = (RECO_LATTICE_COLUMN*)
        ExternAlloc(wisphrc->pRecoLattice->ulColumnCount*sizeof(RECO_LATTICE_COLUMN));
    if (!wisphrc->pRecoLattice->pLatticeColumns)
    {
        FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
        wisphrc->pRecoLattice = NULL;
        wisphrc->pLatticeStringBuffer = NULL;
        wisphrc->pLatticeProperties = NULL;
        wisphrc->pLatticePropertyValues = NULL;
        return E_OUTOFMEMORY;
    }
    ZeroMemory(wisphrc->pRecoLattice->pLatticeColumns, 
        wisphrc->pRecoLattice->ulColumnCount * sizeof(RECO_LATTICE_COLUMN));

    // Then the array of column indexes for the best result
    wisphrc->pRecoLattice->pulBestResultColumns = (ULONG*)
        ExternAlloc(wisphrc->pRecoLattice->ulBestResultColumnCount * sizeof(ULONG));
    if (!wisphrc->pRecoLattice->pulBestResultColumns)
    {
        FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
        wisphrc->pRecoLattice = NULL;
        wisphrc->pLatticeStringBuffer = NULL;
        wisphrc->pLatticePropertyValues = NULL;
        wisphrc->pLatticeProperties = NULL;
        return E_OUTOFMEMORY;
    }
    ZeroMemory(wisphrc->pRecoLattice->pulBestResultColumns, 
        sizeof(ULONG)*wisphrc->pRecoLattice->ulBestResultColumnCount);

    // Then the array of indexes of the best result within the lattice column
    wisphrc->pRecoLattice->pulBestResultIndexes = (ULONG*)
        ExternAlloc(wisphrc->pRecoLattice->ulBestResultColumnCount * sizeof(ULONG));
    if (!wisphrc->pRecoLattice->pulBestResultIndexes)
    {
        FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
        wisphrc->pRecoLattice = NULL;
        wisphrc->pLatticeStringBuffer = NULL;
        wisphrc->pLatticeProperties = NULL;
        wisphrc->pLatticePropertyValues = NULL;
        return E_OUTOFMEMORY;
    }
    ZeroMemory(wisphrc->pRecoLattice->pulBestResultIndexes, 
        sizeof(ULONG)*wisphrc->pRecoLattice->ulBestResultColumnCount);

    ulStringBufferSize = 0;
    
    // If we have columns start getting the number of elements and filling in the columns
    if (wisphrc->pRecoLattice->ulColumnCount)
    {
        // Get the number of elements
        ulElementCount = 0;
        for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
        {
            if ( !bFirstLineFound && (0 != xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol) )
            {
                iFirstRealLine = iLineSeg;
                bFirstLineFound = TRUE;
            }
            for (iSegCol = 0; iSegCol < xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol; iSegCol++)
            {
                // Add the space element between the seg col
                // There is one space element per seg cols
                ulElementCount += 1;
                
                // we have one branching element per segmentation since they
                // are going to be used to branch between different stroke
                // ordering
                ulElementCount += 
                    xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;

                // Find the number of elements in each wordmap for each segmentation
                for (iSeg = 0; iSeg < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;
                    iSeg++)
                {
                     ASSERT(xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord);
                    
                    // Add the space elements between the wordmaps
                    ulElementCount += xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord-1;

                    for (iWord = 0; 
                        iWord < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord;
                        iWord++)
                    {
                        // Add the number of elements
                        if (!xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->ppWord[iWord]->pFinalAltList)
                        {
                            // The Final Alt List has not been computed for this Word map
                            // because it is not part of the best segmentation
                            // Compute it
                            if (!WordMapRecognizeWrap(xrc, NULL, xrc->pLineBrk->pLine[iLineSeg].pResults, 
                                xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->ppWord[iWord],
                                NULL))
                            {
                                // Something went wrong in the computation of the Final Alt List
                                // We should maybe recover nicely, but I won't
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_FAIL;
                            }
                        }
                        ulElementCount += xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                            ppSeg[iSeg]->ppWord[iWord]->pFinalAltList->cAlt;
                        // Add the size of each stroke array
                        ulStrokeArraySize += xrc->pLineBrk->pLine[iLineSeg].pResults->
                            ppSegCol[iSegCol]->ppSeg[iSeg]->ppWord[iWord]->cStroke;
                        // Count the number of characters for the words in the wordmap
                        for (iAlt = 0; iAlt < xrc->pLineBrk->pLine[iLineSeg].pResults->
                            ppSegCol[iSegCol]->ppSeg[iSeg]->ppWord[iWord]->pFinalAltList->cAlt; iAlt++)
                        {
                            ulStringBufferSize += strlen(xrc->pLineBrk->pLine[iLineSeg].pResults->
                                ppSegCol[iSegCol]->ppSeg[iSeg]->ppWord[iWord]->pFinalAltList->pAlt[iAlt].pszStr)+1;
                        }

                       
                    }

                }
            }
        }
        // If we hit this assert that means that no lines have data: weird
        ASSERT(bFirstLineFound);


        // Allocate the array of elements

        // We put its address in the first column's pLatticeElements pointer
        wisphrc->pRecoLattice->pLatticeColumns[0].pLatticeElements = (RECO_LATTICE_ELEMENT*)
            ExternAlloc(sizeof(RECO_LATTICE_ELEMENT) * ulElementCount);
        if (!wisphrc->pRecoLattice->pLatticeColumns[0].pLatticeElements)
        {
            FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
            wisphrc->pRecoLattice = NULL;
            wisphrc->pLatticeStringBuffer = NULL;
            wisphrc->pLatticePropertyValues = NULL;
            wisphrc->pLatticeProperties = NULL;
            return E_OUTOFMEMORY;
        }
		ZeroMemory(wisphrc->pRecoLattice->pLatticeColumns[0].pLatticeElements, sizeof(RECO_LATTICE_ELEMENT) * ulElementCount);

        // Allocate the String Buffer
        wisphrc->pLatticeStringBuffer = 
            (WCHAR*)ExternAlloc(sizeof(WCHAR)*ulStringBufferSize);
        if (ulStringBufferSize && !wisphrc->pLatticeStringBuffer)
        {
            FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
            wisphrc->pRecoLattice = NULL;
            wisphrc->pLatticeStringBuffer = NULL;
            wisphrc->pLatticePropertyValues = NULL;
            wisphrc->pLatticeProperties = NULL;
            return E_OUTOFMEMORY;
        }
        ZeroMemory(wisphrc->pLatticeStringBuffer,
            ulStringBufferSize*sizeof(WCHAR));
        pCurrentString = (WCHAR*)wisphrc->pLatticeStringBuffer;

        // Allocate the array of strokes
        // We put its address in the first column's pStrokes pointer
        wisphrc->pRecoLattice->pLatticeColumns[0].pStrokes = (ULONG*)
            ExternAlloc(sizeof(ULONG) * ulStrokeArraySize);
        if (!wisphrc->pRecoLattice->pLatticeColumns[0].pStrokes)
        {
            FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
            wisphrc->pRecoLattice = NULL;
            wisphrc->pLatticeStringBuffer = NULL;
            wisphrc->pLatticePropertyValues = NULL;
            wisphrc->pLatticeProperties = NULL;
            return E_OUTOFMEMORY;
        }

        // Initialize the array of strokes
        pCurrentElement = wisphrc->pRecoLattice->pLatticeColumns[0].pLatticeElements;
        pCurrentStroke = wisphrc->pRecoLattice->pLatticeColumns[0].pStrokes;
        pCurrentColumn = wisphrc->pRecoLattice->pLatticeColumns;


        for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
        {
            for (iSegCol = 0; iSegCol < xrc->pLineBrk->pLine[iLineSeg].pResults->cSegCol; iSegCol++)
            {
                // Add the space alternate column if this is not the first real lineseg's
                // first segcol. Lines that do not contain data do not count as linesegs
                // We store the index of the first real line in iFirstRealLine

                // If it is then add a braching column if there is
                // more than one segmentation
                if (iLineSeg == iFirstRealLine && iSegCol == 0)
                {
                    iIncrement = 1;
                    // Only create an element if there is more than one
                    // segmentation in the first lineseg's segcol.
//                    if (xrc->pLineBrk->pLine[0].pResults->ppSegCol[0]->cSeg > 1)
                    {
                        // Create a branching column
                        pCurrentColumn->pLatticeElements = pCurrentElement;
                        pCurrentColumn->cLatticeElements = xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;
                        pCurrentColumn->key = pCurrentColumn - wisphrc->pRecoLattice->pLatticeColumns;
                        pCurrentColumn->cpProp.cProperties = 0;
                        pCurrentColumn->cpProp.apProps = NULL;
                        pCurrentColumn->pStrokes = pCurrentStroke;
                        // This column will be part of the best result
                        wisphrc->pRecoLattice->pulBestResultColumns[ulCurrentBestColumn] = pCurrentColumn->key;
                        ulCurrentBestColumn++;
                        
                        // Create the elements for this column
                        for (iElement = 0; iElement < pCurrentColumn->cLatticeElements; iElement++)
                        {
                            // This is a branching element
                            pCurrentElement->ulStrokeNumber = 0;
                            pCurrentElement->epProp.cProperties = 0;
                            pCurrentElement->epProp.apProps = NULL;
                            pCurrentElement->pData = (BYTE*)(L"");
                            pCurrentElement->score = 0;
                            pCurrentElement->type = RECO_TYPE_WSTRING;
                            pCurrentElement->ulNextColumn = pCurrentColumn->key + iIncrement;
                            iIncrement += 2 * 
                                xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iElement]->cWord - 1;
                            pCurrentElement++;
                        }
                        pCurrentColumn++;
                    }
                }
                else
                {
                    // Add the column for the space between segcols
                    pCurrentColumn->pLatticeElements = pCurrentElement;
                    pCurrentColumn->key = pCurrentColumn - wisphrc->pRecoLattice->pLatticeColumns;
                    pCurrentColumn->cpProp.cProperties = 1;
                    pCurrentColumn->cpProp.apProps = (RECO_LATTICE_PROPERTY**)ExternAlloc(sizeof(RECO_LATTICE_PROPERTY*) * pCurrentColumn->cpProp.cProperties);
                    if (!pCurrentColumn->cpProp.apProps)
                    {
                        FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                        wisphrc->pRecoLattice = NULL;
                        wisphrc->pLatticeStringBuffer = NULL;
                        wisphrc->pLatticePropertyValues = NULL;
                        wisphrc->pLatticeProperties = NULL;
                        return E_OUTOFMEMORY;
                    }
                    pCurrentColumn->cpProp.apProps[0] = &wisphrc->pLatticeProperties[iLineSeg];
                    pCurrentColumn->pStrokes = pCurrentStroke;
                    pCurrentColumn->cLatticeElements =1;
                    // Add this column to the best result
                    wisphrc->pRecoLattice->pulBestResultColumns[ulCurrentBestColumn] = pCurrentColumn->key;
                    ulCurrentBestColumn++;

                    // This is a space element
                    pCurrentElement->ulStrokeNumber = 0;
#ifdef CONFIDENCE
                    pCurrentElement->epProp.cProperties = 1;
                    pCurrentElement->epProp.apProps = (RECO_LATTICE_PROPERTY**)ExternAlloc(sizeof(RECO_LATTICE_PROPERTY*) * pCurrentElement->epProp.cProperties);
                    if (!pCurrentElement->epProp.apProps)
                    {
                        FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                        wisphrc->pRecoLattice = NULL;
                        wisphrc->pLatticeStringBuffer = NULL;
                        wisphrc->pLatticePropertyValues = NULL;
                        wisphrc->pLatticeProperties = NULL;
                        return E_OUTOFMEMORY;
                    }
                    pCurrentElement->epProp.apProps[0] = &pCFPropStart[CFL_STRONG];
#else
                    pCurrentElement->epProp.cProperties = 0;
                    pCurrentElement->epProp.apProps = NULL;
#endif
                    pCurrentElement->pData = (BYTE*)(L" ");
                    pCurrentElement->score = 0;
                    pCurrentElement->type = RECO_TYPE_WSTRING;
                    pCurrentElement->ulNextColumn = pCurrentColumn->key + 1;
                    pCurrentElement++;
                    // Increment the column only now!
                    pCurrentColumn++;
                    

                    // Create a branching column between the segcols
                    pCurrentColumn->pLatticeElements = pCurrentElement;
                    pCurrentColumn->key = pCurrentColumn - wisphrc->pRecoLattice->pLatticeColumns;
                    pCurrentColumn->cpProp.cProperties = 0;
                    pCurrentColumn->cpProp.apProps = NULL;
                    pCurrentColumn->pStrokes = pCurrentStroke;
                    // Add this colunm to the best result
                    pCurrentColumn->cLatticeElements = xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;
                    wisphrc->pRecoLattice->pulBestResultColumns[ulCurrentBestColumn] = pCurrentColumn->key;
                    ulCurrentBestColumn++;
                    
                    // Create the elements for this column
                    iIncrement = 1;
                    for (iElement = 0; iElement < pCurrentColumn->cLatticeElements; iElement++)
                    {
                        // This is a branching element
                        pCurrentElement->ulStrokeNumber = 0;
                        pCurrentElement->epProp.cProperties = 0;
                        pCurrentElement->epProp.apProps = NULL;
                        pCurrentElement->pData = (BYTE*)(L"");
                        pCurrentElement->score = 0;
                        pCurrentElement->type = RECO_TYPE_WSTRING;
                        pCurrentElement->ulNextColumn = pCurrentColumn->key + iIncrement;
                        iIncrement += 2 * 
                            xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iElement]->cWord - 1;
                        pCurrentElement++;
                    }
                    pCurrentColumn++;
                }
                // This is going to be the columns after this current segcol
                pColumnAfterThisSegCol = pCurrentColumn + iIncrement - 1;

                // Add the columns and elements for this segmentation
                for (iSeg = 0; iSeg < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;
                    iSeg++)
                {
                    for (iWord = 0; 
                        iWord < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord;
                        iWord++)
                    {
						GLYPH *pGlyph;
						RECT rect;

                        pWordMap = xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                            ppSeg[iSeg]->ppWord[iWord];
                        // Copy the strokes
                        for (iStroke = 0; iStroke < pWordMap->cStroke; iStroke++)
                        {
                            pCurrentStroke[iStroke] = pWordMap->piStrokeIndex[iStroke];
                        }
                        // Create the column for this word map
                        pCurrentColumn->pStrokes = pCurrentStroke;
                        if (!pWordMap->pFinalAltList)
                        {
                            // The Final Alt List has not been computed for this Word map
                            // because it is not part of the best segmentation
                            // Compute it
                            if (!WordMapRecognizeWrap(xrc, NULL, xrc->pLineBrk->pLine[iLineSeg].pResults, pWordMap, NULL))
                            {
                                // Something went wrong in the computation of the Final Alt List
                                // We should maybe recover nicely, but I won't
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_FAIL;
                            }
                        }
                        pCurrentColumn->cLatticeElements = pWordMap->pFinalAltList->cAlt;
                        pCurrentColumn->cpProp.cProperties = 1;
                        pCurrentColumn->cpProp.apProps = (RECO_LATTICE_PROPERTY**)ExternAlloc(sizeof(RECO_LATTICE_PROPERTY*) * pCurrentColumn->cpProp.cProperties);
                        if (!pCurrentColumn->cpProp.apProps)
                        {
                            FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                            wisphrc->pRecoLattice = NULL;
                            wisphrc->pLatticeStringBuffer = NULL;
                            wisphrc->pLatticePropertyValues = NULL;
                            wisphrc->pLatticeProperties = NULL;
                            return E_OUTOFMEMORY;
                        }
                        pCurrentColumn->cpProp.apProps[0] = &wisphrc->pLatticeProperties[iLineSeg];
                        pCurrentColumn->key = pCurrentColumn - wisphrc->pRecoLattice->pLatticeColumns;
                        pCurrentColumn->pLatticeElements = pCurrentElement;
                        pCurrentColumn->cStrokes = pWordMap->cStroke;
                        // Add the size of each stroke array
                        pCurrentStroke += pWordMap->cStroke;

                        // Is this part of the best result?
                        if (0 == iSeg)
                        {
                            wisphrc->pRecoLattice->pulBestResultColumns[ulCurrentBestColumn] = pCurrentColumn->key;
                            ulCurrentBestColumn++;
                        }

                        // Go to the next column
                        pCurrentColumn++;

						// cache the bounding rect for the ink before enumerating through the alt list
						pGlyph = GlyphFromStrokes(xrc->pGlyph, pWordMap->cStroke, pWordMap->piStrokeIndex);
						if (!pGlyph)
						{
                            FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                            wisphrc->pRecoLattice = NULL;
                            wisphrc->pLatticeStringBuffer = NULL;
                            wisphrc->pLatticePropertyValues = NULL;
                            wisphrc->pLatticeProperties = NULL;
							return E_FAIL;
						}
						GetRectGLYPH(pGlyph, &rect);
						DestroyGLYPH(pGlyph);

                        // Create the elements for this column
                        for (iElem = 0; iElem < pWordMap->pFinalAltList->cAlt; iElem++)
                        {
#ifdef CONFIDENCE
                            pCurrentElement->epProp.cProperties = 2;
#else
                            pCurrentElement->epProp.cProperties = 1;
#endif
                            pCurrentElement->epProp.apProps = (RECO_LATTICE_PROPERTY**)ExternAlloc(sizeof(RECO_LATTICE_PROPERTY*) * pCurrentElement->epProp.cProperties);
                            if (!pCurrentElement->epProp.apProps)
                            {
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_OUTOFMEMORY;
                            }
#ifdef CONFIDENCE
                            // Fill the confidence level property
                            // Everything that is not the best guess is considered CF_POOR
                            if (iElem == 0)
                            {
                                switch(pWordMap->iConfidence)
                                {
                                case RECOCONF_LOWCONFIDENCE:
                                    pCurrentElement->epProp.apProps[1] = &pCFPropStart[CFL_POOR];
                                    break;
                                case RECOCONF_MEDIUMCONFIDENCE:
                                    pCurrentElement->epProp.apProps[1] = &pCFPropStart[CFL_INTERMEDIATE];
                                    break;
                                case RECOCONF_HIGHCONFIDENCE:
                                    pCurrentElement->epProp.apProps[1] = &pCFPropStart[CFL_STRONG];
                                    break;
                                default:
                                    FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                    wisphrc->pRecoLattice = NULL;
                                    wisphrc->pLatticeStringBuffer = NULL;
                                    wisphrc->pLatticePropertyValues = NULL;
                                    wisphrc->pLatticeProperties = NULL;
                                    return E_FAIL;
                                }
                            }
                            else
                            {
                                pCurrentElement->epProp.apProps[1] = &pCFPropStart[CFL_POOR];
                            }
#endif
                            // Fill in the Line metrics property
                            // Get the LATTICE_METRICS for that alternate
                            hr = GetLatticeMetrics(&rect, pWordMap, iElem, &lmTemp);
                            if (FAILED(hr))
                            {
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_FAIL;
                            }
                            // Initialize the RECO_LATTICE_PROPERTY structure with this value
                            pLMPropStart[ulCurrentLineMetricsIndex].guidProperty = GUID_LINEMETRICS;
                            pLMPropStart[ulCurrentLineMetricsIndex].cbPropertyValue = sizeof(LATTICE_METRICS);
                            pLMPropStart[ulCurrentLineMetricsIndex].pPropertyValue = pCurrentPropertyValue;
                            *(LATTICE_METRICS*)pCurrentPropertyValue = lmTemp;
                            pCurrentPropertyValue += sizeof(LATTICE_METRICS);
                            pCurrentElement->epProp.apProps[0] = &pLMPropStart[ulCurrentLineMetricsIndex];
                            ulCurrentLineMetricsIndex++;
                            pCurrentElement->score = pWordMap->pFinalAltList->pAlt[iElem].iCost;
                            pCurrentElement->pData = (BYTE*)pCurrentString;
                            strAlt = pWordMap->pFinalAltList->pAlt[iElem].pszStr;

							sz = strAlt;
							wsz = pCurrentString;
							for (i=strlen(strAlt); i; i--)
							{
								if (!CP1252ToUnicode(*sz++, wsz++))
								{
									FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                    wisphrc->pRecoLattice = NULL;
                                    wisphrc->pLatticeStringBuffer = NULL;
                                    wisphrc->pLatticePropertyValues = NULL;
                                    wisphrc->pLatticeProperties = NULL;
									return E_FAIL;
								}
							}

                            pCurrentString += strlen(strAlt)+1;
                            pCurrentElement->type = RECO_TYPE_WSTRING;
                            pCurrentElement->ulStrokeNumber = pWordMap->cStroke;
                            if (iWord == xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                ppSeg[iSeg]->cWord-1)
                            {
                                // This is the last wordmap of this segmentation point
                                // to the space column before the next segcol
                                pCurrentElement->ulNextColumn = pColumnAfterThisSegCol - wisphrc->pRecoLattice->pLatticeColumns;
                            }
                            else
                            {
                                // Point to the next column to be created
                                pCurrentElement->ulNextColumn = pCurrentColumn - wisphrc->pRecoLattice->pLatticeColumns;
                            }
                            pCurrentElement++;
                        }

                        // Add a space column if not at the end
                        if (iWord != xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                            ppSeg[iSeg]->cWord-1)
                        {
                            // Add the column for the spce between segcols
                            pCurrentColumn->pLatticeElements = pCurrentElement;
                            pCurrentColumn->cLatticeElements = 1; //xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg;
                            pCurrentColumn->key = pCurrentColumn - wisphrc->pRecoLattice->pLatticeColumns;
                            pCurrentColumn->cpProp.cProperties = 1;
                            pCurrentColumn->cpProp.apProps = (RECO_LATTICE_PROPERTY**)ExternAlloc(sizeof(RECO_LATTICE_PROPERTY*) * pCurrentColumn->cpProp.cProperties);
                            if (!pCurrentColumn->cpProp.apProps)
                            {
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_OUTOFMEMORY;
                            }
                            pCurrentColumn->cpProp.apProps[0] = &wisphrc->pLatticeProperties[iLineSeg];
                            pCurrentColumn->pStrokes = pCurrentStroke;

                            // Is this part of the best result?
                            if (0 == iSeg)
                            {
                                wisphrc->pRecoLattice->pulBestResultColumns[ulCurrentBestColumn] = pCurrentColumn->key;
                                ulCurrentBestColumn++;
                            }
                            
                            // Create the element for this column (there is only one)
                            // This is a space element
                            pCurrentElement->ulStrokeNumber = 0;
 #ifdef CONFIDENCE
                            pCurrentElement->epProp.cProperties = 1;
                            pCurrentElement->epProp.apProps = (RECO_LATTICE_PROPERTY**)ExternAlloc(sizeof(RECO_LATTICE_PROPERTY*) * pCurrentElement->epProp.cProperties);
                            if (!pCurrentElement->epProp.apProps)
                            {
                                FreeNewRecoLattice(wisphrc->pRecoLattice, wisphrc->pLatticeStringBuffer, wisphrc->pLatticeProperties, wisphrc->pLatticePropertyValues);
                                wisphrc->pRecoLattice = NULL;
                                wisphrc->pLatticeStringBuffer = NULL;
                                wisphrc->pLatticePropertyValues = NULL;
                                wisphrc->pLatticeProperties = NULL;
                                return E_OUTOFMEMORY;
                            }
                            pCurrentElement->epProp.apProps[0] = &pCFPropStart[CFL_STRONG];
#else
                            pCurrentElement->epProp.cProperties = 0;
                            pCurrentElement->epProp.apProps = NULL;
#endif
                            pCurrentElement->pData = (BYTE*)(L" ");
                            pCurrentElement->score = 0;
                            pCurrentElement->type = RECO_TYPE_WSTRING;
                            pCurrentElement->ulNextColumn = pCurrentColumn->key + 1;
                            pCurrentElement++;
                            pCurrentColumn++;
                        }
                    } // for (iWord...
                } // for (iSeg...
            } // for (iSegCol...
        } // for (iLineSeg...
    }
    *ppLattice = wisphrc->pRecoLattice;
    return hr;
}

//
// Lattice manipulation functions
//
static HRESULT FreeNewRecoLattice(RECO_LATTICE *pRecoLattice, WCHAR *pLatticeStringBuffer, RECO_LATTICE_PROPERTY *pLatticeProperties, BYTE *pLatticePropertyValues)
{
    HRESULT		            hr = S_OK;
    ULONG		            i = 0, j = 0;
    RECO_LATTICE_COLUMN     *pColumn = NULL;
    RECO_LATTICE_ELEMENT    *pElement = NULL;

    if (IsBadWritePtr(pRecoLattice, sizeof(RECO_LATTICE))) 
        return E_POINTER;
    
    // Free the Lattice column information
    if (pRecoLattice->pLatticeColumns)
    {
        // Free the RECO_LATTICE_PROPERTY* arrays in each column and element
        for (i = 0; i < pRecoLattice->ulColumnCount; i++)
        {
            pColumn = &pRecoLattice->pLatticeColumns[i];
            if (pColumn->cpProp.apProps)
            {
                ExternFree(pColumn->cpProp.apProps);
            }
            // Get to the elements properties arrays
            for (j = 0; j < pColumn->cLatticeElements; j++)
            {
                pElement = &pColumn->pLatticeElements[j];
                if (pElement->epProp.apProps)
                {
                    ExternFree((pElement->epProp.apProps));
                }
            }
        }
        // Free the array of lattice elements
        if (pRecoLattice->pLatticeColumns[0].pLatticeElements)
            ExternFree(pRecoLattice->pLatticeColumns[0].pLatticeElements);
            
        if (pRecoLattice->pLatticeColumns[0].pStrokes)
        {
            ExternFree(pRecoLattice->pLatticeColumns[0].pStrokes);
        }

        ExternFree(pRecoLattice->pLatticeColumns);
    }
    // Free the the RecoLattice properties
    if (pRecoLattice->pGuidProperties) 
        ExternFree(pRecoLattice->pGuidProperties);
    // Free the best result information
    if (pRecoLattice->pulBestResultColumns) 
        ExternFree(pRecoLattice->pulBestResultColumns);
    if (pRecoLattice->pulBestResultIndexes) 
        ExternFree(pRecoLattice->pulBestResultIndexes);
    if (pLatticeStringBuffer)
        ExternFree(pLatticeStringBuffer);
    if (pLatticeProperties)
        ExternFree(pLatticeProperties);
    if (pLatticePropertyValues)
        ExternFree(pLatticePropertyValues);
    
    // Free the RECO_LATTICE structure
    ExternFree(pRecoLattice);
    return hr;
}


//
// New functions using the new segmentation
///////////////////////////////////////////////////////

//
// DestroyInternalAlternate
//
// This function destroys an alternate, freeing the allocated memory
//
// Parameters:
//		wisphrcalt [in] : pointer to the alternate to be destroyed
/////////////////
static HRESULT DestroyInternalAlternate(WispSegAlternate *wisphrcalt)
{
    if(wisphrcalt->pElements)
	{
		ExternFree(wisphrcalt->pElements);
    }

	ExternFree(wisphrcalt);
    return S_OK;
}

//
// DestroyAlternate
//
// This function destroys an alternate, freeing the allocated memory
//
// Parameters:
//		hrcalt [in] : handle of the alternate to be destroyed
/////////////////
HRESULT WINAPI DestroyAlternate(HRECOALT hrcalt)
{
    WispSegAlternate	*wisphrcalt;
    
	if (NULL == (wisphrcalt = (WispSegAlternate*)DestroyTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
	}

	return DestroyInternalAlternate(wisphrcalt);
}

//
// GetBestAlternate
//
// This function create the best alternate from the best segmentation
//
// Parameters:
//		hrc [in] : the reco context
//		pHrcAlt [out] : pointer to the handle of the alternate
/////////////////
HRESULT WINAPI GetBestAlternate(HRECOCONTEXT hrc, HRECOALT* pHrcAlt)
{
    HRESULT					hr = S_OK;
    WispSegAlternate		*pWispAlt = NULL;
    struct WispContext		*wisphrc;
    XRC						*xrc = NULL;
    int						iLineSeg = 0, iSegCol = 0, iWordMap = 0;
    ULONG					ulIndex = 0, ulCurrentIndex = 0;
    LINE_SEGMENTATION		*pLineSeg = NULL;
    SEGMENTATION			*pSeg = NULL;
    
	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pHrcAlt, sizeof(HRECOALT)))
        return E_POINTER;

    xrc = (XRC*)wisphrc->hrc;  // assuming HRC == XRC*
    if (IsBadReadPtr(xrc, sizeof(XRC))) 
        return E_POINTER;
    
    // Check if there is an alternate
    if (!xrc->pLineBrk || !xrc->pLineBrk->cLine)
        return TPC_E_NOT_RELEVANT;
    
    // Create the alternate
    pWispAlt = (WispSegAlternate*)ExternAlloc(sizeof(WispSegAlternate));
    if (!pWispAlt) 
        return E_OUTOFMEMORY;
    ZeroMemory(pWispAlt, sizeof(WispSegAlternate));
    
    // Initialize the alternate with a pointer to the hrc
    pWispAlt->wisphrc = wisphrc;
    
    // Compute the number of WordPaths needed to store the alternate path
    pWispAlt->ulElementCount = 0;
    // We will fill the length as well!
    pWispAlt->ulLength = 0;
    // Go through each line segmentation
    for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
    {
        pLineSeg = xrc->pLineBrk->pLine[iLineSeg].pResults;
        // for each line segmentation get go through each columns segmentation
        for (iSegCol = 0; iSegCol < pLineSeg->cSegCol; iSegCol++)
        {
            ASSERT(xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg);
            pSeg = pLineSeg->ppSegCol[iSegCol]->ppSeg[0];
            // For each acolumn segmentation look into each wordmap
            for (iWordMap = 0; iWordMap < pSeg->cWord; iWordMap++)
            {
                (pWispAlt->ulElementCount)++;
                pWispAlt->ulLength += strlen(pSeg->ppWord[iWordMap]->pFinalAltList->pAlt[0].pszStr) + 1;
                // The 1 is for the space
            }
        }
    }
    if (0 == pWispAlt->ulElementCount)
    {
        return TPC_E_NOT_RELEVANT;
    }
    if (0 != pWispAlt->ulLength)
    (pWispAlt->ulLength)--; // Remove the last one (not a real space)
    
    // Allocate the array of WordPaths
    pWispAlt->pElements = (WordPath*)ExternAlloc(pWispAlt->ulElementCount * sizeof(WordPath));
    if (!pWispAlt->pElements)
    {
        // cleanup
        DestroyInternalAlternate(pWispAlt);
        return E_OUTOFMEMORY;
        
    }
    
    // Fill the array of WordPaths
    ulIndex = 0;
    ulCurrentIndex = 0;
    // Go through each line segmentation
    for (iLineSeg = 0; iLineSeg < xrc->pLineBrk->cLine; iLineSeg++)
    {
        pLineSeg = xrc->pLineBrk->pLine[iLineSeg].pResults;
        // for each line segmentation get go through each columns segmentation
        for (iSegCol = 0; iSegCol < pLineSeg->cSegCol; iSegCol++)
        {
            ASSERT(xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg);
            pSeg = pLineSeg->ppSegCol[iSegCol]->ppSeg[0];
            // For each acolumn segmentation look into each wordmap
            for (iWordMap = 0; iWordMap < pSeg->cWord; iWordMap++)
            {
                pWispAlt->pElements[ulIndex].ulLineSegmentationIndex = iLineSeg;
                pWispAlt->pElements[ulIndex].ulSegColIndex = iSegCol;
                pWispAlt->pElements[ulIndex].ulSegmentationIndex = 0;
                pWispAlt->pElements[ulIndex].ulWordMapIndex = iWordMap;
                pWispAlt->pElements[ulIndex].ulIndexInWordMap = 0;
                pWispAlt->pElements[ulIndex].ulIndexInString = ulCurrentIndex;
                ulCurrentIndex += strlen(pSeg->ppWord[iWordMap]->pFinalAltList->pAlt[0].pszStr) + 1;
                ulIndex++;
            }
        }
    }
    
    // Set the range of this alternate in the best alternate
    // since it is the best alternate this is the whole thing
    pWispAlt->ReplacementRecoRange.iwcBegin = 0;
    pWispAlt->ReplacementRecoRange.cCount = pWispAlt->ulLength;
    
	// Create the handle
    *pHrcAlt = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pWispAlt);
	if (0 == *pHrcAlt)
	{
		DestroyInternalAlternate(pWispAlt);
		return E_OUTOFMEMORY;
	}

    return S_OK;
}

//
// GetString
//
// This function returns the string corresponding to the given alternate
//
// Parameters:
//		hrcalt [in] :		the handle to the alternate
//		pRecoRange [out] :	pointer to a RECO_RANGE that will be filled with
//							the range that was asked when the alternate was created
//		pcSize [in, out] :	The size of the string (or the size of the provided buffer (in WCHAR))
//		szString [out] :	If NULL we return the character count in *pcSize, if not this is a
//							string of size *pcSize where we copy the alternate string (no ending \0)
/////////////////
HRESULT WINAPI GetString(HRECOALT hrcalt, RECO_RANGE *pRecoRange, ULONG* pcSize, WCHAR* szString)
{
    WispSegAlternate 	*wispalt;
    XRC					*xrc = NULL;
    ULONG				ulCurrent = 0, cStringLength = 0;
    ULONG				ulCol = 0;
    HRESULT				hr = S_OK;
    unsigned char		*strAlt = NULL, *sz = NULL;
	WCHAR				*wsz = NULL;
	int					i;
	BOOL				bTruncated = FALSE;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }
    
    if (IsBadReadPtr(wispalt->wisphrc, sizeof(struct WispContext)))
    {
        return E_POINTER;
    }
    
    // get a pointer to the result structure
    xrc = (XRC*)wispalt->wisphrc->hrc;
    if (IsBadWritePtr(xrc, sizeof(XRC))) 
        return E_POINTER;
    
    // if we ask for the original query range, return it
    if (pRecoRange)
    {
        *pRecoRange = wispalt->ReplacementRecoRange;
    }
    if (!szString && !pcSize)
    {
        return S_OK;
    }

	if (IsBadWritePtr(pcSize, sizeof(ULONG)))
    {
        return E_POINTER;
    }
    
    // If we ask for the size only, return it
    if (!szString)
    {
        *pcSize = wispalt->ulLength;
        return S_OK;
    }
    
	if (IsBadWritePtr(szString, (*pcSize)*sizeof(WCHAR)))
	{
		return E_POINTER;
	}

    // Special case: the space alternate:
    // A space alternate is an alternate that contains just a space
    // In avalanche there, spaces do not exist, they are "virtual"
    // things that live between wordmaps, I need to treat alternate
    // that are made of just one space as a separate case
    if (!wispalt->pElements && wispalt->ulLength == 1)
    {
        // Do we have enough room in the string?
        if (!(*pcSize) )
            return S_OK;
        *pcSize = 1;
        szString[0] = L' ';
        return S_OK;
    }
    if (NULL == wispalt->pElements)
        return E_POINTER;
    
    // Is there too much space in the buffer?
    if (*pcSize > wispalt->ulLength)
        *pcSize = wispalt->ulLength;
    
    // We want to return the string
    ulCurrent = 0;
    for (ulCol = 0; ulCol<wispalt->ulElementCount; ulCol++)
    {
        // Get a pointer to the character string
        strAlt = xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->pFinalAltList->
            pAlt[wispalt->pElements[ulCol].ulIndexInWordMap].pszStr;
        
        // Get the size of the string
        cStringLength = strlen(strAlt);
        if (ulCurrent+cStringLength > *pcSize)
        {
            // The buffer is smaller than what we need
            cStringLength = *pcSize-ulCurrent;
			bTruncated = TRUE;
        }

		sz = strAlt;
		wsz = szString+ulCurrent;
		for (i=cStringLength; i; i--)
		{
			if (!CP1252ToUnicode(*sz++, wsz++))
        {
				return E_FAIL;
			}
        }
        ulCurrent += cStringLength;

		if (bTruncated)
            return TPC_S_TRUNCATED;

        // Add a space at the current location if needed
        if (ulCurrent+1 <= *pcSize && (ulCol != wispalt->ulElementCount -1) )
        {
            szString[ulCurrent] = L' ';
            ulCurrent++;
        }
    }
    return hr;
}

//
// GetStrokeRanges
//
// This function returns the stroke ranges in the ink corresponding 
// to the selected range within the alternate
//
// Parameters:
//		hrcalt [in] :			the handle to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range we want to get
//								the stroke ranges for, it comes back with the real REC_RANGE
//								used to get the stroke ranges.
//		pcRanges [in, out] :	The number of STROKE_RANGES (or the number of it in the provided buffer)
//		pStrokeRanges [out] :	If NULL we return the number in *pcRanges, if not this is an
//								array of size *pcRanges where we copy the stroke ranges
/////////////////
HRESULT WINAPI GetStrokeRanges(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG* pcRanges, STROKE_RANGE* pStrokeRange)
{
    HRESULT					hr = S_OK;
    WispSegAlternate 		*wispalt;
    XRC						*xrc = NULL;
    ULONG					ulStrokeCount = 0, ulSegmentStrokeCount = 0;
    ULONG					ulStartIndex = 0, ulEndIndex = 0;
    ULONG					ulCol = 0, j = 0, ulCurrent = 0;
    ULONG					*tabStrokes = NULL;
    int						*pSegmentIndexes = NULL;
    ULONG					ulStrokeRangesCount = 0;
    ULONG					ulCurrentStrokeRange = 0;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }
    
    if (IsBadReadPtr(wispalt->wisphrc, sizeof(struct WispContext)))
    {
        return E_POINTER;
    }
    
    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }
    if (IsBadWritePtr(pcRanges, sizeof(ULONG)))
    {
        return E_POINTER;
    }
    
    // Check the validity of the reco range
    if (!pRecoRange->cCount) 
    {
        return E_INVALIDARG;
    }
    if (pRecoRange->iwcBegin + pRecoRange->cCount > wispalt->ulLength)
    {
        return E_INVALIDARG;
    }
    
    // No Wordmap?
    if (!wispalt->ulElementCount)
    {
        // then no strokes
        *pcRanges = 0;
        return S_OK;
    }
    
    // Get the pointer to the hwx result
    xrc = (XRC*)wispalt->wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC))) 
        return E_POINTER;
    
    
    // Get the right RECO_RANGE and the indexes
    hr = GetIndexesFromRange(wispalt, pRecoRange, &ulStartIndex, &ulEndIndex);
    if (FAILED(hr))
        return hr;
    if (hr == S_FALSE)
    {
        // Only a space has been selected
        *pcRanges = 0;
        return S_OK;
    }
    
    // Collect the number of Strokes for this columns
    ulStrokeCount = 0;
    for (ulCol = ulStartIndex; ulCol <= ulEndIndex; ulCol++)
    {
        ulStrokeCount += 
            xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->cStroke;
    }
    
    // Collect the Stroke indexes for these Columns
    tabStrokes = (ULONG*)ExternAlloc(sizeof(ULONG)*ulStrokeCount);
    if (!tabStrokes)
    {
        return E_OUTOFMEMORY;
    }
    ulCurrent = 0;
    for (ulCol = ulStartIndex; ulCol <= ulEndIndex; ulCol++)
    {
        pSegmentIndexes = 
            xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->piStrokeIndex;
        ulSegmentStrokeCount = 				
            xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->cStroke;
        for (j = 0; j<ulSegmentStrokeCount; j++)
        {
            // Maybe we should check whether the pSegmentIndexes are OK...
            tabStrokes[ulCurrent+j] = pSegmentIndexes[j];
        }
        ulCurrent += ulSegmentStrokeCount;
    }
    // Sort the array
    SlowSort(tabStrokes, ulStrokeCount);
    // Get the number of STROKE_RANGES needed
    ulStrokeRangesCount = 1;
    for (j = 1; j<ulStrokeCount; j++)
    {
        if (tabStrokes[j-1]+1!=tabStrokes[j]) ulStrokeRangesCount++;
    }
    // Return the count if this is all that is asked
    if (!pStrokeRange)
    {
        *pcRanges = ulStrokeRangesCount;
        ExternFree(tabStrokes);
        return S_OK;
    }

    // Test if the array provided is big enough to store the strokes ranges.
    if (*pcRanges < ulStrokeRangesCount) 
    {
        ExternFree(tabStrokes);
        return TPC_E_INSUFFICIENT_BUFFER;
    }
    
    // Fill in the Strokes
	if (IsBadWritePtr(pStrokeRange, (*pcRanges)*sizeof(STROKE_RANGE)))
		return E_POINTER;
    ulCurrentStrokeRange = 0;
    pStrokeRange[ulCurrentStrokeRange].iStrokeBegin = tabStrokes[0];
    pStrokeRange[ulStrokeRangesCount-1].iStrokeEnd = tabStrokes[ulStrokeCount-1];
    for(j = 1; j < ulStrokeCount; j++)
    {
        // Break in continuity?
        if (tabStrokes[j-1] + 1 != tabStrokes[j]) 
        {
            // Add the new stroke range
            pStrokeRange[ulCurrentStrokeRange].iStrokeEnd = tabStrokes[j-1];
            ulCurrentStrokeRange++;
            if (ulCurrentStrokeRange == ulStrokeRangesCount) break;
            pStrokeRange[ulCurrentStrokeRange].iStrokeBegin = tabStrokes[j];
        };
    }
    // Set the real size
    *pcRanges = ulStrokeRangesCount;
    // Free the array of strokes
    ExternFree(tabStrokes);
    return hr;
}

//
// GetSegmentAlternateList
//
// This function returns alternates of the left most (or starting)
// segment in the Reco Range for this alternate
//
// Parameters:
//		hrcalt [in] :			the handle to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range we want to get
//								the segment alternates for, it comes back with the real REC_RANGE
//								used to get the segment alternates.
//		pcAlts [in, out] :		The number of alternates(or the number of them to put in the provided buffer)
//		pAlts [out] :			If NULL we return the number in *pcAlts, if not this is an
//								array of size *pcAlts where we copy the alternate handles
/////////////////
HRESULT WINAPI GetSegmentAlternateList(HRECOALT hrcalt, RECO_RANGE* pRecoRange, ULONG *pcAlts, HRECOALT* pAlts)
{
    HRESULT					hr = S_OK;
    WispSegAlternate 		*wispalt;
    XRC						*xrc = NULL;
    ULONG					ulIndex = 0, i = 0, j = 0;
    ULONG					ulAltCount = 0;
    WORD_MAP				*pWordMap = NULL;
    WispSegAlternate		*pWispAlt = NULL;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }
    
    if (IsBadReadPtr(wispalt->wisphrc, sizeof(struct WispContext)))
    {
        return E_POINTER;
    }
    
    if (IsBadReadPtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }
    
	if (IsBadWritePtr(pcAlts, sizeof(ULONG)))
	{
		return E_POINTER;
	}

    if (pAlts)
    {
        if (IsBadWritePtr(pAlts, (*pcAlts)*sizeof(HRECOALT)))
            return E_POINTER;
    }
    
    // Check the validity of the reco range
    if (!pRecoRange->cCount) 
    {
        return E_INVALIDARG;
    }
    if (pRecoRange->iwcBegin + pRecoRange->cCount > wispalt->ulLength)
    {
        return E_INVALIDARG;
    }
    
    if (!wispalt->ulElementCount)
    {
        *pcAlts = 0;
        return S_OK;
    }
    
    // We ask for no alternate. Weird but valid choice.
    if (pAlts && !(*pcAlts)) 
    {
        return S_OK;
    }
    
    // Get the pointer to the hwx result
    xrc = (XRC*)wispalt->wisphrc->hrc;
    if (IsBadWritePtr(xrc, sizeof(XRC))) 
    {
        return E_POINTER;
    }
    
    // Find the left-most segment number for this RECO_RANGE
    for (ulIndex = 0; ulIndex < wispalt->ulElementCount; ulIndex++)
    {
        if (wispalt->pElements[ulIndex].ulIndexInString >= pRecoRange->iwcBegin + 1)
            break;
    }
    ulIndex--;
    
    // Check that we have more than a space selected
    if (pRecoRange->cCount == 1 &&
        wispalt->ulElementCount > ulIndex + 1 &&
        wispalt->pElements[ulIndex+1].ulIndexInString == pRecoRange->iwcBegin+1)
    {
        // Only a space is selected
        *pcAlts = 1;
        return CreateSpaceAlternate(wispalt->wisphrc, pRecoRange, pAlts);
    }
    
    // Set the pRecoRange to the value we are going to use
    pRecoRange->iwcBegin = wispalt->pElements[ulIndex].ulIndexInString;
    if (ulIndex + 1 < wispalt->ulElementCount)
        pRecoRange->cCount = wispalt->pElements[ulIndex+1].ulIndexInString - pRecoRange->iwcBegin - 1;
    else
        pRecoRange->cCount = wispalt->ulLength - pRecoRange->iwcBegin;
    
    // Cache the WordMap
    pWordMap = 
        xrc->pLineBrk->pLine[wispalt->pElements[ulIndex].ulLineSegmentationIndex].pResults->
        ppSegCol[wispalt->pElements[ulIndex].ulSegColIndex]->
        ppSeg[wispalt->pElements[ulIndex].ulSegmentationIndex]->
        ppWord[wispalt->pElements[ulIndex].ulWordMapIndex];
    
    // Get the number of alternates in the Word map
    ulAltCount = pWordMap->pFinalAltList->cAlt;
    
    // If we only ask for the number of alternates return it
    if (!pAlts)
    {
        *pcAlts = ulAltCount;
        return S_OK;
    }
    
    // Set the number of alternate
    if (*pcAlts > ulAltCount)
        *pcAlts = ulAltCount;
    
    // Create each alternate
    for (i = 0; i < *pcAlts; i++)
    {
        // Create the alternate
        pWispAlt = (WispSegAlternate*)ExternAlloc(sizeof(WispSegAlternate));
        if (!pWispAlt) 
        {
            // Clean the alternates
            for (j = 0; j < i; j++)
                DestroyAlternate(pAlts[j]);
            return E_OUTOFMEMORY;
        }
        ZeroMemory(pWispAlt, sizeof(WispSegAlternate));
        
        // Initialize the alternate with a pointer to the hrc
        pWispAlt->wisphrc = wispalt->wisphrc;
        
        // Segment alternates always have a length of 1
        pWispAlt->ulElementCount = 1;
        // We will fill the length as well!
        pWispAlt->ulLength = strlen(pWordMap->pFinalAltList->pAlt[i].pszStr);
        pWispAlt->ReplacementRecoRange = *pRecoRange;
        
        // Create the path to the alternate
        pWispAlt->pElements = (WordPath*)ExternAlloc(sizeof(WordPath));
        if (!pWispAlt->pElements)
        {
            // Clean the alternates
            for (j = 0; j < i; j++)
                DestroyAlternate(pAlts[j]);
            DestroyInternalAlternate(pWispAlt);
            return E_OUTOFMEMORY;
        }
        pWispAlt->pElements[0].ulIndexInString = 0;
        pWispAlt->pElements[0].ulIndexInWordMap = i;
        pWispAlt->pElements[0].ulLineSegmentationIndex = 
            wispalt->pElements[ulIndex].ulLineSegmentationIndex;
        pWispAlt->pElements[0].ulSegColIndex = 
            wispalt->pElements[ulIndex].ulSegColIndex;
        pWispAlt->pElements[0].ulSegmentationIndex =
            wispalt->pElements[ulIndex].ulSegmentationIndex;
        pWispAlt->pElements[0].ulWordMapIndex = 
            wispalt->pElements[ulIndex].ulWordMapIndex;
        
        // Add to the array

		pAlts[i] = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pWispAlt);
		if (0 == pAlts[i])
		{
            // Clean the alternates
            for (j = 0; j < i; j++)
			{
                DestroyAlternate(pAlts[j]);
			}

            DestroyInternalAlternate(pWispAlt);
            return E_OUTOFMEMORY;
        }
        pWispAlt = NULL;
    }
    
    return hr;
}

//
// GetMetrics
//
// This function returns the line metrics correponding to an alternate.
// If the range given for the alternate spans more than one line, then
// function returns the value for the first line and truncates the reange.
//
// Parameters:
//		hrcalt [in] :			the handle to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range we want to get
//								the metrics for
//		lm [in] :				What metrics we want (midline, baseline, ...)
//		pls [out] :				Pointer to the line segment corresponding to the metrics
//								we want.
/////////////////
HRESULT WINAPI GetMetrics(HRECOALT hrcalt, RECO_RANGE* pRecoRange, LINE_METRICS lm, LINE_SEGMENT* pls)
{
    HRESULT					hr = S_OK;
    ULONG					ulStartIndex = 0, ulEndIndex = 0;
    WispSegAlternate 		*wispalt;
    XRC						*xrc = NULL;
    ULONG					ulLength = 0, ulCol = 0;
    LATINLAYOUT				ll;
    ULONG					ulStrokeCount = 0;
    ULONG					cStrokes = 0;
    int						*piStroke = NULL;
	RECT					rect;
	GLYPH					*pGlyph;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
    {
        return E_POINTER;
    }

    // Test the validity of the passed arguments
    if (IsBadWritePtr(pls, sizeof(LINE_SEGMENT))) 
    {
        return E_POINTER;
    }
    
    if (IsBadReadPtr(wispalt->wisphrc, sizeof(struct WispContext)))
    {
        return E_POINTER;
    }
    
    if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }
    
    // Get the pointer to the result structure
    xrc = (XRC*)wispalt->wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC)))
    {
        return E_POINTER;
    }
    
    // Special Case : Space Alternate
    if (!wispalt->pElements && wispalt->ulLength == 1)
    {
        return TPC_E_NOT_RELEVANT;
    }
    
    if (!wispalt->pElements)
    {
        return TPC_E_NOT_RELEVANT;
    }
    
    if (pRecoRange)
    {
        // Check the validity of the passed range
        if (!pRecoRange->cCount) 
        {
            return E_INVALIDARG;
        }
        if (pRecoRange->iwcBegin+pRecoRange->cCount > wispalt->ulLength) 
        {
            return E_INVALIDARG;
        }
        
        // Get the start index and the end index of the column
        hr = GetIndexesFromRange(wispalt, pRecoRange, &ulStartIndex, &ulEndIndex);
        if (FAILED(hr)) return hr;
        if (hr == S_FALSE)
        {
            // Only a space has been selected
            return TPC_E_NOT_RELEVANT;
        }
    }
    else
    {
        ulStartIndex = 0;
        ulEndIndex = wispalt->ulElementCount - 1;
    }

	if (ulEndIndex != ulStartIndex)
	{
		// the baseline stuff have been precomputed and cached only for "words"
		// currently, we support baseline stuff for these words only
		// a reco_range corresponding to more than one word will cause an error
		return E_FAIL;
	}
	else
	{
		int i;
		ULONG ulCol1 = ulStartIndex;
		WordPath *pwp;
		ULONG ulLineSeg, ulSegCol, ulSeg, ulWordMap, ulAlt;
		
		ASSERT(ulStartIndex == ulEndIndex);

		pwp = &wispalt->pElements[ulCol1];
		ulLineSeg = pwp->ulLineSegmentationIndex;
		ulSegCol = pwp->ulSegColIndex;
		ulSeg = pwp->ulSegmentationIndex;
		ulWordMap = pwp->ulWordMapIndex;
		ulAlt = pwp->ulIndexInWordMap;
		ll = xrc->pLineBrk->pLine[ulLineSeg].pResults->ppSegCol[ulSegCol]->ppSeg[ulSeg]->ppWord[ulWordMap]->pFinalAltList->pAlt[ulAlt].ll;
	}

    // Get the number of strokes
    cStrokes = 0;
    for (ulCol = ulStartIndex; ulCol <= ulEndIndex; ulCol++)
    {
        cStrokes += 
            xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->cStroke;
    }
    
    // Allocate a stroke array
    piStroke = (int*)ExternAlloc(cStrokes*sizeof(int));
    if (!piStroke)
        return E_OUTOFMEMORY;
    cStrokes = 0;
    for (ulCol = ulStartIndex; ulCol <= ulEndIndex; ulCol++)
    {
        ulStrokeCount = 
            xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->cStroke;
        memcpy(piStroke+cStrokes, 
            xrc->pLineBrk->pLine[wispalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
            ppSegCol[wispalt->pElements[ulCol].ulSegColIndex]->
            ppSeg[wispalt->pElements[ulCol].ulSegmentationIndex]->
            ppWord[wispalt->pElements[ulCol].ulWordMapIndex]->piStrokeIndex,
            ulStrokeCount * sizeof(int));
        cStrokes += ulStrokeCount;
    }
	pGlyph = GlyphFromStrokes(xrc->pGlyph, cStrokes, piStroke);
    ExternFree(piStroke);
	if (!pGlyph)
		return E_FAIL;
	GetRectGLYPH(pGlyph, &rect);
	DestroyGLYPH(pGlyph);

    // Set the result LINE_SEGMENT structure
    switch(lm)
    {
        
    case LM_BASELINE:
        if (ll.bBaseLineSet) 
		{
			int iBaseline;

			iBaseline = LatinLayoutToAbsolute(ll.iBaseLine, &rect);
			pls->PtA.x = rect.left;
			pls->PtA.y = iBaseline;
			pls->PtB.x = rect.right;
			pls->PtB.y = iBaseline;
		}
		else
			hr = E_FAIL;
        break;
        
    case LM_MIDLINE:
        if (ll.bMidLineSet) 
		{
			int iMidline;

			iMidline = LatinLayoutToAbsolute(ll.iMidLine, &rect);
			pls->PtA.x = rect.left;
			pls->PtA.y = iMidline;
			pls->PtB.x = rect.right;
			pls->PtB.y = iMidline;
		}
		else
            hr = E_FAIL;
        break;
        
        
    case LM_ASCENDER:
        if (ll.bAscenderLineSet) 
		{
			int iAscenderline;

			iAscenderline = LatinLayoutToAbsolute(ll.iAscenderLine, &rect);
			pls->PtA.x = rect.left;
			pls->PtA.y = iAscenderline;
			pls->PtB.x = rect.right;
			pls->PtB.y = iAscenderline;
		}
		else
		{
            // We could not define the ascender line, let's compute
            // a fake one!!!
            if (!ll.bBaseLineSet || !ll.bMidLineSet) 
                hr = E_FAIL;
			else
			{
				int iBaseline, iMidline;

				iBaseline = LatinLayoutToAbsolute(ll.iBaseLine, &rect);
				iMidline = LatinLayoutToAbsolute(ll.iMidLine, &rect);
				// We suppose we write horizontally
				pls->PtA.x = rect.left;
				pls->PtA.y = 2*iMidline - iBaseline;
				pls->PtB.x = rect.right;
				pls->PtB.y = 2*iMidline - iBaseline;
			}
        }

        
        break;
        
    case LM_DESCENDER:
        if (ll.bDescenderLineSet) 
		{
			int iDescenderline;

			iDescenderline = LatinLayoutToAbsolute(ll.iDescenderLine, &rect);
			pls->PtA.x = rect.left;
			pls->PtA.y = iDescenderline;
			pls->PtB.x = rect.right;
			pls->PtB.y = iDescenderline;
		}
		else
		{
            // We could not define the ascender line, let's compute
            // a fake one!!!
            if (!ll.bBaseLineSet || !ll.bMidLineSet) 
                hr = E_FAIL;
			else
			{
				int iBaseline, iMidline;

				iBaseline = LatinLayoutToAbsolute(ll.iBaseLine, &rect);
				iMidline = LatinLayoutToAbsolute(ll.iMidLine, &rect);
				// We suppose we write horizontally
				pls->PtA.x = rect.left;
				pls->PtA.y = 2*iBaseline - iMidline;
				pls->PtB.x = rect.right;
				pls->PtB.y = 2*iBaseline - iMidline;
			}
        }
        
        break;
    }
    
    return hr;
}

//
// GetAlternateList
//
// This function returns alternates of the best result
//
// Parameters:
//		hrc [in] :				The handle to the reco context
//		pRecoRange [in, out] :	Pointer to a RECO_RANGE that contains the range we want to get
//								the alternates for. This range comes bck modified to
//								reflect the range we actually used.
//		pSize [in, out] :		The number of alternates. If phrcalt is NULL then this function returns
//								the number of alternates it can return - Note we may return an arbitrary
//								number with an HRESULT S_FALSE if we think that the number of alternate
//								is too long to compute.
//		phrcalt [out] :			Array of alternates used to return the alternate list
//		iBreak [in] :			Mode for querying alternates: ALT_BREAKS_SAME, ALT_BREAKS_FULL or ALT_BREAKS_UNIQUE
/////////////////
HRESULT WINAPI GetAlternateList(HRECOCONTEXT hrc, RECO_RANGE* pRecoRange, ULONG*pSize, HRECOALT*phrcalt, ALT_BREAKS iBreak)
{
    HRESULT						hr = S_OK, hRes = S_OK;
    ULONG						ulStartIndex = 0, ulEndIndex = 0;
    RECO_RANGE					OriginalRecoRange;
    HRECOALT					hrcalt;
    WispSegAlternate			*wispbestalt = NULL;
    struct WispContext			*wisphrc;

	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}
        
    if (IsBadWritePtr(pSize, sizeof(ULONG)))
        return E_POINTER;

    if (phrcalt && !(*pSize)) 
        return S_OK;
    
	if (phrcalt && IsBadWritePtr(phrcalt, (*pSize)*sizeof(HRECOALT)))
        return E_POINTER;

    // Get the best alternate
    hr = GetBestAlternate(hrc, &hrcalt);
    if (FAILED(hr))
        return hr;

	if (NULL == (wispbestalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
    }
    
    // Get the ulStartIndex and ulEndIndex
    if (pRecoRange)
    {
		if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
			return E_POINTER;

        // Check the vaildity of the recorange
        if (!pRecoRange->cCount) 
        {
            hr = DestroyAlternate(hrcalt);
            ASSERT(SUCCEEDED(hr));
            return E_INVALIDARG;
        }
        if (pRecoRange->iwcBegin + pRecoRange->cCount > wispbestalt->ulLength)
        {
            hr = DestroyAlternate(hrcalt);
            ASSERT(SUCCEEDED(hr));
            return E_INVALIDARG;
        }
        OriginalRecoRange = *pRecoRange;
        hr = GetIndexesFromRange(wispbestalt, pRecoRange, &ulStartIndex, &ulEndIndex);
        if (FAILED(hr))
        {
            hRes = DestroyAlternate(hrcalt);
            ASSERT(SUCCEEDED(hRes));
            return hr;
        }
        if (hr == S_FALSE)
        {
            // Only a space has been selected.
            hRes = DestroyAlternate(hrcalt);
            ASSERT(SUCCEEDED(hRes));
            
            // If we are in diff breaks then there are no solutions
            if (iBreak == ALT_BREAKS_FULL)
            {
                *pSize = 0;
                return S_OK;
            }
            if (!phrcalt)
            {
                // We ask for the size only
                *pSize = 1;
                return S_OK;
            }
            else
            {
                // Ask for nothing? Weird but valid
                if (!(*pSize))
                    return S_OK;
                
                // Create the space alternate.
                *pSize = 1;
                hr = CreateSpaceAlternate(wisphrc, pRecoRange, phrcalt);
                return hr;
            }
        }
    }
    else
    {
        OriginalRecoRange.iwcBegin = 0;
        OriginalRecoRange.cCount = wispbestalt->ulLength;
        ulStartIndex = 0;
        ulEndIndex = wispbestalt->ulElementCount - 1;
    }
    
    // Since the method for getting alternates is widely different depending on the iBreak
    // parameter, we will call different functions for each of the iBreak values:
    switch(iBreak)
    {
    case ALT_BREAKS_SAME:
        hr = GetSameBreakAlt(wispbestalt, &OriginalRecoRange, ulStartIndex, ulEndIndex, pSize, phrcalt);
        // Cleanup : Destroy the best alternate
        DestroyAlternate(hrcalt);
        break;
    case ALT_BREAKS_UNIQUE:
        hr = GetAllBreaksAlt(wispbestalt, &OriginalRecoRange, ulStartIndex, ulEndIndex, pSize, phrcalt);
        // Cleanup : Destroy the best alternate
        DestroyAlternate(hrcalt);
        break;
    case ALT_BREAKS_FULL:
        // Cleanup : Destroy the best alternate
        hr = GetDiffBreaksAlt(wispbestalt, &OriginalRecoRange, ulStartIndex, ulEndIndex, pSize, phrcalt);
        DestroyAlternate(hrcalt);
        break;
    default:
        hr = E_INVALIDARG;
        // Cleanup : Destroy the best alternate
        DestroyAlternate(hrcalt);
        break;
    }
    
    
    return hr;
}

//
// Helper functions
//////////////////////////////////////////////////////

//
// GetIndexesFromRange
//
// This helper function gets the starting index and ending index in the alternate
// for the given recorange. It also modifies the reco range to fit a complete
// set of segments
//
// This function returns S_FALSE if only a space has been selected in the alternate
// and S_OK otherwise.
//
// Parameters:
//		wispalt [in] :			the pointer to the alternate
//		pRecoRange [in, out] :	pointer to a RECO_RANGE that contains the range
//								we want.
//		pulStartIndex [out] :	Pointer to an unsigned long that will contain the index
//								of the first column in the alternate for the range
//		pulEndIndex [out] :		Pointer to an unsigned long that will contain the index
//								of the last column in the alternate for the range
/////////////////
static HRESULT GetIndexesFromRange(WispSegAlternate *wispalt, RECO_RANGE *pRecoRange, ULONG *pulStartIndex, ULONG *pulEndIndex)
{
    HRESULT hr = S_OK;
    ULONG ulStartIndex = 0, ulEndIndex = 0;
    
    // Find the left-most segment number for this RECO_RANGE
    for (ulStartIndex = 0; ulStartIndex < wispalt->ulElementCount; ulStartIndex++)
    {
        if (wispalt->pElements[ulStartIndex].ulIndexInString >= pRecoRange->iwcBegin + 1)
            break;
    }
    ulStartIndex--;
    
    // Check that we have more than a space selected
    if (pRecoRange->cCount == 1 &&
        wispalt->ulElementCount > ulStartIndex + 1 &&
        wispalt->pElements[ulStartIndex+1].ulIndexInString == pRecoRange->iwcBegin+1)
    {
        // Only a space is selected
        return S_FALSE;
    }
    
    // Find the last segment for this RECO_RANGE
    for (ulEndIndex = ulStartIndex; ulEndIndex < wispalt->ulElementCount; ulEndIndex++)
    {
        if (wispalt->pElements[ulEndIndex].ulIndexInString >= pRecoRange->iwcBegin + pRecoRange->cCount)
            break;
    }
    ulEndIndex--;
    
    *pulStartIndex = ulStartIndex;
    *pulEndIndex = ulEndIndex;
    
    // Modify the RECO_RANGE
    pRecoRange->iwcBegin = wispalt->pElements[ulStartIndex].ulIndexInString;
    if (wispalt->ulElementCount > ulEndIndex + 1)
    {
        pRecoRange->cCount =  wispalt->pElements[ulEndIndex+1].ulIndexInString
            - pRecoRange->iwcBegin - 1; // -1 to remove the space
    }
    else
    {
        pRecoRange->cCount = wispalt->ulLength -
            pRecoRange->iwcBegin;
    }
    
    return hr;
}

//
// CreateSpaceAlternate
//
// This helper function creates a space alternate (an alternate that only contains
// a space character
//
//
// Parameters:
//		wisphrc [in] :			The pointer to the reco context structure
//		pRecoRange [in] :		The pointer to the replacement reco range to
//								store in the alternate
//		pRecoAlt [out] :		The pointer to the space alternate. (this is an already
//								allocated array
/////////////////
static HRESULT CreateSpaceAlternate(struct WispContext *wisphrc, RECO_RANGE *pRecoRange, HRECOALT *pRecoAlt)
{
    WispSegAlternate		*pWispAlt = NULL;
    
    // Valid choice, we do not want an alternate
    if (!pRecoAlt) 
        return S_OK;
    
    // Create a "space alternate"
    // Create the alternate
    pWispAlt = (WispSegAlternate*)ExternAlloc(sizeof(WispSegAlternate));
    if (!pWispAlt) 
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(pWispAlt, sizeof(WispSegAlternate));
    
    // Fill in the information for this space alternate
    pWispAlt->ReplacementRecoRange = *pRecoRange;
    pWispAlt->ulElementCount = 0; // Means space alternate
    pWispAlt->ulLength = 1;
    pWispAlt->wisphrc = wisphrc;
    pWispAlt->pElements = NULL; // means space alternate
    
    // return the alternate
	pRecoAlt[0] = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pWispAlt);

	if (0 == pRecoAlt[0])
	{
       return E_OUTOFMEMORY;
    }

    return S_OK;
}


// This structure is used to keep the results (sorted by score)
typedef struct tagSameBreaksResult
{
    ULONG	*aIndexesInWordMap;
    int		score;
    
} SameBreaksResult;

// This structure keeps for every column the index in the result
// array for the next element to be modified
// I also keeps the index in the word map that we are considering
typedef struct tagSameBreaksCurrent
{
    ULONG		ulIndexInResultArray;	// Index of the next result to modify for this segment
    WORD_MAP	*pWordMap;				// Cached pointer to the wordmap (optimization)
    ULONG		ulIndexInWordMap;		// index of the element we are considering increasing in the wordmap
    int			iScore;					// score for the next best alternate in this column
} SameBreaksCurrent;

// Value to indicate that we have gone though all the elements for one word map
#define END_WORD_MAP 0xFFFFFFFF

//
// GetSameBreakAlt
//
// This helper function gets the alternate for a given alternate
// for the same break as the top segmentation
//
// Parameters:
//		wispbestalt [in] :		  The pointer to the alternate (actually the best alternate)
//      pOriginalRecoRange [in] : Pointer to the original reco range the alternates 
//                                are queried for.
//		ulStartIndex [in] :		  Index of the first column in the alternate
//		ulEndIndex [in] :		  Index of the last column in the alternate
//		pSize [in, out] :		  Pointer to the size of the array of alternates. If phrcalt
//								  is NULL we return the number of possible alternates, otherwise
//								  we assume this is the size of the phrcalt array
//		phrcalt [out] :			  Array where we return the alternates
/////////////////
static HRESULT GetSameBreakAlt(WispSegAlternate *wispbestalt, RECO_RANGE *pOriginalRecoRange, ULONG ulStartIndex, ULONG ulEndIndex, ULONG *pSize, HRECOALT *phrcalt)
{
    HRESULT					hr = S_OK;
    XRC						*xrc = NULL;
    ULONG					ulCol = 0;
    ULONG					ulCurrentAlternateIndex = 0;
    int						iLastBestScore = 0;
    SameBreaksCurrent		*aSameBreaksCurrent = NULL;
    SameBreaksResult		*aSameBreaksResult = NULL;
    ULONG					*pColumnIndexes = NULL;
    ULONG					iRes = 0, iCurrent = 0;
    WispSegAlternate		*pNewAlternate = NULL;
    ULONG                   ulCurrentIndexInString = 0;
    ULONG                   iElement = 0, iAlternate = 0;
    int                     iLowestScore = 0; 
    ULONG                   ulLowestIndex = 0;
    ULONG                   j = 0;
    ULONG                   ulColumnCount = ulEndIndex - ulStartIndex + 1;
    
    // Get the pointer to the result structure
    xrc = (XRC*)wispbestalt->wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC)))
        return E_POINTER;
    
    // Do we want the size or the alternates?
    if (!phrcalt)
    {
        // We just want the size
        *pSize = 1;
        // This is used to check for overflow of the size
        for (ulCol = ulStartIndex; ulCol <= ulEndIndex; ulCol++)
        {
            // Multiply by the number of alternates in this column.
            (*pSize) *= 
                xrc->pLineBrk->pLine[wispbestalt->pElements[ulCol].ulLineSegmentationIndex].pResults->
                ppSegCol[wispbestalt->pElements[ulCol].ulSegColIndex]->
                ppSeg[wispbestalt->pElements[ulCol].ulSegmentationIndex]->
                ppWord[wispbestalt->pElements[ulCol].ulWordMapIndex]->pFinalAltList->cAlt;
            
            if (*pSize > MAX_ALTERNATE_NUMBER)
            {
                // Overflow
                *pSize = MAX_ALTERNATE_NUMBER;
                hr = S_FALSE;
                break;
            }
        }
    }
    else
    {
        // We actually want the array of alternates
        
        // We will keep for the current modifications in an array 
        // to track what next result column to modify
        aSameBreaksCurrent = (SameBreaksCurrent*)ExternAlloc(ulColumnCount * 
            sizeof(SameBreaksCurrent));
        if (!aSameBreaksCurrent)
        {
            *pSize = 0;
            return E_OUTOFMEMORY;
        }
        ZeroMemory(aSameBreaksCurrent, ulColumnCount * sizeof(SameBreaksCurrent));
        
        // Initialize the array of current solutions properly
        for (iCurrent = 0; iCurrent < ulColumnCount; iCurrent++)
        {
            // Everyone points at the first result
            aSameBreaksCurrent[iCurrent].ulIndexInResultArray = 0;
            // Point to the word map (to avoid havind to dereference the whole thing every time)
            aSameBreaksCurrent[iCurrent].pWordMap = 
                xrc->pLineBrk->pLine[wispbestalt->pElements[ulStartIndex + iCurrent].ulLineSegmentationIndex].pResults->
                ppSegCol[wispbestalt->pElements[ulStartIndex + iCurrent].ulSegColIndex]->
                ppSeg[wispbestalt->pElements[ulStartIndex + iCurrent].ulSegmentationIndex]->
                ppWord[wispbestalt->pElements[iCurrent + ulStartIndex].ulWordMapIndex];
            
            // Everyone points at the second element in the word map (except if 
            // there is no second element)
            if (aSameBreaksCurrent[iCurrent].pWordMap->pFinalAltList->cAlt > 1)
            {
                aSameBreaksCurrent[iCurrent].ulIndexInWordMap = 1;
            }
            else
            {
                aSameBreaksCurrent[iCurrent].ulIndexInWordMap = END_WORD_MAP;
            }
        }
        
        // Allocate the results structures
        aSameBreaksResult = (SameBreaksResult*)ExternAlloc((*pSize) * sizeof(SameBreaksResult));
        if (!aSameBreaksResult)
        {
            *pSize = 0;
            // Cleanup
            ExternFree(aSameBreaksCurrent);
            return E_OUTOFMEMORY;
        }
        ZeroMemory(aSameBreaksResult, (*pSize) * sizeof(SameBreaksResult));
        
        // Allocate the buffer for all the results wordmap column indexes
        pColumnIndexes = (ULONG*)ExternAlloc(ulColumnCount * (*pSize) * sizeof(ULONG));
        if (!pColumnIndexes)
        {
            *pSize = 0;
            // Cleanup
            ExternFree(aSameBreaksCurrent);
            ExternFree(aSameBreaksResult);
            return E_OUTOFMEMORY;
        }
        ZeroMemory(pColumnIndexes, ulColumnCount * (*pSize) * sizeof(ULONG));
        
        // Make the result array point to the right part of the wordmap
        // column index
        for (iRes = 0; iRes < *pSize; iRes++)
        {
            aSameBreaksResult[iRes].aIndexesInWordMap = pColumnIndexes + ulColumnCount * iRes;
        }
        
        // Get the last best score for the alternate
        iLastBestScore = 0;
        for (ulCol = 0; ulCol < ulColumnCount; ulCol++)
        {
            iLastBestScore += 
                xrc->pLineBrk->pLine[wispbestalt->pElements[ulStartIndex + ulCol].ulLineSegmentationIndex].pResults->
                ppSegCol[wispbestalt->pElements[ulStartIndex + ulCol].ulSegColIndex]->
                ppSeg[wispbestalt->pElements[ulStartIndex + ulCol].ulSegmentationIndex]->
                ppWord[wispbestalt->pElements[ulStartIndex + ulCol].ulWordMapIndex]->pFinalAltList->
                pAlt[wispbestalt->pElements[ulStartIndex + ulCol].ulIndexInWordMap].iCost;
        }
        
        // Set the score for the first result alternate
        aSameBreaksResult[0].score = iLastBestScore;
        
        // Cache the scores of the next best thing in each current guess
        for (iCurrent = 0; iCurrent < ulColumnCount; iCurrent++)
        {
            if (aSameBreaksCurrent[iCurrent].ulIndexInWordMap != END_WORD_MAP)
            {
                aSameBreaksCurrent[iCurrent].iScore = iLastBestScore + 
                    aSameBreaksCurrent[iCurrent].pWordMap->pFinalAltList->pAlt[aSameBreaksCurrent[iCurrent].ulIndexInWordMap].iCost -
                    aSameBreaksCurrent[iCurrent].pWordMap->pFinalAltList->pAlt[aSameBreaksCurrent[iCurrent].ulIndexInWordMap-1].iCost;
            }
        }
        
        // Then go to the next alternates
        for (ulCurrentAlternateIndex = 1; ulCurrentAlternateIndex < *pSize; ulCurrentAlternateIndex++)
        {
            // find the first unfinished wordmap
            for (iCurrent = 0; iCurrent < ulColumnCount; iCurrent++)
            {
                if (aSameBreaksCurrent[iCurrent].ulIndexInWordMap != END_WORD_MAP)
                {
                    iLowestScore = aSameBreaksCurrent[iCurrent].iScore;
                    ulLowestIndex = iCurrent;
                    break;
                }
            }
            // Is there still something to explore in the wordmaps
            if (iCurrent == ulColumnCount)
            {
                // I guess not!
                break;
            }
            // Get the index in the current structure for the lowest score for the next result
            for (iCurrent = ulLowestIndex; iCurrent < ulColumnCount; iCurrent++)
            {
                if ((aSameBreaksCurrent[iCurrent].ulIndexInWordMap != END_WORD_MAP) &&
                    (iLowestScore > aSameBreaksCurrent[iCurrent].iScore))
                {
                    iLowestScore = aSameBreaksCurrent[iCurrent].iScore;
                    ulLowestIndex = iCurrent;
                }
            }
            
            
            
            // Update the result structure by adding the new alternate
            // Add the new alternate base on the old one
            // First copy the old one
            for (iCurrent = 0; iCurrent < ulColumnCount; iCurrent++)
            {
                aSameBreaksResult[ulCurrentAlternateIndex].aIndexesInWordMap[iCurrent] = 
                    aSameBreaksResult[aSameBreaksCurrent[ulLowestIndex].ulIndexInResultArray].
                    aIndexesInWordMap[iCurrent];
            }
            // Then change the index of the current change
            aSameBreaksResult[ulCurrentAlternateIndex].aIndexesInWordMap[ulLowestIndex] =
                aSameBreaksResult[ulCurrentAlternateIndex].aIndexesInWordMap[ulLowestIndex] + 1;
            // Update the score for this alternate
            aSameBreaksResult[ulCurrentAlternateIndex].score = iLowestScore;
            
            
            
            // Update the current structure's index in the result array
            aSameBreaksCurrent[ulLowestIndex].ulIndexInResultArray++;
            
            // Update the current structure's index in the wordmap if necessary 
            if (aSameBreaksResult[aSameBreaksCurrent[ulLowestIndex].ulIndexInResultArray].aIndexesInWordMap[ulLowestIndex] == 
                aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap)
            {
                // time to bump it up since we finished all alternate with this wordmap element
                aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap++;
                // Check if we finished the elements in this wordmap
                if (aSameBreaksCurrent[ulLowestIndex].pWordMap->pFinalAltList->cAlt <=
                    (int)aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap)
                {
                    // We reached the end of this word map
                    aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap = END_WORD_MAP;
                }
            }
            // Update the score in the current structure
            if (aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap != END_WORD_MAP)
            {
                aSameBreaksCurrent[ulLowestIndex].iScore = aSameBreaksResult[aSameBreaksCurrent[ulLowestIndex].ulIndexInResultArray].score + 
                    aSameBreaksCurrent[ulLowestIndex].pWordMap->pFinalAltList->pAlt[aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap].iCost -
                    aSameBreaksCurrent[ulLowestIndex].pWordMap->pFinalAltList->pAlt[aSameBreaksCurrent[ulLowestIndex].ulIndexInWordMap-1].iCost;
            }
        }
        
        // Fill the alternate array
        *pSize = ulCurrentAlternateIndex;
        for (iAlternate = 0; iAlternate < *pSize; iAlternate++)
        {
            // Create the alternate
            pNewAlternate = (WispSegAlternate*)ExternAlloc(sizeof(WispSegAlternate));
            if (!pNewAlternate)
            {
                // Cleanup of the previous alternates
                for (j = 0; j < iAlternate; j++)
                    DestroyAlternate(phrcalt[j]);
                // Cleanup the current alternate
                hr = E_OUTOFMEMORY;
                break;
            }
            ZeroMemory(pNewAlternate, sizeof(WispSegAlternate));
            pNewAlternate->wisphrc = wispbestalt->wisphrc;
            pNewAlternate->ulElementCount = ulColumnCount;
            pNewAlternate->pElements = (WordPath*)ExternAlloc(pNewAlternate->ulElementCount * sizeof(WordPath));
            if (!pNewAlternate->pElements)
            {
                // Cleanup of the previous alternates
                for (j = 0; j < iAlternate; j++)
                    DestroyAlternate(phrcalt[j]);
                // Cleanup the current alternate
                DestroyInternalAlternate(pNewAlternate);
                hr = E_OUTOFMEMORY;
                break;
            }
            // Fill in the elements structure for the alternate
            ulCurrentIndexInString = 0;
            for (iElement = 0; iElement < pNewAlternate->ulElementCount; iElement++)
            {
                // Everything but the index in the word map is the same as
                // the best alternate
                pNewAlternate->pElements[iElement] = wispbestalt->pElements[iElement + ulStartIndex];
                pNewAlternate->pElements[iElement].ulIndexInWordMap = 
                    aSameBreaksResult[iAlternate].aIndexesInWordMap[iElement];
                
                // Also the index of the segment in the result string is different
                pNewAlternate->pElements[iElement].ulIndexInString = ulCurrentIndexInString;
                // Add the length of this alternate to the ulCurrentIndexInString
                ulCurrentIndexInString += strlen(
                    xrc->pLineBrk->pLine[pNewAlternate->pElements[iElement].ulLineSegmentationIndex].pResults->
                    ppSegCol[pNewAlternate->pElements[iElement].ulSegColIndex]->
                    ppSeg[pNewAlternate->pElements[iElement].ulSegmentationIndex]->
                    ppWord[pNewAlternate->pElements[iElement].ulWordMapIndex]->
                    pFinalAltList->pAlt[pNewAlternate->
                    pElements[iElement].ulIndexInWordMap].pszStr);
                ulCurrentIndexInString++; // Add one for the space
            }
            
            // Add the length of the alternate string to the alternate structure
            pNewAlternate->ulLength = ulCurrentIndexInString - 1; // Remove the last space
            
            // Add the original reco range the alternate was queried for
            pNewAlternate->ReplacementRecoRange = *pOriginalRecoRange;
            
            // Add the inferno score to the alternate
            pNewAlternate->iInfernoScore = aSameBreaksResult[iAlternate].score;
            
            // Add the new alternate to the array of alternates
			phrcalt[iAlternate] = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pNewAlternate);

			if (0 == phrcalt[iAlternate])
			{
			  // Cleanup of the previous alternates
                for (j = 0; j < iAlternate; j++)
                    DestroyAlternate(phrcalt[j]);
                // Cleanup the current alternate
                DestroyInternalAlternate(pNewAlternate);
                hr = E_OUTOFMEMORY;
                break;
			}
        }
        
        // Cleanup
        ExternFree(aSameBreaksCurrent);
        ExternFree(aSameBreaksResult);
        ExternFree(pColumnIndexes);
    }
    return hr;
}


#define END_POINT 0xFFFFFFFF

//
// CompareInfernoAlt
//
// This function is used as the compare function in a qsort
// it uses the Inferno score to sort alternates in an array
//
// Parameters:
//		arg1 [in] :	The first alternate
//      arg2 [in] : The second alternate
// Return Values:
//      < 0 arg1 better score than arg2 
//      0 arg1 same score as arg2 
//      > 0 arg1 worse score than arg2 
/////////////////
int _cdecl CompareInfernoAlt(const void *arg1, const void *arg2)
{
    return ( (*(WispSegAlternate**)arg1)->iInfernoScore - (*(WispSegAlternate**)arg2)->iInfernoScore );
}

//
// GetAllBreaksAlt
//
// This helper function gets the best alternate for each segmentation
// for the given range of ink
//
// Parameters:
//		wispbestalt [in] :		  The pointer to the alternate (actually the best alternate)
//      pOriginalRecoRange [in] : Pointer to the original reco range the alternates 
//                                are queried for.
//		ulStartIndex [in] :		  Index of the first column in the alternate
//		ulEndIndex [in] :		  Index of the last column in the alternate
//		pSize [in, out] :		  Pointer to the size of the array of alternates. If phrcalt
//								  is NULL we return the number of possible alternates, otherwise
//								  we assume this is the size of the phrcalt array
//		phrcalt [out] :			  Array where we return the alternates
/////////////////
static HRESULT GetAllBreaksAlt(WispSegAlternate *wispbestalt, RECO_RANGE *pOriginalRecoRange, ULONG ulStartIndex, ULONG ulEndIndex, ULONG *pSize, HRECOALT *phrcalt)
{
    HRESULT                 hr = S_OK;
    XRC						*xrc = NULL;
    
    ULONG                   ulNumberOfLineSeg = 0, ulSegColCount = 0;
    ULONG                   iLineSeg = 0, iCol = 0, iSegCol = 0;
    ULONG                   ulEndSegColIndex = 0, ulStartSegColIndex = 0;
    ULONG                   ulEndWordMapIndex = 0, ulStartWordMapIndex = 0;
    ULONG                   ulWordMapCount = 0;
    ULONG                   iCurrentSegColAlt = 0;
    LineSegAlt              *aSegColCurrentAlts = NULL;
    int                     iSeg = 0, jSeg = 0;
    ULONG                   iWordMap = 0;
    LineSegAlt              *aSegColAlts = NULL;
    ULONG                   cSegColAlts = 0;
    ULONG                   cLineSegAlts = 0;
    LineSegAlt              *aLineSegAlts = NULL;
    ULONG                   iAlternate = 0;
    WispSegAlternate        *pNewAlternate = NULL;
    ULONG                   j = 0;
    ULONG                   ulCurrentIndexInString = 0;
    ULONG                   iElement = 0;
    int                     iStart = 0, iEnd = 0;
    
    // Get the pointer to the result structure
    xrc = (XRC*)wispbestalt->wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC)))
        return E_POINTER;
    
    // Do we want the size or the alternates?
    if (!phrcalt)
    {
        // We just want the size
        // Unfortunately calculating the size is costly
        // we will return and arbitrary number for now
        *pSize = 10;
        hr = S_FALSE;
    }
    else
    {
        // Determine how many LineSeg we are selecting
        ulNumberOfLineSeg = wispbestalt->pElements[ulEndIndex].ulLineSegmentationIndex- 
            wispbestalt->pElements[ulStartIndex].ulLineSegmentationIndex + 1;
        
        // For each LineSeg do the work
        for (iLineSeg = wispbestalt->pElements[ulStartIndex].ulLineSegmentationIndex;
        iLineSeg <= wispbestalt->pElements[ulEndIndex].ulLineSegmentationIndex;
        iLineSeg ++)
        {
            // Determine what is the starting and ending SegCol for this LineSeg
            // Starting Point
            ulStartSegColIndex = 0;
            for (iCol = ulStartIndex; iCol <= ulEndIndex; iCol++)
            {
                if (iLineSeg == wispbestalt->pElements[iCol].ulLineSegmentationIndex)
                {
                    ulStartSegColIndex = iCol;
                    break;
                }
            }
            // Ending Point
            ulEndSegColIndex = END_POINT;
            for (iCol = ulStartSegColIndex; iCol <= ulEndIndex; iCol++)
            {
                // Find the last one using this Line Seg
                if (iLineSeg != wispbestalt->pElements[iCol].ulLineSegmentationIndex)
                {
                    ulEndSegColIndex = iCol-1;
                    break;
                }
            }
            if (END_POINT == ulEndSegColIndex)
                ulEndSegColIndex = ulEndIndex;
            
            // Get the number of SegCols selected for this Line Seg
            ulSegColCount = wispbestalt->pElements[ulEndSegColIndex].ulSegColIndex - 
                wispbestalt->pElements[ulStartSegColIndex].ulSegColIndex + 1;
            
            
            // For each SegCol get the segmentation/wordmap corresponding to the ink
            for (iSegCol = wispbestalt->pElements[ulStartSegColIndex].ulSegColIndex; 
            iSegCol <= wispbestalt->pElements[ulEndSegColIndex].ulSegColIndex; 
            iSegCol++)
            {
                // Allocate the array of SegCol alternate
                // There cannot be more than the number of segmentation in the segcol
                aSegColCurrentAlts = 
                    (LineSegAlt*)ExternAlloc(sizeof(LineSegAlt) * xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg);
                if (!aSegColCurrentAlts)
                {
                    // We are out of memory
                    hr = E_OUTOFMEMORY;
                    if (aSegColAlts)
                        FreeSegColAltArray(aSegColAlts, cSegColAlts);
                    aSegColAlts = NULL;
                    if (aLineSegAlts)
                        FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                    aLineSegAlts = NULL;
                    return hr;
                }
                // Initialize the whole array with 0s
                ZeroMemory(aSegColCurrentAlts, 
                    sizeof(LineSegAlt) * xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg);
                
                iCurrentSegColAlt = 0;
                
                // Determine what is the starting and ending SegCol for this LineSeg
                // Starting Point
                ulStartWordMapIndex = 0;
                for (iCol = ulStartSegColIndex; iCol <= ulEndSegColIndex; iCol++)
                {
                    if (iSegCol == wispbestalt->pElements[iCol].ulSegColIndex)
                    {
                        ulStartWordMapIndex = iCol;
                        break;
                    }
                }
                // Ending Point
                ulEndWordMapIndex = END_POINT;
                for (iCol = ulStartWordMapIndex; iCol <= ulEndSegColIndex; iCol++)
                {
                    // Find the last one using this Line Seg
                    if (iSegCol != wispbestalt->pElements[iCol].ulSegColIndex)
                    {
                        ulEndWordMapIndex = iCol-1;
                        break;
                    }
                }
                if (END_POINT == ulEndWordMapIndex)
                    ulEndWordMapIndex = ulEndSegColIndex;
                
                // How many wordmaps for this SegCol are selected
                ulWordMapCount = ulEndWordMapIndex - ulStartWordMapIndex + 1;
                
                // Is the whole SegCol selected? (We assume this is for the segmentation 0)
                if ((int)ulWordMapCount == xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[0]->cWord)
                {
                    
                    // Yes, return all possible Segmentation with the complete WordMaps
                    // Create the seg col alternate for each segmentation in this seg col
                    for (iSeg = 0; iSeg < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg; iSeg++)
                    {
                        // Define the count of wordmaps for this segmentation
                        ulWordMapCount = xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg]->cWord;
                        // Allocate the array of SCWMElement for this alternate
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths = 
                            (WordPath*)ExternAlloc(sizeof(WordPath)*ulWordMapCount);
                        if (!aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths)
                        {
                            FreeSegColAltArray(aSegColCurrentAlts, iCol);
                            aSegColCurrentAlts = NULL;
                            if (aSegColAlts)
                                FreeSegColAltArray(aSegColAlts, cSegColAlts);
                            aSegColAlts = NULL;
                            if (aLineSegAlts)
                                FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                            aLineSegAlts = NULL;
                            return E_OUTOFMEMORY;
                        }
                        // Fill the SegCol Alternate's aSegColCurrentAlts array
                        for (iWordMap = 0; iWordMap < ulWordMapCount; iWordMap++)
                        {
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulSegmentationIndex = iSeg;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulWordMapIndex = iWordMap;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulIndexInWordMap = 0;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulLineSegmentationIndex = iLineSeg;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulSegColIndex = iSegCol;
                            // We will store the inferno score since it is the only one that can be compared
                            // in different segmentations. 
                            // First make sure the inferno score is computed
                            if (!xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                ppSeg[iSeg]->ppWord[iWordMap]->
                                pInfernoAltList)
                            {
                                WordMapRecognizeWrap(xrc,
									NULL,
                                    xrc->pLineBrk->pLine[iLineSeg].pResults,
                                    xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                    ppSeg[iSeg]->ppWord[iWordMap], NULL);
                            }
                            // Then add the score to the current one.
                            aSegColCurrentAlts[iCurrentSegColAlt].score += 
                                xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                ppSeg[iSeg]->ppWord[iWordMap]->pInfernoAltList->pAlt[0].iCost;
                        }
                        aSegColCurrentAlts[iCurrentSegColAlt].cWM = ulWordMapCount;
                        // We just added a Seg Col alternate to the array, bump the count up
                        iCurrentSegColAlt++;
                    }
                }
                else
                {
                    // No, try to see in each Segmentation if there is a set of WordMap that
                    // corresponds to the strokes selected in the main segmenation.
                    
                    // We need to add the best segmentation
                    // Allocate the array of SCWMElement for this alternate
                    aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths = 
                        (WordPath*)ExternAlloc(sizeof(WordPath)*ulWordMapCount);
                    if (!aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths)
                    {
                        FreeSegColAltArray(aSegColCurrentAlts, iCol);
                        aSegColCurrentAlts = NULL;
                        if (aSegColAlts)
                            FreeSegColAltArray(aSegColAlts, cSegColAlts);
                        aSegColAlts = NULL;
                        if (aLineSegAlts)
                            FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                        aLineSegAlts = NULL;
                        return E_OUTOFMEMORY;
                    }
                    // Fill the SegCol Alternate's aSegColCurrentAlts array
                    for (iWordMap = 0; iWordMap < ulWordMapCount; iWordMap++)
                    {
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulSegmentationIndex = 0;
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulWordMapIndex = iWordMap +
                            wispbestalt->pElements[ulStartWordMapIndex].ulWordMapIndex;
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulIndexInWordMap = 0;
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulLineSegmentationIndex = iLineSeg;
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulSegColIndex = iSegCol;
                        
                        // We will store the inferno score since it is the only one that can be compared
                        // in different segmentations. First make sure the infrno score is computed
                        if (!xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                            ppSeg[0]->ppWord[iWordMap + wispbestalt->
                            pElements[ulStartWordMapIndex].ulWordMapIndex]->
                            pInfernoAltList)
                        {
                            WordMapRecognizeWrap(xrc, 
								NULL,
                                xrc->pLineBrk->pLine[iLineSeg].pResults,
                                xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                ppSeg[0]->ppWord[iWordMap + wispbestalt->
                                pElements[ulStartWordMapIndex].ulWordMapIndex], NULL);
                        }
                        // Then add the inferno score to the current one
                        aSegColCurrentAlts[iCurrentSegColAlt].score += 
                            xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                            ppSeg[0]->ppWord[iWordMap + wispbestalt->
                            pElements[ulStartWordMapIndex].ulWordMapIndex]->
                            pInfernoAltList->pAlt[0].iCost;
                    }
                    aSegColCurrentAlts[iCurrentSegColAlt].cWM = ulWordMapCount;
                    // We just added a Seg Col alternate to the array, bump the count up
                    iCurrentSegColAlt++;
                    
                    
                    // Then try all the other segmentations
                    for (iSeg = 1; iSeg < xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->cSeg; iSeg++)
                    {
                        // First does this segmentation contain WordMaps that match the same words
                        if (!GetMatchingWordMapRange(xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[0],
                            wispbestalt->pElements[ulStartWordMapIndex].ulWordMapIndex, 
                            wispbestalt->pElements[ulEndWordMapIndex].ulWordMapIndex,
                            xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->ppSeg[iSeg],
                            &iStart, &iEnd, 
                            (wispbestalt->pElements[ulStartSegColIndex].ulWordMapIndex != 0 ? FALSE : TRUE),
                            (iSegCol != wispbestalt->pElements[ulEndSegColIndex].ulSegColIndex ? TRUE : FALSE))
                            )
                        {
                            continue;
                        }
                        ulWordMapCount = iEnd - iStart + 1;
                        // Allocate the array of WordPath for this alternate
                        aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths = 
                            (WordPath*)ExternAlloc(sizeof(WordPath)*ulWordMapCount);
                        if (!aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths)
                        {
                            FreeSegColAltArray(aSegColCurrentAlts, iCol);
                            aSegColCurrentAlts = NULL;
                            if (aSegColAlts)
                                FreeSegColAltArray(aSegColAlts, cSegColAlts);
                            aSegColAlts = NULL;
                            if (aLineSegAlts)
                                FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                            aLineSegAlts = NULL;
                            return E_OUTOFMEMORY;
                        }
                        // Fill the SegCol Alternate's aSegColCurrentAlts array
                        for (iWordMap = 0; iWordMap < ulWordMapCount; iWordMap++)
                        {
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulSegmentationIndex = iSeg;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulWordMapIndex = iWordMap +
                                iStart;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulIndexInWordMap = 0;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulLineSegmentationIndex = iLineSeg;
                            aSegColCurrentAlts[iCurrentSegColAlt].aWordPaths[iWordMap].ulSegColIndex = iSegCol;
                            // We will store the inferno score since it is the only one that can be compared
                            // in different segmentations
                            if (!xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                ppSeg[iSeg]->ppWord[iWordMap + iStart]->
                                pInfernoAltList)
                            {
                                WordMapRecognizeWrap(xrc, 
									NULL,
                                    xrc->pLineBrk->pLine[iLineSeg].pResults,
                                    xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                    ppSeg[iSeg]->ppWord[iWordMap + iStart], NULL);
                            }
                            
                            aSegColCurrentAlts[iCurrentSegColAlt].score += 
                                xrc->pLineBrk->pLine[iLineSeg].pResults->ppSegCol[iSegCol]->
                                ppSeg[iSeg]->ppWord[iWordMap + iStart]->
                                pInfernoAltList->pAlt[0].iCost;
                            
                        }
                        aSegColCurrentAlts[iCurrentSegColAlt].cWM = ulWordMapCount;
                        
                        // Check that this combination of WORDMAPS is not already used
                        if (!IsAltPresentInThisSegmentation(xrc, aSegColCurrentAlts, iCurrentSegColAlt))
                        {
                            // We just added a Seg Col alternate to the array, bump the count up
                            iCurrentSegColAlt++;
                        }
                    }
                }
                
                hr = MergeLineSegAltArrays(&aSegColAlts, &cSegColAlts, &aSegColCurrentAlts, iCurrentSegColAlt);
                FreeSegColAltArray(aSegColCurrentAlts, iCurrentSegColAlt);
                if (FAILED(hr))
                {
                    if (aSegColAlts)
                        FreeSegColAltArray(aSegColAlts, cSegColAlts);
                    aSegColAlts = NULL;
                    if (aLineSegAlts)
                        FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                    aLineSegAlts = NULL;
                    return E_OUTOFMEMORY;
                }
            } // We have done all the SegCols for this LineSeg
            // Combine the results with this new LineSeg's SegCol alternate
            hr = MergeLineSegAltArrays(&aLineSegAlts, &cLineSegAlts, &aSegColAlts, cSegColAlts);
            FreeSegColAltArray(aSegColAlts, cSegColAlts);
            if (FAILED(hr))
            {
                if (aLineSegAlts)
                    FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                aLineSegAlts = NULL;
                return E_OUTOFMEMORY;
            }
            aSegColAlts = NULL;
            
        }
        
        // Create the alternates.
        // We will only create the number of alternate that we need
        // First compute the real numberwe want to use
        if (*pSize > cLineSegAlts)
            *pSize = cLineSegAlts;
        // For each alternate, create it
        for (iAlternate = 0; iAlternate < *pSize; iAlternate++)
        {
            // Create the alternate
            pNewAlternate = (WispSegAlternate*)ExternAlloc(sizeof(WispSegAlternate));
            if (!pNewAlternate)
            {
                // Cleanup of the previous alternates
                for (j = 0; j < iAlternate; j++)
                {
                    hr = DestroyAlternate(phrcalt[j]);
                    ASSERT(SUCCEEDED(hr));
                }
                // Cleanup the current alternate
                hr = DestroyInternalAlternate(pNewAlternate);
                ASSERT(SUCCEEDED(hr));
                if (aLineSegAlts)
                    FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                aLineSegAlts = NULL;
                hr = E_OUTOFMEMORY;
                break;
            }
            ZeroMemory(pNewAlternate, sizeof(WispSegAlternate));
            pNewAlternate->wisphrc = wispbestalt->wisphrc;
            pNewAlternate->ulElementCount = aLineSegAlts[iAlternate].cWM;
            
            // Add the inferno score
            pNewAlternate->iInfernoScore = aLineSegAlts[iAlternate].score;
            
            // Put the pointer to the elements
            pNewAlternate->pElements = aLineSegAlts[iAlternate].aWordPaths;
            aLineSegAlts[iAlternate].aWordPaths = NULL;
            
            // Fill in the elements structure for the alternate
            ulCurrentIndexInString = 0;
            for (iElement = 0; iElement < pNewAlternate->ulElementCount; iElement++)
            {
                // Everything but the index in the word map is the same as
                // the best alternate
                // Also the index of the segment in the result string is different
                pNewAlternate->pElements[iElement].ulIndexInString = ulCurrentIndexInString;
                
                // If the Final Alt List is not computed, compute it!
                if (!xrc->pLineBrk->pLine[pNewAlternate->pElements[iElement].ulLineSegmentationIndex].pResults->
                    ppSegCol[pNewAlternate->pElements[iElement].ulSegColIndex]->
                    ppSeg[pNewAlternate->pElements[iElement].ulSegmentationIndex]->
                    ppWord[pNewAlternate->pElements[iElement].ulWordMapIndex]->
                    pFinalAltList)
                {
                    // The Final Alt List has not been computed for this Word map
                    // because it is not part of the best segmentation
                    // Compute it
                    if (!WordMapRecognizeWrap(xrc, 
						NULL,
                        xrc->pLineBrk->pLine[pNewAlternate->pElements[iElement].ulLineSegmentationIndex].pResults,
                        xrc->pLineBrk->pLine[pNewAlternate->pElements[iElement].ulLineSegmentationIndex].pResults->
                        ppSegCol[pNewAlternate->pElements[iElement].ulSegColIndex]->
                        ppSeg[pNewAlternate->pElements[iElement].ulSegmentationIndex]->
                        ppWord[pNewAlternate->pElements[iElement].ulWordMapIndex], NULL))
                    {
                        // Something went wrong in the computation of the Final Alt List
                        // We should maybe recover nicely, but I won't
                        // Cleanup of the previous alternates
                        for (j = 0; j < iAlternate; j++)
                            DestroyAlternate(phrcalt[j]);
                        // Cleanup the current alternate
                        DestroyInternalAlternate(pNewAlternate);
                        if (aLineSegAlts)
                            FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
                        aLineSegAlts = NULL;
                        hr = E_OUTOFMEMORY;
                        break;
                        
                    }
                }
                // Add the length of this alternate to the ulCurrentIndexInString
                ulCurrentIndexInString += strlen(
                    xrc->pLineBrk->pLine[pNewAlternate->pElements[iElement].ulLineSegmentationIndex].pResults->
                    ppSegCol[pNewAlternate->pElements[iElement].ulSegColIndex]->
                    ppSeg[pNewAlternate->pElements[iElement].ulSegmentationIndex]->
                    ppWord[pNewAlternate->pElements[iElement].ulWordMapIndex]->
                    pFinalAltList->pAlt[pNewAlternate->
                    pElements[iElement].ulIndexInWordMap].pszStr);
                ulCurrentIndexInString++; // Add one for the space
            }
            
            // Add the length of the alternate string to the alternate structure
            pNewAlternate->ulLength = ulCurrentIndexInString - 1; // Remove the last space
            
            // Add the original reco range the alternate was queried for
            pNewAlternate->ReplacementRecoRange = *pOriginalRecoRange;
            
            // Add the new alternate to the array of alternates
			phrcalt[iAlternate] = (HRECOALT)CreateTpgHandle(TPG_HRECOALT, pNewAlternate);

			if (0 == phrcalt[iAlternate])
			{
				for (j = 0; j < iAlternate; j++)
					DestroyAlternate(phrcalt[j]);
				// Cleanup the current alternate
				DestroyInternalAlternate(pNewAlternate);
				if (aLineSegAlts)
					FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
				aLineSegAlts = NULL;
				hr = E_OUTOFMEMORY;
				break;
			}
        }
        
        // Free the aLineSegAlts array
        if (aLineSegAlts)
            FreeSegColAltArray(aLineSegAlts, cLineSegAlts);
        
        // Sort the array of alternate by Inferno score
        if (SUCCEEDED(hr))
        qsort((void*)(phrcalt+1), (size_t)(*pSize - 1), sizeof(WispSegAlternate*), CompareInfernoAlt);
    }
    
    return hr;
}

//
// FreeSegColAltArray
//
// Helper function to free the an array of Seg Col alternates
//
// Parameters:
//		aSegColCurrentAlts [in] : The array of segcol alternate to be freed
//		cElements [in]          : Number of Seg Col Alternates in the array
/////////////////
static void FreeSegColAltArray(LineSegAlt *aSegColCurrentAlts, const int cElements)
{
    int jSeg = 0;
    
    if (!aSegColCurrentAlts)
        return;
    
    // Free the preceding aSCWMElements
    for (jSeg = 0; jSeg < cElements; jSeg++)
    {
        ExternFree(aSegColCurrentAlts[jSeg].aWordPaths);
    }
    // Free the aSegColCurrentAlts array 
    ExternFree(aSegColCurrentAlts);
}

//
// MergeLineSegAltArrays
//
// Helper function to merge two LineSegAlt arrays. Basically the new number of
// elements will be the size of the first array time the size of the second array.
// The new array will contain the combination of all the elements of the two
// arrays
//
// Parameters:
//		paAlts [in, out] : Pointer to the first array of Line Seg Alts. It is also
//                         the result of the merging
//      pcAlts [in, out] : Pointer to the number of elements in the first array. It
//                         is also the number of elements in the merged array (result)
//      paNewAlts [in]   : Pointer to the second array of Line Seg Alts. Could be NULL 
//                         on return if the first array was NULL, thus we assigned
//                         the value of the second array to the first and should not
//                         free the second array on returning from this call
//		cNewAlts [in]    : Number of Line seg Alternates in the second array
/////////////////
static HRESULT MergeLineSegAltArrays(LineSegAlt **paAlts, ULONG *pcAlts, LineSegAlt **paNewAlts, const ULONG cNewAlts)
{
    LineSegAlt      *aOldAlts = NULL;
    ULONG           ulCurrentAlt = 0;
    ULONG           iAlt = 0, iOldAlt = 0;
    
    // Add the results from this last Seg Col to the global results for the LineSeg
    if (NULL == *paAlts)
    {
        // Special case if this is the first SegCol Just create the aLineSeg array
        *paAlts = (LineSegAlt*)(*paNewAlts);
        
        // Set the secodn array to NULL to avoid freeing it on returning from this function
        *paNewAlts = NULL;
        
        // Set the current numbr of elements in the aSegColAlts array
        *pcAlts = cNewAlts;
    }
    else
    {
        // Normal case: 
        // We are actually going to multiply the number of previous alternates 
        // by the new count of alternates
        
        // Save the old array of alternates
        aOldAlts = *paAlts;
        
        // Create the new array of alternates
        *paAlts = (LineSegAlt*)ExternAlloc(sizeof(LineSegAlt) * cNewAlts * (*pcAlts));
        if (NULL == *paAlts)
        {
            *paAlts = aOldAlts;
            return E_OUTOFMEMORY;
        }
        
        // Set the index of the the current alternate
        ulCurrentAlt = 0;
        
        // Fill the new array of alternates
        for (iAlt = 0; iAlt < cNewAlts; iAlt++)
        {
            for (iOldAlt = 0; iOldAlt < *pcAlts; iOldAlt++)
            {
                // Get the number of Word Map for this alternate
                (*paAlts)[ulCurrentAlt].cWM = aOldAlts[iOldAlt].cWM + 
                    (*paNewAlts)[iAlt].cWM;
                
                // Allocate the aSegColAlts->aSCWMElements for this alternate
                (*paAlts)[ulCurrentAlt].aWordPaths = 
                    (WordPath*)ExternAlloc(sizeof(WordPath)*(*paAlts)[ulCurrentAlt].cWM);
                if (!(*paAlts)[ulCurrentAlt].aWordPaths)
                {
                    FreeSegColAltArray((*paAlts), ulCurrentAlt);
                    FreeSegColAltArray(aOldAlts, (*pcAlts));
                    return E_OUTOFMEMORY;
                };
                
                // Copy the data in the new array of SCWMElements
                // First copy the part from the old alternate
                memcpy((*paAlts)[ulCurrentAlt].aWordPaths,
                    aOldAlts[iOldAlt].aWordPaths, 
                    sizeof(WordPath)*aOldAlts[iOldAlt].cWM);
                // Then copy the new stuff
                memcpy((*paAlts)[ulCurrentAlt].aWordPaths +
                    aOldAlts[iOldAlt].cWM,
                    (*paNewAlts)[iAlt].aWordPaths, 
                    sizeof(WordPath)*(*paNewAlts)[iAlt].cWM);
                
                // Compute the new score for this alternate
                (*paAlts)[ulCurrentAlt].score = 
                    aOldAlts[iOldAlt].score + 
                    (*paNewAlts)[iAlt].score;
                
                // Increment the index of the alternate in the aSegColAlts
                ulCurrentAlt++;
            }
        } // Finished combining the SegCol alternate 
        
        // Free the old array of alternates
        if (aOldAlts)
            FreeSegColAltArray(aOldAlts, (*pcAlts));
        
        // Set the new number of elements in the aSegColAlts array
        (*pcAlts) *= cNewAlts;
    }// End of filling the array of SegCol alternates
    
    return S_OK;
}

#define MAX_UNIQUE_BREAKS 20
//
// GetDiffBreaksAlt
//
// This helper function gets the best alternate for each segmentation
// for the given range of ink, then on each of these alternates it
// gets a list of same break alternates.
//
// Parameters:
//		wispbestalt [in] :		  The pointer to the alternate (actually the best alternate)
//      pOriginalRecoRange [in] : Pointer to the original reco range the alternates 
//                                are queried for.
//		ulStartIndex [in] :		  Index of the first column in the alternate
//		ulEndIndex [in] :		  Index of the last column in the alternate
//		pSize [in, out] :		  Pointer to the size of the array of alternates. If phrcalt
//								  is NULL we return the number of possible alternates, otherwise
//								  we assume this is the size of the phrcalt array
//		phrcalt [out] :			  Array where we return the alternates
/////////////////
static HRESULT GetDiffBreaksAlt(WispSegAlternate *wispbestalt, RECO_RANGE *pOriginalRecoRange, ULONG ulStartIndex, ULONG ulEndIndex, ULONG *pSize, HRECOALT *phrcalt)
{
    HRESULT             hr = S_OK;
    XRC                 *xrc = NULL;
    HRECOALT            aUBAlts[MAX_UNIQUE_BREAKS];
    ULONG               ulUniqueBreaksCount = MAX_UNIQUE_BREAKS;
    HRECOALT            *aTempAlt = NULL;
    HRECOALT            *aBufferAlt = NULL;
    ULONG               ulTempAltCount = 0;
    ULONG               iAlt = 0, iSeg = 0;
    WispSegAlternate    *pAlt = NULL;
    ULONG               ulCurrentCount = 0;
    BOOL                bAnyAltAdded = FALSE;
    
    // Get the pointer to the result structure
    xrc = (XRC*)wispbestalt->wisphrc->hrc;
    if (!xrc)
        return E_POINTER;
    
    // Do we want the size or the alternates?
    if (!phrcalt)
    {
        // We just want the size
        // Unfortunately calculating the size is costly
        // we will return and arbitrary number for now
        *pSize = 10;
        hr = S_FALSE;
    }
    else
    {
        // We are going to ask for UNIQUE_BREAKS and then on each of them
        // ask for ALT_BREAKS_SAME, then sort the results
        
        // First ask for UNIQUE_BREAKS
        hr = GetAllBreaksAlt(wispbestalt, pOriginalRecoRange, 
            ulStartIndex, ulEndIndex, 
            &ulUniqueBreaksCount, aUBAlts);
        if (FAILED(hr))
            return hr;
        
        // Allocate a temporary array of alternates that
        // will act as a buffer for sorting the alternate
        aBufferAlt = (HRECOALT*)ExternAlloc(sizeof(HRECOALT) * (*pSize));
        if (!aBufferAlt)
        {
            // Free the UNIQUE_BREAKS alternates
            for (iAlt = 0; iAlt < ulUniqueBreaksCount; iAlt++)
                DestroyAlternate(aUBAlts[iAlt]);
            return E_OUTOFMEMORY;
        }
        
        // Allocate a temporary array of alternates
        aTempAlt = (HRECOALT*)ExternAlloc(sizeof(HRECOALT) * (*pSize));
        if (!aTempAlt)
        {
            // Free the UNIQUE_BREAKS alternates
            for (iAlt = 0; iAlt < ulUniqueBreaksCount; iAlt++)
                DestroyAlternate(aUBAlts[iAlt]);
            // Free the buffer array
            ExternFree(aBufferAlt);
            return E_OUTOFMEMORY;
        }
        // for each segmentation returned add the alternates to the list
        for (iSeg = 0; iSeg < ulUniqueBreaksCount; iSeg++)
        {
            ulTempAltCount = *pSize;
            
			if (NULL != (pAlt = (WispSegAlternate*)FindTpgHandle((HANDLE)aUBAlts[iSeg], TPG_HRECOALT)) )
			{
            // Get the list of ALT_BREAKS_SAME alternates for this segmentation
            hr = GetSameBreakAlt(pAlt, 
                pOriginalRecoRange, 0, pAlt->ulElementCount - 1, 
                &ulTempAltCount, aTempAlt);
			}
			else
			{
				hr = E_FAIL;
			}

            if (FAILED(hr))
            {
                // Free the UNIQUE_BREAKS alternates
                for (iAlt = 0; iAlt < ulUniqueBreaksCount; iAlt++)
                    DestroyAlternate(aUBAlts[iAlt]);
                // Free the current results
                for (iAlt = 0; iAlt < ulCurrentCount; iAlt++)
                    DestroyAlternate(phrcalt[iAlt]);
                ExternFree(aTempAlt);
                ExternFree(aBufferAlt);
                return hr;
            }
            // Add these alternates to the results array
            bAnyAltAdded = CombineAlternates(phrcalt, 
                &ulCurrentCount, *pSize, 
                aTempAlt, ulTempAltCount, aBufferAlt);
            // Did we add and alternate this time?
            if (FALSE == bAnyAltAdded)
            {
                // Since the next UNIQUE_BREAKS alternates will have a lower score there
                // is no need continuing with them if we know none will be added
                break;
            }
        }
        // Set the real size of the array of alternates
        *pSize = ulCurrentCount;
        
        // Free the UNIQUE_BREAKS alternates
        for (iAlt = 0; iAlt < ulUniqueBreaksCount; iAlt++)
            DestroyAlternate(aUBAlts[iAlt]);
        
        // Free the temp array of alternates
        ExternFree(aTempAlt);
        // Free the array for sorting alternates
        ExternFree(aBufferAlt);
        
    }
    return hr;
}

//
// CombineAlternates
//      This function add alternates from an array to an exisiting
//      array of alternate. It will destroy all alternates that it 
//      does not use.
//
// Parameter:
//      aFinalAlt       [in, out]
//      pFinalAltCount  [in, out]
//      ulMaxCount      [in]
//      aAddAlt         [in]
//      ulAddAltCount   [in]
//      aBufferAlt      [in]
//
// Return Value:
//      TRUE : An alternate from the array has been added
//      FALSE : No alternate from the array has been added
static BOOL CombineAlternates(HRECOALT *aFinalAlt, 
                       ULONG *pFinalAltCount, 
                       const ULONG ulMaxCount, 
                       const HRECOALT *aAddAlt, 
                       const ULONG ulAddAltCount,
                       HRECOALT *aBufferAlt)
{
    BOOL                bAdded = FALSE;
    ULONG               iAlt = 0;
    ULONG               ulCurrentFinal = 1, ulCurrentAdd = 0;
    ULONG               ulNewCount = 0;
    BOOL                bFirstFinished = FALSE;
    BOOL                bSecondFinished = FALSE;
    WispSegAlternate    *pFinal = NULL;
    WispSegAlternate    *pAdd = NULL;
    HRESULT             hr = S_OK;
    
    if (0 == ulAddAltCount)
    {
        return FALSE;
    }
    // Special case: this is the first array added to the FinalArray
    if (0 == *pFinalAltCount)
    {
        // What is the size we want to copy?
        *pFinalAltCount = ulAddAltCount;
        // Copy the elements
        memcpy(aFinalAlt, aAddAlt, sizeof(HRECOALT)*ulAddAltCount);
        // Say that we added something to the array (if we did)
        if (0 != ulAddAltCount)
        {
            bAdded = TRUE;
        }
    }
    else
    {
        // We have to add alternate but always leave the first on in
        // place since we want to conserve the best alternate at
        // the first place in the FinalAlt array whatever the scores
        // are.
        // We will sort by copying to a buffer array
        
        // Get the future count of element in aFinalAlt
        ulNewCount = *pFinalAltCount + ulAddAltCount;
        if (ulNewCount > ulMaxCount)
        {
            ulNewCount = ulMaxCount;
        }
        
        // First copy the first element of the aFinalAlt to the buffer array
        aBufferAlt[0] = aFinalAlt[0];
        
        // Are we done with the elements of the aFinalAlt
        if (1 == *pFinalAltCount)
        {
            bFirstFinished = TRUE;
        }
        
        // Go through each element of the buffer array
        for (iAlt = 1; iAlt < ulNewCount; iAlt++)
        {
            if (!bFirstFinished)
            {
                
                if (!bSecondFinished)
                {

					pFinal	= (WispSegAlternate*)FindTpgHandle((HANDLE)aFinalAlt[ulCurrentFinal], TPG_HRECOALT);
					pAdd	= (WispSegAlternate*)FindTpgHandle((HANDLE)aAddAlt[ulCurrentAdd], TPG_HRECOALT);


					if (NULL == pFinal)
					{
						ASSERT(NULL == pFinal);
						ulCurrentFinal++;
						if (ulCurrentFinal >= *pFinalAltCount)
                        {
                            bFirstFinished = TRUE;
                        }
						continue;
					}
					if (NULL == pAdd)
					{
						ASSERT(NULL == pAdd);
						ulCurrentAdd++;
                        if (ulCurrentAdd >= ulAddAltCount)
                        {
                            bSecondFinished = TRUE;
                        }
						continue;
					}

                    // Which element has the lowest score?
                    if (pFinal->iInfernoScore > pAdd->iInfernoScore)
                    {
                        // Add the second array's element
                        // Add the element of aAddAlt to the buffer array
                        aBufferAlt[iAlt] = aAddAlt[ulCurrentAdd];
                        ulCurrentAdd++;
                        if (ulCurrentAdd >= ulAddAltCount)
                        {
                            bSecondFinished = TRUE;
                        }
                        bAdded = TRUE;
                        
                    }
                    else
                    {
                        // Add the first array's element
                        // Add the element of aFinalAlt to the buffer array
                        aBufferAlt[iAlt] = aFinalAlt[ulCurrentFinal];
                        ulCurrentFinal++;
                        if (ulCurrentFinal >= *pFinalAltCount)
                        {
                            bFirstFinished = TRUE;
                        }
                    }
                }
                else
                {
                    // Add the element of aFinalAlt to the buffer array
                    aBufferAlt[iAlt] = aFinalAlt[ulCurrentFinal];
                    ulCurrentFinal++;
                    if (ulCurrentFinal >= *pFinalAltCount)
                    {
                        bFirstFinished = TRUE;
                    }
                }
            }
            else
            {
                if (bSecondFinished)
                {
                    // Add the element of aAddAlt to the buffer array
                    aBufferAlt[iAlt] = aAddAlt[ulCurrentAdd];
                    ulCurrentAdd++;
                    if (ulCurrentAdd >= ulAddAltCount)
                    {
                        bSecondFinished = TRUE;
                    }
                    bAdded = TRUE;
                }
                else
                {
                    // none of the array have elements anymore, that is odd
                    // we should never reach this point
                    ASSERT (bFirstFinished || bSecondFinished);
                    ulNewCount = iAlt;
                    break;
                }
            }
        }
        // Free the alts that we did not use in the aFinalAlt array
        if (!bFirstFinished)
        {
            for (iAlt = ulCurrentFinal; iAlt < *pFinalAltCount; iAlt++)
            {
                hr = DestroyAlternate(aFinalAlt[iAlt]);
                ASSERT(SUCCEEDED(hr));
            }
        }
        // Free the alts that we did not use in the aAddAlt array
        if (!bSecondFinished)
        {
            for (iAlt = ulCurrentAdd; iAlt < ulAddAltCount; iAlt++)
            {
                hr = DestroyAlternate(aAddAlt[iAlt]);
                ASSERT(SUCCEEDED(hr));
            }
        }
        
        
        // Copy the buffer array back into the aFinalAlt
        memcpy(aFinalAlt, aBufferAlt, sizeof(HRECOALT)*ulNewCount);
        
        // Set the new size of the array
        *pFinalAltCount = ulNewCount;
        
    }
    return bAdded;
}

//
// IsAltPresentInThisSegmentation
//
// This helper function tells if the last LineSegAlt alternate 
// in an array is already present in the earlier members of the array
//
// Parameters:
//		xrc   [in] : The recogniztion context
//      aAlts [in] : The array of LineSeg alternates
//		ulAlt [in] : The index of the last element
/////////////////
static BOOL IsAltPresentInThisSegmentation(const XRC *xrc, const LineSegAlt *aAlts, ULONG ulAlt)
{
    BOOL        bRes = FALSE;
    ULONG       iAlt = 0, iWordMap = 0;
    WordPath    *pFirst = NULL;
    WordPath    *pSecond = NULL;
    
	ASSERT(xrc);
	ASSERT(aAlts);
	if (!xrc || !aAlts)
		return FALSE;

    for (iAlt = 0; iAlt < ulAlt; iAlt++)
    {
        if (aAlts[iAlt].cWM == aAlts[ulAlt].cWM)
        {
            bRes = TRUE; // Assume the word maps are the same
            // See if all the wordmaps are the same
            for (iWordMap = 0; iWordMap < aAlts[iAlt].cWM; iWordMap++)
            {
                pSecond = &aAlts[ulAlt].aWordPaths[iWordMap];
                pFirst = &aAlts[iAlt].aWordPaths[iWordMap];
                
                // Is this word map different?
                if (xrc->pLineBrk->pLine[pFirst->ulLineSegmentationIndex].pResults->
                    ppSegCol[pFirst->ulSegColIndex]->ppSeg[pFirst->ulSegmentationIndex]->
                    ppWord[pFirst->ulWordMapIndex]
                    != 
                    xrc->pLineBrk->pLine[pSecond->ulLineSegmentationIndex].pResults->
                    ppSegCol[pSecond->ulSegColIndex]->ppSeg[pSecond->ulSegmentationIndex]->
                    ppWord[pSecond->ulWordMapIndex])
                {
                    // Yes it is different
                    bRes = FALSE;
                }
                // No need to look at the other Word maps if one is not equal
                if (!bRes)
                    break;
            }
            // we found a match in what is already there, skip.
            if (bRes)
                break;
        }
    }
    return bRes;
}

//
// GetConfidenceLevel
//
// Function returning the confidence level for this alternate
// The confidence level is equal to the lowest confidence level in
// all segments of the alternate.
// The confidence level of a segment is the confidence level of the
// wordmap if it is the first element of the wordmap CFL_POOR
// otherwise
//
// Parameters:
//		hrcalt      [in]        : The wisp alternate handle
//      pRecoRange  [in, out]   : The range we want the confidence level for
//                                This is modified to return the effective range used
//		pcl         [out]       : The pointer to the returned confidence level value
/////////////////
HRESULT WINAPI GetConfidenceLevel(HRECOALT hrcalt, RECO_RANGE* pRecoRange, CONFIDENCE_LEVEL* pcl)
{
#ifdef CONFIDENCE

    HRESULT                 hr = S_OK;
    WispSegAlternate        *wispalt;
    XRC                     *xrc = NULL;
    ULONG                   ulStartIndex = 0, ulEndIndex = 0;
    ULONG                   iWordMap = 0;
    WordPath                *pWordPath = NULL;
    CONFIDENCE_LEVEL        cfTemp = CFL_STRONG;
    CONFIDENCE_LEVEL        cfFinal = CFL_STRONG;
    int                     iInfernoCF;
    
	if (NULL == (wispalt = (WispSegAlternate*)FindTpgHandle((HANDLE)hrcalt, TPG_HRECOALT)) )
	{
        return E_POINTER;
	}

    if (IsBadWritePtr(pcl, sizeof(CONFIDENCE_LEVEL)))
        return E_POINTER;

   if (IsBadWritePtr(pRecoRange, sizeof(RECO_RANGE)))
    {
        return E_POINTER;
    }

   // Check the validity of the reco range
    if (!pRecoRange->cCount) 
        return E_INVALIDARG;
    if (pRecoRange->iwcBegin + pRecoRange->cCount > wispalt->ulLength)
        return E_INVALIDARG;
    
    if (!wispalt->ulElementCount)
    {
        return E_INVALIDARG;
    }
    
    // Get the pointer to the hwx result
    xrc = (XRC*)wispalt->wisphrc->hrc;
    if (IsBadReadPtr(xrc, sizeof(XRC))) 
        return E_POINTER;
    
    
    // Get the right RECO_RANGE and the indexes
    hr = GetIndexesFromRange(wispalt, pRecoRange, &ulStartIndex, &ulEndIndex);
    if (FAILED(hr))
        return hr;

    if (hr == S_FALSE)
    {
        // Only a space has been selected
        *pcl = CFL_STRONG;
        return S_OK;
    }
    
    cfFinal = CFL_STRONG;
    
    // Go through each segmentation and return the lowest confidence level.
    for (iWordMap = ulStartIndex; iWordMap <= ulEndIndex; iWordMap++)
    {
        pWordPath = wispalt->pElements + iWordMap;
        
        // For now return low if this is not the best result in the wordmap 
        if (pWordPath->ulIndexInWordMap != 0)
        {
            cfFinal = CFL_POOR;
            break;
        }
        iInfernoCF = xrc->pLineBrk->pLine[pWordPath->ulLineSegmentationIndex].pResults->
            ppSegCol[pWordPath->ulSegColIndex]->
            ppSeg[pWordPath->ulSegmentationIndex]->
            ppWord[pWordPath->ulWordMapIndex]->iConfidence;
        switch(iInfernoCF)
        {
        case RECOCONF_LOWCONFIDENCE:
            cfTemp = CFL_POOR;
            break;
        case RECOCONF_MEDIUMCONFIDENCE:
            cfTemp = CFL_INTERMEDIATE;
            break;
        case RECOCONF_HIGHCONFIDENCE:
            cfTemp = CFL_STRONG;
            break;
        default:
            hr = E_FAIL;
            break;
        }
        if (cfTemp > cfFinal)
            cfFinal = cfTemp;
    }
    if (SUCCEEDED(hr))
    {
        *pcl = cfFinal;
    }
    
    return hr;
#else
	return E_NOTIMPL;
#endif
}

/////////////////////////////////////////////////////////////////
// User dictionary code
//
//
HRESULT WINAPI MakeWordList(HRECOGNIZER hrec, WCHAR *pBuffer, HRECOWORDLIST *phwl)
{
    HRESULT hr = E_FAIL;
    HWL hwl = 0;

    if (IsBadWritePtr(phwl, sizeof(HRECOWORDLIST)))
    {
        return E_POINTER;
    }

    if (pBuffer)
	{
        hwl = CreateHWLW(NULL, pBuffer, WLT_STRINGTABLE, 0);
	}
    else
	{
        hwl = CreateHWLW(NULL, NULL, WLT_EMPTY, 0);
	}

	if (hwl)
    {
		*phwl = (HRECOWORDLIST)CreateTpgHandle(TPG_HRECOWORDLIST, hwl);
	
		if (0 == *phwl)
		{
			DestroyHWL(hwl);
		    return E_OUTOFMEMORY;
		}
        hr = S_OK;
    }
    return hr;
}

HRESULT WINAPI DestroyWordList(HRECOWORDLIST hwl)
{
	HWL			hwlInternal;
    HRESULT hr = S_OK;

	if (!hwl)
	{
        return S_OK;
	}

	if (NULL == (hwlInternal = (HWL)DestroyTpgHandle((HANDLE)hwl, TPG_HRECOWORDLIST)) )
	{
        return E_POINTER;
	}

    if (HRCR_ERROR == DestroyHWL(hwlInternal))
	{
        hr = E_FAIL;
	}
    return hr;
}

HRESULT WINAPI AddWordsToWordList(HRECOWORDLIST hwl, WCHAR *pwcWords)
{
	HWL			hwlInternal;
	HRESULT     hr = S_OK;

	if (NULL == (hwlInternal = (HWL)FindTpgHandle((HANDLE)hwl, TPG_HRECOWORDLIST)) )
	{
        return E_POINTER;
	}

    if (HRCR_ERROR == AddWordsHWLW(hwlInternal, pwcWords, WLT_STRINGTABLE))
	{
        hr = E_FAIL;
	}
    return hr;
}

HRESULT WINAPI SetWordList(HRECOCONTEXT hrc, HRECOWORDLIST hwl)
{
    HRESULT             hr = S_OK;
	HWL					hwlInternal;
    struct WispContext  *wisphrc;

	if (NULL == (wisphrc = (struct WispContext*)FindTpgHandle((HANDLE)hrc, TPG_HRECOCONTEXT)) )
	{
        return E_POINTER;
	}

	if (0 != hwl)
	{
		if (NULL == (hwlInternal = (HWL)FindTpgHandle((HANDLE)hwl, TPG_HRECOWORDLIST)) )
		{
			return E_POINTER;
		}
	}
	else
	{
		// A null handle is valid - means unset the word list
		hwlInternal = (HWL)hwl;
	}

    if (HRCR_ERROR == SetWordlistHRC(wisphrc->hrc, hwlInternal))
	{
        hr = E_FAIL;
	}

    return hr;
}

// 
// The Internal recognizer dlls are no self registrable anymore
// 


/////////////////////////////////////////////////////////////////
// Registration information
//
//

#define FULL_PATH_VALUE 	L"Recognizer dll"
#define RECO_LANGUAGES      L"Recognized Languages"
#define RECO_CAPABILITIES   L"Recognizer Capability Flags"
#define RECO_MANAGER_KEY	L"CLSID\\{DE815B00-9460-4F6E-9471-892ED2275EA5}\\InprocServer32"
#define CLSID_KEY			L"CLSID"

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

// This recognizer GUID is going to be
// {6D0087D7-61D2-495f-9293-5B7B1C3FCEAB}
// Each recognizer HAS to have a different GUID

STDAPI DllRegisterServer(void)
{
	HKEY		hKeyReco = NULL;
	HKEY		hKeyRecoManager = NULL;
	LONG 		lRes = 0;	
	HKEY		hkeyMyReco = NULL;
	DWORD		dwLength = 0, dwType = 0, dwSize = 0;
	DWORD		dwDisposition;
	WCHAR		szRecognizerPath[MAX_PATH];
	WCHAR		szRecoComPath[MAX_PATH];
    WCHAR       *RECO_SUBKEY = NULL, *RECOGNIZER_SUBKEY = NULL;
    WCHAR       *RECOPROC_SUBKEY = NULL, *RECOCLSID_SUBKEY = NULL;
    RECO_ATTRS  recoAttr;
    HRESULT     hr = S_OK;

    // get language id
    LANGID *pPrimaryLanguage = NULL;
    LANGID *pSecondaryLanguage = NULL;
    LANGID CombinedLangId = 0;
    
    getLANGSupported(g_hInstanceDll, &pPrimaryLanguage, &pSecondaryLanguage);
    if (pPrimaryLanguage == NULL)
        return E_FAIL;

    if (NULL != pSecondaryLanguage)
    CombinedLangId = MAKELANGID(*pPrimaryLanguage, *pSecondaryLanguage);
    else
        CombinedLangId = MAKELANGID(*pPrimaryLanguage, 0);

    if (CombinedLangId == MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (CombinedLangId == MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (CombinedLangId == MAKELANGID(LANG_FRENCH, SUBLANG_DEFAULT))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (CombinedLangId == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
   if (*pPrimaryLanguage == MAKELANGID(LANG_SPANISH, SUBLANG_NEUTRAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{8d9fde44-1b8d-462f-8486-32ed9c2c294b}";
        RECOGNIZER_SUBKEY = L"CLSID\\{8d9fde44-1b8d-462f-8486-32ed9c2c294b}\\InprocServer32";
        RECOPROC_SUBKEY = L"{8d9fde44-1b8d-462f-8486-32ed9c2c294b}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{8d9fde44-1b8d-462f-8486-32ed9c2c294b}";
    }
    // Check that the language is actually recognizer
    if (RECO_SUBKEY == NULL || 
        RECOGNIZER_SUBKEY == NULL ||
        RECOPROC_SUBKEY == NULL ||
        RECOCLSID_SUBKEY == NULL)
    {
        return E_FAIL;
    }
	// Write the path to this dll in the registry under
	// the recognizer subkey

	// Wipe out the previous values
	lRes = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RECO_SUBKEY);

	// Get the current path
	// Try to get the path of the RecoObj.dll
	// It should be the same as the one for the RecoCom.dll
	dwLength = GetModuleFileNameW((HMODULE)g_hInstanceDll, szRecognizerPath, MAX_PATH);
	if (MAX_PATH == dwLength && L'\0' != szRecognizerPath[MAX_PATH-1])
	{
		// Truncated path
		return E_FAIL;
	}

	// Create the new key
	lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE, RECO_SUBKEY, 0, NULL,
		REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyMyReco, &dwDisposition);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
        if (hkeyMyReco)
		RegCloseKey(hkeyMyReco);
		return E_FAIL;
	}

	// Write the path to the dll as a value
	lRes = RegSetValueExW(hkeyMyReco, FULL_PATH_VALUE, 0, REG_SZ, 
		(BYTE*)szRecognizerPath, sizeof(WCHAR)*(wcslen(szRecognizerPath)+1));
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_FAIL;
	}
    // Add the reco attribute information
    hr = GetRecoAttributes(NULL, &recoAttr);
    if (FAILED(hr))
	{
		RegCloseKey(hkeyMyReco);
		return E_FAIL;
	}
	lRes = RegSetValueExW(hkeyMyReco, RECO_LANGUAGES, 0, REG_BINARY, 
		(BYTE*)recoAttr.awLanguageId, 64 * sizeof(WORD));
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_FAIL;
	}
	lRes = RegSetValueExW(hkeyMyReco, RECO_CAPABILITIES, 0, REG_DWORD, 
		(BYTE*)&(recoAttr.dwRecoCapabilityFlags), sizeof(DWORD));
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyMyReco);
		return E_FAIL;
	}
    
	RegCloseKey(hkeyMyReco);
			
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	LONG 		lRes1 = 0;

    // get language id
    LANGID      *pPrimaryLanguage = NULL;
    LANGID      *pSecondaryLanguage = NULL;
    LANGID      CombinedLangId = 0;
    WCHAR       *RECO_SUBKEY = NULL, *RECOGNIZER_SUBKEY = NULL;
    WCHAR       *RECOPROC_SUBKEY = NULL, *RECOCLSID_SUBKEY = NULL;
    
    getLANGSupported(g_hInstanceDll, &pPrimaryLanguage, &pSecondaryLanguage);
    if (pPrimaryLanguage == NULL)
        return E_FAIL;

    if (NULL != pSecondaryLanguage)
    CombinedLangId = MAKELANGID(*pPrimaryLanguage, *pSecondaryLanguage);
    else
        CombinedLangId = MAKELANGID(*pPrimaryLanguage, 0);

    if (CombinedLangId == MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D1087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (CombinedLangId == MAKELANGID(LANG_GERMAN, SUBLANG_DEFAULT))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D2087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (CombinedLangId == MAKELANGID(LANG_FRENCH, SUBLANG_DEFAULT))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6D3087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
    if (CombinedLangId == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}";
        RECOGNIZER_SUBKEY = L"CLSID\\{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOPROC_SUBKEY = L"{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{6DA087D7-61D2-495f-9293-5B7B1C3FCEAB}";
    }
   if (*pPrimaryLanguage == MAKELANGID(LANG_SPANISH, SUBLANG_NEUTRAL))
    {
        RECO_SUBKEY = L"Software\\Microsoft\\TPG\\System Recognizers\\{8d9fde44-1b8d-462f-8486-32ed9c2c294b}";
        RECOGNIZER_SUBKEY = L"CLSID\\{8d9fde44-1b8d-462f-8486-32ed9c2c294b}\\InprocServer32";
        RECOPROC_SUBKEY = L"{8d9fde44-1b8d-462f-8486-32ed9c2c294b}\\InprocServer32";
        RECOCLSID_SUBKEY = L"{8d9fde44-1b8d-462f-8486-32ed9c2c294b}";
    }
    // Check that the language is actually recognizer
    if (RECO_SUBKEY == NULL || 
        RECOGNIZER_SUBKEY == NULL ||
        RECOPROC_SUBKEY == NULL ||
        RECOCLSID_SUBKEY == NULL)
    {
        return E_FAIL;
    }

    // Wipe out the registry information
	lRes1 = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RECO_SUBKEY);

    // Try to erase the local machine\software\microsoft\tpg\recognizer
    // if necessary (don't care if it fails)
	RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\TPG\\System Recognizers");
    RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\TPG");

	if (lRes1 != ERROR_SUCCESS && lRes1 != ERROR_FILE_NOT_FOUND)
	{
		return E_FAIL;
	}
    return S_OK ;
}


/*************************************************
 * NAME: validateTpgHandle
 *
 * Generic function to validate a pointer obtained from a WISP
 * style handle. For now function checks the memory
 * is writable
 *
 * RETURNS
 *   TRUE if the pointer passes a minimal validation
 *
 *************************************************/
BOOL validateTpgHandle(void *pPtr, int type)
{
	BOOL	bRet = FALSE;


	switch (type)
	{
		case TPG_HRECOCONTEXT:
		{
			if (0 == IsBadWritePtr(pPtr, sizeof(struct WispContext)))
			{
				bRet = TRUE;
			}
			break;
		}

		case TPG_HRECOALT:
		{
			if (0 == IsBadWritePtr(pPtr, sizeof(WispSegAlternate)))
			{
				bRet = TRUE;
			}
			break;
		}

		case TPG_HRECOGNIZER:
		{
			if (0 == IsBadWritePtr(pPtr, sizeof(struct WispRec)))
			{
				bRet = TRUE;
			}
		
			break;
		}
		case TPG_HRECOLATTICE:
		{
			// No structure we know about
			break;
		}

		case TPG_HRECOWORDLIST:
		{
			if (0 == IsBadReadPtr(pPtr, sizeof(UDICT)))
			{
				bRet = TRUE;
			}

			break;
		}

		default:
			break;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\fforward.h ===
void FeedForward(FFINFO *ffinfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\charmap.h ===
// charmap.h
// Angshuman Guha, aguha
// Jan 12, 1999
// Modifed March 10, 1999

#ifndef __CHARMAP_H
#define __CHARMAP_H

#ifdef __cplusplus
extern "C" {
#endif

// Maximum number of character activations, (ie begin and continuation activation) supported by the
// recognizer
#define C_CHAR_ACTIVATIONS		512


// Accented characters
#define FIRST_ACCENT		(1)
#define C_ACCENT			(1)

// The first output unit in the character class
#define FIRST_SOFT_MAX_UNIT	(FIRST_ACCENT + C_ACCENT)


//BYTE BeginChar2Out(char);
//BYTE ContinueChar2Out(char);

extern const BYTE rgCharToOutputNode[];
extern const BYTE rgOutputNodeToChar[];
extern const BYTE rgVirtualChar[];

#define BeginChar2Out(ch) rgCharToOutputNode[2*(ch)]
#define ContinueChar2Out(ch) rgCharToOutputNode[2*(ch)+1]

// the following macro is right iff all virtual chars are supported
#define IsSupportedChar(ch) ((BeginChar2Out(ch) < 0xFF) || IsVirtualChar(ch))

#define Out2Char(i) rgOutputNodeToChar[2*(i)+1]
#define IsOutputBegin(i) rgOutputNodeToChar[2*(i)]

#define IsVirtualChar(ch) rgVirtualChar[2*(ch)]
#define BaseVirtualChar(ch) rgVirtualChar[2*(ch)]
#define AccentVirtualChar(ch) rgVirtualChar[2*(ch)+1]

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\nnet.c ===
// nnet.c

#include <common.h>
#include "nnet.h"
//#include "nnet.ci"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\lpunc.h ===
// lpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_LPUNC_H
#define __INC_LPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescLPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\fforward.c ===
#include "common.h"
#include "nfeature.h"
#include "engine.h"
#include "infernop.h"
#include "nnet.h"
#include "fforward.h"
#include "charmap.h"
#include <resource.h>
#include "loadTDNNbin.h"

#ifndef __min
#define __min(a,b) (a < b ? a : b)
#endif

//*********************************** FIXED POINT VERSION ***********************************************************************
#include "math16.h"



NET_DESC	s_Net;

BOOL InitInferno(HINSTANCE hInst)
{
	BOOL		iRet = TRUE;

	iRet = (iRet && LoadTDNNFromResource(hInst, RESID_INFERNO, &s_Net));
	//iRet = (iRet && LoadTDNNFromResource(hInst, RESID_INFERNO_ALT, &s_Net1));
/*
	iRet = (iRet && LoadTDNNFromFp(&s_Net1, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\deu\\nnetBase_1_2.bin") !=NULL);
	iRet = (iRet && LoadTDNNFromFp(&s_Net, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\deu\\nnetBase.bin") !=NULL);
	//iRet = (iRet && LoadTDNNFromFp(&s_Net, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\deu\\nnetCheckConvert.bin") !=NULL);
*/
	return iRet;
}

/*************************************************************************
 *
 * FeedForwardHidOut
 *
 * Does a forward propogation between 2 layers for the case
 * where there is no space displacement in the lower layer, ie the lower layer units
 * have been rolled out in time. We use this case for propogating hidden->
 * output layer. Outputs are not put through the non-linearity 
 *
 *
 * NOTE: Because of the rollout in time, this function assumes no edge effect cases
 *
 ***************************************************************************/ 
void FeedForwardHid2Out(
int						cWidth,				// IN: Number of time slices (columns) in lower layer
int						cWidthUpper,		// IN: Number of time slices (columns) in upper layer
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE HID_OUT_WEIGHT	*rgWeight,			// IN: Weight vector
ROMMABLE OUT_BIAS		*rgBias,			// IN: Bias vector
int						cInNZ,				// IN: Total number of (Non-zero) input values (Only used in debug for checking)
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int			row, col;
	int			*pInput = input, *tmpInput;
unsigned short	*pInNZd, *pcNZd;

	pInNZd = pInNZ;
	pcNZd = pcNZPerCol;


	// Should be no edge affects for this propogation
	ASSERT(cWidthUpper + cWeightWidth - 1 == cWidth);

	for (col= 0 ; col < cWidthUpper ; col++)
	{
		ROMMABLE OUT_BIAS			*pBias = rgBias;
		ROMMABLE HID_OUT_WEIGHT		*pWeight = rgWeight;
		unsigned short *pcCol;
		unsigned short	*pNZInc;

		for (row = cOutput ; row ; row--)
		{
			int	sum = (int)(*pBias++);
			int c, iVal, iw;

			pcCol = pcNZPerCol;
			tmpInput = pInput;
			pNZInc = pInNZ;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					// Maybe these asserts are too defensive??
					ASSERT(*pWeight >= -0x7f);
					ASSERT(*pWeight <= 0x7f);

					iVal = (*tmpInput++) * (int)(*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}

			*output++ = sum;
		}

		// Because of rollout in time of hidden layer go to the next
		// column
		pInNZ = pNZInc;
		pcNZPerCol = pcCol;
		pInput = tmpInput;
	}

}

/********************************************************************************
 *
 * FeedForwardLayerInp2Hid
 *
 * Does the main work of forward propogating one layer. The lower layer (input)
 * is thought of having cWidth columns one column per time slice. A columns has cWeightHeight 
 * units. The upper layer (output) also has cWidth columns, with each column having cOutput units.
 *
 * Each output weight has incoming conections from cWeightWidth columns in the lower layer.
 * In other words an output unit recieves connections from potentially cWeightHeight * cWeightWidth
 * units. Columns at either left or right edge have less incoming units and are handles as edge effects
 * Also, the case of int(cWeightWidth / 2) time slices is handles as a special case.
 *
 * Speedup tricks. The lower units are often saturated, ie have max or 0 value. We
 * take advantage of the case when the units are 0 and simply skip these units. The straight
 * forward approach would be to include an if() statement but that would not really 
 * be a time saving. So before entering this routine, we go through all the inputs, throwing
 * out the zero values and keeping track of the location of non zero entries in a parallel array of offsets.
 * So the 'input' array only has nonzero entries values, the parrallel array pInNZ contains the gaps between
 * the nonzero entries in the **real** input space. (An entry of 1 means that values in input were
 * actually adjacent in the input space.) Finally pcNZPerCol is a count of Non zero entries
 * in wach input column. Now as we do the dot products we only are using non Zero input values
 * taking care to use the correct weights by using the pInNZ to index to the appropriate weight
 *
 * Sept 1999 (mrevow) This function is modelled on FeedForward layer in previous
 * Checkins. The difference is now that it is only used for inp->hidden propogation, no bias
 * applied and the hidden activations are not passed through the sigmoid. This is differerd till later
 * because we roll out the hidden units in time, each hidden unit giving rise to 3 activations
 * each with a different bias
 *
 ***************************************************************************************/
void FeedForwardInp2Hid(
int						cWidth,				// IN: Number of time slices (columns) in lower layer
int						cWidthUpper,		// IN: Number of time slices (columns) in upper layer
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE INP_HID_WEIGHT	*rgWeight,			// IN: Weight vector
int						cInNZ,				// IN: Total number of (Non-zero) input values (Only used in debug for checking)
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int				row, col;
	int				*pInput;
	int				leftMargin, rightMargin;
	unsigned short	*pcNZPerColTmp, *pInNZTmp;
	int				i, iNZtoLeft;
int	cIn = cInNZ;


	leftMargin = (cWidthUpper - cWidth) / 2 + 1;
	rightMargin = min (cWidthUpper - leftMargin, leftMargin);

	if (cWidth < 0)
	{
		return;
	}


	// Take care of edge effects. Do all the upper layer columns
	// where we do not have leftMargin columns to the left in the lower layer

	// For all columns in upper row which dont have 
	// enough columns in the lower layer to the left
	for (col = leftMargin ; col ; --col)
	{
		ROMMABLE INP_HID_WEIGHT *pWeight = rgWeight + col * cWeightHeight;

		pcNZPerColTmp = pcNZPerCol;		// Per column counts
		pInNZTmp = pInNZ;				// The NZ gap counts

		// For each row in the upper layer
		for (row=cOutput; row; row--)
		{
			int	 *tmpInput = input;
			int sum;
			int c, iVal, iw, cLowerCol;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			sum = 0;

			// Iterate over each col in lower layer that connects to
			// one in the upper layer. Normally we have to use
			// cWeightWidth-col time slices in the lower layer, but dont croak if
			// there are insufficient
			cLowerCol = min((cWeightWidth-col), cWidth);
			for (iw = cLowerCol ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);

				// Finally each row in the lower layer
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				// Compensate for gap at end of the slice
				pWeight += *(pNZInc++);
			}

			*output++ = sum;
			pWeight += col * cWeightHeight;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;

	}

	// the middle chunk - has enough on either side to use all weights
	pInput = input;
	pcNZPerColTmp = pcNZPerCol;
	pInNZTmp = pInNZ;

	for (col = cWidthUpper - leftMargin - rightMargin; col > 0; col--)
	{
		ROMMABLE INP_HID_WEIGHT	*pWeight = rgWeight;

		for (row = cOutput ; row ; row--)
		{
			int	 *tmpInput = pInput;
			unsigned short *pcCol = pcNZPerColTmp; 
			int sum = 0;
			int c, iVal, iw;
			unsigned short	*pNZInc = pInNZTmp;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			*output++ =  sum;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column

	}
	ASSERT(pInput - input == cInNZ - pcNZPerColTmp[0] - pcNZPerColTmp[1]);

	// the right part where the weight matrix goes beyond the right end of input
	// note: weight matrix does not go beyond left end

	pcNZPerColTmp = pcNZPerCol + cWidth - rightMargin;
	
	// Count number of NZ entries in the input so we can set the pointer
	// to the first Non zero entry
	iNZtoLeft = 0;
	for (i = 0 ; i < cWidth - rightMargin; ++ i)
	{
		iNZtoLeft += pcNZPerCol[i];
	}

	pInput = input + iNZtoLeft;
	pInNZTmp = pInNZ + iNZtoLeft + i;

	// the left part where the weight matrix goes beyond the left end of input
	// note: weight matrix does not go beyond right end
	//for (col=leftMargin; col; col--)
	for (col = 1 ; col <= rightMargin; ++col)
	{
		ROMMABLE INP_HID_WEIGHT *pWeight = rgWeight;
		int						iColMax = min(cWeightWidth - col, cWidth);		// Number of loer layer columns to do

		for (row=cOutput; row; row--)
		{
			int	 *tmpInput = pInput;
			int		sum = 0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			tmpInput = pInput;

			for (iw = iColMax ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			*output++ = sum;
			pWeight += col * cWeightHeight ;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column
	}
}


// Count the number of non zero elements in the input array, and the gaps between
// them. For ease of later bookeeping we also keep track of the zero space counts
// at the start and end of each time slice
// Returns the total number of NZ elements
int GetNZSpaces(
int					*pData,			// IN/OUT: Input Data array, on out is compacted to remove zero elements
int					cSlice,			// IN: Number of time slices
int					cLen,			// IN: Length of each time slice
unsigned short		*pNZgap,		// OUT: the gaps between the NZ elements
unsigned short		*pcNZPerCol		// OUT: Number of NZ elements per slice	
)
{
	int					i, j, k, cNZ, cGap;
	int					iLastNZ;

	i = 0;
	cNZ = cGap = 0;
	iLastNZ = 0;

	ASSERT(pData);
	ASSERT(pNZgap);
	ASSERT(pcNZPerCol);

	*pcNZPerCol = 0;

	for (k = 0 ; k < cSlice; ++k )
	{
		for (j = 0 ; j < cLen ; ++j, ++i)
		{
			if (pData[i] != 0)
			{
				pData[cNZ++] = pData[i];
				pNZgap[cGap++] = i - iLastNZ;
				(*pcNZPerCol)++;
				iLastNZ = i;
			}
		}

		++pcNZPerCol;
		*pcNZPerCol = 0;

		pNZgap[cGap++] = i - iLastNZ;
		iLastNZ = i;
	}

	return cNZ;
}
//
// Convert output units from something like logDomain to P domain 
// by doing softmax on the output units those that need it and
// sigmoid on those others
// Assumption:  space node is the very first output node
//
void logP2P(
int			cWidth,
int			cOutput,
int			*pOutput
)
{
	int		*p, i;
	int		iF = (1 << 22) - 1;
	int		iSigMax = ( 1 << 16), iSigZero = (1 << 15);


	for ( i = 0 ; i < cWidth ; ++i)
	{
		int		j;
		int		iMax, sum, iV;


		// Sigmoids
		for (j = 0 ;j < FIRST_SOFT_MAX_UNIT ; ++j, ++pOutput)
		{
			*pOutput = Sigmoid16(*pOutput >> 4);

		}

		// Find max so we can do softmax with maximal precision
		p = pOutput;
		iMax =  *p++;
		for (j = FIRST_SOFT_MAX_UNIT + 1 ; j < cOutput ; ++j, ++p )
		{
			if (*p > iMax)
			{
				iMax = *p;
			}
		}

		p = pOutput;
		sum = 0;
		for (j = FIRST_SOFT_MAX_UNIT ; j < cOutput ; ++j, ++p )
		{
			// Want to get (exp(*p - iMax)) compute it as
			// Instead of creating a new table use the
			// existing sigmoid and compute s / (1-s) where 
			// s - sigmoid(x). Note we have to do correct
			// scaling for the To get maximum resolution make max value 2^22
			// (Leaves scope for about 1024 output units without overflow)

			iV = (*p - iMax) >> 4;			// get in the range [-2^16 : 2^16]

			if (iV < 0)
			{
				iV = Sigmoid16(iV);
				iV = iV << 16 / ( iSigMax - iV);		// Maximum resolution with no overflow ??
				iV <<= 6;								// Scale into the 2^22 range
			}
			else
			{
				iV = iF;		// Dont need to do computation it is the maximum 
			}

			*p = iV; 
			sum += *p;
		}

		sum >>= 16;

		ASSERT(sum > 0);

		for (j = FIRST_SOFT_MAX_UNIT ; j < cOutput ; ++j, ++pOutput )
		{
			*pOutput /= sum;


			// Clip outouts
			if (*pOutput > 0xFFFF)
			{
				*pOutput = 0xFFFF;
			}

		}
	}
}
/**********************************************************************
 *
 * Special treatment for hidden units. 
 *   1) Expand each activation into cSpan replicated
 *      activities with different bias added to each replication and
 *   2) Pass through the sigmoid
 *
 **********************************************************************/
void addHidBias(
int						*pHidden,		// IN/OUT Hidden activations (processing is done in place)
int						cHidden,		// IN: Number of hidden units per time slot
int						cSpan,			// IN: Replication size
int						cWidth,			// IN: Number of time slots
int						cWidthHid,		// IN: Number of 'time slots' in hidden layer (CwidthHid > cWidth)
ROMMABLE  HID_BIAS		*pHidBias		// IN: Biases (cHidden * cSpan)
)
{
	int						iW, iRow, iS;
	ROMMABLE  HID_BIAS		*pEndBias = pHidBias + cHidden * cSpan - 1;
	int						iMaxCol;

	ASSERT (cWidthHid == cWidth + (cSpan-1)/2 * 2);

	iMaxCol = cWidth * cSpan;

	// Work from the last time slot backwards
	// that way we can do it in place
	for (iW = cWidthHid - 1 ; iW >= 0 ; --iW)
	{
		ROMMABLE  HID_BIAS		*pB = pHidBias;
		int							*pSrc = pHidden + iW * cHidden;

		// Replication the src column 
		for (iS = 0 ; iS <cSpan ; ++iS)
		{
			int		*pS = pSrc;
			int		iDestCol = cSpan * (iW - iS) + iS;
			int		*pDest;
			
			if (iDestCol < 0 || iDestCol >= iMaxCol)
			{
				pB += cHidden;
				continue;
			}

			
			pDest = pHidden + (iDestCol) * cHidden;

			ASSERT (pDest >= pSrc);

			for (iRow = 0 ; iRow < cHidden ; ++iRow)
			{
				*pDest = *pS++ + *pB++;
				*pDest = Sigmoid16(*pDest);
				++pDest;
			}
		}
	}
}



// Do a forward propagation of a net defined by the weights passed in
void runTDNNForward(
TDNN_NET				*pTdnnNet,				// IN: Which net to use
int						*pInput,
int						*pHidden,			// OUT Hidden activations
int						*pOutput,			// OUT: Desired output activations
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int					cNZ;
	NET_DESC			*pNet;

	pNet = pTdnnNet->pNetDesc;

	// Do forward inp -> hidden
	cNZ = GetNZSpaces(pInput, pTdnnNet->cWidth, pNet->cInput, pNZ, pcNZPerCol);
	ASSERT(cNZ >= 0);

	FeedForwardInp2Hid(pTdnnNet->cWidth, pTdnnNet->cWidthHid, pInput, pHidden, pNet->cHidden, pNet->cInput, pNet->cHidSpan,
			pNet->pIn2HidWgt, cNZ, pNZ, pcNZPerCol);

	// Expand out hidden units to simulate 'shared units' and apply bias
	addHidBias(pHidden, pNet->cHidden, pNet->cOutSpan, pTdnnNet->cWidth, pTdnnNet->cWidthHid, pNet->pHidBias);

	// No Hidden -> output
	cNZ = GetNZSpaces(pHidden, pTdnnNet->cWidth*pNet->cOutSpan, pNet->cHidden, pNZ, pcNZPerCol);

	FeedForwardHid2Out(pTdnnNet->cWidthHid, pTdnnNet->cWidth, pHidden, pOutput, pNet->cOutput, pNet->cHidden, 
			pNet->cOutSpan, pNet->pHid2Out, pNet->pOutBias, cNZ, pNZ, pcNZPerCol);

}

/*
int SumContOrBeginOnlyOutput(REAL *pOutput, int cMainOutput, const unsigned char *pChars)
{
	int		sum = 0;
	int		id;

	while (*pChars)
	{
		if (IsSupportedChar(*pChars))
		{
			id = ContinueChar2Out(*pChars);

			if (id >= cMainOutput)
			{
				id = BeginChar2Out(*pChars);
			}

			if (id < cMainOutput)
			{
				ASSERT(id >= FIRST_SOFT_MAX_UNIT);
				sum += pOutput[id];
			}
			else
			{
				ASSERT(id);
			}

		}

		pChars++;
	}

	ASSERT(sum >= 0);
	sum = __min(sum, 0xFFFF);

	return sum;
}

int SumBeginOnlyOutput(REAL *pOutput, int cMainOutput, const unsigned char *pChars)
{
	int		sum = 0;
	int		ix = 0;
	int		id;

	while (*pChars)
	{
		if (IsSupportedChar(*pChars))
		{
			id = BeginChar2Out(*pChars);
			if (id < cMainOutput)
			{
				ASSERT(id >= FIRST_SOFT_MAX_UNIT);
				sum += pOutput[id];
			}
			else
			{
				ASSERT(id);
			}

		}

		pChars++;
	}

	ASSERT(sum >= 0);
	sum = __min(sum, 0xFFFF);

	return sum;
}

int SumOutput(unsigned short *output, int cMainOutput, const unsigned char *pChars)
{
	int		ix = 0;
	int		idCont;

	while (*pChars)
	{
		if (IsSupportedChar(*pChars))
		{
			ix += (int)output[BeginChar2Out(*pChars)];
			idCont = ContinueChar2Out(*pChars);
			if (idCont < cMainOutput)
			{
				ix += (int)output[idCont];
			}
		}

		pChars++;
	}

	return ix;
}

//
// This is similar to the USA version of the space net
void ForwardSpaceNet_1(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,			// IN: Net to use
int						*pInput,			// IN: Allocated Buffer large enough to hold all inputs
int						*pHidden,			// OUT Hidden activations
REAL					*pOutput,			// I/O: On input has all char activation on OUT adds the space outputs
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol,		// IN: Number of non zero entries per time slice (column)
int						cOutput				// IN: Total Number outputs in main net (not the space net)
)
{
	const unsigned char HiPunc[] = "'\"^`";
	const unsigned char LoPunc[] = ".,_";
	const unsigned char MidPunc[] = "-=~*+";
	const unsigned char BigPunc[] = "\\!#$%&(/:;<>?@[{}|";
	const unsigned char Number[] =  "0123456789";
	const unsigned char UAlpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const unsigned char Ascender[] = "bdfhklt";
	const unsigned char Descender[] = "fgjpqyz";
	const unsigned char LAlpha[] = "aceimnorsuvwx";
	int					i;
	int					*pi, *pSpace, *pSp;
	REAL				*pOutCur;
NET_DESC			*pNet;

	pNet	= pTdnnNet->pNetDesc;
	pi		= pInput;
	pOutCur = pOutput;
	ASSERT(1 == pNet->cOutput);
	pSpace	= (int *)ExternAlloc(sizeof(*pSpace) * pNet->cOutput * pTdnnNet->cWidth);
	ASSERT(pSpace);

	if (NULL == pSpace)
	{
		return;
	}

	// Assign inputs from the feature set
	// NOTE pTdnnNet->cWidth Should have been preset to 1 less than the actual number of times
	// slices because the last slice always will have 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++)
	{
		unsigned short		*pFeat;
		int					j;
		ROMMABLE  HID_BIAS	*pb;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		ASSERT(pNet->cInput > CNEURALFEATURE);

		for (j = 0 ; j < CNEURALFEATURE; j++)
		{
			*pi++ = (*pFeat++ - *pb++) / 16;
		}

		// Before the Potential Space
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  HiPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  LoPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  MidPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  BigPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  Number) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  UAlpha) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  Ascender) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  Descender) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  LAlpha) - (int)(*pb++)) / 16;
		
		nfeature	= nfeature->next;
		pOutCur		+= cOutput;
	}

	ASSERT(pi - pInput == pNet->cInput*pTdnnNet->cWidth);

	runTDNNForward(pTdnnNet, pInput, pHidden, pSpace, pNZ, pcNZPerCol);

	pOutCur = pOutput;
	pSp = pSpace;
	// copy the space outputs into the main net output
	// NOTE dont copy the final time slice - it always has a 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++, ++pSp, pOutCur += cOutput)
	{
		int		val;

		val = Sigmoid16(*pSp >> 4);
		if (val > 0xFFFF)
		{
			val = 0xFFFF;
		}

		ASSERT(val >= 0);
		pOutCur[BeginChar2Out(' ')] = (REAL)val;
	}

	// Restore the proper time slice count
	ExternFree(pSpace);
}


// This is an experimental version of the  space net
// Add  extra features about characters on either side of potential gap
void ForwardSpaceNet(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,			// IN: Net to use
int						*pInput,			// IN: Allocated Buffer large enough to hold all inputs
int						*pHidden,			// OUT Hidden activations
REAL					*pOutput,			// I/O: On input has all char activation on OUT adds the space outputs
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol,		// IN: Number of non zero entries per time slice (column)
int						cOutput				// IN: Total Number outputs in main net (not the space net)
)
{
	const unsigned char HiPuncNoSpaceAfter[] = "'^~";
	const unsigned char MidPuncNoSpaceAfter[] = "*+-=";
	const unsigned char LoPuncSpaceAfter[] = ".,_";
	const unsigned char BigPuncSpaceAfter[] = "!$%&):;>?]}";
	const unsigned char BigPuncNoSpaceAfter[] = "#(/<@[\\{|";
	const unsigned char Number[] =  "0123456789";
	const unsigned char UAlpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const unsigned char Ascender[] = "bdfhklt";
	const unsigned char Descender[] = "fgjpqyz";
	const unsigned char LAlpha[] = "aceimnorsuvwx";

	const unsigned char HiPuncNoSpaceBefore[] = "'^~";
	const unsigned char MidPuncNoSpaceBefore[] = "*+-=";
	const unsigned char LoPuncSpaceBefore[] = "";
	const unsigned char LoPuncNoSpaceBefore[] = ",._";
	const unsigned char BigPuncSpaceBefore[] = "!#$%&(:;<?[{";
	const unsigned char BigPuncNoSpaceBefore[] = "/>@\\]|}";
	int					i;
	int					*pi, *pSpace, *pSp;
	REAL				*pOutCur, *pOutNext;
	NET_DESC			*pNet;

	pNet	= pTdnnNet->pNetDesc;

	pi		= pInput;
	pOutCur = pOutput;
	pOutNext = pOutput + cOutput;
	ASSERT(1 == pNet->cOutput);
	pSpace	= (int *)ExternAlloc(sizeof(*pSpace) * pNet->cOutput * pTdnnNet->cWidth);
	ASSERT(pSpace);

	if (NULL == pSpace)
	{
		return;
	}

	// Assign inputs from the feature set
	// NOTE pTdnnNet->cWidth Should have been preset to 1 less than the actual number of times
	// slices because the last slice always will have 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++)
	{
		unsigned short		*pFeat;
		int					j;
		ROMMABLE  HID_BIAS	*pb;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		ASSERT(pNet->cInput > CNEURALFEATURE);

		for (j = 0 ; j < CNEURALFEATURE; j++)
		{
			*pi++ = (*pFeat++ - *pb++) / 16;
		}

		// Before the Potential Space
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, HiPuncNoSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, MidPuncNoSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, LoPuncSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, BigPuncSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, BigPuncNoSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, Number) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, UAlpha) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, Ascender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, Descender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, LAlpha) - *pb++) / 16;
		
		//After Potential Space
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, HiPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, MidPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, LoPuncSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, LoPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, BigPuncSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, BigPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, Number) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, UAlpha) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, Ascender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, Descender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, LAlpha) - *pb++) / 16;
		
		nfeature	= nfeature->next;
		pOutCur		+= cOutput;
		pOutNext	+= cOutput;
	}

	ASSERT(pi - pInput == pNet->cInput*pTdnnNet->cWidth);

	runTDNNForward(pTdnnNet, pInput, pHidden, pSpace, pNZ, pcNZPerCol);

	pOutCur = pOutput;
	pSp = pSpace;
	// copy the space outputs into the main net output
	// NOTE dont copy the final time slice - it always has a 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++, ++pSp, pOutCur += cOutput)
	{
		int		val;

		val = Sigmoid16(*pSp >> 4);
		if (val > 0xFFFF)
		{
			val = 0xFFFF;
		}

		ASSERT(val >= 0);
		pOutCur[BeginChar2Out(' ')] = (REAL)val;
	}

	// Restore the proper time slice count
	ExternFree(pSpace);
}
*/

// Do a forward propagation of a net defined by the weights passed in
void ForwardMainNet(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,				// IN: Which net to use
int						*pHidden,			// OUT Hidden activations
int						*pOutput,			// OUT: Desired output activations
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{

	int					i;
	int					*pi;
	NET_DESC			*pNet;

	pNet = pTdnnNet->pNetDesc;

	pi = pOutput;

	// Assign inputs from the feature set
	for (i = pTdnnNet->cWidth; i; i--)
	{
		unsigned short		*pFeat;
		int					j;
		ROMMABLE  HID_BIAS	*pb;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		for (j=CNEURALFEATURE; j; j--)
		{
			*pi++ = (*pFeat++ - *pb++) / 16;
		}
		nfeature = nfeature->next;
	}

	ASSERT(pi - pOutput == pNet->cInput*pTdnnNet->cWidth);

	runTDNNForward(pTdnnNet, pOutput, pHidden, pOutput, pNZ, pcNZPerCol);

	// Finally the softmax
	logP2P(pTdnnNet->cWidth, pNet->cOutput, pOutput);

}


void FeedForwardDoit(FFINFO *ffinfo, int idx)
{
	int				*pi;
	NFEATURE		*nfeature;
	int				*piHidden = NULL, *piOutput = NULL;
	NFEATURESET		*nfeatureset = ffinfo->nfeatureset;
	REAL			*output =  ffinfo->NeuralOutput;
	int				iPrint = ffinfo->nfeatureset->iPrint;
	int				cWidth = nfeatureset->cSegment, cWidth1, cWidthHid;
	int				i, iCursive = (1000 - iPrint);
	unsigned short	*pNZ = NULL, *pcNZperCol = NULL;
	int				cHidden, cUnitMax;
	int				iThresh;
	TDNN_NET		net;
	//TDNN_NET		spaceNet;
	NET_DESC		*pNetDesc;

	// Threshold in terms of speed setting. Piecewise linear
	if (ffinfo->iSpeed <= 50)
	{
		ASSERT(ffinfo->iSpeed >= 0);
		iThresh = (ffinfo->iSpeed * 300) / 50;
	}
	else
	{
		ASSERT(ffinfo->iSpeed <= 100);
		iThresh = (ffinfo->iSpeed * 150) / 50 + 150;
	}

	cWidth1 = cWidth + 1;

	if (0 == idx)
	{
		pNetDesc = &s_Net;
	}
	else
	{
		//net.pNetDesc = &s_NetAlt;
		ASSERT(idx == 0 && "TDNN Network is not available");
		return;
	}

	net.pNetDesc = pNetDesc;

	cWidthHid = cWidth + (pNetDesc->cHidSpan) / 2 * 2;

	cHidden		= pNetDesc->cHidden * pNetDesc->cOutSpan;
	cUnitMax	= max(cHidden, pNetDesc->cInput*pNetDesc->cHidSpan) * cWidth1;

	piHidden = (int *) ExternAlloc(cHidden * cWidth * sizeof(*piHidden));
	pNZ = (unsigned short *) ExternAlloc(cUnitMax*sizeof(*pNZ));
	pcNZperCol = (unsigned short *) ExternAlloc(cWidth1 * pNetDesc->cOutSpan * sizeof(*pcNZperCol));
	piOutput = (int *) ExternAlloc(pNetDesc->cOutput * cWidth * sizeof(*piOutput));

	if (!piHidden || !pNZ || !pcNZperCol || !piOutput)
	{
		goto fail;
	}


	net.cWidth				= cWidth;
	net.cWidthHid			= cWidthHid;
	nfeature				= nfeatureset->head;

	//ForwardMainNet(nfeature, pNetDesc, piHidden, piOutput, pNZ, pcNZperCol);		
	ForwardMainNet(nfeature, &net, piHidden, piOutput, pNZ, pcNZperCol);		

	pi = piOutput;
	for (i = 0 ; i < cWidth; i++)
	{
		int		iOut;

		for (iOut = 0 ; iOut < pNetDesc->cOutput ; ++iOut)
		{
			*output = (REAL)*pi;
			++output;
			++pi;
		}
	}

	/*
	// No space net for now
	if (cWidth > 1 )
	{
		spaceNet.cWidth		= cWidth-1;
		spaceNet.cWidthHid	= cWidthHid-1;
		spaceNet.pNetDesc	= &s_SpaceNet;

		ForwardSpaceNet_1(nfeature, &spaceNet, piOutput, piHidden, ffinfo->NeuralOutput, pNZ, pcNZperCol, pNetDesc->cOutput);
	}
	*/

fail:
	ExternFree(piOutput);
	ExternFree(piHidden);
	ExternFree(pNZ);
	ExternFree(pcNZperCol);



	return;

}

void FeedForward(FFINFO *ffinfo)
{
	FeedForwardDoit(ffinfo, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\nnet.h ===
// nnet.h
// converted from command NN_net2c in annTcl on Mon Feb 19 18:11:38 2001
// from net description file H:/fra/TRAINNET/net-desc_37_150_1_5_194.txt,  weight file save_19.wgt, statFile ../../../annEuro/all.sta in directory G:/mrevow/deu/annTcl/goodPanel1/convert on machine MREVOW1
#ifndef NNET_H
#define NNET_H

// Type definitions

typedef short INP_HID_WEIGHT;
typedef int HID_BIAS;
typedef char HID_OUT_WEIGHT;
typedef int OUT_BIAS;
typedef int INP_BIAS;

#define gcOutputNode 185


#endif // NNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\lpunc.c ===
// lpunc.c (Leading punctuation)
// 
// Nov 2001 mrevow
// Matches LM spec of 10/15/2001

#include "common.h"
#include "lpunc.h"

// text generated by re2fsa at Thu Nov 08 14:42:17 2001

// the input-file of rules:
// L = DQ ;
// L = l ;
// L = DQ l ;
// L = l DQ ;
// L = SQ ;
// L = SQ l ;
// L = l SQ ;
// L = SQ DQ ;
// L = DQ SQ ;
// l = "(" ;
// l = "[" ;
// l = "{" ;
// l = "." "." "." ;
// l = "*" ["*" ["*"]] ;
// DQ = "" ;
// SQ = "'" | "," ;
// = L ;

// 13 states

static const unsigned char gaSLPUNC[] = 
	/* gaStringLPUNC+0 */	"',\000"
	/* gaStringLPUNC+3 */	"([{\000"
	/* gaStringLPUNC+7 */	"*\000"
	/* gaStringLPUNC+9 */	".\000"
	/* gaStringLPUNC+11 */	"\000"
	/* gaStringLPUNC+13 */	"([{\000"
	/* gaStringLPUNC+18 */	"',\000"
	/* gaStringLPUNC+22 */	"'(,[{\000"
;

static const STATE_TRANSITION gaTLPUNC[] = {
	{gaSLPUNC+0,	1}, // +0: state 0 transitions
	{gaSLPUNC+3,	2},
	{gaSLPUNC+7,	3},
	{gaSLPUNC+9,	4},
	{gaSLPUNC+11,	5},
	{gaSLPUNC+13,	6}, // +5: state 1 transitions
	{gaSLPUNC+7,	7},
	{gaSLPUNC+9,	8},
	{gaSLPUNC+18,	6}, // +8: state 2 transitions
	{gaSLPUNC+18,	6}, // +9: state 3 transitions
	{gaSLPUNC+7,	9},
	{gaSLPUNC+9,	10}, // +11: state 4 transitions
	{gaSLPUNC+22,	6}, // +12: state 5 transitions
	{gaSLPUNC+7,	7},
	{gaSLPUNC+9,	8},
	{gaSLPUNC+7,	11}, // +15: state 7 transitions
	{gaSLPUNC+9,	12}, // +16: state 8 transitions
	{gaSLPUNC+7,	2}, // +17: state 9 transitions
	{gaSLPUNC+18,	6},
	{gaSLPUNC+9,	2}, // +19: state 10 transitions
	{gaSLPUNC+7,	6}, // +20: state 11 transitions
	{gaSLPUNC+9,	6}, // +21: state 12 transitions
};

const STATE_DESCRIPTION aStateDescLPUNC[13] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTLPUNC+0},
	/*   1 */ {1, 3, gaTLPUNC+5},
	/*   2 */ {1, 1, gaTLPUNC+8},
	/*   3 */ {1, 2, gaTLPUNC+9},
	/*   4 */ {0, 1, gaTLPUNC+11},
	/*   5 */ {1, 3, gaTLPUNC+12},
	/*   6 */ {1, 0, NULL},
	/*   7 */ {1, 1, gaTLPUNC+15},
	/*   8 */ {0, 1, gaTLPUNC+16},
	/*   9 */ {1, 2, gaTLPUNC+17},
	/*  10 */ {0, 1, gaTLPUNC+19},
	/*  11 */ {1, 1, gaTLPUNC+20},
	/*  12 */ {0, 1, gaTLPUNC+21},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\nnetprint.h ===
// nnetPrint.h
// converted from command NN_net2c in annTcl on Mon Feb 19 18:15:29 2001
// from net description file H:/fra/TRAINNET/net-desc_37_150_1_5_194.txt,  weight file save_19.wgt, statFile ../../../annEuro/all.sta in directory G:/mrevow/deu/annTcl/goodPanel1/convert on machine MREVOW1
#ifndef NNET_PRINT_H
#define NNET_PRINT_H

// Time Stamp
#define NET_TIME_STAMP_PRINT	0x3a91d33f

// Type definitions

typedef short INP_HID_WEIGHT_PRINT;
typedef int HID_BIAS_PRINT;
typedef char HID_OUT_WEIGHT_PRINT;
typedef int OUT_BIAS_PRINT;
typedef int INP_BIAS_PRINT;


// Hidden Layer
#define gcHiddenNodePrint 150
#define gcHiddenWeightHeightPrint 37
#define gcHiddenWeightWidthPrint 3
extern ROMMABLE  INP_HID_WEIGHT_PRINT grgHiddenWeightPrint[gcHiddenNodePrint*gcHiddenWeightHeightPrint*gcHiddenWeightWidthPrint];


// Output Layer
#define gcOutputNodePrint 200
#define gcOutputWeightHeightPrint 150
#define gcOutputWeightWidthPrint 3
extern ROMMABLE  HID_OUT_WEIGHT_PRINT grgOutputWeightPrint[gcOutputNodePrint*gcOutputWeightHeightPrint*gcOutputWeightWidthPrint];

// Bias
extern ROMMABLE INP_BIAS_PRINT grgInputBiasPrint[gcHiddenWeightHeightPrint];
extern ROMMABLE HID_BIAS_PRINT grgHiddenBiasPrint[gcHiddenNodePrint * gcOutputWeightWidthPrint];
extern ROMMABLE OUT_BIAS_PRINT grgOutputBiasPrint[gcOutputNodePrint];

#endif // NNET_PRINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\number.c ===
// number.c
// 
// Nov 2001 mrevow
// Matches LM spec of 10/15/2001

#include "common.h"
#include "fsa.h"

// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = number

// 396 states

static const unsigned char gaSNUMBER[] = 
	/* gaStringNUMBER+0 */	"$\000"
	/* gaStringNUMBER+5 */	"'\000"
	/* gaStringNUMBER+7 */	"(\000"
	/* gaStringNUMBER+9 */	"+\000"
	/* gaStringNUMBER+11 */	"-\000"
	/* gaStringNUMBER+13 */	"0\000"
	/* gaStringNUMBER+15 */	"1\000"
	/* gaStringNUMBER+17 */	"2\000"
	/* gaStringNUMBER+19 */	"3\000"
	/* gaStringNUMBER+21 */	"456789\000"
	/* gaStringNUMBER+28 */	"D\000"
	/* gaStringNUMBER+30 */	"E\000"
	/* gaStringNUMBER+32 */	"F\000"
	/* gaStringNUMBER+34 */	"M\000"
	/* gaStringNUMBER+36 */	"S\000"
	/* gaStringNUMBER+38 */	"\000"
	/* gaStringNUMBER+40 */	" \000"
	/* gaStringNUMBER+42 */	"0123456789\000"
	/* gaStringNUMBER+53 */	"+-\000"
	/* gaStringNUMBER+56 */	"*+-/\000"
	/* gaStringNUMBER+61 */	",\000"
	/* gaStringNUMBER+63 */	".\000"
	/* gaStringNUMBER+65 */	"123456789\000"
	/* gaStringNUMBER+75 */	":\000"
	/* gaStringNUMBER+77 */	"<=>\000"
	/* gaStringNUMBER+81 */	"\000"
	/* gaStringNUMBER+83 */	"012\000"
	/* gaStringNUMBER+87 */	"3456789\000"
	/* gaStringNUMBER+95 */	"01234\000"
	/* gaStringNUMBER+101 */	"56789\000"
	/* gaStringNUMBER+107 */	"01\000"
	/* gaStringNUMBER+110 */	"23456789\000"
	/* gaStringNUMBER+119 */	"i\000"
	/* gaStringNUMBER+121 */	"o\000"
	/* gaStringNUMBER+123 */	"U\000"
	/* gaStringNUMBER+125 */	"r\000"
	/* gaStringNUMBER+127 */	"a\000"
	/* gaStringNUMBER+129 */	"$%gl\000"
	/* gaStringNUMBER+137 */	"Ff\000"
	/* gaStringNUMBER+140 */	"K\000"
	/* gaStringNUMBER+142 */	"Zz\000"
	/* gaStringNUMBER+145 */	"c\000"
	/* gaStringNUMBER+147 */	"d\000"
	/* gaStringNUMBER+149 */	"k\000"
	/* gaStringNUMBER+151 */	"m\000"
	/* gaStringNUMBER+153 */	"012345\000"
	/* gaStringNUMBER+160 */	"6789\000"
	/* gaStringNUMBER+165 */	"2345\000"
	/* gaStringNUMBER+170 */	"A\000"
	/* gaStringNUMBER+172 */	"J\000"
	/* gaStringNUMBER+174 */	"N\000"
	/* gaStringNUMBER+176 */	"O\000"
	/* gaStringNUMBER+178 */	"e\000"
	/* gaStringNUMBER+180 */	"n\000"
	/* gaStringNUMBER+182 */	"R\000"
	/* gaStringNUMBER+184 */	"t\000"
	/* gaStringNUMBER+186 */	"%gl\000"
	/* gaStringNUMBER+190 */	"u\000"
	/* gaStringNUMBER+192 */	"glm\000"
	/* gaStringNUMBER+196 */	"l\000"
	/* gaStringNUMBER+198 */	"gm\000"
	/* gaStringNUMBER+201 */	"h\000"
	/* gaStringNUMBER+203 */	".:\000"
	/* gaStringNUMBER+206 */	"*+-\000"
	/* gaStringNUMBER+210 */	"/\000"
	/* gaStringNUMBER+212 */	"CF\000"
	/* gaStringNUMBER+215 */	"p\000"
	/* gaStringNUMBER+217 */	"\000"
	/* gaStringNUMBER+219 */	"s\000"
	/* gaStringNUMBER+221 */	")\000"
	/* gaStringNUMBER+223 */	"\000"
	/* gaStringNUMBER+225 */	"*+\000"
	/* gaStringNUMBER+228 */	"g\000"
	/* gaStringNUMBER+230 */	"z\000"
	/* gaStringNUMBER+232 */	"b\000"
	/* gaStringNUMBER+234 */	"ln\000"
	/* gaStringNUMBER+237 */	"v\000"
	/* gaStringNUMBER+239 */	"w\000"
	/* gaStringNUMBER+241 */	".i\000"
	/* gaStringNUMBER+244 */	".z\000"
	/* gaStringNUMBER+247 */	"12\000"
;

static const STATE_TRANSITION gaTNUMBER[] = {
	{gaSNUMBER+0,	1}, // +0: state 0 transitions
	{gaSNUMBER+5,	2},
	{gaSNUMBER+7,	3},
	{gaSNUMBER+9,	4},
	{gaSNUMBER+11,	5},
	{gaSNUMBER+13,	6},
	{gaSNUMBER+15,	7},
	{gaSNUMBER+17,	8},
	{gaSNUMBER+19,	9},
	{gaSNUMBER+21,	10},
	{gaSNUMBER+28,	11},
	{gaSNUMBER+30,	12},
	{gaSNUMBER+32,	13},
	{gaSNUMBER+34,	14},
	{gaSNUMBER+36,	15},
	{gaSNUMBER+38,	16},
	{gaSNUMBER+40,	17}, // +16: state 1 transitions
	{gaSNUMBER+42,	18}, // +17: state 2 transitions
	{gaSNUMBER+53,	19}, // +18: state 3 transitions
	{gaSNUMBER+42,	20},
	{gaSNUMBER+42,	21}, // +20: state 4 transitions
	{gaSNUMBER+42,	22}, // +21: state 5 transitions
	{gaSNUMBER+40,	23}, // +22: state 6 transitions
	{gaSNUMBER+56,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+63,	26},
	{gaSNUMBER+13,	27},
	{gaSNUMBER+65,	28},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+56,	24}, // +31: state 7 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+83,	28},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	32},
	{gaSNUMBER+63,	33},
	{gaSNUMBER+87,	34},
	{gaSNUMBER+56,	24}, // +40: state 8 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	32},
	{gaSNUMBER+63,	33},
	{gaSNUMBER+95,	34},
	{gaSNUMBER+101,	35},
	{gaSNUMBER+56,	24}, // +49: state 9 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	32},
	{gaSNUMBER+63,	33},
	{gaSNUMBER+107,	35},
	{gaSNUMBER+110,	36},
	{gaSNUMBER+56,	24}, // +58: state 10 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	32},
	{gaSNUMBER+63,	33},
	{gaSNUMBER+42,	36},
	{gaSNUMBER+34,	1}, // +66: state 11 transitions
	{gaSNUMBER+119,	37},
	{gaSNUMBER+121,	38},
	{gaSNUMBER+123,	39}, // +69: state 12 transitions
	{gaSNUMBER+125,	40}, // +70: state 13 transitions
	{gaSNUMBER+119,	41}, // +71: state 14 transitions
	{gaSNUMBER+121,	42},
	{gaSNUMBER+127,	43}, // +73: state 15 transitions
	{gaSNUMBER+121,	44},
	{gaSNUMBER+42,	45}, // +75: state 16 transitions
	{gaSNUMBER+42,	46}, // +76: state 17 transitions
	{gaSNUMBER+42,	47}, // +77: state 18 transitions
	{gaSNUMBER+42,	48}, // +78: state 19 transitions
	{gaSNUMBER+56,	49}, // +79: state 20 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+42,	52},
	{gaSNUMBER+56,	24}, // +83: state 21 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+63,	55},
	{gaSNUMBER+42,	56},
	{gaSNUMBER+56,	24}, // +90: state 22 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+63,	55},
	{gaSNUMBER+42,	57},
	{gaSNUMBER+129,	47}, // +97: state 23 transitions
	{gaSNUMBER+28,	58},
	{gaSNUMBER+30,	59},
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+7,	68}, // +108: state 24 transitions
	{gaSNUMBER+53,	69},
	{gaSNUMBER+42,	70},
	{gaSNUMBER+11,	71}, // +111: state 25 transitions
	{gaSNUMBER+42,	72},
	{gaSNUMBER+153,	73}, // +113: state 26 transitions
	{gaSNUMBER+160,	74},
	{gaSNUMBER+56,	24}, // +115: state 27 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+63,	26},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	75},
	{gaSNUMBER+42,	76},
	{gaSNUMBER+56,	24}, // +123: state 28 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	33},
	{gaSNUMBER+40,	77},
	{gaSNUMBER+42,	78},
	{gaSNUMBER+153,	79}, // +131: state 29 transitions
	{gaSNUMBER+160,	80},
	{gaSNUMBER+7,	81}, // +133: state 30 transitions
	{gaSNUMBER+53,	82},
	{gaSNUMBER+42,	83},
	{gaSNUMBER+40,	84}, // +136: state 31 transitions
	{gaSNUMBER+5,	2}, // +137: state 32 transitions
	{gaSNUMBER+129,	47},
	{gaSNUMBER+28,	58},
	{gaSNUMBER+30,	59},
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+42,	85},
	{gaSNUMBER+40,	86}, // +150: state 33 transitions
	{gaSNUMBER+13,	87},
	{gaSNUMBER+15,	88},
	{gaSNUMBER+165,	89},
	{gaSNUMBER+160,	90},
	{gaSNUMBER+170,	91},
	{gaSNUMBER+28,	92},
	{gaSNUMBER+32,	93},
	{gaSNUMBER+172,	94},
	{gaSNUMBER+34,	95},
	{gaSNUMBER+174,	96},
	{gaSNUMBER+176,	97},
	{gaSNUMBER+36,	98},
	{gaSNUMBER+56,	24}, // +163: state 34 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+75,	29},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	33},
	{gaSNUMBER+40,	75},
	{gaSNUMBER+42,	78},
	{gaSNUMBER+56,	24}, // +171: state 35 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	75},
	{gaSNUMBER+42,	78},
	{gaSNUMBER+63,	99},
	{gaSNUMBER+56,	24}, // +178: state 36 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	75},
	{gaSNUMBER+42,	78},
	{gaSNUMBER+63,	100},
	{gaSNUMBER+63,	101}, // +185: state 37 transitions
	{gaSNUMBER+178,	102},
	{gaSNUMBER+63,	101}, // +187: state 38 transitions
	{gaSNUMBER+180,	103},
	{gaSNUMBER+182,	104}, // +189: state 39 transitions
	{gaSNUMBER+63,	101}, // +190: state 40 transitions
	{gaSNUMBER+178,	105},
	{gaSNUMBER+63,	101}, // +192: state 41 transitions
	{gaSNUMBER+184,	106},
	{gaSNUMBER+63,	101}, // +194: state 42 transitions
	{gaSNUMBER+180,	107},
	{gaSNUMBER+63,	101}, // +196: state 43 transitions
	{gaSNUMBER+151,	108},
	{gaSNUMBER+63,	101}, // +198: state 44 transitions
	{gaSNUMBER+180,	109},
	{gaSNUMBER+42,	45}, // +200: state 45 transitions
	{gaSNUMBER+61,	110}, // +201: state 46 transitions
	{gaSNUMBER+63,	111},
	{gaSNUMBER+42,	112},
	{gaSNUMBER+56,	49}, // +204: state 48 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+42,	113},
	{gaSNUMBER+53,	114}, // +208: state 49 transitions
	{gaSNUMBER+42,	115},
	{gaSNUMBER+11,	116}, // +210: state 50 transitions
	{gaSNUMBER+42,	117},
	{gaSNUMBER+42,	118}, // +212: state 51 transitions
	{gaSNUMBER+56,	49}, // +213: state 52 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+42,	119},
	{gaSNUMBER+186,	47}, // +217: state 53 transitions
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+11,	120}, // +226: state 54 transitions
	{gaSNUMBER+42,	121},
	{gaSNUMBER+42,	122}, // +228: state 55 transitions
	{gaSNUMBER+56,	24}, // +229: state 56 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+63,	55},
	{gaSNUMBER+40,	123},
	{gaSNUMBER+42,	124},
	{gaSNUMBER+56,	24}, // +236: state 57 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+63,	55},
	{gaSNUMBER+42,	124},
	{gaSNUMBER+34,	47}, // +243: state 58 transitions
	{gaSNUMBER+123,	125}, // +244: state 59 transitions
	{gaSNUMBER+190,	126}, // +245: state 60 transitions
	{gaSNUMBER+151,	47}, // +246: state 61 transitions
	{gaSNUMBER+178,	127}, // +247: state 62 transitions
	{gaSNUMBER+121,	128}, // +248: state 63 transitions
	{gaSNUMBER+192,	47}, // +249: state 64 transitions
	{gaSNUMBER+196,	47}, // +250: state 65 transitions
	{gaSNUMBER+198,	47}, // +251: state 66 transitions
	{gaSNUMBER+192,	47}, // +252: state 67 transitions
	{gaSNUMBER+178,	127},
	{gaSNUMBER+53,	129}, // +254: state 68 transitions
	{gaSNUMBER+42,	130},
	{gaSNUMBER+42,	70}, // +256: state 69 transitions
	{gaSNUMBER+77,	30}, // +257: state 70 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	133},
	{gaSNUMBER+40,	23}, // +261: state 71 transitions
	{gaSNUMBER+56,	24},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+56,	24}, // +265: state 72 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+42,	134},
	{gaSNUMBER+201,	47}, // +270: state 73 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+203,	136},
	{gaSNUMBER+42,	137},
	{gaSNUMBER+201,	47}, // +274: state 74 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+203,	136},
	{gaSNUMBER+42,	138},
	{gaSNUMBER+129,	47}, // +278: state 75 transitions
	{gaSNUMBER+28,	58},
	{gaSNUMBER+30,	59},
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+42,	139},
	{gaSNUMBER+40,	23}, // +290: state 76 transitions
	{gaSNUMBER+206,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	100},
	{gaSNUMBER+210,	140},
	{gaSNUMBER+42,	141},
	{gaSNUMBER+5,	2}, // +298: state 77 transitions
	{gaSNUMBER+129,	47},
	{gaSNUMBER+28,	58},
	{gaSNUMBER+30,	59},
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+42,	142},
	{gaSNUMBER+40,	23}, // +311: state 78 transitions
	{gaSNUMBER+206,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	100},
	{gaSNUMBER+210,	140},
	{gaSNUMBER+42,	143},
	{gaSNUMBER+201,	47}, // +319: state 79 transitions
	{gaSNUMBER+42,	80},
	{gaSNUMBER+40,	135},
	{gaSNUMBER+203,	136},
	{gaSNUMBER+201,	47}, // +323: state 80 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+203,	136},
	{gaSNUMBER+53,	144}, // +326: state 81 transitions
	{gaSNUMBER+42,	145},
	{gaSNUMBER+42,	83}, // +328: state 82 transitions
	{gaSNUMBER+56,	146}, // +329: state 83 transitions
	{gaSNUMBER+61,	147},
	{gaSNUMBER+63,	148},
	{gaSNUMBER+42,	149},
	{gaSNUMBER+212,	47}, // +333: state 84 transitions
	{gaSNUMBER+42,	150}, // +334: state 85 transitions
	{gaSNUMBER+170,	91}, // +335: state 86 transitions
	{gaSNUMBER+28,	92},
	{gaSNUMBER+32,	93},
	{gaSNUMBER+172,	94},
	{gaSNUMBER+34,	95},
	{gaSNUMBER+174,	96},
	{gaSNUMBER+176,	97},
	{gaSNUMBER+36,	98},
	{gaSNUMBER+201,	47}, // +343: state 87 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+203,	136},
	{gaSNUMBER+13,	137},
	{gaSNUMBER+65,	151},
	{gaSNUMBER+201,	47}, // +348: state 88 transitions
	{gaSNUMBER+75,	136},
	{gaSNUMBER+87,	137},
	{gaSNUMBER+83,	151},
	{gaSNUMBER+40,	152},
	{gaSNUMBER+63,	153},
	{gaSNUMBER+201,	47}, // +354: state 89 transitions
	{gaSNUMBER+75,	136},
	{gaSNUMBER+42,	137},
	{gaSNUMBER+40,	152},
	{gaSNUMBER+63,	153},
	{gaSNUMBER+201,	47}, // +359: state 90 transitions
	{gaSNUMBER+75,	136},
	{gaSNUMBER+42,	138},
	{gaSNUMBER+40,	152},
	{gaSNUMBER+63,	153},
	{gaSNUMBER+215,	154}, // +364: state 91 transitions
	{gaSNUMBER+190,	155},
	{gaSNUMBER+178,	156}, // +366: state 92 transitions
	{gaSNUMBER+178,	157}, // +367: state 93 transitions
	{gaSNUMBER+127,	158}, // +368: state 94 transitions
	{gaSNUMBER+190,	159},
	{gaSNUMBER+127,	160}, // +370: state 95 transitions
	{gaSNUMBER+217,	161},
	{gaSNUMBER+121,	162}, // +372: state 96 transitions
	{gaSNUMBER+149,	163}, // +373: state 97 transitions
	{gaSNUMBER+178,	164}, // +374: state 98 transitions
	{gaSNUMBER+40,	86}, // +375: state 99 transitions
	{gaSNUMBER+170,	91},
	{gaSNUMBER+28,	92},
	{gaSNUMBER+32,	93},
	{gaSNUMBER+172,	94},
	{gaSNUMBER+34,	95},
	{gaSNUMBER+174,	96},
	{gaSNUMBER+176,	97},
	{gaSNUMBER+36,	98},
	{gaSNUMBER+13,	165},
	{gaSNUMBER+15,	166},
	{gaSNUMBER+110,	167},
	{gaSNUMBER+42,	168}, // +387: state 100 transitions
	{gaSNUMBER+61,	169}, // +388: state 101 transitions
	{gaSNUMBER+180,	108}, // +389: state 102 transitions
	{gaSNUMBER+180,	170}, // +390: state 103 transitions
	{gaSNUMBER+176,	1}, // +391: state 104 transitions
	{gaSNUMBER+40,	17},
	{gaSNUMBER+119,	107}, // +393: state 105 transitions
	{gaSNUMBER+184,	171}, // +394: state 106 transitions
	{gaSNUMBER+184,	172}, // +395: state 107 transitions
	{gaSNUMBER+219,	107}, // +396: state 108 transitions
	{gaSNUMBER+180,	107}, // +397: state 109 transitions
	{gaSNUMBER+42,	18}, // +398: state 110 transitions
	{gaSNUMBER+11,	47},
	{gaSNUMBER+42,	173}, // +400: state 111 transitions
	{gaSNUMBER+61,	110}, // +401: state 112 transitions
	{gaSNUMBER+63,	111},
	{gaSNUMBER+42,	174},
	{gaSNUMBER+56,	49}, // +404: state 113 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+42,	175},
	{gaSNUMBER+42,	115}, // +408: state 114 transitions
	{gaSNUMBER+221,	176}, // +409: state 115 transitions
	{gaSNUMBER+61,	177},
	{gaSNUMBER+63,	178},
	{gaSNUMBER+42,	179},
	{gaSNUMBER+56,	49}, // +413: state 116 transitions
	{gaSNUMBER+56,	49}, // +414: state 117 transitions
	{gaSNUMBER+42,	117},
	{gaSNUMBER+42,	180}, // +416: state 118 transitions
	{gaSNUMBER+56,	49}, // +417: state 119 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+221,	181},
	{gaSNUMBER+42,	182},
	{gaSNUMBER+56,	24}, // +422: state 120 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+56,	24}, // +426: state 121 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+42,	121},
	{gaSNUMBER+42,	183}, // +431: state 122 transitions
	{gaSNUMBER+186,	47}, // +432: state 123 transitions
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+7,	184},
	{gaSNUMBER+42,	185},
	{gaSNUMBER+56,	24}, // +443: state 124 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+63,	55},
	{gaSNUMBER+42,	186},
	{gaSNUMBER+182,	187}, // +450: state 125 transitions
	{gaSNUMBER+223,	47}, // +451: state 126 transitions
	{gaSNUMBER+119,	188}, // +452: state 127 transitions
	{gaSNUMBER+196,	65}, // +453: state 128 transitions
	{gaSNUMBER+42,	130}, // +454: state 129 transitions
	{gaSNUMBER+56,	189}, // +455: state 130 transitions
	{gaSNUMBER+61,	190},
	{gaSNUMBER+63,	191},
	{gaSNUMBER+42,	192},
	{gaSNUMBER+11,	193}, // +459: state 131 transitions
	{gaSNUMBER+42,	194},
	{gaSNUMBER+42,	195}, // +461: state 132 transitions
	{gaSNUMBER+77,	30}, // +462: state 133 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	196},
	{gaSNUMBER+40,	23}, // +466: state 134 transitions
	{gaSNUMBER+56,	24},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+42,	121},
	{gaSNUMBER+123,	197}, // +471: state 135 transitions
	{gaSNUMBER+153,	198}, // +472: state 136 transitions
	{gaSNUMBER+160,	199},
	{gaSNUMBER+201,	47}, // +474: state 137 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+203,	136},
	{gaSNUMBER+42,	200},
	{gaSNUMBER+42,	200}, // +478: state 138 transitions
	{gaSNUMBER+42,	201}, // +479: state 139 transitions
	{gaSNUMBER+7,	68}, // +480: state 140 transitions
	{gaSNUMBER+53,	69},
	{gaSNUMBER+42,	202},
	{gaSNUMBER+225,	24}, // +483: state 141 transitions
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	47},
	{gaSNUMBER+210,	140},
	{gaSNUMBER+40,	203},
	{gaSNUMBER+11,	204},
	{gaSNUMBER+42,	205},
	{gaSNUMBER+42,	206}, // +492: state 142 transitions
	{gaSNUMBER+40,	23}, // +493: state 143 transitions
	{gaSNUMBER+225,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	47},
	{gaSNUMBER+210,	140},
	{gaSNUMBER+11,	204},
	{gaSNUMBER+42,	205},
	{gaSNUMBER+42,	145}, // +502: state 144 transitions
	{gaSNUMBER+56,	207}, // +503: state 145 transitions
	{gaSNUMBER+61,	208},
	{gaSNUMBER+63,	209},
	{gaSNUMBER+42,	210},
	{gaSNUMBER+7,	211}, // +507: state 146 transitions
	{gaSNUMBER+53,	212},
	{gaSNUMBER+42,	213},
	{gaSNUMBER+11,	214}, // +510: state 147 transitions
	{gaSNUMBER+42,	215},
	{gaSNUMBER+42,	216}, // +512: state 148 transitions
	{gaSNUMBER+56,	146}, // +513: state 149 transitions
	{gaSNUMBER+61,	147},
	{gaSNUMBER+63,	148},
	{gaSNUMBER+42,	217},
	{gaSNUMBER+42,	18}, // +517: state 150 transitions
	{gaSNUMBER+201,	47}, // +518: state 151 transitions
	{gaSNUMBER+75,	136},
	{gaSNUMBER+40,	152},
	{gaSNUMBER+63,	153},
	{gaSNUMBER+42,	200},
	{gaSNUMBER+5,	2}, // +523: state 152 transitions
	{gaSNUMBER+42,	85},
	{gaSNUMBER+123,	197},
	{gaSNUMBER+153,	198}, // +526: state 153 transitions
	{gaSNUMBER+160,	199},
	{gaSNUMBER+125,	218}, // +528: state 154 transitions
	{gaSNUMBER+228,	219}, // +529: state 155 transitions
	{gaSNUMBER+230,	220}, // +530: state 156 transitions
	{gaSNUMBER+232,	221}, // +531: state 157 transitions
	{gaSNUMBER+180,	222}, // +532: state 158 transitions
	{gaSNUMBER+234,	223}, // +533: state 159 transitions
	{gaSNUMBER+119,	224}, // +534: state 160 transitions
	{gaSNUMBER+125,	225}, // +535: state 161 transitions
	{gaSNUMBER+237,	220}, // +536: state 162 transitions
	{gaSNUMBER+184,	226}, // +537: state 163 transitions
	{gaSNUMBER+215,	227}, // +538: state 164 transitions
	{gaSNUMBER+13,	138}, // +539: state 165 transitions
	{gaSNUMBER+65,	228},
	{gaSNUMBER+63,	47}, // +541: state 166 transitions
	{gaSNUMBER+87,	138},
	{gaSNUMBER+83,	228},
	{gaSNUMBER+40,	229},
	{gaSNUMBER+63,	47}, // +545: state 167 transitions
	{gaSNUMBER+42,	138},
	{gaSNUMBER+40,	229},
	{gaSNUMBER+42,	138}, // +548: state 168 transitions
	{gaSNUMBER+40,	230}, // +549: state 169 transitions
	{gaSNUMBER+178,	231}, // +550: state 170 transitions
	{gaSNUMBER+239,	232}, // +551: state 171 transitions
	{gaSNUMBER+127,	233}, // +552: state 172 transitions
	{gaSNUMBER+42,	234}, // +553: state 173 transitions
	{gaSNUMBER+61,	110}, // +554: state 174 transitions
	{gaSNUMBER+63,	111},
	{gaSNUMBER+42,	235},
	{gaSNUMBER+56,	49}, // +557: state 175 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+42,	236},
	{gaSNUMBER+56,	24}, // +561: state 176 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+11,	237}, // +563: state 177 transitions
	{gaSNUMBER+42,	238},
	{gaSNUMBER+42,	239}, // +565: state 178 transitions
	{gaSNUMBER+221,	176}, // +566: state 179 transitions
	{gaSNUMBER+61,	177},
	{gaSNUMBER+63,	178},
	{gaSNUMBER+42,	240},
	{gaSNUMBER+42,	241}, // +570: state 180 transitions
	{gaSNUMBER+40,	242}, // +571: state 181 transitions
	{gaSNUMBER+56,	49}, // +572: state 182 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+221,	181},
	{gaSNUMBER+42,	243},
	{gaSNUMBER+42,	244}, // +576: state 183 transitions
	{gaSNUMBER+13,	245}, // +577: state 184 transitions
	{gaSNUMBER+65,	246},
	{gaSNUMBER+42,	247}, // +579: state 185 transitions
	{gaSNUMBER+56,	24}, // +580: state 186 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+42,	186},
	{gaSNUMBER+176,	47}, // +586: state 187 transitions
	{gaSNUMBER+196,	248}, // +587: state 188 transitions
	{gaSNUMBER+53,	249}, // +588: state 189 transitions
	{gaSNUMBER+42,	250},
	{gaSNUMBER+11,	251}, // +590: state 190 transitions
	{gaSNUMBER+42,	252},
	{gaSNUMBER+42,	253}, // +592: state 191 transitions
	{gaSNUMBER+56,	189}, // +593: state 192 transitions
	{gaSNUMBER+61,	190},
	{gaSNUMBER+63,	191},
	{gaSNUMBER+42,	254},
	{gaSNUMBER+77,	30}, // +597: state 193 transitions
	{gaSNUMBER+77,	30}, // +598: state 194 transitions
	{gaSNUMBER+42,	194},
	{gaSNUMBER+42,	255}, // +600: state 195 transitions
	{gaSNUMBER+77,	30}, // +601: state 196 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	256},
	{gaSNUMBER+201,	257}, // +605: state 197 transitions
	{gaSNUMBER+201,	47}, // +606: state 198 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+42,	199},
	{gaSNUMBER+201,	47}, // +609: state 199 transitions
	{gaSNUMBER+40,	135},
	{gaSNUMBER+40,	23}, // +611: state 200 transitions
	{gaSNUMBER+56,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	258},
	{gaSNUMBER+40,	259}, // +617: state 201 transitions
	{gaSNUMBER+77,	30}, // +618: state 202 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	260},
	{gaSNUMBER+129,	47}, // +622: state 203 transitions
	{gaSNUMBER+28,	58},
	{gaSNUMBER+30,	59},
	{gaSNUMBER+137,	60},
	{gaSNUMBER+140,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+142,	63},
	{gaSNUMBER+145,	64},
	{gaSNUMBER+147,	65},
	{gaSNUMBER+149,	66},
	{gaSNUMBER+151,	67},
	{gaSNUMBER+7,	184},
	{gaSNUMBER+42,	185},
	{gaSNUMBER+7,	68}, // +635: state 204 transitions
	{gaSNUMBER+53,	69},
	{gaSNUMBER+13,	261},
	{gaSNUMBER+15,	262},
	{gaSNUMBER+110,	263},
	{gaSNUMBER+40,	23}, // +640: state 205 transitions
	{gaSNUMBER+206,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	47},
	{gaSNUMBER+210,	140},
	{gaSNUMBER+42,	264},
	{gaSNUMBER+42,	18}, // +648: state 206 transitions
	{gaSNUMBER+40,	259},
	{gaSNUMBER+53,	265}, // +650: state 207 transitions
	{gaSNUMBER+42,	266},
	{gaSNUMBER+11,	267}, // +652: state 208 transitions
	{gaSNUMBER+42,	268},
	{gaSNUMBER+42,	269}, // +654: state 209 transitions
	{gaSNUMBER+56,	207}, // +655: state 210 transitions
	{gaSNUMBER+61,	208},
	{gaSNUMBER+63,	209},
	{gaSNUMBER+42,	270},
	{gaSNUMBER+53,	271}, // +659: state 211 transitions
	{gaSNUMBER+42,	272},
	{gaSNUMBER+42,	213}, // +661: state 212 transitions
	{gaSNUMBER+61,	273}, // +662: state 213 transitions
	{gaSNUMBER+63,	274},
	{gaSNUMBER+42,	275},
	{gaSNUMBER+56,	146}, // +665: state 214 transitions
	{gaSNUMBER+56,	146}, // +666: state 215 transitions
	{gaSNUMBER+42,	215},
	{gaSNUMBER+42,	276}, // +668: state 216 transitions
	{gaSNUMBER+56,	146}, // +669: state 217 transitions
	{gaSNUMBER+61,	147},
	{gaSNUMBER+63,	148},
	{gaSNUMBER+42,	277},
	{gaSNUMBER+63,	224}, // +673: state 218 transitions
	{gaSNUMBER+119,	278},
	{gaSNUMBER+63,	224}, // +675: state 219 transitions
	{gaSNUMBER+190,	279},
	{gaSNUMBER+63,	224}, // +677: state 220 transitions
	{gaSNUMBER+178,	280},
	{gaSNUMBER+125,	222}, // +679: state 221 transitions
	{gaSNUMBER+63,	224}, // +680: state 222 transitions
	{gaSNUMBER+190,	281},
	{gaSNUMBER+241,	224}, // +682: state 223 transitions
	{gaSNUMBER+40,	229}, // +683: state 224 transitions
	{gaSNUMBER+244,	224}, // +684: state 225 transitions
	{gaSNUMBER+63,	224}, // +685: state 226 transitions
	{gaSNUMBER+121,	282},
	{gaSNUMBER+184,	220}, // +687: state 227 transitions
	{gaSNUMBER+63,	47}, // +688: state 228 transitions
	{gaSNUMBER+42,	200},
	{gaSNUMBER+40,	229},
	{gaSNUMBER+5,	2}, // +691: state 229 transitions
	{gaSNUMBER+42,	85},
	{gaSNUMBER+13,	283}, // +693: state 230 transitions
	{gaSNUMBER+247,	284},
	{gaSNUMBER+19,	285},
	{gaSNUMBER+21,	286},
	{gaSNUMBER+147,	287},
	{gaSNUMBER+125,	108}, // +698: state 231 transitions
	{gaSNUMBER+121,	288}, // +699: state 232 transitions
	{gaSNUMBER+228,	101}, // +700: state 233 transitions
	{gaSNUMBER+42,	289}, // +701: state 234 transitions
	{gaSNUMBER+61,	110}, // +702: state 235 transitions
	{gaSNUMBER+42,	235},
	{gaSNUMBER+56,	49}, // +704: state 236 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+42,	236},
	{gaSNUMBER+221,	176}, // +707: state 237 transitions
	{gaSNUMBER+221,	176}, // +708: state 238 transitions
	{gaSNUMBER+42,	238},
	{gaSNUMBER+42,	290}, // +710: state 239 transitions
	{gaSNUMBER+221,	176}, // +711: state 240 transitions
	{gaSNUMBER+61,	177},
	{gaSNUMBER+63,	178},
	{gaSNUMBER+42,	291},
	{gaSNUMBER+56,	49}, // +715: state 241 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+63,	51},
	{gaSNUMBER+42,	292}, // +718: state 242 transitions
	{gaSNUMBER+56,	49}, // +719: state 243 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+221,	181},
	{gaSNUMBER+42,	293},
	{gaSNUMBER+56,	24}, // +723: state 244 transitions
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+40,	53},
	{gaSNUMBER+61,	54},
	{gaSNUMBER+63,	55},
	{gaSNUMBER+221,	185}, // +729: state 245 transitions
	{gaSNUMBER+42,	294},
	{gaSNUMBER+42,	294}, // +731: state 246 transitions
	{gaSNUMBER+42,	295}, // +732: state 247 transitions
	{gaSNUMBER+178,	47}, // +733: state 248 transitions
	{gaSNUMBER+42,	250}, // +734: state 249 transitions
	{gaSNUMBER+221,	193}, // +735: state 250 transitions
	{gaSNUMBER+61,	296},
	{gaSNUMBER+63,	297},
	{gaSNUMBER+42,	298},
	{gaSNUMBER+56,	189}, // +739: state 251 transitions
	{gaSNUMBER+56,	189}, // +740: state 252 transitions
	{gaSNUMBER+42,	252},
	{gaSNUMBER+42,	299}, // +742: state 253 transitions
	{gaSNUMBER+56,	189}, // +743: state 254 transitions
	{gaSNUMBER+61,	190},
	{gaSNUMBER+63,	191},
	{gaSNUMBER+42,	300},
	{gaSNUMBER+42,	301}, // +747: state 255 transitions
	{gaSNUMBER+77,	30}, // +748: state 256 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+42,	256},
	{gaSNUMBER+125,	47}, // +751: state 257 transitions
	{gaSNUMBER+42,	168}, // +752: state 258 transitions
	{gaSNUMBER+42,	302}, // +753: state 259 transitions
	{gaSNUMBER+77,	30}, // +754: state 260 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+40,	303},
	{gaSNUMBER+42,	304},
	{gaSNUMBER+77,	30}, // +759: state 261 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+13,	133},
	{gaSNUMBER+65,	305},
	{gaSNUMBER+77,	30}, // +764: state 262 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+87,	133},
	{gaSNUMBER+83,	305},
	{gaSNUMBER+11,	306},
	{gaSNUMBER+77,	30}, // +770: state 263 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	133},
	{gaSNUMBER+11,	306},
	{gaSNUMBER+40,	23}, // +775: state 264 transitions
	{gaSNUMBER+206,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	47},
	{gaSNUMBER+210,	140},
	{gaSNUMBER+42,	307},
	{gaSNUMBER+42,	266}, // +783: state 265 transitions
	{gaSNUMBER+221,	214}, // +784: state 266 transitions
	{gaSNUMBER+61,	308},
	{gaSNUMBER+63,	309},
	{gaSNUMBER+42,	310},
	{gaSNUMBER+56,	207}, // +788: state 267 transitions
	{gaSNUMBER+56,	207}, // +789: state 268 transitions
	{gaSNUMBER+42,	268},
	{gaSNUMBER+42,	311}, // +791: state 269 transitions
	{gaSNUMBER+56,	207}, // +792: state 270 transitions
	{gaSNUMBER+61,	208},
	{gaSNUMBER+63,	209},
	{gaSNUMBER+42,	312},
	{gaSNUMBER+42,	272}, // +796: state 271 transitions
	{gaSNUMBER+56,	313}, // +797: state 272 transitions
	{gaSNUMBER+61,	314},
	{gaSNUMBER+63,	315},
	{gaSNUMBER+42,	316},
	{gaSNUMBER+42,	45}, // +801: state 273 transitions
	{gaSNUMBER+11,	47},
	{gaSNUMBER+42,	317}, // +803: state 274 transitions
	{gaSNUMBER+61,	273}, // +804: state 275 transitions
	{gaSNUMBER+63,	274},
	{gaSNUMBER+42,	318},
	{gaSNUMBER+42,	319}, // +807: state 276 transitions
	{gaSNUMBER+56,	146}, // +808: state 277 transitions
	{gaSNUMBER+61,	147},
	{gaSNUMBER+42,	277},
	{gaSNUMBER+196,	224}, // +811: state 278 transitions
	{gaSNUMBER+219,	320}, // +812: state 279 transitions
	{gaSNUMBER+151,	282}, // +813: state 280 transitions
	{gaSNUMBER+127,	321}, // +814: state 281 transitions
	{gaSNUMBER+232,	322}, // +815: state 282 transitions
	{gaSNUMBER+65,	286}, // +816: state 283 transitions
	{gaSNUMBER+42,	286}, // +817: state 284 transitions
	{gaSNUMBER+63,	323},
	{gaSNUMBER+107,	286}, // +819: state 285 transitions
	{gaSNUMBER+63,	323},
	{gaSNUMBER+63,	323}, // +821: state 286 transitions
	{gaSNUMBER+178,	324}, // +822: state 287 transitions
	{gaSNUMBER+145,	325}, // +823: state 288 transitions
	{gaSNUMBER+61,	110}, // +824: state 289 transitions
	{gaSNUMBER+63,	111},
	{gaSNUMBER+42,	326}, // +826: state 290 transitions
	{gaSNUMBER+221,	176}, // +827: state 291 transitions
	{gaSNUMBER+61,	177},
	{gaSNUMBER+42,	291},
	{gaSNUMBER+42,	327}, // +830: state 292 transitions
	{gaSNUMBER+56,	49}, // +831: state 293 transitions
	{gaSNUMBER+61,	50},
	{gaSNUMBER+221,	181},
	{gaSNUMBER+42,	236},
	{gaSNUMBER+42,	328}, // +835: state 294 transitions
	{gaSNUMBER+40,	242}, // +836: state 295 transitions
	{gaSNUMBER+42,	329},
	{gaSNUMBER+11,	330}, // +838: state 296 transitions
	{gaSNUMBER+42,	331},
	{gaSNUMBER+42,	332}, // +840: state 297 transitions
	{gaSNUMBER+221,	193}, // +841: state 298 transitions
	{gaSNUMBER+61,	296},
	{gaSNUMBER+63,	297},
	{gaSNUMBER+42,	333},
	{gaSNUMBER+42,	334}, // +845: state 299 transitions
	{gaSNUMBER+56,	189}, // +846: state 300 transitions
	{gaSNUMBER+61,	190},
	{gaSNUMBER+42,	300},
	{gaSNUMBER+77,	30}, // +849: state 301 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	335}, // +852: state 302 transitions
	{gaSNUMBER+42,	336}, // +853: state 303 transitions
	{gaSNUMBER+77,	30}, // +854: state 304 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	256},
	{gaSNUMBER+40,	337},
	{gaSNUMBER+77,	30}, // +859: state 305 transitions
	{gaSNUMBER+61,	131},
	{gaSNUMBER+63,	132},
	{gaSNUMBER+42,	196},
	{gaSNUMBER+11,	306},
	{gaSNUMBER+21,	47}, // +864: state 306 transitions
	{gaSNUMBER+13,	338},
	{gaSNUMBER+247,	339},
	{gaSNUMBER+19,	340},
	{gaSNUMBER+40,	23}, // +868: state 307 transitions
	{gaSNUMBER+56,	24},
	{gaSNUMBER+61,	25},
	{gaSNUMBER+77,	30},
	{gaSNUMBER+81,	31},
	{gaSNUMBER+63,	47},
	{gaSNUMBER+42,	307},
	{gaSNUMBER+11,	341}, // +875: state 308 transitions
	{gaSNUMBER+42,	342},
	{gaSNUMBER+42,	343}, // +877: state 309 transitions
	{gaSNUMBER+221,	214}, // +878: state 310 transitions
	{gaSNUMBER+61,	308},
	{gaSNUMBER+63,	309},
	{gaSNUMBER+42,	344},
	{gaSNUMBER+42,	345}, // +882: state 311 transitions
	{gaSNUMBER+56,	207}, // +883: state 312 transitions
	{gaSNUMBER+61,	208},
	{gaSNUMBER+42,	312},
	{gaSNUMBER+53,	346}, // +886: state 313 transitions
	{gaSNUMBER+42,	347},
	{gaSNUMBER+11,	348}, // +888: state 314 transitions
	{gaSNUMBER+42,	349},
	{gaSNUMBER+42,	350}, // +890: state 315 transitions
	{gaSNUMBER+56,	313}, // +891: state 316 transitions
	{gaSNUMBER+61,	314},
	{gaSNUMBER+63,	315},
	{gaSNUMBER+42,	351},
	{gaSNUMBER+42,	352}, // +895: state 317 transitions
	{gaSNUMBER+61,	273}, // +896: state 318 transitions
	{gaSNUMBER+63,	274},
	{gaSNUMBER+42,	353},
	{gaSNUMBER+56,	146}, // +899: state 319 transitions
	{gaSNUMBER+61,	147},
	{gaSNUMBER+63,	148},
	{gaSNUMBER+184,	224}, // +902: state 320 transitions
	{gaSNUMBER+125,	224}, // +903: state 321 transitions
	{gaSNUMBER+178,	321}, // +904: state 322 transitions
	{gaSNUMBER+40,	86}, // +905: state 323 transitions
	{gaSNUMBER+110,	224},
	{gaSNUMBER+13,	354},
	{gaSNUMBER+15,	355},
	{gaSNUMBER+180,	356}, // +909: state 324 transitions
	{gaSNUMBER+201,	101}, // +910: state 325 transitions
	{gaSNUMBER+221,	176}, // +911: state 326 transitions
	{gaSNUMBER+61,	177},
	{gaSNUMBER+63,	178},
	{gaSNUMBER+40,	303}, // +914: state 327 transitions
	{gaSNUMBER+42,	357},
	{gaSNUMBER+221,	181}, // +916: state 328 transitions
	{gaSNUMBER+42,	358},
	{gaSNUMBER+40,	242}, // +918: state 329 transitions
	{gaSNUMBER+42,	359},
	{gaSNUMBER+221,	193}, // +920: state 330 transitions
	{gaSNUMBER+221,	193}, // +921: state 331 transitions
	{gaSNUMBER+42,	331},
	{gaSNUMBER+42,	360}, // +923: state 332 transitions
	{gaSNUMBER+221,	193}, // +924: state 333 transitions
	{gaSNUMBER+61,	296},
	{gaSNUMBER+63,	297},
	{gaSNUMBER+42,	361},
	{gaSNUMBER+56,	189}, // +928: state 334 transitions
	{gaSNUMBER+61,	190},
	{gaSNUMBER+63,	191},
	{gaSNUMBER+40,	362}, // +931: state 335 transitions
	{gaSNUMBER+42,	363}, // +932: state 336 transitions
	{gaSNUMBER+42,	336}, // +933: state 337 transitions
	{gaSNUMBER+11,	364},
	{gaSNUMBER+65,	47}, // +935: state 338 transitions
	{gaSNUMBER+42,	47}, // +936: state 339 transitions
	{gaSNUMBER+107,	47}, // +937: state 340 transitions
	{gaSNUMBER+221,	214}, // +938: state 341 transitions
	{gaSNUMBER+221,	214}, // +939: state 342 transitions
	{gaSNUMBER+42,	342},
	{gaSNUMBER+42,	365}, // +941: state 343 transitions
	{gaSNUMBER+221,	214}, // +942: state 344 transitions
	{gaSNUMBER+61,	308},
	{gaSNUMBER+63,	309},
	{gaSNUMBER+42,	366},
	{gaSNUMBER+56,	207}, // +946: state 345 transitions
	{gaSNUMBER+61,	208},
	{gaSNUMBER+63,	209},
	{gaSNUMBER+42,	347}, // +949: state 346 transitions
	{gaSNUMBER+221,	47}, // +950: state 347 transitions
	{gaSNUMBER+61,	367},
	{gaSNUMBER+63,	368},
	{gaSNUMBER+42,	369},
	{gaSNUMBER+56,	313}, // +954: state 348 transitions
	{gaSNUMBER+56,	313}, // +955: state 349 transitions
	{gaSNUMBER+42,	349},
	{gaSNUMBER+42,	370}, // +957: state 350 transitions
	{gaSNUMBER+56,	313}, // +958: state 351 transitions
	{gaSNUMBER+61,	314},
	{gaSNUMBER+63,	315},
	{gaSNUMBER+42,	371},
	{gaSNUMBER+42,	372}, // +962: state 352 transitions
	{gaSNUMBER+61,	273}, // +963: state 353 transitions
	{gaSNUMBER+42,	353},
	{gaSNUMBER+65,	224}, // +965: state 354 transitions
	{gaSNUMBER+83,	224}, // +966: state 355 transitions
	{gaSNUMBER+40,	229},
	{gaSNUMBER+40,	373}, // +968: state 356 transitions
	{gaSNUMBER+40,	337}, // +969: state 357 transitions
	{gaSNUMBER+221,	181}, // +970: state 358 transitions
	{gaSNUMBER+42,	374},
	{gaSNUMBER+42,	181}, // +972: state 359 transitions
	{gaSNUMBER+40,	242},
	{gaSNUMBER+42,	375}, // +974: state 360 transitions
	{gaSNUMBER+221,	193}, // +975: state 361 transitions
	{gaSNUMBER+61,	296},
	{gaSNUMBER+42,	361},
	{gaSNUMBER+11,	364}, // +978: state 362 transitions
	{gaSNUMBER+40,	376}, // +979: state 363 transitions
	{gaSNUMBER+40,	377}, // +980: state 364 transitions
	{gaSNUMBER+42,	378}, // +981: state 365 transitions
	{gaSNUMBER+221,	214}, // +982: state 366 transitions
	{gaSNUMBER+61,	308},
	{gaSNUMBER+42,	366},
	{gaSNUMBER+11,	379}, // +985: state 367 transitions
	{gaSNUMBER+42,	380},
	{gaSNUMBER+42,	381}, // +987: state 368 transitions
	{gaSNUMBER+221,	47}, // +988: state 369 transitions
	{gaSNUMBER+61,	367},
	{gaSNUMBER+63,	368},
	{gaSNUMBER+42,	382},
	{gaSNUMBER+42,	383}, // +992: state 370 transitions
	{gaSNUMBER+56,	313}, // +993: state 371 transitions
	{gaSNUMBER+61,	314},
	{gaSNUMBER+42,	371},
	{gaSNUMBER+61,	273}, // +996: state 372 transitions
	{gaSNUMBER+63,	274},
	{gaSNUMBER+13,	384}, // +998: state 373 transitions
	{gaSNUMBER+247,	385},
	{gaSNUMBER+19,	386},
	{gaSNUMBER+21,	387},
	{gaSNUMBER+221,	181}, // +1002: state 374 transitions
	{gaSNUMBER+42,	388},
	{gaSNUMBER+221,	193}, // +1004: state 375 transitions
	{gaSNUMBER+61,	296},
	{gaSNUMBER+63,	297},
	{gaSNUMBER+11,	364}, // +1007: state 376 transitions
	{gaSNUMBER+42,	389},
	{gaSNUMBER+42,	390}, // +1009: state 377 transitions
	{gaSNUMBER+221,	214}, // +1010: state 378 transitions
	{gaSNUMBER+61,	308},
	{gaSNUMBER+63,	309},
	{gaSNUMBER+221,	47}, // +1013: state 379 transitions
	{gaSNUMBER+221,	47}, // +1014: state 380 transitions
	{gaSNUMBER+42,	380},
	{gaSNUMBER+42,	391}, // +1016: state 381 transitions
	{gaSNUMBER+221,	47}, // +1017: state 382 transitions
	{gaSNUMBER+61,	367},
	{gaSNUMBER+63,	368},
	{gaSNUMBER+42,	392},
	{gaSNUMBER+56,	313}, // +1021: state 383 transitions
	{gaSNUMBER+61,	314},
	{gaSNUMBER+63,	315},
	{gaSNUMBER+65,	387}, // +1024: state 384 transitions
	{gaSNUMBER+63,	86}, // +1025: state 385 transitions
	{gaSNUMBER+42,	387},
	{gaSNUMBER+63,	86}, // +1027: state 386 transitions
	{gaSNUMBER+107,	387},
	{gaSNUMBER+63,	86}, // +1029: state 387 transitions
	{gaSNUMBER+221,	181}, // +1030: state 388 transitions
	{gaSNUMBER+42,	393}, // +1031: state 389 transitions
	{gaSNUMBER+42,	339}, // +1032: state 390 transitions
	{gaSNUMBER+42,	394}, // +1033: state 391 transitions
	{gaSNUMBER+221,	47}, // +1034: state 392 transitions
	{gaSNUMBER+61,	367},
	{gaSNUMBER+42,	392},
	{gaSNUMBER+40,	395}, // +1037: state 393 transitions
	{gaSNUMBER+221,	47}, // +1038: state 394 transitions
	{gaSNUMBER+61,	367},
	{gaSNUMBER+63,	368},
	{gaSNUMBER+42,	302}, // +1041: state 395 transitions
	{gaSNUMBER+11,	364},
};

const STATE_DESCRIPTION aStateDescNUMBER[396] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 16, gaTNUMBER+0},
	/*   1 */ {0, 1, gaTNUMBER+16},
	/*   2 */ {0, 1, gaTNUMBER+17},
	/*   3 */ {0, 2, gaTNUMBER+18},
	/*   4 */ {0, 1, gaTNUMBER+20},
	/*   5 */ {0, 1, gaTNUMBER+21},
	/*   6 */ {1, 9, gaTNUMBER+22},
	/*   7 */ {1, 9, gaTNUMBER+31},
	/*   8 */ {1, 9, gaTNUMBER+40},
	/*   9 */ {1, 9, gaTNUMBER+49},
	/*  10 */ {1, 8, gaTNUMBER+58},
	/*  11 */ {0, 3, gaTNUMBER+66},
	/*  12 */ {0, 1, gaTNUMBER+69},
	/*  13 */ {0, 1, gaTNUMBER+70},
	/*  14 */ {0, 2, gaTNUMBER+71},
	/*  15 */ {0, 2, gaTNUMBER+73},
	/*  16 */ {0, 1, gaTNUMBER+75},
	/*  17 */ {0, 1, gaTNUMBER+76},
	/*  18 */ {0, 1, gaTNUMBER+77},
	/*  19 */ {0, 1, gaTNUMBER+78},
	/*  20 */ {0, 4, gaTNUMBER+79},
	/*  21 */ {1, 7, gaTNUMBER+83},
	/*  22 */ {1, 7, gaTNUMBER+90},
	/*  23 */ {0, 11, gaTNUMBER+97},
	/*  24 */ {0, 3, gaTNUMBER+108},
	/*  25 */ {0, 2, gaTNUMBER+111},
	/*  26 */ {1, 2, gaTNUMBER+113},
	/*  27 */ {1, 8, gaTNUMBER+115},
	/*  28 */ {1, 8, gaTNUMBER+123},
	/*  29 */ {0, 2, gaTNUMBER+131},
	/*  30 */ {0, 3, gaTNUMBER+133},
	/*  31 */ {0, 1, gaTNUMBER+136},
	/*  32 */ {0, 13, gaTNUMBER+137},
	/*  33 */ {1, 13, gaTNUMBER+150},
	/*  34 */ {1, 8, gaTNUMBER+163},
	/*  35 */ {1, 7, gaTNUMBER+171},
	/*  36 */ {1, 7, gaTNUMBER+178},
	/*  37 */ {0, 2, gaTNUMBER+185},
	/*  38 */ {0, 2, gaTNUMBER+187},
	/*  39 */ {0, 1, gaTNUMBER+189},
	/*  40 */ {0, 2, gaTNUMBER+190},
	/*  41 */ {0, 2, gaTNUMBER+192},
	/*  42 */ {0, 2, gaTNUMBER+194},
	/*  43 */ {0, 2, gaTNUMBER+196},
	/*  44 */ {0, 2, gaTNUMBER+198},
	/*  45 */ {1, 1, gaTNUMBER+200},
	/*  46 */ {1, 3, gaTNUMBER+201},
	/*  47 */ {1, 0, NULL},
	/*  48 */ {0, 4, gaTNUMBER+204},
	/*  49 */ {0, 2, gaTNUMBER+208},
	/*  50 */ {0, 2, gaTNUMBER+210},
	/*  51 */ {0, 1, gaTNUMBER+212},
	/*  52 */ {0, 4, gaTNUMBER+213},
	/*  53 */ {0, 9, gaTNUMBER+217},
	/*  54 */ {0, 2, gaTNUMBER+226},
	/*  55 */ {0, 1, gaTNUMBER+228},
	/*  56 */ {1, 7, gaTNUMBER+229},
	/*  57 */ {1, 7, gaTNUMBER+236},
	/*  58 */ {0, 1, gaTNUMBER+243},
	/*  59 */ {0, 1, gaTNUMBER+244},
	/*  60 */ {0, 1, gaTNUMBER+245},
	/*  61 */ {0, 1, gaTNUMBER+246},
	/*  62 */ {0, 1, gaTNUMBER+247},
	/*  63 */ {0, 1, gaTNUMBER+248},
	/*  64 */ {0, 1, gaTNUMBER+249},
	/*  65 */ {0, 1, gaTNUMBER+250},
	/*  66 */ {0, 1, gaTNUMBER+251},
	/*  67 */ {1, 2, gaTNUMBER+252},
	/*  68 */ {0, 2, gaTNUMBER+254},
	/*  69 */ {0, 1, gaTNUMBER+256},
	/*  70 */ {1, 4, gaTNUMBER+257},
	/*  71 */ {1, 4, gaTNUMBER+261},
	/*  72 */ {1, 5, gaTNUMBER+265},
	/*  73 */ {1, 4, gaTNUMBER+270},
	/*  74 */ {1, 4, gaTNUMBER+274},
	/*  75 */ {0, 12, gaTNUMBER+278},
	/*  76 */ {1, 8, gaTNUMBER+290},
	/*  77 */ {0, 13, gaTNUMBER+298},
	/*  78 */ {1, 8, gaTNUMBER+311},
	/*  79 */ {1, 4, gaTNUMBER+319},
	/*  80 */ {1, 3, gaTNUMBER+323},
	/*  81 */ {0, 2, gaTNUMBER+326},
	/*  82 */ {0, 1, gaTNUMBER+328},
	/*  83 */ {1, 4, gaTNUMBER+329},
	/*  84 */ {0, 1, gaTNUMBER+333},
	/*  85 */ {0, 1, gaTNUMBER+334},
	/*  86 */ {0, 8, gaTNUMBER+335},
	/*  87 */ {1, 5, gaTNUMBER+343},
	/*  88 */ {1, 6, gaTNUMBER+348},
	/*  89 */ {1, 5, gaTNUMBER+354},
	/*  90 */ {1, 5, gaTNUMBER+359},
	/*  91 */ {0, 2, gaTNUMBER+364},
	/*  92 */ {0, 1, gaTNUMBER+366},
	/*  93 */ {0, 1, gaTNUMBER+367},
	/*  94 */ {0, 2, gaTNUMBER+368},
	/*  95 */ {0, 2, gaTNUMBER+370},
	/*  96 */ {0, 1, gaTNUMBER+372},
	/*  97 */ {0, 1, gaTNUMBER+373},
	/*  98 */ {0, 1, gaTNUMBER+374},
	/*  99 */ {1, 12, gaTNUMBER+375},
	/* 100 */ {1, 1, gaTNUMBER+387},
	/* 101 */ {0, 1, gaTNUMBER+388},
	/* 102 */ {0, 1, gaTNUMBER+389},
	/* 103 */ {0, 1, gaTNUMBER+390},
	/* 104 */ {0, 2, gaTNUMBER+391},
	/* 105 */ {0, 1, gaTNUMBER+393},
	/* 106 */ {0, 1, gaTNUMBER+394},
	/* 107 */ {0, 1, gaTNUMBER+395},
	/* 108 */ {0, 1, gaTNUMBER+396},
	/* 109 */ {0, 1, gaTNUMBER+397},
	/* 110 */ {0, 2, gaTNUMBER+398},
	/* 111 */ {0, 1, gaTNUMBER+400},
	/* 112 */ {1, 3, gaTNUMBER+401},
	/* 113 */ {0, 4, gaTNUMBER+404},
	/* 114 */ {0, 1, gaTNUMBER+408},
	/* 115 */ {0, 4, gaTNUMBER+409},
	/* 116 */ {0, 1, gaTNUMBER+413},
	/* 117 */ {0, 2, gaTNUMBER+414},
	/* 118 */ {0, 1, gaTNUMBER+416},
	/* 119 */ {0, 5, gaTNUMBER+417},
	/* 120 */ {1, 4, gaTNUMBER+422},
	/* 121 */ {1, 5, gaTNUMBER+426},
	/* 122 */ {0, 1, gaTNUMBER+431},
	/* 123 */ {0, 11, gaTNUMBER+432},
	/* 124 */ {1, 7, gaTNUMBER+443},
	/* 125 */ {0, 1, gaTNUMBER+450},
	/* 126 */ {0, 1, gaTNUMBER+451},
	/* 127 */ {0, 1, gaTNUMBER+452},
	/* 128 */ {0, 1, gaTNUMBER+453},
	/* 129 */ {0, 1, gaTNUMBER+454},
	/* 130 */ {0, 4, gaTNUMBER+455},
	/* 131 */ {0, 2, gaTNUMBER+459},
	/* 132 */ {0, 1, gaTNUMBER+461},
	/* 133 */ {1, 4, gaTNUMBER+462},
	/* 134 */ {1, 5, gaTNUMBER+466},
	/* 135 */ {0, 1, gaTNUMBER+471},
	/* 136 */ {0, 2, gaTNUMBER+472},
	/* 137 */ {1, 4, gaTNUMBER+474},
	/* 138 */ {0, 1, gaTNUMBER+478},
	/* 139 */ {0, 1, gaTNUMBER+479},
	/* 140 */ {0, 3, gaTNUMBER+480},
	/* 141 */ {1, 9, gaTNUMBER+483},
	/* 142 */ {0, 1, gaTNUMBER+492},
	/* 143 */ {1, 9, gaTNUMBER+493},
	/* 144 */ {0, 1, gaTNUMBER+502},
	/* 145 */ {0, 4, gaTNUMBER+503},
	/* 146 */ {0, 3, gaTNUMBER+507},
	/* 147 */ {0, 2, gaTNUMBER+510},
	/* 148 */ {0, 1, gaTNUMBER+512},
	/* 149 */ {1, 4, gaTNUMBER+513},
	/* 150 */ {1, 1, gaTNUMBER+517},
	/* 151 */ {1, 5, gaTNUMBER+518},
	/* 152 */ {0, 3, gaTNUMBER+523},
	/* 153 */ {1, 2, gaTNUMBER+526},
	/* 154 */ {0, 1, gaTNUMBER+528},
	/* 155 */ {0, 1, gaTNUMBER+529},
	/* 156 */ {0, 1, gaTNUMBER+530},
	/* 157 */ {0, 1, gaTNUMBER+531},
	/* 158 */ {0, 1, gaTNUMBER+532},
	/* 159 */ {0, 1, gaTNUMBER+533},
	/* 160 */ {0, 1, gaTNUMBER+534},
	/* 161 */ {0, 1, gaTNUMBER+535},
	/* 162 */ {0, 1, gaTNUMBER+536},
	/* 163 */ {0, 1, gaTNUMBER+537},
	/* 164 */ {0, 1, gaTNUMBER+538},
	/* 165 */ {0, 2, gaTNUMBER+539},
	/* 166 */ {1, 4, gaTNUMBER+541},
	/* 167 */ {1, 3, gaTNUMBER+545},
	/* 168 */ {0, 1, gaTNUMBER+548},
	/* 169 */ {0, 1, gaTNUMBER+549},
	/* 170 */ {0, 1, gaTNUMBER+550},
	/* 171 */ {0, 1, gaTNUMBER+551},
	/* 172 */ {0, 1, gaTNUMBER+552},
	/* 173 */ {0, 1, gaTNUMBER+553},
	/* 174 */ {1, 3, gaTNUMBER+554},
	/* 175 */ {0, 4, gaTNUMBER+557},
	/* 176 */ {1, 2, gaTNUMBER+561},
	/* 177 */ {0, 2, gaTNUMBER+563},
	/* 178 */ {0, 1, gaTNUMBER+565},
	/* 179 */ {0, 4, gaTNUMBER+566},
	/* 180 */ {0, 1, gaTNUMBER+570},
	/* 181 */ {0, 1, gaTNUMBER+571},
	/* 182 */ {0, 4, gaTNUMBER+572},
	/* 183 */ {0, 1, gaTNUMBER+576},
	/* 184 */ {0, 2, gaTNUMBER+577},
	/* 185 */ {0, 1, gaTNUMBER+579},
	/* 186 */ {1, 6, gaTNUMBER+580},
	/* 187 */ {1, 1, gaTNUMBER+586},
	/* 188 */ {0, 1, gaTNUMBER+587},
	/* 189 */ {0, 2, gaTNUMBER+588},
	/* 190 */ {0, 2, gaTNUMBER+590},
	/* 191 */ {0, 1, gaTNUMBER+592},
	/* 192 */ {0, 4, gaTNUMBER+593},
	/* 193 */ {1, 1, gaTNUMBER+597},
	/* 194 */ {1, 2, gaTNUMBER+598},
	/* 195 */ {0, 1, gaTNUMBER+600},
	/* 196 */ {1, 4, gaTNUMBER+601},
	/* 197 */ {0, 1, gaTNUMBER+605},
	/* 198 */ {1, 3, gaTNUMBER+606},
	/* 199 */ {1, 2, gaTNUMBER+609},
	/* 200 */ {1, 6, gaTNUMBER+611},
	/* 201 */ {0, 1, gaTNUMBER+617},
	/* 202 */ {1, 4, gaTNUMBER+618},
	/* 203 */ {0, 13, gaTNUMBER+622},
	/* 204 */ {0, 5, gaTNUMBER+635},
	/* 205 */ {1, 8, gaTNUMBER+640},
	/* 206 */ {1, 2, gaTNUMBER+648},
	/* 207 */ {0, 2, gaTNUMBER+650},
	/* 208 */ {0, 2, gaTNUMBER+652},
	/* 209 */ {0, 1, gaTNUMBER+654},
	/* 210 */ {0, 4, gaTNUMBER+655},
	/* 211 */ {0, 2, gaTNUMBER+659},
	/* 212 */ {0, 1, gaTNUMBER+661},
	/* 213 */ {1, 3, gaTNUMBER+662},
	/* 214 */ {1, 1, gaTNUMBER+665},
	/* 215 */ {1, 2, gaTNUMBER+666},
	/* 216 */ {0, 1, gaTNUMBER+668},
	/* 217 */ {1, 4, gaTNUMBER+669},
	/* 218 */ {0, 2, gaTNUMBER+673},
	/* 219 */ {0, 2, gaTNUMBER+675},
	/* 220 */ {0, 2, gaTNUMBER+677},
	/* 221 */ {0, 1, gaTNUMBER+679},
	/* 222 */ {0, 2, gaTNUMBER+680},
	/* 223 */ {0, 1, gaTNUMBER+682},
	/* 224 */ {1, 1, gaTNUMBER+683},
	/* 225 */ {0, 1, gaTNUMBER+684},
	/* 226 */ {0, 2, gaTNUMBER+685},
	/* 227 */ {0, 1, gaTNUMBER+687},
	/* 228 */ {1, 3, gaTNUMBER+688},
	/* 229 */ {0, 2, gaTNUMBER+691},
	/* 230 */ {0, 5, gaTNUMBER+693},
	/* 231 */ {0, 1, gaTNUMBER+698},
	/* 232 */ {0, 1, gaTNUMBER+699},
	/* 233 */ {0, 1, gaTNUMBER+700},
	/* 234 */ {0, 1, gaTNUMBER+701},
	/* 235 */ {1, 2, gaTNUMBER+702},
	/* 236 */ {0, 3, gaTNUMBER+704},
	/* 237 */ {0, 1, gaTNUMBER+707},
	/* 238 */ {0, 2, gaTNUMBER+708},
	/* 239 */ {0, 1, gaTNUMBER+710},
	/* 240 */ {0, 4, gaTNUMBER+711},
	/* 241 */ {0, 3, gaTNUMBER+715},
	/* 242 */ {0, 1, gaTNUMBER+718},
	/* 243 */ {0, 4, gaTNUMBER+719},
	/* 244 */ {1, 6, gaTNUMBER+723},
	/* 245 */ {0, 2, gaTNUMBER+729},
	/* 246 */ {0, 1, gaTNUMBER+731},
	/* 247 */ {0, 1, gaTNUMBER+732},
	/* 248 */ {0, 1, gaTNUMBER+733},
	/* 249 */ {0, 1, gaTNUMBER+734},
	/* 250 */ {0, 4, gaTNUMBER+735},
	/* 251 */ {0, 1, gaTNUMBER+739},
	/* 252 */ {0, 2, gaTNUMBER+740},
	/* 253 */ {0, 1, gaTNUMBER+742},
	/* 254 */ {0, 4, gaTNUMBER+743},
	/* 255 */ {0, 1, gaTNUMBER+747},
	/* 256 */ {1, 3, gaTNUMBER+748},
	/* 257 */ {0, 1, gaTNUMBER+751},
	/* 258 */ {0, 1, gaTNUMBER+752},
	/* 259 */ {0, 1, gaTNUMBER+753},
	/* 260 */ {1, 5, gaTNUMBER+754},
	/* 261 */ {1, 5, gaTNUMBER+759},
	/* 262 */ {1, 6, gaTNUMBER+764},
	/* 263 */ {1, 5, gaTNUMBER+770},
	/* 264 */ {1, 8, gaTNUMBER+775},
	/* 265 */ {0, 1, gaTNUMBER+783},
	/* 266 */ {0, 4, gaTNUMBER+784},
	/* 267 */ {0, 1, gaTNUMBER+788},
	/* 268 */ {0, 2, gaTNUMBER+789},
	/* 269 */ {0, 1, gaTNUMBER+791},
	/* 270 */ {0, 4, gaTNUMBER+792},
	/* 271 */ {0, 1, gaTNUMBER+796},
	/* 272 */ {0, 4, gaTNUMBER+797},
	/* 273 */ {0, 2, gaTNUMBER+801},
	/* 274 */ {0, 1, gaTNUMBER+803},
	/* 275 */ {1, 3, gaTNUMBER+804},
	/* 276 */ {0, 1, gaTNUMBER+807},
	/* 277 */ {1, 3, gaTNUMBER+808},
	/* 278 */ {0, 1, gaTNUMBER+811},
	/* 279 */ {0, 1, gaTNUMBER+812},
	/* 280 */ {0, 1, gaTNUMBER+813},
	/* 281 */ {0, 1, gaTNUMBER+814},
	/* 282 */ {0, 1, gaTNUMBER+815},
	/* 283 */ {0, 1, gaTNUMBER+816},
	/* 284 */ {0, 2, gaTNUMBER+817},
	/* 285 */ {0, 2, gaTNUMBER+819},
	/* 286 */ {0, 1, gaTNUMBER+821},
	/* 287 */ {0, 1, gaTNUMBER+822},
	/* 288 */ {0, 1, gaTNUMBER+823},
	/* 289 */ {1, 2, gaTNUMBER+824},
	/* 290 */ {0, 1, gaTNUMBER+826},
	/* 291 */ {0, 3, gaTNUMBER+827},
	/* 292 */ {0, 1, gaTNUMBER+830},
	/* 293 */ {0, 4, gaTNUMBER+831},
	/* 294 */ {0, 1, gaTNUMBER+835},
	/* 295 */ {0, 2, gaTNUMBER+836},
	/* 296 */ {0, 2, gaTNUMBER+838},
	/* 297 */ {0, 1, gaTNUMBER+840},
	/* 298 */ {0, 4, gaTNUMBER+841},
	/* 299 */ {0, 1, gaTNUMBER+845},
	/* 300 */ {0, 3, gaTNUMBER+846},
	/* 301 */ {1, 3, gaTNUMBER+849},
	/* 302 */ {0, 1, gaTNUMBER+852},
	/* 303 */ {0, 1, gaTNUMBER+853},
	/* 304 */ {1, 5, gaTNUMBER+854},
	/* 305 */ {1, 5, gaTNUMBER+859},
	/* 306 */ {0, 4, gaTNUMBER+864},
	/* 307 */ {1, 7, gaTNUMBER+868},
	/* 308 */ {0, 2, gaTNUMBER+875},
	/* 309 */ {0, 1, gaTNUMBER+877},
	/* 310 */ {0, 4, gaTNUMBER+878},
	/* 311 */ {0, 1, gaTNUMBER+882},
	/* 312 */ {0, 3, gaTNUMBER+883},
	/* 313 */ {0, 2, gaTNUMBER+886},
	/* 314 */ {0, 2, gaTNUMBER+888},
	/* 315 */ {0, 1, gaTNUMBER+890},
	/* 316 */ {0, 4, gaTNUMBER+891},
	/* 317 */ {0, 1, gaTNUMBER+895},
	/* 318 */ {1, 3, gaTNUMBER+896},
	/* 319 */ {1, 3, gaTNUMBER+899},
	/* 320 */ {0, 1, gaTNUMBER+902},
	/* 321 */ {0, 1, gaTNUMBER+903},
	/* 322 */ {0, 1, gaTNUMBER+904},
	/* 323 */ {0, 4, gaTNUMBER+905},
	/* 324 */ {0, 1, gaTNUMBER+909},
	/* 325 */ {0, 1, gaTNUMBER+910},
	/* 326 */ {0, 3, gaTNUMBER+911},
	/* 327 */ {0, 2, gaTNUMBER+914},
	/* 328 */ {0, 2, gaTNUMBER+916},
	/* 329 */ {0, 2, gaTNUMBER+918},
	/* 330 */ {0, 1, gaTNUMBER+920},
	/* 331 */ {0, 2, gaTNUMBER+921},
	/* 332 */ {0, 1, gaTNUMBER+923},
	/* 333 */ {0, 4, gaTNUMBER+924},
	/* 334 */ {0, 3, gaTNUMBER+928},
	/* 335 */ {1, 1, gaTNUMBER+931},
	/* 336 */ {0, 1, gaTNUMBER+932},
	/* 337 */ {0, 2, gaTNUMBER+933},
	/* 338 */ {0, 1, gaTNUMBER+935},
	/* 339 */ {1, 1, gaTNUMBER+936},
	/* 340 */ {1, 1, gaTNUMBER+937},
	/* 341 */ {0, 1, gaTNUMBER+938},
	/* 342 */ {0, 2, gaTNUMBER+939},
	/* 343 */ {0, 1, gaTNUMBER+941},
	/* 344 */ {0, 4, gaTNUMBER+942},
	/* 345 */ {0, 3, gaTNUMBER+946},
	/* 346 */ {0, 1, gaTNUMBER+949},
	/* 347 */ {0, 4, gaTNUMBER+950},
	/* 348 */ {0, 1, gaTNUMBER+954},
	/* 349 */ {0, 2, gaTNUMBER+955},
	/* 350 */ {0, 1, gaTNUMBER+957},
	/* 351 */ {0, 4, gaTNUMBER+958},
	/* 352 */ {0, 1, gaTNUMBER+962},
	/* 353 */ {1, 2, gaTNUMBER+963},
	/* 354 */ {0, 1, gaTNUMBER+965},
	/* 355 */ {1, 2, gaTNUMBER+966},
	/* 356 */ {0, 1, gaTNUMBER+968},
	/* 357 */ {1, 1, gaTNUMBER+969},
	/* 358 */ {0, 2, gaTNUMBER+970},
	/* 359 */ {0, 2, gaTNUMBER+972},
	/* 360 */ {0, 1, gaTNUMBER+974},
	/* 361 */ {0, 3, gaTNUMBER+975},
	/* 362 */ {0, 1, gaTNUMBER+978},
	/* 363 */ {1, 1, gaTNUMBER+979},
	/* 364 */ {0, 1, gaTNUMBER+980},
	/* 365 */ {0, 1, gaTNUMBER+981},
	/* 366 */ {0, 3, gaTNUMBER+982},
	/* 367 */ {0, 2, gaTNUMBER+985},
	/* 368 */ {0, 1, gaTNUMBER+987},
	/* 369 */ {0, 4, gaTNUMBER+988},
	/* 370 */ {0, 1, gaTNUMBER+992},
	/* 371 */ {0, 3, gaTNUMBER+993},
	/* 372 */ {1, 2, gaTNUMBER+996},
	/* 373 */ {0, 4, gaTNUMBER+998},
	/* 374 */ {0, 2, gaTNUMBER+1002},
	/* 375 */ {0, 3, gaTNUMBER+1004},
	/* 376 */ {0, 2, gaTNUMBER+1007},
	/* 377 */ {0, 1, gaTNUMBER+1009},
	/* 378 */ {0, 3, gaTNUMBER+1010},
	/* 379 */ {0, 1, gaTNUMBER+1013},
	/* 380 */ {0, 2, gaTNUMBER+1014},
	/* 381 */ {0, 1, gaTNUMBER+1016},
	/* 382 */ {0, 4, gaTNUMBER+1017},
	/* 383 */ {0, 3, gaTNUMBER+1021},
	/* 384 */ {0, 1, gaTNUMBER+1024},
	/* 385 */ {0, 2, gaTNUMBER+1025},
	/* 386 */ {0, 2, gaTNUMBER+1027},
	/* 387 */ {0, 1, gaTNUMBER+1029},
	/* 388 */ {0, 1, gaTNUMBER+1030},
	/* 389 */ {0, 1, gaTNUMBER+1031},
	/* 390 */ {1, 1, gaTNUMBER+1032},
	/* 391 */ {0, 1, gaTNUMBER+1033},
	/* 392 */ {0, 3, gaTNUMBER+1034},
	/* 393 */ {1, 1, gaTNUMBER+1037},
	/* 394 */ {0, 3, gaTNUMBER+1038},
	/* 395 */ {0, 2, gaTNUMBER+1041},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numsimple

// 13 states

static const unsigned char gaSNUMSIMPLE[] = 
	/* gaStringNUMSIMPLE+0 */	"+-\000"
	/* gaStringNUMSIMPLE+3 */	"0123456789\000"
	/* gaStringNUMSIMPLE+14 */	",\000"
	/* gaStringNUMSIMPLE+16 */	".\000"
	/* gaStringNUMSIMPLE+18 */	"-\000"
;

static const STATE_TRANSITION gaTNUMSIMPLE[] = {
	{gaSNUMSIMPLE+0,	1}, // +0: state 0 transitions
	{gaSNUMSIMPLE+3,	2},
	{gaSNUMSIMPLE+3,	2}, // +2: state 1 transitions
	{gaSNUMSIMPLE+14,	3}, // +3: state 2 transitions
	{gaSNUMSIMPLE+16,	4},
	{gaSNUMSIMPLE+3,	5},
	{gaSNUMSIMPLE+18,	6}, // +6: state 3 transitions
	{gaSNUMSIMPLE+3,	7},
	{gaSNUMSIMPLE+3,	8}, // +8: state 4 transitions
	{gaSNUMSIMPLE+14,	3}, // +9: state 5 transitions
	{gaSNUMSIMPLE+16,	4},
	{gaSNUMSIMPLE+3,	9},
	{gaSNUMSIMPLE+3,	7}, // +12: state 7 transitions
	{gaSNUMSIMPLE+3,	10}, // +13: state 8 transitions
	{gaSNUMSIMPLE+14,	3}, // +14: state 9 transitions
	{gaSNUMSIMPLE+16,	4},
	{gaSNUMSIMPLE+3,	11},
	{gaSNUMSIMPLE+3,	12}, // +17: state 10 transitions
	{gaSNUMSIMPLE+14,	3}, // +18: state 11 transitions
	{gaSNUMSIMPLE+3,	11},
	{gaSNUMSIMPLE+14,	3}, // +20: state 12 transitions
	{gaSNUMSIMPLE+16,	4},
};

const STATE_DESCRIPTION aStateDescNUMSIMPLE[13] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMSIMPLE+0},
	/*   1 */ {0, 1, gaTNUMSIMPLE+2},
	/*   2 */ {1, 3, gaTNUMSIMPLE+3},
	/*   3 */ {0, 2, gaTNUMSIMPLE+6},
	/*   4 */ {0, 1, gaTNUMSIMPLE+8},
	/*   5 */ {1, 3, gaTNUMSIMPLE+9},
	/*   6 */ {1, 0, NULL},
	/*   7 */ {1, 1, gaTNUMSIMPLE+12},
	/*   8 */ {0, 1, gaTNUMSIMPLE+13},
	/*   9 */ {1, 3, gaTNUMSIMPLE+14},
	/*  10 */ {0, 1, gaTNUMSIMPLE+17},
	/*  11 */ {1, 2, gaTNUMSIMPLE+18},
	/*  12 */ {1, 2, gaTNUMSIMPLE+20},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numnth

// 3 states

static const unsigned char gaSNUMNTH[] = 
	/* gaStringNUMNTH+0 */	"0123456789\000"
	/* gaStringNUMNTH+11 */	".\000"
;

static const STATE_TRANSITION gaTNUMNTH[] = {
	{gaSNUMNTH+0,	1}, // +0: state 0 transitions
	{gaSNUMNTH+0,	1}, // +1: state 1 transitions
	{gaSNUMNTH+11,	2},
};

const STATE_DESCRIPTION aStateDescNUMNTH[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNTH+0},
	/*   1 */ {1, 2, gaTNUMNTH+1},
	/*   2 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numunit

// 30 states

static const unsigned char gaSNUMUNIT[] = 
	/* gaStringNUMUNIT+0 */	"+-\000"
	/* gaStringNUMUNIT+3 */	"0123456789\000"
	/* gaStringNUMUNIT+14 */	" \000"
	/* gaStringNUMUNIT+16 */	",\000"
	/* gaStringNUMUNIT+18 */	".\000"
	/* gaStringNUMUNIT+20 */	"\000"
	/* gaStringNUMUNIT+22 */	"Ff\000"
	/* gaStringNUMUNIT+25 */	"K\000"
	/* gaStringNUMUNIT+27 */	"M\000"
	/* gaStringNUMUNIT+29 */	"Zz\000"
	/* gaStringNUMUNIT+32 */	"c\000"
	/* gaStringNUMUNIT+34 */	"d\000"
	/* gaStringNUMUNIT+36 */	"gl\000"
	/* gaStringNUMUNIT+39 */	"k\000"
	/* gaStringNUMUNIT+41 */	"m\000"
	/* gaStringNUMUNIT+43 */	"-\000"
	/* gaStringNUMUNIT+45 */	"u\000"
	/* gaStringNUMUNIT+47 */	"e\000"
	/* gaStringNUMUNIT+49 */	"o\000"
	/* gaStringNUMUNIT+51 */	"glm\000"
	/* gaStringNUMUNIT+55 */	"l\000"
	/* gaStringNUMUNIT+57 */	"gm\000"
	/* gaStringNUMUNIT+60 */	"CF\000"
	/* gaStringNUMUNIT+63 */	"\000"
	/* gaStringNUMUNIT+65 */	"i\000"
;

static const STATE_TRANSITION gaTNUMUNIT[] = {
	{gaSNUMUNIT+0,	1}, // +0: state 0 transitions
	{gaSNUMUNIT+3,	2},
	{gaSNUMUNIT+3,	2}, // +2: state 1 transitions
	{gaSNUMUNIT+14,	3}, // +3: state 2 transitions
	{gaSNUMUNIT+16,	4},
	{gaSNUMUNIT+18,	5},
	{gaSNUMUNIT+3,	6},
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+22,	8}, // +8: state 3 transitions
	{gaSNUMUNIT+25,	9},
	{gaSNUMUNIT+27,	10},
	{gaSNUMUNIT+29,	11},
	{gaSNUMUNIT+32,	12},
	{gaSNUMUNIT+34,	13},
	{gaSNUMUNIT+36,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+43,	17}, // +17: state 4 transitions
	{gaSNUMUNIT+3,	18},
	{gaSNUMUNIT+3,	19}, // +19: state 5 transitions
	{gaSNUMUNIT+14,	3}, // +20: state 6 transitions
	{gaSNUMUNIT+16,	4},
	{gaSNUMUNIT+18,	5},
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+3,	20},
	{gaSNUMUNIT+14,	21}, // +25: state 7 transitions
	{gaSNUMUNIT+45,	22}, // +26: state 8 transitions
	{gaSNUMUNIT+41,	14}, // +27: state 9 transitions
	{gaSNUMUNIT+47,	23}, // +28: state 10 transitions
	{gaSNUMUNIT+49,	24}, // +29: state 11 transitions
	{gaSNUMUNIT+51,	14}, // +30: state 12 transitions
	{gaSNUMUNIT+55,	14}, // +31: state 13 transitions
	{gaSNUMUNIT+57,	14}, // +32: state 15 transitions
	{gaSNUMUNIT+51,	14}, // +33: state 16 transitions
	{gaSNUMUNIT+47,	23},
	{gaSNUMUNIT+14,	3}, // +35: state 17 transitions
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+14,	3}, // +37: state 18 transitions
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+3,	18},
	{gaSNUMUNIT+3,	25}, // +40: state 19 transitions
	{gaSNUMUNIT+14,	3}, // +41: state 20 transitions
	{gaSNUMUNIT+16,	4},
	{gaSNUMUNIT+18,	5},
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+3,	26},
	{gaSNUMUNIT+60,	14}, // +46: state 21 transitions
	{gaSNUMUNIT+63,	14}, // +47: state 22 transitions
	{gaSNUMUNIT+65,	27}, // +48: state 23 transitions
	{gaSNUMUNIT+55,	13}, // +49: state 24 transitions
	{gaSNUMUNIT+3,	28}, // +50: state 25 transitions
	{gaSNUMUNIT+14,	3}, // +51: state 26 transitions
	{gaSNUMUNIT+16,	4},
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+3,	26},
	{gaSNUMUNIT+55,	29}, // +55: state 27 transitions
	{gaSNUMUNIT+14,	3}, // +56: state 28 transitions
	{gaSNUMUNIT+16,	4},
	{gaSNUMUNIT+18,	5},
	{gaSNUMUNIT+20,	7},
	{gaSNUMUNIT+47,	14}, // +60: state 29 transitions
};

const STATE_DESCRIPTION aStateDescNUMUNIT[30] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMUNIT+0},
	/*   1 */ {0, 1, gaTNUMUNIT+2},
	/*   2 */ {0, 5, gaTNUMUNIT+3},
	/*   3 */ {0, 9, gaTNUMUNIT+8},
	/*   4 */ {0, 2, gaTNUMUNIT+17},
	/*   5 */ {0, 1, gaTNUMUNIT+19},
	/*   6 */ {0, 5, gaTNUMUNIT+20},
	/*   7 */ {0, 1, gaTNUMUNIT+25},
	/*   8 */ {0, 1, gaTNUMUNIT+26},
	/*   9 */ {0, 1, gaTNUMUNIT+27},
	/*  10 */ {0, 1, gaTNUMUNIT+28},
	/*  11 */ {0, 1, gaTNUMUNIT+29},
	/*  12 */ {0, 1, gaTNUMUNIT+30},
	/*  13 */ {0, 1, gaTNUMUNIT+31},
	/*  14 */ {1, 0, NULL},
	/*  15 */ {0, 1, gaTNUMUNIT+32},
	/*  16 */ {1, 2, gaTNUMUNIT+33},
	/*  17 */ {0, 2, gaTNUMUNIT+35},
	/*  18 */ {0, 3, gaTNUMUNIT+37},
	/*  19 */ {0, 1, gaTNUMUNIT+40},
	/*  20 */ {0, 5, gaTNUMUNIT+41},
	/*  21 */ {0, 1, gaTNUMUNIT+46},
	/*  22 */ {0, 1, gaTNUMUNIT+47},
	/*  23 */ {0, 1, gaTNUMUNIT+48},
	/*  24 */ {0, 1, gaTNUMUNIT+49},
	/*  25 */ {0, 1, gaTNUMUNIT+50},
	/*  26 */ {0, 4, gaTNUMUNIT+51},
	/*  27 */ {0, 1, gaTNUMUNIT+55},
	/*  28 */ {0, 4, gaTNUMUNIT+56},
	/*  29 */ {0, 1, gaTNUMUNIT+60},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numnum

// 3 states

static const unsigned char gaSNUMNUM[] = 
	/* gaStringNUMNUM+0 */	"\000"
	/* gaStringNUMNUM+2 */	"0123456789\000"
;

static const STATE_TRANSITION gaTNUMNUM[] = {
	{gaSNUMNUM+0,	1}, // +0: state 0 transitions
	{gaSNUMNUM+2,	2}, // +1: state 1 transitions
	{gaSNUMNUM+2,	2}, // +2: state 2 transitions
};

const STATE_DESCRIPTION aStateDescNUMNUM[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNUM+0},
	/*   1 */ {0, 1, gaTNUMNUM+1},
	/*   2 */ {1, 1, gaTNUMNUM+2},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numpercent

// 15 states

static const unsigned char gaSNUMPERCENT[] = 
	/* gaStringNUMPERCENT+0 */	"+-\000"
	/* gaStringNUMPERCENT+3 */	"0123456789\000"
	/* gaStringNUMPERCENT+14 */	" \000"
	/* gaStringNUMPERCENT+16 */	",\000"
	/* gaStringNUMPERCENT+18 */	".\000"
	/* gaStringNUMPERCENT+20 */	"%\000"
	/* gaStringNUMPERCENT+22 */	"-\000"
;

static const STATE_TRANSITION gaTNUMPERCENT[] = {
	{gaSNUMPERCENT+0,	1}, // +0: state 0 transitions
	{gaSNUMPERCENT+3,	2},
	{gaSNUMPERCENT+3,	2}, // +2: state 1 transitions
	{gaSNUMPERCENT+14,	3}, // +3: state 2 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+3,	6},
	{gaSNUMPERCENT+20,	7}, // +7: state 3 transitions
	{gaSNUMPERCENT+22,	8}, // +8: state 4 transitions
	{gaSNUMPERCENT+3,	9},
	{gaSNUMPERCENT+3,	10}, // +10: state 5 transitions
	{gaSNUMPERCENT+14,	3}, // +11: state 6 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+3,	11},
	{gaSNUMPERCENT+14,	3}, // +15: state 8 transitions
	{gaSNUMPERCENT+14,	3}, // +16: state 9 transitions
	{gaSNUMPERCENT+3,	9},
	{gaSNUMPERCENT+3,	12}, // +18: state 10 transitions
	{gaSNUMPERCENT+14,	3}, // +19: state 11 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+3,	13},
	{gaSNUMPERCENT+3,	14}, // +23: state 12 transitions
	{gaSNUMPERCENT+14,	3}, // +24: state 13 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+3,	13},
	{gaSNUMPERCENT+14,	3}, // +27: state 14 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
};

const STATE_DESCRIPTION aStateDescNUMPERCENT[15] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMPERCENT+0},
	/*   1 */ {0, 1, gaTNUMPERCENT+2},
	/*   2 */ {0, 4, gaTNUMPERCENT+3},
	/*   3 */ {0, 1, gaTNUMPERCENT+7},
	/*   4 */ {0, 2, gaTNUMPERCENT+8},
	/*   5 */ {0, 1, gaTNUMPERCENT+10},
	/*   6 */ {0, 4, gaTNUMPERCENT+11},
	/*   7 */ {1, 0, NULL},
	/*   8 */ {0, 1, gaTNUMPERCENT+15},
	/*   9 */ {0, 2, gaTNUMPERCENT+16},
	/*  10 */ {0, 1, gaTNUMPERCENT+18},
	/*  11 */ {0, 4, gaTNUMPERCENT+19},
	/*  12 */ {0, 1, gaTNUMPERCENT+23},
	/*  13 */ {0, 3, gaTNUMPERCENT+24},
	/*  14 */ {0, 3, gaTNUMPERCENT+27},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numdate

// 111 states

static const unsigned char gaSNUMDATE[] = 
	/* gaStringNUMDATE+0 */	"'\000"
	/* gaStringNUMDATE+2 */	"0\000"
	/* gaStringNUMDATE+4 */	"1\000"
	/* gaStringNUMDATE+6 */	"2\000"
	/* gaStringNUMDATE+8 */	"3\000"
	/* gaStringNUMDATE+10 */	"456789\000"
	/* gaStringNUMDATE+17 */	"D\000"
	/* gaStringNUMDATE+19 */	"F\000"
	/* gaStringNUMDATE+21 */	"M\000"
	/* gaStringNUMDATE+23 */	"S\000"
	/* gaStringNUMDATE+25 */	"0123456789\000"
	/* gaStringNUMDATE+36 */	"123456789\000"
	/* gaStringNUMDATE+46 */	"012\000"
	/* gaStringNUMDATE+50 */	" \000"
	/* gaStringNUMDATE+52 */	".\000"
	/* gaStringNUMDATE+54 */	"3456789\000"
	/* gaStringNUMDATE+62 */	"23456789\000"
	/* gaStringNUMDATE+71 */	"01\000"
	/* gaStringNUMDATE+74 */	"i\000"
	/* gaStringNUMDATE+76 */	"o\000"
	/* gaStringNUMDATE+78 */	"r\000"
	/* gaStringNUMDATE+80 */	"a\000"
	/* gaStringNUMDATE+82 */	"A\000"
	/* gaStringNUMDATE+84 */	"J\000"
	/* gaStringNUMDATE+86 */	"N\000"
	/* gaStringNUMDATE+88 */	"O\000"
	/* gaStringNUMDATE+90 */	"e\000"
	/* gaStringNUMDATE+92 */	"n\000"
	/* gaStringNUMDATE+94 */	"t\000"
	/* gaStringNUMDATE+96 */	"m\000"
	/* gaStringNUMDATE+98 */	"p\000"
	/* gaStringNUMDATE+100 */	"u\000"
	/* gaStringNUMDATE+102 */	"\000"
	/* gaStringNUMDATE+104 */	"k\000"
	/* gaStringNUMDATE+106 */	",\000"
	/* gaStringNUMDATE+108 */	"s\000"
	/* gaStringNUMDATE+110 */	"-\000"
	/* gaStringNUMDATE+112 */	"g\000"
	/* gaStringNUMDATE+114 */	"z\000"
	/* gaStringNUMDATE+116 */	"b\000"
	/* gaStringNUMDATE+118 */	"ln\000"
	/* gaStringNUMDATE+121 */	"v\000"
	/* gaStringNUMDATE+123 */	"w\000"
	/* gaStringNUMDATE+125 */	".i\000"
	/* gaStringNUMDATE+128 */	".z\000"
	/* gaStringNUMDATE+131 */	"12\000"
	/* gaStringNUMDATE+134 */	"d\000"
	/* gaStringNUMDATE+136 */	"l\000"
	/* gaStringNUMDATE+138 */	"c\000"
	/* gaStringNUMDATE+140 */	"h\000"
;

static const STATE_TRANSITION gaTNUMDATE[] = {
	{gaSNUMDATE+0,	1}, // +0: state 0 transitions
	{gaSNUMDATE+2,	2},
	{gaSNUMDATE+4,	3},
	{gaSNUMDATE+6,	4},
	{gaSNUMDATE+8,	5},
	{gaSNUMDATE+10,	6},
	{gaSNUMDATE+17,	7},
	{gaSNUMDATE+19,	8},
	{gaSNUMDATE+21,	9},
	{gaSNUMDATE+23,	10},
	{gaSNUMDATE+25,	11}, // +10: state 1 transitions
	{gaSNUMDATE+2,	12}, // +11: state 2 transitions
	{gaSNUMDATE+36,	13},
	{gaSNUMDATE+46,	13}, // +13: state 3 transitions
	{gaSNUMDATE+50,	14},
	{gaSNUMDATE+52,	15},
	{gaSNUMDATE+54,	16},
	{gaSNUMDATE+50,	14}, // +17: state 4 transitions
	{gaSNUMDATE+52,	15},
	{gaSNUMDATE+25,	16},
	{gaSNUMDATE+62,	12}, // +20: state 5 transitions
	{gaSNUMDATE+50,	14},
	{gaSNUMDATE+52,	15},
	{gaSNUMDATE+71,	16},
	{gaSNUMDATE+25,	12}, // +24: state 6 transitions
	{gaSNUMDATE+50,	14},
	{gaSNUMDATE+52,	15},
	{gaSNUMDATE+74,	17}, // +27: state 7 transitions
	{gaSNUMDATE+76,	18},
	{gaSNUMDATE+78,	19}, // +29: state 8 transitions
	{gaSNUMDATE+74,	20}, // +30: state 9 transitions
	{gaSNUMDATE+76,	21},
	{gaSNUMDATE+80,	22}, // +32: state 10 transitions
	{gaSNUMDATE+76,	23},
	{gaSNUMDATE+25,	24}, // +34: state 11 transitions
	{gaSNUMDATE+25,	25}, // +35: state 12 transitions
	{gaSNUMDATE+50,	14}, // +36: state 13 transitions
	{gaSNUMDATE+52,	15},
	{gaSNUMDATE+25,	25},
	{gaSNUMDATE+0,	1}, // +39: state 14 transitions
	{gaSNUMDATE+25,	26},
	{gaSNUMDATE+50,	27}, // +41: state 15 transitions
	{gaSNUMDATE+2,	28},
	{gaSNUMDATE+4,	29},
	{gaSNUMDATE+62,	30},
	{gaSNUMDATE+82,	31},
	{gaSNUMDATE+17,	32},
	{gaSNUMDATE+19,	33},
	{gaSNUMDATE+84,	34},
	{gaSNUMDATE+21,	35},
	{gaSNUMDATE+86,	36},
	{gaSNUMDATE+88,	37},
	{gaSNUMDATE+23,	38},
	{gaSNUMDATE+52,	15}, // +53: state 16 transitions
	{gaSNUMDATE+25,	25},
	{gaSNUMDATE+52,	39}, // +55: state 17 transitions
	{gaSNUMDATE+90,	40},
	{gaSNUMDATE+52,	39}, // +57: state 18 transitions
	{gaSNUMDATE+92,	41},
	{gaSNUMDATE+52,	39}, // +59: state 19 transitions
	{gaSNUMDATE+90,	42},
	{gaSNUMDATE+52,	39}, // +61: state 20 transitions
	{gaSNUMDATE+94,	43},
	{gaSNUMDATE+52,	39}, // +63: state 21 transitions
	{gaSNUMDATE+92,	44},
	{gaSNUMDATE+52,	39}, // +65: state 22 transitions
	{gaSNUMDATE+96,	45},
	{gaSNUMDATE+52,	39}, // +67: state 23 transitions
	{gaSNUMDATE+92,	46},
	{gaSNUMDATE+25,	47}, // +69: state 25 transitions
	{gaSNUMDATE+25,	48}, // +70: state 26 transitions
	{gaSNUMDATE+82,	31}, // +71: state 27 transitions
	{gaSNUMDATE+17,	32},
	{gaSNUMDATE+19,	33},
	{gaSNUMDATE+84,	34},
	{gaSNUMDATE+21,	35},
	{gaSNUMDATE+86,	36},
	{gaSNUMDATE+88,	37},
	{gaSNUMDATE+23,	38},
	{gaSNUMDATE+36,	30}, // +79: state 28 transitions
	{gaSNUMDATE+50,	14}, // +80: state 29 transitions
	{gaSNUMDATE+52,	24},
	{gaSNUMDATE+46,	30},
	{gaSNUMDATE+50,	14}, // +83: state 30 transitions
	{gaSNUMDATE+52,	24},
	{gaSNUMDATE+98,	49}, // +85: state 31 transitions
	{gaSNUMDATE+100,	50},
	{gaSNUMDATE+90,	51}, // +87: state 32 transitions
	{gaSNUMDATE+90,	52}, // +88: state 33 transitions
	{gaSNUMDATE+80,	53}, // +89: state 34 transitions
	{gaSNUMDATE+100,	54},
	{gaSNUMDATE+80,	55}, // +91: state 35 transitions
	{gaSNUMDATE+102,	56},
	{gaSNUMDATE+76,	57}, // +93: state 36 transitions
	{gaSNUMDATE+104,	58}, // +94: state 37 transitions
	{gaSNUMDATE+90,	59}, // +95: state 38 transitions
	{gaSNUMDATE+106,	60}, // +96: state 39 transitions
	{gaSNUMDATE+92,	45}, // +97: state 40 transitions
	{gaSNUMDATE+92,	61}, // +98: state 41 transitions
	{gaSNUMDATE+74,	44}, // +99: state 42 transitions
	{gaSNUMDATE+94,	62}, // +100: state 43 transitions
	{gaSNUMDATE+94,	63}, // +101: state 44 transitions
	{gaSNUMDATE+108,	44}, // +102: state 45 transitions
	{gaSNUMDATE+92,	44}, // +103: state 46 transitions
	{gaSNUMDATE+110,	64}, // +104: state 47 transitions
	{gaSNUMDATE+25,	11}, // +105: state 48 transitions
	{gaSNUMDATE+78,	65}, // +106: state 49 transitions
	{gaSNUMDATE+112,	66}, // +107: state 50 transitions
	{gaSNUMDATE+114,	67}, // +108: state 51 transitions
	{gaSNUMDATE+116,	68}, // +109: state 52 transitions
	{gaSNUMDATE+92,	69}, // +110: state 53 transitions
	{gaSNUMDATE+118,	70}, // +111: state 54 transitions
	{gaSNUMDATE+74,	71}, // +112: state 55 transitions
	{gaSNUMDATE+78,	72}, // +113: state 56 transitions
	{gaSNUMDATE+121,	67}, // +114: state 57 transitions
	{gaSNUMDATE+94,	73}, // +115: state 58 transitions
	{gaSNUMDATE+98,	74}, // +116: state 59 transitions
	{gaSNUMDATE+50,	75}, // +117: state 60 transitions
	{gaSNUMDATE+90,	76}, // +118: state 61 transitions
	{gaSNUMDATE+123,	77}, // +119: state 62 transitions
	{gaSNUMDATE+80,	78}, // +120: state 63 transitions
	{gaSNUMDATE+2,	79}, // +121: state 64 transitions
	{gaSNUMDATE+4,	80},
	{gaSNUMDATE+62,	81},
	{gaSNUMDATE+52,	71}, // +124: state 65 transitions
	{gaSNUMDATE+74,	82},
	{gaSNUMDATE+52,	71}, // +126: state 66 transitions
	{gaSNUMDATE+100,	83},
	{gaSNUMDATE+52,	71}, // +128: state 67 transitions
	{gaSNUMDATE+90,	84},
	{gaSNUMDATE+78,	69}, // +130: state 68 transitions
	{gaSNUMDATE+52,	71}, // +131: state 69 transitions
	{gaSNUMDATE+100,	85},
	{gaSNUMDATE+125,	71}, // +133: state 70 transitions
	{gaSNUMDATE+50,	14}, // +134: state 71 transitions
	{gaSNUMDATE+128,	71}, // +135: state 72 transitions
	{gaSNUMDATE+52,	71}, // +136: state 73 transitions
	{gaSNUMDATE+76,	86},
	{gaSNUMDATE+94,	67}, // +138: state 74 transitions
	{gaSNUMDATE+2,	87}, // +139: state 75 transitions
	{gaSNUMDATE+131,	88},
	{gaSNUMDATE+8,	89},
	{gaSNUMDATE+10,	90},
	{gaSNUMDATE+134,	91},
	{gaSNUMDATE+78,	45}, // +144: state 76 transitions
	{gaSNUMDATE+76,	92}, // +145: state 77 transitions
	{gaSNUMDATE+112,	39}, // +146: state 78 transitions
	{gaSNUMDATE+36,	81}, // +147: state 79 transitions
	{gaSNUMDATE+46,	81}, // +148: state 80 transitions
	{gaSNUMDATE+110,	93},
	{gaSNUMDATE+110,	93}, // +150: state 81 transitions
	{gaSNUMDATE+136,	71}, // +151: state 82 transitions
	{gaSNUMDATE+108,	94}, // +152: state 83 transitions
	{gaSNUMDATE+96,	86}, // +153: state 84 transitions
	{gaSNUMDATE+80,	95}, // +154: state 85 transitions
	{gaSNUMDATE+116,	96}, // +155: state 86 transitions
	{gaSNUMDATE+36,	90}, // +156: state 87 transitions
	{gaSNUMDATE+25,	90}, // +157: state 88 transitions
	{gaSNUMDATE+52,	97},
	{gaSNUMDATE+71,	90}, // +159: state 89 transitions
	{gaSNUMDATE+52,	97},
	{gaSNUMDATE+52,	97}, // +161: state 90 transitions
	{gaSNUMDATE+90,	98}, // +162: state 91 transitions
	{gaSNUMDATE+138,	99}, // +163: state 92 transitions
	{gaSNUMDATE+10,	24}, // +164: state 93 transitions
	{gaSNUMDATE+2,	100},
	{gaSNUMDATE+131,	101},
	{gaSNUMDATE+8,	102},
	{gaSNUMDATE+94,	71}, // +168: state 94 transitions
	{gaSNUMDATE+78,	71}, // +169: state 95 transitions
	{gaSNUMDATE+90,	95}, // +170: state 96 transitions
	{gaSNUMDATE+50,	27}, // +171: state 97 transitions
	{gaSNUMDATE+62,	71},
	{gaSNUMDATE+2,	103},
	{gaSNUMDATE+4,	104},
	{gaSNUMDATE+92,	105}, // +175: state 98 transitions
	{gaSNUMDATE+140,	39}, // +176: state 99 transitions
	{gaSNUMDATE+36,	24}, // +177: state 100 transitions
	{gaSNUMDATE+25,	24}, // +178: state 101 transitions
	{gaSNUMDATE+71,	24}, // +179: state 102 transitions
	{gaSNUMDATE+36,	71}, // +180: state 103 transitions
	{gaSNUMDATE+50,	14}, // +181: state 104 transitions
	{gaSNUMDATE+46,	71},
	{gaSNUMDATE+50,	106}, // +183: state 105 transitions
	{gaSNUMDATE+2,	107}, // +184: state 106 transitions
	{gaSNUMDATE+131,	108},
	{gaSNUMDATE+8,	109},
	{gaSNUMDATE+10,	110},
	{gaSNUMDATE+36,	110}, // +188: state 107 transitions
	{gaSNUMDATE+52,	27}, // +189: state 108 transitions
	{gaSNUMDATE+25,	110},
	{gaSNUMDATE+52,	27}, // +191: state 109 transitions
	{gaSNUMDATE+71,	110},
	{gaSNUMDATE+52,	27}, // +193: state 110 transitions
};

const STATE_DESCRIPTION aStateDescNUMDATE[111] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 10, gaTNUMDATE+0},
	/*   1 */ {0, 1, gaTNUMDATE+10},
	/*   2 */ {0, 2, gaTNUMDATE+11},
	/*   3 */ {0, 4, gaTNUMDATE+13},
	/*   4 */ {0, 3, gaTNUMDATE+17},
	/*   5 */ {0, 4, gaTNUMDATE+20},
	/*   6 */ {0, 3, gaTNUMDATE+24},
	/*   7 */ {0, 2, gaTNUMDATE+27},
	/*   8 */ {0, 1, gaTNUMDATE+29},
	/*   9 */ {0, 2, gaTNUMDATE+30},
	/*  10 */ {0, 2, gaTNUMDATE+32},
	/*  11 */ {0, 1, gaTNUMDATE+34},
	/*  12 */ {1, 1, gaTNUMDATE+35},
	/*  13 */ {1, 3, gaTNUMDATE+36},
	/*  14 */ {0, 2, gaTNUMDATE+39},
	/*  15 */ {0, 12, gaTNUMDATE+41},
	/*  16 */ {1, 2, gaTNUMDATE+53},
	/*  17 */ {0, 2, gaTNUMDATE+55},
	/*  18 */ {0, 2, gaTNUMDATE+57},
	/*  19 */ {0, 2, gaTNUMDATE+59},
	/*  20 */ {0, 2, gaTNUMDATE+61},
	/*  21 */ {0, 2, gaTNUMDATE+63},
	/*  22 */ {0, 2, gaTNUMDATE+65},
	/*  23 */ {0, 2, gaTNUMDATE+67},
	/*  24 */ {1, 0, NULL},
	/*  25 */ {0, 1, gaTNUMDATE+69},
	/*  26 */ {0, 1, gaTNUMDATE+70},
	/*  27 */ {0, 8, gaTNUMDATE+71},
	/*  28 */ {0, 1, gaTNUMDATE+79},
	/*  29 */ {1, 3, gaTNUMDATE+80},
	/*  30 */ {1, 2, gaTNUMDATE+83},
	/*  31 */ {0, 2, gaTNUMDATE+85},
	/*  32 */ {0, 1, gaTNUMDATE+87},
	/*  33 */ {0, 1, gaTNUMDATE+88},
	/*  34 */ {0, 2, gaTNUMDATE+89},
	/*  35 */ {0, 2, gaTNUMDATE+91},
	/*  36 */ {0, 1, gaTNUMDATE+93},
	/*  37 */ {0, 1, gaTNUMDATE+94},
	/*  38 */ {0, 1, gaTNUMDATE+95},
	/*  39 */ {0, 1, gaTNUMDATE+96},
	/*  40 */ {0, 1, gaTNUMDATE+97},
	/*  41 */ {0, 1, gaTNUMDATE+98},
	/*  42 */ {0, 1, gaTNUMDATE+99},
	/*  43 */ {0, 1, gaTNUMDATE+100},
	/*  44 */ {0, 1, gaTNUMDATE+101},
	/*  45 */ {0, 1, gaTNUMDATE+102},
	/*  46 */ {0, 1, gaTNUMDATE+103},
	/*  47 */ {1, 1, gaTNUMDATE+104},
	/*  48 */ {1, 1, gaTNUMDATE+105},
	/*  49 */ {0, 1, gaTNUMDATE+106},
	/*  50 */ {0, 1, gaTNUMDATE+107},
	/*  51 */ {0, 1, gaTNUMDATE+108},
	/*  52 */ {0, 1, gaTNUMDATE+109},
	/*  53 */ {0, 1, gaTNUMDATE+110},
	/*  54 */ {0, 1, gaTNUMDATE+111},
	/*  55 */ {0, 1, gaTNUMDATE+112},
	/*  56 */ {0, 1, gaTNUMDATE+113},
	/*  57 */ {0, 1, gaTNUMDATE+114},
	/*  58 */ {0, 1, gaTNUMDATE+115},
	/*  59 */ {0, 1, gaTNUMDATE+116},
	/*  60 */ {0, 1, gaTNUMDATE+117},
	/*  61 */ {0, 1, gaTNUMDATE+118},
	/*  62 */ {0, 1, gaTNUMDATE+119},
	/*  63 */ {0, 1, gaTNUMDATE+120},
	/*  64 */ {0, 3, gaTNUMDATE+121},
	/*  65 */ {0, 2, gaTNUMDATE+124},
	/*  66 */ {0, 2, gaTNUMDATE+126},
	/*  67 */ {0, 2, gaTNUMDATE+128},
	/*  68 */ {0, 1, gaTNUMDATE+130},
	/*  69 */ {0, 2, gaTNUMDATE+131},
	/*  70 */ {0, 1, gaTNUMDATE+133},
	/*  71 */ {1, 1, gaTNUMDATE+134},
	/*  72 */ {0, 1, gaTNUMDATE+135},
	/*  73 */ {0, 2, gaTNUMDATE+136},
	/*  74 */ {0, 1, gaTNUMDATE+138},
	/*  75 */ {0, 5, gaTNUMDATE+139},
	/*  76 */ {0, 1, gaTNUMDATE+144},
	/*  77 */ {0, 1, gaTNUMDATE+145},
	/*  78 */ {0, 1, gaTNUMDATE+146},
	/*  79 */ {0, 1, gaTNUMDATE+147},
	/*  80 */ {0, 2, gaTNUMDATE+148},
	/*  81 */ {0, 1, gaTNUMDATE+150},
	/*  82 */ {0, 1, gaTNUMDATE+151},
	/*  83 */ {0, 1, gaTNUMDATE+152},
	/*  84 */ {0, 1, gaTNUMDATE+153},
	/*  85 */ {0, 1, gaTNUMDATE+154},
	/*  86 */ {0, 1, gaTNUMDATE+155},
	/*  87 */ {0, 1, gaTNUMDATE+156},
	/*  88 */ {0, 2, gaTNUMDATE+157},
	/*  89 */ {0, 2, gaTNUMDATE+159},
	/*  90 */ {0, 1, gaTNUMDATE+161},
	/*  91 */ {0, 1, gaTNUMDATE+162},
	/*  92 */ {0, 1, gaTNUMDATE+163},
	/*  93 */ {0, 4, gaTNUMDATE+164},
	/*  94 */ {0, 1, gaTNUMDATE+168},
	/*  95 */ {0, 1, gaTNUMDATE+169},
	/*  96 */ {0, 1, gaTNUMDATE+170},
	/*  97 */ {0, 4, gaTNUMDATE+171},
	/*  98 */ {0, 1, gaTNUMDATE+175},
	/*  99 */ {0, 1, gaTNUMDATE+176},
	/* 100 */ {0, 1, gaTNUMDATE+177},
	/* 101 */ {1, 1, gaTNUMDATE+178},
	/* 102 */ {1, 1, gaTNUMDATE+179},
	/* 103 */ {0, 1, gaTNUMDATE+180},
	/* 104 */ {1, 2, gaTNUMDATE+181},
	/* 105 */ {0, 1, gaTNUMDATE+183},
	/* 106 */ {0, 4, gaTNUMDATE+184},
	/* 107 */ {0, 1, gaTNUMDATE+188},
	/* 108 */ {0, 2, gaTNUMDATE+189},
	/* 109 */ {0, 2, gaTNUMDATE+191},
	/* 110 */ {0, 1, gaTNUMDATE+193},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:05 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numtime

// 14 states

static const unsigned char gaSNUMTIME[] = 
	/* gaStringNUMTIME+0 */	"01\000"
	/* gaStringNUMTIME+3 */	"2\000"
	/* gaStringNUMTIME+5 */	"3456789\000"
	/* gaStringNUMTIME+13 */	"0123456789\000"
	/* gaStringNUMTIME+24 */	".:\000"
	/* gaStringNUMTIME+27 */	"01234\000"
	/* gaStringNUMTIME+33 */	"012345\000"
	/* gaStringNUMTIME+40 */	"6789\000"
	/* gaStringNUMTIME+45 */	" \000"
	/* gaStringNUMTIME+47 */	"h\000"
	/* gaStringNUMTIME+49 */	"U\000"
	/* gaStringNUMTIME+51 */	"r\000"
;

static const STATE_TRANSITION gaTNUMTIME[] = {
	{gaSNUMTIME+0,	1}, // +0: state 0 transitions
	{gaSNUMTIME+3,	2},
	{gaSNUMTIME+5,	3},
	{gaSNUMTIME+13,	3}, // +3: state 1 transitions
	{gaSNUMTIME+24,	4},
	{gaSNUMTIME+27,	3}, // +5: state 2 transitions
	{gaSNUMTIME+24,	4},
	{gaSNUMTIME+24,	4}, // +7: state 3 transitions
	{gaSNUMTIME+33,	5}, // +8: state 4 transitions
	{gaSNUMTIME+40,	6},
	{gaSNUMTIME+13,	6}, // +10: state 5 transitions
	{gaSNUMTIME+45,	7},
	{gaSNUMTIME+24,	8},
	{gaSNUMTIME+47,	9},
	{gaSNUMTIME+45,	7}, // +14: state 6 transitions
	{gaSNUMTIME+24,	8},
	{gaSNUMTIME+47,	9},
	{gaSNUMTIME+49,	10}, // +17: state 7 transitions
	{gaSNUMTIME+33,	11}, // +18: state 8 transitions
	{gaSNUMTIME+40,	12},
	{gaSNUMTIME+47,	13}, // +20: state 10 transitions
	{gaSNUMTIME+45,	7}, // +21: state 11 transitions
	{gaSNUMTIME+47,	9},
	{gaSNUMTIME+13,	12},
	{gaSNUMTIME+45,	7}, // +24: state 12 transitions
	{gaSNUMTIME+47,	9},
	{gaSNUMTIME+51,	9}, // +26: state 13 transitions
};

const STATE_DESCRIPTION aStateDescNUMTIME[14] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMTIME+0},
	/*   1 */ {0, 2, gaTNUMTIME+3},
	/*   2 */ {0, 2, gaTNUMTIME+5},
	/*   3 */ {0, 1, gaTNUMTIME+7},
	/*   4 */ {0, 2, gaTNUMTIME+8},
	/*   5 */ {1, 4, gaTNUMTIME+10},
	/*   6 */ {1, 3, gaTNUMTIME+14},
	/*   7 */ {0, 1, gaTNUMTIME+17},
	/*   8 */ {0, 2, gaTNUMTIME+18},
	/*   9 */ {1, 0, NULL},
	/*  10 */ {0, 1, gaTNUMTIME+20},
	/*  11 */ {1, 3, gaTNUMTIME+21},
	/*  12 */ {1, 2, gaTNUMTIME+24},
	/*  13 */ {0, 1, gaTNUMTIME+26},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numcurrency

// 34 states

static const unsigned char gaSNUMCURRENCY[] = 
	/* gaStringNUMCURRENCY+0 */	"$\000"
	/* gaStringNUMCURRENCY+5 */	"0123456789\000"
	/* gaStringNUMCURRENCY+16 */	"D\000"
	/* gaStringNUMCURRENCY+18 */	"E\000"
	/* gaStringNUMCURRENCY+20 */	" \000"
	/* gaStringNUMCURRENCY+22 */	",\000"
	/* gaStringNUMCURRENCY+24 */	".\000"
	/* gaStringNUMCURRENCY+26 */	"M\000"
	/* gaStringNUMCURRENCY+28 */	"U\000"
	/* gaStringNUMCURRENCY+30 */	"-\000"
	/* gaStringNUMCURRENCY+32 */	"R\000"
	/* gaStringNUMCURRENCY+34 */	"O\000"
;

static const STATE_TRANSITION gaTNUMCURRENCY[] = {
	{gaSNUMCURRENCY+0,	1}, // +0: state 0 transitions
	{gaSNUMCURRENCY+5,	2},
	{gaSNUMCURRENCY+16,	3},
	{gaSNUMCURRENCY+18,	4},
	{gaSNUMCURRENCY+20,	5}, // +4: state 1 transitions
	{gaSNUMCURRENCY+20,	6}, // +5: state 2 transitions
	{gaSNUMCURRENCY+22,	7},
	{gaSNUMCURRENCY+24,	8},
	{gaSNUMCURRENCY+5,	9},
	{gaSNUMCURRENCY+26,	1}, // +9: state 3 transitions
	{gaSNUMCURRENCY+28,	10}, // +10: state 4 transitions
	{gaSNUMCURRENCY+5,	11}, // +11: state 5 transitions
	{gaSNUMCURRENCY+0,	12}, // +12: state 6 transitions
	{gaSNUMCURRENCY+16,	13},
	{gaSNUMCURRENCY+18,	14},
	{gaSNUMCURRENCY+30,	15}, // +15: state 7 transitions
	{gaSNUMCURRENCY+5,	16},
	{gaSNUMCURRENCY+5,	17}, // +17: state 8 transitions
	{gaSNUMCURRENCY+20,	6}, // +18: state 9 transitions
	{gaSNUMCURRENCY+22,	7},
	{gaSNUMCURRENCY+24,	8},
	{gaSNUMCURRENCY+5,	18},
	{gaSNUMCURRENCY+32,	19}, // +22: state 10 transitions
	{gaSNUMCURRENCY+22,	20}, // +23: state 11 transitions
	{gaSNUMCURRENCY+24,	21},
	{gaSNUMCURRENCY+5,	22},
	{gaSNUMCURRENCY+26,	12}, // +26: state 13 transitions
	{gaSNUMCURRENCY+28,	23}, // +27: state 14 transitions
	{gaSNUMCURRENCY+20,	6}, // +28: state 15 transitions
	{gaSNUMCURRENCY+5,	15}, // +29: state 16 transitions
	{gaSNUMCURRENCY+5,	24}, // +30: state 17 transitions
	{gaSNUMCURRENCY+20,	6}, // +31: state 18 transitions
	{gaSNUMCURRENCY+22,	7},
	{gaSNUMCURRENCY+24,	8},
	{gaSNUMCURRENCY+5,	25},
	{gaSNUMCURRENCY+34,	1}, // +35: state 19 transitions
	{gaSNUMCURRENCY+20,	5},
	{gaSNUMCURRENCY+30,	12}, // +37: state 20 transitions
	{gaSNUMCURRENCY+5,	26},
	{gaSNUMCURRENCY+5,	27}, // +39: state 21 transitions
	{gaSNUMCURRENCY+22,	20}, // +40: state 22 transitions
	{gaSNUMCURRENCY+24,	21},
	{gaSNUMCURRENCY+5,	28},
	{gaSNUMCURRENCY+32,	29}, // +43: state 23 transitions
	{gaSNUMCURRENCY+5,	30}, // +44: state 24 transitions
	{gaSNUMCURRENCY+20,	6}, // +45: state 25 transitions
	{gaSNUMCURRENCY+22,	7},
	{gaSNUMCURRENCY+5,	25},
	{gaSNUMCURRENCY+5,	12}, // +48: state 26 transitions
	{gaSNUMCURRENCY+5,	31}, // +49: state 27 transitions
	{gaSNUMCURRENCY+22,	20}, // +50: state 28 transitions
	{gaSNUMCURRENCY+24,	21},
	{gaSNUMCURRENCY+5,	32},
	{gaSNUMCURRENCY+34,	12}, // +53: state 29 transitions
	{gaSNUMCURRENCY+20,	6}, // +54: state 30 transitions
	{gaSNUMCURRENCY+22,	7},
	{gaSNUMCURRENCY+24,	8},
	{gaSNUMCURRENCY+5,	33}, // +57: state 31 transitions
	{gaSNUMCURRENCY+22,	20}, // +58: state 32 transitions
	{gaSNUMCURRENCY+5,	32},
	{gaSNUMCURRENCY+22,	20}, // +60: state 33 transitions
	{gaSNUMCURRENCY+24,	21},
};

const STATE_DESCRIPTION aStateDescNUMCURRENCY[34] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTNUMCURRENCY+0},
	/*   1 */ {0, 1, gaTNUMCURRENCY+4},
	/*   2 */ {0, 4, gaTNUMCURRENCY+5},
	/*   3 */ {0, 1, gaTNUMCURRENCY+9},
	/*   4 */ {0, 1, gaTNUMCURRENCY+10},
	/*   5 */ {0, 1, gaTNUMCURRENCY+11},
	/*   6 */ {0, 3, gaTNUMCURRENCY+12},
	/*   7 */ {0, 2, gaTNUMCURRENCY+15},
	/*   8 */ {0, 1, gaTNUMCURRENCY+17},
	/*   9 */ {0, 4, gaTNUMCURRENCY+18},
	/*  10 */ {0, 1, gaTNUMCURRENCY+22},
	/*  11 */ {1, 3, gaTNUMCURRENCY+23},
	/*  12 */ {1, 0, NULL},
	/*  13 */ {0, 1, gaTNUMCURRENCY+26},
	/*  14 */ {0, 1, gaTNUMCURRENCY+27},
	/*  15 */ {0, 1, gaTNUMCURRENCY+28},
	/*  16 */ {0, 1, gaTNUMCURRENCY+29},
	/*  17 */ {0, 1, gaTNUMCURRENCY+30},
	/*  18 */ {0, 4, gaTNUMCURRENCY+31},
	/*  19 */ {0, 2, gaTNUMCURRENCY+35},
	/*  20 */ {0, 2, gaTNUMCURRENCY+37},
	/*  21 */ {0, 1, gaTNUMCURRENCY+39},
	/*  22 */ {1, 3, gaTNUMCURRENCY+40},
	/*  23 */ {0, 1, gaTNUMCURRENCY+43},
	/*  24 */ {0, 1, gaTNUMCURRENCY+44},
	/*  25 */ {0, 3, gaTNUMCURRENCY+45},
	/*  26 */ {0, 1, gaTNUMCURRENCY+48},
	/*  27 */ {0, 1, gaTNUMCURRENCY+49},
	/*  28 */ {1, 3, gaTNUMCURRENCY+50},
	/*  29 */ {1, 1, gaTNUMCURRENCY+53},
	/*  30 */ {0, 3, gaTNUMCURRENCY+54},
	/*  31 */ {0, 1, gaTNUMCURRENCY+57},
	/*  32 */ {1, 2, gaTNUMCURRENCY+58},
	/*  33 */ {1, 2, gaTNUMCURRENCY+60},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = numphone

// 50 states

static const unsigned char gaSNUMPHONE[] = 
	/* gaStringNUMPHONE+0 */	"(\000"
	/* gaStringNUMPHONE+2 */	"+\000"
	/* gaStringNUMPHONE+4 */	"0\000"
	/* gaStringNUMPHONE+6 */	"123456789\000"
	/* gaStringNUMPHONE+16 */	"0123456789\000"
	/* gaStringNUMPHONE+27 */	" \000"
	/* gaStringNUMPHONE+29 */	"/\000"
	/* gaStringNUMPHONE+31 */	")\000"
	/* gaStringNUMPHONE+33 */	"-\000"
;

static const STATE_TRANSITION gaTNUMPHONE[] = {
	{gaSNUMPHONE+0,	1}, // +0: state 0 transitions
	{gaSNUMPHONE+2,	2},
	{gaSNUMPHONE+4,	3},
	{gaSNUMPHONE+6,	4},
	{gaSNUMPHONE+16,	5}, // +4: state 1 transitions
	{gaSNUMPHONE+16,	6}, // +5: state 2 transitions
	{gaSNUMPHONE+4,	7}, // +6: state 3 transitions
	{gaSNUMPHONE+6,	8},
	{gaSNUMPHONE+16,	8}, // +8: state 4 transitions
	{gaSNUMPHONE+16,	9}, // +9: state 5 transitions
	{gaSNUMPHONE+16,	10}, // +10: state 6 transitions
	{gaSNUMPHONE+27,	11}, // +11: state 7 transitions
	{gaSNUMPHONE+16,	12},
	{gaSNUMPHONE+27,	11}, // +13: state 8 transitions
	{gaSNUMPHONE+16,	13},
	{gaSNUMPHONE+16,	14}, // +15: state 9 transitions
	{gaSNUMPHONE+27,	15}, // +16: state 10 transitions
	{gaSNUMPHONE+16,	16}, // +17: state 11 transitions
	{gaSNUMPHONE+27,	17}, // +18: state 12 transitions
	{gaSNUMPHONE+29,	18},
	{gaSNUMPHONE+16,	19},
	{gaSNUMPHONE+27,	17}, // +21: state 13 transitions
	{gaSNUMPHONE+29,	18},
	{gaSNUMPHONE+16,	20},
	{gaSNUMPHONE+31,	21}, // +24: state 14 transitions
	{gaSNUMPHONE+16,	22},
	{gaSNUMPHONE+0,	23}, // +26: state 15 transitions
	{gaSNUMPHONE+16,	24},
	{gaSNUMPHONE+16,	25}, // +28: state 16 transitions
	{gaSNUMPHONE+16,	16}, // +29: state 17 transitions
	{gaSNUMPHONE+33,	26},
	{gaSNUMPHONE+16,	27}, // +31: state 18 transitions
	{gaSNUMPHONE+27,	15}, // +32: state 19 transitions
	{gaSNUMPHONE+29,	18},
	{gaSNUMPHONE+16,	28},
	{gaSNUMPHONE+29,	18}, // +35: state 20 transitions
	{gaSNUMPHONE+16,	28},
	{gaSNUMPHONE+27,	18}, // +37: state 21 transitions
	{gaSNUMPHONE+31,	21}, // +38: state 22 transitions
	{gaSNUMPHONE+16,	29},
	{gaSNUMPHONE+6,	5}, // +40: state 23 transitions
	{gaSNUMPHONE+4,	30},
	{gaSNUMPHONE+16,	31}, // +42: state 24 transitions
	{gaSNUMPHONE+27,	32}, // +43: state 25 transitions
	{gaSNUMPHONE+27,	33}, // +44: state 26 transitions
	{gaSNUMPHONE+16,	34}, // +45: state 27 transitions
	{gaSNUMPHONE+29,	18}, // +46: state 28 transitions
	{gaSNUMPHONE+16,	35},
	{gaSNUMPHONE+31,	21}, // +48: state 29 transitions
	{gaSNUMPHONE+16,	36},
	{gaSNUMPHONE+16,	9}, // +50: state 30 transitions
	{gaSNUMPHONE+31,	24},
	{gaSNUMPHONE+16,	37}, // +52: state 31 transitions
	{gaSNUMPHONE+33,	26}, // +53: state 32 transitions
	{gaSNUMPHONE+16,	38},
	{gaSNUMPHONE+16,	39}, // +55: state 33 transitions
	{gaSNUMPHONE+27,	11}, // +56: state 34 transitions
	{gaSNUMPHONE+16,	40},
	{gaSNUMPHONE+29,	18}, // +58: state 35 transitions
	{gaSNUMPHONE+31,	21}, // +59: state 36 transitions
	{gaSNUMPHONE+27,	18}, // +60: state 37 transitions
	{gaSNUMPHONE+16,	41},
	{gaSNUMPHONE+16,	42}, // +62: state 38 transitions
	{gaSNUMPHONE+16,	43}, // +63: state 39 transitions
	{gaSNUMPHONE+27,	17}, // +64: state 40 transitions
	{gaSNUMPHONE+27,	18}, // +65: state 41 transitions
	{gaSNUMPHONE+16,	44},
	{gaSNUMPHONE+27,	45}, // +67: state 42 transitions
	{gaSNUMPHONE+16,	46}, // +68: state 43 transitions
	{gaSNUMPHONE+27,	18}, // +69: state 44 transitions
	{gaSNUMPHONE+16,	21},
	{gaSNUMPHONE+33,	26}, // +71: state 45 transitions
	{gaSNUMPHONE+16,	47},
	{gaSNUMPHONE+16,	48}, // +73: state 47 transitions
	{gaSNUMPHONE+27,	49}, // +74: state 48 transitions
	{gaSNUMPHONE+33,	26}, // +75: state 49 transitions
};

const STATE_DESCRIPTION aStateDescNUMPHONE[50] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTNUMPHONE+0},
	/*   1 */ {0, 1, gaTNUMPHONE+4},
	/*   2 */ {0, 1, gaTNUMPHONE+5},
	/*   3 */ {0, 2, gaTNUMPHONE+6},
	/*   4 */ {0, 1, gaTNUMPHONE+8},
	/*   5 */ {0, 1, gaTNUMPHONE+9},
	/*   6 */ {0, 1, gaTNUMPHONE+10},
	/*   7 */ {0, 2, gaTNUMPHONE+11},
	/*   8 */ {0, 2, gaTNUMPHONE+13},
	/*   9 */ {0, 1, gaTNUMPHONE+15},
	/*  10 */ {0, 1, gaTNUMPHONE+16},
	/*  11 */ {0, 1, gaTNUMPHONE+17},
	/*  12 */ {1, 3, gaTNUMPHONE+18},
	/*  13 */ {1, 3, gaTNUMPHONE+21},
	/*  14 */ {0, 2, gaTNUMPHONE+24},
	/*  15 */ {0, 2, gaTNUMPHONE+26},
	/*  16 */ {0, 1, gaTNUMPHONE+28},
	/*  17 */ {0, 2, gaTNUMPHONE+29},
	/*  18 */ {0, 1, gaTNUMPHONE+31},
	/*  19 */ {0, 3, gaTNUMPHONE+32},
	/*  20 */ {0, 2, gaTNUMPHONE+35},
	/*  21 */ {0, 1, gaTNUMPHONE+37},
	/*  22 */ {0, 2, gaTNUMPHONE+38},
	/*  23 */ {0, 2, gaTNUMPHONE+40},
	/*  24 */ {0, 1, gaTNUMPHONE+42},
	/*  25 */ {1, 1, gaTNUMPHONE+43},
	/*  26 */ {0, 1, gaTNUMPHONE+44},
	/*  27 */ {0, 1, gaTNUMPHONE+45},
	/*  28 */ {0, 2, gaTNUMPHONE+46},
	/*  29 */ {0, 2, gaTNUMPHONE+48},
	/*  30 */ {0, 2, gaTNUMPHONE+50},
	/*  31 */ {0, 1, gaTNUMPHONE+52},
	/*  32 */ {0, 2, gaTNUMPHONE+53},
	/*  33 */ {0, 1, gaTNUMPHONE+55},
	/*  34 */ {0, 2, gaTNUMPHONE+56},
	/*  35 */ {0, 1, gaTNUMPHONE+58},
	/*  36 */ {0, 1, gaTNUMPHONE+59},
	/*  37 */ {0, 2, gaTNUMPHONE+60},
	/*  38 */ {0, 1, gaTNUMPHONE+62},
	/*  39 */ {1, 1, gaTNUMPHONE+63},
	/*  40 */ {1, 1, gaTNUMPHONE+64},
	/*  41 */ {0, 2, gaTNUMPHONE+65},
	/*  42 */ {1, 1, gaTNUMPHONE+67},
	/*  43 */ {1, 1, gaTNUMPHONE+68},
	/*  44 */ {0, 2, gaTNUMPHONE+69},
	/*  45 */ {0, 2, gaTNUMPHONE+71},
	/*  46 */ {1, 0, NULL},
	/*  47 */ {0, 1, gaTNUMPHONE+73},
	/*  48 */ {1, 1, gaTNUMPHONE+74},
	/*  49 */ {0, 1, gaTNUMPHONE+75},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = nummath

// 156 states

static const unsigned char gaSNUMMATH[] = 
	/* gaStringNUMMATH+0 */	"(\000"
	/* gaStringNUMMATH+2 */	"+-\000"
	/* gaStringNUMMATH+5 */	"0123456789\000"
	/* gaStringNUMMATH+16 */	"*+-/\000"
	/* gaStringNUMMATH+21 */	",\000"
	/* gaStringNUMMATH+23 */	".\000"
	/* gaStringNUMMATH+25 */	"<=>\000"
	/* gaStringNUMMATH+29 */	"-\000"
	/* gaStringNUMMATH+31 */	")\000"
;

static const STATE_TRANSITION gaTNUMMATH[] = {
	{gaSNUMMATH+0,	1}, // +0: state 0 transitions
	{gaSNUMMATH+2,	2},
	{gaSNUMMATH+5,	3},
	{gaSNUMMATH+2,	4}, // +3: state 1 transitions
	{gaSNUMMATH+5,	5},
	{gaSNUMMATH+5,	3}, // +5: state 2 transitions
	{gaSNUMMATH+16,	6}, // +6: state 3 transitions
	{gaSNUMMATH+21,	7},
	{gaSNUMMATH+23,	8},
	{gaSNUMMATH+5,	9},
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+5,	5}, // +11: state 4 transitions
	{gaSNUMMATH+16,	11}, // +12: state 5 transitions
	{gaSNUMMATH+21,	12},
	{gaSNUMMATH+23,	13},
	{gaSNUMMATH+5,	14},
	{gaSNUMMATH+0,	15}, // +16: state 6 transitions
	{gaSNUMMATH+2,	16},
	{gaSNUMMATH+5,	17},
	{gaSNUMMATH+29,	18}, // +19: state 7 transitions
	{gaSNUMMATH+5,	19},
	{gaSNUMMATH+5,	20}, // +21: state 8 transitions
	{gaSNUMMATH+16,	6}, // +22: state 9 transitions
	{gaSNUMMATH+21,	7},
	{gaSNUMMATH+23,	8},
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+5,	21},
	{gaSNUMMATH+0,	22}, // +27: state 10 transitions
	{gaSNUMMATH+2,	23},
	{gaSNUMMATH+5,	24},
	{gaSNUMMATH+2,	25}, // +30: state 11 transitions
	{gaSNUMMATH+5,	26},
	{gaSNUMMATH+29,	27}, // +32: state 12 transitions
	{gaSNUMMATH+5,	28},
	{gaSNUMMATH+5,	29}, // +34: state 13 transitions
	{gaSNUMMATH+16,	11}, // +35: state 14 transitions
	{gaSNUMMATH+21,	12},
	{gaSNUMMATH+23,	13},
	{gaSNUMMATH+5,	30},
	{gaSNUMMATH+2,	31}, // +39: state 15 transitions
	{gaSNUMMATH+5,	32},
	{gaSNUMMATH+5,	17}, // +41: state 16 transitions
	{gaSNUMMATH+25,	10}, // +42: state 17 transitions
	{gaSNUMMATH+21,	33},
	{gaSNUMMATH+23,	34},
	{gaSNUMMATH+5,	35},
	{gaSNUMMATH+16,	6}, // +46: state 18 transitions
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+16,	6}, // +48: state 19 transitions
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+5,	19},
	{gaSNUMMATH+5,	36}, // +51: state 20 transitions
	{gaSNUMMATH+16,	6}, // +52: state 21 transitions
	{gaSNUMMATH+21,	7},
	{gaSNUMMATH+23,	8},
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+5,	37},
	{gaSNUMMATH+2,	38}, // +57: state 22 transitions
	{gaSNUMMATH+5,	39},
	{gaSNUMMATH+5,	24}, // +59: state 23 transitions
	{gaSNUMMATH+16,	40}, // +60: state 24 transitions
	{gaSNUMMATH+21,	41},
	{gaSNUMMATH+23,	42},
	{gaSNUMMATH+5,	43},
	{gaSNUMMATH+5,	26}, // +64: state 25 transitions
	{gaSNUMMATH+31,	18}, // +65: state 26 transitions
	{gaSNUMMATH+21,	44},
	{gaSNUMMATH+23,	45},
	{gaSNUMMATH+5,	46},
	{gaSNUMMATH+16,	11}, // +69: state 27 transitions
	{gaSNUMMATH+16,	11}, // +70: state 28 transitions
	{gaSNUMMATH+5,	28},
	{gaSNUMMATH+5,	47}, // +72: state 29 transitions
	{gaSNUMMATH+16,	11}, // +73: state 30 transitions
	{gaSNUMMATH+21,	12},
	{gaSNUMMATH+23,	13},
	{gaSNUMMATH+5,	48},
	{gaSNUMMATH+5,	32}, // +77: state 31 transitions
	{gaSNUMMATH+16,	49}, // +78: state 32 transitions
	{gaSNUMMATH+21,	50},
	{gaSNUMMATH+23,	51},
	{gaSNUMMATH+5,	52},
	{gaSNUMMATH+29,	53}, // +82: state 33 transitions
	{gaSNUMMATH+5,	54},
	{gaSNUMMATH+5,	55}, // +84: state 34 transitions
	{gaSNUMMATH+25,	10}, // +85: state 35 transitions
	{gaSNUMMATH+21,	33},
	{gaSNUMMATH+23,	34},
	{gaSNUMMATH+5,	56},
	{gaSNUMMATH+5,	57}, // +89: state 36 transitions
	{gaSNUMMATH+16,	6}, // +90: state 37 transitions
	{gaSNUMMATH+21,	7},
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+5,	37},
	{gaSNUMMATH+5,	39}, // +94: state 38 transitions
	{gaSNUMMATH+16,	58}, // +95: state 39 transitions
	{gaSNUMMATH+21,	59},
	{gaSNUMMATH+23,	60},
	{gaSNUMMATH+5,	61},
	{gaSNUMMATH+0,	62}, // +99: state 40 transitions
	{gaSNUMMATH+2,	63},
	{gaSNUMMATH+5,	64},
	{gaSNUMMATH+29,	65}, // +102: state 41 transitions
	{gaSNUMMATH+5,	66},
	{gaSNUMMATH+5,	67}, // +104: state 42 transitions
	{gaSNUMMATH+16,	40}, // +105: state 43 transitions
	{gaSNUMMATH+21,	41},
	{gaSNUMMATH+23,	42},
	{gaSNUMMATH+5,	68},
	{gaSNUMMATH+29,	69}, // +109: state 44 transitions
	{gaSNUMMATH+5,	70},
	{gaSNUMMATH+5,	71}, // +111: state 45 transitions
	{gaSNUMMATH+31,	18}, // +112: state 46 transitions
	{gaSNUMMATH+21,	44},
	{gaSNUMMATH+23,	45},
	{gaSNUMMATH+5,	72},
	{gaSNUMMATH+5,	73}, // +116: state 47 transitions
	{gaSNUMMATH+16,	11}, // +117: state 48 transitions
	{gaSNUMMATH+21,	12},
	{gaSNUMMATH+5,	48},
	{gaSNUMMATH+2,	74}, // +120: state 49 transitions
	{gaSNUMMATH+5,	75},
	{gaSNUMMATH+29,	76}, // +122: state 50 transitions
	{gaSNUMMATH+5,	77},
	{gaSNUMMATH+5,	78}, // +124: state 51 transitions
	{gaSNUMMATH+16,	49}, // +125: state 52 transitions
	{gaSNUMMATH+21,	50},
	{gaSNUMMATH+23,	51},
	{gaSNUMMATH+5,	79},
	{gaSNUMMATH+25,	10}, // +129: state 53 transitions
	{gaSNUMMATH+25,	10}, // +130: state 54 transitions
	{gaSNUMMATH+5,	54},
	{gaSNUMMATH+5,	80}, // +132: state 55 transitions
	{gaSNUMMATH+25,	10}, // +133: state 56 transitions
	{gaSNUMMATH+21,	33},
	{gaSNUMMATH+23,	34},
	{gaSNUMMATH+5,	81},
	{gaSNUMMATH+16,	6}, // +137: state 57 transitions
	{gaSNUMMATH+21,	7},
	{gaSNUMMATH+23,	8},
	{gaSNUMMATH+25,	10},
	{gaSNUMMATH+2,	82}, // +141: state 58 transitions
	{gaSNUMMATH+5,	83},
	{gaSNUMMATH+29,	84}, // +143: state 59 transitions
	{gaSNUMMATH+5,	85},
	{gaSNUMMATH+5,	86}, // +145: state 60 transitions
	{gaSNUMMATH+16,	58}, // +146: state 61 transitions
	{gaSNUMMATH+21,	59},
	{gaSNUMMATH+23,	60},
	{gaSNUMMATH+5,	87},
	{gaSNUMMATH+2,	88}, // +150: state 62 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+5,	64}, // +152: state 63 transitions
	{gaSNUMMATH+21,	90}, // +153: state 64 transitions
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+5,	92},
	{gaSNUMMATH+16,	40}, // +156: state 65 transitions
	{gaSNUMMATH+16,	40}, // +157: state 66 transitions
	{gaSNUMMATH+5,	66},
	{gaSNUMMATH+5,	93}, // +159: state 67 transitions
	{gaSNUMMATH+16,	40}, // +160: state 68 transitions
	{gaSNUMMATH+21,	41},
	{gaSNUMMATH+23,	42},
	{gaSNUMMATH+5,	94},
	{gaSNUMMATH+31,	18}, // +164: state 69 transitions
	{gaSNUMMATH+31,	18}, // +165: state 70 transitions
	{gaSNUMMATH+5,	70},
	{gaSNUMMATH+5,	95}, // +167: state 71 transitions
	{gaSNUMMATH+31,	18}, // +168: state 72 transitions
	{gaSNUMMATH+21,	44},
	{gaSNUMMATH+23,	45},
	{gaSNUMMATH+5,	96},
	{gaSNUMMATH+16,	11}, // +172: state 73 transitions
	{gaSNUMMATH+21,	12},
	{gaSNUMMATH+23,	13},
	{gaSNUMMATH+5,	75}, // +175: state 74 transitions
	{gaSNUMMATH+31,	53}, // +176: state 75 transitions
	{gaSNUMMATH+21,	97},
	{gaSNUMMATH+23,	98},
	{gaSNUMMATH+5,	99},
	{gaSNUMMATH+16,	49}, // +180: state 76 transitions
	{gaSNUMMATH+16,	49}, // +181: state 77 transitions
	{gaSNUMMATH+5,	77},
	{gaSNUMMATH+5,	100}, // +183: state 78 transitions
	{gaSNUMMATH+16,	49}, // +184: state 79 transitions
	{gaSNUMMATH+21,	50},
	{gaSNUMMATH+23,	51},
	{gaSNUMMATH+5,	101},
	{gaSNUMMATH+5,	102}, // +188: state 80 transitions
	{gaSNUMMATH+25,	10}, // +189: state 81 transitions
	{gaSNUMMATH+21,	33},
	{gaSNUMMATH+5,	81},
	{gaSNUMMATH+5,	83}, // +192: state 82 transitions
	{gaSNUMMATH+31,	65}, // +193: state 83 transitions
	{gaSNUMMATH+21,	103},
	{gaSNUMMATH+23,	104},
	{gaSNUMMATH+5,	105},
	{gaSNUMMATH+16,	58}, // +197: state 84 transitions
	{gaSNUMMATH+16,	58}, // +198: state 85 transitions
	{gaSNUMMATH+5,	85},
	{gaSNUMMATH+5,	106}, // +200: state 86 transitions
	{gaSNUMMATH+16,	58}, // +201: state 87 transitions
	{gaSNUMMATH+21,	59},
	{gaSNUMMATH+23,	60},
	{gaSNUMMATH+5,	107},
	{gaSNUMMATH+5,	89}, // +205: state 88 transitions
	{gaSNUMMATH+16,	108}, // +206: state 89 transitions
	{gaSNUMMATH+21,	109},
	{gaSNUMMATH+23,	110},
	{gaSNUMMATH+5,	111},
	{gaSNUMMATH+29,	112}, // +210: state 90 transitions
	{gaSNUMMATH+5,	113},
	{gaSNUMMATH+5,	114}, // +212: state 91 transitions
	{gaSNUMMATH+21,	90}, // +213: state 92 transitions
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+5,	115},
	{gaSNUMMATH+5,	116}, // +216: state 93 transitions
	{gaSNUMMATH+16,	40}, // +217: state 94 transitions
	{gaSNUMMATH+21,	41},
	{gaSNUMMATH+5,	94},
	{gaSNUMMATH+5,	117}, // +220: state 95 transitions
	{gaSNUMMATH+31,	18}, // +221: state 96 transitions
	{gaSNUMMATH+21,	44},
	{gaSNUMMATH+5,	96},
	{gaSNUMMATH+29,	118}, // +224: state 97 transitions
	{gaSNUMMATH+5,	119},
	{gaSNUMMATH+5,	120}, // +226: state 98 transitions
	{gaSNUMMATH+31,	53}, // +227: state 99 transitions
	{gaSNUMMATH+21,	97},
	{gaSNUMMATH+23,	98},
	{gaSNUMMATH+5,	121},
	{gaSNUMMATH+5,	122}, // +231: state 100 transitions
	{gaSNUMMATH+16,	49}, // +232: state 101 transitions
	{gaSNUMMATH+21,	50},
	{gaSNUMMATH+5,	101},
	{gaSNUMMATH+25,	10}, // +235: state 102 transitions
	{gaSNUMMATH+21,	33},
	{gaSNUMMATH+23,	34},
	{gaSNUMMATH+29,	123}, // +238: state 103 transitions
	{gaSNUMMATH+5,	124},
	{gaSNUMMATH+5,	125}, // +240: state 104 transitions
	{gaSNUMMATH+31,	65}, // +241: state 105 transitions
	{gaSNUMMATH+21,	103},
	{gaSNUMMATH+23,	104},
	{gaSNUMMATH+5,	126},
	{gaSNUMMATH+5,	127}, // +245: state 106 transitions
	{gaSNUMMATH+16,	58}, // +246: state 107 transitions
	{gaSNUMMATH+21,	59},
	{gaSNUMMATH+5,	107},
	{gaSNUMMATH+2,	128}, // +249: state 108 transitions
	{gaSNUMMATH+5,	129},
	{gaSNUMMATH+29,	130}, // +251: state 109 transitions
	{gaSNUMMATH+5,	131},
	{gaSNUMMATH+5,	132}, // +253: state 110 transitions
	{gaSNUMMATH+16,	108}, // +254: state 111 transitions
	{gaSNUMMATH+21,	109},
	{gaSNUMMATH+23,	110},
	{gaSNUMMATH+5,	133},
	{gaSNUMMATH+5,	113}, // +258: state 113 transitions
	{gaSNUMMATH+5,	134}, // +259: state 114 transitions
	{gaSNUMMATH+21,	90}, // +260: state 115 transitions
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+5,	135},
	{gaSNUMMATH+16,	40}, // +263: state 116 transitions
	{gaSNUMMATH+21,	41},
	{gaSNUMMATH+23,	42},
	{gaSNUMMATH+31,	18}, // +266: state 117 transitions
	{gaSNUMMATH+21,	44},
	{gaSNUMMATH+23,	45},
	{gaSNUMMATH+31,	53}, // +269: state 118 transitions
	{gaSNUMMATH+31,	53}, // +270: state 119 transitions
	{gaSNUMMATH+5,	119},
	{gaSNUMMATH+5,	136}, // +272: state 120 transitions
	{gaSNUMMATH+31,	53}, // +273: state 121 transitions
	{gaSNUMMATH+21,	97},
	{gaSNUMMATH+23,	98},
	{gaSNUMMATH+5,	137},
	{gaSNUMMATH+16,	49}, // +277: state 122 transitions
	{gaSNUMMATH+21,	50},
	{gaSNUMMATH+23,	51},
	{gaSNUMMATH+31,	65}, // +280: state 123 transitions
	{gaSNUMMATH+31,	65}, // +281: state 124 transitions
	{gaSNUMMATH+5,	124},
	{gaSNUMMATH+5,	138}, // +283: state 125 transitions
	{gaSNUMMATH+31,	65}, // +284: state 126 transitions
	{gaSNUMMATH+21,	103},
	{gaSNUMMATH+23,	104},
	{gaSNUMMATH+5,	139},
	{gaSNUMMATH+16,	58}, // +288: state 127 transitions
	{gaSNUMMATH+21,	59},
	{gaSNUMMATH+23,	60},
	{gaSNUMMATH+5,	129}, // +291: state 128 transitions
	{gaSNUMMATH+31,	112}, // +292: state 129 transitions
	{gaSNUMMATH+21,	140},
	{gaSNUMMATH+23,	141},
	{gaSNUMMATH+5,	142},
	{gaSNUMMATH+16,	108}, // +296: state 130 transitions
	{gaSNUMMATH+16,	108}, // +297: state 131 transitions
	{gaSNUMMATH+5,	131},
	{gaSNUMMATH+5,	143}, // +299: state 132 transitions
	{gaSNUMMATH+16,	108}, // +300: state 133 transitions
	{gaSNUMMATH+21,	109},
	{gaSNUMMATH+23,	110},
	{gaSNUMMATH+5,	144},
	{gaSNUMMATH+5,	145}, // +304: state 134 transitions
	{gaSNUMMATH+21,	90}, // +305: state 135 transitions
	{gaSNUMMATH+5,	135},
	{gaSNUMMATH+5,	146}, // +307: state 136 transitions
	{gaSNUMMATH+31,	53}, // +308: state 137 transitions
	{gaSNUMMATH+21,	97},
	{gaSNUMMATH+5,	137},
	{gaSNUMMATH+5,	147}, // +311: state 138 transitions
	{gaSNUMMATH+31,	65}, // +312: state 139 transitions
	{gaSNUMMATH+21,	103},
	{gaSNUMMATH+5,	139},
	{gaSNUMMATH+29,	148}, // +315: state 140 transitions
	{gaSNUMMATH+5,	149},
	{gaSNUMMATH+5,	150}, // +317: state 141 transitions
	{gaSNUMMATH+31,	112}, // +318: state 142 transitions
	{gaSNUMMATH+21,	140},
	{gaSNUMMATH+23,	141},
	{gaSNUMMATH+5,	151},
	{gaSNUMMATH+5,	152}, // +322: state 143 transitions
	{gaSNUMMATH+16,	108}, // +323: state 144 transitions
	{gaSNUMMATH+21,	109},
	{gaSNUMMATH+5,	144},
	{gaSNUMMATH+21,	90}, // +326: state 145 transitions
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+31,	53}, // +328: state 146 transitions
	{gaSNUMMATH+21,	97},
	{gaSNUMMATH+23,	98},
	{gaSNUMMATH+31,	65}, // +331: state 147 transitions
	{gaSNUMMATH+21,	103},
	{gaSNUMMATH+23,	104},
	{gaSNUMMATH+31,	112}, // +334: state 148 transitions
	{gaSNUMMATH+31,	112}, // +335: state 149 transitions
	{gaSNUMMATH+5,	149},
	{gaSNUMMATH+5,	153}, // +337: state 150 transitions
	{gaSNUMMATH+31,	112}, // +338: state 151 transitions
	{gaSNUMMATH+21,	140},
	{gaSNUMMATH+23,	141},
	{gaSNUMMATH+5,	154},
	{gaSNUMMATH+16,	108}, // +342: state 152 transitions
	{gaSNUMMATH+21,	109},
	{gaSNUMMATH+23,	110},
	{gaSNUMMATH+5,	155}, // +345: state 153 transitions
	{gaSNUMMATH+31,	112}, // +346: state 154 transitions
	{gaSNUMMATH+21,	140},
	{gaSNUMMATH+5,	154},
	{gaSNUMMATH+31,	112}, // +349: state 155 transitions
	{gaSNUMMATH+21,	140},
	{gaSNUMMATH+23,	141},
};

const STATE_DESCRIPTION aStateDescNUMMATH[156] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMMATH+0},
	/*   1 */ {0, 2, gaTNUMMATH+3},
	/*   2 */ {0, 1, gaTNUMMATH+5},
	/*   3 */ {1, 5, gaTNUMMATH+6},
	/*   4 */ {0, 1, gaTNUMMATH+11},
	/*   5 */ {0, 4, gaTNUMMATH+12},
	/*   6 */ {0, 3, gaTNUMMATH+16},
	/*   7 */ {0, 2, gaTNUMMATH+19},
	/*   8 */ {0, 1, gaTNUMMATH+21},
	/*   9 */ {1, 5, gaTNUMMATH+22},
	/*  10 */ {0, 3, gaTNUMMATH+27},
	/*  11 */ {0, 2, gaTNUMMATH+30},
	/*  12 */ {0, 2, gaTNUMMATH+32},
	/*  13 */ {0, 1, gaTNUMMATH+34},
	/*  14 */ {0, 4, gaTNUMMATH+35},
	/*  15 */ {0, 2, gaTNUMMATH+39},
	/*  16 */ {0, 1, gaTNUMMATH+41},
	/*  17 */ {1, 4, gaTNUMMATH+42},
	/*  18 */ {1, 2, gaTNUMMATH+46},
	/*  19 */ {1, 3, gaTNUMMATH+48},
	/*  20 */ {0, 1, gaTNUMMATH+51},
	/*  21 */ {1, 5, gaTNUMMATH+52},
	/*  22 */ {0, 2, gaTNUMMATH+57},
	/*  23 */ {0, 1, gaTNUMMATH+59},
	/*  24 */ {1, 4, gaTNUMMATH+60},
	/*  25 */ {0, 1, gaTNUMMATH+64},
	/*  26 */ {0, 4, gaTNUMMATH+65},
	/*  27 */ {0, 1, gaTNUMMATH+69},
	/*  28 */ {0, 2, gaTNUMMATH+70},
	/*  29 */ {0, 1, gaTNUMMATH+72},
	/*  30 */ {0, 4, gaTNUMMATH+73},
	/*  31 */ {0, 1, gaTNUMMATH+77},
	/*  32 */ {0, 4, gaTNUMMATH+78},
	/*  33 */ {0, 2, gaTNUMMATH+82},
	/*  34 */ {0, 1, gaTNUMMATH+84},
	/*  35 */ {1, 4, gaTNUMMATH+85},
	/*  36 */ {0, 1, gaTNUMMATH+89},
	/*  37 */ {1, 4, gaTNUMMATH+90},
	/*  38 */ {0, 1, gaTNUMMATH+94},
	/*  39 */ {0, 4, gaTNUMMATH+95},
	/*  40 */ {0, 3, gaTNUMMATH+99},
	/*  41 */ {0, 2, gaTNUMMATH+102},
	/*  42 */ {0, 1, gaTNUMMATH+104},
	/*  43 */ {1, 4, gaTNUMMATH+105},
	/*  44 */ {0, 2, gaTNUMMATH+109},
	/*  45 */ {0, 1, gaTNUMMATH+111},
	/*  46 */ {0, 4, gaTNUMMATH+112},
	/*  47 */ {0, 1, gaTNUMMATH+116},
	/*  48 */ {0, 3, gaTNUMMATH+117},
	/*  49 */ {0, 2, gaTNUMMATH+120},
	/*  50 */ {0, 2, gaTNUMMATH+122},
	/*  51 */ {0, 1, gaTNUMMATH+124},
	/*  52 */ {0, 4, gaTNUMMATH+125},
	/*  53 */ {1, 1, gaTNUMMATH+129},
	/*  54 */ {1, 2, gaTNUMMATH+130},
	/*  55 */ {0, 1, gaTNUMMATH+132},
	/*  56 */ {1, 4, gaTNUMMATH+133},
	/*  57 */ {1, 4, gaTNUMMATH+137},
	/*  58 */ {0, 2, gaTNUMMATH+141},
	/*  59 */ {0, 2, gaTNUMMATH+143},
	/*  60 */ {0, 1, gaTNUMMATH+145},
	/*  61 */ {0, 4, gaTNUMMATH+146},
	/*  62 */ {0, 2, gaTNUMMATH+150},
	/*  63 */ {0, 1, gaTNUMMATH+152},
	/*  64 */ {1, 3, gaTNUMMATH+153},
	/*  65 */ {1, 1, gaTNUMMATH+156},
	/*  66 */ {1, 2, gaTNUMMATH+157},
	/*  67 */ {0, 1, gaTNUMMATH+159},
	/*  68 */ {1, 4, gaTNUMMATH+160},
	/*  69 */ {0, 1, gaTNUMMATH+164},
	/*  70 */ {0, 2, gaTNUMMATH+165},
	/*  71 */ {0, 1, gaTNUMMATH+167},
	/*  72 */ {0, 4, gaTNUMMATH+168},
	/*  73 */ {0, 3, gaTNUMMATH+172},
	/*  74 */ {0, 1, gaTNUMMATH+175},
	/*  75 */ {0, 4, gaTNUMMATH+176},
	/*  76 */ {0, 1, gaTNUMMATH+180},
	/*  77 */ {0, 2, gaTNUMMATH+181},
	/*  78 */ {0, 1, gaTNUMMATH+183},
	/*  79 */ {0, 4, gaTNUMMATH+184},
	/*  80 */ {0, 1, gaTNUMMATH+188},
	/*  81 */ {1, 3, gaTNUMMATH+189},
	/*  82 */ {0, 1, gaTNUMMATH+192},
	/*  83 */ {0, 4, gaTNUMMATH+193},
	/*  84 */ {0, 1, gaTNUMMATH+197},
	/*  85 */ {0, 2, gaTNUMMATH+198},
	/*  86 */ {0, 1, gaTNUMMATH+200},
	/*  87 */ {0, 4, gaTNUMMATH+201},
	/*  88 */ {0, 1, gaTNUMMATH+205},
	/*  89 */ {0, 4, gaTNUMMATH+206},
	/*  90 */ {0, 2, gaTNUMMATH+210},
	/*  91 */ {0, 1, gaTNUMMATH+212},
	/*  92 */ {1, 3, gaTNUMMATH+213},
	/*  93 */ {0, 1, gaTNUMMATH+216},
	/*  94 */ {1, 3, gaTNUMMATH+217},
	/*  95 */ {0, 1, gaTNUMMATH+220},
	/*  96 */ {0, 3, gaTNUMMATH+221},
	/*  97 */ {0, 2, gaTNUMMATH+224},
	/*  98 */ {0, 1, gaTNUMMATH+226},
	/*  99 */ {0, 4, gaTNUMMATH+227},
	/* 100 */ {0, 1, gaTNUMMATH+231},
	/* 101 */ {0, 3, gaTNUMMATH+232},
	/* 102 */ {1, 3, gaTNUMMATH+235},
	/* 103 */ {0, 2, gaTNUMMATH+238},
	/* 104 */ {0, 1, gaTNUMMATH+240},
	/* 105 */ {0, 4, gaTNUMMATH+241},
	/* 106 */ {0, 1, gaTNUMMATH+245},
	/* 107 */ {0, 3, gaTNUMMATH+246},
	/* 108 */ {0, 2, gaTNUMMATH+249},
	/* 109 */ {0, 2, gaTNUMMATH+251},
	/* 110 */ {0, 1, gaTNUMMATH+253},
	/* 111 */ {0, 4, gaTNUMMATH+254},
	/* 112 */ {1, 0, NULL},
	/* 113 */ {1, 1, gaTNUMMATH+258},
	/* 114 */ {0, 1, gaTNUMMATH+259},
	/* 115 */ {1, 3, gaTNUMMATH+260},
	/* 116 */ {1, 3, gaTNUMMATH+263},
	/* 117 */ {0, 3, gaTNUMMATH+266},
	/* 118 */ {0, 1, gaTNUMMATH+269},
	/* 119 */ {0, 2, gaTNUMMATH+270},
	/* 120 */ {0, 1, gaTNUMMATH+272},
	/* 121 */ {0, 4, gaTNUMMATH+273},
	/* 122 */ {0, 3, gaTNUMMATH+277},
	/* 123 */ {0, 1, gaTNUMMATH+280},
	/* 124 */ {0, 2, gaTNUMMATH+281},
	/* 125 */ {0, 1, gaTNUMMATH+283},
	/* 126 */ {0, 4, gaTNUMMATH+284},
	/* 127 */ {0, 3, gaTNUMMATH+288},
	/* 128 */ {0, 1, gaTNUMMATH+291},
	/* 129 */ {0, 4, gaTNUMMATH+292},
	/* 130 */ {0, 1, gaTNUMMATH+296},
	/* 131 */ {0, 2, gaTNUMMATH+297},
	/* 132 */ {0, 1, gaTNUMMATH+299},
	/* 133 */ {0, 4, gaTNUMMATH+300},
	/* 134 */ {0, 1, gaTNUMMATH+304},
	/* 135 */ {1, 2, gaTNUMMATH+305},
	/* 136 */ {0, 1, gaTNUMMATH+307},
	/* 137 */ {0, 3, gaTNUMMATH+308},
	/* 138 */ {0, 1, gaTNUMMATH+311},
	/* 139 */ {0, 3, gaTNUMMATH+312},
	/* 140 */ {0, 2, gaTNUMMATH+315},
	/* 141 */ {0, 1, gaTNUMMATH+317},
	/* 142 */ {0, 4, gaTNUMMATH+318},
	/* 143 */ {0, 1, gaTNUMMATH+322},
	/* 144 */ {0, 3, gaTNUMMATH+323},
	/* 145 */ {1, 2, gaTNUMMATH+326},
	/* 146 */ {0, 3, gaTNUMMATH+328},
	/* 147 */ {0, 3, gaTNUMMATH+331},
	/* 148 */ {0, 1, gaTNUMMATH+334},
	/* 149 */ {0, 2, gaTNUMMATH+335},
	/* 150 */ {0, 1, gaTNUMMATH+337},
	/* 151 */ {0, 4, gaTNUMMATH+338},
	/* 152 */ {0, 3, gaTNUMMATH+342},
	/* 153 */ {0, 1, gaTNUMMATH+345},
	/* 154 */ {0, 3, gaTNUMMATH+346},
	/* 155 */ {0, 3, gaTNUMMATH+349},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = hour

// 4 states

static const unsigned char gaSHOUR[] = 
	/* gaStringHOUR+0 */	"01\000"
	/* gaStringHOUR+3 */	"2\000"
	/* gaStringHOUR+5 */	"3456789\000"
	/* gaStringHOUR+13 */	"0123456789\000"
	/* gaStringHOUR+24 */	"01234\000"
;

static const STATE_TRANSITION gaTHOUR[] = {
	{gaSHOUR+0,	1}, // +0: state 0 transitions
	{gaSHOUR+3,	2},
	{gaSHOUR+5,	3},
	{gaSHOUR+13,	3}, // +3: state 1 transitions
	{gaSHOUR+24,	3}, // +4: state 2 transitions
};

const STATE_DESCRIPTION aStateDescHOUR[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTHOUR+0},
	/*   1 */ {1, 1, gaTHOUR+3},
	/*   2 */ {1, 1, gaTHOUR+4},
	/*   3 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = minute

// 3 states

static const unsigned char gaSMINUTE[] = 
	/* gaStringMINUTE+0 */	"012345\000"
	/* gaStringMINUTE+7 */	"6789\000"
	/* gaStringMINUTE+12 */	"0123456789\000"
;

static const STATE_TRANSITION gaTMINUTE[] = {
	{gaSMINUTE+0,	1}, // +0: state 0 transitions
	{gaSMINUTE+7,	2},
	{gaSMINUTE+12,	2}, // +2: state 1 transitions
};

const STATE_DESCRIPTION aStateDescMINUTE[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTMINUTE+0},
	/*   1 */ {1, 1, gaTMINUTE+2},
	/*   2 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = second

// 3 states

static const unsigned char gaSSECOND[] = 
	/* gaStringSECOND+0 */	"012345\000"
	/* gaStringSECOND+7 */	"6789\000"
	/* gaStringSECOND+12 */	"0123456789\000"
;

static const STATE_TRANSITION gaTSECOND[] = {
	{gaSSECOND+0,	1}, // +0: state 0 transitions
	{gaSSECOND+7,	2},
	{gaSSECOND+12,	2}, // +2: state 1 transitions
};

const STATE_DESCRIPTION aStateDescSECOND[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTSECOND+0},
	/*   1 */ {1, 1, gaTSECOND+2},
	/*   2 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = year

// 6 states

static const unsigned char gaSYEAR[] = 
	/* gaStringYEAR+0 */	"'\000"
	/* gaStringYEAR+2 */	"0123456789\000"
;

static const STATE_TRANSITION gaTYEAR[] = {
	{gaSYEAR+0,	1}, // +0: state 0 transitions
	{gaSYEAR+2,	2},
	{gaSYEAR+2,	3}, // +2: state 1 transitions
	{gaSYEAR+2,	4}, // +3: state 2 transitions
	{gaSYEAR+2,	5}, // +4: state 3 transitions
	{gaSYEAR+2,	3}, // +5: state 4 transitions
};

const STATE_DESCRIPTION aStateDescYEAR[6] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTYEAR+0},
	/*   1 */ {0, 1, gaTYEAR+2},
	/*   2 */ {0, 1, gaTYEAR+3},
	/*   3 */ {0, 1, gaTYEAR+4},
	/*   4 */ {1, 1, gaTYEAR+5},
	/*   5 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = monthnum

// 4 states

static const unsigned char gaSMONTHNUM[] = 
	/* gaStringMONTHNUM+0 */	"0\000"
	/* gaStringMONTHNUM+2 */	"1\000"
	/* gaStringMONTHNUM+4 */	"23456789\000"
	/* gaStringMONTHNUM+13 */	"123456789\000"
	/* gaStringMONTHNUM+23 */	"012\000"
;

static const STATE_TRANSITION gaTMONTHNUM[] = {
	{gaSMONTHNUM+0,	1}, // +0: state 0 transitions
	{gaSMONTHNUM+2,	2},
	{gaSMONTHNUM+4,	3},
	{gaSMONTHNUM+13,	3}, // +3: state 1 transitions
	{gaSMONTHNUM+23,	3}, // +4: state 2 transitions
};

const STATE_DESCRIPTION aStateDescMONTHNUM[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTMONTHNUM+0},
	/*   1 */ {0, 1, gaTMONTHNUM+3},
	/*   2 */ {1, 1, gaTMONTHNUM+4},
	/*   3 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = dayofmonth

// 5 states

static const unsigned char gaSDAYOFMONTH[] = 
	/* gaStringDAYOFMONTH+0 */	"0\000"
	/* gaStringDAYOFMONTH+2 */	"12\000"
	/* gaStringDAYOFMONTH+5 */	"3\000"
	/* gaStringDAYOFMONTH+7 */	"456789\000"
	/* gaStringDAYOFMONTH+14 */	"123456789\000"
	/* gaStringDAYOFMONTH+24 */	"0123456789\000"
	/* gaStringDAYOFMONTH+35 */	"01\000"
;

static const STATE_TRANSITION gaTDAYOFMONTH[] = {
	{gaSDAYOFMONTH+0,	1}, // +0: state 0 transitions
	{gaSDAYOFMONTH+2,	2},
	{gaSDAYOFMONTH+5,	3},
	{gaSDAYOFMONTH+7,	4},
	{gaSDAYOFMONTH+14,	4}, // +4: state 1 transitions
	{gaSDAYOFMONTH+24,	4}, // +5: state 2 transitions
	{gaSDAYOFMONTH+35,	4}, // +6: state 3 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFMONTH[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTDAYOFMONTH+0},
	/*   1 */ {0, 1, gaTDAYOFMONTH+4},
	/*   2 */ {1, 1, gaTDAYOFMONTH+5},
	/*   3 */ {1, 1, gaTDAYOFMONTH+6},
	/*   4 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = creditcard

// 20 states

static const unsigned char gaSCREDITCARD[] = 
	/* gaStringCREDITCARD+0 */	"0123456789\000"
	/* gaStringCREDITCARD+11 */	" \000"
;

static const STATE_TRANSITION gaTCREDITCARD[] = {
	{gaSCREDITCARD+0,	1}, // +0: state 0 transitions
	{gaSCREDITCARD+0,	2}, // +1: state 1 transitions
	{gaSCREDITCARD+0,	3}, // +2: state 2 transitions
	{gaSCREDITCARD+0,	4}, // +3: state 3 transitions
	{gaSCREDITCARD+11,	5}, // +4: state 4 transitions
	{gaSCREDITCARD+0,	6}, // +5: state 5 transitions
	{gaSCREDITCARD+0,	7}, // +6: state 6 transitions
	{gaSCREDITCARD+0,	8}, // +7: state 7 transitions
	{gaSCREDITCARD+0,	9}, // +8: state 8 transitions
	{gaSCREDITCARD+11,	10}, // +9: state 9 transitions
	{gaSCREDITCARD+0,	11}, // +10: state 10 transitions
	{gaSCREDITCARD+0,	12}, // +11: state 11 transitions
	{gaSCREDITCARD+0,	13}, // +12: state 12 transitions
	{gaSCREDITCARD+0,	14}, // +13: state 13 transitions
	{gaSCREDITCARD+11,	15}, // +14: state 14 transitions
	{gaSCREDITCARD+0,	16}, // +15: state 15 transitions
	{gaSCREDITCARD+0,	17}, // +16: state 16 transitions
	{gaSCREDITCARD+0,	18}, // +17: state 17 transitions
	{gaSCREDITCARD+0,	19}, // +18: state 18 transitions
};

const STATE_DESCRIPTION aStateDescCREDITCARD[20] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTCREDITCARD+0},
	/*   1 */ {0, 1, gaTCREDITCARD+1},
	/*   2 */ {0, 1, gaTCREDITCARD+2},
	/*   3 */ {0, 1, gaTCREDITCARD+3},
	/*   4 */ {0, 1, gaTCREDITCARD+4},
	/*   5 */ {0, 1, gaTCREDITCARD+5},
	/*   6 */ {0, 1, gaTCREDITCARD+6},
	/*   7 */ {0, 1, gaTCREDITCARD+7},
	/*   8 */ {0, 1, gaTCREDITCARD+8},
	/*   9 */ {0, 1, gaTCREDITCARD+9},
	/*  10 */ {0, 1, gaTCREDITCARD+10},
	/*  11 */ {0, 1, gaTCREDITCARD+11},
	/*  12 */ {0, 1, gaTCREDITCARD+12},
	/*  13 */ {0, 1, gaTCREDITCARD+13},
	/*  14 */ {0, 1, gaTCREDITCARD+14},
	/*  15 */ {0, 1, gaTCREDITCARD+15},
	/*  16 */ {0, 1, gaTCREDITCARD+16},
	/*  17 */ {0, 1, gaTCREDITCARD+17},
	/*  18 */ {0, 1, gaTCREDITCARD+18},
	/*  19 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Tue Apr 23 18:28:06 2002

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "." ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," ( digit_seq | "-")] ;
// 
// numnum = "" digit_seq ;
// numnth = integer [rank] ;
// 
// numunit = numsimple space unit ;
// numunit = numsimple "" space ("C" | "F" ) ;
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = [dayofmonth "."] monthnum space year ;
// numdate = dayofmonth "." monthnum "." ;
// 
// numdate = digit digit digit digit "-" monthnum "-" dayofmonth ;
// 
// numdate = [weekday ","  space] dayofmonth period  monthnum  [space year ];
// numdate = [weekday ","  space "d" "e" "n" space] dayofmonth period  monthName  [space year] ;
// numdate = [weekday ","  space] dayofmonth period space  monthName  [space year ];
// numdate = year ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01" ;
// year = digit digit [digit digit] ;
// year = "'" digit2 ;
// 
// weekday = "M" "o" "n" "t" "a" "g" ;
// weekday = "D" "i" "e" "n" "s" "t" "a" "g" ;
// weekday = "M" "i" "t" "t" "w" "o" "c" "h" ;
// weekday = "D" "o" "n" "n" "e" "r" "s" "t" "a" "g" ;
// weekday =  "F" "r" "e" "i" "t" "a" "g" ;
// weekday = "S" "a" "m" "s" "t" "a" "g" ;
// weekday = "S" "o" "n" "n" "t" "a" "g" ;
// weekday = "M" "o" "." ;
// weekday = "D" "i" "." ;
// weekday = "M" "i" "." ;
// weekday = "D" "o" "." ;
// weekday = "F" "r" "." ;
// weekday = "S" "a" "." ;
// weekday = "S" "o" "." ;
// 
// 
// monthName = "J" "a" "n" "u" "a" "r" ;
// monthName = "J" "a" "n" "." ;
// monthName = "F" "e" "b" "r" "u" "a" "r" ;
// monthName = "F" "e" "b" "r" "." ;
// monthName = "M" "" "r" "z" ;
// monthName =  "M" "" "r" "." ;
// monthName = "A" "p" "r" "i" "l" ;
// monthName = "A" "p" "r" "." ;
// monthName = "M" "a" "i" ;
// monthName = "J" "u" "n"  "i";
// monthName = "J" "u" "n"  ".";
// monthName = "J" "u" "l" "i" ;
// monthName = "J" "u" "l" "." ;
// monthName = "A" "u" "g" "u" "s" "t" ;
// monthName = "A" "u" "g" "." ;
// monthName = "S" "e" "p" "t" "e" "m" "b" "e" "r" ;
// monthName = "S" "e" "p" "t" "." ;
// monthName = "O" "k" "t" "o" "b" "e" "r" ;
// monthName = "O" "k" "t" "." ;
// monthName = "N" "o" "v" "e" "m" "b" "e" "r" ;
// monthName = "N" "o" "v" "." ;
// monthName = "D" "e" "z" "e" "m" "b" "e" "r" ;
// monthName = "D" "e" "z" "." ;
// 
// 
// timeSep = ":" | "." ;
// numtime = hour timeSep minute [timeSep second]  ;
// numtime = hour timeSep minute [timeSep second] space "U" "h" "r" ;
// numtime = hour timeSep minute [timeSep second] "h" ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "D" "M" | "E" "U" "R" ["O"] ;
// numcurrency = numsimpleUnsigned ["," (digit2 | "-") ] space curSymbol ;
// numcurrency = curSymbol space numsimpleUnsigned ["," (digit2 | "-") ] ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// digit3 = digit digit digit;
// digit2_5 = digit2 [digit [digit [digit] ] ] ;
// digit3_6 = digit3 [digit [digit [digit] ] ] ;
// 
// countryCode = ("+" | "0" "0" ) digit2   ;
// areacodeIntl = "(" "0" ")" digit2_5  ;
// areacodeIntl = "(" digit3_6 ")" ;
// areacodeIntl = digit3_6  ;
// 
// areacode = "(" digit3_6 ")" space;
// areacode = digit3_6 "/"  ;
// 
// phoneOdd = digit3 [space digit2 [space digit2 [space digit2 ] ] ] ;
// phoneEven = digit2 space digit2 [space digit2 [space digit2 ] ] ;
// 
// phoneExtension = space "-" space digit [ digit [ digit ] ] ] ;
// 
// numPhoneDefault =  countryCode space areacodeIntl space  (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  areacode (phoneOdd | phoneEven)  [ phoneExtension ];
// numPhoneDefault =  digit2 space digit2 space digit2 [ phoneExtension ] ;
// 
// numphone = numPhoneDefault ;
// numphone = (phoneOdd | phoneEven) [ phoneExtension ];
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple plus numsimple ")" ;
// equals = "<>=" ;
// plus = "+-/*" ;
// 
// unitDistance =  ["mckK" ] "m"  ;
// unitDistance = ("z" | "Z") "o" "l" "l"  ;
// unitDistance = ("F" | "f" ) "u" "" ;
// unitDistance = ("M" | "m") "e" "i" "l" "e" ;
// 
// unitVolume =  ["mcd" ]"l" ;
// unitWeight =  ["mkc" ] "g" ;
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// 
// number = numsimple ;
// number = numnth ;
// number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numPhoneDefault ;
// number = nummath ;
// number = numnum ;
// = zip

// 6 states

static const unsigned char gaSZIP[] = 
	/* gaStringZIP+0 */	"0123456789\000"
;

static const STATE_TRANSITION gaTZIP[] = {
	{gaSZIP+0,	1}, // +0: state 0 transitions
	{gaSZIP+0,	2}, // +1: state 1 transitions
	{gaSZIP+0,	3}, // +2: state 2 transitions
	{gaSZIP+0,	4}, // +3: state 3 transitions
	{gaSZIP+0,	5}, // +4: state 4 transitions
};

const STATE_DESCRIPTION aStateDescZIP[6] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTZIP+0},
	/*   1 */ {0, 1, gaTZIP+1},
	/*   2 */ {0, 1, gaTZIP+2},
	/*   3 */ {0, 1, gaTZIP+3},
	/*   4 */ {0, 1, gaTZIP+4},
	/*   5 */ {1, 0, NULL},
};

// end of text generated by re2fsa

const STATE_DESCRIPTION *aStateDescSSN = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\number.h ===
// number.h
// Angshuman Guha, aguha
// Sep 18, 1998

#ifndef __INC_NUMBER_H
#define __INC_NUMBER_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescNUMBER[];
extern const STATE_DESCRIPTION aStateDescNUMSIMPLE[];
extern const STATE_DESCRIPTION aStateDescNUMNTH[];
extern const STATE_DESCRIPTION aStateDescNUMUNIT[];
extern const STATE_DESCRIPTION aStateDescNUMNUM[];
extern const STATE_DESCRIPTION aStateDescNUMPERCENT[];
extern const STATE_DESCRIPTION aStateDescNUMDATE[];
extern const STATE_DESCRIPTION aStateDescNUMTIME[];
extern const STATE_DESCRIPTION aStateDescNUMCURRENCY[];
extern const STATE_DESCRIPTION aStateDescNUMPHONE[];
extern const STATE_DESCRIPTION aStateDescNUMMATH[];
extern const STATE_DESCRIPTION aStateDescZIP[];
extern const STATE_DESCRIPTION aStateDescCREDITCARD[];
extern const STATE_DESCRIPTION aStateDescDAYOFMONTH[];
extern const STATE_DESCRIPTION aStateDescMONTHNUM[];
extern const STATE_DESCRIPTION aStateDescYEAR[];
extern const STATE_DESCRIPTION aStateDescSECOND[];
extern const STATE_DESCRIPTION aStateDescMINUTE[];
extern const STATE_DESCRIPTION aStateDescHOUR[];
extern const STATE_DESCRIPTION aStateDescSSN[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\prefix.c ===
// prefix.c
// Angshuman Guha
// aguha
// April 17, 2001

#include "common.h"
#include "prefix.h"

const STATE_DESCRIPTION *aStateDescPrefix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\prefix.h ===
// prefix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_PREFIX_H
#define __INC_PREFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescPrefix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\punc.h ===
// punc.h
// Angshuman Guha, aguha
// Sep 22, 1998
// Major mod Jan 10, 2001

#ifndef __INC_PUNC_H
#define __INC_PUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\shrtlist.c ===
// shrtlist.c  (factoids which are short lists of words)
//
// November 2001 (mrevow)
//

#include "common.h"
#include "shrtlist.h"

// text generated by re2fsa at Thu Nov 08 16:33:09 2001

// the input-file of rules:
// Montag
// Dienstag
// Mittwoch
// Donnerstag
// Freitag
// Samstag
// Sonntag
// Mo.
// Di.
// Mi.
// Do.
// Fr.
// Sa.
// So.

// 28 states

static const unsigned char gaSDAYOFWEEK[] = 
	/* gaStringDAYOFWEEK+0 */	"D\000"
	/* gaStringDAYOFWEEK+2 */	"F\000"
	/* gaStringDAYOFWEEK+4 */	"M\000"
	/* gaStringDAYOFWEEK+6 */	"S\000"
	/* gaStringDAYOFWEEK+8 */	"i\000"
	/* gaStringDAYOFWEEK+10 */	"o\000"
	/* gaStringDAYOFWEEK+12 */	"r\000"
	/* gaStringDAYOFWEEK+14 */	"a\000"
	/* gaStringDAYOFWEEK+16 */	".\000"
	/* gaStringDAYOFWEEK+18 */	"e\000"
	/* gaStringDAYOFWEEK+20 */	"n\000"
	/* gaStringDAYOFWEEK+22 */	"t\000"
	/* gaStringDAYOFWEEK+24 */	"m\000"
	/* gaStringDAYOFWEEK+26 */	"s\000"
	/* gaStringDAYOFWEEK+28 */	"w\000"
	/* gaStringDAYOFWEEK+30 */	"g\000"
	/* gaStringDAYOFWEEK+32 */	"c\000"
	/* gaStringDAYOFWEEK+34 */	"h\000"
;

static const STATE_TRANSITION gaTDAYOFWEEK[] = {
	{gaSDAYOFWEEK+0,	1}, // +0: state 0 transitions
	{gaSDAYOFWEEK+2,	2},
	{gaSDAYOFWEEK+4,	3},
	{gaSDAYOFWEEK+6,	4},
	{gaSDAYOFWEEK+8,	5}, // +4: state 1 transitions
	{gaSDAYOFWEEK+10,	6},
	{gaSDAYOFWEEK+12,	7}, // +6: state 2 transitions
	{gaSDAYOFWEEK+8,	8}, // +7: state 3 transitions
	{gaSDAYOFWEEK+10,	9},
	{gaSDAYOFWEEK+14,	10}, // +9: state 4 transitions
	{gaSDAYOFWEEK+10,	11},
	{gaSDAYOFWEEK+16,	12}, // +11: state 5 transitions
	{gaSDAYOFWEEK+18,	13},
	{gaSDAYOFWEEK+16,	12}, // +13: state 6 transitions
	{gaSDAYOFWEEK+20,	14},
	{gaSDAYOFWEEK+16,	12}, // +15: state 7 transitions
	{gaSDAYOFWEEK+18,	15},
	{gaSDAYOFWEEK+16,	12}, // +17: state 8 transitions
	{gaSDAYOFWEEK+22,	16},
	{gaSDAYOFWEEK+16,	12}, // +19: state 9 transitions
	{gaSDAYOFWEEK+20,	17},
	{gaSDAYOFWEEK+16,	12}, // +21: state 10 transitions
	{gaSDAYOFWEEK+24,	18},
	{gaSDAYOFWEEK+16,	12}, // +23: state 11 transitions
	{gaSDAYOFWEEK+20,	19},
	{gaSDAYOFWEEK+20,	18}, // +25: state 13 transitions
	{gaSDAYOFWEEK+20,	20}, // +26: state 14 transitions
	{gaSDAYOFWEEK+8,	17}, // +27: state 15 transitions
	{gaSDAYOFWEEK+22,	21}, // +28: state 16 transitions
	{gaSDAYOFWEEK+22,	22}, // +29: state 17 transitions
	{gaSDAYOFWEEK+26,	17}, // +30: state 18 transitions
	{gaSDAYOFWEEK+20,	17}, // +31: state 19 transitions
	{gaSDAYOFWEEK+18,	23}, // +32: state 20 transitions
	{gaSDAYOFWEEK+28,	24}, // +33: state 21 transitions
	{gaSDAYOFWEEK+14,	25}, // +34: state 22 transitions
	{gaSDAYOFWEEK+12,	18}, // +35: state 23 transitions
	{gaSDAYOFWEEK+10,	26}, // +36: state 24 transitions
	{gaSDAYOFWEEK+30,	12}, // +37: state 25 transitions
	{gaSDAYOFWEEK+32,	27}, // +38: state 26 transitions
	{gaSDAYOFWEEK+34,	12}, // +39: state 27 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFWEEK[28] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTDAYOFWEEK+0},
	/*   1 */ {0, 2, gaTDAYOFWEEK+4},
	/*   2 */ {0, 1, gaTDAYOFWEEK+6},
	/*   3 */ {0, 2, gaTDAYOFWEEK+7},
	/*   4 */ {0, 2, gaTDAYOFWEEK+9},
	/*   5 */ {0, 2, gaTDAYOFWEEK+11},
	/*   6 */ {0, 2, gaTDAYOFWEEK+13},
	/*   7 */ {0, 2, gaTDAYOFWEEK+15},
	/*   8 */ {0, 2, gaTDAYOFWEEK+17},
	/*   9 */ {0, 2, gaTDAYOFWEEK+19},
	/*  10 */ {0, 2, gaTDAYOFWEEK+21},
	/*  11 */ {0, 2, gaTDAYOFWEEK+23},
	/*  12 */ {1, 0, NULL},
	/*  13 */ {0, 1, gaTDAYOFWEEK+25},
	/*  14 */ {0, 1, gaTDAYOFWEEK+26},
	/*  15 */ {0, 1, gaTDAYOFWEEK+27},
	/*  16 */ {0, 1, gaTDAYOFWEEK+28},
	/*  17 */ {0, 1, gaTDAYOFWEEK+29},
	/*  18 */ {0, 1, gaTDAYOFWEEK+30},
	/*  19 */ {0, 1, gaTDAYOFWEEK+31},
	/*  20 */ {0, 1, gaTDAYOFWEEK+32},
	/*  21 */ {0, 1, gaTDAYOFWEEK+33},
	/*  22 */ {0, 1, gaTDAYOFWEEK+34},
	/*  23 */ {0, 1, gaTDAYOFWEEK+35},
	/*  24 */ {0, 1, gaTDAYOFWEEK+36},
	/*  25 */ {0, 1, gaTDAYOFWEEK+37},
	/*  26 */ {0, 1, gaTDAYOFWEEK+38},
	/*  27 */ {0, 1, gaTDAYOFWEEK+39},
};

// end of text generated by re2fsa
// text generated by re2fsa at Thu Nov 08 16:33:12 2001

// the input-file of rules:
// Januar
// Februar
// Mrz
// April
// Mai
// Juni
// Juli
// August
// September
// Oktober
// November
// Dezember
// Jan.
// Febr.
// Feb.
// Apr.
// Aug.
// Sept.
// Okt.
// Nov.
// Dez.
// 

// 37 states

static const unsigned char gaSMONTH[] = 
	/* gaStringMONTH+0 */	"A\000"
	/* gaStringMONTH+2 */	"D\000"
	/* gaStringMONTH+4 */	"F\000"
	/* gaStringMONTH+6 */	"J\000"
	/* gaStringMONTH+8 */	"M\000"
	/* gaStringMONTH+10 */	"N\000"
	/* gaStringMONTH+12 */	"O\000"
	/* gaStringMONTH+14 */	"S\000"
	/* gaStringMONTH+16 */	"p\000"
	/* gaStringMONTH+18 */	"u\000"
	/* gaStringMONTH+20 */	"e\000"
	/* gaStringMONTH+22 */	"a\000"
	/* gaStringMONTH+24 */	"\000"
	/* gaStringMONTH+26 */	"o\000"
	/* gaStringMONTH+28 */	"k\000"
	/* gaStringMONTH+30 */	"r\000"
	/* gaStringMONTH+32 */	"g\000"
	/* gaStringMONTH+34 */	"z\000"
	/* gaStringMONTH+36 */	"b\000"
	/* gaStringMONTH+38 */	"n\000"
	/* gaStringMONTH+40 */	"ln\000"
	/* gaStringMONTH+43 */	"i\000"
	/* gaStringMONTH+45 */	"v\000"
	/* gaStringMONTH+47 */	"t\000"
	/* gaStringMONTH+49 */	".\000"
	/* gaStringMONTH+51 */	"l\000"
	/* gaStringMONTH+53 */	"s\000"
	/* gaStringMONTH+55 */	"m\000"
;

static const STATE_TRANSITION gaTMONTH[] = {
	{gaSMONTH+0,	1}, // +0: state 0 transitions
	{gaSMONTH+2,	2},
	{gaSMONTH+4,	3},
	{gaSMONTH+6,	4},
	{gaSMONTH+8,	5},
	{gaSMONTH+10,	6},
	{gaSMONTH+12,	7},
	{gaSMONTH+14,	8},
	{gaSMONTH+16,	9}, // +8: state 1 transitions
	{gaSMONTH+18,	10},
	{gaSMONTH+20,	11}, // +10: state 2 transitions
	{gaSMONTH+20,	12}, // +11: state 3 transitions
	{gaSMONTH+22,	13}, // +12: state 4 transitions
	{gaSMONTH+18,	14},
	{gaSMONTH+22,	15}, // +14: state 5 transitions
	{gaSMONTH+24,	16},
	{gaSMONTH+26,	17}, // +16: state 6 transitions
	{gaSMONTH+28,	18}, // +17: state 7 transitions
	{gaSMONTH+20,	19}, // +18: state 8 transitions
	{gaSMONTH+30,	20}, // +19: state 9 transitions
	{gaSMONTH+32,	21}, // +20: state 10 transitions
	{gaSMONTH+34,	22}, // +21: state 11 transitions
	{gaSMONTH+36,	23}, // +22: state 12 transitions
	{gaSMONTH+38,	24}, // +23: state 13 transitions
	{gaSMONTH+40,	15}, // +24: state 14 transitions
	{gaSMONTH+43,	25}, // +25: state 15 transitions
	{gaSMONTH+30,	26}, // +26: state 16 transitions
	{gaSMONTH+45,	22}, // +27: state 17 transitions
	{gaSMONTH+47,	27}, // +28: state 18 transitions
	{gaSMONTH+16,	28}, // +29: state 19 transitions
	{gaSMONTH+49,	25}, // +30: state 20 transitions
	{gaSMONTH+43,	29},
	{gaSMONTH+49,	25}, // +32: state 21 transitions
	{gaSMONTH+18,	30},
	{gaSMONTH+49,	25}, // +34: state 22 transitions
	{gaSMONTH+20,	31},
	{gaSMONTH+30,	24}, // +36: state 23 transitions
	{gaSMONTH+49,	25},
	{gaSMONTH+49,	25}, // +38: state 24 transitions
	{gaSMONTH+18,	32},
	{gaSMONTH+34,	25}, // +40: state 26 transitions
	{gaSMONTH+49,	25}, // +41: state 27 transitions
	{gaSMONTH+26,	33},
	{gaSMONTH+47,	22}, // +43: state 28 transitions
	{gaSMONTH+51,	25}, // +44: state 29 transitions
	{gaSMONTH+53,	34}, // +45: state 30 transitions
	{gaSMONTH+55,	33}, // +46: state 31 transitions
	{gaSMONTH+22,	35}, // +47: state 32 transitions
	{gaSMONTH+36,	36}, // +48: state 33 transitions
	{gaSMONTH+47,	25}, // +49: state 34 transitions
	{gaSMONTH+30,	25}, // +50: state 35 transitions
	{gaSMONTH+20,	35}, // +51: state 36 transitions
};

const STATE_DESCRIPTION aStateDescMONTH[37] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 8, gaTMONTH+0},
	/*   1 */ {0, 2, gaTMONTH+8},
	/*   2 */ {0, 1, gaTMONTH+10},
	/*   3 */ {0, 1, gaTMONTH+11},
	/*   4 */ {0, 2, gaTMONTH+12},
	/*   5 */ {0, 2, gaTMONTH+14},
	/*   6 */ {0, 1, gaTMONTH+16},
	/*   7 */ {0, 1, gaTMONTH+17},
	/*   8 */ {0, 1, gaTMONTH+18},
	/*   9 */ {0, 1, gaTMONTH+19},
	/*  10 */ {0, 1, gaTMONTH+20},
	/*  11 */ {0, 1, gaTMONTH+21},
	/*  12 */ {0, 1, gaTMONTH+22},
	/*  13 */ {0, 1, gaTMONTH+23},
	/*  14 */ {0, 1, gaTMONTH+24},
	/*  15 */ {0, 1, gaTMONTH+25},
	/*  16 */ {0, 1, gaTMONTH+26},
	/*  17 */ {0, 1, gaTMONTH+27},
	/*  18 */ {0, 1, gaTMONTH+28},
	/*  19 */ {0, 1, gaTMONTH+29},
	/*  20 */ {0, 2, gaTMONTH+30},
	/*  21 */ {0, 2, gaTMONTH+32},
	/*  22 */ {0, 2, gaTMONTH+34},
	/*  23 */ {0, 2, gaTMONTH+36},
	/*  24 */ {0, 2, gaTMONTH+38},
	/*  25 */ {1, 0, NULL},
	/*  26 */ {0, 1, gaTMONTH+40},
	/*  27 */ {0, 2, gaTMONTH+41},
	/*  28 */ {0, 1, gaTMONTH+43},
	/*  29 */ {0, 1, gaTMONTH+44},
	/*  30 */ {0, 1, gaTMONTH+45},
	/*  31 */ {0, 1, gaTMONTH+46},
	/*  32 */ {0, 1, gaTMONTH+47},
	/*  33 */ {0, 1, gaTMONTH+48},
	/*  34 */ {0, 1, gaTMONTH+49},
	/*  35 */ {0, 1, gaTMONTH+50},
	/*  36 */ {0, 1, gaTMONTH+51},
};

// end of text generated by re2fsa
// text generated by re2fsa at Thu Nov 08 16:33:16 2001

// the input-file of rules:
// mnnlich 
// weiblich 
// mnnl.
// weibl.

// 12 states

static const unsigned char gaSGENDER[] = 
	/* gaStringGENDER+0 */	"m\000"
	/* gaStringGENDER+2 */	"w\000"
	/* gaStringGENDER+4 */	"\000"
	/* gaStringGENDER+6 */	"e\000"
	/* gaStringGENDER+8 */	"n\000"
	/* gaStringGENDER+10 */	"i\000"
	/* gaStringGENDER+12 */	"b\000"
	/* gaStringGENDER+14 */	"l\000"
	/* gaStringGENDER+16 */	".\000"
	/* gaStringGENDER+18 */	"c\000"
	/* gaStringGENDER+20 */	"h\000"
;

static const STATE_TRANSITION gaTGENDER[] = {
	{gaSGENDER+0,	1}, // +0: state 0 transitions
	{gaSGENDER+2,	2},
	{gaSGENDER+4,	3}, // +2: state 1 transitions
	{gaSGENDER+6,	4}, // +3: state 2 transitions
	{gaSGENDER+8,	5}, // +4: state 3 transitions
	{gaSGENDER+10,	6}, // +5: state 4 transitions
	{gaSGENDER+8,	7}, // +6: state 5 transitions
	{gaSGENDER+12,	7}, // +7: state 6 transitions
	{gaSGENDER+14,	8}, // +8: state 7 transitions
	{gaSGENDER+16,	9}, // +9: state 8 transitions
	{gaSGENDER+10,	10},
	{gaSGENDER+18,	11}, // +11: state 10 transitions
	{gaSGENDER+20,	9}, // +12: state 11 transitions
};

const STATE_DESCRIPTION aStateDescGENDER[12] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTGENDER+0},
	/*   1 */ {0, 1, gaTGENDER+2},
	/*   2 */ {0, 1, gaTGENDER+3},
	/*   3 */ {0, 1, gaTGENDER+4},
	/*   4 */ {0, 1, gaTGENDER+5},
	/*   5 */ {0, 1, gaTGENDER+6},
	/*   6 */ {0, 1, gaTGENDER+7},
	/*   7 */ {0, 1, gaTGENDER+8},
	/*   8 */ {0, 2, gaTGENDER+9},
	/*   9 */ {1, 0, NULL},
	/*  10 */ {0, 1, gaTGENDER+11},
	/*  11 */ {0, 1, gaTGENDER+12},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\punc.c ===
// punc.c
// Angshuman Guha
// aguha
// Jan 10, 2001

#include "common.h"
#include "punc.h"

// text generated by re2fsa at Thu Aug 02 13:27:47 2001

// the input-file of rules:
// punc = comma;
// punc = dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = colon;
// punc = semicolon;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = rparen;
// punc = rparen comma;
// punc = rparen dot;
// punc = rparen colon;
// punc = rparen semicolon;
// punc = rparen question;
// punc = rparen question question;
// punc = rparen question question question;
// punc = rparen bang;
// punc = rparen bang bang;
// punc = rparen bang bang bang;
// punc = rparen rparen;
// punc = rparen rparen comma;
// punc = rparen rparen dot;
// punc = rparen rparen colon;
// punc = rparen rparen semicolon;
// punc = rparen rparen question;
// punc = rparen rparen question question;
// punc = rparen rparen question question question;
// punc = rparen rparen bang;
// punc = rparen rparen bang bang;
// punc = rparen rparen bang bang bang;
// punc = comma rparen;
// punc = dot rparen;
// punc = colon rparen;
// punc = semicolon rparen;
// punc = question rparen;
// punc = question question rparen;
// punc = question question question rparen;
// punc = bang rparen;
// punc = bang bang rparen;
// punc = bang bang bang rparen;
// punc = dot dot dot rparen;
// punc = rbracket;
// punc = rbracket comma;
// punc = rbracket dot;
// punc = rbracket colon;
// punc = rbracket semicolon;
// punc = rbracket question;
// punc = rbracket question question;
// punc = rbracket question question question;
// punc = rbracket bang;
// punc = rbracket bang bang;
// punc = rbracket bang bang bang;
// punc = rbrace;
// punc = rbrace comma;
// punc = rbrace dot;
// punc = rbrace colon;
// punc = rbrace semicolon;
// punc = rbrace question;
// punc = rbrace question question;
// punc = rbrace question question question;
// punc = rbrace bang;
// punc = rbrace bang bang;
// punc = rbrace bang bang bang;
// punc = star;
// punc = star star;
// punc = star star star;
// punc = slash;
// punc = ampersand;
// punc = dollar;
// punc = dollar dollar;
// punc = dollar dollar dollar;
// punc = euro;
// punc = pound;
// punc = yen;
// punc = equals;
// punc = dquote;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = question question question question;
// punc = question question question question question;
// punc = bslash;
// punc = lessthan;
// punc = greaterthan;
// punc = plus;
// punc = tilde;
// punc = at;
// punc = circumflex;
// punc = star;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = bang bang bang bang;
// punc = bang bang bang bang bang;
// punc = hash;
// punc = lparen plus rparen;
// punc = lparen minus rparen;
// punc = dquote bquote dquote;
// punc = dquote tilde dquote;
// punc = dquote bang dquote;
// punc = dquote at dquote;
// punc = dquote hash dquote;
// punc = dquote dollar dquote;
// punc = dquote euro dquote;
// punc = dquote pound dquote;
// punc = dquote yen dquote;
// punc = dquote percent dquote;
// punc = dquote circumflex dquote;
// punc = dquote ampersand dquote;
// punc = dquote star dquote;
// punc = dquote lparen dquote;
// punc = dquote rparen dquote;
// punc = dquote minus dquote;
// punc = dquote uscore dquote;
// punc = dquote equals dquote;
// punc = dquote plus dquote;
// punc = dquote lbracket dquote;
// punc = dquote lbrace dquote;
// punc = dquote rbracket dquote;
// punc = dquote rbrace dquote;
// punc = dquote bslash dquote;
// punc = dquote semicolon dquote;
// punc = dquote colon dquote;
// punc = dquote squote dquote;
// punc = dquote dquote dquote;
// punc = dquote comma dquote;
// punc = dquote lessthan dquote;
// punc = dquote dot dquote;
// punc = dquote greaterthan dquote;
// punc = dquote slash dquote;
// punc = dquote question dquote;
// punc = minus;
// punc = minus minus;
// punc = minus minus minus;
// punc = minus minus minus minus;
// punc = minus minus minus minus minus;
// punc = uscore;
// punc = uscore uscore;
// punc = uscore uscore uscore;
// punc = uscore uscore uscore uscore;
// punc = uscore uscore uscore uscore uscore;
// punc = dot;
// punc = dot dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = dot dot dot dot dot;
// comma = ",";
// dot = ".";
// colon = ":";
// semicolon = ";";
// question = "?";
// bang = "!";
// rparen = ")";
// lparen = "(";
// rbracket = "]";
// lbracket = "[";
// rbrace = "}";
// lbrace = "{";
// dquote = "\"";
// squote = "'";
// bquote = "`";
// tilde = "~";
// at = "@";
// hash = "#";
// dollar = "$";
// percent = "%";
// circumflex = "^";
// ampersand = "&";
// star = "*";
// plus = "+";
// minus = "-";
// uscore = "_";
// lessthan = "<";
// greaterthan = ">";
// slash = "/";
// bslash = "\\";
// equals = "=";
// pound = "";
// yen = "";
// euro = "";
// = punc

// 35 states

static const unsigned char gaSPUNC[] = 
	/* gaStringPUNC+0 */	"!\000"
	/* gaStringPUNC+2 */	"\"\000"
	/* gaStringPUNC+4 */	"#&+/<=>@\\^~\000"
	/* gaStringPUNC+19 */	"$\000"
	/* gaStringPUNC+21 */	"(\000"
	/* gaStringPUNC+23 */	")\000"
	/* gaStringPUNC+25 */	"*\000"
	/* gaStringPUNC+27 */	",:;\000"
	/* gaStringPUNC+31 */	"-\000"
	/* gaStringPUNC+33 */	".\000"
	/* gaStringPUNC+35 */	"?\000"
	/* gaStringPUNC+37 */	"]}\000"
	/* gaStringPUNC+40 */	"_\000"
	/* gaStringPUNC+42 */	"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{}~\000"
	/* gaStringPUNC+77 */	"+-\000"
	/* gaStringPUNC+80 */	",.:;\000"
;

static const STATE_TRANSITION gaTPUNC[] = {
	{gaSPUNC+0,	1}, // +0: state 0 transitions
	{gaSPUNC+2,	2},
	{gaSPUNC+4,	3},
	{gaSPUNC+19,	4},
	{gaSPUNC+21,	5},
	{gaSPUNC+23,	6},
	{gaSPUNC+25,	7},
	{gaSPUNC+27,	8},
	{gaSPUNC+31,	9},
	{gaSPUNC+33,	10},
	{gaSPUNC+35,	11},
	{gaSPUNC+37,	12},
	{gaSPUNC+40,	13},
	{gaSPUNC+23,	3}, // +13: state 1 transitions
	{gaSPUNC+0,	14},
	{gaSPUNC+42,	15}, // +15: state 2 transitions
	{gaSPUNC+19,	16}, // +16: state 4 transitions
	{gaSPUNC+77,	17}, // +17: state 5 transitions
	{gaSPUNC+80,	3}, // +18: state 6 transitions
	{gaSPUNC+23,	12},
	{gaSPUNC+0,	18},
	{gaSPUNC+35,	19},
	{gaSPUNC+25,	20}, // +22: state 7 transitions
	{gaSPUNC+23,	3}, // +23: state 8 transitions
	{gaSPUNC+31,	21}, // +24: state 9 transitions
	{gaSPUNC+23,	3}, // +25: state 10 transitions
	{gaSPUNC+33,	22},
	{gaSPUNC+23,	3}, // +27: state 11 transitions
	{gaSPUNC+35,	23},
	{gaSPUNC+80,	3}, // +29: state 12 transitions
	{gaSPUNC+0,	18},
	{gaSPUNC+35,	19},
	{gaSPUNC+40,	24}, // +32: state 13 transitions
	{gaSPUNC+23,	3}, // +33: state 14 transitions
	{gaSPUNC+0,	25},
	{gaSPUNC+2,	3}, // +35: state 15 transitions
	{gaSPUNC+19,	3}, // +36: state 16 transitions
	{gaSPUNC+23,	3}, // +37: state 17 transitions
	{gaSPUNC+0,	26}, // +38: state 18 transitions
	{gaSPUNC+35,	27}, // +39: state 19 transitions
	{gaSPUNC+25,	3}, // +40: state 20 transitions
	{gaSPUNC+31,	28}, // +41: state 21 transitions
	{gaSPUNC+33,	29}, // +42: state 22 transitions
	{gaSPUNC+23,	3}, // +43: state 23 transitions
	{gaSPUNC+35,	30},
	{gaSPUNC+40,	31}, // +45: state 24 transitions
	{gaSPUNC+23,	3}, // +46: state 25 transitions
	{gaSPUNC+0,	26},
	{gaSPUNC+0,	3}, // +48: state 26 transitions
	{gaSPUNC+35,	3}, // +49: state 27 transitions
	{gaSPUNC+31,	32}, // +50: state 28 transitions
	{gaSPUNC+23,	3}, // +51: state 29 transitions
	{gaSPUNC+33,	33},
	{gaSPUNC+23,	3}, // +53: state 30 transitions
	{gaSPUNC+35,	27},
	{gaSPUNC+40,	34}, // +55: state 31 transitions
	{gaSPUNC+31,	3}, // +56: state 32 transitions
	{gaSPUNC+33,	3}, // +57: state 33 transitions
	{gaSPUNC+40,	3}, // +58: state 34 transitions
};

const STATE_DESCRIPTION aStateDescPUNC[35] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 13, gaTPUNC+0},
	/*   1 */ {1, 2, gaTPUNC+13},
	/*   2 */ {1, 1, gaTPUNC+15},
	/*   3 */ {1, 0, NULL},
	/*   4 */ {1, 1, gaTPUNC+16},
	/*   5 */ {0, 1, gaTPUNC+17},
	/*   6 */ {1, 4, gaTPUNC+18},
	/*   7 */ {1, 1, gaTPUNC+22},
	/*   8 */ {1, 1, gaTPUNC+23},
	/*   9 */ {1, 1, gaTPUNC+24},
	/*  10 */ {1, 2, gaTPUNC+25},
	/*  11 */ {1, 2, gaTPUNC+27},
	/*  12 */ {1, 3, gaTPUNC+29},
	/*  13 */ {1, 1, gaTPUNC+32},
	/*  14 */ {1, 2, gaTPUNC+33},
	/*  15 */ {0, 1, gaTPUNC+35},
	/*  16 */ {1, 1, gaTPUNC+36},
	/*  17 */ {0, 1, gaTPUNC+37},
	/*  18 */ {1, 1, gaTPUNC+38},
	/*  19 */ {1, 1, gaTPUNC+39},
	/*  20 */ {1, 1, gaTPUNC+40},
	/*  21 */ {1, 1, gaTPUNC+41},
	/*  22 */ {1, 1, gaTPUNC+42},
	/*  23 */ {1, 2, gaTPUNC+43},
	/*  24 */ {1, 1, gaTPUNC+45},
	/*  25 */ {1, 2, gaTPUNC+46},
	/*  26 */ {1, 1, gaTPUNC+48},
	/*  27 */ {1, 1, gaTPUNC+49},
	/*  28 */ {1, 1, gaTPUNC+50},
	/*  29 */ {1, 2, gaTPUNC+51},
	/*  30 */ {1, 2, gaTPUNC+53},
	/*  31 */ {1, 1, gaTPUNC+55},
	/*  32 */ {1, 1, gaTPUNC+56},
	/*  33 */ {1, 1, gaTPUNC+57},
	/*  34 */ {1, 1, gaTPUNC+58},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\shrtlist.h ===
// shrtlist.c
// Angshuman Guha
// aguha
// Feb 7, 2001

#ifndef __INC_SHORTLIST_H
#define __INC_SHORTLIST_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescDAYOFWEEK[];
extern const STATE_DESCRIPTION aStateDescMONTH[];
extern const STATE_DESCRIPTION aStateDescGENDER[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\suffix.c ===
// suffix.c
// Angshuman Guha
// aguha
// April 17, 2001

#include "common.h"
#include "suffix.h"

const STATE_DESCRIPTION *aStateDescSuffix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\suffix.h ===
// suffix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_SUFFIX_H
#define __INC_SUFFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescSuffix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\singlech.h ===
// singlech.h
// Angshuman Guha
// aguha
// Feb 6, 2001

#ifndef __INC_SINGLE_CHAR_H
#define __INC_SINGLE_CHAR_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescUPPERCHAR[];
extern const STATE_DESCRIPTION aStateDescLOWERCHAR[];
extern const STATE_DESCRIPTION aStateDescDIGITCHAR[];
extern const STATE_DESCRIPTION aStateDescPUNCCHAR[];
extern const STATE_DESCRIPTION aStateDescONECHAR[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\singlech.c ===
// singlech.c
// Angshuman Guha
// aguha
// Feb 6, 2001

#include "common.h"
#include "singlech.h"

/**************** UPPERCHAR ***********************************/

static const STATE_TRANSITION gaTUPPERCHAR[] = { {"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1} };

const STATE_DESCRIPTION aStateDescUPPERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTUPPERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** LOWERCHAR ***********************************/

static const STATE_TRANSITION gaTLOWERCHAR[] = { {"abcdefghijklmnopqrstuvwxyz", 1} };

const STATE_DESCRIPTION aStateDescLOWERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTLOWERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** DIGITCHAR ***********************************/

static const STATE_TRANSITION gaTDIGITCHAR[] = { {"0123456789", 1} };

const STATE_DESCRIPTION aStateDescDIGITCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTDIGITCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** PUNCCHAR ***********************************/

static const STATE_TRANSITION gaTPUNCCHAR[] = { {"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", 1} };

const STATE_DESCRIPTION aStateDescPUNCCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTPUNCCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** ONECHAR ***********************************/

static const STATE_TRANSITION gaTONECHAR[] = { {"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~", 1} };

const STATE_DESCRIPTION aStateDescONECHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTONECHAR },
	/*  1 */ { 1, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\charcost.c ===
// charcost.c
// created by extracting code from beam.c
// March 11, 1999
// Angshuman Guha,  aguha

#include <limits.h>
#include "common.h"
#include "charmap.h"
#include "infernop.h"
#include "nnet.h"
#include "probcost.h"

// Global data containing the log probs of the neural network outputs, for the
// current column.
// NetContActivation() and NetFirstActivation() are macros for fetching the 2 log-probs
// associated with a particular letter.

// Initializes the log-probs of the neural network outputs in the current column,
// and recomputes the best drops for this column.

void InitColumn(int *aActivations, const REAL *pProb)
{
	int		c;
	int		iMin = INT_MAX;  // The smallest cost for this column
	const	REAL *pAct;
	int		*pLog;
	int		iNotAccentSum, iNotAccent[C_ACCENT];

	// initialize
	for (c=C_CHAR_ACTIVATIONS, pLog=aActivations; c; c--, pLog++)
	{
		*pLog = ZERO_PROB_COST;
	}

	iNotAccentSum = 0;
	pAct = pProb + FIRST_ACCENT;
	for (c = 0 ; c < C_ACCENT ; ++c, ++pAct)
	{	
		iNotAccent[c] = PROB_TO_COST(65536 - *pAct);
		iNotAccentSum += iNotAccent[c];
	}


	// scan through all outputs
	for (c = 0, pAct=pProb; c < gcOutputNode; c++, pAct++)
	{
		int iNew = PROB_TO_COST(*pAct);

		if (iNew < iMin)
			iMin = iNew;

		iNew += iNotAccentSum;

		if (IsOutputBegin(c))
			aActivations[Out2Char(c)] = iNew;
		else
			aActivations[256+Out2Char(c)] = iNew;
	}

	// deal with virtual characters
	for (c=0; c<256; c++)
	{
		if (IsVirtualChar(c))
		{
			BYTE o1, o2;

			//o1 = BeginChar2Out(BaseVirtualChar(c));
			o1 = BaseVirtualChar(c);
			o2 = BeginChar2Out(AccentVirtualChar(c));
			
			// 2/9/00 Version (f)
			//aActivations[c] = PROB_TO_COST((pProb[o1]+pProb[o2])/2);

			ASSERT(o2 >= FIRST_ACCENT);
			ASSERT(o2 < C_ACCENT + FIRST_ACCENT);

			// 2/9/00 Version (a)
			aActivations[c] = aActivations[o1] - iNotAccent[o2-FIRST_ACCENT] + PROB_TO_COST(pProb[o2]);

			// 2/9/00  (Version (c)
			//aActivations[c] = aActivations[o1] - iNotAccentSum + PROB_TO_COST(pProb[o2]);

			//ASSERT(aActivations[c] >= iMin);

			//o1 = ContinueChar2Out(BaseVirtualChar(c));
			//if (o1 < 255)
			if (ContinueChar2Out(o1) < 255)
			{
				// 2/9/00 Version (f)
				//aActivations[256+c] = PROB_TO_COST((pProb[o1]+pProb[o2])/2);
	
				// 2/9/00 Version (a)
				aActivations[256+c] = aActivations[256 + o1] - iNotAccent[o2-FIRST_ACCENT] + PROB_TO_COST(pProb[o2]);
	
				// 2/9/00  (Version (c)
				//aActivations[256+c] = aActivations[256 + o1] - iNotAccentSum + PROB_TO_COST(pProb[o2]);
				//ASSERT(aActivations[c+256] >= iMin);
			}
		}
	}
}

void ComputeCharacterProbs(const REAL *pActivation, int cSegment, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong)
{
	int			row, col;
	int			thisChar;
	const int	ShortWidth = 4;
	const int	LongWidth = 7;

	// short window
	memset(aCharProb, 0, 256*sizeof(REAL));
	memset(aCharBeginProb, 0, 256*sizeof(REAL));
	col = cSegment;
	if (col > ShortWidth)
		col = ShortWidth;
	for (; col; col--)
	{
		for (row=0; row<gcOutputNode; row++, pActivation++)
		{
			thisChar = Out2Char(row);
			if (*pActivation > aCharProb[thisChar])
				aCharProb[thisChar] = *pActivation;
			if (IsOutputBegin(row))
			{
				if (*pActivation > aCharBeginProb[thisChar])
					aCharBeginProb[thisChar] = *pActivation;
			}
		}
	}

	// long window
	if (aCharProbLong && aCharBeginProbLong)
	{
		memcpy(aCharProbLong, aCharProb, 256*sizeof(REAL));
		memcpy(aCharBeginProbLong, aCharBeginProb, 256*sizeof(REAL));

		col = cSegment - ShortWidth;
		if (col <= 0)
			return;
		if (col > LongWidth - ShortWidth)
			col = LongWidth - ShortWidth;
		for (; col; col--)
		{
			for (row=0; row<gcOutputNode; row++, pActivation++)
			{
				thisChar = Out2Char(row);
				if (*pActivation > aCharProbLong[thisChar])
					aCharProbLong[thisChar] = *pActivation;
				if (IsOutputBegin(row))
				{
					if (*pActivation > aCharBeginProbLong[thisChar])
						aCharBeginProbLong[thisChar] = *pActivation;
				}
			}
		}
	}

	// deal with virtual chars
	for (thisChar=0; thisChar<256; thisChar++)
	{
		if (IsVirtualChar(thisChar))
		{
			unsigned char baseChar, accentChar;

			baseChar = BaseVirtualChar(thisChar);
			accentChar = AccentVirtualChar(thisChar);
			aCharProb[thisChar] = aCharProb[baseChar] < aCharProb[accentChar] ? aCharProb[baseChar] : aCharProb[accentChar];
			aCharBeginProb[thisChar] = aCharBeginProb[baseChar] < aCharBeginProb[accentChar] ? aCharBeginProb[baseChar] : aCharBeginProb[accentChar];
			if (aCharProbLong && aCharBeginProbLong)
			{
				aCharProbLong[thisChar] = aCharProbLong[baseChar] < aCharProbLong[accentChar] ? aCharProbLong[baseChar] : aCharProbLong[accentChar];
				aCharBeginProbLong[thisChar] = aCharBeginProbLong[baseChar] < aCharBeginProbLong[accentChar] ? aCharBeginProbLong[baseChar] : aCharBeginProbLong[accentChar];
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\tpunc.h ===
// tpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_TPUNC_H
#define __INC_TPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescTPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\tpunc.c ===
// lpunc.c (Leading punctuation)
// 
// Nov 2001 mrevow
// Matches LM spec of 10/15/2001
// This is identical to the USA version except we dont 
// have the possesive s rule

#include "common.h"
#include "lpunc.h"

// text generated by re2fsa at Thu Nov 08 14:50:03 2001

// the input-file of rules:
// T = DQ  ;
// T = t ;
// T = DQ t ;
// T = t DQ  ;
// T = SQ  ;
// T = SQ t ;
// T = t SQ  ;
// T = SQ DQ  ;
// T = t SQ DQ  ;
// T = SQ DQ t ;
// T = DQ SQ  ;
// T = t DQ SQ  ;
// T = DQ SQ t ;
// T = rparen DQ dot  ;
// T = rparen SQ dot  ;
// t = comma  ;
// t = dot  ;
// t = dot dot dot  ;
// t = dot dot dot dot  ;
// t = colon  ;
// t = semicolon  ;
// t = question  ;
// t = question question  ;
// t = question question question  ;
// t = exclamation  ;
// t = exclamation exclamation  ;
// t = exclamation exclamation exclamation  ;
// t = rparen  ;
// t = rparen comma  ;
// t = rparen dot  ;
// t = rparen colon  ;
// t = rparen semicolon  ;
// t = rparen question  ;
// t = rparen question question  ;
// t = rparen question question question  ;
// t = rparen exclamation  ;
// t = rparen exclamation exclamation  ;
// t = rparen exclamation exclamation exclamation  ;
// t = rparen rparen  ;
// t = rparen rparen comma  ;
// t = rparen rparen dot  ;
// t = rparen rparen colon  ;
// t = rparen rparen semicolon  ;
// t = rparen rparen question  ;
// t = rparen rparen question question  ;
// t = rparen rparen question question question  ;
// t = rparen rparen exclamation  ;
// t = rparen rparen exclamation exclamation  ;
// t = rparen rparen exclamation exclamation exclamation  ;
// t = comma rparen  ;
// t = dot rparen  ;
// t = colon rparen  ;
// t = semicolon rparen  ;
// t = question rparen  ;
// t = question question rparen  ;
// t = question question question rparen  ;
// t = exclamation rparen  ;
// t = exclamation exclamation rparen  ;
// t = exclamation exclamation exclamation rparen  ;
// t = dot dot dot rparen  ;
// t = rbracket  ;
// t = rbracket comma  ;
// t = rbracket dot  ;
// t = rbracket colon  ;
// t = rbracket semicolon  ;
// t = rbracket question  ;
// t = rbracket question question  ;
// t = rbracket question question question  ;
// t = rbracket exclamation  ;
// t = rbracket exclamation exclamation  ;
// t = rbracket exclamation exclamation exclamation  ;
// t = rbrace  ;
// t = rbrace comma  ;
// t = rbrace dot  ;
// t = rbrace colon  ;
// t = rbrace semicolon  ;
// t = rbrace question  ;
// t = rbrace question question  ;
// t = rbrace question question question  ;
// t = rbrace exclamation  ;
// t = rbrace exclamation exclamation  ;
// t = rbrace exclamation exclamation exclamation  ;
// t = "*" ["*" ["*"]] ;
// t = "/" ;
// DQ = "\"" ;
// SQ = "'" ;
// rparen = ")" ;
// dot = "." ;
// comma = "," ;
// colon = ":" ;
// semicolon = ";" ;
// question = "?" ;
// exclamation = "!" ;
// rbracket = "]" ;
// rbrace = "}" ;
// = T ;

// 42 states

static const unsigned char gaSTPUNC[] = 
	/* gaStringTPUNC+0 */	"!\000"
	/* gaStringTPUNC+2 */	"\"\000"
	/* gaStringTPUNC+4 */	"'\000"
	/* gaStringTPUNC+6 */	")\000"
	/* gaStringTPUNC+8 */	"*\000"
	/* gaStringTPUNC+10 */	",:;\000"
	/* gaStringTPUNC+14 */	".\000"
	/* gaStringTPUNC+16 */	"/\000"
	/* gaStringTPUNC+18 */	"?\000"
	/* gaStringTPUNC+20 */	"]}\000"
	/* gaStringTPUNC+23 */	",.:;\000"
	/* gaStringTPUNC+28 */	"'.\000"
	/* gaStringTPUNC+31 */	"\".\000"
	/* gaStringTPUNC+34 */	").\000"
;

static const STATE_TRANSITION gaTTPUNC[] = {
	{gaSTPUNC+0,	1}, // +0: state 0 transitions
	{gaSTPUNC+2,	2},
	{gaSTPUNC+4,	3},
	{gaSTPUNC+6,	4},
	{gaSTPUNC+8,	5},
	{gaSTPUNC+10,	6},
	{gaSTPUNC+14,	7},
	{gaSTPUNC+16,	8},
	{gaSTPUNC+18,	9},
	{gaSTPUNC+20,	10},
	{gaSTPUNC+6,	8}, // +10: state 1 transitions
	{gaSTPUNC+0,	11},
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+0,	14}, // +14: state 2 transitions
	{gaSTPUNC+4,	15},
	{gaSTPUNC+6,	16},
	{gaSTPUNC+8,	17},
	{gaSTPUNC+10,	18},
	{gaSTPUNC+14,	19},
	{gaSTPUNC+16,	20},
	{gaSTPUNC+18,	21},
	{gaSTPUNC+20,	22},
	{gaSTPUNC+0,	14}, // +23: state 3 transitions
	{gaSTPUNC+2,	15},
	{gaSTPUNC+6,	16},
	{gaSTPUNC+8,	17},
	{gaSTPUNC+10,	18},
	{gaSTPUNC+14,	19},
	{gaSTPUNC+16,	20},
	{gaSTPUNC+18,	21},
	{gaSTPUNC+20,	22},
	{gaSTPUNC+23,	8}, // +32: state 4 transitions
	{gaSTPUNC+6,	10},
	{gaSTPUNC+0,	23},
	{gaSTPUNC+2,	24},
	{gaSTPUNC+4,	25},
	{gaSTPUNC+18,	26},
	{gaSTPUNC+2,	12}, // +38: state 5 transitions
	{gaSTPUNC+4,	13},
	{gaSTPUNC+8,	27},
	{gaSTPUNC+6,	8}, // +41: state 6 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+6,	8}, // +44: state 7 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+14,	28},
	{gaSTPUNC+2,	12}, // +48: state 8 transitions
	{gaSTPUNC+4,	13},
	{gaSTPUNC+6,	8}, // +50: state 9 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+18,	29},
	{gaSTPUNC+23,	8}, // +54: state 10 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+0,	23},
	{gaSTPUNC+18,	26},
	{gaSTPUNC+0,	6}, // +59: state 11 transitions
	{gaSTPUNC+6,	8},
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+4,	20}, // +63: state 12 transitions
	{gaSTPUNC+2,	20}, // +64: state 13 transitions
	{gaSTPUNC+6,	20}, // +65: state 14 transitions
	{gaSTPUNC+0,	30},
	{gaSTPUNC+0,	14}, // +67: state 15 transitions
	{gaSTPUNC+6,	16},
	{gaSTPUNC+8,	17},
	{gaSTPUNC+10,	18},
	{gaSTPUNC+14,	19},
	{gaSTPUNC+16,	20},
	{gaSTPUNC+18,	21},
	{gaSTPUNC+20,	22},
	{gaSTPUNC+23,	20}, // +75: state 16 transitions
	{gaSTPUNC+6,	22},
	{gaSTPUNC+0,	31},
	{gaSTPUNC+18,	32},
	{gaSTPUNC+8,	33}, // +79: state 17 transitions
	{gaSTPUNC+6,	20}, // +80: state 18 transitions
	{gaSTPUNC+6,	20}, // +81: state 19 transitions
	{gaSTPUNC+14,	34},
	{gaSTPUNC+6,	20}, // +83: state 21 transitions
	{gaSTPUNC+18,	35},
	{gaSTPUNC+23,	20}, // +85: state 22 transitions
	{gaSTPUNC+0,	31},
	{gaSTPUNC+18,	32},
	{gaSTPUNC+2,	12}, // +88: state 23 transitions
	{gaSTPUNC+4,	13},
	{gaSTPUNC+0,	36},
	{gaSTPUNC+28,	20}, // +91: state 24 transitions
	{gaSTPUNC+31,	20}, // +92: state 25 transitions
	{gaSTPUNC+2,	12}, // +93: state 26 transitions
	{gaSTPUNC+4,	13},
	{gaSTPUNC+18,	37},
	{gaSTPUNC+8,	8}, // +96: state 27 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+14,	38}, // +99: state 28 transitions
	{gaSTPUNC+18,	6}, // +100: state 29 transitions
	{gaSTPUNC+6,	8},
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+0,	18}, // +104: state 30 transitions
	{gaSTPUNC+6,	20},
	{gaSTPUNC+0,	39}, // +106: state 31 transitions
	{gaSTPUNC+18,	40}, // +107: state 32 transitions
	{gaSTPUNC+8,	20}, // +108: state 33 transitions
	{gaSTPUNC+14,	41}, // +109: state 34 transitions
	{gaSTPUNC+18,	18}, // +110: state 35 transitions
	{gaSTPUNC+6,	20},
	{gaSTPUNC+0,	8}, // +112: state 36 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+18,	8}, // +115: state 37 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+34,	8}, // +118: state 38 transitions
	{gaSTPUNC+2,	12},
	{gaSTPUNC+4,	13},
	{gaSTPUNC+0,	20}, // +121: state 39 transitions
	{gaSTPUNC+18,	20}, // +122: state 40 transitions
	{gaSTPUNC+34,	20}, // +123: state 41 transitions
};

const STATE_DESCRIPTION aStateDescTPUNC[42] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 10, gaTTPUNC+0},
	/*   1 */ {1, 4, gaTTPUNC+10},
	/*   2 */ {1, 9, gaTTPUNC+14},
	/*   3 */ {1, 9, gaTTPUNC+23},
	/*   4 */ {1, 6, gaTTPUNC+32},
	/*   5 */ {1, 3, gaTTPUNC+38},
	/*   6 */ {1, 3, gaTTPUNC+41},
	/*   7 */ {1, 4, gaTTPUNC+44},
	/*   8 */ {1, 2, gaTTPUNC+48},
	/*   9 */ {1, 4, gaTTPUNC+50},
	/*  10 */ {1, 5, gaTTPUNC+54},
	/*  11 */ {1, 4, gaTTPUNC+59},
	/*  12 */ {1, 1, gaTTPUNC+63},
	/*  13 */ {1, 1, gaTTPUNC+64},
	/*  14 */ {1, 2, gaTTPUNC+65},
	/*  15 */ {1, 8, gaTTPUNC+67},
	/*  16 */ {1, 4, gaTTPUNC+75},
	/*  17 */ {1, 1, gaTTPUNC+79},
	/*  18 */ {1, 1, gaTTPUNC+80},
	/*  19 */ {1, 2, gaTTPUNC+81},
	/*  20 */ {1, 0, NULL},
	/*  21 */ {1, 2, gaTTPUNC+83},
	/*  22 */ {1, 3, gaTTPUNC+85},
	/*  23 */ {1, 3, gaTTPUNC+88},
	/*  24 */ {1, 1, gaTTPUNC+91},
	/*  25 */ {1, 1, gaTTPUNC+92},
	/*  26 */ {1, 3, gaTTPUNC+93},
	/*  27 */ {1, 3, gaTTPUNC+96},
	/*  28 */ {0, 1, gaTTPUNC+99},
	/*  29 */ {1, 4, gaTTPUNC+100},
	/*  30 */ {1, 2, gaTTPUNC+104},
	/*  31 */ {1, 1, gaTTPUNC+106},
	/*  32 */ {1, 1, gaTTPUNC+107},
	/*  33 */ {1, 1, gaTTPUNC+108},
	/*  34 */ {0, 1, gaTTPUNC+109},
	/*  35 */ {1, 2, gaTTPUNC+110},
	/*  36 */ {1, 3, gaTTPUNC+112},
	/*  37 */ {1, 3, gaTTPUNC+115},
	/*  38 */ {1, 3, gaTTPUNC+118},
	/*  39 */ {1, 1, gaTTPUNC+121},
	/*  40 */ {1, 1, gaTTPUNC+122},
	/*  41 */ {1, 1, gaTTPUNC+123},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\deu\viterbixlate.c ===
/****************************************************
 *
 * viterbiXlate.c
 *
 * Provides translation services between activataions and supported characters
 * for the viterbi search
 *
 * This is language specific, because European construct virtual activations
 * cannot simply use net outputs activations as surrogate
 * for character activations
 *
 ********************************************************/  
#include <common.h>
#include <nfeature.h>
#include <engine.h>
#include <infernop.h>
#include "charmap.h"
#include <charcost.h>
#include <outDict.h>
#include <viterbi.h>


void BuildActiveMap(const REAL *pActivation, int cSegments, int cOutput, BYTE rgbActiveChar[C_CHAR_ACTIVATIONS])
{
	int				row, col, cActive, cIteration = 5;
	int				thisChar;
	const REAL		*pAct;
	REAL			MinActivation = (REAL)
#ifdef FIXEDPOINT
	655;
#else
	0.01;
#endif

	do 
	{
		cActive = 0;
		memset(rgbActiveChar, 0, C_CHAR_ACTIVATIONS*sizeof(*rgbActiveChar));
		pAct = pActivation;

		for (col=cSegments; col; col--)
		{
			pAct++;

			for (row = 1 ; row < cOutput ; row++, pAct++)
			{
				if (IsOutputBegin(row))
				{
					thisChar = Out2Char(row);
				}
				else
				{
					thisChar = 256+Out2Char(row);
				}

				if (!rgbActiveChar[thisChar] && *pAct > MinActivation)
				{
					rgbActiveChar[thisChar] = 1;
					++cActive;
				}
			}
		}

		// Keep doubling the min activation if there are too many active characters
		MinActivation *= 2;

	} while ((cActive > OD_MAX_ACTIVE_CHAR) && --cIteration);

	// Check for Virtual Character activations
	for (thisChar=0; thisChar<256; thisChar++)
	{
		if (IsVirtualChar(thisChar))
		{
			rgbActiveChar[thisChar] = rgbActiveChar[BaseVirtualChar(thisChar)] && rgbActiveChar[AccentVirtualChar(thisChar)];
			rgbActiveChar[thisChar+256] = rgbActiveChar[BaseVirtualChar(thisChar)+256] && rgbActiveChar[AccentVirtualChar(thisChar)];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\fforward.h ===
void FeedForward(FFINFO *ffinfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\charcost.h ===
// charcost.h
// March 11, 1999
// Angshuman Guha,  aguha

// Language specific tuning constants which help with word breaking decisions in beam.c

// 1) Maximum overlap of strokes within a wordgap
#define MAX_STROKE_OVERLAP (0)

// 2) Tuning factor that turns for space node Cost (numerator and denominator)
#define IS_SPACE_NUM	(3)
#define IS_SPACE_DEN	(1)

// 3) Tuning factor  for Not space cost
#define NOT_SPACE_NUM	(2)
#define NOT_SPACE_DEN	(3)

// 4) Tuning factor to for allowing a 'Factoid Space' based on space output
#define FACTOID_SPACE_FUDGE		(90)

#define INFINITY_COST 999999999

//#define NetContActivation(aActivations, ch) (ContinueChar2Out(ch) < 255 ? aActivations[ContinueChar2Out(ch)]: INFINITY_COST)
//#define NetFirstActivation(aActivations, ch) aActivations[BeginChar2Out(ch)]
#define NetContActivation(aActivations, ch) (ch < 255 ? aActivations[256 + ch]: ZERO_PROB_COST * 4)
#define NetFirstActivation(aActivations, ch) aActivations[ch]

// Macros that work on the activation state index
#define IsOutputBeginAct(si) (si < 256)
#define Out2CharAct(si) (si < 256 ? si : si - 256)
#define BeginChar2OutAct(si) (si)

//void InitColumn(int * aActivations, const REAL *pAct);
void InitColumn(int * aActivations, const REAL *pAct);
void ComputeCharacterProbs(const REAL *pActivation, int cSegment, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\charmap.c ===
// charmap.c (FRA vesrion)
// Angshuman Guha, aguha
// Jan 12, 1999
// Modifed Jan 2000 (mrevow)
//  - moved accent marks to front of list
//  - Cleaned up missing characters, added the the Br pound and Euro
//
// Nov 2000
//   - Synch with usa with respect to continuation chars
// Sept 2001
//   - Synch with LM spec dated 9/8/2001 to use the supported chars

#include "common.h"
#include "charmap.h"

const unsigned char g_charMapDesc[] = "French Charmap Last updated 19 Sept 2001 - matches LM spec of 9/8/2001";

#define COUTPUT 200

const BYTE rgCharToOutputNode[2*256] = {
	// the first number is the beginning-activation node
	// the second number is the continuing-activation node
	// the value 255 means there is no output node
	// space ' ( ) , - . / < > [ \ ] ^ _ ` { | }  dont have continuation nodes
	// and accents  ` (0x60) ~ (0x7e)  (0x88)  (0xa8)  (0xb4)  dont have continuation nodes

	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	  0, 255, //   0x20 ( 32)
	  5,   6, // ! 0x21 ( 33)
	  7,   8, // " 0x22 ( 34)
	 32,  33, // # 0x23 ( 35)
	 24,  25, // $ 0x24 ( 36)
	 34,  35, // % 0x25 ( 37)
	 36,  37, // & 0x26 ( 38)
	  9, 255, // ' 0x27 ( 39)
	 10, 255, // ( 0x28 ( 40)
	 11, 255, // ) 0x29 ( 41)
	 38,  39, // * 0x2a ( 42)
	 40,  41, // + 0x2b ( 43)
	 12, 255, // , 0x2c ( 44)
	 13, 255, // - 0x2d ( 45)
	 14, 255, // . 0x2e ( 46)
	 15, 255, // / 0x2f ( 47)
	 56,  57, // 0 0x30 ( 48)
	 58,  59, // 1 0x31 ( 49)
	 60,  61, // 2 0x32 ( 50)
	 62,  63, // 3 0x33 ( 51)
	 64,  65, // 4 0x34 ( 52)
	 66,  67, // 5 0x35 ( 53)
	 68,  69, // 6 0x36 ( 54)
	 70,  71, // 7 0x37 ( 55)
	 72,  73, // 8 0x38 ( 56)
	 74,  75, // 9 0x39 ( 57)
	 16,  17, // : 0x3a ( 58)
	 18,  19, // ; 0x3b ( 59)
	 42, 255, // < 0x3c ( 60)
	 43,  44, // = 0x3d ( 61)
	 45, 255, // > 0x3e ( 62)
	 20,  21, // ? 0x3f ( 63)
	 46,  47, // @ 0x40 ( 64)
	128, 129, // A 0x41 ( 65)
	130, 131, // B 0x42 ( 66)
	132, 133, // C 0x43 ( 67)
	134, 135, // D 0x44 ( 68)
	136, 137, // E 0x45 ( 69)
	138, 139, // F 0x46 ( 70)
	140, 141, // G 0x47 ( 71)
	142, 143, // H 0x48 ( 72)
	144, 145, // I 0x49 ( 73)
	146, 147, // J 0x4a ( 74)
	148, 149, // K 0x4b ( 75)
	150, 151, // L 0x4c ( 76)
	152, 153, // M 0x4d ( 77)
	154, 155, // N 0x4e ( 78)
	156, 157, // O 0x4f ( 79)
	158, 159, // P 0x50 ( 80)
	160, 161, // Q 0x51 ( 81)
	162, 163, // R 0x52 ( 82)
	164, 165, // S 0x53 ( 83)
	166, 167, // T 0x54 ( 84)
	168, 169, // U 0x55 ( 85)
	170, 171, // V 0x56 ( 86)
	172, 173, // W 0x57 ( 87)
	174, 175, // X 0x58 ( 88)
	176, 177, // Y 0x59 ( 89)
	178, 179, // Z 0x5a ( 90)
	 48, 255, // [ 0x5b ( 91)
	 22, 255, // \ 0x5c ( 92)
	 49, 255, // ] 0x5d ( 93)
	 50, 255, // ^ 0x5e ( 94)
	 23, 255, // _ 0x5f ( 95)
	  1, 255, // ` 0x60 ( 96)
	 76,  77, // a 0x61 ( 97)
	 78,  79, // b 0x62 ( 98)
	 80,  81, // c 0x63 ( 99)
	 82,  83, // d 0x64 (100)
	 84,  85, // e 0x65 (101)
	 86,  87, // f 0x66 (102)
	 88,  89, // g 0x67 (103)
	 90,  91, // h 0x68 (104)
	 92,  93, // i 0x69 (105)
	 94,  95, // j 0x6a (106)
	 96,  97, // k 0x6b (107)
	 98,  99, // l 0x6c (108)
	100, 101, // m 0x6d (109)
	102, 103, // n 0x6e (110)
	104, 105, // o 0x6f (111)
	106, 107, // p 0x70 (112)
	108, 109, // q 0x71 (113)
	110, 111, // r 0x72 (114)
	112, 113, // s 0x73 (115)
	114, 115, // t 0x74 (116)
	116, 117, // u 0x75 (117)
	118, 119, // v 0x76 (118)
	120, 121, // w 0x77 (119)
	122, 123, // x 0x78 (120)
	124, 125, // y 0x79 (121)
	126, 127, // z 0x7a (122)
	 51, 255, // { 0x7b (123)
	 52, 255, // | 0x7c (124)
	 53, 255, // } 0x7d (125)
	 54,  55, // ~ 0x7e (126)
	255, 255,
	 28,  29, //  0x80 (128)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	  2, 255, //  0x88 (136)
	255, 255,
	255, 255,
	255, 255,
	180, 181, //  0x8c (140)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	182, 183, //  0x9c (156)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	 26,  27, //  0xa3 (163)
	255, 255,
	 30,  31, //  0xa5 (165)
	255, 255,
	184, 185, //  0xa7 (167)
	  3, 255, //  0xa8 (168)
	255, 255,
	255, 255,
	186, 187, //  0xab (171)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	188, 189, //  0xb0 (176)
	255, 255,
	255, 255,
	255, 255,
	  4, 255, //  0xb4 (180)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	190, 191, //  0xbb (187)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	192, 193, //  0xc6 (198)
	194, 195, //  0xc7 (199)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	196, 197, //  0xe6 (230)
	198, 199, //  0xe7 (231)
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255
};

const BYTE rgOutputNodeToChar[2*COUTPUT] = {
	// the first number is 0 for char-continuation node, 1 for char-beginning node
	// the second number is the character
// A) Space Node	
	1, ' ', // 0 0

// B) Accent characters
	1, '`', // 1 accent mark: grave `
	1, '', // 2 accent mark: circumflex ^
	1, '', // 3 accent mark: diaeresis (German umlaut)
	1, '', // 4 accent mark: accute grave 
	
// C) common punc
	1, '!', // 5
	0, '!', // 6
	1, '"', // 7
	0, '"', // 8
	1, '\'', // 9
	1, '(', // 10
	1, ')', // 11
	1, ',', // 12
	1, '-', // 13
	1, '.', // 14
	1, '/', // 15
	1, ':', // 16
	0, ':', // 17
	1, ';', // 18
	0, ';', // 19
	1, '?', // 20
	0, '?', // 21
	1, '\\', // 22
	1, '_', // 23

// D) Currency
	1, '$', // 24
	0, '$', // 25
	1, '', // 26
	0, '', // 27
	1, '', // 28 euro
	0, '', // 29 euro
	1, '', // 30
	0, '', // 31

// D) rare punc
	1, '#', // 32
	0, '#', // 33
	1, '%', // 34
	0, '%', // 35
	1, '&', // 36
	0, '&', // 37
	1, '*', // 38
	0, '*', // 39
	1, '+', // 40
	0, '+', // 41
	1, '<', // 42
	1, '=', // 43
	0, '=', // 44
	1, '>', // 45
	1, '@', // 46
	0, '@', // 47
	1, '[', // 48
	1, ']', // 49
	1, '^', // 50
	1, '{', // 51
	1, '|', // 52
	1, '}', // 53
	1, '~', // 54
	0, '~', // 55

// E) digits
	1, '0', // 56
	0, '0', // 57
	1, '1', // 58
	0, '1', // 59
	1, '2', // 60
	0, '2', // 61
	1, '3', // 62
	0, '3', // 63
	1, '4', // 64
	0, '4', // 65
	1, '5', // 66
	0, '5', // 67
	1, '6', // 68
	0, '6', // 69
	1, '7', // 70
	0, '7', // 71
	1, '8', // 72
	0, '8', // 73
	1, '9', // 74
	0, '9', // 75

// F) lowercase alphabets
	1, 'a', // 76
	0, 'a', // 77
	1, 'b', // 78
	0, 'b', // 79
	1, 'c', // 80
	0, 'c', // 81
	1, 'd', // 82
	0, 'd', // 83
	1, 'e', // 84
	0, 'e', // 85
	1, 'f', // 86
	0, 'f', // 87
	1, 'g', // 88
	0, 'g', // 89
	1, 'h', // 90
	0, 'h', // 91
	1, 'i', // 92
	0, 'i', // 93
	1, 'j', // 94
	0, 'j', // 95
	1, 'k', // 96
	0, 'k', // 97
	1, 'l', // 98
	0, 'l', // 99
	1, 'm', // 100
	0, 'm', // 101
	1, 'n', // 102
	0, 'n', // 103
	1, 'o', // 104
	0, 'o', // 105
	1, 'p', // 106
	0, 'p', // 107
	1, 'q', // 108
	0, 'q', // 109
	1, 'r', // 110
	0, 'r', // 111
	1, 's', // 112
	0, 's', // 113
	1, 't', // 114
	0, 't', // 115
	1, 'u', // 116
	0, 'u', // 117
	1, 'v', // 118
	0, 'v', // 119
	1, 'w', // 120
	0, 'w', // 121
	1, 'x', // 122
	0, 'x', // 123
	1, 'y', // 124
	0, 'y', // 125
	1, 'z', // 126
	0, 'z', // 127

//  G) uppercase alphabets
	1, 'A', // 128
	0, 'A', // 129
	1, 'B', // 130
	0, 'B', // 131
	1, 'C', // 132
	0, 'C', // 133
	1, 'D', // 134
	0, 'D', // 135
	1, 'E', // 136
	0, 'E', // 137
	1, 'F', // 138
	0, 'F', // 139
	1, 'G', // 140
	0, 'G', // 141
	1, 'H', // 142
	0, 'H', // 143
	1, 'I', // 144
	0, 'I', // 145
	1, 'J', // 146
	0, 'J', // 147
	1, 'K', // 148
	0, 'K', // 149
	1, 'L', // 150
	0, 'L', // 151
	1, 'M', // 152
	0, 'M', // 153
	1, 'N', // 154
	0, 'N', // 155
	1, 'O', // 156
	0, 'O', // 157
	1, 'P', // 158
	0, 'P', // 159
	1, 'Q', // 160
	0, 'Q', // 161
	1, 'R', // 162
	0, 'R', // 163
	1, 'S', // 164
	0, 'S', // 165
	1, 'T', // 166
	0, 'T', // 167
	1, 'U', // 168
	0, 'U', // 169
	1, 'V', // 170
	0, 'V', // 171
	1, 'W', // 172
	0, 'W', // 173
	1, 'X', // 174
	0, 'X', // 175
	1, 'Y', // 176
	0, 'Y', // 177
	1, 'Z', // 178
	0, 'Z', // 179

//	H) Euro chars
	1, '', // 180
	0, '', // 181
	1, '', // 182
	0, '', // 183
	1, '', // 184
	0, '', // 185
	1, '', // 186
	0, '', // 187
	1, '', // 188
	0, '', // 189
	1, '', // 190
	0, '', // 191
	1, '', // 192
	0, '', // 193
	1, '', // 194
	0, '', // 195
	1, '', // 196
	0, '', // 197
	1, '', // 198
	0, '', // 199
};

/*
BYTE BeginChar2Out(char ch)
{
	BYTE x;

	x = rgCharToOutputNode[2*(ch)];
	assert(x < COUTPUT);
	return x;
}

BYTE ContinueChar2Out(char ch)
{
	BYTE x;

	x = rgCharToOutputNode[2*(ch)+1];
	assert(x < COUTPUT);
	return x;
}
*/

const BYTE rgVirtualChar[2*256] = 
{
	// these are European accented characters which we currently represent as the
	// simultaneous occurrence of a base character and an accent character
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, //  (0x9f) == Y  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x41, 0x60, //  (0xc0) == A ` 
	0x00, 0x00, //  (0xc1) == A  
	0x41, 0x88, //  (0xc2) == A  
	0x00, 0x00, //  (0xc3) == A ~ 
	0x41, 0xa8, //  (0xc4) == A  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x45, 0x60, //  (0xc8) == E ` 
	0x45, 0xb4, //  (0xc9) == E  
	0x45, 0x88, //  (0xca) == E  
	0x45, 0xa8, //  (0xcb) == E  
	0x00, 0x00, //  (0xcc) == I ` 
	0x00, 0x00, //  (0xcd) == I  
	0x49, 0x88, //  (0xce) == I  
	0x49, 0xa8, //  (0xcf) == I  
	0x00, 0x00,
	0x00, 0x00, //  (0xd1) == N ~ 
	0x00, 0x00, //  (0xd2) == O ` 
	0x00, 0x00, //  (0xd3) == O  
	0x4f, 0x88, //  (0xd4) == O  
	0x00, 0x00, //  (0xd5) == O ~ 
	0x00, 0x00, //  (0xd6) == O  
	0x00, 0x00,
	0x00, 0x00,
	0x55, 0x60, //  (0xd9) == U ` 
	0x00, 0x00, //  (0xda) == U  
	0x55, 0x88, //  (0xdb) == U  
	0x55, 0xa8, //  (0xdc) == U  
	0x00, 0x00, //  (0xdd) == Y  
	0x00, 0x00,
	0x00, 0x00,
	0x61, 0x60, //  (0xe0) == a ` 
	0x00, 0x00, //  (0xe1) == a  
	0x61, 0x88, //  (0xe2) == a  
	0x00, 0x00, //  (0xe3) == a ~ 
	0x61, 0xa8, //  (0xe4) == a  
	0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00,
	0x65, 0x60, //  (0xe8) == e ` 
	0x65, 0xb4, //  (0xe9) == e  
	0x65, 0x88, //  (0xea) == e  
	0x65, 0xa8, //  (0xeb) == e  
	0x00, 0x00, //  (0xec) == i ` 
	0x00, 0x00, //  (0xed) == i  
	0x69, 0x88, //  (0xee) == i  
	0x69, 0xa8, //  (0xef) == i  
	0x00, 0x00,
	0x00, 0x00, //  (0xf1) == n ~ 
	0x00, 0x00, //  (0xf2) == o ` 
	0x00, 0x00, //  (0xf3) == o  
	0x6f, 0x88, //  (0xf4) == o  
	0x00, 0x00, //  (0xf5) == o ~ 
	0x00, 0x00, //  (0xf6) == o  
	0x00, 0x00,
	0x00, 0x00,
	0x75, 0x60, //  (0xf9) == u ` 
	0x00, 0x00, //  (0xfa) == u  
	0x75, 0x88, //  (0xfb) == u  
	0x75, 0xa8, //  (0xfc) == u  
	0x00, 0x00, //  (0xfd) == y  
	0x00, 0x00,
	0x00, 0x00  //  (0xff) == y  
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\lpunc.h ===
// lpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_LPUNC_H
#define __INC_LPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescLPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\charmap.h ===
// charmap.h
// Angshuman Guha, aguha
// Jan 12, 1999
// Modifed March 10, 1999

#ifndef __CHARMAP_H
#define __CHARMAP_H

#ifdef __cplusplus
extern "C" {
#endif

// Maximum number of character activations, (ie begin and continuation activation) supported by the
// recognizer
#define C_CHAR_ACTIVATIONS		512


// Accented characters
#define FIRST_ACCENT		(1)
#define C_ACCENT			(4)

// The first output unit in the character class
#define FIRST_SOFT_MAX_UNIT	(FIRST_ACCENT + C_ACCENT)


//BYTE BeginChar2Out(char);
//BYTE ContinueChar2Out(char);

extern const BYTE rgCharToOutputNode[];
extern const BYTE rgOutputNodeToChar[];
extern const BYTE rgVirtualChar[];

#define BeginChar2Out(ch) rgCharToOutputNode[2*(ch)]
#define ContinueChar2Out(ch) rgCharToOutputNode[2*(ch)+1]

// the following macro is right iff all virtual chars are supported
#define IsSupportedChar(ch) ((BeginChar2Out(ch) < 0xFF) || IsVirtualChar(ch))

#define Out2Char(i) rgOutputNodeToChar[2*(i)+1]
#define IsOutputBegin(i) rgOutputNodeToChar[2*(i)]

#define IsVirtualChar(ch) rgVirtualChar[2*(ch)]
#define BaseVirtualChar(ch) rgVirtualChar[2*(ch)]
#define AccentVirtualChar(ch) rgVirtualChar[2*(ch)+1]

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\fforward.c ===
#include "common.h"
#include "nfeature.h"
#include "engine.h"
#include "infernop.h"
#include "nnet.h"
#include "fforward.h"
#include "charmap.h"
#include "loadTDNNbin.h"
#include <resource.h>
#include <math16.h>

#ifndef __min
#define __min(a,b) (a < b ? a : b)
#endif


NET_DESC	s_NetPrint;
NET_DESC	s_NetCurs;
NET_DESC	s_NetAlt;
NET_DESC	s_SpaceNet;

BOOL InitInferno(HINSTANCE hInst)
{
	BOOL		iRet = TRUE;


	iRet = (iRet && LoadTDNNFromResource(hInst, RESID_INFERNO, &s_NetPrint));
	iRet = (iRet && LoadTDNNFromResource(hInst, RESID_INFERNO_CURS, &s_NetCurs));
	//iRet = (iRet && LoadTDNNFromResource(hInst, RESID_INFERNO_ALT, &s_NetAlt));
	iRet = (iRet && LoadTDNNFromResource(hInst, RESID_INFERNO_SPACE, &s_SpaceNet));


/*
	iRet = (iRet && LoadTDNNFromFp(&s_Net0, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\fra\\nnetCont_195.bin") != NULL);
	iRet = (iRet && LoadTDNNFromFp(&s_NetPrint, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\fra\\nnetPrint_195.bin") !=NULL);
	iRet = (iRet && LoadTDNNFromFp(&s_NetCurs, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\fra\\nnetCurs_195.bin") !=NULL);
	iRet = (iRet && LoadTDNNFromFp(&s_SpaceNet_1, "\\\\mrevow1\\nt\\drivers\\tabletpc\\tpg\\hwx\\inferno\\src\\fra\\nnetSpace_15.bin") !=NULL);
*/
	ASSERT(s_NetPrint.cOutput == gcOutputNode && "Cannot load print TDNN because net size is wrong");
	ASSERT(s_NetCurs.cOutput == gcOutputNode && "Cannot load curs TDNN because net size is wrong");

	if (s_NetPrint.cOutput != gcOutputNode || s_NetCurs.cOutput != gcOutputNode)
	{
		iRet = FALSE;
	}

	return iRet;
}

/*************************************************************************
 *
 * FeedForwardHidOut
 *
 * Does a forward propogation between 2 layers for the case
 * where there is no space displacement in the lower layer, ie the lower layer units
 * have been rolled out in time. We use this case for propogating hidden->
 * output layer. Outputs are not put through the non-linearity 
 *
 *
 * NOTE: Because of the rollout in time, this function assumes no edge effect cases
 *
 ***************************************************************************/ 
void FeedForwardHid2Out(
int						cWidth,				// IN: Number of time slices (columns) in lower layer
int						cWidthUpper,		// IN: Number of time slices (columns) in upper layer
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE HID_OUT_WEIGHT	*rgWeight,			// IN: Weight vector
ROMMABLE OUT_BIAS		*rgBias,			// IN: Bias vector
int						cInNZ,				// IN: Total number of (Non-zero) input values (Only used in debug for checking)
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int			row, col;
	int			*pInput = input, *tmpInput;
unsigned short	*pInNZd, *pcNZd;

	pInNZd = pInNZ;
	pcNZd = pcNZPerCol;


	// Should be no edge affects for this propogation
	ASSERT(cWidthUpper + cWeightWidth - 1 == cWidth);

	for (col= 0 ; col < cWidthUpper ; col++)
	{
		ROMMABLE OUT_BIAS			*pBias = rgBias;
		ROMMABLE HID_OUT_WEIGHT		*pWeight = rgWeight;
		unsigned short *pcCol;
		unsigned short	*pNZInc;

		for (row = cOutput ; row ; row--)
		{
			int	sum = (int)(*pBias++);
			int c, iVal, iw;

			pcCol = pcNZPerCol;
			tmpInput = pInput;
			pNZInc = pInNZ;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					// Maybe these asserts are too defensive??
					ASSERT(*pWeight >= -0x7f);
					ASSERT(*pWeight <= 0x7f);

					iVal = (*tmpInput++) * (int)(*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}

			*output++ = sum;
		}

		// Because of rollout in time of hidden layer go to the next
		// column
		pInNZ = pNZInc;
		pcNZPerCol = pcCol;
		pInput = tmpInput;
	}

}

/********************************************************************************
 *
 * FeedForwardLayerInp2Hid
 *
 * Does the main work of forward propogating one layer. The lower layer (input)
 * is thought of having cWidth columns one column per time slice. A columns has cWeightHeight 
 * units. The upper layer (output) also has cWidth columns, with each column having cOutput units.
 *
 * Each output weight has incoming conections from cWeightWidth columns in the lower layer.
 * In other words an output unit recieves connections from potentially cWeightHeight * cWeightWidth
 * units. Columns at either left or right edge have less incoming units and are handles as edge effects
 * Also, the case of int(cWeightWidth / 2) time slices is handles as a special case.
 *
 * Speedup tricks. The lower units are often saturated, ie have max or 0 value. We
 * take advantage of the case when the units are 0 and simply skip these units. The straight
 * forward approach would be to include an if() statement but that would not really 
 * be a time saving. So before entering this routine, we go through all the inputs, throwing
 * out the zero values and keeping track of the location of non zero entries in a parallel array of offsets.
 * So the 'input' array only has nonzero entries values, the parrallel array pInNZ contains the gaps between
 * the nonzero entries in the **real** input space. (An entry of 1 means that values in input were
 * actually adjacent in the input space.) Finally pcNZPerCol is a count of Non zero entries
 * in wach input column. Now as we do the dot products we only are using non Zero input values
 * taking care to use the correct weights by using the pInNZ to index to the appropriate weight
 *
 * Sept 1999 (mrevow) This function is modelled on FeedForward layer in previous
 * Checkins. The difference is now that it is only used for inp->hidden propogation, no bias
 * applied and the hidden activations are not passed through the sigmoid. This is differerd till later
 * because we roll out the hidden units in time, each hidden unit giving rise to 3 activations
 * each with a different bias
 *
 ***************************************************************************************/
void FeedForwardInp2Hid(
int						cWidth,				// IN: Number of time slices (columns) in lower layer
int						cWidthUpper,		// IN: Number of time slices (columns) in upper layer
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE INP_HID_WEIGHT	*rgWeight,			// IN: Weight vector
int						cInNZ,				// IN: Total number of (Non-zero) input values (Only used in debug for checking)
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int				row, col;
	int				*pInput;
	int				leftMargin, rightMargin;
	unsigned short	*pcNZPerColTmp, *pInNZTmp;
	int				i, iNZtoLeft;
int	cIn = cInNZ;


	leftMargin = (cWidthUpper - cWidth) / 2 + 1;
	rightMargin = min (cWidthUpper - leftMargin, leftMargin);

	if (cWidth < 0)
	{
		return;
	}


	// Take care of edge effects. Do all the upper layer columns
	// where we do not have leftMargin columns to the left in the lower layer

	// For all columns in upper row which dont have 
	// enough columns in the lower layer to the left
	for (col = leftMargin ; col ; --col)
	{
		ROMMABLE INP_HID_WEIGHT *pWeight = rgWeight + col * cWeightHeight;

		pcNZPerColTmp = pcNZPerCol;		// Per column counts
		pInNZTmp = pInNZ;				// The NZ gap counts

		// For each row in the upper layer
		for (row=cOutput; row; row--)
		{
			int	 *tmpInput = input;
			int sum;
			int c, iVal, iw, cLowerCol;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			sum = 0;

			// Iterate over each col in lower layer that connects to
			// one in the upper layer. Normally we have to use
			// cWeightWidth-col time slices in the lower layer, but dont croak if
			// there are insufficient
			cLowerCol = min((cWeightWidth-col), cWidth);
			for (iw = cLowerCol ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);

				// Finally each row in the lower layer
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				// Compensate for gap at end of the slice
				pWeight += *(pNZInc++);
			}

			*output++ = sum;
			pWeight += col * cWeightHeight;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;

	}

	// the middle chunk - has enough on either side to use all weights
	pInput = input;
	pcNZPerColTmp = pcNZPerCol;
	pInNZTmp = pInNZ;

	for (col = cWidthUpper - leftMargin - rightMargin; col > 0; col--)
	{
		ROMMABLE INP_HID_WEIGHT	*pWeight = rgWeight;

		for (row = cOutput ; row ; row--)
		{
			int	 *tmpInput = pInput;
			unsigned short *pcCol = pcNZPerColTmp; 
			int sum = 0;
			int c, iVal, iw;
			unsigned short	*pNZInc = pInNZTmp;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			*output++ =  sum;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column

	}
	ASSERT(pInput - input == cInNZ - pcNZPerColTmp[0] - pcNZPerColTmp[1]);

	// the right part where the weight matrix goes beyond the right end of input
	// note: weight matrix does not go beyond left end

	pcNZPerColTmp = pcNZPerCol + cWidth - rightMargin;
	
	// Count number of NZ entries in the input so we can set the pointer
	// to the first Non zero entry
	iNZtoLeft = 0;
	for (i = 0 ; i < cWidth - rightMargin; ++ i)
	{
		iNZtoLeft += pcNZPerCol[i];
	}

	pInput = input + iNZtoLeft;
	pInNZTmp = pInNZ + iNZtoLeft + i;

	// the left part where the weight matrix goes beyond the left end of input
	// note: weight matrix does not go beyond right end
	//for (col=leftMargin; col; col--)
	for (col = 1 ; col <= rightMargin; ++col)
	{
		ROMMABLE INP_HID_WEIGHT *pWeight = rgWeight;
		int						iColMax = min(cWeightWidth - col, cWidth);		// Number of loer layer columns to do

		for (row=cOutput; row; row--)
		{
			int	 *tmpInput = pInput;
			int		sum = 0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			tmpInput = pInput;

			for (iw = iColMax ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			*output++ = sum;
			pWeight += col * cWeightHeight ;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column
	}
}



// Count the number of non zero elements in the input array, and the gaps between
// them. For ease of later bookeeping we also keep track of the zero space counts
// at the start and end of each time slice
// Returns the total number of NZ elements
int GetNZSpaces(
int					*pData,			// IN/OUT: Input Data array, on out is compacted to remove zero elements
int					cSlice,			// IN: Number of time slices
int					cLen,			// IN: Length of each time slice
unsigned short		*pNZgap,		// OUT: the gaps between the NZ elements
unsigned short		*pcNZPerCol		// OUT: Number of NZ elements per slice	
)
{
	int					i, j, k, cNZ, cGap;
	int					iLastNZ;

	i = 0;
	cNZ = cGap = 0;
	iLastNZ = 0;

	ASSERT(pData);
	ASSERT(pNZgap);
	ASSERT(pcNZPerCol);

	*pcNZPerCol = 0;

	for (k = 0 ; k < cSlice; ++k )
	{
		for (j = 0 ; j < cLen ; ++j, ++i)
		{
			if (pData[i] != 0)
			{
				pData[cNZ++] = pData[i];
				pNZgap[cGap++] = i - iLastNZ;
				(*pcNZPerCol)++;
				iLastNZ = i;
			}
		}

		++pcNZPerCol;
		*pcNZPerCol = 0;

		pNZgap[cGap++] = i - iLastNZ;
		iLastNZ = i;
	}

	return cNZ;
}
//
// Convert output units from something like logDomain to P domain 
// by doing softmax on the output units those that need it and
// sigmoid on those others
// Assumption:  space node is the very first output node
//
void logP2P(
int			cWidth,
int			cOutput,
int			*pOutput
)
{
	int		*p, i;
	int		iF = (1 << 22) - 1;
	int		iSigMax = ( 1 << 16), iSigZero = (1 << 15);


	for ( i = 0 ; i < cWidth ; ++i)
	{
		int		j;
		int		iMax, sum, iV;


		// Sigmoids
		for (j = 0 ;j < FIRST_SOFT_MAX_UNIT ; ++j, ++pOutput)
		{
			*pOutput = Sigmoid16(*pOutput >> 4);

		}

		// Find max so we can do softmax with maximal precision
		p = pOutput;
		iMax =  *p++;
		for (j = FIRST_SOFT_MAX_UNIT + 1 ; j < cOutput ; ++j, ++p )
		{
			if (*p > iMax)
			{
				iMax = *p;
			}
		}

		p = pOutput;
		sum = 0;
		for (j = FIRST_SOFT_MAX_UNIT ; j < cOutput ; ++j, ++p )
		{
			// Want to get (exp(*p - iMax)) compute it as
			// Instead of creating a new table use the
			// existing sigmoid and compute s / (1-s) where 
			// s - sigmoid(x). Note we have to do correct
			// scaling for the To get maximum resolution make max value 2^22
			// (Leaves scope for about 1024 output units without overflow)

			iV = (*p - iMax) >> 4;			// get in the range [-2^16 : 2^16]

			if (iV < 0)
			{
				iV = Sigmoid16(iV);
				iV = iV << 16 / ( iSigMax - iV);		// Maximum resolution with no overflow ??
				iV <<= 6;								// Scale into the 2^22 range
			}
			else
			{
				iV = iF;		// Dont need to do computation it is the maximum 
			}

			*p = iV; 
			sum += *p;
		}

		sum >>= 16;

		ASSERT(sum > 0);

		for (j = FIRST_SOFT_MAX_UNIT ; j < cOutput ; ++j, ++pOutput )
		{
			*pOutput /= sum;


			// Clip outouts
			if (*pOutput > 0xFFFF)
			{
				*pOutput = 0xFFFF;
			}

		}
	}
}
/**********************************************************************
 *
 * Special treatment for hidden units. 
 *   1) Expand each activation into cSpan replicated
 *      activities with different bias added to each replication and
 *   2) Pass through the sigmoid
 *
 **********************************************************************/
void addHidBias(
int						*pHidden,		// IN/OUT Hidden activations (processing is done in place)
int						cHidden,		// IN: Number of hidden units per time slot
int						cSpan,			// IN: Replication size
int						cWidth,			// IN: Number of time slots
int						cWidthHid,		// IN: Number of 'time slots' in hidden layer (CwidthHid > cWidth)
ROMMABLE  HID_BIAS		*pHidBias		// IN: Biases (cHidden * cSpan)
)
{
	int						iW, iRow, iS;
	ROMMABLE  HID_BIAS		*pEndBias = pHidBias + cHidden * cSpan - 1;
	int						iMaxCol;

	ASSERT (cWidthHid == cWidth + (cSpan-1)/2 * 2);

	iMaxCol = cWidth * cSpan;

	// Work from the last time slot backwards
	// that way we can do it in place
	for (iW = cWidthHid - 1 ; iW >= 0 ; --iW)
	{
		ROMMABLE  HID_BIAS		*pB = pHidBias;
		int							*pSrc = pHidden + iW * cHidden;

		// Replication the src column 
		for (iS = 0 ; iS <cSpan ; ++iS)
		{
			int		*pS = pSrc;
			int		iDestCol = cSpan * (iW - iS) + iS;
			int		*pDest;
			
			if (iDestCol < 0 || iDestCol >= iMaxCol)
			{
				pB += cHidden;
				continue;
			}

			
			pDest = pHidden + (iDestCol) * cHidden;

			ASSERT (pDest >= pSrc);

			for (iRow = 0 ; iRow < cHidden ; ++iRow)
			{
				*pDest = *pS++ + *pB++;
				*pDest = Sigmoid16(*pDest);
				++pDest;
			}
		}
	}
}
/*
// Do a forward propagation of a net defined by the weights passed in
void ForwardNet(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,			// IN: Which net to use
int						*pHidden,			// OUT Hidden activations
int						*pOutput,			// OUT: Desired output activations
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int					i;
	int					*pi;
	ROMMABLE  HID_BIAS	*pb;
	int					cNZ;
	NET_DESC			*pNet;

	pNet = pTdnnNet->pNetDesc;


	pi = pOutput;

	// Get features
	for (i = pTdnnNet->cWidth; i; i--)
	{
		unsigned short *pFeat;
		int j;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		if (CNEURALFEATURE == pNet->cInput )
		{
			for (j=CNEURALFEATURE; j; j--)
			{
				*pi++ = (*pFeat++ - *pb++) / 16;
			}
		}
		else
		{
			int		x;

			for (j=0; j < F_INDEX_XOVERLAP ; j++)
			{
				*pi++ = (*pFeat++ - *pb++) / 16;
			}

			// Convert from signed to unsigned
			x = *pFeat ;
			if (x > 0x7FFF)
			{
				x = 0;
			}
			else
			{
				x = 2 * (0x7FFF - x);
			}

			ASSERT(x >= 0 && x <= 0xFFFF);
			*pi++ = (x - *pb++) / 16;

			pFeat += (F_INDEX_BOOLSECONDARY - F_INDEX_XOVERLAP);
			for (j = F_INDEX_BOOLSECONDARY ; j < CNEURALFEATURE ; ++j)
			{
				*pi++ = (*pFeat++ - *pb++) / 16;
			}
		}

		nfeature = nfeature->next;
	}

	ASSERT(pi - pOutput == pNet->cInput*pTdnnNet->cWidth);



	// Do forward inp -> hidden
	cNZ = GetNZSpaces(pOutput, pTdnnNet->cWidth, pNet->cInput, pNZ, pcNZPerCol);
	ASSERT(cNZ >= 0);

	FeedForwardInp2Hid(pTdnnNet->cWidth, pTdnnNet->cWidthHid, pOutput, pHidden, pNet->cHidden, pNet->cInput, pNet->cHidSpan,
			pNet->pIn2HidWgt, cNZ, pNZ, pcNZPerCol);

	// Expand out hidden units to simulate 'shared units' and apply bias
	addHidBias(pHidden, pNet->cHidden, pNet->cOutSpan, pTdnnNet->cWidth, pTdnnNet->cWidthHid, pNet->pHidBias);

	// No Hidden -> output
	cNZ = GetNZSpaces(pHidden, pTdnnNet->cWidth*pNet->cOutSpan, pNet->cHidden, pNZ, pcNZPerCol);

	FeedForwardHid2Out(pTdnnNet->cWidthHid, pTdnnNet->cWidth, pHidden, pOutput, pNet->cOutput, pNet->cHidden, 
			pNet->cOutSpan, pNet->pHid2Out, pNet->pOutBias, cNZ, pNZ, pcNZPerCol);

	// Finally the softmax
	logP2P(pTdnnNet->cWidth, pNet->cOutput, pOutput);
}
*/

// Do a forward propagation of a net defined by the weights passed in
void runTDNNForward(
TDNN_NET				*pTdnnNet,				// IN: Which net to use
int						*pInput,
int						*pHidden,			// OUT Hidden activations
int						*pOutput,			// OUT: Desired output activations
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{
	int					cNZ;
	NET_DESC			*pNet;

	pNet = pTdnnNet->pNetDesc;

	// Do forward inp -> hidden
	cNZ = GetNZSpaces(pInput, pTdnnNet->cWidth, pNet->cInput, pNZ, pcNZPerCol);
	ASSERT(cNZ >= 0);

	FeedForwardInp2Hid(pTdnnNet->cWidth, pTdnnNet->cWidthHid, pInput, pHidden, pNet->cHidden, pNet->cInput, pNet->cHidSpan,
			pNet->pIn2HidWgt, cNZ, pNZ, pcNZPerCol);

	// Expand out hidden units to simulate 'shared units' and apply bias
	addHidBias(pHidden, pNet->cHidden, pNet->cOutSpan, pTdnnNet->cWidth, pTdnnNet->cWidthHid, pNet->pHidBias);

	// No Hidden -> output
	cNZ = GetNZSpaces(pHidden, pTdnnNet->cWidth*pNet->cOutSpan, pNet->cHidden, pNZ, pcNZPerCol);

	FeedForwardHid2Out(pTdnnNet->cWidthHid, pTdnnNet->cWidth, pHidden, pOutput, pNet->cOutput, pNet->cHidden, 
			pNet->cOutSpan, pNet->pHid2Out, pNet->pOutBias, cNZ, pNZ, pcNZPerCol);

}

int SumContOrBeginOnlyOutput(REAL *pOutput, int cMainOutput, const unsigned char *pChars)
{
	int		sum = 0;
	int		id;

	while (*pChars)
	{
		if (IsSupportedChar(*pChars))
		{
			id = ContinueChar2Out(*pChars);

			if (id >= cMainOutput)
			{
				id = BeginChar2Out(*pChars);
			}

			if (id < cMainOutput)
			{
				ASSERT(id >= FIRST_SOFT_MAX_UNIT);
				sum += pOutput[id];
			}
			else
			{
				ASSERT(id);
			}

		}

		pChars++;
	}

	ASSERT(sum >= 0);
	sum = __min(sum, 0xFFFF);

	return sum;
}

int SumBeginOnlyOutput(REAL *pOutput, int cMainOutput, const unsigned char *pChars)
{
	int		sum = 0;
	int		ix = 0;
	int		id;

	while (*pChars)
	{
		if (IsSupportedChar(*pChars))
		{
			id = BeginChar2Out(*pChars);
			if (id < cMainOutput)
			{
				ASSERT(id >= FIRST_SOFT_MAX_UNIT);
				sum += pOutput[id];
			}
			else
			{
				ASSERT(id);
			}

		}

		pChars++;
	}

	ASSERT(sum >= 0);
	sum = __min(sum, 0xFFFF);

	return sum;
}

int SumOutput(unsigned short *output, int cMainOutput, const unsigned char *pChars)
{
	int		ix = 0;
	int		idCont;

	while (*pChars)
	{
		if (IsSupportedChar(*pChars))
		{
			ix += (int)output[BeginChar2Out(*pChars)];
			idCont = ContinueChar2Out(*pChars);
			if (idCont < cMainOutput)
			{
				ix += (int)output[idCont];
			}
		}

		pChars++;
	}

	return ix;
}

//
// This is similar to the USA version of the space net
void ForwardSpaceNet_1(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,			// IN: Net to use
int						*pInput,			// IN: Allocated Buffer large enough to hold all inputs
int						*pHidden,			// OUT Hidden activations
REAL					*pOutput,			// I/O: On input has all char activation on OUT adds the space outputs
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol,		// IN: Number of non zero entries per time slice (column)
int						cOutput				// IN: Total Number outputs in main net (not the space net)
)
{
	const unsigned char HiPunc[] = "'\"^`";
	const unsigned char LoPunc[] = ".,_";
	const unsigned char MidPunc[] = "-=~*+";
	const unsigned char BigPunc[] = "\\!#$%&(/:;<>?@[{}|";
	const unsigned char Number[] =  "0123456789";
	const unsigned char UAlpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const unsigned char Ascender[] = "bdfhklt";
	const unsigned char Descender[] = "fgjpqyz";
	const unsigned char LAlpha[] = "aceimnorsuvwx";
	int					i;
	int					*pi, *pSpace, *pSp;
	REAL				*pOutCur;
	NET_DESC			*pNet;

	pNet	= pTdnnNet->pNetDesc;
	pi		= pInput;
	pOutCur = pOutput;
	ASSERT(1 == pNet->cOutput);
	pSpace	= (int *)ExternAlloc(sizeof(*pSpace) * pNet->cOutput * pTdnnNet->cWidth);
	ASSERT(pSpace);

	if (NULL == pSpace)
	{
		return;
	}

	// Assign inputs from the feature set
	// NOTE pTdnnNet->cWidth Should have been preset to 1 less than the actual number of times
	// slices because the last slice always will have 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++)
	{
		unsigned short		*pFeat;
		int					j;
		ROMMABLE  HID_BIAS	*pb;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		ASSERT(pNet->cInput > CNEURALFEATURE);

		for (j = 0 ; j < CNEURALFEATURE; j++)
		{
			*pi++ = (*pFeat++ - *pb++) / 16;
		}

		// Before the Potential Space
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  HiPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  LoPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  MidPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  BigPunc) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  Number) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  UAlpha) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  Ascender) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  Descender) - (int)(*pb++)) / 16;
		*pi++ = ((int)SumOutput(pOutCur, cOutput,  LAlpha) - (int)(*pb++)) / 16;
		
		nfeature	= nfeature->next;
		pOutCur		+= cOutput;
	}

	ASSERT(pi - pInput == pNet->cInput*pTdnnNet->cWidth);

	runTDNNForward(pTdnnNet, pInput, pHidden, pSpace, pNZ, pcNZPerCol);

	pOutCur = pOutput;
	pSp = pSpace;
	// copy the space outputs into the main net output
	// NOTE dont copy the final time slice - it always has a 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++, ++pSp, pOutCur += cOutput)
	{
		int		val;

		val = Sigmoid16(*pSp >> 4);
		if (val > 0xFFFF)
		{
			val = 0xFFFF;
		}

		ASSERT(val >= 0);
		pOutCur[BeginChar2Out(' ')] = (REAL)val;
	}

	// Restore the proper time slice count
	ExternFree(pSpace);
}

// This is an experimental version of the  space net
// Add  extra features about characters on either side of potential gap
/*
void ForwardSpaceNet(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,			// IN: Net to use
int						*pInput,			// IN: Allocated Buffer large enough to hold all inputs
int						*pHidden,			// OUT Hidden activations
REAL					*pOutput,			// I/O: On input has all char activation on OUT adds the space outputs
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol,		// IN: Number of non zero entries per time slice (column)
int						cOutput				// IN: Total Number outputs in main net (not the space net)
)
{
	const unsigned char HiPuncNoSpaceAfter[] = "'^~";
	const unsigned char MidPuncNoSpaceAfter[] = "*+-=";
	const unsigned char LoPuncSpaceAfter[] = ".,_";
	const unsigned char BigPuncSpaceAfter[] = "!$%&):;>?]}";
	const unsigned char BigPuncNoSpaceAfter[] = "#(/<@[\\{|";
	const unsigned char Number[] =  "0123456789";
	const unsigned char UAlpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	const unsigned char Ascender[] = "bdfhklt";
	const unsigned char Descender[] = "fgjpqyz";
	const unsigned char LAlpha[] = "aceimnorsuvwx";

	const unsigned char HiPuncNoSpaceBefore[] = "'^~";
	const unsigned char MidPuncNoSpaceBefore[] = "*+-=";
	const unsigned char LoPuncSpaceBefore[] = "";
	const unsigned char LoPuncNoSpaceBefore[] = ",._";
	const unsigned char BigPuncSpaceBefore[] = "!#$%&(:;<?[{";
	const unsigned char BigPuncNoSpaceBefore[] = "/>@\\]|}";
	int					i;
	int					*pi, *pSpace, *pSp;
	REAL				*pOutCur, *pOutNext;
	NET_DESC			*pNet;

	pNet	= pTdnnNet->pNetDesc;

	pi		= pInput;
	pOutCur = pOutput;
	pOutNext = pOutput + cOutput;
	ASSERT(1 == pNet->cOutput);
	pSpace	= (int *)ExternAlloc(sizeof(*pSpace) * pNet->cOutput * pTdnnNet->cWidth);
	ASSERT(pSpace);

	if (NULL == pSpace)
	{
		return;
	}

	// Assign inputs from the feature set
	// NOTE pTdnnNet->cWidth Should have been preset to 1 less than the actual number of times
	// slices because the last slice always will have 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++)
	{
		unsigned short		*pFeat;
		int					j;
		ROMMABLE  HID_BIAS	*pb;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		ASSERT(pNet->cInput > CNEURALFEATURE);

		for (j = 0 ; j < CNEURALFEATURE; j++)
		{
			*pi++ = (*pFeat++ - *pb++) / 16;
		}

		// Before the Potential Space
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, HiPuncNoSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, MidPuncNoSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, LoPuncSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, BigPuncSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, BigPuncNoSpaceAfter) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, Number) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, UAlpha) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, Ascender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, Descender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumContOrBeginOnlyOutput(pOutCur, cOutput, LAlpha) - *pb++) / 16;
		
		//After Potential Space
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, HiPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, MidPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, LoPuncSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, LoPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, BigPuncSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, BigPuncNoSpaceBefore) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, Number) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, UAlpha) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, Ascender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, Descender) - *pb++) / 16;
		*pi++ = ((unsigned short)SumBeginOnlyOutput(pOutNext, cOutput, LAlpha) - *pb++) / 16;
		
		nfeature	= nfeature->next;
		pOutCur		+= cOutput;
		pOutNext	+= cOutput;
	}

	ASSERT(pi - pInput == pNet->cInput*pTdnnNet->cWidth);

	runTDNNForward(pTdnnNet, pInput, pHidden, pSpace, pNZ, pcNZPerCol);

	pOutCur = pOutput;
	pSp = pSpace;
	// copy the space outputs into the main net output
	// NOTE dont copy the final time slice - it always has a 0 space output
	for (i = 0 ; i < pTdnnNet->cWidth; i++, ++pSp, pOutCur += cOutput)
	{
		int		val;

		val = Sigmoid16(*pSp >> 4);
		if (val > 0xFFFF)
		{
			val = 0xFFFF;
		}

		ASSERT(val >= 0);
		pOutCur[BeginChar2Out(' ')] = (REAL)val;
	}

	// Restore the proper time slice count
	ExternFree(pSpace);
}
*/

// Do a forward propagation of a net defined by the weights passed in
void ForwardMainNet(
NFEATURE				*nfeature,			// IN: Features
TDNN_NET				*pTdnnNet,				// IN: Which net to use
int						*pHidden,			// OUT Hidden activations
int						*pOutput,			// OUT: Desired output activations
unsigned short			*pNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol			// IN: Number of non zero entries per time slice (column)
)
{

	int					i;
	int					*pi;
	NET_DESC			*pNet;

	pNet = pTdnnNet->pNetDesc;

	pi = pOutput;

	// Assign inputs from the feature set
	for (i = pTdnnNet->cWidth; i; i--)
	{
		unsigned short		*pFeat;
		int					j;
		ROMMABLE  HID_BIAS	*pb;

		pb = pNet->pInBias;
		ASSERT(nfeature);
		pFeat = nfeature->rgFeat;

		for (j=CNEURALFEATURE; j; j--)
		{
			*pi++ = (*pFeat++ - *pb++) / 16;
		}
		nfeature = nfeature->next;
	}

	ASSERT(pi - pOutput == pNet->cInput*pTdnnNet->cWidth);

	runTDNNForward(pTdnnNet, pOutput, pHidden, pOutput, pNZ, pcNZPerCol);

	// Finally the softmax
	logP2P(pTdnnNet->cWidth, pNet->cOutput, pOutput);

}

void FeedForwardDoit(FFINFO *ffinfo, int idx)
{
	int				*pi;
	NFEATURE		*nfeature;
	int				*piHidden = NULL, *piOutput = NULL;
	NFEATURESET		*nfeatureset = ffinfo->nfeatureset;
	REAL			*output =  ffinfo->NeuralOutput;
	int				iPrint = ffinfo->nfeatureset->iPrint;
	int				cWidth = nfeatureset->cSegment, cWidth1, cWidthHid;
	int				i, iCursive = (1000 - iPrint);
	unsigned short	*pNZ = NULL, *pcNZperCol = NULL;
	int				cHidden, cUnitMax;
	int				iThresh;
	TDNN_NET		net;
	TDNN_NET		spaceNet;
	NET_DESC		*pNetDesc;

	// Threshold in terms of speed setting. Piecewise linear
	if (ffinfo->iSpeed <= 50)
	{
		ASSERT(ffinfo->iSpeed >= 0);
		iThresh = (ffinfo->iSpeed * 300) / 50;
	}
	else
	{
		ASSERT(ffinfo->iSpeed <= 100);
		iThresh = (ffinfo->iSpeed * 150) / 50 + 150;
	}

	cWidth1 = cWidth + 1;

	if (0 == idx)
	{
		iThresh = 250;
		if (iPrint >= iThresh)
		{
			pNetDesc = &s_NetPrint;
		}
		else
		{
			pNetDesc = &s_NetCurs;
		}
	}
	else
	{
		//net.pNetDesc = &s_NetAlt;
		ASSERT(idx == 0 && "TDNN Network is not available");
		return;
	}

	net.pNetDesc = pNetDesc;

	cWidthHid = cWidth + (pNetDesc->cHidSpan) / 2 * 2;

	cHidden		= pNetDesc->cHidden * pNetDesc->cOutSpan;
	cUnitMax	= max(cHidden, pNetDesc->cInput*pNetDesc->cHidSpan) * cWidth1;

	piHidden = (int *) ExternAlloc(cHidden * cWidth * sizeof(*piHidden));
	pNZ = (unsigned short *) ExternAlloc(cUnitMax*sizeof(*pNZ));
	pcNZperCol = (unsigned short *) ExternAlloc(cWidth1 * pNetDesc->cOutSpan * sizeof(*pcNZperCol));
	piOutput = (int *) ExternAlloc(pNetDesc->cOutput * cWidth * sizeof(*piOutput));

	if (!piHidden || !pNZ || !pcNZperCol || !piOutput)
	{
		goto fail;
	}


	net.cWidth				= cWidth;
	net.cWidthHid			= cWidthHid;
	nfeature				= nfeatureset->head;

	ForwardMainNet(nfeature, &net, piHidden, piOutput, pNZ, pcNZperCol);		

	pi = piOutput;
	for (i = 0 ; i < cWidth; i++)
	{
		int		iOut;

		for (iOut = 0 ; iOut < pNetDesc->cOutput ; ++iOut)
		{
			*output = (REAL)*pi;
			++output;
			++pi;
		}
	}

	if (cWidth > 1 )
	{
		spaceNet.cWidth		= cWidth-1;
		spaceNet.cWidthHid	= cWidthHid-1;
		spaceNet.pNetDesc	= &s_SpaceNet;

		ForwardSpaceNet_1(nfeature, &spaceNet, piOutput, piHidden, ffinfo->NeuralOutput, pNZ, pcNZperCol, pNetDesc->cOutput);
	}


fail:
	ExternFree(piOutput);
	ExternFree(piHidden);
	ExternFree(pNZ);
	ExternFree(pcNZperCol);



	return;

}

void FeedForward(FFINFO *ffinfo)
{
	FeedForwardDoit(ffinfo, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\nnetprint.h ===
// nnetPrint.h
// converted from command NN_net2c in annTcl on Mon Mar 20 18:48:22 2000
// from net description file /fra/trainNet/net-desc_37_100_1_5_209.txt,  weight file save_19.wgt, statFile /fra/trainNet/midfeat/statPrint in directory H:/fra/TRAINNET/unlabel/print5 on machine MREVOW1
#ifndef NNET_PRINT_H
#define NNET_PRINT_H

// Time Stamp
#define NET_TIME_STAMP_PRINT	0x38d6e2f5

// Type definitions

typedef short INP_HID_WEIGHT_PRINT;
typedef int HID_BIAS_PRINT;
typedef char HID_OUT_WEIGHT_PRINT;
typedef int OUT_BIAS_PRINT;
typedef int INP_BIAS_PRINT;


// Hidden Layer
#define gcHiddenNodePrint 100
#define gcHiddenWeightHeightPrint 37
#define gcHiddenWeightWidthPrint 3
extern ROMMABLE  INP_HID_WEIGHT_PRINT grgHiddenWeightPrint[gcHiddenNodePrint*gcHiddenWeightHeightPrint*gcHiddenWeightWidthPrint];


// Output Layer
#define gcOutputNodePrint 215
#define gcOutputWeightHeightPrint 100
#define gcOutputWeightWidthPrint 3
extern ROMMABLE  HID_OUT_WEIGHT_PRINT grgOutputWeightPrint[gcOutputNodePrint*gcOutputWeightHeightPrint*gcOutputWeightWidthPrint];

// Bias
extern ROMMABLE INP_BIAS_PRINT grgInputBiasPrint[gcHiddenWeightHeightPrint];
extern ROMMABLE HID_BIAS_PRINT grgHiddenBiasPrint[gcHiddenNodePrint * gcOutputWeightWidthPrint];
extern ROMMABLE OUT_BIAS_PRINT grgOutputBiasPrint[gcOutputNodePrint];

#endif // NNET_PRINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\nnet.c ===
// nnet.c

#include <common.h>
#include "nnet.h"
#include "nnetPrint.h"

#include "nnet.ci"
#include "nnetPrint.ci"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\nnet.h ===
// nnet.h
// converted from command NN_net2c in annTcl on Thu Dec 20 15:11:00 2001
// from net description file ../net-desc_37_100_1_4_194.txt,  weight file ../curs/save_19Convert.wgt, statFile ../curs/statCurs in directory K:/mrevow/fra/train/baseline/OldCheckedInConvert/convert on machine MREVOW1
#ifndef NNET_H
#define NNET_H

// Time Stamp
#define NET_TIME_STAMP	0x3c227003

// Type definitions

typedef short INP_HID_WEIGHT;
typedef int HID_BIAS;
typedef char HID_OUT_WEIGHT;
typedef int OUT_BIAS;
typedef int INP_BIAS;


#define gcOutputNode 200

#endif // NNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\number.c ===
// number.c
// 
// Nov 2001 mrevow
// Matches LM spec of 10/15/2001

#include "common.h"
#include "fsa.h"

// text generated by re2fsa at Fri Nov 30 16:02:28 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = number

// 333 states

static const unsigned char gaSNUMBER[] = 
	/* gaStringNUMBER+0 */	"'\000"
	/* gaStringNUMBER+2 */	"(\000"
	/* gaStringNUMBER+4 */	"+\000"
	/* gaStringNUMBER+6 */	"-\000"
	/* gaStringNUMBER+8 */	"0\000"
	/* gaStringNUMBER+10 */	"1\000"
	/* gaStringNUMBER+12 */	"2\000"
	/* gaStringNUMBER+14 */	"3\000"
	/* gaStringNUMBER+16 */	"456789\000"
	/* gaStringNUMBER+23 */	"Dd\000"
	/* gaStringNUMBER+26 */	"Jj\000"
	/* gaStringNUMBER+29 */	"Ll\000"
	/* gaStringNUMBER+32 */	"Mm\000"
	/* gaStringNUMBER+35 */	"Ss\000"
	/* gaStringNUMBER+38 */	"Vv\000"
	/* gaStringNUMBER+41 */	"[\000"
	/* gaStringNUMBER+43 */	"{\000"
	/* gaStringNUMBER+45 */	"0123456789\000"
	/* gaStringNUMBER+56 */	"+-\000"
	/* gaStringNUMBER+59 */	" \000"
	/* gaStringNUMBER+61 */	"*+-/x\000"
	/* gaStringNUMBER+67 */	",\000"
	/* gaStringNUMBER+69 */	"123456789\000"
	/* gaStringNUMBER+79 */	":\000"
	/* gaStringNUMBER+81 */	"<=>\000"
	/* gaStringNUMBER+85 */	"Hh\000"
	/* gaStringNUMBER+88 */	"*+x\000"
	/* gaStringNUMBER+92 */	"/\000"
	/* gaStringNUMBER+94 */	"e\000"
	/* gaStringNUMBER+96 */	"01234\000"
	/* gaStringNUMBER+102 */	"56789\000"
	/* gaStringNUMBER+108 */	"01\000"
	/* gaStringNUMBER+111 */	"23456789\000"
	/* gaStringNUMBER+120 */	"i\000"
	/* gaStringNUMBER+122 */	"u\000"
	/* gaStringNUMBER+124 */	"a\000"
	/* gaStringNUMBER+126 */	")\000"
	/* gaStringNUMBER+128 */	"$%Hh\000"
	/* gaStringNUMBER+136 */	"E\000"
	/* gaStringNUMBER+138 */	"F\000"
	/* gaStringNUMBER+140 */	"U\000"
	/* gaStringNUMBER+142 */	"f\000"
	/* gaStringNUMBER+144 */	".\000"
	/* gaStringNUMBER+146 */	"012345\000"
	/* gaStringNUMBER+153 */	"6789\000"
	/* gaStringNUMBER+158 */	"Aa\000"
	/* gaStringNUMBER+161 */	"Nn\000"
	/* gaStringNUMBER+164 */	"Oo\000"
	/* gaStringNUMBER+167 */	"r\000"
	/* gaStringNUMBER+169 */	"m\000"
	/* gaStringNUMBER+171 */	"n\000"
	/* gaStringNUMBER+173 */	"%\000"
	/* gaStringNUMBER+175 */	".F\000"
	/* gaStringNUMBER+178 */	"R\000"
	/* gaStringNUMBER+180 */	"S\000"
	/* gaStringNUMBER+182 */	"o\000"
	/* gaStringNUMBER+184 */	"v\000"
	/* gaStringNUMBER+186 */	"\000"
	/* gaStringNUMBER+188 */	"c\000"
	/* gaStringNUMBER+190 */	"3456789\000"
	/* gaStringNUMBER+198 */	"012\000"
	/* gaStringNUMBER+202 */	"$%\000"
	/* gaStringNUMBER+208 */	"d\000"
	/* gaStringNUMBER+210 */	" .\000"
	/* gaStringNUMBER+213 */	"s\000"
	/* gaStringNUMBER+215 */	"$D\000"
	/* gaStringNUMBER+218 */	"*+/x\000"
	/* gaStringNUMBER+223 */	"\000"
	/* gaStringNUMBER+225 */	"t\000"
	/* gaStringNUMBER+227 */	"p\000"
	/* gaStringNUMBER+229 */	"Ff\000"
	/* gaStringNUMBER+232 */	"]\000"
	/* gaStringNUMBER+234 */	"}\000"
	/* gaStringNUMBER+236 */	"O\000"
	/* gaStringNUMBER+238 */	".t\000"
	/* gaStringNUMBER+241 */	".n\000"
	/* gaStringNUMBER+244 */	"l\000"
	/* gaStringNUMBER+246 */	".s\000"
	/* gaStringNUMBER+249 */	"b\000"
	/* gaStringNUMBER+251 */	"h\000"
	/* gaStringNUMBER+253 */	"12\000"
;

static const STATE_TRANSITION gaTNUMBER[] = {
	{gaSNUMBER+0,	1}, // +0: state 0 transitions
	{gaSNUMBER+2,	2},
	{gaSNUMBER+4,	3},
	{gaSNUMBER+6,	4},
	{gaSNUMBER+8,	5},
	{gaSNUMBER+10,	6},
	{gaSNUMBER+12,	7},
	{gaSNUMBER+14,	8},
	{gaSNUMBER+16,	9},
	{gaSNUMBER+23,	10},
	{gaSNUMBER+26,	11},
	{gaSNUMBER+29,	12},
	{gaSNUMBER+32,	13},
	{gaSNUMBER+35,	14},
	{gaSNUMBER+38,	15},
	{gaSNUMBER+41,	16},
	{gaSNUMBER+43,	17},
	{gaSNUMBER+45,	18}, // +17: state 1 transitions
	{gaSNUMBER+56,	19}, // +18: state 2 transitions
	{gaSNUMBER+45,	20},
	{gaSNUMBER+45,	21}, // +20: state 3 transitions
	{gaSNUMBER+45,	22}, // +21: state 4 transitions
	{gaSNUMBER+59,	23}, // +22: state 5 transitions
	{gaSNUMBER+61,	24},
	{gaSNUMBER+67,	25},
	{gaSNUMBER+8,	26},
	{gaSNUMBER+69,	27},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+88,	24}, // +30: state 6 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+59,	31},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+45,	34},
	{gaSNUMBER+94,	35},
	{gaSNUMBER+88,	24}, // +40: state 7 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+59,	31},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+96,	34},
	{gaSNUMBER+102,	36},
	{gaSNUMBER+88,	24}, // +50: state 8 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+59,	31},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+108,	36},
	{gaSNUMBER+111,	37},
	{gaSNUMBER+88,	24}, // +60: state 9 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+59,	31},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+45,	37},
	{gaSNUMBER+120,	38}, // +69: state 10 transitions
	{gaSNUMBER+94,	39}, // +70: state 11 transitions
	{gaSNUMBER+122,	40}, // +71: state 12 transitions
	{gaSNUMBER+124,	41}, // +72: state 13 transitions
	{gaSNUMBER+94,	42},
	{gaSNUMBER+124,	43}, // +74: state 14 transitions
	{gaSNUMBER+94,	44}, // +75: state 15 transitions
	{gaSNUMBER+56,	45}, // +76: state 16 transitions
	{gaSNUMBER+45,	46},
	{gaSNUMBER+56,	47}, // +78: state 17 transitions
	{gaSNUMBER+45,	48},
	{gaSNUMBER+45,	49}, // +80: state 18 transitions
	{gaSNUMBER+45,	50}, // +81: state 19 transitions
	{gaSNUMBER+126,	51}, // +82: state 20 transitions
	{gaSNUMBER+61,	52},
	{gaSNUMBER+67,	53},
	{gaSNUMBER+45,	54},
	{gaSNUMBER+61,	24}, // +86: state 21 transitions
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	55},
	{gaSNUMBER+67,	56},
	{gaSNUMBER+45,	57},
	{gaSNUMBER+45,	22}, // +91: state 22 transitions
	{gaSNUMBER+61,	24},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	55},
	{gaSNUMBER+67,	56},
	{gaSNUMBER+128,	49}, // +96: state 23 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+138,	59},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+142,	61},
	{gaSNUMBER+2,	62}, // +101: state 24 transitions
	{gaSNUMBER+56,	63},
	{gaSNUMBER+45,	64},
	{gaSNUMBER+41,	65},
	{gaSNUMBER+43,	66},
	{gaSNUMBER+45,	67}, // +106: state 25 transitions
	{gaSNUMBER+61,	24}, // +107: state 26 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+59,	68},
	{gaSNUMBER+144,	69},
	{gaSNUMBER+45,	70},
	{gaSNUMBER+88,	24}, // +115: state 27 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+144,	69},
	{gaSNUMBER+59,	71},
	{gaSNUMBER+45,	72},
	{gaSNUMBER+146,	73}, // +125: state 28 transitions
	{gaSNUMBER+153,	74},
	{gaSNUMBER+2,	75}, // +127: state 29 transitions
	{gaSNUMBER+56,	76},
	{gaSNUMBER+45,	77},
	{gaSNUMBER+41,	78},
	{gaSNUMBER+43,	79},
	{gaSNUMBER+153,	49}, // +132: state 30 transitions
	{gaSNUMBER+146,	80},
	{gaSNUMBER+128,	49}, // +134: state 31 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+158,	81},
	{gaSNUMBER+23,	82},
	{gaSNUMBER+138,	83},
	{gaSNUMBER+26,	84},
	{gaSNUMBER+32,	85},
	{gaSNUMBER+161,	86},
	{gaSNUMBER+164,	87},
	{gaSNUMBER+35,	88},
	{gaSNUMBER+142,	89},
	{gaSNUMBER+2,	62}, // +146: state 32 transitions
	{gaSNUMBER+56,	63},
	{gaSNUMBER+41,	65},
	{gaSNUMBER+43,	66},
	{gaSNUMBER+8,	90},
	{gaSNUMBER+10,	91},
	{gaSNUMBER+111,	92},
	{gaSNUMBER+2,	62}, // +153: state 33 transitions
	{gaSNUMBER+56,	63},
	{gaSNUMBER+41,	65},
	{gaSNUMBER+43,	66},
	{gaSNUMBER+8,	93},
	{gaSNUMBER+10,	94},
	{gaSNUMBER+111,	95},
	{gaSNUMBER+88,	24}, // +160: state 34 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+79,	28},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+85,	30},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+144,	69},
	{gaSNUMBER+59,	71},
	{gaSNUMBER+45,	96},
	{gaSNUMBER+167,	97}, // +170: state 35 transitions
	{gaSNUMBER+88,	24}, // +171: state 36 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+6,	32},
	{gaSNUMBER+92,	33},
	{gaSNUMBER+144,	69},
	{gaSNUMBER+45,	96},
	{gaSNUMBER+59,	98},
	{gaSNUMBER+61,	24}, // +179: state 37 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+144,	69},
	{gaSNUMBER+45,	96},
	{gaSNUMBER+59,	99},
	{gaSNUMBER+169,	100}, // +185: state 38 transitions
	{gaSNUMBER+122,	101}, // +186: state 39 transitions
	{gaSNUMBER+171,	101}, // +187: state 40 transitions
	{gaSNUMBER+167,	101}, // +188: state 41 transitions
	{gaSNUMBER+167,	102}, // +189: state 42 transitions
	{gaSNUMBER+169,	103}, // +190: state 43 transitions
	{gaSNUMBER+171,	104}, // +191: state 44 transitions
	{gaSNUMBER+45,	46}, // +192: state 45 transitions
	{gaSNUMBER+45,	46}, // +193: state 46 transitions
	{gaSNUMBER+61,	105},
	{gaSNUMBER+67,	106},
	{gaSNUMBER+45,	48}, // +196: state 47 transitions
	{gaSNUMBER+45,	48}, // +197: state 48 transitions
	{gaSNUMBER+61,	107},
	{gaSNUMBER+67,	108},
	{gaSNUMBER+45,	50}, // +200: state 50 transitions
	{gaSNUMBER+126,	51},
	{gaSNUMBER+61,	52},
	{gaSNUMBER+67,	53},
	{gaSNUMBER+61,	24}, // +204: state 51 transitions
	{gaSNUMBER+81,	29},
	{gaSNUMBER+56,	109}, // +206: state 52 transitions
	{gaSNUMBER+45,	110},
	{gaSNUMBER+45,	111}, // +208: state 53 transitions
	{gaSNUMBER+45,	50}, // +209: state 54 transitions
	{gaSNUMBER+61,	52},
	{gaSNUMBER+67,	53},
	{gaSNUMBER+126,	112},
	{gaSNUMBER+173,	49}, // +213: state 55 transitions
	{gaSNUMBER+45,	113}, // +214: state 56 transitions
	{gaSNUMBER+45,	22}, // +215: state 57 transitions
	{gaSNUMBER+61,	24},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+67,	56},
	{gaSNUMBER+59,	114},
	{gaSNUMBER+140,	115}, // +220: state 58 transitions
	{gaSNUMBER+175,	49}, // +221: state 59 transitions
	{gaSNUMBER+178,	116},
	{gaSNUMBER+167,	117},
	{gaSNUMBER+180,	118}, // +224: state 60 transitions
	{gaSNUMBER+144,	49}, // +225: state 61 transitions
	{gaSNUMBER+167,	117},
	{gaSNUMBER+56,	119}, // +227: state 62 transitions
	{gaSNUMBER+45,	120},
	{gaSNUMBER+45,	64}, // +229: state 63 transitions
	{gaSNUMBER+81,	29}, // +230: state 64 transitions
	{gaSNUMBER+45,	64},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+56,	122}, // +233: state 65 transitions
	{gaSNUMBER+45,	123},
	{gaSNUMBER+56,	124}, // +235: state 66 transitions
	{gaSNUMBER+45,	125},
	{gaSNUMBER+61,	24}, // +237: state 67 transitions
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	55},
	{gaSNUMBER+45,	126},
	{gaSNUMBER+128,	49}, // +241: state 68 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+138,	59},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+142,	61},
	{gaSNUMBER+2,	127},
	{gaSNUMBER+45,	128},
	{gaSNUMBER+45,	129}, // +248: state 69 transitions
	{gaSNUMBER+61,	24}, // +249: state 70 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	130},
	{gaSNUMBER+45,	131},
	{gaSNUMBER+128,	49}, // +254: state 71 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+158,	81},
	{gaSNUMBER+23,	82},
	{gaSNUMBER+138,	83},
	{gaSNUMBER+26,	84},
	{gaSNUMBER+32,	85},
	{gaSNUMBER+161,	86},
	{gaSNUMBER+164,	87},
	{gaSNUMBER+35,	88},
	{gaSNUMBER+142,	89},
	{gaSNUMBER+2,	127},
	{gaSNUMBER+45,	128},
	{gaSNUMBER+61,	24}, // +268: state 72 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	130},
	{gaSNUMBER+45,	132},
	{gaSNUMBER+79,	30}, // +273: state 73 transitions
	{gaSNUMBER+45,	74},
	{gaSNUMBER+59,	133},
	{gaSNUMBER+79,	30}, // +276: state 74 transitions
	{gaSNUMBER+59,	133},
	{gaSNUMBER+56,	134}, // +278: state 75 transitions
	{gaSNUMBER+45,	135},
	{gaSNUMBER+45,	77}, // +280: state 76 transitions
	{gaSNUMBER+45,	77}, // +281: state 77 transitions
	{gaSNUMBER+61,	136},
	{gaSNUMBER+67,	137},
	{gaSNUMBER+56,	138}, // +284: state 78 transitions
	{gaSNUMBER+45,	139},
	{gaSNUMBER+56,	140}, // +286: state 79 transitions
	{gaSNUMBER+45,	141},
	{gaSNUMBER+45,	49}, // +288: state 80 transitions
	{gaSNUMBER+182,	142}, // +289: state 81 transitions
	{gaSNUMBER+184,	143},
	{gaSNUMBER+186,	144}, // +291: state 82 transitions
	{gaSNUMBER+175,	49}, // +292: state 83 transitions
	{gaSNUMBER+178,	116},
	{gaSNUMBER+167,	117},
	{gaSNUMBER+186,	145},
	{gaSNUMBER+124,	146}, // +296: state 84 transitions
	{gaSNUMBER+122,	147},
	{gaSNUMBER+124,	148}, // +298: state 85 transitions
	{gaSNUMBER+182,	149}, // +299: state 86 transitions
	{gaSNUMBER+188,	150}, // +300: state 87 transitions
	{gaSNUMBER+94,	151}, // +301: state 88 transitions
	{gaSNUMBER+144,	49}, // +302: state 89 transitions
	{gaSNUMBER+167,	117},
	{gaSNUMBER+186,	145},
	{gaSNUMBER+81,	29}, // +305: state 90 transitions
	{gaSNUMBER+8,	64},
	{gaSNUMBER+69,	92},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+81,	29}, // +309: state 91 transitions
	{gaSNUMBER+190,	64},
	{gaSNUMBER+198,	92},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+6,	152},
	{gaSNUMBER+81,	29}, // +314: state 92 transitions
	{gaSNUMBER+45,	64},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+6,	152},
	{gaSNUMBER+81,	29}, // +318: state 93 transitions
	{gaSNUMBER+8,	64},
	{gaSNUMBER+69,	95},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+81,	29}, // +322: state 94 transitions
	{gaSNUMBER+190,	64},
	{gaSNUMBER+198,	95},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+92,	152},
	{gaSNUMBER+81,	29}, // +327: state 95 transitions
	{gaSNUMBER+45,	64},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+92,	152},
	{gaSNUMBER+61,	24}, // +331: state 96 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	130},
	{gaSNUMBER+45,	153},
	{gaSNUMBER+59,	154}, // +336: state 97 transitions
	{gaSNUMBER+202,	49}, // +337: state 98 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+158,	81},
	{gaSNUMBER+23,	82},
	{gaSNUMBER+138,	83},
	{gaSNUMBER+26,	84},
	{gaSNUMBER+32,	85},
	{gaSNUMBER+161,	86},
	{gaSNUMBER+164,	87},
	{gaSNUMBER+35,	88},
	{gaSNUMBER+142,	89},
	{gaSNUMBER+2,	127},
	{gaSNUMBER+45,	128},
	{gaSNUMBER+202,	49}, // +351: state 99 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+138,	59},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+142,	61},
	{gaSNUMBER+2,	127},
	{gaSNUMBER+45,	128},
	{gaSNUMBER+124,	155}, // +358: state 100 transitions
	{gaSNUMBER+208,	156}, // +359: state 101 transitions
	{gaSNUMBER+188,	157}, // +360: state 102 transitions
	{gaSNUMBER+94,	101}, // +361: state 103 transitions
	{gaSNUMBER+208,	157}, // +362: state 104 transitions
	{gaSNUMBER+56,	158}, // +363: state 105 transitions
	{gaSNUMBER+45,	159},
	{gaSNUMBER+45,	160}, // +365: state 106 transitions
	{gaSNUMBER+56,	161}, // +366: state 107 transitions
	{gaSNUMBER+45,	162},
	{gaSNUMBER+45,	163}, // +368: state 108 transitions
	{gaSNUMBER+45,	110}, // +369: state 109 transitions
	{gaSNUMBER+126,	51}, // +370: state 110 transitions
	{gaSNUMBER+45,	110},
	{gaSNUMBER+67,	164},
	{gaSNUMBER+126,	51}, // +373: state 111 transitions
	{gaSNUMBER+61,	52},
	{gaSNUMBER+45,	111},
	{gaSNUMBER+61,	24}, // +376: state 112 transitions
	{gaSNUMBER+81,	29},
	{gaSNUMBER+210,	165},
	{gaSNUMBER+61,	24}, // +379: state 113 transitions
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	55},
	{gaSNUMBER+45,	113},
	{gaSNUMBER+173,	49}, // +383: state 114 transitions
	{gaSNUMBER+2,	127},
	{gaSNUMBER+45,	166},
	{gaSNUMBER+178,	167}, // +386: state 115 transitions
	{gaSNUMBER+138,	49}, // +387: state 116 transitions
	{gaSNUMBER+213,	49}, // +388: state 117 transitions
	{gaSNUMBER+215,	49}, // +389: state 118 transitions
	{gaSNUMBER+45,	120}, // +390: state 119 transitions
	{gaSNUMBER+45,	120}, // +391: state 120 transitions
	{gaSNUMBER+126,	168},
	{gaSNUMBER+61,	169},
	{gaSNUMBER+67,	170},
	{gaSNUMBER+45,	171}, // +395: state 121 transitions
	{gaSNUMBER+45,	123}, // +396: state 122 transitions
	{gaSNUMBER+45,	123}, // +397: state 123 transitions
	{gaSNUMBER+61,	172},
	{gaSNUMBER+67,	173},
	{gaSNUMBER+45,	125}, // +400: state 124 transitions
	{gaSNUMBER+45,	125}, // +401: state 125 transitions
	{gaSNUMBER+61,	174},
	{gaSNUMBER+67,	175},
	{gaSNUMBER+61,	24}, // +404: state 126 transitions
	{gaSNUMBER+81,	29},
	{gaSNUMBER+45,	113},
	{gaSNUMBER+59,	130},
	{gaSNUMBER+8,	176}, // +408: state 127 transitions
	{gaSNUMBER+45,	177}, // +409: state 128 transitions
	{gaSNUMBER+45,	178}, // +410: state 129 transitions
	{gaSNUMBER+202,	49}, // +411: state 130 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+138,	59},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+142,	61},
	{gaSNUMBER+218,	24}, // +416: state 131 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	179},
	{gaSNUMBER+6,	180},
	{gaSNUMBER+144,	181},
	{gaSNUMBER+45,	182},
	{gaSNUMBER+218,	24}, // +423: state 132 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+6,	180},
	{gaSNUMBER+144,	181},
	{gaSNUMBER+45,	182},
	{gaSNUMBER+59,	183},
	{gaSNUMBER+85,	49}, // +430: state 133 transitions
	{gaSNUMBER+45,	135}, // +431: state 134 transitions
	{gaSNUMBER+45,	135}, // +432: state 135 transitions
	{gaSNUMBER+126,	184},
	{gaSNUMBER+61,	185},
	{gaSNUMBER+67,	186},
	{gaSNUMBER+2,	187}, // +436: state 136 transitions
	{gaSNUMBER+56,	188},
	{gaSNUMBER+45,	189},
	{gaSNUMBER+41,	190},
	{gaSNUMBER+43,	191},
	{gaSNUMBER+45,	192}, // +441: state 137 transitions
	{gaSNUMBER+45,	139}, // +442: state 138 transitions
	{gaSNUMBER+45,	139}, // +443: state 139 transitions
	{gaSNUMBER+61,	193},
	{gaSNUMBER+67,	194},
	{gaSNUMBER+45,	141}, // +446: state 140 transitions
	{gaSNUMBER+45,	141}, // +447: state 141 transitions
	{gaSNUMBER+61,	195},
	{gaSNUMBER+67,	196},
	{gaSNUMBER+223,	197}, // +450: state 142 transitions
	{gaSNUMBER+59,	152}, // +451: state 143 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+167,	199},
	{gaSNUMBER+188,	200}, // +454: state 144 transitions
	{gaSNUMBER+184,	201}, // +455: state 145 transitions
	{gaSNUMBER+171,	202}, // +456: state 146 transitions
	{gaSNUMBER+120,	203}, // +457: state 147 transitions
	{gaSNUMBER+120,	198}, // +458: state 148 transitions
	{gaSNUMBER+167,	204},
	{gaSNUMBER+184,	200}, // +460: state 149 transitions
	{gaSNUMBER+225,	205}, // +461: state 150 transitions
	{gaSNUMBER+227,	206}, // +462: state 151 transitions
	{gaSNUMBER+45,	207}, // +463: state 152 transitions
	{gaSNUMBER+218,	24}, // +464: state 153 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	130},
	{gaSNUMBER+6,	180},
	{gaSNUMBER+45,	182},
	{gaSNUMBER+158,	81}, // +470: state 154 transitions
	{gaSNUMBER+23,	82},
	{gaSNUMBER+26,	84},
	{gaSNUMBER+32,	85},
	{gaSNUMBER+161,	86},
	{gaSNUMBER+164,	87},
	{gaSNUMBER+35,	88},
	{gaSNUMBER+229,	208},
	{gaSNUMBER+171,	209}, // +478: state 155 transitions
	{gaSNUMBER+120,	210}, // +479: state 156 transitions
	{gaSNUMBER+167,	103}, // +480: state 157 transitions
	{gaSNUMBER+45,	159}, // +481: state 158 transitions
	{gaSNUMBER+232,	51}, // +482: state 159 transitions
	{gaSNUMBER+45,	159},
	{gaSNUMBER+67,	211},
	{gaSNUMBER+61,	105}, // +485: state 160 transitions
	{gaSNUMBER+45,	160},
	{gaSNUMBER+45,	162}, // +487: state 161 transitions
	{gaSNUMBER+234,	51}, // +488: state 162 transitions
	{gaSNUMBER+45,	162},
	{gaSNUMBER+67,	212},
	{gaSNUMBER+61,	107}, // +491: state 163 transitions
	{gaSNUMBER+45,	163},
	{gaSNUMBER+45,	213}, // +493: state 164 transitions
	{gaSNUMBER+45,	166}, // +494: state 165 transitions
	{gaSNUMBER+45,	214}, // +495: state 166 transitions
	{gaSNUMBER+236,	49}, // +496: state 167 transitions
	{gaSNUMBER+81,	29}, // +497: state 168 transitions
	{gaSNUMBER+56,	215}, // +498: state 169 transitions
	{gaSNUMBER+45,	216},
	{gaSNUMBER+45,	217}, // +500: state 170 transitions
	{gaSNUMBER+81,	29}, // +501: state 171 transitions
	{gaSNUMBER+45,	171},
	{gaSNUMBER+56,	218}, // +503: state 172 transitions
	{gaSNUMBER+45,	219},
	{gaSNUMBER+45,	220}, // +505: state 173 transitions
	{gaSNUMBER+56,	221}, // +506: state 174 transitions
	{gaSNUMBER+45,	222},
	{gaSNUMBER+45,	223}, // +508: state 175 transitions
	{gaSNUMBER+126,	166}, // +509: state 176 transitions
	{gaSNUMBER+144,	69}, // +510: state 177 transitions
	{gaSNUMBER+59,	224},
	{gaSNUMBER+144,	181}, // +512: state 178 transitions
	{gaSNUMBER+202,	49}, // +513: state 179 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+138,	59},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+142,	61},
	{gaSNUMBER+2,	127},
	{gaSNUMBER+45,	225},
	{gaSNUMBER+2,	62}, // +520: state 180 transitions
	{gaSNUMBER+56,	63},
	{gaSNUMBER+41,	65},
	{gaSNUMBER+43,	66},
	{gaSNUMBER+8,	226},
	{gaSNUMBER+10,	227},
	{gaSNUMBER+111,	228},
	{gaSNUMBER+45,	229}, // +527: state 181 transitions
	{gaSNUMBER+61,	24}, // +528: state 182 transitions
	{gaSNUMBER+67,	25},
	{gaSNUMBER+81,	29},
	{gaSNUMBER+59,	130},
	{gaSNUMBER+45,	182},
	{gaSNUMBER+202,	49}, // +533: state 183 transitions
	{gaSNUMBER+136,	58},
	{gaSNUMBER+138,	59},
	{gaSNUMBER+140,	60},
	{gaSNUMBER+142,	61},
	{gaSNUMBER+45,	230},
	{gaSNUMBER+61,	136}, // +539: state 184 transitions
	{gaSNUMBER+56,	231}, // +540: state 185 transitions
	{gaSNUMBER+45,	232},
	{gaSNUMBER+45,	233}, // +542: state 186 transitions
	{gaSNUMBER+56,	234}, // +543: state 187 transitions
	{gaSNUMBER+45,	235},
	{gaSNUMBER+45,	189}, // +545: state 188 transitions
	{gaSNUMBER+45,	189}, // +546: state 189 transitions
	{gaSNUMBER+67,	236},
	{gaSNUMBER+56,	237}, // +548: state 190 transitions
	{gaSNUMBER+45,	238},
	{gaSNUMBER+56,	239}, // +550: state 191 transitions
	{gaSNUMBER+45,	240},
	{gaSNUMBER+61,	136}, // +552: state 192 transitions
	{gaSNUMBER+45,	192},
	{gaSNUMBER+56,	241}, // +554: state 193 transitions
	{gaSNUMBER+45,	242},
	{gaSNUMBER+45,	243}, // +556: state 194 transitions
	{gaSNUMBER+56,	244}, // +557: state 195 transitions
	{gaSNUMBER+45,	245},
	{gaSNUMBER+45,	246}, // +559: state 196 transitions
	{gaSNUMBER+59,	152}, // +560: state 197 transitions
	{gaSNUMBER+238,	198},
	{gaSNUMBER+59,	152}, // +562: state 198 transitions
	{gaSNUMBER+120,	247}, // +563: state 199 transitions
	{gaSNUMBER+59,	152}, // +564: state 200 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+94,	248},
	{gaSNUMBER+59,	152}, // +567: state 201 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+167,	249},
	{gaSNUMBER+59,	152}, // +570: state 202 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+184,	249},
	{gaSNUMBER+59,	152}, // +573: state 203 transitions
	{gaSNUMBER+241,	198},
	{gaSNUMBER+244,	250},
	{gaSNUMBER+59,	152}, // +576: state 204 transitions
	{gaSNUMBER+246,	198},
	{gaSNUMBER+59,	152}, // +578: state 205 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+182,	251},
	{gaSNUMBER+59,	152}, // +581: state 206 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+225,	252},
	{gaSNUMBER+45,	253}, // +584: state 207 transitions
	{gaSNUMBER+186,	145}, // +585: state 208 transitions
	{gaSNUMBER+188,	254}, // +586: state 209 transitions
	{gaSNUMBER+59,	255}, // +587: state 210 transitions
	{gaSNUMBER+45,	256}, // +588: state 211 transitions
	{gaSNUMBER+45,	257}, // +589: state 212 transitions
	{gaSNUMBER+126,	51}, // +590: state 213 transitions
	{gaSNUMBER+45,	213},
	{gaSNUMBER+144,	69}, // +592: state 214 transitions
	{gaSNUMBER+59,	258},
	{gaSNUMBER+45,	216}, // +594: state 215 transitions
	{gaSNUMBER+126,	168}, // +595: state 216 transitions
	{gaSNUMBER+45,	216},
	{gaSNUMBER+67,	259},
	{gaSNUMBER+126,	168}, // +598: state 217 transitions
	{gaSNUMBER+61,	169},
	{gaSNUMBER+45,	217},
	{gaSNUMBER+45,	219}, // +601: state 218 transitions
	{gaSNUMBER+232,	168}, // +602: state 219 transitions
	{gaSNUMBER+45,	219},
	{gaSNUMBER+67,	260},
	{gaSNUMBER+61,	172}, // +605: state 220 transitions
	{gaSNUMBER+45,	220},
	{gaSNUMBER+45,	222}, // +607: state 221 transitions
	{gaSNUMBER+234,	168}, // +608: state 222 transitions
	{gaSNUMBER+45,	222},
	{gaSNUMBER+67,	261},
	{gaSNUMBER+61,	174}, // +611: state 223 transitions
	{gaSNUMBER+45,	223},
	{gaSNUMBER+45,	262}, // +613: state 224 transitions
	{gaSNUMBER+45,	263}, // +614: state 225 transitions
	{gaSNUMBER+81,	29}, // +615: state 226 transitions
	{gaSNUMBER+8,	64},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+69,	228},
	{gaSNUMBER+81,	29}, // +619: state 227 transitions
	{gaSNUMBER+190,	64},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+198,	228},
	{gaSNUMBER+6,	264},
	{gaSNUMBER+81,	29}, // +624: state 228 transitions
	{gaSNUMBER+45,	64},
	{gaSNUMBER+67,	121},
	{gaSNUMBER+6,	264},
	{gaSNUMBER+45,	265}, // +628: state 229 transitions
	{gaSNUMBER+45,	266}, // +629: state 230 transitions
	{gaSNUMBER+45,	232}, // +630: state 231 transitions
	{gaSNUMBER+126,	184}, // +631: state 232 transitions
	{gaSNUMBER+45,	232},
	{gaSNUMBER+67,	267},
	{gaSNUMBER+126,	184}, // +634: state 233 transitions
	{gaSNUMBER+61,	185},
	{gaSNUMBER+45,	233},
	{gaSNUMBER+45,	235}, // +637: state 234 transitions
	{gaSNUMBER+126,	49}, // +638: state 235 transitions
	{gaSNUMBER+45,	235},
	{gaSNUMBER+61,	268},
	{gaSNUMBER+67,	269},
	{gaSNUMBER+45,	270}, // +642: state 236 transitions
	{gaSNUMBER+45,	238}, // +643: state 237 transitions
	{gaSNUMBER+45,	238}, // +644: state 238 transitions
	{gaSNUMBER+61,	271},
	{gaSNUMBER+67,	272},
	{gaSNUMBER+45,	240}, // +647: state 239 transitions
	{gaSNUMBER+45,	240}, // +648: state 240 transitions
	{gaSNUMBER+61,	273},
	{gaSNUMBER+67,	274},
	{gaSNUMBER+45,	242}, // +651: state 241 transitions
	{gaSNUMBER+232,	184}, // +652: state 242 transitions
	{gaSNUMBER+45,	242},
	{gaSNUMBER+67,	275},
	{gaSNUMBER+61,	193}, // +655: state 243 transitions
	{gaSNUMBER+45,	243},
	{gaSNUMBER+45,	245}, // +657: state 244 transitions
	{gaSNUMBER+234,	184}, // +658: state 245 transitions
	{gaSNUMBER+45,	245},
	{gaSNUMBER+67,	276},
	{gaSNUMBER+61,	195}, // +661: state 246 transitions
	{gaSNUMBER+45,	246},
	{gaSNUMBER+244,	198}, // +663: state 247 transitions
	{gaSNUMBER+169,	251}, // +664: state 248 transitions
	{gaSNUMBER+120,	277}, // +665: state 249 transitions
	{gaSNUMBER+59,	152}, // +666: state 250 transitions
	{gaSNUMBER+144,	198},
	{gaSNUMBER+244,	278},
	{gaSNUMBER+249,	279}, // +669: state 251 transitions
	{gaSNUMBER+94,	248}, // +670: state 252 transitions
	{gaSNUMBER+45,	18}, // +671: state 253 transitions
	{gaSNUMBER+251,	280}, // +672: state 254 transitions
	{gaSNUMBER+16,	97}, // +673: state 255 transitions
	{gaSNUMBER+8,	281},
	{gaSNUMBER+10,	282},
	{gaSNUMBER+12,	283},
	{gaSNUMBER+14,	284},
	{gaSNUMBER+232,	51}, // +678: state 256 transitions
	{gaSNUMBER+45,	256},
	{gaSNUMBER+234,	51}, // +680: state 257 transitions
	{gaSNUMBER+45,	257},
	{gaSNUMBER+45,	285}, // +682: state 258 transitions
	{gaSNUMBER+45,	286}, // +683: state 259 transitions
	{gaSNUMBER+45,	287}, // +684: state 260 transitions
	{gaSNUMBER+45,	288}, // +685: state 261 transitions
	{gaSNUMBER+45,	289}, // +686: state 262 transitions
	{gaSNUMBER+144,	69}, // +687: state 263 transitions
	{gaSNUMBER+59,	290},
	{gaSNUMBER+16,	49}, // +689: state 264 transitions
	{gaSNUMBER+253,	80},
	{gaSNUMBER+8,	291},
	{gaSNUMBER+14,	292},
	{gaSNUMBER+144,	293}, // +693: state 265 transitions
	{gaSNUMBER+59,	294}, // +694: state 266 transitions
	{gaSNUMBER+45,	295}, // +695: state 267 transitions
	{gaSNUMBER+56,	296}, // +696: state 268 transitions
	{gaSNUMBER+45,	297},
	{gaSNUMBER+45,	298}, // +698: state 269 transitions
	{gaSNUMBER+45,	270}, // +699: state 270 transitions
	{gaSNUMBER+56,	299}, // +700: state 271 transitions
	{gaSNUMBER+45,	300},
	{gaSNUMBER+45,	301}, // +702: state 272 transitions
	{gaSNUMBER+56,	302}, // +703: state 273 transitions
	{gaSNUMBER+45,	303},
	{gaSNUMBER+45,	304}, // +705: state 274 transitions
	{gaSNUMBER+45,	305}, // +706: state 275 transitions
	{gaSNUMBER+45,	306}, // +707: state 276 transitions
	{gaSNUMBER+94,	307}, // +708: state 277 transitions
	{gaSNUMBER+94,	308}, // +709: state 278 transitions
	{gaSNUMBER+167,	309}, // +710: state 279 transitions
	{gaSNUMBER+94,	210}, // +711: state 280 transitions
	{gaSNUMBER+69,	97}, // +712: state 281 transitions
	{gaSNUMBER+94,	35}, // +713: state 282 transitions
	{gaSNUMBER+45,	97},
	{gaSNUMBER+59,	154},
	{gaSNUMBER+45,	97}, // +716: state 283 transitions
	{gaSNUMBER+59,	154},
	{gaSNUMBER+108,	97}, // +718: state 284 transitions
	{gaSNUMBER+59,	154},
	{gaSNUMBER+45,	310}, // +720: state 285 transitions
	{gaSNUMBER+126,	168}, // +721: state 286 transitions
	{gaSNUMBER+45,	286},
	{gaSNUMBER+232,	168}, // +723: state 287 transitions
	{gaSNUMBER+45,	287},
	{gaSNUMBER+234,	168}, // +725: state 288 transitions
	{gaSNUMBER+45,	288},
	{gaSNUMBER+59,	311}, // +727: state 289 transitions
	{gaSNUMBER+45,	312}, // +728: state 290 transitions
	{gaSNUMBER+69,	49}, // +729: state 291 transitions
	{gaSNUMBER+108,	49}, // +730: state 292 transitions
	{gaSNUMBER+45,	313}, // +731: state 293 transitions
	{gaSNUMBER+45,	314}, // +732: state 294 transitions
	{gaSNUMBER+126,	184}, // +733: state 295 transitions
	{gaSNUMBER+45,	295},
	{gaSNUMBER+45,	297}, // +735: state 296 transitions
	{gaSNUMBER+126,	49}, // +736: state 297 transitions
	{gaSNUMBER+45,	297},
	{gaSNUMBER+67,	315},
	{gaSNUMBER+126,	49}, // +739: state 298 transitions
	{gaSNUMBER+61,	268},
	{gaSNUMBER+45,	298},
	{gaSNUMBER+45,	300}, // +742: state 299 transitions
	{gaSNUMBER+232,	49}, // +743: state 300 transitions
	{gaSNUMBER+45,	300},
	{gaSNUMBER+67,	316},
	{gaSNUMBER+61,	271}, // +746: state 301 transitions
	{gaSNUMBER+45,	301},
	{gaSNUMBER+45,	303}, // +748: state 302 transitions
	{gaSNUMBER+234,	49}, // +749: state 303 transitions
	{gaSNUMBER+45,	303},
	{gaSNUMBER+67,	317},
	{gaSNUMBER+61,	273}, // +752: state 304 transitions
	{gaSNUMBER+45,	304},
	{gaSNUMBER+232,	184}, // +754: state 305 transitions
	{gaSNUMBER+45,	305},
	{gaSNUMBER+234,	184}, // +756: state 306 transitions
	{gaSNUMBER+45,	306},
	{gaSNUMBER+167,	198}, // +758: state 307 transitions
	{gaSNUMBER+225,	198}, // +759: state 308 transitions
	{gaSNUMBER+94,	198}, // +760: state 309 transitions
	{gaSNUMBER+59,	318}, // +761: state 310 transitions
	{gaSNUMBER+45,	319}, // +762: state 311 transitions
	{gaSNUMBER+45,	320}, // +763: state 312 transitions
	{gaSNUMBER+45,	321}, // +764: state 313 transitions
	{gaSNUMBER+45,	322}, // +765: state 314 transitions
	{gaSNUMBER+45,	323}, // +766: state 315 transitions
	{gaSNUMBER+45,	324}, // +767: state 316 transitions
	{gaSNUMBER+45,	325}, // +768: state 317 transitions
	{gaSNUMBER+45,	230}, // +769: state 318 transitions
	{gaSNUMBER+45,	326}, // +770: state 319 transitions
	{gaSNUMBER+59,	327}, // +771: state 320 transitions
	{gaSNUMBER+144,	1}, // +772: state 321 transitions
	{gaSNUMBER+59,	1}, // +773: state 322 transitions
	{gaSNUMBER+126,	49}, // +774: state 323 transitions
	{gaSNUMBER+45,	323},
	{gaSNUMBER+232,	49}, // +776: state 324 transitions
	{gaSNUMBER+45,	324},
	{gaSNUMBER+234,	49}, // +778: state 325 transitions
	{gaSNUMBER+45,	325},
	{gaSNUMBER+59,	328}, // +780: state 326 transitions
	{gaSNUMBER+45,	329}, // +781: state 327 transitions
	{gaSNUMBER+45,	330}, // +782: state 328 transitions
	{gaSNUMBER+45,	331}, // +783: state 329 transitions
	{gaSNUMBER+45,	332}, // +784: state 330 transitions
	{gaSNUMBER+59,	294}, // +785: state 331 transitions
	{gaSNUMBER+59,	1}, // +786: state 332 transitions
};

const STATE_DESCRIPTION aStateDescNUMBER[333] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 17, gaTNUMBER+0},
	/*   1 */ {0, 1, gaTNUMBER+17},
	/*   2 */ {0, 2, gaTNUMBER+18},
	/*   3 */ {0, 1, gaTNUMBER+20},
	/*   4 */ {0, 1, gaTNUMBER+21},
	/*   5 */ {1, 8, gaTNUMBER+22},
	/*   6 */ {1, 10, gaTNUMBER+30},
	/*   7 */ {1, 10, gaTNUMBER+40},
	/*   8 */ {1, 10, gaTNUMBER+50},
	/*   9 */ {1, 9, gaTNUMBER+60},
	/*  10 */ {0, 1, gaTNUMBER+69},
	/*  11 */ {0, 1, gaTNUMBER+70},
	/*  12 */ {0, 1, gaTNUMBER+71},
	/*  13 */ {0, 2, gaTNUMBER+72},
	/*  14 */ {0, 1, gaTNUMBER+74},
	/*  15 */ {0, 1, gaTNUMBER+75},
	/*  16 */ {0, 2, gaTNUMBER+76},
	/*  17 */ {0, 2, gaTNUMBER+78},
	/*  18 */ {0, 1, gaTNUMBER+80},
	/*  19 */ {0, 1, gaTNUMBER+81},
	/*  20 */ {0, 4, gaTNUMBER+82},
	/*  21 */ {1, 5, gaTNUMBER+86},
	/*  22 */ {1, 5, gaTNUMBER+91},
	/*  23 */ {0, 5, gaTNUMBER+96},
	/*  24 */ {0, 5, gaTNUMBER+101},
	/*  25 */ {0, 1, gaTNUMBER+106},
	/*  26 */ {1, 8, gaTNUMBER+107},
	/*  27 */ {1, 10, gaTNUMBER+115},
	/*  28 */ {0, 2, gaTNUMBER+125},
	/*  29 */ {0, 5, gaTNUMBER+127},
	/*  30 */ {0, 2, gaTNUMBER+132},
	/*  31 */ {0, 12, gaTNUMBER+134},
	/*  32 */ {0, 7, gaTNUMBER+146},
	/*  33 */ {0, 7, gaTNUMBER+153},
	/*  34 */ {1, 10, gaTNUMBER+160},
	/*  35 */ {0, 1, gaTNUMBER+170},
	/*  36 */ {1, 8, gaTNUMBER+171},
	/*  37 */ {1, 6, gaTNUMBER+179},
	/*  38 */ {0, 1, gaTNUMBER+185},
	/*  39 */ {0, 1, gaTNUMBER+186},
	/*  40 */ {0, 1, gaTNUMBER+187},
	/*  41 */ {0, 1, gaTNUMBER+188},
	/*  42 */ {0, 1, gaTNUMBER+189},
	/*  43 */ {0, 1, gaTNUMBER+190},
	/*  44 */ {0, 1, gaTNUMBER+191},
	/*  45 */ {0, 1, gaTNUMBER+192},
	/*  46 */ {0, 3, gaTNUMBER+193},
	/*  47 */ {0, 1, gaTNUMBER+196},
	/*  48 */ {0, 3, gaTNUMBER+197},
	/*  49 */ {1, 0, NULL},
	/*  50 */ {0, 4, gaTNUMBER+200},
	/*  51 */ {1, 2, gaTNUMBER+204},
	/*  52 */ {0, 2, gaTNUMBER+206},
	/*  53 */ {0, 1, gaTNUMBER+208},
	/*  54 */ {0, 4, gaTNUMBER+209},
	/*  55 */ {0, 1, gaTNUMBER+213},
	/*  56 */ {0, 1, gaTNUMBER+214},
	/*  57 */ {1, 5, gaTNUMBER+215},
	/*  58 */ {0, 1, gaTNUMBER+220},
	/*  59 */ {1, 3, gaTNUMBER+221},
	/*  60 */ {0, 1, gaTNUMBER+224},
	/*  61 */ {1, 2, gaTNUMBER+225},
	/*  62 */ {0, 2, gaTNUMBER+227},
	/*  63 */ {0, 1, gaTNUMBER+229},
	/*  64 */ {1, 3, gaTNUMBER+230},
	/*  65 */ {0, 2, gaTNUMBER+233},
	/*  66 */ {0, 2, gaTNUMBER+235},
	/*  67 */ {1, 4, gaTNUMBER+237},
	/*  68 */ {0, 7, gaTNUMBER+241},
	/*  69 */ {0, 1, gaTNUMBER+248},
	/*  70 */ {1, 5, gaTNUMBER+249},
	/*  71 */ {0, 14, gaTNUMBER+254},
	/*  72 */ {1, 5, gaTNUMBER+268},
	/*  73 */ {1, 3, gaTNUMBER+273},
	/*  74 */ {1, 2, gaTNUMBER+276},
	/*  75 */ {0, 2, gaTNUMBER+278},
	/*  76 */ {0, 1, gaTNUMBER+280},
	/*  77 */ {1, 3, gaTNUMBER+281},
	/*  78 */ {0, 2, gaTNUMBER+284},
	/*  79 */ {0, 2, gaTNUMBER+286},
	/*  80 */ {1, 1, gaTNUMBER+288},
	/*  81 */ {0, 2, gaTNUMBER+289},
	/*  82 */ {0, 1, gaTNUMBER+291},
	/*  83 */ {1, 4, gaTNUMBER+292},
	/*  84 */ {0, 2, gaTNUMBER+296},
	/*  85 */ {0, 1, gaTNUMBER+298},
	/*  86 */ {0, 1, gaTNUMBER+299},
	/*  87 */ {0, 1, gaTNUMBER+300},
	/*  88 */ {0, 1, gaTNUMBER+301},
	/*  89 */ {1, 3, gaTNUMBER+302},
	/*  90 */ {1, 4, gaTNUMBER+305},
	/*  91 */ {1, 5, gaTNUMBER+309},
	/*  92 */ {1, 4, gaTNUMBER+314},
	/*  93 */ {1, 4, gaTNUMBER+318},
	/*  94 */ {1, 5, gaTNUMBER+322},
	/*  95 */ {1, 4, gaTNUMBER+327},
	/*  96 */ {1, 5, gaTNUMBER+331},
	/*  97 */ {0, 1, gaTNUMBER+336},
	/*  98 */ {0, 14, gaTNUMBER+337},
	/*  99 */ {0, 7, gaTNUMBER+351},
	/* 100 */ {0, 1, gaTNUMBER+358},
	/* 101 */ {0, 1, gaTNUMBER+359},
	/* 102 */ {0, 1, gaTNUMBER+360},
	/* 103 */ {0, 1, gaTNUMBER+361},
	/* 104 */ {0, 1, gaTNUMBER+362},
	/* 105 */ {0, 2, gaTNUMBER+363},
	/* 106 */ {0, 1, gaTNUMBER+365},
	/* 107 */ {0, 2, gaTNUMBER+366},
	/* 108 */ {0, 1, gaTNUMBER+368},
	/* 109 */ {0, 1, gaTNUMBER+369},
	/* 110 */ {0, 3, gaTNUMBER+370},
	/* 111 */ {0, 3, gaTNUMBER+373},
	/* 112 */ {1, 3, gaTNUMBER+376},
	/* 113 */ {1, 4, gaTNUMBER+379},
	/* 114 */ {0, 3, gaTNUMBER+383},
	/* 115 */ {0, 1, gaTNUMBER+386},
	/* 116 */ {1, 1, gaTNUMBER+387},
	/* 117 */ {1, 1, gaTNUMBER+388},
	/* 118 */ {0, 1, gaTNUMBER+389},
	/* 119 */ {0, 1, gaTNUMBER+390},
	/* 120 */ {0, 4, gaTNUMBER+391},
	/* 121 */ {0, 1, gaTNUMBER+395},
	/* 122 */ {0, 1, gaTNUMBER+396},
	/* 123 */ {0, 3, gaTNUMBER+397},
	/* 124 */ {0, 1, gaTNUMBER+400},
	/* 125 */ {0, 3, gaTNUMBER+401},
	/* 126 */ {1, 4, gaTNUMBER+404},
	/* 127 */ {0, 1, gaTNUMBER+408},
	/* 128 */ {0, 1, gaTNUMBER+409},
	/* 129 */ {0, 1, gaTNUMBER+410},
	/* 130 */ {0, 5, gaTNUMBER+411},
	/* 131 */ {1, 7, gaTNUMBER+416},
	/* 132 */ {1, 7, gaTNUMBER+423},
	/* 133 */ {0, 1, gaTNUMBER+430},
	/* 134 */ {0, 1, gaTNUMBER+431},
	/* 135 */ {0, 4, gaTNUMBER+432},
	/* 136 */ {0, 5, gaTNUMBER+436},
	/* 137 */ {0, 1, gaTNUMBER+441},
	/* 138 */ {0, 1, gaTNUMBER+442},
	/* 139 */ {0, 3, gaTNUMBER+443},
	/* 140 */ {0, 1, gaTNUMBER+446},
	/* 141 */ {0, 3, gaTNUMBER+447},
	/* 142 */ {0, 1, gaTNUMBER+450},
	/* 143 */ {1, 3, gaTNUMBER+451},
	/* 144 */ {0, 1, gaTNUMBER+454},
	/* 145 */ {0, 1, gaTNUMBER+455},
	/* 146 */ {0, 1, gaTNUMBER+456},
	/* 147 */ {0, 1, gaTNUMBER+457},
	/* 148 */ {0, 2, gaTNUMBER+458},
	/* 149 */ {0, 1, gaTNUMBER+460},
	/* 150 */ {0, 1, gaTNUMBER+461},
	/* 151 */ {0, 1, gaTNUMBER+462},
	/* 152 */ {0, 1, gaTNUMBER+463},
	/* 153 */ {1, 6, gaTNUMBER+464},
	/* 154 */ {0, 8, gaTNUMBER+470},
	/* 155 */ {0, 1, gaTNUMBER+478},
	/* 156 */ {0, 1, gaTNUMBER+479},
	/* 157 */ {0, 1, gaTNUMBER+480},
	/* 158 */ {0, 1, gaTNUMBER+481},
	/* 159 */ {0, 3, gaTNUMBER+482},
	/* 160 */ {0, 2, gaTNUMBER+485},
	/* 161 */ {0, 1, gaTNUMBER+487},
	/* 162 */ {0, 3, gaTNUMBER+488},
	/* 163 */ {0, 2, gaTNUMBER+491},
	/* 164 */ {0, 1, gaTNUMBER+493},
	/* 165 */ {0, 1, gaTNUMBER+494},
	/* 166 */ {0, 1, gaTNUMBER+495},
	/* 167 */ {1, 1, gaTNUMBER+496},
	/* 168 */ {1, 1, gaTNUMBER+497},
	/* 169 */ {0, 2, gaTNUMBER+498},
	/* 170 */ {0, 1, gaTNUMBER+500},
	/* 171 */ {1, 2, gaTNUMBER+501},
	/* 172 */ {0, 2, gaTNUMBER+503},
	/* 173 */ {0, 1, gaTNUMBER+505},
	/* 174 */ {0, 2, gaTNUMBER+506},
	/* 175 */ {0, 1, gaTNUMBER+508},
	/* 176 */ {0, 1, gaTNUMBER+509},
	/* 177 */ {0, 2, gaTNUMBER+510},
	/* 178 */ {0, 1, gaTNUMBER+512},
	/* 179 */ {0, 7, gaTNUMBER+513},
	/* 180 */ {0, 7, gaTNUMBER+520},
	/* 181 */ {0, 1, gaTNUMBER+527},
	/* 182 */ {1, 5, gaTNUMBER+528},
	/* 183 */ {0, 6, gaTNUMBER+533},
	/* 184 */ {1, 1, gaTNUMBER+539},
	/* 185 */ {0, 2, gaTNUMBER+540},
	/* 186 */ {0, 1, gaTNUMBER+542},
	/* 187 */ {0, 2, gaTNUMBER+543},
	/* 188 */ {0, 1, gaTNUMBER+545},
	/* 189 */ {1, 2, gaTNUMBER+546},
	/* 190 */ {0, 2, gaTNUMBER+548},
	/* 191 */ {0, 2, gaTNUMBER+550},
	/* 192 */ {1, 2, gaTNUMBER+552},
	/* 193 */ {0, 2, gaTNUMBER+554},
	/* 194 */ {0, 1, gaTNUMBER+556},
	/* 195 */ {0, 2, gaTNUMBER+557},
	/* 196 */ {0, 1, gaTNUMBER+559},
	/* 197 */ {1, 2, gaTNUMBER+560},
	/* 198 */ {1, 1, gaTNUMBER+562},
	/* 199 */ {0, 1, gaTNUMBER+563},
	/* 200 */ {1, 3, gaTNUMBER+564},
	/* 201 */ {1, 3, gaTNUMBER+567},
	/* 202 */ {1, 3, gaTNUMBER+570},
	/* 203 */ {1, 3, gaTNUMBER+573},
	/* 204 */ {1, 2, gaTNUMBER+576},
	/* 205 */ {1, 3, gaTNUMBER+578},
	/* 206 */ {1, 3, gaTNUMBER+581},
	/* 207 */ {0, 1, gaTNUMBER+584},
	/* 208 */ {0, 1, gaTNUMBER+585},
	/* 209 */ {0, 1, gaTNUMBER+586},
	/* 210 */ {0, 1, gaTNUMBER+587},
	/* 211 */ {0, 1, gaTNUMBER+588},
	/* 212 */ {0, 1, gaTNUMBER+589},
	/* 213 */ {0, 2, gaTNUMBER+590},
	/* 214 */ {0, 2, gaTNUMBER+592},
	/* 215 */ {0, 1, gaTNUMBER+594},
	/* 216 */ {0, 3, gaTNUMBER+595},
	/* 217 */ {0, 3, gaTNUMBER+598},
	/* 218 */ {0, 1, gaTNUMBER+601},
	/* 219 */ {0, 3, gaTNUMBER+602},
	/* 220 */ {0, 2, gaTNUMBER+605},
	/* 221 */ {0, 1, gaTNUMBER+607},
	/* 222 */ {0, 3, gaTNUMBER+608},
	/* 223 */ {0, 2, gaTNUMBER+611},
	/* 224 */ {0, 1, gaTNUMBER+613},
	/* 225 */ {0, 1, gaTNUMBER+614},
	/* 226 */ {1, 4, gaTNUMBER+615},
	/* 227 */ {1, 5, gaTNUMBER+619},
	/* 228 */ {1, 4, gaTNUMBER+624},
	/* 229 */ {0, 1, gaTNUMBER+628},
	/* 230 */ {0, 1, gaTNUMBER+629},
	/* 231 */ {0, 1, gaTNUMBER+630},
	/* 232 */ {0, 3, gaTNUMBER+631},
	/* 233 */ {0, 3, gaTNUMBER+634},
	/* 234 */ {0, 1, gaTNUMBER+637},
	/* 235 */ {0, 4, gaTNUMBER+638},
	/* 236 */ {0, 1, gaTNUMBER+642},
	/* 237 */ {0, 1, gaTNUMBER+643},
	/* 238 */ {0, 3, gaTNUMBER+644},
	/* 239 */ {0, 1, gaTNUMBER+647},
	/* 240 */ {0, 3, gaTNUMBER+648},
	/* 241 */ {0, 1, gaTNUMBER+651},
	/* 242 */ {0, 3, gaTNUMBER+652},
	/* 243 */ {0, 2, gaTNUMBER+655},
	/* 244 */ {0, 1, gaTNUMBER+657},
	/* 245 */ {0, 3, gaTNUMBER+658},
	/* 246 */ {0, 2, gaTNUMBER+661},
	/* 247 */ {0, 1, gaTNUMBER+663},
	/* 248 */ {0, 1, gaTNUMBER+664},
	/* 249 */ {0, 1, gaTNUMBER+665},
	/* 250 */ {1, 3, gaTNUMBER+666},
	/* 251 */ {0, 1, gaTNUMBER+669},
	/* 252 */ {0, 1, gaTNUMBER+670},
	/* 253 */ {1, 1, gaTNUMBER+671},
	/* 254 */ {0, 1, gaTNUMBER+672},
	/* 255 */ {0, 5, gaTNUMBER+673},
	/* 256 */ {0, 2, gaTNUMBER+678},
	/* 257 */ {0, 2, gaTNUMBER+680},
	/* 258 */ {0, 1, gaTNUMBER+682},
	/* 259 */ {0, 1, gaTNUMBER+683},
	/* 260 */ {0, 1, gaTNUMBER+684},
	/* 261 */ {0, 1, gaTNUMBER+685},
	/* 262 */ {0, 1, gaTNUMBER+686},
	/* 263 */ {0, 2, gaTNUMBER+687},
	/* 264 */ {0, 4, gaTNUMBER+689},
	/* 265 */ {0, 1, gaTNUMBER+693},
	/* 266 */ {0, 1, gaTNUMBER+694},
	/* 267 */ {0, 1, gaTNUMBER+695},
	/* 268 */ {0, 2, gaTNUMBER+696},
	/* 269 */ {0, 1, gaTNUMBER+698},
	/* 270 */ {1, 1, gaTNUMBER+699},
	/* 271 */ {0, 2, gaTNUMBER+700},
	/* 272 */ {0, 1, gaTNUMBER+702},
	/* 273 */ {0, 2, gaTNUMBER+703},
	/* 274 */ {0, 1, gaTNUMBER+705},
	/* 275 */ {0, 1, gaTNUMBER+706},
	/* 276 */ {0, 1, gaTNUMBER+707},
	/* 277 */ {0, 1, gaTNUMBER+708},
	/* 278 */ {0, 1, gaTNUMBER+709},
	/* 279 */ {0, 1, gaTNUMBER+710},
	/* 280 */ {0, 1, gaTNUMBER+711},
	/* 281 */ {0, 1, gaTNUMBER+712},
	/* 282 */ {0, 3, gaTNUMBER+713},
	/* 283 */ {0, 2, gaTNUMBER+716},
	/* 284 */ {0, 2, gaTNUMBER+718},
	/* 285 */ {0, 1, gaTNUMBER+720},
	/* 286 */ {0, 2, gaTNUMBER+721},
	/* 287 */ {0, 2, gaTNUMBER+723},
	/* 288 */ {0, 2, gaTNUMBER+725},
	/* 289 */ {0, 1, gaTNUMBER+727},
	/* 290 */ {0, 1, gaTNUMBER+728},
	/* 291 */ {0, 1, gaTNUMBER+729},
	/* 292 */ {1, 1, gaTNUMBER+730},
	/* 293 */ {0, 1, gaTNUMBER+731},
	/* 294 */ {0, 1, gaTNUMBER+732},
	/* 295 */ {0, 2, gaTNUMBER+733},
	/* 296 */ {0, 1, gaTNUMBER+735},
	/* 297 */ {0, 3, gaTNUMBER+736},
	/* 298 */ {0, 3, gaTNUMBER+739},
	/* 299 */ {0, 1, gaTNUMBER+742},
	/* 300 */ {0, 3, gaTNUMBER+743},
	/* 301 */ {0, 2, gaTNUMBER+746},
	/* 302 */ {0, 1, gaTNUMBER+748},
	/* 303 */ {0, 3, gaTNUMBER+749},
	/* 304 */ {0, 2, gaTNUMBER+752},
	/* 305 */ {0, 2, gaTNUMBER+754},
	/* 306 */ {0, 2, gaTNUMBER+756},
	/* 307 */ {0, 1, gaTNUMBER+758},
	/* 308 */ {0, 1, gaTNUMBER+759},
	/* 309 */ {0, 1, gaTNUMBER+760},
	/* 310 */ {0, 1, gaTNUMBER+761},
	/* 311 */ {0, 1, gaTNUMBER+762},
	/* 312 */ {0, 1, gaTNUMBER+763},
	/* 313 */ {0, 1, gaTNUMBER+764},
	/* 314 */ {0, 1, gaTNUMBER+765},
	/* 315 */ {0, 1, gaTNUMBER+766},
	/* 316 */ {0, 1, gaTNUMBER+767},
	/* 317 */ {0, 1, gaTNUMBER+768},
	/* 318 */ {0, 1, gaTNUMBER+769},
	/* 319 */ {0, 1, gaTNUMBER+770},
	/* 320 */ {0, 1, gaTNUMBER+771},
	/* 321 */ {0, 1, gaTNUMBER+772},
	/* 322 */ {0, 1, gaTNUMBER+773},
	/* 323 */ {0, 2, gaTNUMBER+774},
	/* 324 */ {0, 2, gaTNUMBER+776},
	/* 325 */ {0, 2, gaTNUMBER+778},
	/* 326 */ {1, 1, gaTNUMBER+780},
	/* 327 */ {0, 1, gaTNUMBER+781},
	/* 328 */ {0, 1, gaTNUMBER+782},
	/* 329 */ {0, 1, gaTNUMBER+783},
	/* 330 */ {0, 1, gaTNUMBER+784},
	/* 331 */ {1, 1, gaTNUMBER+785},
	/* 332 */ {1, 1, gaTNUMBER+786},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:28 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numsimple

// 5 states

static const unsigned char gaSNUMSIMPLE[] = 
	/* gaStringNUMSIMPLE+0 */	"+-\000"
	/* gaStringNUMSIMPLE+3 */	"0123456789\000"
	/* gaStringNUMSIMPLE+14 */	",\000"
;

static const STATE_TRANSITION gaTNUMSIMPLE[] = {
	{gaSNUMSIMPLE+0,	1}, // +0: state 0 transitions
	{gaSNUMSIMPLE+3,	2},
	{gaSNUMSIMPLE+3,	2}, // +2: state 1 transitions
	{gaSNUMSIMPLE+3,	2}, // +3: state 2 transitions
	{gaSNUMSIMPLE+14,	3},
	{gaSNUMSIMPLE+3,	4}, // +5: state 3 transitions
	{gaSNUMSIMPLE+3,	4}, // +6: state 4 transitions
};

const STATE_DESCRIPTION aStateDescNUMSIMPLE[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMSIMPLE+0},
	/*   1 */ {0, 1, gaTNUMSIMPLE+2},
	/*   2 */ {1, 2, gaTNUMSIMPLE+3},
	/*   3 */ {0, 1, gaTNUMSIMPLE+5},
	/*   4 */ {1, 1, gaTNUMSIMPLE+6},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:28 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numnth

// 9 states

static const unsigned char gaSNUMNTH[] = 
	/* gaStringNUMNTH+0 */	"0123456789\000"
	/* gaStringNUMNTH+11 */	"E\000"
	/* gaStringNUMNTH+13 */	"e\000"
	/* gaStringNUMNTH+15 */	"\000"
	/* gaStringNUMNTH+17 */	"\000"
	/* gaStringNUMNTH+19 */	"R\000"
	/* gaStringNUMNTH+21 */	"r\000"
	/* gaStringNUMNTH+23 */	"m\000"
	/* gaStringNUMNTH+25 */	"mr\000"
;

static const STATE_TRANSITION gaTNUMNTH[] = {
	{gaSNUMNTH+0,	1}, // +0: state 0 transitions
	{gaSNUMNTH+0,	1}, // +1: state 1 transitions
	{gaSNUMNTH+11,	2},
	{gaSNUMNTH+13,	3},
	{gaSNUMNTH+15,	4},
	{gaSNUMNTH+17,	5},
	{gaSNUMNTH+19,	6}, // +6: state 2 transitions
	{gaSNUMNTH+21,	6}, // +7: state 3 transitions
	{gaSNUMNTH+19,	7}, // +8: state 4 transitions
	{gaSNUMNTH+23,	8},
	{gaSNUMNTH+25,	8}, // +10: state 5 transitions
	{gaSNUMNTH+11,	6}, // +11: state 7 transitions
	{gaSNUMNTH+13,	6}, // +12: state 8 transitions
};

const STATE_DESCRIPTION aStateDescNUMNTH[9] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNTH+0},
	/*   1 */ {0, 5, gaTNUMNTH+1},
	/*   2 */ {1, 1, gaTNUMNTH+6},
	/*   3 */ {1, 1, gaTNUMNTH+7},
	/*   4 */ {1, 2, gaTNUMNTH+8},
	/*   5 */ {1, 1, gaTNUMNTH+10},
	/*   6 */ {1, 0, NULL},
	/*   7 */ {0, 1, gaTNUMNTH+11},
	/*   8 */ {0, 1, gaTNUMNTH+12},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:28 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numunit

// 20 states

static const unsigned char gaSNUMUNIT[] = 
	/* gaStringNUMUNIT+0 */	"+-\000"
	/* gaStringNUMUNIT+3 */	"0123456789\000"
	/* gaStringNUMUNIT+14 */	" \000"
	/* gaStringNUMUNIT+16 */	",\000"
	/* gaStringNUMUNIT+18 */	"\000"
	/* gaStringNUMUNIT+20 */	"K\000"
	/* gaStringNUMUNIT+22 */	"LTajlqst\000"
	/* gaStringNUMUNIT+31 */	"M\000"
	/* gaStringNUMUNIT+33 */	"c\000"
	/* gaStringNUMUNIT+35 */	"d\000"
	/* gaStringNUMUNIT+37 */	"g\000"
	/* gaStringNUMUNIT+39 */	"h\000"
	/* gaStringNUMUNIT+41 */	"k\000"
	/* gaStringNUMUNIT+43 */	"m\000"
	/* gaStringNUMUNIT+45 */	"gmo\000"
	/* gaStringNUMUNIT+49 */	".\000"
	/* gaStringNUMUNIT+51 */	"o\000"
	/* gaStringNUMUNIT+53 */	"aglm\000"
	/* gaStringNUMUNIT+58 */	"Bglm\000"
	/* gaStringNUMUNIT+63 */	"a\000"
	/* gaStringNUMUNIT+65 */	"r\000"
	/* gaStringNUMUNIT+67 */	"gm\000"
	/* gaStringNUMUNIT+70 */	"glm\000"
	/* gaStringNUMUNIT+74 */	"i\000"
	/* gaStringNUMUNIT+76 */	"CF\000"
	/* gaStringNUMUNIT+79 */	"n\000"
;

static const STATE_TRANSITION gaTNUMUNIT[] = {
	{gaSNUMUNIT+0,	1}, // +0: state 0 transitions
	{gaSNUMUNIT+3,	2},
	{gaSNUMUNIT+3,	2}, // +2: state 1 transitions
	{gaSNUMUNIT+3,	2}, // +3: state 2 transitions
	{gaSNUMUNIT+14,	3},
	{gaSNUMUNIT+16,	4},
	{gaSNUMUNIT+18,	5},
	{gaSNUMUNIT+20,	6}, // +7: state 3 transitions
	{gaSNUMUNIT+22,	7},
	{gaSNUMUNIT+31,	8},
	{gaSNUMUNIT+33,	9},
	{gaSNUMUNIT+35,	10},
	{gaSNUMUNIT+37,	11},
	{gaSNUMUNIT+39,	12},
	{gaSNUMUNIT+41,	13},
	{gaSNUMUNIT+43,	14},
	{gaSNUMUNIT+3,	15}, // +16: state 4 transitions
	{gaSNUMUNIT+14,	16}, // +17: state 5 transitions
	{gaSNUMUNIT+45,	7}, // +18: state 6 transitions
	{gaSNUMUNIT+49,	17}, // +19: state 7 transitions
	{gaSNUMUNIT+51,	7}, // +20: state 8 transitions
	{gaSNUMUNIT+53,	7}, // +21: state 9 transitions
	{gaSNUMUNIT+58,	7}, // +22: state 10 transitions
	{gaSNUMUNIT+63,	18},
	{gaSNUMUNIT+65,	7}, // +24: state 11 transitions
	{gaSNUMUNIT+49,	17},
	{gaSNUMUNIT+53,	7}, // +26: state 12 transitions
	{gaSNUMUNIT+49,	17},
	{gaSNUMUNIT+67,	7}, // +28: state 13 transitions
	{gaSNUMUNIT+70,	7}, // +29: state 14 transitions
	{gaSNUMUNIT+49,	17},
	{gaSNUMUNIT+74,	19},
	{gaSNUMUNIT+14,	3}, // +32: state 15 transitions
	{gaSNUMUNIT+18,	5},
	{gaSNUMUNIT+3,	15},
	{gaSNUMUNIT+76,	17}, // +35: state 16 transitions
	{gaSNUMUNIT+70,	7}, // +36: state 18 transitions
	{gaSNUMUNIT+79,	7}, // +37: state 19 transitions
};

const STATE_DESCRIPTION aStateDescNUMUNIT[20] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMUNIT+0},
	/*   1 */ {0, 1, gaTNUMUNIT+2},
	/*   2 */ {0, 4, gaTNUMUNIT+3},
	/*   3 */ {0, 9, gaTNUMUNIT+7},
	/*   4 */ {0, 1, gaTNUMUNIT+16},
	/*   5 */ {0, 1, gaTNUMUNIT+17},
	/*   6 */ {0, 1, gaTNUMUNIT+18},
	/*   7 */ {1, 1, gaTNUMUNIT+19},
	/*   8 */ {0, 1, gaTNUMUNIT+20},
	/*   9 */ {0, 1, gaTNUMUNIT+21},
	/*  10 */ {0, 2, gaTNUMUNIT+22},
	/*  11 */ {1, 2, gaTNUMUNIT+24},
	/*  12 */ {1, 2, gaTNUMUNIT+26},
	/*  13 */ {0, 1, gaTNUMUNIT+28},
	/*  14 */ {1, 3, gaTNUMUNIT+29},
	/*  15 */ {0, 3, gaTNUMUNIT+32},
	/*  16 */ {0, 1, gaTNUMUNIT+35},
	/*  17 */ {1, 0, NULL},
	/*  18 */ {0, 1, gaTNUMUNIT+36},
	/*  19 */ {0, 1, gaTNUMUNIT+37},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:28 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numnum

// 4 states

static const unsigned char gaSNUMNUM[] = 
	/* gaStringNUMNUM+0 */	"\000"
	/* gaStringNUMNUM+2 */	" \000"
	/* gaStringNUMNUM+4 */	"0123456789\000"
;

static const STATE_TRANSITION gaTNUMNUM[] = {
	{gaSNUMNUM+0,	1}, // +0: state 0 transitions
	{gaSNUMNUM+2,	2}, // +1: state 1 transitions
	{gaSNUMNUM+4,	3}, // +2: state 2 transitions
	{gaSNUMNUM+4,	3}, // +3: state 3 transitions
};

const STATE_DESCRIPTION aStateDescNUMNUM[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNUM+0},
	/*   1 */ {0, 1, gaTNUMNUM+1},
	/*   2 */ {0, 1, gaTNUMNUM+2},
	/*   3 */ {1, 1, gaTNUMNUM+3},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:28 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numpercent

// 7 states

static const unsigned char gaSNUMPERCENT[] = 
	/* gaStringNUMPERCENT+0 */	"+-\000"
	/* gaStringNUMPERCENT+3 */	"0123456789\000"
	/* gaStringNUMPERCENT+14 */	" \000"
	/* gaStringNUMPERCENT+16 */	",\000"
	/* gaStringNUMPERCENT+18 */	"%\000"
;

static const STATE_TRANSITION gaTNUMPERCENT[] = {
	{gaSNUMPERCENT+0,	1}, // +0: state 0 transitions
	{gaSNUMPERCENT+3,	2},
	{gaSNUMPERCENT+3,	2}, // +2: state 1 transitions
	{gaSNUMPERCENT+3,	2}, // +3: state 2 transitions
	{gaSNUMPERCENT+14,	3},
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5}, // +6: state 3 transitions
	{gaSNUMPERCENT+3,	6}, // +7: state 4 transitions
	{gaSNUMPERCENT+14,	3}, // +8: state 6 transitions
	{gaSNUMPERCENT+3,	6},
};

const STATE_DESCRIPTION aStateDescNUMPERCENT[7] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMPERCENT+0},
	/*   1 */ {0, 1, gaTNUMPERCENT+2},
	/*   2 */ {0, 3, gaTNUMPERCENT+3},
	/*   3 */ {0, 1, gaTNUMPERCENT+6},
	/*   4 */ {0, 1, gaTNUMPERCENT+7},
	/*   5 */ {1, 0, NULL},
	/*   6 */ {0, 2, gaTNUMPERCENT+8},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numdate

// 116 states

static const unsigned char gaSNUMDATE[] = 
	/* gaStringNUMDATE+0 */	"'\000"
	/* gaStringNUMDATE+2 */	"0\000"
	/* gaStringNUMDATE+4 */	"1\000"
	/* gaStringNUMDATE+6 */	"2\000"
	/* gaStringNUMDATE+8 */	"3\000"
	/* gaStringNUMDATE+10 */	"456789\000"
	/* gaStringNUMDATE+17 */	"Dd\000"
	/* gaStringNUMDATE+20 */	"Jj\000"
	/* gaStringNUMDATE+23 */	"Ll\000"
	/* gaStringNUMDATE+26 */	"Mm\000"
	/* gaStringNUMDATE+29 */	"Ss\000"
	/* gaStringNUMDATE+32 */	"Vv\000"
	/* gaStringNUMDATE+35 */	"0123456789\000"
	/* gaStringNUMDATE+46 */	"123456789\000"
	/* gaStringNUMDATE+56 */	"012\000"
	/* gaStringNUMDATE+60 */	" \000"
	/* gaStringNUMDATE+62 */	"-\000"
	/* gaStringNUMDATE+64 */	"/\000"
	/* gaStringNUMDATE+66 */	"3456789\000"
	/* gaStringNUMDATE+74 */	"e\000"
	/* gaStringNUMDATE+76 */	"23456789\000"
	/* gaStringNUMDATE+85 */	"01\000"
	/* gaStringNUMDATE+88 */	"i\000"
	/* gaStringNUMDATE+90 */	"u\000"
	/* gaStringNUMDATE+92 */	"a\000"
	/* gaStringNUMDATE+94 */	"Aa\000"
	/* gaStringNUMDATE+97 */	"Ff\000"
	/* gaStringNUMDATE+100 */	"Nn\000"
	/* gaStringNUMDATE+103 */	"Oo\000"
	/* gaStringNUMDATE+106 */	"r\000"
	/* gaStringNUMDATE+108 */	"m\000"
	/* gaStringNUMDATE+110 */	"n\000"
	/* gaStringNUMDATE+112 */	"o\000"
	/* gaStringNUMDATE+114 */	"v\000"
	/* gaStringNUMDATE+116 */	"\000"
	/* gaStringNUMDATE+118 */	"c\000"
	/* gaStringNUMDATE+120 */	"d\000"
	/* gaStringNUMDATE+122 */	"\000"
	/* gaStringNUMDATE+124 */	".\000"
	/* gaStringNUMDATE+126 */	"t\000"
	/* gaStringNUMDATE+128 */	"p\000"
	/* gaStringNUMDATE+130 */	".t\000"
	/* gaStringNUMDATE+133 */	".n\000"
	/* gaStringNUMDATE+136 */	"l\000"
	/* gaStringNUMDATE+138 */	".s\000"
	/* gaStringNUMDATE+141 */	"b\000"
	/* gaStringNUMDATE+143 */	"h\000"
	/* gaStringNUMDATE+145 */	"12\000"
;

static const STATE_TRANSITION gaTNUMDATE[] = {
	{gaSNUMDATE+0,	1}, // +0: state 0 transitions
	{gaSNUMDATE+2,	2},
	{gaSNUMDATE+4,	3},
	{gaSNUMDATE+6,	4},
	{gaSNUMDATE+8,	5},
	{gaSNUMDATE+10,	6},
	{gaSNUMDATE+17,	7},
	{gaSNUMDATE+20,	8},
	{gaSNUMDATE+23,	9},
	{gaSNUMDATE+26,	10},
	{gaSNUMDATE+29,	11},
	{gaSNUMDATE+32,	12},
	{gaSNUMDATE+35,	13}, // +12: state 1 transitions
	{gaSNUMDATE+2,	14}, // +13: state 2 transitions
	{gaSNUMDATE+46,	15},
	{gaSNUMDATE+56,	15}, // +15: state 3 transitions
	{gaSNUMDATE+60,	16},
	{gaSNUMDATE+62,	17},
	{gaSNUMDATE+64,	18},
	{gaSNUMDATE+66,	19},
	{gaSNUMDATE+74,	20},
	{gaSNUMDATE+60,	16}, // +21: state 4 transitions
	{gaSNUMDATE+62,	17},
	{gaSNUMDATE+64,	18},
	{gaSNUMDATE+35,	19},
	{gaSNUMDATE+76,	14}, // +25: state 5 transitions
	{gaSNUMDATE+60,	16},
	{gaSNUMDATE+62,	17},
	{gaSNUMDATE+64,	18},
	{gaSNUMDATE+85,	19},
	{gaSNUMDATE+35,	14}, // +30: state 6 transitions
	{gaSNUMDATE+60,	16},
	{gaSNUMDATE+62,	17},
	{gaSNUMDATE+64,	18},
	{gaSNUMDATE+88,	21}, // +34: state 7 transitions
	{gaSNUMDATE+74,	22}, // +35: state 8 transitions
	{gaSNUMDATE+90,	23}, // +36: state 9 transitions
	{gaSNUMDATE+92,	24}, // +37: state 10 transitions
	{gaSNUMDATE+74,	25},
	{gaSNUMDATE+92,	26}, // +39: state 11 transitions
	{gaSNUMDATE+74,	27}, // +40: state 12 transitions
	{gaSNUMDATE+35,	28}, // +41: state 13 transitions
	{gaSNUMDATE+35,	29}, // +42: state 14 transitions
	{gaSNUMDATE+60,	16}, // +43: state 15 transitions
	{gaSNUMDATE+62,	17},
	{gaSNUMDATE+64,	18},
	{gaSNUMDATE+35,	29},
	{gaSNUMDATE+94,	30}, // +47: state 16 transitions
	{gaSNUMDATE+17,	31},
	{gaSNUMDATE+97,	32},
	{gaSNUMDATE+20,	33},
	{gaSNUMDATE+26,	34},
	{gaSNUMDATE+100,	35},
	{gaSNUMDATE+103,	36},
	{gaSNUMDATE+29,	37},
	{gaSNUMDATE+2,	38}, // +55: state 17 transitions
	{gaSNUMDATE+4,	39},
	{gaSNUMDATE+76,	40},
	{gaSNUMDATE+2,	41}, // +58: state 18 transitions
	{gaSNUMDATE+4,	42},
	{gaSNUMDATE+76,	43},
	{gaSNUMDATE+60,	16}, // +61: state 19 transitions
	{gaSNUMDATE+35,	29},
	{gaSNUMDATE+62,	44},
	{gaSNUMDATE+64,	45},
	{gaSNUMDATE+106,	46}, // +65: state 20 transitions
	{gaSNUMDATE+108,	47}, // +66: state 21 transitions
	{gaSNUMDATE+90,	48}, // +67: state 22 transitions
	{gaSNUMDATE+110,	48}, // +68: state 23 transitions
	{gaSNUMDATE+106,	48}, // +69: state 24 transitions
	{gaSNUMDATE+106,	49}, // +70: state 25 transitions
	{gaSNUMDATE+108,	50}, // +71: state 26 transitions
	{gaSNUMDATE+110,	51}, // +72: state 27 transitions
	{gaSNUMDATE+35,	52}, // +73: state 29 transitions
	{gaSNUMDATE+112,	53}, // +74: state 30 transitions
	{gaSNUMDATE+114,	54},
	{gaSNUMDATE+116,	55}, // +76: state 31 transitions
	{gaSNUMDATE+116,	56}, // +77: state 32 transitions
	{gaSNUMDATE+92,	57}, // +78: state 33 transitions
	{gaSNUMDATE+90,	58},
	{gaSNUMDATE+92,	59}, // +80: state 34 transitions
	{gaSNUMDATE+112,	60}, // +81: state 35 transitions
	{gaSNUMDATE+118,	61}, // +82: state 36 transitions
	{gaSNUMDATE+74,	62}, // +83: state 37 transitions
	{gaSNUMDATE+2,	63}, // +84: state 38 transitions
	{gaSNUMDATE+46,	64},
	{gaSNUMDATE+66,	63}, // +86: state 39 transitions
	{gaSNUMDATE+56,	64},
	{gaSNUMDATE+62,	65},
	{gaSNUMDATE+35,	63}, // +89: state 40 transitions
	{gaSNUMDATE+62,	65},
	{gaSNUMDATE+2,	63}, // +91: state 41 transitions
	{gaSNUMDATE+46,	66},
	{gaSNUMDATE+66,	63}, // +93: state 42 transitions
	{gaSNUMDATE+64,	65},
	{gaSNUMDATE+56,	66},
	{gaSNUMDATE+35,	63}, // +96: state 43 transitions
	{gaSNUMDATE+64,	65},
	{gaSNUMDATE+2,	67}, // +98: state 44 transitions
	{gaSNUMDATE+4,	68},
	{gaSNUMDATE+76,	69},
	{gaSNUMDATE+2,	70}, // +101: state 45 transitions
	{gaSNUMDATE+4,	71},
	{gaSNUMDATE+76,	72},
	{gaSNUMDATE+60,	16}, // +104: state 46 transitions
	{gaSNUMDATE+92,	73}, // +105: state 47 transitions
	{gaSNUMDATE+120,	74}, // +106: state 48 transitions
	{gaSNUMDATE+118,	75}, // +107: state 49 transitions
	{gaSNUMDATE+74,	48}, // +108: state 50 transitions
	{gaSNUMDATE+120,	75}, // +109: state 51 transitions
	{gaSNUMDATE+62,	76}, // +110: state 52 transitions
	{gaSNUMDATE+122,	77}, // +111: state 53 transitions
	{gaSNUMDATE+60,	65}, // +112: state 54 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+106,	79},
	{gaSNUMDATE+118,	80}, // +115: state 55 transitions
	{gaSNUMDATE+114,	81}, // +116: state 56 transitions
	{gaSNUMDATE+110,	82}, // +117: state 57 transitions
	{gaSNUMDATE+88,	83}, // +118: state 58 transitions
	{gaSNUMDATE+88,	78}, // +119: state 59 transitions
	{gaSNUMDATE+106,	84},
	{gaSNUMDATE+114,	80}, // +121: state 60 transitions
	{gaSNUMDATE+126,	85}, // +122: state 61 transitions
	{gaSNUMDATE+128,	86}, // +123: state 62 transitions
	{gaSNUMDATE+35,	13}, // +124: state 63 transitions
	{gaSNUMDATE+35,	13}, // +125: state 64 transitions
	{gaSNUMDATE+62,	65},
	{gaSNUMDATE+35,	87}, // +127: state 65 transitions
	{gaSNUMDATE+35,	13}, // +128: state 66 transitions
	{gaSNUMDATE+64,	65},
	{gaSNUMDATE+46,	69}, // +130: state 67 transitions
	{gaSNUMDATE+62,	65}, // +131: state 68 transitions
	{gaSNUMDATE+56,	69},
	{gaSNUMDATE+62,	65}, // +133: state 69 transitions
	{gaSNUMDATE+46,	72}, // +134: state 70 transitions
	{gaSNUMDATE+64,	65}, // +135: state 71 transitions
	{gaSNUMDATE+56,	72},
	{gaSNUMDATE+64,	65}, // +137: state 72 transitions
	{gaSNUMDATE+110,	88}, // +138: state 73 transitions
	{gaSNUMDATE+88,	89}, // +139: state 74 transitions
	{gaSNUMDATE+106,	50}, // +140: state 75 transitions
	{gaSNUMDATE+2,	90}, // +141: state 76 transitions
	{gaSNUMDATE+4,	91},
	{gaSNUMDATE+76,	92},
	{gaSNUMDATE+60,	65}, // +144: state 77 transitions
	{gaSNUMDATE+130,	78},
	{gaSNUMDATE+60,	65}, // +146: state 78 transitions
	{gaSNUMDATE+88,	93}, // +147: state 79 transitions
	{gaSNUMDATE+60,	65}, // +148: state 80 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+74,	94},
	{gaSNUMDATE+60,	65}, // +151: state 81 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+106,	95},
	{gaSNUMDATE+60,	65}, // +154: state 82 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+114,	95},
	{gaSNUMDATE+60,	65}, // +157: state 83 transitions
	{gaSNUMDATE+133,	78},
	{gaSNUMDATE+136,	96},
	{gaSNUMDATE+60,	65}, // +160: state 84 transitions
	{gaSNUMDATE+138,	78},
	{gaSNUMDATE+60,	65}, // +162: state 85 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+112,	97},
	{gaSNUMDATE+60,	65}, // +165: state 86 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+126,	98},
	{gaSNUMDATE+35,	63}, // +168: state 87 transitions
	{gaSNUMDATE+118,	99}, // +169: state 88 transitions
	{gaSNUMDATE+60,	100}, // +170: state 89 transitions
	{gaSNUMDATE+46,	92}, // +171: state 90 transitions
	{gaSNUMDATE+56,	92}, // +172: state 91 transitions
	{gaSNUMDATE+62,	101},
	{gaSNUMDATE+62,	101}, // +174: state 92 transitions
	{gaSNUMDATE+136,	78}, // +175: state 93 transitions
	{gaSNUMDATE+108,	97}, // +176: state 94 transitions
	{gaSNUMDATE+88,	102}, // +177: state 95 transitions
	{gaSNUMDATE+60,	65}, // +178: state 96 transitions
	{gaSNUMDATE+124,	78},
	{gaSNUMDATE+136,	103},
	{gaSNUMDATE+141,	104}, // +181: state 97 transitions
	{gaSNUMDATE+74,	94}, // +182: state 98 transitions
	{gaSNUMDATE+143,	105}, // +183: state 99 transitions
	{gaSNUMDATE+10,	46}, // +184: state 100 transitions
	{gaSNUMDATE+2,	106},
	{gaSNUMDATE+4,	107},
	{gaSNUMDATE+6,	108},
	{gaSNUMDATE+8,	109},
	{gaSNUMDATE+10,	28}, // +189: state 101 transitions
	{gaSNUMDATE+2,	110},
	{gaSNUMDATE+145,	111},
	{gaSNUMDATE+8,	112},
	{gaSNUMDATE+74,	113}, // +193: state 102 transitions
	{gaSNUMDATE+74,	114}, // +194: state 103 transitions
	{gaSNUMDATE+106,	115}, // +195: state 104 transitions
	{gaSNUMDATE+74,	89}, // +196: state 105 transitions
	{gaSNUMDATE+46,	46}, // +197: state 106 transitions
	{gaSNUMDATE+60,	16}, // +198: state 107 transitions
	{gaSNUMDATE+74,	20},
	{gaSNUMDATE+35,	46},
	{gaSNUMDATE+60,	16}, // +201: state 108 transitions
	{gaSNUMDATE+35,	46},
	{gaSNUMDATE+60,	16}, // +203: state 109 transitions
	{gaSNUMDATE+85,	46},
	{gaSNUMDATE+46,	28}, // +205: state 110 transitions
	{gaSNUMDATE+35,	28}, // +206: state 111 transitions
	{gaSNUMDATE+85,	28}, // +207: state 112 transitions
	{gaSNUMDATE+106,	78}, // +208: state 113 transitions
	{gaSNUMDATE+126,	78}, // +209: state 114 transitions
	{gaSNUMDATE+74,	78}, // +210: state 115 transitions
};

const STATE_DESCRIPTION aStateDescNUMDATE[116] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 12, gaTNUMDATE+0},
	/*   1 */ {0, 1, gaTNUMDATE+12},
	/*   2 */ {0, 2, gaTNUMDATE+13},
	/*   3 */ {0, 6, gaTNUMDATE+15},
	/*   4 */ {0, 4, gaTNUMDATE+21},
	/*   5 */ {0, 5, gaTNUMDATE+25},
	/*   6 */ {0, 4, gaTNUMDATE+30},
	/*   7 */ {0, 1, gaTNUMDATE+34},
	/*   8 */ {0, 1, gaTNUMDATE+35},
	/*   9 */ {0, 1, gaTNUMDATE+36},
	/*  10 */ {0, 2, gaTNUMDATE+37},
	/*  11 */ {0, 1, gaTNUMDATE+39},
	/*  12 */ {0, 1, gaTNUMDATE+40},
	/*  13 */ {0, 1, gaTNUMDATE+41},
	/*  14 */ {0, 1, gaTNUMDATE+42},
	/*  15 */ {0, 4, gaTNUMDATE+43},
	/*  16 */ {0, 8, gaTNUMDATE+47},
	/*  17 */ {0, 3, gaTNUMDATE+55},
	/*  18 */ {0, 3, gaTNUMDATE+58},
	/*  19 */ {0, 4, gaTNUMDATE+61},
	/*  20 */ {0, 1, gaTNUMDATE+65},
	/*  21 */ {0, 1, gaTNUMDATE+66},
	/*  22 */ {0, 1, gaTNUMDATE+67},
	/*  23 */ {0, 1, gaTNUMDATE+68},
	/*  24 */ {0, 1, gaTNUMDATE+69},
	/*  25 */ {0, 1, gaTNUMDATE+70},
	/*  26 */ {0, 1, gaTNUMDATE+71},
	/*  27 */ {0, 1, gaTNUMDATE+72},
	/*  28 */ {1, 0, NULL},
	/*  29 */ {0, 1, gaTNUMDATE+73},
	/*  30 */ {0, 2, gaTNUMDATE+74},
	/*  31 */ {0, 1, gaTNUMDATE+76},
	/*  32 */ {0, 1, gaTNUMDATE+77},
	/*  33 */ {0, 2, gaTNUMDATE+78},
	/*  34 */ {0, 1, gaTNUMDATE+80},
	/*  35 */ {0, 1, gaTNUMDATE+81},
	/*  36 */ {0, 1, gaTNUMDATE+82},
	/*  37 */ {0, 1, gaTNUMDATE+83},
	/*  38 */ {0, 2, gaTNUMDATE+84},
	/*  39 */ {1, 3, gaTNUMDATE+86},
	/*  40 */ {1, 2, gaTNUMDATE+89},
	/*  41 */ {0, 2, gaTNUMDATE+91},
	/*  42 */ {1, 3, gaTNUMDATE+93},
	/*  43 */ {1, 2, gaTNUMDATE+96},
	/*  44 */ {0, 3, gaTNUMDATE+98},
	/*  45 */ {0, 3, gaTNUMDATE+101},
	/*  46 */ {0, 1, gaTNUMDATE+104},
	/*  47 */ {0, 1, gaTNUMDATE+105},
	/*  48 */ {0, 1, gaTNUMDATE+106},
	/*  49 */ {0, 1, gaTNUMDATE+107},
	/*  50 */ {0, 1, gaTNUMDATE+108},
	/*  51 */ {0, 1, gaTNUMDATE+109},
	/*  52 */ {0, 1, gaTNUMDATE+110},
	/*  53 */ {0, 1, gaTNUMDATE+111},
	/*  54 */ {1, 3, gaTNUMDATE+112},
	/*  55 */ {0, 1, gaTNUMDATE+115},
	/*  56 */ {0, 1, gaTNUMDATE+116},
	/*  57 */ {0, 1, gaTNUMDATE+117},
	/*  58 */ {0, 1, gaTNUMDATE+118},
	/*  59 */ {0, 2, gaTNUMDATE+119},
	/*  60 */ {0, 1, gaTNUMDATE+121},
	/*  61 */ {0, 1, gaTNUMDATE+122},
	/*  62 */ {0, 1, gaTNUMDATE+123},
	/*  63 */ {1, 1, gaTNUMDATE+124},
	/*  64 */ {1, 2, gaTNUMDATE+125},
	/*  65 */ {0, 1, gaTNUMDATE+127},
	/*  66 */ {1, 2, gaTNUMDATE+128},
	/*  67 */ {0, 1, gaTNUMDATE+130},
	/*  68 */ {1, 2, gaTNUMDATE+131},
	/*  69 */ {1, 1, gaTNUMDATE+133},
	/*  70 */ {0, 1, gaTNUMDATE+134},
	/*  71 */ {1, 2, gaTNUMDATE+135},
	/*  72 */ {1, 1, gaTNUMDATE+137},
	/*  73 */ {0, 1, gaTNUMDATE+138},
	/*  74 */ {0, 1, gaTNUMDATE+139},
	/*  75 */ {0, 1, gaTNUMDATE+140},
	/*  76 */ {0, 3, gaTNUMDATE+141},
	/*  77 */ {1, 2, gaTNUMDATE+144},
	/*  78 */ {1, 1, gaTNUMDATE+146},
	/*  79 */ {0, 1, gaTNUMDATE+147},
	/*  80 */ {1, 3, gaTNUMDATE+148},
	/*  81 */ {1, 3, gaTNUMDATE+151},
	/*  82 */ {1, 3, gaTNUMDATE+154},
	/*  83 */ {1, 3, gaTNUMDATE+157},
	/*  84 */ {1, 2, gaTNUMDATE+160},
	/*  85 */ {1, 3, gaTNUMDATE+162},
	/*  86 */ {1, 3, gaTNUMDATE+165},
	/*  87 */ {0, 1, gaTNUMDATE+168},
	/*  88 */ {0, 1, gaTNUMDATE+169},
	/*  89 */ {0, 1, gaTNUMDATE+170},
	/*  90 */ {0, 1, gaTNUMDATE+171},
	/*  91 */ {0, 2, gaTNUMDATE+172},
	/*  92 */ {0, 1, gaTNUMDATE+174},
	/*  93 */ {0, 1, gaTNUMDATE+175},
	/*  94 */ {0, 1, gaTNUMDATE+176},
	/*  95 */ {0, 1, gaTNUMDATE+177},
	/*  96 */ {1, 3, gaTNUMDATE+178},
	/*  97 */ {0, 1, gaTNUMDATE+181},
	/*  98 */ {0, 1, gaTNUMDATE+182},
	/*  99 */ {0, 1, gaTNUMDATE+183},
	/* 100 */ {0, 5, gaTNUMDATE+184},
	/* 101 */ {0, 4, gaTNUMDATE+189},
	/* 102 */ {0, 1, gaTNUMDATE+193},
	/* 103 */ {0, 1, gaTNUMDATE+194},
	/* 104 */ {0, 1, gaTNUMDATE+195},
	/* 105 */ {0, 1, gaTNUMDATE+196},
	/* 106 */ {0, 1, gaTNUMDATE+197},
	/* 107 */ {0, 3, gaTNUMDATE+198},
	/* 108 */ {0, 2, gaTNUMDATE+201},
	/* 109 */ {0, 2, gaTNUMDATE+203},
	/* 110 */ {0, 1, gaTNUMDATE+205},
	/* 111 */ {1, 1, gaTNUMDATE+206},
	/* 112 */ {1, 1, gaTNUMDATE+207},
	/* 113 */ {0, 1, gaTNUMDATE+208},
	/* 114 */ {0, 1, gaTNUMDATE+209},
	/* 115 */ {0, 1, gaTNUMDATE+210},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numtime

// 11 states

static const unsigned char gaSNUMTIME[] = 
	/* gaStringNUMTIME+0 */	"01\000"
	/* gaStringNUMTIME+3 */	"2\000"
	/* gaStringNUMTIME+5 */	"3456789\000"
	/* gaStringNUMTIME+13 */	"0123456789\000"
	/* gaStringNUMTIME+24 */	" \000"
	/* gaStringNUMTIME+26 */	":\000"
	/* gaStringNUMTIME+28 */	"Hh\000"
	/* gaStringNUMTIME+31 */	"01234\000"
	/* gaStringNUMTIME+37 */	"012345\000"
	/* gaStringNUMTIME+44 */	"6789\000"
;

static const STATE_TRANSITION gaTNUMTIME[] = {
	{gaSNUMTIME+0,	1}, // +0: state 0 transitions
	{gaSNUMTIME+3,	2},
	{gaSNUMTIME+5,	3},
	{gaSNUMTIME+13,	3}, // +3: state 1 transitions
	{gaSNUMTIME+24,	4},
	{gaSNUMTIME+26,	5},
	{gaSNUMTIME+28,	6},
	{gaSNUMTIME+31,	3}, // +7: state 2 transitions
	{gaSNUMTIME+24,	4},
	{gaSNUMTIME+26,	5},
	{gaSNUMTIME+28,	6},
	{gaSNUMTIME+24,	4}, // +11: state 3 transitions
	{gaSNUMTIME+26,	5},
	{gaSNUMTIME+28,	6},
	{gaSNUMTIME+28,	7}, // +14: state 4 transitions
	{gaSNUMTIME+37,	8}, // +15: state 5 transitions
	{gaSNUMTIME+44,	9},
	{gaSNUMTIME+44,	7}, // +17: state 6 transitions
	{gaSNUMTIME+37,	10},
	{gaSNUMTIME+24,	4}, // +19: state 8 transitions
	{gaSNUMTIME+26,	6},
	{gaSNUMTIME+13,	9},
	{gaSNUMTIME+24,	4}, // +22: state 9 transitions
	{gaSNUMTIME+26,	6},
	{gaSNUMTIME+13,	7}, // +24: state 10 transitions
};

const STATE_DESCRIPTION aStateDescNUMTIME[11] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMTIME+0},
	/*   1 */ {0, 4, gaTNUMTIME+3},
	/*   2 */ {0, 4, gaTNUMTIME+7},
	/*   3 */ {0, 3, gaTNUMTIME+11},
	/*   4 */ {0, 1, gaTNUMTIME+14},
	/*   5 */ {0, 2, gaTNUMTIME+15},
	/*   6 */ {0, 2, gaTNUMTIME+17},
	/*   7 */ {1, 0, NULL},
	/*   8 */ {1, 3, gaTNUMTIME+19},
	/*   9 */ {1, 2, gaTNUMTIME+22},
	/*  10 */ {1, 1, gaTNUMTIME+24},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numcurrency

// 16 states

static const unsigned char gaSNUMCURRENCY[] = 
	/* gaStringNUMCURRENCY+0 */	"0123456789\000"
	/* gaStringNUMCURRENCY+11 */	" \000"
	/* gaStringNUMCURRENCY+13 */	",\000"
	/* gaStringNUMCURRENCY+15 */	"$\000"
	/* gaStringNUMCURRENCY+20 */	"E\000"
	/* gaStringNUMCURRENCY+22 */	"F\000"
	/* gaStringNUMCURRENCY+24 */	"U\000"
	/* gaStringNUMCURRENCY+26 */	"f\000"
	/* gaStringNUMCURRENCY+28 */	".F\000"
	/* gaStringNUMCURRENCY+31 */	"R\000"
	/* gaStringNUMCURRENCY+33 */	"r\000"
	/* gaStringNUMCURRENCY+35 */	"S\000"
	/* gaStringNUMCURRENCY+37 */	".\000"
	/* gaStringNUMCURRENCY+39 */	"s\000"
	/* gaStringNUMCURRENCY+41 */	"$D\000"
	/* gaStringNUMCURRENCY+44 */	"O\000"
;

static const STATE_TRANSITION gaTNUMCURRENCY[] = {
	{gaSNUMCURRENCY+0,	1}, // +0: state 0 transitions
	{gaSNUMCURRENCY+0,	1}, // +1: state 1 transitions
	{gaSNUMCURRENCY+11,	2},
	{gaSNUMCURRENCY+13,	3},
	{gaSNUMCURRENCY+15,	4}, // +4: state 2 transitions
	{gaSNUMCURRENCY+20,	5},
	{gaSNUMCURRENCY+22,	6},
	{gaSNUMCURRENCY+24,	7},
	{gaSNUMCURRENCY+26,	8},
	{gaSNUMCURRENCY+0,	9}, // +9: state 3 transitions
	{gaSNUMCURRENCY+24,	10}, // +10: state 5 transitions
	{gaSNUMCURRENCY+28,	4}, // +11: state 6 transitions
	{gaSNUMCURRENCY+31,	11},
	{gaSNUMCURRENCY+33,	12},
	{gaSNUMCURRENCY+35,	13}, // +14: state 7 transitions
	{gaSNUMCURRENCY+37,	4}, // +15: state 8 transitions
	{gaSNUMCURRENCY+33,	12},
	{gaSNUMCURRENCY+0,	14}, // +17: state 9 transitions
	{gaSNUMCURRENCY+31,	15}, // +18: state 10 transitions
	{gaSNUMCURRENCY+22,	4}, // +19: state 11 transitions
	{gaSNUMCURRENCY+39,	4}, // +20: state 12 transitions
	{gaSNUMCURRENCY+41,	4}, // +21: state 13 transitions
	{gaSNUMCURRENCY+11,	2}, // +22: state 14 transitions
	{gaSNUMCURRENCY+44,	4}, // +23: state 15 transitions
};

const STATE_DESCRIPTION aStateDescNUMCURRENCY[16] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMCURRENCY+0},
	/*   1 */ {0, 3, gaTNUMCURRENCY+1},
	/*   2 */ {0, 5, gaTNUMCURRENCY+4},
	/*   3 */ {0, 1, gaTNUMCURRENCY+9},
	/*   4 */ {1, 0, NULL},
	/*   5 */ {0, 1, gaTNUMCURRENCY+10},
	/*   6 */ {1, 3, gaTNUMCURRENCY+11},
	/*   7 */ {0, 1, gaTNUMCURRENCY+14},
	/*   8 */ {1, 2, gaTNUMCURRENCY+15},
	/*   9 */ {0, 1, gaTNUMCURRENCY+17},
	/*  10 */ {0, 1, gaTNUMCURRENCY+18},
	/*  11 */ {1, 1, gaTNUMCURRENCY+19},
	/*  12 */ {1, 1, gaTNUMCURRENCY+20},
	/*  13 */ {0, 1, gaTNUMCURRENCY+21},
	/*  14 */ {0, 1, gaTNUMCURRENCY+22},
	/*  15 */ {1, 1, gaTNUMCURRENCY+23},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = numphone

// 65 states

static const unsigned char gaSNUMPHONE[] = 
	/* gaStringNUMPHONE+0 */	"(\000"
	/* gaStringNUMPHONE+2 */	"+\000"
	/* gaStringNUMPHONE+4 */	"0\000"
	/* gaStringNUMPHONE+6 */	"123456789\000"
	/* gaStringNUMPHONE+16 */	"0123456789\000"
	/* gaStringNUMPHONE+27 */	" \000"
	/* gaStringNUMPHONE+29 */	".\000"
	/* gaStringNUMPHONE+31 */	")\000"
	/* gaStringNUMPHONE+33 */	" .\000"
;

static const STATE_TRANSITION gaTNUMPHONE[] = {
	{gaSNUMPHONE+0,	1}, // +0: state 0 transitions
	{gaSNUMPHONE+2,	2},
	{gaSNUMPHONE+4,	3},
	{gaSNUMPHONE+6,	4},
	{gaSNUMPHONE+16,	5}, // +4: state 1 transitions
	{gaSNUMPHONE+16,	6}, // +5: state 2 transitions
	{gaSNUMPHONE+4,	7}, // +6: state 3 transitions
	{gaSNUMPHONE+6,	8},
	{gaSNUMPHONE+16,	9}, // +8: state 4 transitions
	{gaSNUMPHONE+16,	10}, // +9: state 5 transitions
	{gaSNUMPHONE+16,	11}, // +10: state 6 transitions
	{gaSNUMPHONE+27,	12}, // +11: state 7 transitions
	{gaSNUMPHONE+29,	13},
	{gaSNUMPHONE+16,	14},
	{gaSNUMPHONE+27,	12}, // +14: state 8 transitions
	{gaSNUMPHONE+29,	13},
	{gaSNUMPHONE+16,	15},
	{gaSNUMPHONE+27,	12}, // +17: state 9 transitions
	{gaSNUMPHONE+29,	13},
	{gaSNUMPHONE+31,	16}, // +19: state 10 transitions
	{gaSNUMPHONE+27,	17}, // +20: state 11 transitions
	{gaSNUMPHONE+0,	18}, // +21: state 12 transitions
	{gaSNUMPHONE+16,	19},
	{gaSNUMPHONE+16,	20}, // +23: state 13 transitions
	{gaSNUMPHONE+16,	21}, // +24: state 14 transitions
	{gaSNUMPHONE+16,	22}, // +25: state 15 transitions
	{gaSNUMPHONE+33,	23}, // +26: state 16 transitions
	{gaSNUMPHONE+0,	18}, // +27: state 17 transitions
	{gaSNUMPHONE+16,	24},
	{gaSNUMPHONE+4,	25}, // +29: state 18 transitions
	{gaSNUMPHONE+16,	26}, // +30: state 19 transitions
	{gaSNUMPHONE+16,	27}, // +31: state 20 transitions
	{gaSNUMPHONE+27,	28}, // +32: state 21 transitions
	{gaSNUMPHONE+29,	29},
	{gaSNUMPHONE+29,	29}, // +34: state 22 transitions
	{gaSNUMPHONE+27,	30},
	{gaSNUMPHONE+16,	24}, // +36: state 23 transitions
	{gaSNUMPHONE+16,	31}, // +37: state 24 transitions
	{gaSNUMPHONE+31,	24}, // +38: state 25 transitions
	{gaSNUMPHONE+29,	13}, // +39: state 26 transitions
	{gaSNUMPHONE+27,	32},
	{gaSNUMPHONE+29,	29}, // +41: state 27 transitions
	{gaSNUMPHONE+0,	18}, // +42: state 28 transitions
	{gaSNUMPHONE+16,	33},
	{gaSNUMPHONE+16,	34}, // +44: state 29 transitions
	{gaSNUMPHONE+16,	35}, // +45: state 30 transitions
	{gaSNUMPHONE+29,	13}, // +46: state 31 transitions
	{gaSNUMPHONE+27,	36},
	{gaSNUMPHONE+16,	37}, // +48: state 32 transitions
	{gaSNUMPHONE+16,	38}, // +49: state 33 transitions
	{gaSNUMPHONE+16,	39}, // +50: state 34 transitions
	{gaSNUMPHONE+16,	40}, // +51: state 35 transitions
	{gaSNUMPHONE+16,	41}, // +52: state 36 transitions
	{gaSNUMPHONE+16,	42}, // +53: state 37 transitions
	{gaSNUMPHONE+29,	13}, // +54: state 38 transitions
	{gaSNUMPHONE+27,	43},
	{gaSNUMPHONE+29,	44}, // +56: state 39 transitions
	{gaSNUMPHONE+27,	45}, // +57: state 40 transitions
	{gaSNUMPHONE+16,	46}, // +58: state 41 transitions
	{gaSNUMPHONE+27,	47}, // +59: state 42 transitions
	{gaSNUMPHONE+16,	48}, // +60: state 43 transitions
	{gaSNUMPHONE+16,	49}, // +61: state 44 transitions
	{gaSNUMPHONE+16,	50}, // +62: state 45 transitions
	{gaSNUMPHONE+27,	30}, // +63: state 46 transitions
	{gaSNUMPHONE+16,	51}, // +64: state 47 transitions
	{gaSNUMPHONE+16,	52}, // +65: state 48 transitions
	{gaSNUMPHONE+16,	53}, // +66: state 49 transitions
	{gaSNUMPHONE+16,	54}, // +67: state 50 transitions
	{gaSNUMPHONE+16,	55}, // +68: state 51 transitions
	{gaSNUMPHONE+27,	56}, // +69: state 52 transitions
	{gaSNUMPHONE+29,	57}, // +70: state 53 transitions
	{gaSNUMPHONE+27,	57}, // +71: state 54 transitions
	{gaSNUMPHONE+27,	58}, // +72: state 55 transitions
	{gaSNUMPHONE+16,	59}, // +73: state 56 transitions
	{gaSNUMPHONE+16,	60}, // +74: state 57 transitions
	{gaSNUMPHONE+16,	61}, // +75: state 58 transitions
	{gaSNUMPHONE+16,	62}, // +76: state 59 transitions
	{gaSNUMPHONE+16,	63}, // +77: state 60 transitions
	{gaSNUMPHONE+16,	64}, // +78: state 61 transitions
	{gaSNUMPHONE+27,	45}, // +79: state 62 transitions
	{gaSNUMPHONE+27,	57}, // +80: state 64 transitions
};

const STATE_DESCRIPTION aStateDescNUMPHONE[65] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTNUMPHONE+0},
	/*   1 */ {0, 1, gaTNUMPHONE+4},
	/*   2 */ {0, 1, gaTNUMPHONE+5},
	/*   3 */ {0, 2, gaTNUMPHONE+6},
	/*   4 */ {0, 1, gaTNUMPHONE+8},
	/*   5 */ {0, 1, gaTNUMPHONE+9},
	/*   6 */ {0, 1, gaTNUMPHONE+10},
	/*   7 */ {0, 3, gaTNUMPHONE+11},
	/*   8 */ {0, 3, gaTNUMPHONE+14},
	/*   9 */ {0, 2, gaTNUMPHONE+17},
	/*  10 */ {0, 1, gaTNUMPHONE+19},
	/*  11 */ {0, 1, gaTNUMPHONE+20},
	/*  12 */ {0, 2, gaTNUMPHONE+21},
	/*  13 */ {0, 1, gaTNUMPHONE+23},
	/*  14 */ {0, 1, gaTNUMPHONE+24},
	/*  15 */ {0, 1, gaTNUMPHONE+25},
	/*  16 */ {0, 1, gaTNUMPHONE+26},
	/*  17 */ {0, 2, gaTNUMPHONE+27},
	/*  18 */ {0, 1, gaTNUMPHONE+29},
	/*  19 */ {0, 1, gaTNUMPHONE+30},
	/*  20 */ {0, 1, gaTNUMPHONE+31},
	/*  21 */ {0, 2, gaTNUMPHONE+32},
	/*  22 */ {0, 2, gaTNUMPHONE+34},
	/*  23 */ {0, 1, gaTNUMPHONE+36},
	/*  24 */ {0, 1, gaTNUMPHONE+37},
	/*  25 */ {0, 1, gaTNUMPHONE+38},
	/*  26 */ {0, 2, gaTNUMPHONE+39},
	/*  27 */ {0, 1, gaTNUMPHONE+41},
	/*  28 */ {0, 2, gaTNUMPHONE+42},
	/*  29 */ {0, 1, gaTNUMPHONE+44},
	/*  30 */ {0, 1, gaTNUMPHONE+45},
	/*  31 */ {0, 2, gaTNUMPHONE+46},
	/*  32 */ {0, 1, gaTNUMPHONE+48},
	/*  33 */ {0, 1, gaTNUMPHONE+49},
	/*  34 */ {0, 1, gaTNUMPHONE+50},
	/*  35 */ {0, 1, gaTNUMPHONE+51},
	/*  36 */ {0, 1, gaTNUMPHONE+52},
	/*  37 */ {0, 1, gaTNUMPHONE+53},
	/*  38 */ {0, 2, gaTNUMPHONE+54},
	/*  39 */ {0, 1, gaTNUMPHONE+56},
	/*  40 */ {0, 1, gaTNUMPHONE+57},
	/*  41 */ {0, 1, gaTNUMPHONE+58},
	/*  42 */ {0, 1, gaTNUMPHONE+59},
	/*  43 */ {0, 1, gaTNUMPHONE+60},
	/*  44 */ {0, 1, gaTNUMPHONE+61},
	/*  45 */ {0, 1, gaTNUMPHONE+62},
	/*  46 */ {0, 1, gaTNUMPHONE+63},
	/*  47 */ {0, 1, gaTNUMPHONE+64},
	/*  48 */ {0, 1, gaTNUMPHONE+65},
	/*  49 */ {0, 1, gaTNUMPHONE+66},
	/*  50 */ {0, 1, gaTNUMPHONE+67},
	/*  51 */ {0, 1, gaTNUMPHONE+68},
	/*  52 */ {0, 1, gaTNUMPHONE+69},
	/*  53 */ {0, 1, gaTNUMPHONE+70},
	/*  54 */ {0, 1, gaTNUMPHONE+71},
	/*  55 */ {1, 1, gaTNUMPHONE+72},
	/*  56 */ {0, 1, gaTNUMPHONE+73},
	/*  57 */ {0, 1, gaTNUMPHONE+74},
	/*  58 */ {0, 1, gaTNUMPHONE+75},
	/*  59 */ {0, 1, gaTNUMPHONE+76},
	/*  60 */ {0, 1, gaTNUMPHONE+77},
	/*  61 */ {0, 1, gaTNUMPHONE+78},
	/*  62 */ {1, 1, gaTNUMPHONE+79},
	/*  63 */ {1, 0, NULL},
	/*  64 */ {1, 1, gaTNUMPHONE+80},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = nummath

// 144 states

static const unsigned char gaSNUMMATH[] = 
	/* gaStringNUMMATH+0 */	"(\000"
	/* gaStringNUMMATH+2 */	"+-\000"
	/* gaStringNUMMATH+5 */	"0123456789\000"
	/* gaStringNUMMATH+16 */	"[\000"
	/* gaStringNUMMATH+18 */	"{\000"
	/* gaStringNUMMATH+20 */	"*+-/x\000"
	/* gaStringNUMMATH+26 */	",\000"
	/* gaStringNUMMATH+28 */	"<=>\000"
	/* gaStringNUMMATH+32 */	")\000"
	/* gaStringNUMMATH+34 */	"]\000"
	/* gaStringNUMMATH+36 */	"}\000"
;

static const STATE_TRANSITION gaTNUMMATH[] = {
	{gaSNUMMATH+0,	1}, // +0: state 0 transitions
	{gaSNUMMATH+2,	2},
	{gaSNUMMATH+5,	3},
	{gaSNUMMATH+16,	4},
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+2,	6}, // +5: state 1 transitions
	{gaSNUMMATH+5,	7},
	{gaSNUMMATH+5,	3}, // +7: state 2 transitions
	{gaSNUMMATH+5,	3}, // +8: state 3 transitions
	{gaSNUMMATH+20,	8},
	{gaSNUMMATH+26,	9},
	{gaSNUMMATH+28,	10},
	{gaSNUMMATH+2,	11}, // +12: state 4 transitions
	{gaSNUMMATH+5,	12},
	{gaSNUMMATH+2,	13}, // +14: state 5 transitions
	{gaSNUMMATH+5,	14},
	{gaSNUMMATH+5,	7}, // +16: state 6 transitions
	{gaSNUMMATH+5,	7}, // +17: state 7 transitions
	{gaSNUMMATH+32,	15},
	{gaSNUMMATH+20,	16},
	{gaSNUMMATH+26,	17},
	{gaSNUMMATH+0,	18}, // +21: state 8 transitions
	{gaSNUMMATH+2,	19},
	{gaSNUMMATH+5,	20},
	{gaSNUMMATH+16,	21},
	{gaSNUMMATH+18,	22},
	{gaSNUMMATH+5,	23}, // +26: state 9 transitions
	{gaSNUMMATH+0,	24}, // +27: state 10 transitions
	{gaSNUMMATH+2,	25},
	{gaSNUMMATH+5,	26},
	{gaSNUMMATH+16,	27},
	{gaSNUMMATH+18,	28},
	{gaSNUMMATH+5,	12}, // +32: state 11 transitions
	{gaSNUMMATH+5,	12}, // +33: state 12 transitions
	{gaSNUMMATH+20,	29},
	{gaSNUMMATH+26,	30},
	{gaSNUMMATH+5,	14}, // +36: state 13 transitions
	{gaSNUMMATH+5,	14}, // +37: state 14 transitions
	{gaSNUMMATH+20,	31},
	{gaSNUMMATH+26,	32},
	{gaSNUMMATH+20,	8}, // +40: state 15 transitions
	{gaSNUMMATH+28,	10},
	{gaSNUMMATH+2,	33}, // +42: state 16 transitions
	{gaSNUMMATH+5,	34},
	{gaSNUMMATH+5,	35}, // +44: state 17 transitions
	{gaSNUMMATH+2,	36}, // +45: state 18 transitions
	{gaSNUMMATH+5,	37},
	{gaSNUMMATH+5,	20}, // +47: state 19 transitions
	{gaSNUMMATH+28,	10}, // +48: state 20 transitions
	{gaSNUMMATH+5,	20},
	{gaSNUMMATH+26,	38},
	{gaSNUMMATH+2,	39}, // +51: state 21 transitions
	{gaSNUMMATH+5,	40},
	{gaSNUMMATH+2,	41}, // +53: state 22 transitions
	{gaSNUMMATH+5,	42},
	{gaSNUMMATH+20,	8}, // +55: state 23 transitions
	{gaSNUMMATH+28,	10},
	{gaSNUMMATH+5,	23},
	{gaSNUMMATH+2,	43}, // +58: state 24 transitions
	{gaSNUMMATH+5,	44},
	{gaSNUMMATH+5,	26}, // +60: state 25 transitions
	{gaSNUMMATH+5,	26}, // +61: state 26 transitions
	{gaSNUMMATH+20,	45},
	{gaSNUMMATH+26,	46},
	{gaSNUMMATH+2,	47}, // +64: state 27 transitions
	{gaSNUMMATH+5,	48},
	{gaSNUMMATH+2,	49}, // +66: state 28 transitions
	{gaSNUMMATH+5,	50},
	{gaSNUMMATH+2,	51}, // +68: state 29 transitions
	{gaSNUMMATH+5,	52},
	{gaSNUMMATH+5,	53}, // +70: state 30 transitions
	{gaSNUMMATH+2,	54}, // +71: state 31 transitions
	{gaSNUMMATH+5,	55},
	{gaSNUMMATH+5,	56}, // +73: state 32 transitions
	{gaSNUMMATH+5,	34}, // +74: state 33 transitions
	{gaSNUMMATH+32,	15}, // +75: state 34 transitions
	{gaSNUMMATH+5,	34},
	{gaSNUMMATH+26,	57},
	{gaSNUMMATH+32,	15}, // +78: state 35 transitions
	{gaSNUMMATH+20,	16},
	{gaSNUMMATH+5,	35},
	{gaSNUMMATH+5,	37}, // +81: state 36 transitions
	{gaSNUMMATH+5,	37}, // +82: state 37 transitions
	{gaSNUMMATH+32,	58},
	{gaSNUMMATH+20,	59},
	{gaSNUMMATH+26,	60},
	{gaSNUMMATH+5,	61}, // +86: state 38 transitions
	{gaSNUMMATH+5,	40}, // +87: state 39 transitions
	{gaSNUMMATH+5,	40}, // +88: state 40 transitions
	{gaSNUMMATH+20,	62},
	{gaSNUMMATH+26,	63},
	{gaSNUMMATH+5,	42}, // +91: state 41 transitions
	{gaSNUMMATH+5,	42}, // +92: state 42 transitions
	{gaSNUMMATH+20,	64},
	{gaSNUMMATH+26,	65},
	{gaSNUMMATH+5,	44}, // +95: state 43 transitions
	{gaSNUMMATH+5,	44}, // +96: state 44 transitions
	{gaSNUMMATH+32,	66},
	{gaSNUMMATH+20,	67},
	{gaSNUMMATH+26,	68},
	{gaSNUMMATH+0,	69}, // +100: state 45 transitions
	{gaSNUMMATH+2,	70},
	{gaSNUMMATH+5,	71},
	{gaSNUMMATH+16,	72},
	{gaSNUMMATH+18,	73},
	{gaSNUMMATH+5,	74}, // +105: state 46 transitions
	{gaSNUMMATH+5,	48}, // +106: state 47 transitions
	{gaSNUMMATH+5,	48}, // +107: state 48 transitions
	{gaSNUMMATH+20,	75},
	{gaSNUMMATH+26,	76},
	{gaSNUMMATH+5,	50}, // +110: state 49 transitions
	{gaSNUMMATH+5,	50}, // +111: state 50 transitions
	{gaSNUMMATH+20,	77},
	{gaSNUMMATH+26,	78},
	{gaSNUMMATH+5,	52}, // +114: state 51 transitions
	{gaSNUMMATH+34,	15}, // +115: state 52 transitions
	{gaSNUMMATH+5,	52},
	{gaSNUMMATH+26,	79},
	{gaSNUMMATH+20,	29}, // +118: state 53 transitions
	{gaSNUMMATH+5,	53},
	{gaSNUMMATH+5,	55}, // +120: state 54 transitions
	{gaSNUMMATH+36,	15}, // +121: state 55 transitions
	{gaSNUMMATH+5,	55},
	{gaSNUMMATH+26,	80},
	{gaSNUMMATH+20,	31}, // +124: state 56 transitions
	{gaSNUMMATH+5,	56},
	{gaSNUMMATH+5,	81}, // +126: state 57 transitions
	{gaSNUMMATH+28,	10}, // +127: state 58 transitions
	{gaSNUMMATH+2,	82}, // +128: state 59 transitions
	{gaSNUMMATH+5,	83},
	{gaSNUMMATH+5,	84}, // +130: state 60 transitions
	{gaSNUMMATH+28,	10}, // +131: state 61 transitions
	{gaSNUMMATH+5,	61},
	{gaSNUMMATH+2,	85}, // +133: state 62 transitions
	{gaSNUMMATH+5,	86},
	{gaSNUMMATH+5,	87}, // +135: state 63 transitions
	{gaSNUMMATH+2,	88}, // +136: state 64 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+5,	90}, // +138: state 65 transitions
	{gaSNUMMATH+20,	45}, // +139: state 66 transitions
	{gaSNUMMATH+2,	91}, // +140: state 67 transitions
	{gaSNUMMATH+5,	92},
	{gaSNUMMATH+5,	93}, // +142: state 68 transitions
	{gaSNUMMATH+2,	94}, // +143: state 69 transitions
	{gaSNUMMATH+5,	95},
	{gaSNUMMATH+5,	71}, // +145: state 70 transitions
	{gaSNUMMATH+5,	71}, // +146: state 71 transitions
	{gaSNUMMATH+26,	96},
	{gaSNUMMATH+2,	97}, // +148: state 72 transitions
	{gaSNUMMATH+5,	98},
	{gaSNUMMATH+2,	99}, // +150: state 73 transitions
	{gaSNUMMATH+5,	100},
	{gaSNUMMATH+20,	45}, // +152: state 74 transitions
	{gaSNUMMATH+5,	74},
	{gaSNUMMATH+2,	101}, // +154: state 75 transitions
	{gaSNUMMATH+5,	102},
	{gaSNUMMATH+5,	103}, // +156: state 76 transitions
	{gaSNUMMATH+2,	104}, // +157: state 77 transitions
	{gaSNUMMATH+5,	105},
	{gaSNUMMATH+5,	106}, // +159: state 78 transitions
	{gaSNUMMATH+5,	107}, // +160: state 79 transitions
	{gaSNUMMATH+5,	108}, // +161: state 80 transitions
	{gaSNUMMATH+32,	15}, // +162: state 81 transitions
	{gaSNUMMATH+5,	81},
	{gaSNUMMATH+5,	83}, // +164: state 82 transitions
	{gaSNUMMATH+32,	58}, // +165: state 83 transitions
	{gaSNUMMATH+5,	83},
	{gaSNUMMATH+26,	109},
	{gaSNUMMATH+32,	58}, // +168: state 84 transitions
	{gaSNUMMATH+20,	59},
	{gaSNUMMATH+5,	84},
	{gaSNUMMATH+5,	86}, // +171: state 85 transitions
	{gaSNUMMATH+34,	58}, // +172: state 86 transitions
	{gaSNUMMATH+5,	86},
	{gaSNUMMATH+26,	110},
	{gaSNUMMATH+20,	62}, // +175: state 87 transitions
	{gaSNUMMATH+5,	87},
	{gaSNUMMATH+5,	89}, // +177: state 88 transitions
	{gaSNUMMATH+36,	58}, // +178: state 89 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+26,	111},
	{gaSNUMMATH+20,	64}, // +181: state 90 transitions
	{gaSNUMMATH+5,	90},
	{gaSNUMMATH+5,	92}, // +183: state 91 transitions
	{gaSNUMMATH+32,	66}, // +184: state 92 transitions
	{gaSNUMMATH+5,	92},
	{gaSNUMMATH+26,	112},
	{gaSNUMMATH+32,	66}, // +187: state 93 transitions
	{gaSNUMMATH+20,	67},
	{gaSNUMMATH+5,	93},
	{gaSNUMMATH+5,	95}, // +190: state 94 transitions
	{gaSNUMMATH+5,	95}, // +191: state 95 transitions
	{gaSNUMMATH+32,	113},
	{gaSNUMMATH+20,	114},
	{gaSNUMMATH+26,	115},
	{gaSNUMMATH+5,	116}, // +195: state 96 transitions
	{gaSNUMMATH+5,	98}, // +196: state 97 transitions
	{gaSNUMMATH+5,	98}, // +197: state 98 transitions
	{gaSNUMMATH+20,	117},
	{gaSNUMMATH+26,	118},
	{gaSNUMMATH+5,	100}, // +200: state 99 transitions
	{gaSNUMMATH+5,	100}, // +201: state 100 transitions
	{gaSNUMMATH+20,	119},
	{gaSNUMMATH+26,	120},
	{gaSNUMMATH+5,	102}, // +204: state 101 transitions
	{gaSNUMMATH+34,	66}, // +205: state 102 transitions
	{gaSNUMMATH+5,	102},
	{gaSNUMMATH+26,	121},
	{gaSNUMMATH+20,	75}, // +208: state 103 transitions
	{gaSNUMMATH+5,	103},
	{gaSNUMMATH+5,	105}, // +210: state 104 transitions
	{gaSNUMMATH+36,	66}, // +211: state 105 transitions
	{gaSNUMMATH+5,	105},
	{gaSNUMMATH+26,	122},
	{gaSNUMMATH+20,	77}, // +214: state 106 transitions
	{gaSNUMMATH+5,	106},
	{gaSNUMMATH+34,	15}, // +216: state 107 transitions
	{gaSNUMMATH+5,	107},
	{gaSNUMMATH+36,	15}, // +218: state 108 transitions
	{gaSNUMMATH+5,	108},
	{gaSNUMMATH+5,	123}, // +220: state 109 transitions
	{gaSNUMMATH+5,	124}, // +221: state 110 transitions
	{gaSNUMMATH+5,	125}, // +222: state 111 transitions
	{gaSNUMMATH+5,	126}, // +223: state 112 transitions
	{gaSNUMMATH+2,	127}, // +224: state 114 transitions
	{gaSNUMMATH+5,	128},
	{gaSNUMMATH+5,	129}, // +226: state 115 transitions
	{gaSNUMMATH+5,	116}, // +227: state 116 transitions
	{gaSNUMMATH+2,	130}, // +228: state 117 transitions
	{gaSNUMMATH+5,	131},
	{gaSNUMMATH+5,	132}, // +230: state 118 transitions
	{gaSNUMMATH+2,	133}, // +231: state 119 transitions
	{gaSNUMMATH+5,	134},
	{gaSNUMMATH+5,	135}, // +233: state 120 transitions
	{gaSNUMMATH+5,	136}, // +234: state 121 transitions
	{gaSNUMMATH+5,	137}, // +235: state 122 transitions
	{gaSNUMMATH+32,	58}, // +236: state 123 transitions
	{gaSNUMMATH+5,	123},
	{gaSNUMMATH+34,	58}, // +238: state 124 transitions
	{gaSNUMMATH+5,	124},
	{gaSNUMMATH+36,	58}, // +240: state 125 transitions
	{gaSNUMMATH+5,	125},
	{gaSNUMMATH+32,	66}, // +242: state 126 transitions
	{gaSNUMMATH+5,	126},
	{gaSNUMMATH+5,	128}, // +244: state 127 transitions
	{gaSNUMMATH+32,	113}, // +245: state 128 transitions
	{gaSNUMMATH+5,	128},
	{gaSNUMMATH+26,	138},
	{gaSNUMMATH+32,	113}, // +248: state 129 transitions
	{gaSNUMMATH+20,	114},
	{gaSNUMMATH+5,	129},
	{gaSNUMMATH+5,	131}, // +251: state 130 transitions
	{gaSNUMMATH+34,	113}, // +252: state 131 transitions
	{gaSNUMMATH+5,	131},
	{gaSNUMMATH+26,	139},
	{gaSNUMMATH+20,	117}, // +255: state 132 transitions
	{gaSNUMMATH+5,	132},
	{gaSNUMMATH+5,	134}, // +257: state 133 transitions
	{gaSNUMMATH+36,	113}, // +258: state 134 transitions
	{gaSNUMMATH+5,	134},
	{gaSNUMMATH+26,	140},
	{gaSNUMMATH+20,	119}, // +261: state 135 transitions
	{gaSNUMMATH+5,	135},
	{gaSNUMMATH+34,	66}, // +263: state 136 transitions
	{gaSNUMMATH+5,	136},
	{gaSNUMMATH+36,	66}, // +265: state 137 transitions
	{gaSNUMMATH+5,	137},
	{gaSNUMMATH+5,	141}, // +267: state 138 transitions
	{gaSNUMMATH+5,	142}, // +268: state 139 transitions
	{gaSNUMMATH+5,	143}, // +269: state 140 transitions
	{gaSNUMMATH+32,	113}, // +270: state 141 transitions
	{gaSNUMMATH+5,	141},
	{gaSNUMMATH+34,	113}, // +272: state 142 transitions
	{gaSNUMMATH+5,	142},
	{gaSNUMMATH+36,	113}, // +274: state 143 transitions
	{gaSNUMMATH+5,	143},
};

const STATE_DESCRIPTION aStateDescNUMMATH[144] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTNUMMATH+0},
	/*   1 */ {0, 2, gaTNUMMATH+5},
	/*   2 */ {0, 1, gaTNUMMATH+7},
	/*   3 */ {1, 4, gaTNUMMATH+8},
	/*   4 */ {0, 2, gaTNUMMATH+12},
	/*   5 */ {0, 2, gaTNUMMATH+14},
	/*   6 */ {0, 1, gaTNUMMATH+16},
	/*   7 */ {0, 4, gaTNUMMATH+17},
	/*   8 */ {0, 5, gaTNUMMATH+21},
	/*   9 */ {0, 1, gaTNUMMATH+26},
	/*  10 */ {0, 5, gaTNUMMATH+27},
	/*  11 */ {0, 1, gaTNUMMATH+32},
	/*  12 */ {0, 3, gaTNUMMATH+33},
	/*  13 */ {0, 1, gaTNUMMATH+36},
	/*  14 */ {0, 3, gaTNUMMATH+37},
	/*  15 */ {1, 2, gaTNUMMATH+40},
	/*  16 */ {0, 2, gaTNUMMATH+42},
	/*  17 */ {0, 1, gaTNUMMATH+44},
	/*  18 */ {0, 2, gaTNUMMATH+45},
	/*  19 */ {0, 1, gaTNUMMATH+47},
	/*  20 */ {1, 3, gaTNUMMATH+48},
	/*  21 */ {0, 2, gaTNUMMATH+51},
	/*  22 */ {0, 2, gaTNUMMATH+53},
	/*  23 */ {1, 3, gaTNUMMATH+55},
	/*  24 */ {0, 2, gaTNUMMATH+58},
	/*  25 */ {0, 1, gaTNUMMATH+60},
	/*  26 */ {1, 3, gaTNUMMATH+61},
	/*  27 */ {0, 2, gaTNUMMATH+64},
	/*  28 */ {0, 2, gaTNUMMATH+66},
	/*  29 */ {0, 2, gaTNUMMATH+68},
	/*  30 */ {0, 1, gaTNUMMATH+70},
	/*  31 */ {0, 2, gaTNUMMATH+71},
	/*  32 */ {0, 1, gaTNUMMATH+73},
	/*  33 */ {0, 1, gaTNUMMATH+74},
	/*  34 */ {0, 3, gaTNUMMATH+75},
	/*  35 */ {0, 3, gaTNUMMATH+78},
	/*  36 */ {0, 1, gaTNUMMATH+81},
	/*  37 */ {0, 4, gaTNUMMATH+82},
	/*  38 */ {0, 1, gaTNUMMATH+86},
	/*  39 */ {0, 1, gaTNUMMATH+87},
	/*  40 */ {0, 3, gaTNUMMATH+88},
	/*  41 */ {0, 1, gaTNUMMATH+91},
	/*  42 */ {0, 3, gaTNUMMATH+92},
	/*  43 */ {0, 1, gaTNUMMATH+95},
	/*  44 */ {0, 4, gaTNUMMATH+96},
	/*  45 */ {0, 5, gaTNUMMATH+100},
	/*  46 */ {0, 1, gaTNUMMATH+105},
	/*  47 */ {0, 1, gaTNUMMATH+106},
	/*  48 */ {0, 3, gaTNUMMATH+107},
	/*  49 */ {0, 1, gaTNUMMATH+110},
	/*  50 */ {0, 3, gaTNUMMATH+111},
	/*  51 */ {0, 1, gaTNUMMATH+114},
	/*  52 */ {0, 3, gaTNUMMATH+115},
	/*  53 */ {0, 2, gaTNUMMATH+118},
	/*  54 */ {0, 1, gaTNUMMATH+120},
	/*  55 */ {0, 3, gaTNUMMATH+121},
	/*  56 */ {0, 2, gaTNUMMATH+124},
	/*  57 */ {0, 1, gaTNUMMATH+126},
	/*  58 */ {1, 1, gaTNUMMATH+127},
	/*  59 */ {0, 2, gaTNUMMATH+128},
	/*  60 */ {0, 1, gaTNUMMATH+130},
	/*  61 */ {1, 2, gaTNUMMATH+131},
	/*  62 */ {0, 2, gaTNUMMATH+133},
	/*  63 */ {0, 1, gaTNUMMATH+135},
	/*  64 */ {0, 2, gaTNUMMATH+136},
	/*  65 */ {0, 1, gaTNUMMATH+138},
	/*  66 */ {1, 1, gaTNUMMATH+139},
	/*  67 */ {0, 2, gaTNUMMATH+140},
	/*  68 */ {0, 1, gaTNUMMATH+142},
	/*  69 */ {0, 2, gaTNUMMATH+143},
	/*  70 */ {0, 1, gaTNUMMATH+145},
	/*  71 */ {1, 2, gaTNUMMATH+146},
	/*  72 */ {0, 2, gaTNUMMATH+148},
	/*  73 */ {0, 2, gaTNUMMATH+150},
	/*  74 */ {1, 2, gaTNUMMATH+152},
	/*  75 */ {0, 2, gaTNUMMATH+154},
	/*  76 */ {0, 1, gaTNUMMATH+156},
	/*  77 */ {0, 2, gaTNUMMATH+157},
	/*  78 */ {0, 1, gaTNUMMATH+159},
	/*  79 */ {0, 1, gaTNUMMATH+160},
	/*  80 */ {0, 1, gaTNUMMATH+161},
	/*  81 */ {0, 2, gaTNUMMATH+162},
	/*  82 */ {0, 1, gaTNUMMATH+164},
	/*  83 */ {0, 3, gaTNUMMATH+165},
	/*  84 */ {0, 3, gaTNUMMATH+168},
	/*  85 */ {0, 1, gaTNUMMATH+171},
	/*  86 */ {0, 3, gaTNUMMATH+172},
	/*  87 */ {0, 2, gaTNUMMATH+175},
	/*  88 */ {0, 1, gaTNUMMATH+177},
	/*  89 */ {0, 3, gaTNUMMATH+178},
	/*  90 */ {0, 2, gaTNUMMATH+181},
	/*  91 */ {0, 1, gaTNUMMATH+183},
	/*  92 */ {0, 3, gaTNUMMATH+184},
	/*  93 */ {0, 3, gaTNUMMATH+187},
	/*  94 */ {0, 1, gaTNUMMATH+190},
	/*  95 */ {0, 4, gaTNUMMATH+191},
	/*  96 */ {0, 1, gaTNUMMATH+195},
	/*  97 */ {0, 1, gaTNUMMATH+196},
	/*  98 */ {0, 3, gaTNUMMATH+197},
	/*  99 */ {0, 1, gaTNUMMATH+200},
	/* 100 */ {0, 3, gaTNUMMATH+201},
	/* 101 */ {0, 1, gaTNUMMATH+204},
	/* 102 */ {0, 3, gaTNUMMATH+205},
	/* 103 */ {0, 2, gaTNUMMATH+208},
	/* 104 */ {0, 1, gaTNUMMATH+210},
	/* 105 */ {0, 3, gaTNUMMATH+211},
	/* 106 */ {0, 2, gaTNUMMATH+214},
	/* 107 */ {0, 2, gaTNUMMATH+216},
	/* 108 */ {0, 2, gaTNUMMATH+218},
	/* 109 */ {0, 1, gaTNUMMATH+220},
	/* 110 */ {0, 1, gaTNUMMATH+221},
	/* 111 */ {0, 1, gaTNUMMATH+222},
	/* 112 */ {0, 1, gaTNUMMATH+223},
	/* 113 */ {1, 0, NULL},
	/* 114 */ {0, 2, gaTNUMMATH+224},
	/* 115 */ {0, 1, gaTNUMMATH+226},
	/* 116 */ {1, 1, gaTNUMMATH+227},
	/* 117 */ {0, 2, gaTNUMMATH+228},
	/* 118 */ {0, 1, gaTNUMMATH+230},
	/* 119 */ {0, 2, gaTNUMMATH+231},
	/* 120 */ {0, 1, gaTNUMMATH+233},
	/* 121 */ {0, 1, gaTNUMMATH+234},
	/* 122 */ {0, 1, gaTNUMMATH+235},
	/* 123 */ {0, 2, gaTNUMMATH+236},
	/* 124 */ {0, 2, gaTNUMMATH+238},
	/* 125 */ {0, 2, gaTNUMMATH+240},
	/* 126 */ {0, 2, gaTNUMMATH+242},
	/* 127 */ {0, 1, gaTNUMMATH+244},
	/* 128 */ {0, 3, gaTNUMMATH+245},
	/* 129 */ {0, 3, gaTNUMMATH+248},
	/* 130 */ {0, 1, gaTNUMMATH+251},
	/* 131 */ {0, 3, gaTNUMMATH+252},
	/* 132 */ {0, 2, gaTNUMMATH+255},
	/* 133 */ {0, 1, gaTNUMMATH+257},
	/* 134 */ {0, 3, gaTNUMMATH+258},
	/* 135 */ {0, 2, gaTNUMMATH+261},
	/* 136 */ {0, 2, gaTNUMMATH+263},
	/* 137 */ {0, 2, gaTNUMMATH+265},
	/* 138 */ {0, 1, gaTNUMMATH+267},
	/* 139 */ {0, 1, gaTNUMMATH+268},
	/* 140 */ {0, 1, gaTNUMMATH+269},
	/* 141 */ {0, 2, gaTNUMMATH+270},
	/* 142 */ {0, 2, gaTNUMMATH+272},
	/* 143 */ {0, 2, gaTNUMMATH+274},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = hour

// 4 states

static const unsigned char gaSHOUR[] = 
	/* gaStringHOUR+0 */	"01\000"
	/* gaStringHOUR+3 */	"2\000"
	/* gaStringHOUR+5 */	"3456789\000"
	/* gaStringHOUR+13 */	"0123456789\000"
	/* gaStringHOUR+24 */	"01234\000"
;

static const STATE_TRANSITION gaTHOUR[] = {
	{gaSHOUR+0,	1}, // +0: state 0 transitions
	{gaSHOUR+3,	2},
	{gaSHOUR+5,	3},
	{gaSHOUR+13,	3}, // +3: state 1 transitions
	{gaSHOUR+24,	3}, // +4: state 2 transitions
};

const STATE_DESCRIPTION aStateDescHOUR[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTHOUR+0},
	/*   1 */ {1, 1, gaTHOUR+3},
	/*   2 */ {1, 1, gaTHOUR+4},
	/*   3 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = minute

// 3 states

static const unsigned char gaSMINUTE[] = 
	/* gaStringMINUTE+0 */	"012345\000"
	/* gaStringMINUTE+7 */	"6789\000"
	/* gaStringMINUTE+12 */	"0123456789\000"
;

static const STATE_TRANSITION gaTMINUTE[] = {
	{gaSMINUTE+0,	1}, // +0: state 0 transitions
	{gaSMINUTE+7,	2},
	{gaSMINUTE+12,	2}, // +2: state 1 transitions
};

const STATE_DESCRIPTION aStateDescMINUTE[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTMINUTE+0},
	/*   1 */ {1, 1, gaTMINUTE+2},
	/*   2 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = second

// 3 states

static const unsigned char gaSSECOND[] = 
	/* gaStringSECOND+0 */	"012345\000"
	/* gaStringSECOND+7 */	"6789\000"
	/* gaStringSECOND+12 */	"0123456789\000"
;

static const STATE_TRANSITION gaTSECOND[] = {
	{gaSSECOND+0,	1}, // +0: state 0 transitions
	{gaSSECOND+7,	2},
	{gaSSECOND+12,	2}, // +2: state 1 transitions
};

const STATE_DESCRIPTION aStateDescSECOND[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTSECOND+0},
	/*   1 */ {1, 1, gaTSECOND+2},
	/*   2 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = year

// 5 states

static const unsigned char gaSYEAR[] = 
	/* gaStringYEAR+0 */	"0123456789\000"
;

static const STATE_TRANSITION gaTYEAR[] = {
	{gaSYEAR+0,	1}, // +0: state 0 transitions
	{gaSYEAR+0,	2}, // +1: state 1 transitions
	{gaSYEAR+0,	3}, // +2: state 2 transitions
	{gaSYEAR+0,	4}, // +3: state 3 transitions
};

const STATE_DESCRIPTION aStateDescYEAR[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTYEAR+0},
	/*   1 */ {0, 1, gaTYEAR+1},
	/*   2 */ {1, 1, gaTYEAR+2},
	/*   3 */ {0, 1, gaTYEAR+3},
	/*   4 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:29 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = monthnum

// 4 states

static const unsigned char gaSMONTHNUM[] = 
	/* gaStringMONTHNUM+0 */	"0\000"
	/* gaStringMONTHNUM+2 */	"1\000"
	/* gaStringMONTHNUM+4 */	"23456789\000"
	/* gaStringMONTHNUM+13 */	"123456789\000"
	/* gaStringMONTHNUM+23 */	"012\000"
;

static const STATE_TRANSITION gaTMONTHNUM[] = {
	{gaSMONTHNUM+0,	1}, // +0: state 0 transitions
	{gaSMONTHNUM+2,	2},
	{gaSMONTHNUM+4,	3},
	{gaSMONTHNUM+13,	3}, // +3: state 1 transitions
	{gaSMONTHNUM+23,	3}, // +4: state 2 transitions
};

const STATE_DESCRIPTION aStateDescMONTHNUM[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTMONTHNUM+0},
	/*   1 */ {0, 1, gaTMONTHNUM+3},
	/*   2 */ {1, 1, gaTMONTHNUM+4},
	/*   3 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:30 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = dayofmonth

// 5 states

static const unsigned char gaSDAYOFMONTH[] = 
	/* gaStringDAYOFMONTH+0 */	"0\000"
	/* gaStringDAYOFMONTH+2 */	"12\000"
	/* gaStringDAYOFMONTH+5 */	"3\000"
	/* gaStringDAYOFMONTH+7 */	"456789\000"
	/* gaStringDAYOFMONTH+14 */	"123456789\000"
	/* gaStringDAYOFMONTH+24 */	"0123456789\000"
	/* gaStringDAYOFMONTH+35 */	"01\000"
;

static const STATE_TRANSITION gaTDAYOFMONTH[] = {
	{gaSDAYOFMONTH+0,	1}, // +0: state 0 transitions
	{gaSDAYOFMONTH+2,	2},
	{gaSDAYOFMONTH+5,	3},
	{gaSDAYOFMONTH+7,	4},
	{gaSDAYOFMONTH+14,	4}, // +4: state 1 transitions
	{gaSDAYOFMONTH+24,	4}, // +5: state 2 transitions
	{gaSDAYOFMONTH+35,	4}, // +6: state 3 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFMONTH[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTDAYOFMONTH+0},
	/*   1 */ {0, 1, gaTDAYOFMONTH+4},
	/*   2 */ {1, 1, gaTDAYOFMONTH+5},
	/*   3 */ {1, 1, gaTDAYOFMONTH+6},
	/*   4 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:30 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = creditcard

// 20 states

static const unsigned char gaSCREDITCARD[] = 
	/* gaStringCREDITCARD+0 */	"0123456789\000"
	/* gaStringCREDITCARD+11 */	" \000"
;

static const STATE_TRANSITION gaTCREDITCARD[] = {
	{gaSCREDITCARD+0,	1}, // +0: state 0 transitions
	{gaSCREDITCARD+0,	2}, // +1: state 1 transitions
	{gaSCREDITCARD+0,	3}, // +2: state 2 transitions
	{gaSCREDITCARD+0,	4}, // +3: state 3 transitions
	{gaSCREDITCARD+11,	5}, // +4: state 4 transitions
	{gaSCREDITCARD+0,	6}, // +5: state 5 transitions
	{gaSCREDITCARD+0,	7}, // +6: state 6 transitions
	{gaSCREDITCARD+0,	8}, // +7: state 7 transitions
	{gaSCREDITCARD+0,	9}, // +8: state 8 transitions
	{gaSCREDITCARD+11,	10}, // +9: state 9 transitions
	{gaSCREDITCARD+0,	11}, // +10: state 10 transitions
	{gaSCREDITCARD+0,	12}, // +11: state 11 transitions
	{gaSCREDITCARD+0,	13}, // +12: state 12 transitions
	{gaSCREDITCARD+0,	14}, // +13: state 13 transitions
	{gaSCREDITCARD+11,	15}, // +14: state 14 transitions
	{gaSCREDITCARD+0,	16}, // +15: state 15 transitions
	{gaSCREDITCARD+0,	17}, // +16: state 16 transitions
	{gaSCREDITCARD+0,	18}, // +17: state 17 transitions
	{gaSCREDITCARD+0,	19}, // +18: state 18 transitions
};

const STATE_DESCRIPTION aStateDescCREDITCARD[20] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTCREDITCARD+0},
	/*   1 */ {0, 1, gaTCREDITCARD+1},
	/*   2 */ {0, 1, gaTCREDITCARD+2},
	/*   3 */ {0, 1, gaTCREDITCARD+3},
	/*   4 */ {0, 1, gaTCREDITCARD+4},
	/*   5 */ {0, 1, gaTCREDITCARD+5},
	/*   6 */ {0, 1, gaTCREDITCARD+6},
	/*   7 */ {0, 1, gaTCREDITCARD+7},
	/*   8 */ {0, 1, gaTCREDITCARD+8},
	/*   9 */ {0, 1, gaTCREDITCARD+9},
	/*  10 */ {0, 1, gaTCREDITCARD+10},
	/*  11 */ {0, 1, gaTCREDITCARD+11},
	/*  12 */ {0, 1, gaTCREDITCARD+12},
	/*  13 */ {0, 1, gaTCREDITCARD+13},
	/*  14 */ {0, 1, gaTCREDITCARD+14},
	/*  15 */ {0, 1, gaTCREDITCARD+15},
	/*  16 */ {0, 1, gaTCREDITCARD+16},
	/*  17 */ {0, 1, gaTCREDITCARD+17},
	/*  18 */ {0, 1, gaTCREDITCARD+18},
	/*  19 */ {1, 0, NULL},
};

// end of text generated by re2fsa
// text generated by re2fsa at Fri Nov 30 16:02:30 2001

// the input-file of rules:
// integer = digit_seq  ;
// digit_seq = digit+ ;
// digit = "0123456789" ;
// space = " " ;
// period = "." ;
// rank = "e" "r" | "e" | "" | "" "m" "e" | "" "r" "e";
// rank = "E" "R" | "E" | "" | "" "m" "e" | "" "R" "E" ;
// sign = "+-" ;
// 
// numThousand = digit digit digit ;
// numThousandSpace = digit digit digit space  ;
// numThousandPeriod = digit digit digit period ;
// numThousandSpaceLeading = [digit [digit]] digit space  ;
// numThousandPeriodLeading  = [digit [digit]] digit period ;
// numThousandTrailing = [digit [digit]] digit ;
// 
// #numsimpleUnsigned =  [numThousandSpaceLeading] numThousandSpace* numThousand  ;
// #numsimpleUnsigned =  [numThousandPeriodLeading] numThousandPeriod* numThousand ;
// #numsimpleUnsigned =  numThousandTrailing ;
// numsimpleUnsigned = digit_seq ;
// 
// numsimple = [sign] numsimpleUnsigned ["," digit_seq] ;
// 
// numnum = "" space digit_seq ;
// numnth = integer rank ;
// 
// numunit = numsimple space unit [period] ;
// numunit = numsimple "" space ("C" | "F" );
// 
// numpercent = numsimple space "%" ;
// 
// 
// numdate = "'" digit digit ;
// numdate = [dayofmonth "/"] monthnum "/" year ;
// numdate = dayofmonth "/" monthnum ;
// numdate = [dayofmonth "-"] monthnum "-" year ;
// numdate = dayofmonth "-" monthnum ;
// numdate = [weekday space]  dayofmonthLong space monthName [space year ];
// numdate = dayofmonthLong  space monthName [space year ];
// numdate = digit4 "-" monthnum "-" dayofmonth ;
// 
// monthnum = ["0"] "123456789" | "1" "012" ;
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01"  ;
// dayofmonthLong = dayofmonth | "1" "e" "r";
// year = digit digit [digit digit] ;
// 
// weekday = ("L" | "l") "u" "n" "d" "i" ;
// weekday = ("M" | "m") "a" "r" "d" "i" ;
// weekday = ("M" | "m") "e" "r" "c" "r" "e" "d" "i" ;
// weekday = ("J" | "j") "e" "u" "d" "i" ;
// weekday = ("V" | "v") "e" "n" "d" "r" "e" "d" "i" ;
// weekday = ("S" | "s") "a" "m" "e" "d" "i" ;
// weekday = ("D" | "d") "i" "m" "a" "n" "c" "h" "e" ;
// 
// 
// monthName = ("J" | "j") "a" "n" ["v" "i" "e" "r" | period];
// monthName = ("F" | "f") "" "v"  ["r" "i" "e" "r"  | period];
// monthName = ("M" | "m") "a" "r" ["s" | period] ;
// monthName = ("A" | "a") "v"  ["r" "i" "l" | period];
// monthName = ("M" | "m") "a" "i" ;
// monthName = ("J" | "j") "u" "i" ["n" | period] ;
// monthName = ("J" | "j") "u" "i" "l" ["l" "e" "t" | period ];
// monthName = ("A" | "a") "o" ""  ["t" | period];
// monthName = ("S" | "s") "e" "p" ["t" "e" "m" "b" "r" "e" | period];
// monthName = ("O" | "o") "c" "t" ["o" "b" "r" "e" | period];
// monthName = ("N" | "n") "o" "v" ["e" "m" "b" "r" "e" | period];
// monthName = ("D" | "d") "" "c" ["e" "m" "b" "r" "e" | period];
// 
// 
// numtime = hour ":" minute [":" second]  ;
// numtime = hour ":" minute space ("h" | "H") ;
// numtime = hour ("h" | "H") minute ;
// numtime = hour space ("h" | "H" ) ;
// 
// hour = ["01" ] "0123456789" | "2" "01234" ;
// minute = digit | "012345" digit;
// second = digit | "012345" digit;
// 
// curSymbol = "$" | "F" [ "." | "r" | "R" ["F"] | "F" | "r" "s" ] | "f" [ "." | "r" ["s"] ]  ;
// curSymbol = "E" "U" "R" ["O"]  | "U" "S" "D" | "U" "S" "$" ;
// 
// numcurrency = numsimpleUnsigned ["," digit2 ] space  curSymbol ;
// 
// zip = digit digit digit digit digit ;
// 
// digit4 = digit digit digit digit ;
// 
// creditcard = digit4 space digit4 space digit4 space  digit4 ;
// 
// digit2 = digit digit ;
// phonePrefix = ["+" | "0" "0" ] digit2 space ( digit2 | "(" "0" ")" digit) ;
// phonePrefix = "(" digit2 ")" (space | ".") digit2 ;
// 
// 
// numphone = (phonePrefix | digit2 ) "."   digit2  "."  digit2 "."   digit2  "."  digit2;
// numphone = (phonePrefix | digit2)  space digit2 space digit2 space digit2 space digit2;
// numphone =  digit2  space digit2 space digit2 space digit2 ;
// numphone = "0" numThousand space digit2 space digit2 space digit2;
// numphone = "0" numThousand period digit2 period digit2 period digit2;
// 
// 
// nummath = expr [equals expr] ;
// expr = term [plus term] ;
// term = numsimple ;
// term = "(" numsimple ")";
// term = "(" numsimple plus numsimple ")" ;
// term = "{" numsimple plus numsimple "}" ;
// term = "[" numsimple plus numsimple "]" ;
// equals = "<>=" ;
// plus = "+-/*x" ;
// 
// unitDistance = "mcdhkK" "m" | "m" | "d" "a" "m" ;
// unitVolume = "mcdh" "l" | "l" | "L" | "d" "a" "l" ;
// unitWeight = "mkcdhK" "g" | "g" ["r" ] | "d" "a" "g" | "q"  | "tT" ;
// unitSurface = "ch" "a" | "a" ;
// unitTime = "shj" | "m" "i" "n" ;
// unitSound = "d" "B" ;
// unitComputer = "MK" "o";
// 
// unit = unitDistance ;
// unit = unitVolume ;
// unit = unitWeight ;
// unit = unitSurface ;
// unit = unitTime ;
// unit = unitSound;
// unit = unitComputer ;
// 
// number = numsimple ;
// #number = numnth ;
// #number = numunit ;
// number = numpercent ;
// number = numdate ;
// number = numtime ;
// number = numcurrency ;
// number = numphone ;
// number = nummath ;
// 
// = zip

// 6 states

static const unsigned char gaSZIP[] = 
	/* gaStringZIP+0 */	"0123456789\000"
;

static const STATE_TRANSITION gaTZIP[] = {
	{gaSZIP+0,	1}, // +0: state 0 transitions
	{gaSZIP+0,	2}, // +1: state 1 transitions
	{gaSZIP+0,	3}, // +2: state 2 transitions
	{gaSZIP+0,	4}, // +3: state 3 transitions
	{gaSZIP+0,	5}, // +4: state 4 transitions
};

const STATE_DESCRIPTION aStateDescZIP[6] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTZIP+0},
	/*   1 */ {0, 1, gaTZIP+1},
	/*   2 */ {0, 1, gaTZIP+2},
	/*   3 */ {0, 1, gaTZIP+3},
	/*   4 */ {0, 1, gaTZIP+4},
	/*   5 */ {1, 0, NULL},
};

// end of text generated by re2fsa

const STATE_DESCRIPTION *aStateDescSSN = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\number.h ===
// number.h
// Angshuman Guha, aguha
// Sep 18, 1998

#ifndef __INC_NUMBER_H
#define __INC_NUMBER_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescNUMBER[];
extern const STATE_DESCRIPTION aStateDescNUMSIMPLE[];
extern const STATE_DESCRIPTION aStateDescNUMNTH[];
extern const STATE_DESCRIPTION aStateDescNUMUNIT[];
extern const STATE_DESCRIPTION aStateDescNUMNUM[];
extern const STATE_DESCRIPTION aStateDescNUMPERCENT[];
extern const STATE_DESCRIPTION aStateDescNUMDATE[];
extern const STATE_DESCRIPTION aStateDescNUMTIME[];
extern const STATE_DESCRIPTION aStateDescNUMCURRENCY[];
extern const STATE_DESCRIPTION aStateDescNUMPHONE[];
extern const STATE_DESCRIPTION aStateDescNUMMATH[];
extern const STATE_DESCRIPTION aStateDescZIP[];
extern const STATE_DESCRIPTION aStateDescCREDITCARD[];
extern const STATE_DESCRIPTION aStateDescDAYOFMONTH[];
extern const STATE_DESCRIPTION aStateDescMONTHNUM[];
extern const STATE_DESCRIPTION aStateDescYEAR[];
extern const STATE_DESCRIPTION aStateDescSECOND[];
extern const STATE_DESCRIPTION aStateDescMINUTE[];
extern const STATE_DESCRIPTION aStateDescHOUR[];
extern const STATE_DESCRIPTION aStateDescSSN[9];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\prefix.h ===
// prefix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_PREFIX_H
#define __INC_PREFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescPrefix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\lpunc.c ===
// lpunc.c (Leading punctuation)
// 
// Nov 2001 mrevow
// Matches LM spec of 10/15/2001

#include "common.h"
#include "lpunc.h"

// text generated by re2fsa at Mon Nov 05 13:18:04 2001

// the input-file of rules:
// L = DQ ;
// L = l ;
// L = DQ l ;
// L = l DQ ;
// L = SQ ;
// L = SQ l ;
// L = l SQ ;
// L = SQ DQ ;
// L = DQ SQ ;
// # L'' ;
// # L''l ;
// # Ll'' ;
// # L`` ;
// # L``l ;
// # Ll`` ;
// l = "(" ;
// l = "[" ;
// l = "{" ;
// l = "" " " ;
// l = "." "." "." ;
// l = "*" ["*" ["*"]] ;
// DQ = "\"" ;
// SQ = "'" ;
// = L ;

// 15 states

static const unsigned char gaSLPUNC[] = 
	/* gaStringLPUNC+0 */	"\"\000"
	/* gaStringLPUNC+2 */	"'\000"
	/* gaStringLPUNC+4 */	"([{\000"
	/* gaStringLPUNC+8 */	"*\000"
	/* gaStringLPUNC+10 */	".\000"
	/* gaStringLPUNC+12 */	"\000"
	/* gaStringLPUNC+14 */	"'([{\000"
	/* gaStringLPUNC+19 */	"\"([{\000"
	/* gaStringLPUNC+24 */	"\"'\000"
	/* gaStringLPUNC+27 */	" \000"
;

static const STATE_TRANSITION gaTLPUNC[] = {
	{gaSLPUNC+0,	1}, // +0: state 0 transitions
	{gaSLPUNC+2,	2},
	{gaSLPUNC+4,	3},
	{gaSLPUNC+8,	4},
	{gaSLPUNC+10,	5},
	{gaSLPUNC+12,	6},
	{gaSLPUNC+14,	7}, // +6: state 1 transitions
	{gaSLPUNC+8,	8},
	{gaSLPUNC+10,	9},
	{gaSLPUNC+12,	10},
	{gaSLPUNC+19,	7}, // +10: state 2 transitions
	{gaSLPUNC+8,	8},
	{gaSLPUNC+10,	9},
	{gaSLPUNC+12,	10},
	{gaSLPUNC+24,	7}, // +14: state 3 transitions
	{gaSLPUNC+24,	7}, // +15: state 4 transitions
	{gaSLPUNC+8,	11},
	{gaSLPUNC+10,	12}, // +17: state 5 transitions
	{gaSLPUNC+27,	3}, // +18: state 6 transitions
	{gaSLPUNC+8,	13}, // +19: state 8 transitions
	{gaSLPUNC+10,	14}, // +20: state 9 transitions
	{gaSLPUNC+27,	7}, // +21: state 10 transitions
	{gaSLPUNC+8,	3}, // +22: state 11 transitions
	{gaSLPUNC+24,	7},
	{gaSLPUNC+10,	3}, // +24: state 12 transitions
	{gaSLPUNC+8,	7}, // +25: state 13 transitions
	{gaSLPUNC+10,	7}, // +26: state 14 transitions
};

const STATE_DESCRIPTION aStateDescLPUNC[15] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 6, gaTLPUNC+0},
	/*   1 */ {1, 4, gaTLPUNC+6},
	/*   2 */ {1, 4, gaTLPUNC+10},
	/*   3 */ {1, 1, gaTLPUNC+14},
	/*   4 */ {1, 2, gaTLPUNC+15},
	/*   5 */ {0, 1, gaTLPUNC+17},
	/*   6 */ {0, 1, gaTLPUNC+18},
	/*   7 */ {1, 0, NULL},
	/*   8 */ {1, 1, gaTLPUNC+19},
	/*   9 */ {0, 1, gaTLPUNC+20},
	/*  10 */ {0, 1, gaTLPUNC+21},
	/*  11 */ {1, 2, gaTLPUNC+22},
	/*  12 */ {0, 1, gaTLPUNC+24},
	/*  13 */ {1, 1, gaTLPUNC+25},
	/*  14 */ {0, 1, gaTLPUNC+26},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\prefix.c ===
#include "common.h"
#include "prefix.h"

const STATE_DESCRIPTION *aStateDescPrefix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\punc.h ===
// punc.h
// Angshuman Guha, aguha
// Sep 22, 1998
// Major mod Jan 10, 2001

#ifndef __INC_PUNC_H
#define __INC_PUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\shrtlist.h ===
// shrtlist.c
// Angshuman Guha
// aguha
// Feb 7, 2001

#ifndef __INC_SHORTLIST_H
#define __INC_SHORTLIST_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescDAYOFWEEK[];
extern const STATE_DESCRIPTION aStateDescMONTH[];
extern const STATE_DESCRIPTION aStateDescGENDER[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\singlech.h ===
// singlech.h
// Angshuman Guha
// aguha
// Feb 6, 2001

#ifndef __INC_SINGLE_CHAR_H
#define __INC_SINGLE_CHAR_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescUPPERCHAR[];
extern const STATE_DESCRIPTION aStateDescLOWERCHAR[];
extern const STATE_DESCRIPTION aStateDescDIGITCHAR[];
extern const STATE_DESCRIPTION aStateDescPUNCCHAR[];
extern const STATE_DESCRIPTION aStateDescONECHAR[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\suffix.h ===
// suffix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_SUFFIX_H
#define __INC_SUFFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescSuffix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\tpunc.h ===
// tpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_TPUNC_H
#define __INC_TPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescTPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\viterbixlate.c ===
/****************************************************
 *
 * viterbiXlate.c
 *
 * Provides translation services between activataions and supported characters
 * for the viterbi search
 *
 * This is language specific, because European construct virtual activations
 * cannot simply use net outputs activations as surrogate
 * for character activations
 *
 ********************************************************/  
#include <common.h>
#include <nfeature.h>
#include <engine.h>
#include <infernop.h>
#include "charmap.h"
#include <charcost.h>
#include <outDict.h>
#include <viterbi.h>


void BuildActiveMap(const REAL *pActivation, int cSegments, int cOutput, BYTE rgbActiveChar[C_CHAR_ACTIVATIONS])
{
	int				row, col, cActive, cIteration = 5;
	int				thisChar;
	const REAL		*pAct;
	REAL			MinActivation = (REAL)
#ifdef FIXEDPOINT
	655;
#else
	0.01;
#endif

	do 
	{
		cActive = 0;
		memset(rgbActiveChar, 0, C_CHAR_ACTIVATIONS*sizeof(*rgbActiveChar));
		pAct = pActivation;

		for (col=cSegments; col; col--)
		{
			pAct++;

			for (row = 1 ; row < cOutput ; row++, pAct++)
			{
				if (IsOutputBegin(row))
				{
					thisChar = Out2Char(row);
				}
				else
				{
					thisChar = 256+Out2Char(row);
				}

				if (!rgbActiveChar[thisChar] && *pAct > MinActivation)
				{
					rgbActiveChar[thisChar] = 1;
					++cActive;
				}
			}
		}

		// Keep doubling the min activation if there are too many active characters
		MinActivation *= 2;

	} while ((cActive > OD_MAX_ACTIVE_CHAR) && --cIteration);

	// Check for Virtual Character activations
	for (thisChar=0; thisChar<256; thisChar++)
	{
		if (IsVirtualChar(thisChar))
		{
			rgbActiveChar[thisChar] = rgbActiveChar[BaseVirtualChar(thisChar)] && rgbActiveChar[AccentVirtualChar(thisChar)];
			rgbActiveChar[thisChar+256] = rgbActiveChar[BaseVirtualChar(thisChar)+256] && rgbActiveChar[AccentVirtualChar(thisChar)];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\suffix.c ===
#include "common.h"
#include "suffix.h"

const STATE_DESCRIPTION *aStateDescSuffix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\punc.c ===
// punc.c
// 
// Nov 2001 mrevow
// Matches LM spec of 10/15/2001

#include "common.h"
#include "punc.h"

// text generated by re2fsa at Mon Nov 05 13:36:52 2001

// the input-file of rules:
// punc = comma;
// punc = dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = colon;
// punc = semicolon;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = rparen;
// punc = rparen comma;
// punc = rparen dot;
// punc = rparen colon;
// punc = rparen semicolon;
// punc = rparen question;
// punc = rparen question question;
// punc = rparen question question question;
// punc = rparen bang;
// punc = rparen bang bang;
// punc = rparen bang bang bang;
// punc = rparen rparen;
// punc = rparen rparen comma;
// punc = rparen rparen dot;
// punc = rparen rparen colon;
// punc = rparen rparen semicolon;
// punc = rparen rparen question;
// punc = rparen rparen question question;
// punc = rparen rparen question question question;
// punc = rparen rparen bang;
// punc = rparen rparen bang bang;
// punc = rparen rparen bang bang bang;
// punc = comma rparen;
// punc = dot rparen;
// punc = colon rparen;
// punc = semicolon rparen;
// punc = question rparen;
// punc = question question rparen;
// punc = question question question rparen;
// punc = bang rparen;
// punc = bang bang rparen;
// punc = bang bang bang rparen;
// punc = dot dot dot rparen;
// punc = rbracket;
// punc = rbracket comma;
// punc = rbracket dot;
// punc = rbracket colon;
// punc = rbracket semicolon;
// punc = rbracket question;
// punc = rbracket question question;
// punc = rbracket question question question;
// punc = rbracket bang;
// punc = rbracket bang bang;
// punc = rbracket bang bang bang;
// punc = rbrace;
// punc = rbrace comma;
// punc = rbrace dot;
// punc = rbrace colon;
// punc = rbrace semicolon;
// punc = rbrace question;
// punc = rbrace question question;
// punc = rbrace question question question;
// punc = rbrace bang;
// punc = rbrace bang bang;
// punc = rbrace bang bang bang;
// punc = star;
// punc = star star;
// punc = star star star;
// punc = slash;
// punc = ampersand;
// punc = dollar;
// punc = dollar dollar;
// punc = dollar dollar dollar;
// punc = euro;
// punc = pound;
// punc = yen;
// punc = equals;
// punc = dquote;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = question question question question;
// punc = question question question question question;
// punc = bslash;
// punc = lessthan;
// punc = greaterthan;
// punc = plus;
// punc = tilde;
// punc = at;
// punc = circumflex;
// punc = star;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = bang bang bang bang;
// punc = bang bang bang bang bang;
// punc = hash;
// punc = lparen plus rparen;
// punc = lparen minus rparen;
// punc = dquote tilde dquote;
// punc = dquote bang dquote;
// punc = dquote at dquote;
// punc = dquote hash dquote;
// punc = dquote dollar dquote;
// punc = dquote euro dquote;
// punc = dquote pound dquote;
// punc = dquote yen dquote;
// punc = dquote percent dquote;
// punc = dquote circumflex dquote;
// punc = dquote ampersand dquote;
// punc = dquote star dquote;
// punc = dquote lparen dquote;
// punc = dquote rparen dquote;
// punc = dquote minus dquote;
// punc = dquote uscore dquote;
// punc = dquote equals dquote;
// punc = dquote plus dquote;
// punc = dquote lbracket dquote;
// punc = dquote lbrace dquote;
// punc = dquote rbracket dquote;
// punc = dquote rbrace dquote;
// punc = dquote bslash dquote;
// punc = dquote semicolon dquote;
// punc = dquote colon dquote;
// punc = dquote squote dquote;
// punc = dquote dquote dquote;
// punc = dquote comma dquote;
// punc = dquote lessthan dquote;
// punc = dquote dot dquote;
// punc = dquote greaterthan dquote;
// punc = dquote slash dquote;
// punc = dquote question dquote;
// punc = minus;
// punc = minus minus;
// punc = minus minus minus;
// punc = minus minus minus minus;
// punc = minus minus minus minus minus;
// punc = uscore;
// punc = uscore uscore;
// punc = uscore uscore uscore;
// punc = uscore uscore uscore uscore;
// punc = uscore uscore uscore uscore uscore;
// punc = dot;
// punc = dot dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = dot dot dot dot dot;
// comma = ",";
// dot = ".";
// colon = ":";
// semicolon = ";";
// question = "?";
// bang = "!";
// rparen = ")";
// lparen = "(";
// rbracket = "]";
// lbracket = "[";
// rbrace = "}";
// lbrace = "{";
// dquote = "\"" | "" ;
// squote = "'";
// tilde = "~";
// at = "@";
// hash = "#";
// dollar = "$";
// percent = "%";
// circumflex = "^";
// ampersand = "&";
// star = "*";
// plus = "+";
// minus = "-";
// uscore = "_";
// lessthan = "<";
// greaterthan = ">";
// slash = "/";
// bslash = "\\";
// equals = "=";
// pound = "";
// yen = "";
// euro = "";
// 
// = punc ;
// 35 states

static const unsigned char gaSPUNC[] = 
	/* gaStringPUNC+0 */	"!\000"
	/* gaStringPUNC+2 */	"\"\000"
	/* gaStringPUNC+5 */	"#&+/<=>@\\^~\000"
	/* gaStringPUNC+20 */	"$\000"
	/* gaStringPUNC+22 */	"(\000"
	/* gaStringPUNC+24 */	")\000"
	/* gaStringPUNC+26 */	"*\000"
	/* gaStringPUNC+28 */	",:;\000"
	/* gaStringPUNC+32 */	"-\000"
	/* gaStringPUNC+34 */	".\000"
	/* gaStringPUNC+36 */	"?\000"
	/* gaStringPUNC+38 */	"]}\000"
	/* gaStringPUNC+41 */	"_\000"
	/* gaStringPUNC+43 */	"!\"#$%&'()*+,-./:;<=>?@[\\]^_{}~\000"
	/* gaStringPUNC+78 */	"+-\000"
	/* gaStringPUNC+81 */	",.:;\000"
;

static const STATE_TRANSITION gaTPUNC[] = {
	{gaSPUNC+0,	1}, // +0: state 0 transitions
	{gaSPUNC+2,	2},
	{gaSPUNC+5,	3},
	{gaSPUNC+20,	4},
	{gaSPUNC+22,	5},
	{gaSPUNC+24,	6},
	{gaSPUNC+26,	7},
	{gaSPUNC+28,	8},
	{gaSPUNC+32,	9},
	{gaSPUNC+34,	10},
	{gaSPUNC+36,	11},
	{gaSPUNC+38,	12},
	{gaSPUNC+41,	13},
	{gaSPUNC+24,	3}, // +13: state 1 transitions
	{gaSPUNC+0,	14},
	{gaSPUNC+43,	15}, // +15: state 2 transitions
	{gaSPUNC+20,	16}, // +16: state 4 transitions
	{gaSPUNC+78,	17}, // +17: state 5 transitions
	{gaSPUNC+81,	3}, // +18: state 6 transitions
	{gaSPUNC+24,	12},
	{gaSPUNC+0,	18},
	{gaSPUNC+36,	19},
	{gaSPUNC+26,	20}, // +22: state 7 transitions
	{gaSPUNC+24,	3}, // +23: state 8 transitions
	{gaSPUNC+32,	21}, // +24: state 9 transitions
	{gaSPUNC+24,	3}, // +25: state 10 transitions
	{gaSPUNC+34,	22},
	{gaSPUNC+24,	3}, // +27: state 11 transitions
	{gaSPUNC+36,	23},
	{gaSPUNC+81,	3}, // +29: state 12 transitions
	{gaSPUNC+0,	18},
	{gaSPUNC+36,	19},
	{gaSPUNC+41,	24}, // +32: state 13 transitions
	{gaSPUNC+24,	3}, // +33: state 14 transitions
	{gaSPUNC+0,	25},
	{gaSPUNC+2,	3}, // +35: state 15 transitions
	{gaSPUNC+20,	3}, // +36: state 16 transitions
	{gaSPUNC+24,	3}, // +37: state 17 transitions
	{gaSPUNC+0,	26}, // +38: state 18 transitions
	{gaSPUNC+36,	27}, // +39: state 19 transitions
	{gaSPUNC+26,	3}, // +40: state 20 transitions
	{gaSPUNC+32,	28}, // +41: state 21 transitions
	{gaSPUNC+34,	29}, // +42: state 22 transitions
	{gaSPUNC+24,	3}, // +43: state 23 transitions
	{gaSPUNC+36,	30},
	{gaSPUNC+41,	31}, // +45: state 24 transitions
	{gaSPUNC+24,	3}, // +46: state 25 transitions
	{gaSPUNC+0,	26},
	{gaSPUNC+0,	3}, // +48: state 26 transitions
	{gaSPUNC+36,	3}, // +49: state 27 transitions
	{gaSPUNC+32,	32}, // +50: state 28 transitions
	{gaSPUNC+24,	3}, // +51: state 29 transitions
	{gaSPUNC+34,	33},
	{gaSPUNC+24,	3}, // +53: state 30 transitions
	{gaSPUNC+36,	27},
	{gaSPUNC+41,	34}, // +55: state 31 transitions
	{gaSPUNC+32,	3}, // +56: state 32 transitions
	{gaSPUNC+34,	3}, // +57: state 33 transitions
	{gaSPUNC+41,	3}, // +58: state 34 transitions
};

const STATE_DESCRIPTION aStateDescPUNC[35] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 13, gaTPUNC+0},
	/*   1 */ {1, 2, gaTPUNC+13},
	/*   2 */ {1, 1, gaTPUNC+15},
	/*   3 */ {1, 0, NULL},
	/*   4 */ {1, 1, gaTPUNC+16},
	/*   5 */ {0, 1, gaTPUNC+17},
	/*   6 */ {1, 4, gaTPUNC+18},
	/*   7 */ {1, 1, gaTPUNC+22},
	/*   8 */ {1, 1, gaTPUNC+23},
	/*   9 */ {1, 1, gaTPUNC+24},
	/*  10 */ {1, 2, gaTPUNC+25},
	/*  11 */ {1, 2, gaTPUNC+27},
	/*  12 */ {1, 3, gaTPUNC+29},
	/*  13 */ {1, 1, gaTPUNC+32},
	/*  14 */ {1, 2, gaTPUNC+33},
	/*  15 */ {0, 1, gaTPUNC+35},
	/*  16 */ {1, 1, gaTPUNC+36},
	/*  17 */ {0, 1, gaTPUNC+37},
	/*  18 */ {1, 1, gaTPUNC+38},
	/*  19 */ {1, 1, gaTPUNC+39},
	/*  20 */ {1, 1, gaTPUNC+40},
	/*  21 */ {1, 1, gaTPUNC+41},
	/*  22 */ {1, 1, gaTPUNC+42},
	/*  23 */ {1, 2, gaTPUNC+43},
	/*  24 */ {1, 1, gaTPUNC+45},
	/*  25 */ {1, 2, gaTPUNC+46},
	/*  26 */ {1, 1, gaTPUNC+48},
	/*  27 */ {1, 1, gaTPUNC+49},
	/*  28 */ {1, 1, gaTPUNC+50},
	/*  29 */ {1, 2, gaTPUNC+51},
	/*  30 */ {1, 2, gaTPUNC+53},
	/*  31 */ {1, 1, gaTPUNC+55},
	/*  32 */ {1, 1, gaTPUNC+56},
	/*  33 */ {1, 1, gaTPUNC+57},
	/*  34 */ {1, 1, gaTPUNC+58},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\singlech.c ===
// singlech.c
// Angshuman Guha
// aguha
// Feb 6, 2001

#include "common.h"
#include "singlech.h"

/**************** UPPERCHAR ***********************************/

static const STATE_TRANSITION gaTUPPERCHAR[] = { {"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1} };

const STATE_DESCRIPTION aStateDescUPPERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTUPPERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** LOWERCHAR ***********************************/

static const STATE_TRANSITION gaTLOWERCHAR[] = { {"abcdefghijklmnopqrstuvwxyz", 1} };

const STATE_DESCRIPTION aStateDescLOWERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTLOWERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** DIGITCHAR ***********************************/

static const STATE_TRANSITION gaTDIGITCHAR[] = { {"0123456789", 1} };

const STATE_DESCRIPTION aStateDescDIGITCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTDIGITCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** PUNCCHAR ***********************************/

static const STATE_TRANSITION gaTPUNCCHAR[] = { {"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", 1} };

const STATE_DESCRIPTION aStateDescPUNCCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTPUNCCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** ONECHAR ***********************************/

static const STATE_TRANSITION gaTONECHAR[] = { {"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~", 1} };

const STATE_DESCRIPTION aStateDescONECHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTONECHAR },
	/*  1 */ { 1, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\shrtlist.c ===
// shrtlist.c  (factoids which are short lists of words)
//
// November 2001 (mrevow)
//

#include "common.h"
#include "shrtlist.h"

// text generated by re2fsa at Thu Nov 15 13:56:17 2001

// the input-file of rules:
// Lundi
// Mardi
// Mercredi
// Jeudi
// Vendredi
// Samedi
// Dimanche
// lundi
// mardi
// mercredi
// jeudi
// vendredi
// samedi
// dimanche

// 26 states

static const unsigned char gaSDAYOFWEEK[] = 
	/* gaStringDAYOFWEEK+0 */	"Dd\000"
	/* gaStringDAYOFWEEK+3 */	"Jj\000"
	/* gaStringDAYOFWEEK+6 */	"Ll\000"
	/* gaStringDAYOFWEEK+9 */	"Mm\000"
	/* gaStringDAYOFWEEK+12 */	"Ss\000"
	/* gaStringDAYOFWEEK+15 */	"Vv\000"
	/* gaStringDAYOFWEEK+18 */	"i\000"
	/* gaStringDAYOFWEEK+20 */	"e\000"
	/* gaStringDAYOFWEEK+22 */	"u\000"
	/* gaStringDAYOFWEEK+24 */	"a\000"
	/* gaStringDAYOFWEEK+26 */	"m\000"
	/* gaStringDAYOFWEEK+28 */	"n\000"
	/* gaStringDAYOFWEEK+30 */	"r\000"
	/* gaStringDAYOFWEEK+32 */	"d\000"
	/* gaStringDAYOFWEEK+34 */	"c\000"
	/* gaStringDAYOFWEEK+36 */	"h\000"
;

static const STATE_TRANSITION gaTDAYOFWEEK[] = {
	{gaSDAYOFWEEK+0,	1}, // +0: state 0 transitions
	{gaSDAYOFWEEK+3,	2},
	{gaSDAYOFWEEK+6,	3},
	{gaSDAYOFWEEK+9,	4},
	{gaSDAYOFWEEK+12,	5},
	{gaSDAYOFWEEK+15,	6},
	{gaSDAYOFWEEK+18,	7}, // +6: state 1 transitions
	{gaSDAYOFWEEK+20,	8}, // +7: state 2 transitions
	{gaSDAYOFWEEK+22,	9}, // +8: state 3 transitions
	{gaSDAYOFWEEK+24,	10}, // +9: state 4 transitions
	{gaSDAYOFWEEK+20,	11},
	{gaSDAYOFWEEK+24,	12}, // +11: state 5 transitions
	{gaSDAYOFWEEK+20,	13}, // +12: state 6 transitions
	{gaSDAYOFWEEK+26,	14}, // +13: state 7 transitions
	{gaSDAYOFWEEK+22,	15}, // +14: state 8 transitions
	{gaSDAYOFWEEK+28,	15}, // +15: state 9 transitions
	{gaSDAYOFWEEK+30,	15}, // +16: state 10 transitions
	{gaSDAYOFWEEK+30,	16}, // +17: state 11 transitions
	{gaSDAYOFWEEK+26,	17}, // +18: state 12 transitions
	{gaSDAYOFWEEK+28,	18}, // +19: state 13 transitions
	{gaSDAYOFWEEK+24,	19}, // +20: state 14 transitions
	{gaSDAYOFWEEK+32,	20}, // +21: state 15 transitions
	{gaSDAYOFWEEK+34,	21}, // +22: state 16 transitions
	{gaSDAYOFWEEK+20,	15}, // +23: state 17 transitions
	{gaSDAYOFWEEK+32,	21}, // +24: state 18 transitions
	{gaSDAYOFWEEK+28,	22}, // +25: state 19 transitions
	{gaSDAYOFWEEK+18,	23}, // +26: state 20 transitions
	{gaSDAYOFWEEK+30,	17}, // +27: state 21 transitions
	{gaSDAYOFWEEK+34,	24}, // +28: state 22 transitions
	{gaSDAYOFWEEK+36,	25}, // +29: state 24 transitions
	{gaSDAYOFWEEK+20,	23}, // +30: state 25 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFWEEK[26] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 6, gaTDAYOFWEEK+0},
	/*   1 */ {0, 1, gaTDAYOFWEEK+6},
	/*   2 */ {0, 1, gaTDAYOFWEEK+7},
	/*   3 */ {0, 1, gaTDAYOFWEEK+8},
	/*   4 */ {0, 2, gaTDAYOFWEEK+9},
	/*   5 */ {0, 1, gaTDAYOFWEEK+11},
	/*   6 */ {0, 1, gaTDAYOFWEEK+12},
	/*   7 */ {0, 1, gaTDAYOFWEEK+13},
	/*   8 */ {0, 1, gaTDAYOFWEEK+14},
	/*   9 */ {0, 1, gaTDAYOFWEEK+15},
	/*  10 */ {0, 1, gaTDAYOFWEEK+16},
	/*  11 */ {0, 1, gaTDAYOFWEEK+17},
	/*  12 */ {0, 1, gaTDAYOFWEEK+18},
	/*  13 */ {0, 1, gaTDAYOFWEEK+19},
	/*  14 */ {0, 1, gaTDAYOFWEEK+20},
	/*  15 */ {0, 1, gaTDAYOFWEEK+21},
	/*  16 */ {0, 1, gaTDAYOFWEEK+22},
	/*  17 */ {0, 1, gaTDAYOFWEEK+23},
	/*  18 */ {0, 1, gaTDAYOFWEEK+24},
	/*  19 */ {0, 1, gaTDAYOFWEEK+25},
	/*  20 */ {0, 1, gaTDAYOFWEEK+26},
	/*  21 */ {0, 1, gaTDAYOFWEEK+27},
	/*  22 */ {0, 1, gaTDAYOFWEEK+28},
	/*  23 */ {1, 0, NULL},
	/*  24 */ {0, 1, gaTDAYOFWEEK+29},
	/*  25 */ {0, 1, gaTDAYOFWEEK+30},
};

// end of text generated by re2fsa
// text generated by re2fsa at Thu Nov 15 13:56:41 2001

// the input-file of rules:
// Janvier
// Fvrier
// Mars
// Avril
// Mai
// Juin
// Juillet
// Aot
// Septembre
// Octobre
// Novembre
// Dcembre
// janvier
// fvrier
// mars
// avril
// mai
// juin
// juillet
// aot
// septembre
// octobre
// novembre
// dcembre
// jan.
// fv.
// mar.
// avr.
// jui.
// juil.
// ao.
// sep.
// nov.
// dc.
// Jan.
// Fv.
// Mar.
// Avr.
// Jui.
// Juil.
// Ao.
// Sep.
// Nov.
// Dc.

// 41 states

static const unsigned char gaSMONTH[] = 
	/* gaStringMONTH+0 */	"Aa\000"
	/* gaStringMONTH+3 */	"Dd\000"
	/* gaStringMONTH+6 */	"Ff\000"
	/* gaStringMONTH+9 */	"Jj\000"
	/* gaStringMONTH+12 */	"Mm\000"
	/* gaStringMONTH+15 */	"Nn\000"
	/* gaStringMONTH+18 */	"Oo\000"
	/* gaStringMONTH+21 */	"Ss\000"
	/* gaStringMONTH+24 */	"o\000"
	/* gaStringMONTH+26 */	"v\000"
	/* gaStringMONTH+28 */	"\000"
	/* gaStringMONTH+30 */	"a\000"
	/* gaStringMONTH+32 */	"u\000"
	/* gaStringMONTH+34 */	"c\000"
	/* gaStringMONTH+36 */	"e\000"
	/* gaStringMONTH+38 */	"\000"
	/* gaStringMONTH+40 */	"r\000"
	/* gaStringMONTH+42 */	"n\000"
	/* gaStringMONTH+44 */	"i\000"
	/* gaStringMONTH+46 */	"t\000"
	/* gaStringMONTH+48 */	"p\000"
	/* gaStringMONTH+50 */	".t\000"
	/* gaStringMONTH+53 */	".\000"
	/* gaStringMONTH+55 */	".n\000"
	/* gaStringMONTH+58 */	"l\000"
	/* gaStringMONTH+60 */	".s\000"
	/* gaStringMONTH+63 */	"m\000"
	/* gaStringMONTH+65 */	"b\000"
;

static const STATE_TRANSITION gaTMONTH[] = {
	{gaSMONTH+0,	1}, // +0: state 0 transitions
	{gaSMONTH+3,	2},
	{gaSMONTH+6,	3},
	{gaSMONTH+9,	4},
	{gaSMONTH+12,	5},
	{gaSMONTH+15,	6},
	{gaSMONTH+18,	7},
	{gaSMONTH+21,	8},
	{gaSMONTH+24,	9}, // +8: state 1 transitions
	{gaSMONTH+26,	10},
	{gaSMONTH+28,	11}, // +10: state 2 transitions
	{gaSMONTH+28,	12}, // +11: state 3 transitions
	{gaSMONTH+30,	13}, // +12: state 4 transitions
	{gaSMONTH+32,	14},
	{gaSMONTH+30,	15}, // +14: state 5 transitions
	{gaSMONTH+24,	16}, // +15: state 6 transitions
	{gaSMONTH+34,	17}, // +16: state 7 transitions
	{gaSMONTH+36,	18}, // +17: state 8 transitions
	{gaSMONTH+38,	19}, // +18: state 9 transitions
	{gaSMONTH+40,	20}, // +19: state 10 transitions
	{gaSMONTH+34,	21}, // +20: state 11 transitions
	{gaSMONTH+26,	22}, // +21: state 12 transitions
	{gaSMONTH+42,	23}, // +22: state 13 transitions
	{gaSMONTH+44,	24}, // +23: state 14 transitions
	{gaSMONTH+44,	25}, // +24: state 15 transitions
	{gaSMONTH+40,	26},
	{gaSMONTH+26,	21}, // +26: state 16 transitions
	{gaSMONTH+46,	27}, // +27: state 17 transitions
	{gaSMONTH+48,	28}, // +28: state 18 transitions
	{gaSMONTH+50,	25}, // +29: state 19 transitions
	{gaSMONTH+53,	25}, // +30: state 20 transitions
	{gaSMONTH+44,	29},
	{gaSMONTH+53,	25}, // +32: state 21 transitions
	{gaSMONTH+36,	30},
	{gaSMONTH+53,	25}, // +34: state 22 transitions
	{gaSMONTH+40,	31},
	{gaSMONTH+53,	25}, // +36: state 23 transitions
	{gaSMONTH+26,	31},
	{gaSMONTH+55,	25}, // +38: state 24 transitions
	{gaSMONTH+58,	32},
	{gaSMONTH+60,	25}, // +40: state 26 transitions
	{gaSMONTH+24,	33}, // +41: state 27 transitions
	{gaSMONTH+53,	25}, // +42: state 28 transitions
	{gaSMONTH+46,	34},
	{gaSMONTH+58,	25}, // +44: state 29 transitions
	{gaSMONTH+63,	33}, // +45: state 30 transitions
	{gaSMONTH+44,	35}, // +46: state 31 transitions
	{gaSMONTH+53,	25}, // +47: state 32 transitions
	{gaSMONTH+58,	36},
	{gaSMONTH+65,	37}, // +49: state 33 transitions
	{gaSMONTH+36,	30}, // +50: state 34 transitions
	{gaSMONTH+36,	38}, // +51: state 35 transitions
	{gaSMONTH+36,	39}, // +52: state 36 transitions
	{gaSMONTH+40,	40}, // +53: state 37 transitions
	{gaSMONTH+40,	25}, // +54: state 38 transitions
	{gaSMONTH+46,	25}, // +55: state 39 transitions
	{gaSMONTH+36,	25}, // +56: state 40 transitions
};

const STATE_DESCRIPTION aStateDescMONTH[41] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 8, gaTMONTH+0},
	/*   1 */ {0, 2, gaTMONTH+8},
	/*   2 */ {0, 1, gaTMONTH+10},
	/*   3 */ {0, 1, gaTMONTH+11},
	/*   4 */ {0, 2, gaTMONTH+12},
	/*   5 */ {0, 1, gaTMONTH+14},
	/*   6 */ {0, 1, gaTMONTH+15},
	/*   7 */ {0, 1, gaTMONTH+16},
	/*   8 */ {0, 1, gaTMONTH+17},
	/*   9 */ {0, 1, gaTMONTH+18},
	/*  10 */ {0, 1, gaTMONTH+19},
	/*  11 */ {0, 1, gaTMONTH+20},
	/*  12 */ {0, 1, gaTMONTH+21},
	/*  13 */ {0, 1, gaTMONTH+22},
	/*  14 */ {0, 1, gaTMONTH+23},
	/*  15 */ {0, 2, gaTMONTH+24},
	/*  16 */ {0, 1, gaTMONTH+26},
	/*  17 */ {0, 1, gaTMONTH+27},
	/*  18 */ {0, 1, gaTMONTH+28},
	/*  19 */ {0, 1, gaTMONTH+29},
	/*  20 */ {0, 2, gaTMONTH+30},
	/*  21 */ {0, 2, gaTMONTH+32},
	/*  22 */ {0, 2, gaTMONTH+34},
	/*  23 */ {0, 2, gaTMONTH+36},
	/*  24 */ {0, 2, gaTMONTH+38},
	/*  25 */ {1, 0, NULL},
	/*  26 */ {0, 1, gaTMONTH+40},
	/*  27 */ {0, 1, gaTMONTH+41},
	/*  28 */ {0, 2, gaTMONTH+42},
	/*  29 */ {0, 1, gaTMONTH+44},
	/*  30 */ {0, 1, gaTMONTH+45},
	/*  31 */ {0, 1, gaTMONTH+46},
	/*  32 */ {0, 2, gaTMONTH+47},
	/*  33 */ {0, 1, gaTMONTH+49},
	/*  34 */ {0, 1, gaTMONTH+50},
	/*  35 */ {0, 1, gaTMONTH+51},
	/*  36 */ {0, 1, gaTMONTH+52},
	/*  37 */ {0, 1, gaTMONTH+53},
	/*  38 */ {0, 1, gaTMONTH+54},
	/*  39 */ {0, 1, gaTMONTH+55},
	/*  40 */ {0, 1, gaTMONTH+56},
};

// end of text generated by re2fsa
// text generated by re2fsa at Thu Nov 15 15:04:10 2001

// the input-file of rules:
// mle
// femelle
// Mle
// Femelle
// H
// F
// h
// f

// 9 states

static const unsigned char gaSGENDER[] = 
	/* gaStringGENDER+0 */	"Ff\000"
	/* gaStringGENDER+3 */	"Hh\000"
	/* gaStringGENDER+6 */	"Mm\000"
	/* gaStringGENDER+9 */	"e\000"
	/* gaStringGENDER+11 */	"\000"
	/* gaStringGENDER+13 */	"m\000"
	/* gaStringGENDER+15 */	"l\000"
;

static const STATE_TRANSITION gaTGENDER[] = {
	{gaSGENDER+0,	1}, // +0: state 0 transitions
	{gaSGENDER+3,	2},
	{gaSGENDER+6,	3},
	{gaSGENDER+9,	4}, // +3: state 1 transitions
	{gaSGENDER+11,	5}, // +4: state 3 transitions
	{gaSGENDER+13,	6}, // +5: state 4 transitions
	{gaSGENDER+15,	7}, // +6: state 5 transitions
	{gaSGENDER+9,	8}, // +7: state 6 transitions
	{gaSGENDER+9,	2}, // +8: state 7 transitions
	{gaSGENDER+15,	5}, // +9: state 8 transitions
};

const STATE_DESCRIPTION aStateDescGENDER[9] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTGENDER+0},
	/*   1 */ {1, 1, gaTGENDER+3},
	/*   2 */ {1, 0, NULL},
	/*   3 */ {0, 1, gaTGENDER+4},
	/*   4 */ {0, 1, gaTGENDER+5},
	/*   5 */ {0, 1, gaTGENDER+6},
	/*   6 */ {0, 1, gaTGENDER+7},
	/*   7 */ {0, 1, gaTGENDER+8},
	/*   8 */ {0, 1, gaTGENDER+9},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\fra\tpunc.c ===
#include "common.h"
#include "tpunc.h"

// text generated by re2fsa at Wed Dec 12 08:42:25 2001

// the input-file of rules:
// T = DQ ;
// T = CH  ;
// T = t ;
// T = DQ t ;
// T = CH t ;
// T = t DQ  ;
// T = t CH ;
// T = SQ  ;
// T = SQ t ;
// T = t SQ  ;
// T = SQ DQ  ;
// T = SQ CH ;
// T = t SQ DQ ;
// T = t SQ CH  ;
// T = SQ DQ t ;
// T = SQ CH t ;
// T = DQ SQ  ;
// T = CH SQ ;
// T = t DQ SQ  ;
// T = t CH SQ ;
// T = DQ SQ t ;
// T = CH SQ t ;
// T = rparen DQ dot  ;
// T = rparen CH dot  ;
// T = rparen SQ dot  ;
// t = comma  ;
// t = dot  ;
// t = dot dot dot  ;
// t = dot dot dot dot  ;
// t = colon  ;
// t = semicolon  ;
// t = question  ;
// t = question questionNS  ;
// t = question questionNS questionNS ;
// t = exclamation  ;
// t = exclamation exclamationNS ;
// t = exclamation exclamationNS exclamationNS ;
// t = rparen  ;
// t = rparen comma  ;
// t = rparen dot  ;
// t = rparen colon  ;
// t = rparen semicolon  ;
// t = rparen question  ;
// t = rparen question questionNS  ;
// t = rparen question questionNS questionNS ;
// t = rparen exclamation  ;
// t = rparen exclamation exclamationNS ;
// t = rparen exclamation exclamationNS exclamationNS ;
// t = rparen rparen  ;
// t = rparen rparen comma  ;
// t = rparen rparen dot  ;
// t = rparen rparen colon  ;
// t = rparen rparen semicolon  ;
// t = rparen rparen question  ;
// t = rparen rparen question questionNS  ;
// t = rparen rparen question questionNS questionNS ;
// t = rparen rparen exclamation  ;
// t = rparen rparen exclamation exclamationNS ;
// t = rparen rparen exclamation exclamationNS exclamationNS ;
// t = comma rparen  ;
// t = dot rparen  ;
// t = colon rparen  ;
// t = semicolon rparen  ;
// t = question rparen  ;
// t = question questionNS rparen  ;
// t = question questionNS questionNS rparen  ;
// t = exclamation rparen  ;
// t = exclamation exclamationNS rparen  ;
// t = exclamation exclamationNS exclamationNS rparen  ;
// t = dot dot dot rparen  ;
// t = rbracket  ;
// t = rbracket comma  ;
// t = rbracket dot  ;
// t = rbracket colon  ;
// t = rbracket semicolon  ;
// t = rbracket question  ;
// t = rbracket question questionNS  ;
// t = rbracket question questionNS questionNS ;
// t = rbracket exclamation  ;
// t = rbracket exclamation exclamationNS ;
// t = rbracket exclamation exclamationNS exclamationNS ;
// t = rbrace  ;
// t = rbrace comma  ;
// t = rbrace dot  ;
// t = rbrace colon  ;
// t = rbrace semicolon  ;
// t = rbrace question  ;
// t = rbrace question questionNS  ;
// t = rbrace question questionNS questionNS ;
// t = rbrace exclamation  ;
// t = rbrace exclamationNS exclamationNS  ;
// t = rbrace exclamation exclamationNS exclamationNS ;
// t = "*" ["*" ["*"]] ;
// t = "/" ;
// t = "." "." "." ;
// space = " " ;
// DQ = "\"" ;
// SQ = "'" ;
// CH = space "" ;
// rparen = ")" ;
// dot = "." ;
// comma = "," ;
// colon =  space ":" ;
// semicolon =  space ";" ;
// question =  space "?" ;
// exclamation =  space "!" ;
// questionNS = "?" ;
// exclamationNS = "!" ;
// rbracket = "]" ;
// rbrace = "}" ;
// 
// = T ;

// 58 states

static const unsigned char gaSTPUNC[] = 
	/* gaStringTPUNC+0 */	" \000"
	/* gaStringTPUNC+2 */	"\"\000"
	/* gaStringTPUNC+4 */	"'\000"
	/* gaStringTPUNC+6 */	")\000"
	/* gaStringTPUNC+8 */	"*\000"
	/* gaStringTPUNC+10 */	",\000"
	/* gaStringTPUNC+12 */	".\000"
	/* gaStringTPUNC+14 */	"/\000"
	/* gaStringTPUNC+16 */	"]\000"
	/* gaStringTPUNC+18 */	"}\000"
	/* gaStringTPUNC+20 */	"\000"
	/* gaStringTPUNC+22 */	":;\000"
	/* gaStringTPUNC+25 */	"!\000"
	/* gaStringTPUNC+27 */	"?\000"
	/* gaStringTPUNC+29 */	",.\000"
	/* gaStringTPUNC+32 */	"'.\000"
	/* gaStringTPUNC+35 */	"\".\000"
	/* gaStringTPUNC+38 */	").\000"
;

static const STATE_TRANSITION gaTTPUNC[] = {
	{gaSTPUNC+0,	1}, // +0: state 0 transitions
	{gaSTPUNC+2,	2},
	{gaSTPUNC+4,	3},
	{gaSTPUNC+6,	4},
	{gaSTPUNC+8,	5},
	{gaSTPUNC+10,	6},
	{gaSTPUNC+12,	7},
	{gaSTPUNC+14,	8},
	{gaSTPUNC+16,	9},
	{gaSTPUNC+18,	10},
	{gaSTPUNC+20,	2}, // +10: state 1 transitions
	{gaSTPUNC+22,	6},
	{gaSTPUNC+25,	11},
	{gaSTPUNC+27,	12},
	{gaSTPUNC+0,	13}, // +14: state 2 transitions
	{gaSTPUNC+4,	14},
	{gaSTPUNC+6,	15},
	{gaSTPUNC+8,	16},
	{gaSTPUNC+10,	17},
	{gaSTPUNC+12,	18},
	{gaSTPUNC+14,	19},
	{gaSTPUNC+16,	20},
	{gaSTPUNC+18,	21},
	{gaSTPUNC+2,	14}, // +23: state 3 transitions
	{gaSTPUNC+6,	15},
	{gaSTPUNC+8,	16},
	{gaSTPUNC+10,	17},
	{gaSTPUNC+12,	18},
	{gaSTPUNC+14,	19},
	{gaSTPUNC+16,	20},
	{gaSTPUNC+18,	21},
	{gaSTPUNC+0,	22},
	{gaSTPUNC+29,	8}, // +32: state 4 transitions
	{gaSTPUNC+6,	9},
	{gaSTPUNC+0,	23},
	{gaSTPUNC+2,	24},
	{gaSTPUNC+4,	25},
	{gaSTPUNC+0,	26}, // +37: state 5 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+8,	29},
	{gaSTPUNC+6,	8}, // +41: state 6 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+6,	8}, // +45: state 7 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+12,	30},
	{gaSTPUNC+0,	26}, // +50: state 8 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+29,	8}, // +53: state 9 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+0,	31},
	{gaSTPUNC+29,	8}, // +57: state 10 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+0,	32},
	{gaSTPUNC+25,	33},
	{gaSTPUNC+6,	8}, // +62: state 11 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+25,	34},
	{gaSTPUNC+6,	8}, // +67: state 12 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+27,	35},
	{gaSTPUNC+22,	17}, // +72: state 13 transitions
	{gaSTPUNC+25,	36},
	{gaSTPUNC+27,	37},
	{gaSTPUNC+0,	13}, // +75: state 14 transitions
	{gaSTPUNC+6,	15},
	{gaSTPUNC+8,	16},
	{gaSTPUNC+10,	17},
	{gaSTPUNC+12,	18},
	{gaSTPUNC+14,	19},
	{gaSTPUNC+16,	20},
	{gaSTPUNC+18,	21},
	{gaSTPUNC+29,	19}, // +83: state 15 transitions
	{gaSTPUNC+6,	20},
	{gaSTPUNC+0,	38},
	{gaSTPUNC+8,	39}, // +86: state 16 transitions
	{gaSTPUNC+6,	19}, // +87: state 17 transitions
	{gaSTPUNC+6,	19}, // +88: state 18 transitions
	{gaSTPUNC+12,	40},
	{gaSTPUNC+29,	19}, // +90: state 20 transitions
	{gaSTPUNC+0,	38},
	{gaSTPUNC+29,	19}, // +92: state 21 transitions
	{gaSTPUNC+0,	41},
	{gaSTPUNC+25,	42},
	{gaSTPUNC+20,	14}, // +95: state 22 transitions
	{gaSTPUNC+22,	17},
	{gaSTPUNC+25,	36},
	{gaSTPUNC+27,	37},
	{gaSTPUNC+22,	8}, // +99: state 23 transitions
	{gaSTPUNC+20,	24},
	{gaSTPUNC+25,	43},
	{gaSTPUNC+27,	44},
	{gaSTPUNC+32,	19}, // +103: state 24 transitions
	{gaSTPUNC+35,	19}, // +104: state 25 transitions
	{gaSTPUNC+0,	45},
	{gaSTPUNC+20,	27}, // +106: state 26 transitions
	{gaSTPUNC+4,	19}, // +107: state 27 transitions
	{gaSTPUNC+2,	19}, // +108: state 28 transitions
	{gaSTPUNC+0,	45},
	{gaSTPUNC+8,	8}, // +110: state 29 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+12,	46}, // +114: state 30 transitions
	{gaSTPUNC+22,	8}, // +115: state 31 transitions
	{gaSTPUNC+20,	27},
	{gaSTPUNC+25,	43},
	{gaSTPUNC+27,	44},
	{gaSTPUNC+22,	8}, // +119: state 32 transitions
	{gaSTPUNC+20,	27},
	{gaSTPUNC+27,	44},
	{gaSTPUNC+25,	47},
	{gaSTPUNC+25,	8}, // +123: state 33 transitions
	{gaSTPUNC+25,	6}, // +124: state 34 transitions
	{gaSTPUNC+6,	8},
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+27,	6}, // +129: state 35 transitions
	{gaSTPUNC+6,	8},
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+6,	19}, // +134: state 36 transitions
	{gaSTPUNC+25,	48},
	{gaSTPUNC+6,	19}, // +136: state 37 transitions
	{gaSTPUNC+27,	49},
	{gaSTPUNC+22,	19}, // +138: state 38 transitions
	{gaSTPUNC+25,	50},
	{gaSTPUNC+27,	51},
	{gaSTPUNC+8,	19}, // +141: state 39 transitions
	{gaSTPUNC+12,	52}, // +142: state 40 transitions
	{gaSTPUNC+22,	19}, // +143: state 41 transitions
	{gaSTPUNC+27,	51},
	{gaSTPUNC+25,	53},
	{gaSTPUNC+25,	19}, // +146: state 42 transitions
	{gaSTPUNC+0,	26}, // +147: state 43 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+25,	54},
	{gaSTPUNC+0,	26}, // +151: state 44 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+27,	55},
	{gaSTPUNC+20,	19}, // +155: state 45 transitions
	{gaSTPUNC+38,	8}, // +156: state 46 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+0,	26}, // +160: state 47 transitions
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+25,	33},
	{gaSTPUNC+25,	17}, // +164: state 48 transitions
	{gaSTPUNC+6,	19},
	{gaSTPUNC+27,	17}, // +166: state 49 transitions
	{gaSTPUNC+6,	19},
	{gaSTPUNC+25,	56}, // +168: state 50 transitions
	{gaSTPUNC+27,	57}, // +169: state 51 transitions
	{gaSTPUNC+38,	19}, // +170: state 52 transitions
	{gaSTPUNC+25,	42}, // +171: state 53 transitions
	{gaSTPUNC+25,	8}, // +172: state 54 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+27,	8}, // +176: state 55 transitions
	{gaSTPUNC+0,	26},
	{gaSTPUNC+2,	27},
	{gaSTPUNC+4,	28},
	{gaSTPUNC+25,	19}, // +180: state 56 transitions
	{gaSTPUNC+27,	19}, // +181: state 57 transitions
};

const STATE_DESCRIPTION aStateDescTPUNC[58] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 10, gaTTPUNC+0},
	/*   1 */ {0, 4, gaTTPUNC+10},
	/*   2 */ {1, 9, gaTTPUNC+14},
	/*   3 */ {1, 9, gaTTPUNC+23},
	/*   4 */ {1, 5, gaTTPUNC+32},
	/*   5 */ {1, 4, gaTTPUNC+37},
	/*   6 */ {1, 4, gaTTPUNC+41},
	/*   7 */ {1, 5, gaTTPUNC+45},
	/*   8 */ {1, 3, gaTTPUNC+50},
	/*   9 */ {1, 4, gaTTPUNC+53},
	/*  10 */ {1, 5, gaTTPUNC+57},
	/*  11 */ {1, 5, gaTTPUNC+62},
	/*  12 */ {1, 5, gaTTPUNC+67},
	/*  13 */ {0, 3, gaTTPUNC+72},
	/*  14 */ {1, 8, gaTTPUNC+75},
	/*  15 */ {1, 3, gaTTPUNC+83},
	/*  16 */ {1, 1, gaTTPUNC+86},
	/*  17 */ {1, 1, gaTTPUNC+87},
	/*  18 */ {1, 2, gaTTPUNC+88},
	/*  19 */ {1, 0, NULL},
	/*  20 */ {1, 2, gaTTPUNC+90},
	/*  21 */ {1, 3, gaTTPUNC+92},
	/*  22 */ {0, 4, gaTTPUNC+95},
	/*  23 */ {0, 4, gaTTPUNC+99},
	/*  24 */ {1, 1, gaTTPUNC+103},
	/*  25 */ {1, 2, gaTTPUNC+104},
	/*  26 */ {0, 1, gaTTPUNC+106},
	/*  27 */ {1, 1, gaTTPUNC+107},
	/*  28 */ {1, 2, gaTTPUNC+108},
	/*  29 */ {1, 4, gaTTPUNC+110},
	/*  30 */ {0, 1, gaTTPUNC+114},
	/*  31 */ {0, 4, gaTTPUNC+115},
	/*  32 */ {0, 4, gaTTPUNC+119},
	/*  33 */ {0, 1, gaTTPUNC+123},
	/*  34 */ {1, 5, gaTTPUNC+124},
	/*  35 */ {1, 5, gaTTPUNC+129},
	/*  36 */ {1, 2, gaTTPUNC+134},
	/*  37 */ {1, 2, gaTTPUNC+136},
	/*  38 */ {0, 3, gaTTPUNC+138},
	/*  39 */ {1, 1, gaTTPUNC+141},
	/*  40 */ {0, 1, gaTTPUNC+142},
	/*  41 */ {0, 3, gaTTPUNC+143},
	/*  42 */ {0, 1, gaTTPUNC+146},
	/*  43 */ {1, 4, gaTTPUNC+147},
	/*  44 */ {1, 4, gaTTPUNC+151},
	/*  45 */ {0, 1, gaTTPUNC+155},
	/*  46 */ {1, 4, gaTTPUNC+156},
	/*  47 */ {1, 4, gaTTPUNC+160},
	/*  48 */ {1, 2, gaTTPUNC+164},
	/*  49 */ {1, 2, gaTTPUNC+166},
	/*  50 */ {1, 1, gaTTPUNC+168},
	/*  51 */ {1, 1, gaTTPUNC+169},
	/*  52 */ {1, 1, gaTTPUNC+170},
	/*  53 */ {1, 1, gaTTPUNC+171},
	/*  54 */ {1, 4, gaTTPUNC+172},
	/*  55 */ {1, 4, gaTTPUNC+176},
	/*  56 */ {1, 1, gaTTPUNC+180},
	/*  57 */ {1, 1, gaTTPUNC+181},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\charcost.h ===
// charcost.h
// March 11, 1999
// Angshuman Guha,  aguha

// Language specific tuning constants which help with word breaking decisions in beam.c

// 1) Maximum overlap of strokes within a wordgap
#define MAX_STROKE_OVERLAP (5)

// 2) Tuning factor that turns for space node Cost (numerator and denominator)
#define IS_SPACE_NUM	(5)
#define IS_SPACE_DEN	(2)

// 3) Tuning factor  for Not space cost
#define NOT_SPACE_NUM	(5)
#define NOT_SPACE_DEN	(3)

// 4) Tuning factor to for allowing a 'Factoid Space' based on space output
#define FACTOID_SPACE_FUDGE		(90)

#define INFINITY_COST 999999999

#define NetContActivation(aActivations, ch) (ContinueChar2Out(ch) < 255 ? aActivations[ContinueChar2Out(ch)]: ZERO_PROB_COST*4)
#define NetFirstActivation(aActivations, ch) aActivations[BeginChar2Out(ch)]

// Macros that work on the activation state index
#define IsOutputBeginAct(si) (IsOutputBegin(si))
#define Out2CharAct(si) (Out2Char(si))
#define BeginChar2OutAct(si) (BeginChar2Out(si))

void InitColumn(int * aActivations, const REAL *pAct);
void ComputeCharacterProbs(const REAL *pActivation, int cSegments, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\charcost.c ===
// charcost.c
// created by extracting code from beam.c
// March 11, 1999
// Angshuman Guha,  aguha

#include <limits.h>
#include "common.h"
#include "charmap.h"
#include "infernop.h"
#include "nnet.h"
#include "probcost.h"

// Global data containing the log probs of the neural network outputs, for the
// current column.
// NetContActivation() and NetFirstActivation() are macros for fetching the 2 log-probs
// associated with a particular letter.

// Initializes the log-probs of the neural network outputs in the current column,
// and recomputes the best drops for this column.

void InitColumn(int *aActivations, const REAL *pAct)
{
	int c;

	for (c = gcOutputNode; c; c--, pAct++, aActivations++)
	{
		*aActivations = PROB_TO_COST(*pAct);
	}

}

void ComputeCharacterProbs(const REAL *pActivation, int cSegment, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong)
{
	int row, col;
	unsigned char thisChar;
	const int ShortWidth = 4;
	const int LongWidth = 7;

	// short window
	memset(aCharProb, 0, 256*sizeof(REAL));
	memset(aCharBeginProb, 0, 256*sizeof(REAL));
	col = cSegment;
	if (col > ShortWidth)
		col = ShortWidth;
	for (; col; col--)
	{
		for (row=0; row<gcOutputNode; row++, pActivation++)
		{
			thisChar = Out2Char(row);
			if (*pActivation > aCharProb[thisChar])
				aCharProb[thisChar] = *pActivation;
			if (IsOutputBegin(row))
			{
				if (*pActivation > aCharBeginProb[thisChar])
					aCharBeginProb[thisChar] = *pActivation;
			}
		}
	}

	// long window
	if (!aCharProbLong || !aCharBeginProbLong)
		return;
	memcpy(aCharProbLong, aCharProb, 256*sizeof(REAL));
	memcpy(aCharBeginProbLong, aCharBeginProb, 256*sizeof(REAL));

	col = cSegment - ShortWidth;
	if (col <= 0)
		return;
	if (col > LongWidth - ShortWidth)
		col = LongWidth - ShortWidth;
	for (; col; col--)
	{
		for (row=0; row<gcOutputNode; row++, pActivation++)
		{
			thisChar = Out2Char(row);
			if (*pActivation > aCharProbLong[thisChar])
				aCharProbLong[thisChar] = *pActivation;
			if (IsOutputBegin(row))
			{
				if (*pActivation > aCharBeginProbLong[thisChar])
					aCharBeginProbLong[thisChar] = *pActivation;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\lpunc.h ===
// lpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_LPUNC_H
#define __INC_LPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescLPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\charmap.h ===
// charmap.h
// Angshuman Guha, aguha
// Jan 12, 1999

#ifndef __CHARMAP_H
#define __CHARMAP_H

#ifdef __cplusplus
extern "C" {
#endif

// Maximum number of character activations, (ie begin and continuation activation) supported by the
// recognizer
#define C_CHAR_ACTIVATIONS		gcOutputNode

//BYTE BeginChar2Out(char);
//BYTE ContinueChar2Out(char);

extern const BYTE rgCharToOutputNode[];
extern const unsigned char rgOutputNodeToChar[];

#define BeginChar2Out(ch) rgCharToOutputNode[2*((unsigned char)(ch))]
#define ContinueChar2Out(ch) rgCharToOutputNode[2*((unsigned char)(ch))+1]

#define IsSupportedChar(ch) (BeginChar2Out(ch) < 0xFF)

#define Out2Char(i) rgOutputNodeToChar[2*(i)+1]
#define IsOutputBegin(i) rgOutputNodeToChar[2*(i)]

// There are no virtual chars in UK at this moment
#define IsVirtualChar(ch)		(0)
#define BaseVirtualChar(ch)		(255)
#define AccentVirtualChar(ch)	(255)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\charmap.c ===
// charmap.c
// Angshuman Guha, aguha
// Jan 12, 1999
// Modified June 5, 2000: added  and euro, deleted a whole bunch of "continue" nodes

#include "common.h"
#include "charmap.h"

#define COUTPUT 175

const BYTE rgCharToOutputNode[2*256] = {
	// the first number is the beginning-activation node
	// the second number is the continuing-activation node
	// the value 255 means there is no output node
	// Of the 95 printable ASCII, the following don't have a continuing-activation node
	//		space ' ( ) , - . / < > [ \ ] ^ _ ` { | } 
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	  0, 255, // space
	  5,   6, // ! 
	 11,  12, // " 
	 27,  28, // # 
	  7,   8, // $ 
	 29,  30, // % 
	 31,  32, // & 
	  9, 255, // ' 
	 13, 255, // ( 
	 14, 255, // ) 
	 33,  34, // * 
	 35,  36, // + 
	  2, 255, // , 
	 15, 255, // - 
	  1, 255, // . 
	 21, 255, // / 
	 51,  52, // 0 
	 53,  54, // 1 
	 55,  56, // 2 
	 57,  58, // 3 
	 59,  60, // 4 
	 61,  62, // 5 
	 63,  64, // 6 
	 65,  66, // 7 
	 67,  68, // 8 
	 69,  70, // 9 
	 17,  18, // : 
	 19,  20, // ; 
	 37, 255, // < 
	 38,  39, // = 
	 40, 255, // > 
	  3,   4, // ? 
	 41,  42, // @ 
	123, 124, // A 
	125, 126, // B 
	127, 128, // C 
	129, 130, // D 
	131, 132, // E 
	133, 134, // F 
	135, 136, // G 
	137, 138, // H 
	139, 140, // I 
	141, 142, // J 
	143, 144, // K 
	145, 146, // L 
	147, 148, // M 
	149, 150, // N 
	151, 152, // O 
	153, 154, // P 
	155, 156, // Q 
	157, 158, // R 
	159, 160, // S 
	161, 162, // T 
	163, 164, // U 
	165, 166, // V 
	167, 168, // W 
	169, 170, // X 
	171, 172, // Y 
	173, 174, // Z 
	 43, 255, // [ 
	 22, 255, // \ 
	 44, 255, // ] 
	 45, 255, // ^ 
	 16, 255, // _ 
	 10, 255, // ` 
	 71,  72, // a 
	 73,  74, // b 
	 75,  76, // c 
	 77,  78, // d 
	 79,  80, // e 
	 81,  82, // f 
	 83,  84, // g 
	 85,  86, // h 
	 87,  88, // i 
	 89,  90, // j 
	 91,  92, // k 
	 93,  94, // l 
	 95,  96, // m 
	 97,  98, // n 
	 99, 100, // o 
	101, 102, // p 
	103, 104, // q 
	105, 106, // r 
	107, 108, // s 
	109, 110, // t 
	111, 112, // u 
	113, 114, // v 
	115, 116, // w 
	117, 118, // x 
	119, 120, // y 
	121, 122, // z 
	 46, 255, // { 
	 47, 255, // | 
	 48, 255, // } 
	 49,  50, // ~ 
	255, 255,
	 25,  26, // euro
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	  0, 255, // NBSP maps to space
	255, 255,
	255, 255,
	 23,  24, //  
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
	255, 255,
};

const unsigned char rgOutputNodeToChar[2*COUTPUT] = {
	// the first number is 0 for char-continuation node, 1 for char-beginning node
	// the second number is the character

	// space
	1, ' ', // 0

	// common punc
	1, '.', // 1
	1, ',', // 2
	1, '?', // 3
	0, '?', // 4
	1, '!', // 5
	0, '!', // 6
	1, '$', // 7
	0, '$', // 8
	1, '\'',// 9
	1, '`', // 10
	1, '"', // 11
	0, '"', // 12
	1, '(', // 13
	1, ')', // 14
	1, '-', // 15
	1, '_', // 16
	1, ':', // 17
	0, ':', // 18
	1, ';', // 19
	0, ';', // 20
	1, '/', // 21
	1, '\\',// 22
	1, '', // 23
	0, '', // 24
	1, '', // 25 euro
	0, '', // 26 euro

	// rare punc
	1, '#', // 27
	0, '#', // 28
	1, '%', // 29
	0, '%', // 30
	1, '&', // 31
	0, '&', // 32
	1, '*', // 33
	0, '*', // 34
	1, '+', // 35
	0, '+', // 36
	1, '<', // 37
	1, '=', // 38
	0, '=', // 39
	1, '>', // 40
	1, '@', // 41
	0, '@', // 42
	1, '[', // 43
	1, ']', // 44
	1, '^', // 45
	1, '{', // 46
	1, '|', // 47
	1, '}', // 48
	1, '~', // 49
	0, '~', // 50

	// digits
	1, '0', // 51
	0, '0', // 52
	1, '1', // 53
	0, '1', // 54
	1, '2', // 55
	0, '2', // 56
	1, '3', // 57
	0, '3', // 58
	1, '4', // 59
	0, '4', // 60
	1, '5', // 61
	0, '5', // 62
	1, '6', // 63
	0, '6', // 64
	1, '7', // 65
	0, '7', // 66
	1, '8', // 67
	0, '8', // 68
	1, '9', // 69
	0, '9', // 70

	// lowercase alphabets
	1, 'a', // 71
	0, 'a', // 72
	1, 'b', // 73
	0, 'b', // 74
	1, 'c', // 75
	0, 'c', // 76
	1, 'd', // 77
	0, 'd', // 78
	1, 'e', // 79
	0, 'e', // 80
	1, 'f', // 81
	0, 'f', // 82
	1, 'g', // 83
	0, 'g', // 84
	1, 'h', // 85
	0, 'h', // 86
	1, 'i', // 87
	0, 'i', // 88
	1, 'j', // 89
	0, 'j', // 90
	1, 'k', // 91
	0, 'k', // 92
	1, 'l', // 93
	0, 'l', // 94
	1, 'm', // 95
	0, 'm', // 96
	1, 'n', // 97
	0, 'n', // 98
	1, 'o', // 99
	0, 'o', // 100
	1, 'p', // 101
	0, 'p', // 102
	1, 'q', // 103
	0, 'q', // 104
	1, 'r', // 105
	0, 'r', // 106
	1, 's', // 107
	0, 's', // 108
	1, 't', // 109
	0, 't', // 110
	1, 'u', // 111
	0, 'u', // 112
	1, 'v', // 113
	0, 'v', // 114
	1, 'w', // 115
	0, 'w', // 116
	1, 'x', // 117
	0, 'x', // 118
	1, 'y', // 119
	0, 'y', // 120
	1, 'z', // 121
	0, 'z', // 122

	// uppercase alphabets
	1, 'A', // 123
	0, 'A', // 124
	1, 'B', // 125
	0, 'B', // 126
	1, 'C', // 127
	0, 'C', // 128
	1, 'D', // 129
	0, 'D', // 130
	1, 'E', // 131
	0, 'E', // 132
	1, 'F', // 133
	0, 'F', // 134
	1, 'G', // 135
	0, 'G', // 136
	1, 'H', // 137
	0, 'H', // 138
	1, 'I', // 139
	0, 'I', // 140
	1, 'J', // 141
	0, 'J', // 142
	1, 'K', // 143
	0, 'K', // 144
	1, 'L', // 145
	0, 'L', // 146
	1, 'M', // 147
	0, 'M', // 148
	1, 'N', // 149
	0, 'N', // 150
	1, 'O', // 151
	0, 'O', // 152
	1, 'P', // 153
	0, 'P', // 154
	1, 'Q', // 155
	0, 'Q', // 156
	1, 'R', // 157
	0, 'R', // 158
	1, 'S', // 159
	0, 'S', // 160
	1, 'T', // 161
	0, 'T', // 162
	1, 'U', // 163
	0, 'U', // 164
	1, 'V', // 165
	0, 'V', // 166
	1, 'W', // 167
	0, 'W', // 168
	1, 'X', // 169
	0, 'X', // 170
	1, 'Y', // 171
	0, 'Y', // 172
	1, 'Z', // 173
	0, 'Z'  // 174
};

/*
BYTE BeginChar2Out(char ch)
{
	BYTE x;

	x = rgCharToOutputNode[2*(ch)];
	ASSERT(x < COUTPUT);
	return x;
}

BYTE ContinueChar2Out(char ch)
{
	BYTE x;

	x = rgCharToOutputNode[2*(ch)+1];
	ASSERT(x < COUTPUT);
	return x;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\prefix.c ===
// prefix.c
// Angshuman Guha
// aguha
// April 17, 2001

#include "common.h"
#include "prefix.h"

const STATE_DESCRIPTION *aStateDescPrefix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\fforward.h ===
void FeedForward(FFINFO *ffinfo);
//BOOL FeedForwardNoSpace(NFEATURESET *nfeatureset, REAL *NeuralOutput);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\prefix.h ===
// prefix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_PREFIX_H
#define __INC_PREFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescPrefix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\nnet.c ===
// nnet.c

#include <common.h>

#include "nnet.h"
#include "nnet.ci"

#include "snet.h"
#include "snet.ci"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\nnet.h ===
// nnet.h
// computed from <1130.net,mixed.ist> (45000000) by net2c at Mon Jun 25 14:48:30 2001
#ifndef __INC_NNET_H
#define __INC_NNET_H

// Time Stamp
#define NET_TIME_STAMP	0x3b37b1ad

// Type definitions

typedef short INP_HID_WEIGHT;
typedef short HID_BIAS;
typedef char HID_OUT_WEIGHT;
typedef short OUT_BIAS;
//typedef unsigned short INP_BIAS;


// Hidden Layer
#define gcHiddenNode 150
#define gcHiddenWeightHeight 37
#define gcHiddenWeightWidth 3
extern int giHiddenScale;
extern ROMMABLE  INP_HID_WEIGHT grgHiddenWeight[gcHiddenNode*gcHiddenWeightHeight*gcHiddenWeightWidth];
extern ROMMABLE  HID_BIAS grgHiddenBias[gcHiddenNode];


// Output Layer
#define gcOutputNode 175
#define gcOutputWeightHeight 150
#define gcOutputWeightWidth 3
extern int giOutputScale;
extern ROMMABLE  HID_OUT_WEIGHT grgOutputWeight[gcOutputNode*gcOutputWeightHeight*gcOutputWeightWidth];
extern ROMMABLE  OUT_BIAS grgOutputBias[gcOutputNode];


// Input Layer
//extern ROMMABLE INP_BIAS grgInputBias[gcHiddenWeightHeight];

#endif // __INC_NNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\lpunc.c ===
// lpunc.c (leading punctuation)
// Angshuman Guha
// aguha
// Nov 15, 2000

#include "common.h"
#include "lpunc.h"

// text generated by re2fsa at Fri Feb 02 15:35:36 2001

// the input-file of rules:
// L = DQ
// L = l
// L = DQ l
// L = l DQ
// L = SQ
// L = SQ l
// L = l SQ
// L = SQ DQ
// L = DQ SQ
// L = BQ
// L = BQ l
// L = l BQ
// L = BQ DQ
// L = DQ BQ
// # L''
// # L''l
// # Ll''
// # L``
// # L``l
// # Ll``
// l = "("
// l = "["
// l = "{"
// l = "-"
// l = "." "." "."
// l = "*" ["*" ["*"]]
// DQ = "\""
// SQ = "'"
// BQ = "`"
// = L

// 13 states

static const unsigned char gaSLPUNC[] = 
	/* gaStringLPUNC+0 */	".\000"
	/* gaStringLPUNC+2 */	"\"\000"
	/* gaStringLPUNC+4 */	"'`\000"
	/* gaStringLPUNC+7 */	"(-[{\000"
	/* gaStringLPUNC+12 */	"*\000"
	/* gaStringLPUNC+14 */	"'(-[`{\000"
	/* gaStringLPUNC+21 */	"\"(-[{\000"
	/* gaStringLPUNC+27 */	"\"'`\000"
;

static const STATE_TRANSITION gaTLPUNC[] = {
	{gaSLPUNC+0,	1}, // +0: state 0 transitions
	{gaSLPUNC+2,	5},
	{gaSLPUNC+4,	6},
	{gaSLPUNC+7,	7},
	{gaSLPUNC+12,	8},
	{gaSLPUNC+0,	4}, // +5: state 1 transitions
	{gaSLPUNC+0,	3}, // +6: state 2 transitions
	{gaSLPUNC+0,	10}, // +7: state 3 transitions
	{gaSLPUNC+0,	7}, // +8: state 4 transitions
	{gaSLPUNC+0,	2}, // +9: state 5 transitions
	{gaSLPUNC+14,	10},
	{gaSLPUNC+12,	11},
	{gaSLPUNC+0,	2}, // +12: state 6 transitions
	{gaSLPUNC+21,	10},
	{gaSLPUNC+12,	11},
	{gaSLPUNC+27,	10}, // +15: state 7 transitions
	{gaSLPUNC+12,	9}, // +16: state 8 transitions
	{gaSLPUNC+27,	10},
	{gaSLPUNC+12,	7}, // +18: state 9 transitions
	{gaSLPUNC+27,	10},
	{gaSLPUNC+12,	12}, // +20: state 11 transitions
	{gaSLPUNC+12,	10}, // +21: state 12 transitions
};

const STATE_DESCRIPTION aStateDescLPUNC[13] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTLPUNC+0},
	/*   1 */ {0, 1, gaTLPUNC+5},
	/*   2 */ {0, 1, gaTLPUNC+6},
	/*   3 */ {0, 1, gaTLPUNC+7},
	/*   4 */ {0, 1, gaTLPUNC+8},
	/*   5 */ {1, 3, gaTLPUNC+9},
	/*   6 */ {1, 3, gaTLPUNC+12},
	/*   7 */ {1, 1, gaTLPUNC+15},
	/*   8 */ {1, 2, gaTLPUNC+16},
	/*   9 */ {1, 2, gaTLPUNC+18},
	/*  10 */ {1, 0, NULL},
	/*  11 */ {1, 1, gaTLPUNC+20},
	/*  12 */ {1, 1, gaTLPUNC+21},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\fforward.c ===
#include "common.h"
#include "nfeature.h"
#include "engine.h"
#include "infernop.h"
#include "nnet.h"
#include "snet.h"
#include "fforward.h"

#include "math16.h"

// No loading necessary
BOOL InitInferno(HINSTANCE hInst)
{
	return TRUE;
}

/******************************Private*Routine******************************\
* GetNZSpaces
*
* Function to ount the number of non zero elements in the input array, and 
* the gaps between them. For ease of later bookeeping we also keep track of 
* the zero space counts at the start and end of each time slice.
* Returns the total number of NZ elements
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Wrote this comment header.
\**************************************************************************/
// 
int GetNZSpaces(
int		*pData,						// IN/OUT: Input Data array, on out is compacted to remove zero elements
int					cSlice,			// IN: Number of time slices
int					cLen,			// IN: Length of each time slice
unsigned short		*pNZgap,		// OUT: the gaps between the NZ elements
unsigned short		*pcNZPerCol		// OUT: Number of NZ elements per slice	
)
{
	int					i, j, k, cNZ, cGap;
	int					iLastNZ;

	i = 0;
	cNZ = cGap = 0;
	iLastNZ = 0;

	ASSERT(pData);
	ASSERT(pNZgap);
	ASSERT(pcNZPerCol);

	*pcNZPerCol = 0;

	for (k = 0 ; k < cSlice; ++k )
	{
		for (j = 0 ; j < cLen ; ++j, ++i)
		{
			if (pData[i] != 0)
			{
				pData[cNZ++] = pData[i];
				pNZgap[cGap++] = i - iLastNZ;
				(*pcNZPerCol)++;
				iLastNZ = i;
			}
		}

		++pcNZPerCol;
		*pcNZPerCol = 0;

		pNZgap[cGap++] = i - iLastNZ;
		iLastNZ = i;
	}

	return cNZ;
}

/******************************Private*Routine******************************\
* FF_HiddenLayer_General
*
* Function to do input-to-hidden layer feedforward.
* This is most general (inefficient) implementation and is used only for short inputs.
* The more efficient one is FF_HiddenLayer
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_HiddenLayer_General(
int						cWidth, 
int						*input, 
int						*output, 
int						cOutput, 
int						cWeightHeight, 
int						cWeightWidth, 
ROMMABLE INP_HID_WEIGHT *rgWeight, 
ROMMABLE HID_BIAS		*rgBias, 
int						iScale
)
{
	int leftMargin, rightMargin, col;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;
	for (col=0; col<cWidth; col++)
	{
		int *pInput;
		const short *pBias;
		int iLeft, iRight, cWeightSkip, row;

		iLeft = col-leftMargin;
		if (iLeft < 0)
			iLeft = 0;
		iRight = col+rightMargin;
		if (iRight >= cWidth)
			iRight = cWidth-1;
		cWeightSkip = leftMargin-col+iLeft;

		pInput = input + iLeft*cWeightHeight;
		pBias = rgBias;

		for (row=0; row<cOutput; row++)
		{
			const short *pWeight = rgWeight + row*cWeightHeight*cWeightWidth + cWeightSkip*cWeightHeight;
			int sum = 0;
			int *tmpInput = pInput;
			int c, iVal;

			for (c=(iRight-iLeft+1)*cWeightHeight; c; c--)
			{
				iVal = (*tmpInput++) * (*pWeight++);
				sum += iVal;
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
		}
	}
}

/******************************Private*Routine******************************\
* FF_HiddenLayer
*
* Function to do input-to-hidden layer feedforward.
*
* The lower layer (input)
* is thought of having cWidth columns one column per time slice. A columns has cWeightHeight 
* units. The upper layer (output) also has cWidth columns, with each column having cOutput units.
*
* Each output weight has incoming conections from cWeightWidth columns in the lower layer.
* In other words an output unit recieves connections from potentially cWeightHeight * cWeightWidth
* units. Columns at either left or right edge have less incoming units and are handles as edge effects
* Also, the case of int(cWeightWidth / 2) time slices is handles as a special case.
*
* Speedup tricks. The lower units are oftewn saturated, ie have max or 0 value. We
* take advantage of the case when the units are 0 and simply skip these units. The straight
* forward approach would be to include an if() statement but that would not really 
* be a time saving. So before entering this routine, we go through all the inputs, throwing
* out the zero values and keeping track of the location of non zero entries in a parallel array of offsets.
* So the 'input' array only has nonzero entries values, the parrallel array pInNZ contains the gaps between
* the nonzero entries in the **real** input space. (An entry of 1 means that values in input were
* actually adjacent in the input space.) Finally pcNZPerCol is a count of Non zero entries
* in wach input column. Now as we do the dot products we only are using non Zero input values
* taking care to use the correct weights by using the pInNZ to index to the appropriate weight
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_HiddenLayer(
int						cWidth,				// IN: Number of time slices (columns) in upper and lower layers
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE INP_HID_WEIGHT	*rgWeight,			// IN: Weight vector
ROMMABLE HID_BIAS		*rgBias,			// IN: Bias vector
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol, 		// IN: Number of non zero entries per time slice (column)
int iScale
)
{
	int				row, col;
	int *pInput;
	int				leftMargin, rightMargin;
	unsigned short	*pcNZPerColTmp, *pInNZTmp;
	int				i, iNZtoLeft;
	int	cInNZ;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;

	// special case: there are output columns for which weight matrxi goes beyond both ends of input
	if (cWidth < leftMargin + rightMargin)
	{
		FF_HiddenLayer_General(cWidth, input, output, cOutput, cWeightHeight, cWeightWidth, rgWeight, rgBias, iScale);
		return;
	}

	cInNZ = GetNZSpaces(input, cWidth, cWeightHeight, pInNZ, pcNZPerCol);
	ASSERT(cInNZ >= 0);

	// Take care of edge effects. Do all the upper layer columns
	// where we do not have leftMargin columns to the left in the lower layer

	pcNZPerColTmp = pcNZPerCol;		// Per column counts
	pInNZTmp = pInNZ;				// The NZ gap counts

	// For all columns in upper row which dont have 
	// enough cols in the lower layer to the left
	for (col = leftMargin ; col ; --col)
	{
		const short *pBias = rgBias;
		const short *pWeight = rgWeight + col * cWeightHeight;

		// For each row in the upper layer
		for (row=cOutput; row; row--)
		{
			int *tmpInput = input;
			int sum= 0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			// Iterate over each col in lower layer that connects to
			// one in the upper layer
			for (iw = cWeightWidth - leftMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);

				// Finall each row in the lower layer
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				// Compensate for gap at end of the slice
				pWeight += *(pNZInc++);
			}

			// Transfer function and clip
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
			pWeight += col * cWeightHeight;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;

	}

	// the middle chunk - has enough on either side to use all weights
	pInput = input;
	pcNZPerColTmp = pcNZPerCol;
	pInNZTmp = pInNZ;

	for (col= 0 ; col < cWidth-leftMargin-rightMargin; col++)
	{
		const short		*pBias = rgBias;
		const short		*pWeight = rgWeight;

		for (row = cOutput ; row ; row--)
		{
			int *tmpInput = pInput;
			unsigned short *pcCol = pcNZPerColTmp; 
			int sum=0;
			int c, iVal, iw;
			unsigned short	*pNZInc = pInNZTmp;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column

	}
	ASSERT(pInput - input == cInNZ - pcNZPerColTmp[0] - pcNZPerColTmp[1]);

	// the right part where the weight matrix goes beyond the right end of input
	// note: weight matrix does not go beyond left end

	pcNZPerColTmp = pcNZPerCol + cWidth - rightMargin - 1;
	
	// Count number of NZ entries in the input so we can set the pointer
	// to the first Non zero entry
	iNZtoLeft = 0;
	for (i = 0 ; i < cWidth - rightMargin -1; ++ i)
	{
		iNZtoLeft += pcNZPerCol[i];
	}

	pInput = input + iNZtoLeft;
	pInNZTmp = pInNZ + iNZtoLeft + i;

	// the left part where the weight matrix goes beyond the left end of input
	// note: weight matrix does not go beyond right end
	//for (col=leftMargin; col; col--)
	for (col = 1 ; col <= rightMargin; ++col)
	{
		const short *pBias = rgBias;
		const short *pWeight = rgWeight; 

		for (row=cOutput; row; row--)
		{
			int *tmpInput = pInput;
			int sum= 0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			for (iw = cWeightWidth - rightMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
			pWeight += col * cWeightHeight ;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;
	}
}

/******************************Private*Routine******************************\
* FF_OutputLayer_General
*
* Function to do hidden-to-output layer feedforward.
* This is most general (inefficient) implementation and is used only for short inputs.
* The more efficient one is FF_OutputLayer.
*
* Note: Unlike the input-to-hidden case, we do not apply the sigmoid function
* at the end here.  We simply compute the weighted sum of the inputs.
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_OutputLayer_General(
int						cWidth, 
int						*input, 
int						*output, 
int						cOutput, 
int						cWeightHeight, 
int						cWeightWidth, 
ROMMABLE HID_OUT_WEIGHT *rgWeight, 
ROMMABLE OUT_BIAS		*rgBias, 
int						iScale
)
{
	int leftMargin, rightMargin, col;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;
	for (col=0; col<cWidth; col++)
	{
		int *pInput;
		const short *pBias;
		int iLeft, iRight, cWeightSkip, row;

		iLeft = col-leftMargin;
		if (iLeft < 0)
			iLeft = 0;
		iRight = col+rightMargin;
		if (iRight >= cWidth)
			iRight = cWidth-1;
		cWeightSkip = leftMargin-col+iLeft;

		pInput = input + iLeft*cWeightHeight;
		pBias = rgBias;

		for (row=0; row<cOutput; row++)
		{
			const char *pWeight = rgWeight + row*cWeightHeight*cWeightWidth + cWeightSkip*cWeightHeight;
			int sum = 0;
			int *tmpInput = pInput;
			int c, iVal;

			for (c=(iRight-iLeft+1)*cWeightHeight; c; c--)
			{
				iVal = (*tmpInput++) * (*pWeight++);
				sum += iVal;
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
		}
	}
}

/******************************Private*Routine******************************\
* FF_OutputLayer
*
* Function to do hidden-to-output layer feedforward.
*
* Note: Unlike the input-to-hidden case, we do not apply the sigmoid function
* at the end here.  We simply compute the weighted sum of the inputs.
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_OutputLayer(
int						cWidth,				// IN: Number of time slices (columns) in upper and lower layers
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE HID_OUT_WEIGHT	*rgWeight,			// IN: Weight vector
ROMMABLE OUT_BIAS		*rgBias,			// IN: Bias vector
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol, 		// IN: Number of non zero entries per time slice (column)
int iScale
)
{
	int				row, col;
	int *pInput;
	int				leftMargin, rightMargin;
	unsigned short	*pcNZPerColTmp, *pInNZTmp;
	int				i, iNZtoLeft;
	int	cInNZ;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;

	// special case: there are output columns for which weight matrxi goes beyond both ends of input
	if (cWidth < leftMargin + rightMargin)
	{
		FF_OutputLayer_General(cWidth, input, output, cOutput, cWeightHeight, cWeightWidth, rgWeight, rgBias, iScale);
		return;
	}

	cInNZ = GetNZSpaces(input, cWidth, cWeightHeight, pInNZ, pcNZPerCol);

	// Take care of edge effects. Do all the upper layer columns
	// where we do not have leftMargin columns to the left in the lower layer

	pcNZPerColTmp = pcNZPerCol;		// Per column counts
	pInNZTmp = pInNZ;				// The NZ gap counts

	// For all columns in upper row which dont have 
	// enough cols in the lower layer to the left
	for (col = leftMargin ; col ; --col)
	{
		const short *pBias = rgBias;
		const char *pWeight = rgWeight + col * cWeightHeight;

		// For each row in the upper layer
		for (row=cOutput; row; row--)
		{
			int *tmpInput = input;
			int sum=0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			// Iterate over each col in lower layer that connects to
			// one in the upper layer
			for (iw = cWeightWidth - leftMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);

				// Finall each row in the lower layer
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				// Compensate for gap at end of the slice
				pWeight += *(pNZInc++);
			}

			// Transfer function and clip
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
			pWeight += col * cWeightHeight;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;

	}

	// the middle chunk - has enough on either side to use all weights
	pInput = input;
	pcNZPerColTmp = pcNZPerCol;
	pInNZTmp = pInNZ;

	for (col= 0 ; col < cWidth-leftMargin-rightMargin; col++)
	{
		const short		*pBias = rgBias;
		const char		*pWeight = rgWeight;

		for (row = cOutput ; row ; row--)
		{
			int *tmpInput = pInput;
			unsigned short *pcCol = pcNZPerColTmp; 
			int sum=0;
			int c, iVal, iw;
			unsigned short	*pNZInc = pInNZTmp;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column

	}
	// warning: the following assertion hold only with width of weight matrix is 3
	ASSERT(pInput - input == cInNZ - pcNZPerColTmp[0] - pcNZPerColTmp[1]);

	// the right part where the weight matrix goes beyond the right end of input
	// note: weight matrix does not go beyond left end

	pcNZPerColTmp = pcNZPerCol + cWidth - rightMargin - 1;
	
	// Count number of NZ entries in the input so we can set the pointer
	// to the first Non zero entry
	iNZtoLeft = 0;
	for (i = 0 ; i < cWidth - rightMargin -1; ++ i)
	{
		iNZtoLeft += pcNZPerCol[i];
	}

	pInput = input + iNZtoLeft;
	pInNZTmp = pInNZ + iNZtoLeft + i;

	// the left part where the weight matrix goes beyond the left end of input
	// note: weight matrix does not go beyond right end
	//for (col=leftMargin; col; col--)
	for (col = 1 ; col <= rightMargin; ++col)
	{
		const short *pBias = rgBias;
		const char *pWeight = rgWeight; 

		for (row=cOutput; row; row--)
		{
			int *tmpInput = pInput;
			int sum=0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			for (iw = cWeightWidth - rightMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
			pWeight += col * cWeightHeight ;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;
	}
}

/******************************Private*Routine******************************\
* logP2P
*
* Function to convert the weight sums at the output nodes to activations.
* A sigmoid functions is used for Node 0.
* Other nodes use a softmax, hence the name logP2P.
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from the last checked-in version.
\**************************************************************************/
void logP2P(
int	cWidth,
int *output,
int cOutput
)
{
	int	row, col;
	int	iSigMax = (1 << 16);
	int	*pOutput;

	for (col= 0 ; col < cWidth; col++)
	{
		int sum, max;

		// first row is sigmoid
		*output = Sigmoid16(*output);
		output++;
		
		//first find max weighted-sum over all rows
		max = *output;
		pOutput = output+1;
		for (row = 2; row<cOutput; row++, pOutput++)
		{
			if (*pOutput > max)
				max = *pOutput;
		}
		// now exponentiate and compute sum of exponentials
		pOutput = output;
		sum = 0;
		for (row = 1; row<cOutput; row++, pOutput++)
		{
			int iV;

			iV = *pOutput - max;
			if (iV < 0)
			{
				iV = Sigmoid16(iV);
				iV = (iV << 16) / (iSigMax - iV);
			}
			else
			{
				iV = 1 << 16;
			}
			*pOutput = iV;
			sum += iV;
		}
		// normalize
		for (row = 1; row<cOutput; row++, output++)
		{
			*output = Div16(*output, sum);
			if (*output > 0xFFFF)
				*output = 0xFFFF;
		}
	}
}

int SumOutput(int *output, const unsigned char *pIndex)
{
	int ix = 0;

	while (*pIndex < 255)
	{
		ix += output[*pIndex];
		pIndex++;
	}

	return ix;
}

BOOL ForwardFeedNet(
unsigned short *outputReturn, 
int cWidth, 
int *input,
int *hidden, 
unsigned short *pInNZ, 
unsigned short *pHidNZ, 
unsigned short *pcInNZperCol, 
unsigned short *pcHidNZperCol,
NFEATURE *nfeature,
BOOL bDoSpace
)
{
	int *output, *p, *space, *q;
	int i;
	NFEATURE *tmp;
	const unsigned char HiPunc[] = {9, 11, 12, 45, 10, 255};
	const unsigned char LoPunc[] = {2, 1, 16, 255};
	const unsigned char MidPunc[] = {15, 38, 39, 49, 50, 33, 34, 35, 36, 255};
	const unsigned char BigPunc[] = {22, 5, 6, 27, 28, 7, 8, 29, 30, 31, 32, 13, 14, 21, 17, 18, 19, 20, 37, 40, 3, 4, 41, 42, 43, 44, 46, 48, 47, 255};
	const unsigned char Number[] =  {51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 255};
	const unsigned char UAlpha[] = {123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 255};
	const unsigned char Ascender[] = {73, 74, 77, 78, 81, 82, 85, 86, 91, 92, 93, 94, 109, 110, 255};
	const unsigned char Descender[] = {81, 82, 83, 84, 89, 90, 101, 102, 103, 104, 119, 120, 121, 122, 255};
	const unsigned char LAlpha[] = {71, 72, 75, 76, 79, 80, 87, 88, 95, 96, 97, 98, 99, 100, 105, 106, 107, 108, 111, 112, 113, 114, 115, 116, 117, 118, 255};

	output = (int *) ExternAlloc(gcOutputNode*cWidth*sizeof(int));
	if (!output)
		return FALSE;

	if (bDoSpace)
	{
		space = (int *) ExternAlloc(gcOutputNode_S*cWidth*sizeof(int));
		if (!space)
		{
			ExternFree(output);
			return FALSE;
		}
	}

	p = input;
	tmp = nfeature;
	for (i=cWidth; i; i--)
	{
		unsigned short *pFeat;
		const unsigned short *pBias;
		int j;

		ASSERT(tmp);
		pFeat = tmp->rgFeat;
		pBias = grgInputBias_S;
		for (j=CNEURALFEATURE; j; j--)
		{
			*p++ = ((int)(*pFeat++) - (int)(*pBias++));
		}
		tmp = tmp->next;
	}
	ASSERT(p - input == CNEURALFEATURE*cWidth);

	FF_HiddenLayer(cWidth, input, hidden, gcHiddenNode, gcHiddenWeightHeight, 
		gcHiddenWeightWidth, grgHiddenWeight, grgHiddenBias, pInNZ, pcInNZperCol, giHiddenScale);

	FF_OutputLayer(cWidth, hidden, output, gcOutputNode, gcOutputWeightHeight, 
		gcOutputWeightWidth, grgOutputWeight, grgOutputBias, pHidNZ, pcHidNZperCol, giOutputScale);

	logP2P(cWidth, output, gcOutputNode);

	// deal with space
	if (bDoSpace)
	{
		p = input;
		q = output;
		tmp = nfeature;
		for (i=cWidth; i; i--)
		{
			unsigned short *pFeat;
			const unsigned short *pBias;
			int j;

			ASSERT(tmp);
			pFeat = tmp->rgFeat;
			pBias = grgInputBias_S;
			for (j=CNEURALFEATURE; j; j--)
			{
				*p++ = ((int)(*pFeat++) - (int)(*pBias++));
			}
			// extra features
			*p++ = ((int)SumOutput(q, HiPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, LoPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, MidPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, BigPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, Number) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, UAlpha) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, Ascender) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, Descender) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, LAlpha) - (int)(*pBias++));
			tmp = tmp->next;
			q += gcOutputNode;
		}
		ASSERT(p - input == (CNEURALFEATURE+9)*cWidth);

		FF_HiddenLayer(cWidth, input, hidden, gcHiddenNode_S, gcHiddenWeightHeight_S, 
			gcHiddenWeightWidth_S, grgHiddenWeight_S, grgHiddenBias_S, pInNZ, pcInNZperCol, giHiddenScale_S);

		FF_OutputLayer(cWidth, hidden, space, gcOutputNode_S, gcOutputWeightHeight_S, 
			gcOutputWeightWidth_S, grgOutputWeight_S, grgOutputBias_S, pHidNZ, pcHidNZperCol, giOutputScale_S);

		// now overwrite space probs in "output" with "space"
		p = output;
		q = space;
		for (i=cWidth; i; i--)
		{
			*p = Sigmoid16(*q++);
			if (*p > 0xFFFF)
				*p = 0xFFFF;
			p += gcOutputNode;
		}

		ExternFree(space);
	}  // if bDoSpace

	// now convert int's into unsigned short's
	p = output;
	for (i=cWidth*gcOutputNode; i; i--)
		*outputReturn++ = (unsigned short)*p++;
	ExternFree(output);

	return TRUE;
}


/******************************Public*Routine******************************\
* FeedForward
*
* Main public function called from outside to feed inut through the neural
* net(s).
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FeedForward(FFINFO *ffinfo)
{
	NFEATURESET *nfeatureset = ffinfo->nfeatureset;
	unsigned short *output = ffinfo->NeuralOutput;
	int	*input = NULL, *hidden = NULL;
	int				cWidth = nfeatureset->cSegment, cWidth1;
	unsigned short	*pHidNZ = NULL, *pInNZ = NULL, *pcInNZperCol = NULL, *pcHidNZperCol = NULL;
	int				inputHeightMax, hiddenHeightMax;

	cWidth1 = cWidth + 1;
	ASSERT(gcHiddenWeightHeight == CNEURALFEATURE);
	ASSERT(gcOutputWeightHeight == gcHiddenNode);

	inputHeightMax = max(gcHiddenWeightHeight, gcHiddenWeightHeight_S);
	hiddenHeightMax = max(gcOutputWeightHeight, gcOutputWeightHeight_S);

	// allocate hidden layer
	input = (int *) ExternAlloc(inputHeightMax*cWidth*sizeof(int));
	hidden = (int *) ExternAlloc(hiddenHeightMax*cWidth*sizeof(int));
	pInNZ = (unsigned short *) ExternAlloc((inputHeightMax+1)*cWidth*sizeof(unsigned short));
	pHidNZ = (unsigned short *) ExternAlloc((hiddenHeightMax+1)*cWidth*sizeof(unsigned short));
	pcInNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));
	pcHidNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));


	if (!input || !hidden || !pInNZ || !pHidNZ || !pcInNZperCol || !pcHidNZperCol )
		goto fail;

	// forward feed through net

	ForwardFeedNet(ffinfo->NeuralOutput, cWidth, input, hidden, pInNZ, pHidNZ, pcInNZperCol, pcHidNZperCol, nfeatureset->head, TRUE);
fail:
	ExternFree(input);
	ExternFree(hidden);
	ExternFree(pInNZ);
	ExternFree(pHidNZ);
	ExternFree(pcInNZperCol);
	ExternFree(pcHidNZperCol);
	
	return;
}
//FeedForwardNoSpace was originally called by baseline.c--not used anymore-Mango--6/20/2001
/*BOOL FeedForwardNoSpace(NFEATURESET *nfeatureset, REAL *NeuralOutput)
{
	int	*input = NULL, *hidden = NULL;
	int				cWidth = nfeatureset->cSegment, cWidth1;
	unsigned short	*pHidNZ = NULL, *pInNZ = NULL, *pcInNZperCol = NULL, *pcHidNZperCol = NULL;
	BOOL retVal;

	cWidth1 = cWidth + 1;
	ASSERT(gcHiddenWeightHeight == CNEURALFEATURE);
	ASSERT(gcOutputWeightHeight == gcHiddenNode);

	input = (int *) ExternAlloc(gcHiddenWeightHeight*cWidth*sizeof(int));
	hidden = (int *) ExternAlloc(gcOutputWeightHeight*cWidth*sizeof(int));
	pInNZ = (unsigned short *) ExternAlloc((gcHiddenWeightHeight+1)*cWidth*sizeof(unsigned short));
	pHidNZ = (unsigned short *) ExternAlloc((gcOutputWeightHeight+1)*cWidth*sizeof(unsigned short));
	pcInNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));
	pcHidNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));


	if (!input || !hidden || !pInNZ || !pHidNZ || !pcInNZperCol || !pcHidNZperCol )
		retVal = FALSE;
	else
		// forward feed through net
		retVal = ForwardFeedNet(NeuralOutput, cWidth, input, hidden, pInNZ, pHidNZ, pcInNZperCol, pcHidNZperCol, nfeatureset->head, FALSE);

	ExternFree(input);
	ExternFree(hidden);
	ExternFree(pInNZ);
	ExternFree(pHidNZ);
	ExternFree(pcInNZperCol);
	ExternFree(pcHidNZperCol);
	
	return retVal;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\number.c ===
// number.c
// Angshuman Guha, aguha
// Jan 8, 2001

#include "common.h"
#include "number.h"

// text generated by re2fsa at Tue Apr 16 13:52:08 2002

// the input-file of rules:
// numsimple = [sign] integer;
// numsimple = [sign] [digit_seq] "." digit_seq;
// 
// numnth = integer [rank];
// 
// numunit = numsimple unit;
// 
// numnum = "#" integer;
// 
// numpercent = numsimple "%";
// 
// numdate = "'" digit digit;
// numdate = [dayofmonth "/"] nummonth "/" year;
// numdate = dayofmonth "/" nummonth;
// numdate = digit digit digit digit ["-" digit digit digit digit];
// nummonth = ["0"] "123456789" | "1" "012";
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01";
// year = digit digit [digit digit];
// 
// longdate = [dayofweek "," space] monthname space dayofmonth [","  space digit digit digit digit];
// date = numdate | longdate;
// 
// dayofweek = "S" "u" "n" [ "d" "a" "y" ];
// dayofweek = "M" "o" "n" [ "d" "a" "y" ];
// dayofweek = "T" "u" "e" [ "s" "d" "a" "y" ];
// dayofweek = "W" "e" "d" [ "n" "e" "s" "d" "a" "y" ];
// dayofweek = "T" "h" "u" [ "r" "s" "d" "a" "y" ];
// dayofweek = "F" "r" "i" [ "d" "a" "y" ];
// dayofweek = "S" "a" "t" [ "u" "r" "d" "a" "y" ];
// monthname = "J" "a" "n" [ "u" "a" "r" "y" ];
// monthname = "J" "A" "N";
// monthname = "F" "e" "b" [ "r" "u" "a" "r" "y" ];
// monthname = "F" "E" "B";
// monthname = "M" "a" "r" [ "c" "h" ];
// monthname = "M" "A" "R";
// monthname = "A" "p" "r" [ "i" "l" ];
// monthname = "A" "P" "R";
// monthname = "M" "a" "y";
// monthname = "M" "A" "Y";
// monthname = "J" "u" "n" [ "e" ];
// monthname = "J" "U" "N";
// monthname = "J" "u" "l" [ "y" ];
// monthname = "J" "U" "L";
// monthname = "A" "u" "g" [ "u" "s" "t" ];
// monthname = "A" "U" "G";
// monthname = "S" "e" "p" [ "t" "e" "m" "b" "e" "r" ];
// monthname = "S" "E" "P";
// monthname = "O" "c" "t" [ "o" "b" "e" "r" ];
// monthname = "O" "C" "T";
// monthname = "N" "o" "v" [ "e" "m" "b" "e" "r" ];
// monthname = "N" "O" "V";
// monthname = "D" "e" "c" [ "e" "m" "b" "e" "r" ];
// monthname = "D" "E" "C";
// 
// numtime = hour ":" minutes [":" seconds] space ampm;
// numtime = militaryhour ":" minutes [":" seconds];
// numtime = minutes ":" seconds;
// hour = ["0"] "123456789" | "1" "012";
// militaryhour = ["0"] digit | "1" digit | "2" "0123";
// minutes = "012345" digit;
// seconds = "012345" digit;
// ampm = "a" "m" | "p" "m" | "A" "M" | "P" "M";
// 
// numcurrency = "$" integer ["." [digit digit]] ["km"];
// numcurrency = "$" "." digit digit ["km"];
// numcurrency = [digit] digit "p";
// numcurrency = "" digit_seq "." digit digit "p";
// 
// parenthesized_phone = "(" digit+ ")";
// separator_phone = "-. ";
// sequence_phone = (digit+ separator_phone)* digit+;
// numphone = ["+"] sequence_phone;
// numphone = parenthesized_phone [space] sequence_phone;
// numphone = ["+"] sequence_phone [space] parenthesized_phone [space] sequence_phone;
// 
// nummath = expr [equals expr];
// expr = term [plus term];
// term = numsimple;
// term = "(" numsimple plus numsimple ")";
// equals = "<>=";
// plus = "+-/*";
// 
// integer = digit_seq | comma_sep_integer;
// digit_seq = digit+;
// comma_sep_integer = digit [digit [digit]] ["," digit digit digit]*;
// digit = "0123456789";
// rank = "s" "t" | "n" "d" | "r" "d" | "t" "h";
// rank = "S" "T" | "N" "D" | "R" "D" | "T" "H";
// sign = "+-";
// unit = "bBkKmM\"'";
// unit = "k" "b" | "K" "b" | "K" "B" | "m" "b" | "M" "b" | "M" "B";
// unit = "s" "q" | "S" "q" | "k" "m" | "K" "m" | "i" "n" "." | "f" "t" ".";
// unit = "m" "m" ["."];
// unit = "c" "m" ["."];
// unit = "e" "r" "s";
// unit = "k" "v" | "K" "V";
// unit = "";
// 
// space = " ";
// 
// number = numsimple;
// number = numnth;
// number = numunit;
// number = numnum;
// number = numpercent;
// number = numdate;
// number = numtime;
// number = numcurrency;
// number = numphone;
// number = nummath;
// 
// = number

// 258 states

static const unsigned char gaSNUMBER[] = 
	/* gaStringNUMBER+0 */	"#\000"
	/* gaStringNUMBER+2 */	"$\000"
	/* gaStringNUMBER+6 */	"'\000"
	/* gaStringNUMBER+8 */	"(\000"
	/* gaStringNUMBER+10 */	"+\000"
	/* gaStringNUMBER+12 */	"-\000"
	/* gaStringNUMBER+14 */	".\000"
	/* gaStringNUMBER+16 */	"0\000"
	/* gaStringNUMBER+18 */	"1\000"
	/* gaStringNUMBER+20 */	"2\000"
	/* gaStringNUMBER+22 */	"3\000"
	/* gaStringNUMBER+24 */	"45\000"
	/* gaStringNUMBER+27 */	"6789\000"
	/* gaStringNUMBER+32 */	"\000"
	/* gaStringNUMBER+34 */	"0123456789\000"
	/* gaStringNUMBER+45 */	"+-\000"
	/* gaStringNUMBER+48 */	" \000"
	/* gaStringNUMBER+50 */	"\"%'Bbp\000"
	/* gaStringNUMBER+59 */	"*+/\000"
	/* gaStringNUMBER+63 */	",\000"
	/* gaStringNUMBER+65 */	"123456789\000"
	/* gaStringNUMBER+75 */	":\000"
	/* gaStringNUMBER+77 */	"<=>\000"
	/* gaStringNUMBER+81 */	"K\000"
	/* gaStringNUMBER+83 */	"M\000"
	/* gaStringNUMBER+85 */	"NR\000"
	/* gaStringNUMBER+88 */	"S\000"
	/* gaStringNUMBER+90 */	"T\000"
	/* gaStringNUMBER+92 */	"c\000"
	/* gaStringNUMBER+94 */	"e\000"
	/* gaStringNUMBER+96 */	"f\000"
	/* gaStringNUMBER+98 */	"i\000"
	/* gaStringNUMBER+100 */	"k\000"
	/* gaStringNUMBER+102 */	"m\000"
	/* gaStringNUMBER+104 */	"nr\000"
	/* gaStringNUMBER+107 */	"s\000"
	/* gaStringNUMBER+109 */	"t\000"
	/* gaStringNUMBER+111 */	"*+\000"
	/* gaStringNUMBER+114 */	"012\000"
	/* gaStringNUMBER+118 */	"/\000"
	/* gaStringNUMBER+120 */	"3456789\000"
	/* gaStringNUMBER+128 */	"0123\000"
	/* gaStringNUMBER+133 */	"456789\000"
	/* gaStringNUMBER+140 */	"01\000"
	/* gaStringNUMBER+143 */	"23456789\000"
	/* gaStringNUMBER+152 */	"km\000"
	/* gaStringNUMBER+155 */	")\000"
	/* gaStringNUMBER+157 */	"*+-/\000"
	/* gaStringNUMBER+162 */	"\"%'Bb\000"
	/* gaStringNUMBER+169 */	"Ss\000"
	/* gaStringNUMBER+172 */	"012345\000"
	/* gaStringNUMBER+179 */	"BVbm\000"
	/* gaStringNUMBER+184 */	"Bb\000"
	/* gaStringNUMBER+187 */	"D\000"
	/* gaStringNUMBER+189 */	"Tq\000"
	/* gaStringNUMBER+192 */	"H\000"
	/* gaStringNUMBER+194 */	"r\000"
	/* gaStringNUMBER+196 */	"n\000"
	/* gaStringNUMBER+198 */	"bmv\000"
	/* gaStringNUMBER+202 */	"b\000"
	/* gaStringNUMBER+204 */	"d\000"
	/* gaStringNUMBER+206 */	"qt\000"
	/* gaStringNUMBER+209 */	"h\000"
	/* gaStringNUMBER+211 */	"q\000"
	/* gaStringNUMBER+213 */	"-.\000"
	/* gaStringNUMBER+216 */	" -.\000"
	/* gaStringNUMBER+220 */	"AP\000"
	/* gaStringNUMBER+223 */	"ap\000"
	/* gaStringNUMBER+226 */	"kmp\000"
;

static const STATE_TRANSITION gaTNUMBER[] = {
	{gaSNUMBER+0,	1}, // +0: state 0 transitions
	{gaSNUMBER+2,	2},
	{gaSNUMBER+6,	3},
	{gaSNUMBER+8,	4},
	{gaSNUMBER+10,	5},
	{gaSNUMBER+12,	6},
	{gaSNUMBER+14,	7},
	{gaSNUMBER+16,	8},
	{gaSNUMBER+18,	9},
	{gaSNUMBER+20,	10},
	{gaSNUMBER+22,	11},
	{gaSNUMBER+24,	12},
	{gaSNUMBER+27,	13},
	{gaSNUMBER+32,	14},
	{gaSNUMBER+34,	15}, // +14: state 1 transitions
	{gaSNUMBER+14,	16}, // +15: state 2 transitions
	{gaSNUMBER+34,	17},
	{gaSNUMBER+34,	18}, // +17: state 3 transitions
	{gaSNUMBER+45,	19}, // +18: state 4 transitions
	{gaSNUMBER+14,	20},
	{gaSNUMBER+34,	21},
	{gaSNUMBER+14,	7}, // +21: state 5 transitions
	{gaSNUMBER+34,	22},
	{gaSNUMBER+14,	7}, // +23: state 6 transitions
	{gaSNUMBER+34,	23},
	{gaSNUMBER+34,	24}, // +25: state 7 transitions
	{gaSNUMBER+48,	25}, // +26: state 8 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+16,	32},
	{gaSNUMBER+65,	33},
	{gaSNUMBER+75,	34},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+48,	25}, // +51: state 9 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+114,	33},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+120,	51},
	{gaSNUMBER+75,	52},
	{gaSNUMBER+48,	25}, // +77: state 10 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+128,	51},
	{gaSNUMBER+75,	52},
	{gaSNUMBER+133,	53},
	{gaSNUMBER+48,	25}, // +103: state 11 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+75,	52},
	{gaSNUMBER+140,	53},
	{gaSNUMBER+143,	54},
	{gaSNUMBER+48,	25}, // +129: state 12 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+75,	52},
	{gaSNUMBER+34,	54},
	{gaSNUMBER+48,	25}, // +154: state 13 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+75,	52},
	{gaSNUMBER+34,	55},
	{gaSNUMBER+14,	16}, // +179: state 14 transitions
	{gaSNUMBER+34,	56},
	{gaSNUMBER+63,	57}, // +181: state 15 transitions
	{gaSNUMBER+34,	58},
	{gaSNUMBER+34,	59}, // +183: state 16 transitions
	{gaSNUMBER+152,	26}, // +184: state 17 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	61},
	{gaSNUMBER+34,	62},
	{gaSNUMBER+34,	26}, // +188: state 18 transitions
	{gaSNUMBER+14,	20}, // +189: state 19 transitions
	{gaSNUMBER+34,	63},
	{gaSNUMBER+34,	64}, // +191: state 20 transitions
	{gaSNUMBER+14,	20}, // +192: state 21 transitions
	{gaSNUMBER+155,	65},
	{gaSNUMBER+157,	66},
	{gaSNUMBER+63,	67},
	{gaSNUMBER+34,	68},
	{gaSNUMBER+48,	25}, // +197: state 22 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+34,	70},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+14,	7}, // +215: state 23 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+157,	28},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	72},
	{gaSNUMBER+34,	24}, // +230: state 24 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+157,	28},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+8,	27}, // +243: state 25 transitions
	{gaSNUMBER+34,	73},
	{gaSNUMBER+34,	74}, // +245: state 27 transitions
	{gaSNUMBER+8,	75}, // +246: state 28 transitions
	{gaSNUMBER+45,	76},
	{gaSNUMBER+14,	77},
	{gaSNUMBER+34,	78},
	{gaSNUMBER+34,	79}, // +250: state 29 transitions
	{gaSNUMBER+8,	75}, // +251: state 30 transitions
	{gaSNUMBER+45,	76},
	{gaSNUMBER+14,	77},
	{gaSNUMBER+34,	80},
	{gaSNUMBER+34,	81}, // +255: state 31 transitions
	{gaSNUMBER+48,	25}, // +256: state 32 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+75,	34},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+34,	82},
	{gaSNUMBER+48,	25}, // +280: state 33 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+75,	52},
	{gaSNUMBER+34,	82},
	{gaSNUMBER+172,	83}, // +305: state 34 transitions
	{gaSNUMBER+8,	84}, // +306: state 35 transitions
	{gaSNUMBER+45,	85},
	{gaSNUMBER+14,	86},
	{gaSNUMBER+34,	87},
	{gaSNUMBER+179,	26}, // +310: state 36 transitions
	{gaSNUMBER+184,	26}, // +311: state 37 transitions
	{gaSNUMBER+187,	26}, // +312: state 38 transitions
	{gaSNUMBER+189,	26}, // +313: state 39 transitions
	{gaSNUMBER+192,	26}, // +314: state 40 transitions
	{gaSNUMBER+102,	88}, // +315: state 41 transitions
	{gaSNUMBER+194,	89}, // +316: state 42 transitions
	{gaSNUMBER+109,	90}, // +317: state 43 transitions
	{gaSNUMBER+196,	90}, // +318: state 44 transitions
	{gaSNUMBER+198,	26}, // +319: state 45 transitions
	{gaSNUMBER+202,	26}, // +320: state 46 transitions
	{gaSNUMBER+102,	88},
	{gaSNUMBER+204,	26}, // +322: state 47 transitions
	{gaSNUMBER+206,	26}, // +323: state 48 transitions
	{gaSNUMBER+209,	26}, // +324: state 49 transitions
	{gaSNUMBER+8,	75}, // +325: state 50 transitions
	{gaSNUMBER+45,	76},
	{gaSNUMBER+14,	77},
	{gaSNUMBER+16,	91},
	{gaSNUMBER+18,	92},
	{gaSNUMBER+143,	93},
	{gaSNUMBER+48,	25}, // +331: state 51 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+75,	34},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+34,	82},
	{gaSNUMBER+172,	94}, // +356: state 52 transitions
	{gaSNUMBER+48,	25}, // +357: state 53 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+111,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+118,	50},
	{gaSNUMBER+34,	82},
	{gaSNUMBER+75,	95},
	{gaSNUMBER+48,	25}, // +382: state 54 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+34,	82},
	{gaSNUMBER+75,	95},
	{gaSNUMBER+48,	25}, // +406: state 55 transitions
	{gaSNUMBER+50,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+34,	82},
	{gaSNUMBER+152,	26}, // +429: state 56 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	96},
	{gaSNUMBER+34,	97},
	{gaSNUMBER+34,	98}, // +433: state 57 transitions
	{gaSNUMBER+63,	57}, // +434: state 58 transitions
	{gaSNUMBER+34,	99},
	{gaSNUMBER+34,	100}, // +436: state 59 transitions
	{gaSNUMBER+34,	101}, // +437: state 60 transitions
	{gaSNUMBER+152,	26}, // +438: state 61 transitions
	{gaSNUMBER+34,	59},
	{gaSNUMBER+152,	26}, // +440: state 62 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	61},
	{gaSNUMBER+34,	102},
	{gaSNUMBER+14,	20}, // +444: state 63 transitions
	{gaSNUMBER+157,	66},
	{gaSNUMBER+63,	67},
	{gaSNUMBER+34,	103},
	{gaSNUMBER+34,	64}, // +448: state 64 transitions
	{gaSNUMBER+157,	66},
	{gaSNUMBER+48,	104}, // +450: state 65 transitions
	{gaSNUMBER+34,	105},
	{gaSNUMBER+45,	106}, // +452: state 66 transitions
	{gaSNUMBER+14,	107},
	{gaSNUMBER+34,	108},
	{gaSNUMBER+34,	109}, // +455: state 67 transitions
	{gaSNUMBER+14,	20}, // +456: state 68 transitions
	{gaSNUMBER+155,	65},
	{gaSNUMBER+157,	66},
	{gaSNUMBER+63,	67},
	{gaSNUMBER+34,	110},
	{gaSNUMBER+34,	111}, // +461: state 69 transitions
	{gaSNUMBER+48,	25}, // +462: state 70 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	112},
	{gaSNUMBER+211,	26}, // +480: state 71 transitions
	{gaSNUMBER+14,	7}, // +481: state 72 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+157,	28},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	113},
	{gaSNUMBER+48,	25}, // +496: state 73 transitions
	{gaSNUMBER+8,	27},
	{gaSNUMBER+34,	73},
	{gaSNUMBER+213,	114},
	{gaSNUMBER+155,	65}, // +500: state 74 transitions
	{gaSNUMBER+34,	74},
	{gaSNUMBER+45,	115}, // +502: state 75 transitions
	{gaSNUMBER+14,	116},
	{gaSNUMBER+34,	117},
	{gaSNUMBER+14,	77}, // +505: state 76 transitions
	{gaSNUMBER+34,	78},
	{gaSNUMBER+34,	118}, // +507: state 77 transitions
	{gaSNUMBER+77,	35}, // +508: state 78 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+34,	120},
	{gaSNUMBER+34,	121}, // +512: state 79 transitions
	{gaSNUMBER+48,	25}, // +513: state 80 transitions
	{gaSNUMBER+8,	27},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+12,	114},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+14,	122},
	{gaSNUMBER+34,	123},
	{gaSNUMBER+48,	25}, // +520: state 81 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	81},
	{gaSNUMBER+14,	114},
	{gaSNUMBER+48,	25}, // +537: state 82 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+34,	124},
	{gaSNUMBER+34,	125}, // +560: state 83 transitions
	{gaSNUMBER+45,	126}, // +561: state 84 transitions
	{gaSNUMBER+14,	127},
	{gaSNUMBER+34,	128},
	{gaSNUMBER+14,	86}, // +564: state 85 transitions
	{gaSNUMBER+34,	87},
	{gaSNUMBER+34,	129}, // +566: state 86 transitions
	{gaSNUMBER+14,	86}, // +567: state 87 transitions
	{gaSNUMBER+157,	130},
	{gaSNUMBER+63,	131},
	{gaSNUMBER+34,	132},
	{gaSNUMBER+14,	26}, // +571: state 88 transitions
	{gaSNUMBER+107,	26}, // +572: state 89 transitions
	{gaSNUMBER+14,	26}, // +573: state 90 transitions
	{gaSNUMBER+77,	35}, // +574: state 91 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+16,	120},
	{gaSNUMBER+65,	133},
	{gaSNUMBER+77,	35}, // +579: state 92 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+120,	120},
	{gaSNUMBER+114,	133},
	{gaSNUMBER+118,	134},
	{gaSNUMBER+77,	35}, // +585: state 93 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+34,	120},
	{gaSNUMBER+118,	134},
	{gaSNUMBER+34,	135}, // +590: state 94 transitions
	{gaSNUMBER+172,	18}, // +591: state 95 transitions
	{gaSNUMBER+152,	26}, // +592: state 96 transitions
	{gaSNUMBER+34,	136},
	{gaSNUMBER+152,	26}, // +594: state 97 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	96},
	{gaSNUMBER+34,	137},
	{gaSNUMBER+34,	138}, // +598: state 98 transitions
	{gaSNUMBER+63,	57}, // +599: state 99 transitions
	{gaSNUMBER+34,	139},
	{gaSNUMBER+152,	26}, // +601: state 100 transitions
	{gaSNUMBER+34,	140}, // +602: state 101 transitions
	{gaSNUMBER+152,	26}, // +603: state 102 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	61},
	{gaSNUMBER+34,	141},
	{gaSNUMBER+14,	20}, // +607: state 103 transitions
	{gaSNUMBER+157,	66},
	{gaSNUMBER+63,	67},
	{gaSNUMBER+34,	142},
	{gaSNUMBER+34,	105}, // +611: state 104 transitions
	{gaSNUMBER+216,	104}, // +612: state 105 transitions
	{gaSNUMBER+34,	105},
	{gaSNUMBER+14,	107}, // +614: state 106 transitions
	{gaSNUMBER+34,	108},
	{gaSNUMBER+34,	143}, // +616: state 107 transitions
	{gaSNUMBER+14,	107}, // +617: state 108 transitions
	{gaSNUMBER+155,	144},
	{gaSNUMBER+63,	145},
	{gaSNUMBER+34,	146},
	{gaSNUMBER+34,	147}, // +621: state 109 transitions
	{gaSNUMBER+14,	20}, // +622: state 110 transitions
	{gaSNUMBER+155,	65},
	{gaSNUMBER+157,	66},
	{gaSNUMBER+63,	67},
	{gaSNUMBER+34,	148},
	{gaSNUMBER+34,	149}, // +627: state 111 transitions
	{gaSNUMBER+48,	25}, // +628: state 112 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	150},
	{gaSNUMBER+14,	7}, // +646: state 113 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+157,	28},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	151},
	{gaSNUMBER+34,	73}, // +661: state 114 transitions
	{gaSNUMBER+14,	116}, // +662: state 115 transitions
	{gaSNUMBER+34,	117},
	{gaSNUMBER+34,	152}, // +664: state 116 transitions
	{gaSNUMBER+14,	116}, // +665: state 117 transitions
	{gaSNUMBER+157,	153},
	{gaSNUMBER+63,	154},
	{gaSNUMBER+34,	155},
	{gaSNUMBER+77,	35}, // +669: state 118 transitions
	{gaSNUMBER+34,	118},
	{gaSNUMBER+34,	156}, // +671: state 119 transitions
	{gaSNUMBER+77,	35}, // +672: state 120 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+34,	157},
	{gaSNUMBER+34,	158}, // +676: state 121 transitions
	{gaSNUMBER+34,	159}, // +677: state 122 transitions
	{gaSNUMBER+48,	25}, // +678: state 123 transitions
	{gaSNUMBER+8,	27},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+12,	114},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+14,	122},
	{gaSNUMBER+34,	160},
	{gaSNUMBER+48,	25}, // +685: state 124 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+34,	124},
	{gaSNUMBER+75,	95}, // +707: state 125 transitions
	{gaSNUMBER+14,	127}, // +708: state 126 transitions
	{gaSNUMBER+34,	128},
	{gaSNUMBER+34,	161}, // +710: state 127 transitions
	{gaSNUMBER+14,	127}, // +711: state 128 transitions
	{gaSNUMBER+157,	162},
	{gaSNUMBER+63,	163},
	{gaSNUMBER+34,	164},
	{gaSNUMBER+34,	129}, // +715: state 129 transitions
	{gaSNUMBER+157,	130},
	{gaSNUMBER+8,	165}, // +717: state 130 transitions
	{gaSNUMBER+45,	166},
	{gaSNUMBER+14,	167},
	{gaSNUMBER+34,	168},
	{gaSNUMBER+34,	169}, // +721: state 131 transitions
	{gaSNUMBER+14,	86}, // +722: state 132 transitions
	{gaSNUMBER+157,	130},
	{gaSNUMBER+63,	131},
	{gaSNUMBER+34,	170},
	{gaSNUMBER+77,	35}, // +726: state 133 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+118,	134},
	{gaSNUMBER+34,	157},
	{gaSNUMBER+34,	171}, // +731: state 134 transitions
	{gaSNUMBER+48,	172}, // +732: state 135 transitions
	{gaSNUMBER+75,	173},
	{gaSNUMBER+34,	174}, // +734: state 136 transitions
	{gaSNUMBER+152,	26}, // +735: state 137 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	96},
	{gaSNUMBER+34,	175},
	{gaSNUMBER+34,	176}, // +739: state 138 transitions
	{gaSNUMBER+34,	139}, // +740: state 139 transitions
	{gaSNUMBER+34,	177}, // +741: state 140 transitions
	{gaSNUMBER+152,	26}, // +742: state 141 transitions
	{gaSNUMBER+14,	61},
	{gaSNUMBER+34,	141},
	{gaSNUMBER+14,	20}, // +745: state 142 transitions
	{gaSNUMBER+157,	66},
	{gaSNUMBER+63,	67},
	{gaSNUMBER+34,	178},
	{gaSNUMBER+34,	143}, // +749: state 143 transitions
	{gaSNUMBER+155,	144},
	{gaSNUMBER+157,	28}, // +751: state 144 transitions
	{gaSNUMBER+77,	35},
	{gaSNUMBER+34,	179}, // +753: state 145 transitions
	{gaSNUMBER+14,	107}, // +754: state 146 transitions
	{gaSNUMBER+155,	144},
	{gaSNUMBER+63,	145},
	{gaSNUMBER+34,	180},
	{gaSNUMBER+34,	181}, // +758: state 147 transitions
	{gaSNUMBER+14,	20}, // +759: state 148 transitions
	{gaSNUMBER+155,	65},
	{gaSNUMBER+157,	66},
	{gaSNUMBER+34,	148},
	{gaSNUMBER+34,	182}, // +763: state 149 transitions
	{gaSNUMBER+48,	25}, // +764: state 150 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+8,	27},
	{gaSNUMBER+59,	28},
	{gaSNUMBER+12,	30},
	{gaSNUMBER+14,	31},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	150},
	{gaSNUMBER+14,	7}, // +781: state 151 transitions
	{gaSNUMBER+162,	26},
	{gaSNUMBER+157,	28},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+34,	151},
	{gaSNUMBER+34,	152}, // +795: state 152 transitions
	{gaSNUMBER+157,	153},
	{gaSNUMBER+45,	183}, // +797: state 153 transitions
	{gaSNUMBER+14,	184},
	{gaSNUMBER+34,	185},
	{gaSNUMBER+34,	186}, // +800: state 154 transitions
	{gaSNUMBER+14,	116}, // +801: state 155 transitions
	{gaSNUMBER+157,	153},
	{gaSNUMBER+63,	154},
	{gaSNUMBER+34,	187},
	{gaSNUMBER+34,	188}, // +805: state 156 transitions
	{gaSNUMBER+77,	35}, // +806: state 157 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+34,	189},
	{gaSNUMBER+162,	26}, // +810: state 158 transitions
	{gaSNUMBER+157,	28},
	{gaSNUMBER+63,	29},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+85,	38},
	{gaSNUMBER+88,	39},
	{gaSNUMBER+90,	40},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+104,	47},
	{gaSNUMBER+107,	48},
	{gaSNUMBER+109,	49},
	{gaSNUMBER+48,	25}, // +828: state 159 transitions
	{gaSNUMBER+8,	27},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+213,	114},
	{gaSNUMBER+34,	159},
	{gaSNUMBER+48,	25}, // +833: state 160 transitions
	{gaSNUMBER+8,	27},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+12,	114},
	{gaSNUMBER+63,	119},
	{gaSNUMBER+14,	122},
	{gaSNUMBER+34,	190},
	{gaSNUMBER+34,	161}, // +840: state 161 transitions
	{gaSNUMBER+157,	162},
	{gaSNUMBER+45,	191}, // +842: state 162 transitions
	{gaSNUMBER+14,	192},
	{gaSNUMBER+34,	193},
	{gaSNUMBER+34,	194}, // +845: state 163 transitions
	{gaSNUMBER+14,	127}, // +846: state 164 transitions
	{gaSNUMBER+157,	162},
	{gaSNUMBER+63,	163},
	{gaSNUMBER+34,	195},
	{gaSNUMBER+45,	196}, // +850: state 165 transitions
	{gaSNUMBER+14,	197},
	{gaSNUMBER+34,	198},
	{gaSNUMBER+14,	167}, // +853: state 166 transitions
	{gaSNUMBER+34,	168},
	{gaSNUMBER+34,	139}, // +855: state 167 transitions
	{gaSNUMBER+63,	57}, // +856: state 168 transitions
	{gaSNUMBER+14,	167},
	{gaSNUMBER+34,	199},
	{gaSNUMBER+34,	200}, // +859: state 169 transitions
	{gaSNUMBER+14,	86}, // +860: state 170 transitions
	{gaSNUMBER+157,	130},
	{gaSNUMBER+63,	131},
	{gaSNUMBER+34,	201},
	{gaSNUMBER+34,	202}, // +864: state 171 transitions
	{gaSNUMBER+220,	203}, // +865: state 172 transitions
	{gaSNUMBER+223,	204},
	{gaSNUMBER+172,	205}, // +867: state 173 transitions
	{gaSNUMBER+226,	26}, // +868: state 174 transitions
	{gaSNUMBER+152,	26}, // +869: state 175 transitions
	{gaSNUMBER+14,	96},
	{gaSNUMBER+34,	175},
	{gaSNUMBER+63,	57}, // +872: state 176 transitions
	{gaSNUMBER+152,	26}, // +873: state 177 transitions
	{gaSNUMBER+63,	60},
	{gaSNUMBER+14,	61},
	{gaSNUMBER+14,	20}, // +876: state 178 transitions
	{gaSNUMBER+157,	66},
	{gaSNUMBER+34,	178},
	{gaSNUMBER+34,	206}, // +879: state 179 transitions
	{gaSNUMBER+14,	107}, // +880: state 180 transitions
	{gaSNUMBER+155,	144},
	{gaSNUMBER+63,	145},
	{gaSNUMBER+34,	207},
	{gaSNUMBER+157,	66}, // +884: state 181 transitions
	{gaSNUMBER+63,	67},
	{gaSNUMBER+162,	26}, // +886: state 182 transitions
	{gaSNUMBER+157,	28},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+81,	36},
	{gaSNUMBER+83,	37},
	{gaSNUMBER+92,	41},
	{gaSNUMBER+94,	42},
	{gaSNUMBER+96,	43},
	{gaSNUMBER+98,	44},
	{gaSNUMBER+100,	45},
	{gaSNUMBER+102,	46},
	{gaSNUMBER+63,	69},
	{gaSNUMBER+169,	71},
	{gaSNUMBER+14,	184}, // +899: state 183 transitions
	{gaSNUMBER+34,	185},
	{gaSNUMBER+34,	208}, // +901: state 184 transitions
	{gaSNUMBER+14,	184}, // +902: state 185 transitions
	{gaSNUMBER+155,	209},
	{gaSNUMBER+63,	210},
	{gaSNUMBER+34,	211},
	{gaSNUMBER+34,	212}, // +906: state 186 transitions
	{gaSNUMBER+14,	116}, // +907: state 187 transitions
	{gaSNUMBER+157,	153},
	{gaSNUMBER+63,	154},
	{gaSNUMBER+34,	213},
	{gaSNUMBER+34,	214}, // +911: state 188 transitions
	{gaSNUMBER+77,	35}, // +912: state 189 transitions
	{gaSNUMBER+14,	77},
	{gaSNUMBER+34,	189},
	{gaSNUMBER+48,	25}, // +915: state 190 transitions
	{gaSNUMBER+8,	27},
	{gaSNUMBER+77,	35},
	{gaSNUMBER+12,	114},
	{gaSNUMBER+14,	122},
	{gaSNUMBER+34,	190},
	{gaSNUMBER+14,	192}, // +921: state 191 transitions
	{gaSNUMBER+34,	193},
	{gaSNUMBER+34,	215}, // +923: state 192 transitions
	{gaSNUMBER+14,	192}, // +924: state 193 transitions
	{gaSNUMBER+155,	216},
	{gaSNUMBER+63,	217},
	{gaSNUMBER+34,	218},
	{gaSNUMBER+34,	219}, // +928: state 194 transitions
	{gaSNUMBER+14,	127}, // +929: state 195 transitions
	{gaSNUMBER+157,	162},
	{gaSNUMBER+63,	163},
	{gaSNUMBER+34,	220},
	{gaSNUMBER+14,	197}, // +933: state 196 transitions
	{gaSNUMBER+34,	198},
	{gaSNUMBER+34,	221}, // +935: state 197 transitions
	{gaSNUMBER+14,	197}, // +936: state 198 transitions
	{gaSNUMBER+157,	222},
	{gaSNUMBER+63,	223},
	{gaSNUMBER+34,	224},
	{gaSNUMBER+63,	57}, // +940: state 199 transitions
	{gaSNUMBER+14,	167},
	{gaSNUMBER+34,	225},
	{gaSNUMBER+34,	226}, // +943: state 200 transitions
	{gaSNUMBER+14,	86}, // +944: state 201 transitions
	{gaSNUMBER+157,	130},
	{gaSNUMBER+34,	201},
	{gaSNUMBER+34,	18}, // +947: state 202 transitions
	{gaSNUMBER+83,	26}, // +948: state 203 transitions
	{gaSNUMBER+102,	26}, // +949: state 204 transitions
	{gaSNUMBER+34,	227}, // +950: state 205 transitions
	{gaSNUMBER+34,	228}, // +951: state 206 transitions
	{gaSNUMBER+14,	107}, // +952: state 207 transitions
	{gaSNUMBER+155,	144},
	{gaSNUMBER+34,	207},
	{gaSNUMBER+34,	208}, // +955: state 208 transitions
	{gaSNUMBER+155,	209},
	{gaSNUMBER+77,	35}, // +957: state 209 transitions
	{gaSNUMBER+34,	229}, // +958: state 210 transitions
	{gaSNUMBER+14,	184}, // +959: state 211 transitions
	{gaSNUMBER+155,	209},
	{gaSNUMBER+63,	210},
	{gaSNUMBER+34,	230},
	{gaSNUMBER+34,	231}, // +963: state 212 transitions
	{gaSNUMBER+14,	116}, // +964: state 213 transitions
	{gaSNUMBER+157,	153},
	{gaSNUMBER+34,	213},
	{gaSNUMBER+77,	35}, // +967: state 214 transitions
	{gaSNUMBER+63,	119},
	{gaSNUMBER+34,	215}, // +969: state 215 transitions
	{gaSNUMBER+155,	216},
	{gaSNUMBER+157,	130}, // +971: state 216 transitions
	{gaSNUMBER+34,	232}, // +972: state 217 transitions
	{gaSNUMBER+14,	192}, // +973: state 218 transitions
	{gaSNUMBER+155,	216},
	{gaSNUMBER+63,	217},
	{gaSNUMBER+34,	233},
	{gaSNUMBER+34,	234}, // +977: state 219 transitions
	{gaSNUMBER+14,	127}, // +978: state 220 transitions
	{gaSNUMBER+157,	162},
	{gaSNUMBER+34,	220},
	{gaSNUMBER+34,	221}, // +981: state 221 transitions
	{gaSNUMBER+157,	222},
	{gaSNUMBER+45,	235}, // +983: state 222 transitions
	{gaSNUMBER+14,	236},
	{gaSNUMBER+34,	237},
	{gaSNUMBER+34,	238}, // +986: state 223 transitions
	{gaSNUMBER+14,	197}, // +987: state 224 transitions
	{gaSNUMBER+157,	222},
	{gaSNUMBER+63,	223},
	{gaSNUMBER+34,	239},
	{gaSNUMBER+63,	57}, // +991: state 225 transitions
	{gaSNUMBER+14,	167},
	{gaSNUMBER+34,	240},
	{gaSNUMBER+157,	130}, // +994: state 226 transitions
	{gaSNUMBER+63,	131},
	{gaSNUMBER+48,	172}, // +996: state 227 transitions
	{gaSNUMBER+155,	144}, // +997: state 228 transitions
	{gaSNUMBER+63,	145},
	{gaSNUMBER+34,	241}, // +999: state 229 transitions
	{gaSNUMBER+14,	184}, // +1000: state 230 transitions
	{gaSNUMBER+155,	209},
	{gaSNUMBER+63,	210},
	{gaSNUMBER+34,	242},
	{gaSNUMBER+157,	153}, // +1004: state 231 transitions
	{gaSNUMBER+63,	154},
	{gaSNUMBER+34,	243}, // +1006: state 232 transitions
	{gaSNUMBER+14,	192}, // +1007: state 233 transitions
	{gaSNUMBER+155,	216},
	{gaSNUMBER+63,	217},
	{gaSNUMBER+34,	244},
	{gaSNUMBER+157,	162}, // +1011: state 234 transitions
	{gaSNUMBER+63,	163},
	{gaSNUMBER+14,	236}, // +1013: state 235 transitions
	{gaSNUMBER+34,	237},
	{gaSNUMBER+34,	245}, // +1015: state 236 transitions
	{gaSNUMBER+155,	26}, // +1016: state 237 transitions
	{gaSNUMBER+14,	236},
	{gaSNUMBER+63,	246},
	{gaSNUMBER+34,	247},
	{gaSNUMBER+34,	248}, // +1020: state 238 transitions
	{gaSNUMBER+14,	197}, // +1021: state 239 transitions
	{gaSNUMBER+157,	222},
	{gaSNUMBER+63,	223},
	{gaSNUMBER+34,	249},
	{gaSNUMBER+14,	167}, // +1025: state 240 transitions
	{gaSNUMBER+34,	240},
	{gaSNUMBER+34,	250}, // +1027: state 241 transitions
	{gaSNUMBER+14,	184}, // +1028: state 242 transitions
	{gaSNUMBER+155,	209},
	{gaSNUMBER+34,	242},
	{gaSNUMBER+34,	251}, // +1031: state 243 transitions
	{gaSNUMBER+14,	192}, // +1032: state 244 transitions
	{gaSNUMBER+155,	216},
	{gaSNUMBER+34,	244},
	{gaSNUMBER+155,	26}, // +1035: state 245 transitions
	{gaSNUMBER+34,	245},
	{gaSNUMBER+34,	252}, // +1037: state 246 transitions
	{gaSNUMBER+155,	26}, // +1038: state 247 transitions
	{gaSNUMBER+14,	236},
	{gaSNUMBER+63,	246},
	{gaSNUMBER+34,	253},
	{gaSNUMBER+34,	254}, // +1042: state 248 transitions
	{gaSNUMBER+14,	197}, // +1043: state 249 transitions
	{gaSNUMBER+157,	222},
	{gaSNUMBER+34,	249},
	{gaSNUMBER+155,	209}, // +1046: state 250 transitions
	{gaSNUMBER+63,	210},
	{gaSNUMBER+155,	216}, // +1048: state 251 transitions
	{gaSNUMBER+63,	217},
	{gaSNUMBER+34,	255}, // +1050: state 252 transitions
	{gaSNUMBER+155,	26}, // +1051: state 253 transitions
	{gaSNUMBER+14,	236},
	{gaSNUMBER+63,	246},
	{gaSNUMBER+34,	256},
	{gaSNUMBER+157,	222}, // +1055: state 254 transitions
	{gaSNUMBER+63,	223},
	{gaSNUMBER+34,	257}, // +1057: state 255 transitions
	{gaSNUMBER+155,	26}, // +1058: state 256 transitions
	{gaSNUMBER+14,	236},
	{gaSNUMBER+34,	256},
	{gaSNUMBER+155,	26}, // +1061: state 257 transitions
	{gaSNUMBER+63,	246},
};

const STATE_DESCRIPTION aStateDescNUMBER[258] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 14, gaTNUMBER+0},
	/*   1 */ {0, 1, gaTNUMBER+14},
	/*   2 */ {0, 2, gaTNUMBER+15},
	/*   3 */ {0, 1, gaTNUMBER+17},
	/*   4 */ {0, 3, gaTNUMBER+18},
	/*   5 */ {0, 2, gaTNUMBER+21},
	/*   6 */ {0, 2, gaTNUMBER+23},
	/*   7 */ {0, 1, gaTNUMBER+25},
	/*   8 */ {1, 25, gaTNUMBER+26},
	/*   9 */ {1, 26, gaTNUMBER+51},
	/*  10 */ {1, 26, gaTNUMBER+77},
	/*  11 */ {1, 26, gaTNUMBER+103},
	/*  12 */ {1, 25, gaTNUMBER+129},
	/*  13 */ {1, 25, gaTNUMBER+154},
	/*  14 */ {0, 2, gaTNUMBER+179},
	/*  15 */ {1, 2, gaTNUMBER+181},
	/*  16 */ {0, 1, gaTNUMBER+183},
	/*  17 */ {1, 4, gaTNUMBER+184},
	/*  18 */ {0, 1, gaTNUMBER+188},
	/*  19 */ {0, 2, gaTNUMBER+189},
	/*  20 */ {0, 1, gaTNUMBER+191},
	/*  21 */ {0, 5, gaTNUMBER+192},
	/*  22 */ {1, 18, gaTNUMBER+197},
	/*  23 */ {1, 15, gaTNUMBER+215},
	/*  24 */ {1, 13, gaTNUMBER+230},
	/*  25 */ {0, 2, gaTNUMBER+243},
	/*  26 */ {1, 0, NULL},
	/*  27 */ {0, 1, gaTNUMBER+245},
	/*  28 */ {0, 4, gaTNUMBER+246},
	/*  29 */ {0, 1, gaTNUMBER+250},
	/*  30 */ {0, 4, gaTNUMBER+251},
	/*  31 */ {0, 1, gaTNUMBER+255},
	/*  32 */ {1, 24, gaTNUMBER+256},
	/*  33 */ {1, 25, gaTNUMBER+280},
	/*  34 */ {0, 1, gaTNUMBER+305},
	/*  35 */ {0, 4, gaTNUMBER+306},
	/*  36 */ {1, 1, gaTNUMBER+310},
	/*  37 */ {1, 1, gaTNUMBER+311},
	/*  38 */ {0, 1, gaTNUMBER+312},
	/*  39 */ {0, 1, gaTNUMBER+313},
	/*  40 */ {0, 1, gaTNUMBER+314},
	/*  41 */ {0, 1, gaTNUMBER+315},
	/*  42 */ {0, 1, gaTNUMBER+316},
	/*  43 */ {0, 1, gaTNUMBER+317},
	/*  44 */ {0, 1, gaTNUMBER+318},
	/*  45 */ {1, 1, gaTNUMBER+319},
	/*  46 */ {1, 2, gaTNUMBER+320},
	/*  47 */ {0, 1, gaTNUMBER+322},
	/*  48 */ {0, 1, gaTNUMBER+323},
	/*  49 */ {0, 1, gaTNUMBER+324},
	/*  50 */ {0, 6, gaTNUMBER+325},
	/*  51 */ {1, 25, gaTNUMBER+331},
	/*  52 */ {0, 1, gaTNUMBER+356},
	/*  53 */ {1, 25, gaTNUMBER+357},
	/*  54 */ {1, 24, gaTNUMBER+382},
	/*  55 */ {1, 23, gaTNUMBER+406},
	/*  56 */ {1, 4, gaTNUMBER+429},
	/*  57 */ {0, 1, gaTNUMBER+433},
	/*  58 */ {1, 2, gaTNUMBER+434},
	/*  59 */ {0, 1, gaTNUMBER+436},
	/*  60 */ {0, 1, gaTNUMBER+437},
	/*  61 */ {1, 2, gaTNUMBER+438},
	/*  62 */ {1, 4, gaTNUMBER+440},
	/*  63 */ {0, 4, gaTNUMBER+444},
	/*  64 */ {0, 2, gaTNUMBER+448},
	/*  65 */ {0, 2, gaTNUMBER+450},
	/*  66 */ {0, 3, gaTNUMBER+452},
	/*  67 */ {0, 1, gaTNUMBER+455},
	/*  68 */ {0, 5, gaTNUMBER+456},
	/*  69 */ {0, 1, gaTNUMBER+461},
	/*  70 */ {1, 18, gaTNUMBER+462},
	/*  71 */ {0, 1, gaTNUMBER+480},
	/*  72 */ {1, 15, gaTNUMBER+481},
	/*  73 */ {1, 4, gaTNUMBER+496},
	/*  74 */ {0, 2, gaTNUMBER+500},
	/*  75 */ {0, 3, gaTNUMBER+502},
	/*  76 */ {0, 2, gaTNUMBER+505},
	/*  77 */ {0, 1, gaTNUMBER+507},
	/*  78 */ {1, 4, gaTNUMBER+508},
	/*  79 */ {0, 1, gaTNUMBER+512},
	/*  80 */ {1, 7, gaTNUMBER+513},
	/*  81 */ {1, 17, gaTNUMBER+520},
	/*  82 */ {1, 23, gaTNUMBER+537},
	/*  83 */ {0, 1, gaTNUMBER+560},
	/*  84 */ {0, 3, gaTNUMBER+561},
	/*  85 */ {0, 2, gaTNUMBER+564},
	/*  86 */ {0, 1, gaTNUMBER+566},
	/*  87 */ {1, 4, gaTNUMBER+567},
	/*  88 */ {1, 1, gaTNUMBER+571},
	/*  89 */ {0, 1, gaTNUMBER+572},
	/*  90 */ {0, 1, gaTNUMBER+573},
	/*  91 */ {1, 5, gaTNUMBER+574},
	/*  92 */ {1, 6, gaTNUMBER+579},
	/*  93 */ {1, 5, gaTNUMBER+585},
	/*  94 */ {0, 1, gaTNUMBER+590},
	/*  95 */ {0, 1, gaTNUMBER+591},
	/*  96 */ {1, 2, gaTNUMBER+592},
	/*  97 */ {1, 4, gaTNUMBER+594},
	/*  98 */ {0, 1, gaTNUMBER+598},
	/*  99 */ {1, 2, gaTNUMBER+599},
	/* 100 */ {1, 1, gaTNUMBER+601},
	/* 101 */ {0, 1, gaTNUMBER+602},
	/* 102 */ {1, 4, gaTNUMBER+603},
	/* 103 */ {0, 4, gaTNUMBER+607},
	/* 104 */ {0, 1, gaTNUMBER+611},
	/* 105 */ {1, 2, gaTNUMBER+612},
	/* 106 */ {0, 2, gaTNUMBER+614},
	/* 107 */ {0, 1, gaTNUMBER+616},
	/* 108 */ {0, 4, gaTNUMBER+617},
	/* 109 */ {0, 1, gaTNUMBER+621},
	/* 110 */ {0, 5, gaTNUMBER+622},
	/* 111 */ {0, 1, gaTNUMBER+627},
	/* 112 */ {1, 18, gaTNUMBER+628},
	/* 113 */ {1, 15, gaTNUMBER+646},
	/* 114 */ {0, 1, gaTNUMBER+661},
	/* 115 */ {0, 2, gaTNUMBER+662},
	/* 116 */ {0, 1, gaTNUMBER+664},
	/* 117 */ {0, 4, gaTNUMBER+665},
	/* 118 */ {1, 2, gaTNUMBER+669},
	/* 119 */ {0, 1, gaTNUMBER+671},
	/* 120 */ {1, 4, gaTNUMBER+672},
	/* 121 */ {0, 1, gaTNUMBER+676},
	/* 122 */ {0, 1, gaTNUMBER+677},
	/* 123 */ {1, 7, gaTNUMBER+678},
	/* 124 */ {1, 22, gaTNUMBER+685},
	/* 125 */ {1, 1, gaTNUMBER+707},
	/* 126 */ {0, 2, gaTNUMBER+708},
	/* 127 */ {0, 1, gaTNUMBER+710},
	/* 128 */ {0, 4, gaTNUMBER+711},
	/* 129 */ {1, 2, gaTNUMBER+715},
	/* 130 */ {0, 4, gaTNUMBER+717},
	/* 131 */ {0, 1, gaTNUMBER+721},
	/* 132 */ {1, 4, gaTNUMBER+722},
	/* 133 */ {1, 5, gaTNUMBER+726},
	/* 134 */ {0, 1, gaTNUMBER+731},
	/* 135 */ {1, 2, gaTNUMBER+732},
	/* 136 */ {0, 1, gaTNUMBER+734},
	/* 137 */ {1, 4, gaTNUMBER+735},
	/* 138 */ {0, 1, gaTNUMBER+739},
	/* 139 */ {1, 1, gaTNUMBER+740},
	/* 140 */ {0, 1, gaTNUMBER+741},
	/* 141 */ {1, 3, gaTNUMBER+742},
	/* 142 */ {0, 4, gaTNUMBER+745},
	/* 143 */ {0, 2, gaTNUMBER+749},
	/* 144 */ {1, 2, gaTNUMBER+751},
	/* 145 */ {0, 1, gaTNUMBER+753},
	/* 146 */ {0, 4, gaTNUMBER+754},
	/* 147 */ {0, 1, gaTNUMBER+758},
	/* 148 */ {0, 4, gaTNUMBER+759},
	/* 149 */ {0, 1, gaTNUMBER+763},
	/* 150 */ {1, 17, gaTNUMBER+764},
	/* 151 */ {1, 14, gaTNUMBER+781},
	/* 152 */ {0, 2, gaTNUMBER+795},
	/* 153 */ {0, 3, gaTNUMBER+797},
	/* 154 */ {0, 1, gaTNUMBER+800},
	/* 155 */ {0, 4, gaTNUMBER+801},
	/* 156 */ {0, 1, gaTNUMBER+805},
	/* 157 */ {1, 4, gaTNUMBER+806},
	/* 158 */ {1, 18, gaTNUMBER+810},
	/* 159 */ {1, 5, gaTNUMBER+828},
	/* 160 */ {1, 7, gaTNUMBER+833},
	/* 161 */ {0, 2, gaTNUMBER+840},
	/* 162 */ {0, 3, gaTNUMBER+842},
	/* 163 */ {0, 1, gaTNUMBER+845},
	/* 164 */ {0, 4, gaTNUMBER+846},
	/* 165 */ {0, 3, gaTNUMBER+850},
	/* 166 */ {0, 2, gaTNUMBER+853},
	/* 167 */ {0, 1, gaTNUMBER+855},
	/* 168 */ {1, 3, gaTNUMBER+856},
	/* 169 */ {0, 1, gaTNUMBER+859},
	/* 170 */ {1, 4, gaTNUMBER+860},
	/* 171 */ {0, 1, gaTNUMBER+864},
	/* 172 */ {0, 2, gaTNUMBER+865},
	/* 173 */ {0, 1, gaTNUMBER+867},
	/* 174 */ {1, 1, gaTNUMBER+868},
	/* 175 */ {1, 3, gaTNUMBER+869},
	/* 176 */ {1, 1, gaTNUMBER+872},
	/* 177 */ {1, 3, gaTNUMBER+873},
	/* 178 */ {0, 3, gaTNUMBER+876},
	/* 179 */ {0, 1, gaTNUMBER+879},
	/* 180 */ {0, 4, gaTNUMBER+880},
	/* 181 */ {0, 2, gaTNUMBER+884},
	/* 182 */ {1, 13, gaTNUMBER+886},
	/* 183 */ {0, 2, gaTNUMBER+899},
	/* 184 */ {0, 1, gaTNUMBER+901},
	/* 185 */ {0, 4, gaTNUMBER+902},
	/* 186 */ {0, 1, gaTNUMBER+906},
	/* 187 */ {0, 4, gaTNUMBER+907},
	/* 188 */ {0, 1, gaTNUMBER+911},
	/* 189 */ {1, 3, gaTNUMBER+912},
	/* 190 */ {1, 6, gaTNUMBER+915},
	/* 191 */ {0, 2, gaTNUMBER+921},
	/* 192 */ {0, 1, gaTNUMBER+923},
	/* 193 */ {0, 4, gaTNUMBER+924},
	/* 194 */ {0, 1, gaTNUMBER+928},
	/* 195 */ {0, 4, gaTNUMBER+929},
	/* 196 */ {0, 2, gaTNUMBER+933},
	/* 197 */ {0, 1, gaTNUMBER+935},
	/* 198 */ {0, 4, gaTNUMBER+936},
	/* 199 */ {1, 3, gaTNUMBER+940},
	/* 200 */ {0, 1, gaTNUMBER+943},
	/* 201 */ {1, 3, gaTNUMBER+944},
	/* 202 */ {1, 1, gaTNUMBER+947},
	/* 203 */ {0, 1, gaTNUMBER+948},
	/* 204 */ {0, 1, gaTNUMBER+949},
	/* 205 */ {0, 1, gaTNUMBER+950},
	/* 206 */ {0, 1, gaTNUMBER+951},
	/* 207 */ {0, 3, gaTNUMBER+952},
	/* 208 */ {0, 2, gaTNUMBER+955},
	/* 209 */ {1, 1, gaTNUMBER+957},
	/* 210 */ {0, 1, gaTNUMBER+958},
	/* 211 */ {0, 4, gaTNUMBER+959},
	/* 212 */ {0, 1, gaTNUMBER+963},
	/* 213 */ {0, 3, gaTNUMBER+964},
	/* 214 */ {1, 2, gaTNUMBER+967},
	/* 215 */ {0, 2, gaTNUMBER+969},
	/* 216 */ {1, 1, gaTNUMBER+971},
	/* 217 */ {0, 1, gaTNUMBER+972},
	/* 218 */ {0, 4, gaTNUMBER+973},
	/* 219 */ {0, 1, gaTNUMBER+977},
	/* 220 */ {0, 3, gaTNUMBER+978},
	/* 221 */ {0, 2, gaTNUMBER+981},
	/* 222 */ {0, 3, gaTNUMBER+983},
	/* 223 */ {0, 1, gaTNUMBER+986},
	/* 224 */ {0, 4, gaTNUMBER+987},
	/* 225 */ {1, 3, gaTNUMBER+991},
	/* 226 */ {1, 2, gaTNUMBER+994},
	/* 227 */ {1, 1, gaTNUMBER+996},
	/* 228 */ {0, 2, gaTNUMBER+997},
	/* 229 */ {0, 1, gaTNUMBER+999},
	/* 230 */ {0, 4, gaTNUMBER+1000},
	/* 231 */ {0, 2, gaTNUMBER+1004},
	/* 232 */ {0, 1, gaTNUMBER+1006},
	/* 233 */ {0, 4, gaTNUMBER+1007},
	/* 234 */ {0, 2, gaTNUMBER+1011},
	/* 235 */ {0, 2, gaTNUMBER+1013},
	/* 236 */ {0, 1, gaTNUMBER+1015},
	/* 237 */ {0, 4, gaTNUMBER+1016},
	/* 238 */ {0, 1, gaTNUMBER+1020},
	/* 239 */ {0, 4, gaTNUMBER+1021},
	/* 240 */ {1, 2, gaTNUMBER+1025},
	/* 241 */ {0, 1, gaTNUMBER+1027},
	/* 242 */ {0, 3, gaTNUMBER+1028},
	/* 243 */ {0, 1, gaTNUMBER+1031},
	/* 244 */ {0, 3, gaTNUMBER+1032},
	/* 245 */ {0, 2, gaTNUMBER+1035},
	/* 246 */ {0, 1, gaTNUMBER+1037},
	/* 247 */ {0, 4, gaTNUMBER+1038},
	/* 248 */ {0, 1, gaTNUMBER+1042},
	/* 249 */ {0, 3, gaTNUMBER+1043},
	/* 250 */ {0, 2, gaTNUMBER+1046},
	/* 251 */ {0, 2, gaTNUMBER+1048},
	/* 252 */ {0, 1, gaTNUMBER+1050},
	/* 253 */ {0, 4, gaTNUMBER+1051},
	/* 254 */ {0, 2, gaTNUMBER+1055},
	/* 255 */ {0, 1, gaTNUMBER+1057},
	/* 256 */ {0, 3, gaTNUMBER+1058},
	/* 257 */ {0, 2, gaTNUMBER+1061},
};

// end of text generated by re2fsa

/**************** NUMSIMPLE ***********************************/

// 12 states

static const unsigned char gaSNUMSIMPLE[] = 
	/* gaStringNUMSIMPLE+0 */	"+-\000"
	/* gaStringNUMSIMPLE+3 */	".\000"
	/* gaStringNUMSIMPLE+5 */	"0123456789\000"
	/* gaStringNUMSIMPLE+16 */	",\000"
;

static const STATE_TRANSITION gaTNUMSIMPLE[] = {
	{gaSNUMSIMPLE+0,	1}, // +0: state 0 transitions
	{gaSNUMSIMPLE+3,	2},
	{gaSNUMSIMPLE+5,	3},
	{gaSNUMSIMPLE+3,	2}, // +3: state 1 transitions
	{gaSNUMSIMPLE+5,	3},
	{gaSNUMSIMPLE+5,	4}, // +5: state 2 transitions
	{gaSNUMSIMPLE+3,	2}, // +6: state 3 transitions
	{gaSNUMSIMPLE+16,	5},
	{gaSNUMSIMPLE+5,	6},
	{gaSNUMSIMPLE+5,	4}, // +9: state 4 transitions
	{gaSNUMSIMPLE+5,	7}, // +10: state 5 transitions
	{gaSNUMSIMPLE+3,	2}, // +11: state 6 transitions
	{gaSNUMSIMPLE+16,	5},
	{gaSNUMSIMPLE+5,	8},
	{gaSNUMSIMPLE+5,	9}, // +14: state 7 transitions
	{gaSNUMSIMPLE+3,	2}, // +15: state 8 transitions
	{gaSNUMSIMPLE+16,	5},
	{gaSNUMSIMPLE+5,	10},
	{gaSNUMSIMPLE+5,	11}, // +18: state 9 transitions
	{gaSNUMSIMPLE+3,	2}, // +19: state 10 transitions
	{gaSNUMSIMPLE+5,	10},
	{gaSNUMSIMPLE+16,	5}, // +21: state 11 transitions
};

const STATE_DESCRIPTION aStateDescNUMSIMPLE[12] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMSIMPLE+0},
	/*   1 */ {0, 2, gaTNUMSIMPLE+3},
	/*   2 */ {0, 1, gaTNUMSIMPLE+5},
	/*   3 */ {1, 3, gaTNUMSIMPLE+6},
	/*   4 */ {1, 1, gaTNUMSIMPLE+9},
	/*   5 */ {0, 1, gaTNUMSIMPLE+10},
	/*   6 */ {1, 3, gaTNUMSIMPLE+11},
	/*   7 */ {0, 1, gaTNUMSIMPLE+14},
	/*   8 */ {1, 3, gaTNUMSIMPLE+15},
	/*   9 */ {0, 1, gaTNUMSIMPLE+18},
	/*  10 */ {1, 2, gaTNUMSIMPLE+19},
	/*  11 */ {1, 1, gaTNUMSIMPLE+21},
};

/**************** NUMNTH ***********************************/

// 16 states

static const unsigned char gaSNUMNTH[] = 
	/* gaStringNUMNTH+0 */	"0123456789\000"
	/* gaStringNUMNTH+11 */	"D\000"
	/* gaStringNUMNTH+13 */	"T\000"
	/* gaStringNUMNTH+15 */	"H\000"
	/* gaStringNUMNTH+17 */	"d\000"
	/* gaStringNUMNTH+19 */	"t\000"
	/* gaStringNUMNTH+21 */	"h\000"
	/* gaStringNUMNTH+23 */	",\000"
	/* gaStringNUMNTH+25 */	"NR\000"
	/* gaStringNUMNTH+28 */	"S\000"
	/* gaStringNUMNTH+30 */	"nr\000"
	/* gaStringNUMNTH+33 */	"s\000"
;

static const STATE_TRANSITION gaTNUMNTH[] = {
	{gaSNUMNTH+0,	10}, // +0: state 0 transitions
	{gaSNUMNTH+0,	15}, // +1: state 1 transitions
	{gaSNUMNTH+0,	3}, // +2: state 2 transitions
	{gaSNUMNTH+0,	1}, // +3: state 3 transitions
	{gaSNUMNTH+11,	13}, // +4: state 4 transitions
	{gaSNUMNTH+13,	13}, // +5: state 5 transitions
	{gaSNUMNTH+15,	13}, // +6: state 6 transitions
	{gaSNUMNTH+17,	13}, // +7: state 7 transitions
	{gaSNUMNTH+19,	13}, // +8: state 8 transitions
	{gaSNUMNTH+21,	13}, // +9: state 9 transitions
	{gaSNUMNTH+23,	2}, // +10: state 10 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	11},
	{gaSNUMNTH+23,	2}, // +18: state 11 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	12},
	{gaSNUMNTH+23,	2}, // +26: state 12 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	14},
	{gaSNUMNTH+25,	4}, // +34: state 14 transitions
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	14},
	{gaSNUMNTH+23,	2}, // +41: state 15 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
};

const STATE_DESCRIPTION aStateDescNUMNTH[16] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNTH+0},
	/*   1 */ {0, 1, gaTNUMNTH+1},
	/*   2 */ {0, 1, gaTNUMNTH+2},
	/*   3 */ {0, 1, gaTNUMNTH+3},
	/*   4 */ {0, 1, gaTNUMNTH+4},
	/*   5 */ {0, 1, gaTNUMNTH+5},
	/*   6 */ {0, 1, gaTNUMNTH+6},
	/*   7 */ {0, 1, gaTNUMNTH+7},
	/*   8 */ {0, 1, gaTNUMNTH+8},
	/*   9 */ {0, 1, gaTNUMNTH+9},
	/*  10 */ {1, 8, gaTNUMNTH+10},
	/*  11 */ {1, 8, gaTNUMNTH+18},
	/*  12 */ {1, 8, gaTNUMNTH+26},
	/*  13 */ {1, 0, NULL},
	/*  14 */ {1, 7, gaTNUMNTH+34},
	/*  15 */ {1, 7, gaTNUMNTH+41},
};

/**************** NUMUNIT ***********************************/

// 25 states

static const unsigned char gaSNUMUNIT[] = 
	/* gaStringNUMUNIT+0 */	"+-\000"
	/* gaStringNUMUNIT+3 */	".\000"
	/* gaStringNUMUNIT+5 */	"0123456789\000"
	/* gaStringNUMUNIT+16 */	"\"'Bb\000"
	/* gaStringNUMUNIT+22 */	",\000"
	/* gaStringNUMUNIT+24 */	"K\000"
	/* gaStringNUMUNIT+26 */	"M\000"
	/* gaStringNUMUNIT+28 */	"Ss\000"
	/* gaStringNUMUNIT+31 */	"c\000"
	/* gaStringNUMUNIT+33 */	"e\000"
	/* gaStringNUMUNIT+35 */	"f\000"
	/* gaStringNUMUNIT+37 */	"i\000"
	/* gaStringNUMUNIT+39 */	"k\000"
	/* gaStringNUMUNIT+41 */	"m\000"
	/* gaStringNUMUNIT+43 */	"BVbm\000"
	/* gaStringNUMUNIT+48 */	"Bb\000"
	/* gaStringNUMUNIT+51 */	"q\000"
	/* gaStringNUMUNIT+53 */	"r\000"
	/* gaStringNUMUNIT+55 */	"t\000"
	/* gaStringNUMUNIT+57 */	"n\000"
	/* gaStringNUMUNIT+59 */	"bmv\000"
	/* gaStringNUMUNIT+63 */	"b\000"
	/* gaStringNUMUNIT+65 */	"s\000"
;

static const STATE_TRANSITION gaTNUMUNIT[] = {
	{gaSNUMUNIT+0,	1}, // +0: state 0 transitions
	{gaSNUMUNIT+3,	2},
	{gaSNUMUNIT+5,	3},
	{gaSNUMUNIT+3,	2}, // +3: state 1 transitions
	{gaSNUMUNIT+5,	3},
	{gaSNUMUNIT+5,	4}, // +5: state 2 transitions
	{gaSNUMUNIT+3,	2}, // +6: state 3 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+5,	7},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	4}, // +19: state 4 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	17}, // +30: state 6 transitions
	{gaSNUMUNIT+3,	2}, // +31: state 7 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	18},
	{gaSNUMUNIT+43,	5}, // +44: state 8 transitions
	{gaSNUMUNIT+48,	5}, // +45: state 9 transitions
	{gaSNUMUNIT+51,	5}, // +46: state 10 transitions
	{gaSNUMUNIT+41,	19}, // +47: state 11 transitions
	{gaSNUMUNIT+53,	20}, // +48: state 12 transitions
	{gaSNUMUNIT+55,	21}, // +49: state 13 transitions
	{gaSNUMUNIT+57,	21}, // +50: state 14 transitions
	{gaSNUMUNIT+59,	5}, // +51: state 15 transitions
	{gaSNUMUNIT+63,	5}, // +52: state 16 transitions
	{gaSNUMUNIT+41,	19},
	{gaSNUMUNIT+5,	22}, // +54: state 17 transitions
	{gaSNUMUNIT+3,	2}, // +55: state 18 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	23},
	{gaSNUMUNIT+3,	5}, // +68: state 19 transitions
	{gaSNUMUNIT+65,	5}, // +69: state 20 transitions
	{gaSNUMUNIT+3,	5}, // +70: state 21 transitions
	{gaSNUMUNIT+5,	24}, // +71: state 22 transitions
	{gaSNUMUNIT+3,	2}, // +72: state 23 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	23},
	{gaSNUMUNIT+16,	5}, // +84: state 24 transitions
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
};

const STATE_DESCRIPTION aStateDescNUMUNIT[25] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMUNIT+0},
	/*   1 */ {0, 2, gaTNUMUNIT+3},
	/*   2 */ {0, 1, gaTNUMUNIT+5},
	/*   3 */ {0, 13, gaTNUMUNIT+6},
	/*   4 */ {0, 11, gaTNUMUNIT+19},
	/*   5 */ {1, 0, NULL},
	/*   6 */ {0, 1, gaTNUMUNIT+30},
	/*   7 */ {0, 13, gaTNUMUNIT+31},
	/*   8 */ {1, 1, gaTNUMUNIT+44},
	/*   9 */ {1, 1, gaTNUMUNIT+45},
	/*  10 */ {0, 1, gaTNUMUNIT+46},
	/*  11 */ {0, 1, gaTNUMUNIT+47},
	/*  12 */ {0, 1, gaTNUMUNIT+48},
	/*  13 */ {0, 1, gaTNUMUNIT+49},
	/*  14 */ {0, 1, gaTNUMUNIT+50},
	/*  15 */ {1, 1, gaTNUMUNIT+51},
	/*  16 */ {1, 2, gaTNUMUNIT+52},
	/*  17 */ {0, 1, gaTNUMUNIT+54},
	/*  18 */ {0, 13, gaTNUMUNIT+55},
	/*  19 */ {1, 1, gaTNUMUNIT+68},
	/*  20 */ {0, 1, gaTNUMUNIT+69},
	/*  21 */ {0, 1, gaTNUMUNIT+70},
	/*  22 */ {0, 1, gaTNUMUNIT+71},
	/*  23 */ {0, 12, gaTNUMUNIT+72},
	/*  24 */ {0, 11, gaTNUMUNIT+84},
};

/**************** NUMNUM ***********************************/

// 10 states

static const unsigned char gaSNUMNUM[] = 
	/* gaStringNUMNUM+0 */	"#\000"
	/* gaStringNUMNUM+2 */	"0123456789\000"
	/* gaStringNUMNUM+13 */	",\000"
;

static const STATE_TRANSITION gaTNUMNUM[] = {
	{gaSNUMNUM+0,	1}, // +0: state 0 transitions
	{gaSNUMNUM+2,	2}, // +1: state 1 transitions
	{gaSNUMNUM+13,	3}, // +2: state 2 transitions
	{gaSNUMNUM+2,	4},
	{gaSNUMNUM+2,	7}, // +4: state 3 transitions
	{gaSNUMNUM+13,	3}, // +5: state 4 transitions
	{gaSNUMNUM+2,	5},
	{gaSNUMNUM+13,	3}, // +7: state 5 transitions
	{gaSNUMNUM+2,	6},
	{gaSNUMNUM+2,	6}, // +9: state 6 transitions
	{gaSNUMNUM+2,	8}, // +10: state 7 transitions
	{gaSNUMNUM+2,	9}, // +11: state 8 transitions
	{gaSNUMNUM+13,	3}, // +12: state 9 transitions
};

const STATE_DESCRIPTION aStateDescNUMNUM[10] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNUM+0},
	/*   1 */ {0, 1, gaTNUMNUM+1},
	/*   2 */ {1, 2, gaTNUMNUM+2},
	/*   3 */ {0, 1, gaTNUMNUM+4},
	/*   4 */ {1, 2, gaTNUMNUM+5},
	/*   5 */ {1, 2, gaTNUMNUM+7},
	/*   6 */ {1, 1, gaTNUMNUM+9},
	/*   7 */ {0, 1, gaTNUMNUM+10},
	/*   8 */ {0, 1, gaTNUMNUM+11},
	/*   9 */ {1, 1, gaTNUMNUM+12},
};

/**************** NUMPERCENT ***********************************/

// 13 states

static const unsigned char gaSNUMPERCENT[] = 
	/* gaStringNUMPERCENT+0 */	"+-\000"
	/* gaStringNUMPERCENT+3 */	".\000"
	/* gaStringNUMPERCENT+5 */	"0123456789\000"
	/* gaStringNUMPERCENT+16 */	"%\000"
	/* gaStringNUMPERCENT+18 */	",\000"
;

static const STATE_TRANSITION gaTNUMPERCENT[] = {
	{gaSNUMPERCENT+0,	1}, // +0: state 0 transitions
	{gaSNUMPERCENT+3,	2},
	{gaSNUMPERCENT+5,	3},
	{gaSNUMPERCENT+3,	2}, // +3: state 1 transitions
	{gaSNUMPERCENT+5,	3},
	{gaSNUMPERCENT+5,	4}, // +5: state 2 transitions
	{gaSNUMPERCENT+3,	2}, // +6: state 3 transitions
	{gaSNUMPERCENT+16,	5},
	{gaSNUMPERCENT+18,	6},
	{gaSNUMPERCENT+5,	7},
	{gaSNUMPERCENT+5,	4}, // +10: state 4 transitions
	{gaSNUMPERCENT+16,	5},
	{gaSNUMPERCENT+5,	8}, // +12: state 6 transitions
	{gaSNUMPERCENT+3,	2}, // +13: state 7 transitions
	{gaSNUMPERCENT+16,	5},
	{gaSNUMPERCENT+18,	6},
	{gaSNUMPERCENT+5,	9},
	{gaSNUMPERCENT+5,	10}, // +17: state 8 transitions
	{gaSNUMPERCENT+3,	2}, // +18: state 9 transitions
	{gaSNUMPERCENT+16,	5},
	{gaSNUMPERCENT+18,	6},
	{gaSNUMPERCENT+5,	11},
	{gaSNUMPERCENT+5,	12}, // +22: state 10 transitions
	{gaSNUMPERCENT+3,	2}, // +23: state 11 transitions
	{gaSNUMPERCENT+16,	5},
	{gaSNUMPERCENT+5,	11},
	{gaSNUMPERCENT+16,	5}, // +26: state 12 transitions
	{gaSNUMPERCENT+18,	6},
};

const STATE_DESCRIPTION aStateDescNUMPERCENT[13] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMPERCENT+0},
	/*   1 */ {0, 2, gaTNUMPERCENT+3},
	/*   2 */ {0, 1, gaTNUMPERCENT+5},
	/*   3 */ {0, 4, gaTNUMPERCENT+6},
	/*   4 */ {0, 2, gaTNUMPERCENT+10},
	/*   5 */ {1, 0, NULL},
	/*   6 */ {0, 1, gaTNUMPERCENT+12},
	/*   7 */ {0, 4, gaTNUMPERCENT+13},
	/*   8 */ {0, 1, gaTNUMPERCENT+17},
	/*   9 */ {0, 4, gaTNUMPERCENT+18},
	/*  10 */ {0, 1, gaTNUMPERCENT+22},
	/*  11 */ {0, 3, gaTNUMPERCENT+23},
	/*  12 */ {0, 2, gaTNUMPERCENT+26},
};

/**************** NUMDATE ***********************************/

// = date

// 111 states

static const unsigned char gaSNUMDATE[] = 
	/* gaStringNUMDATE+0 */	"'\000"
	/* gaStringNUMDATE+2 */	"0\000"
	/* gaStringNUMDATE+4 */	"1\000"
	/* gaStringNUMDATE+6 */	"2\000"
	/* gaStringNUMDATE+8 */	"3\000"
	/* gaStringNUMDATE+10 */	"456789\000"
	/* gaStringNUMDATE+17 */	"A\000"
	/* gaStringNUMDATE+19 */	"D\000"
	/* gaStringNUMDATE+21 */	"F\000"
	/* gaStringNUMDATE+23 */	"J\000"
	/* gaStringNUMDATE+25 */	"M\000"
	/* gaStringNUMDATE+27 */	"N\000"
	/* gaStringNUMDATE+29 */	"O\000"
	/* gaStringNUMDATE+31 */	"S\000"
	/* gaStringNUMDATE+33 */	"T\000"
	/* gaStringNUMDATE+35 */	"W\000"
	/* gaStringNUMDATE+37 */	"0123456789\000"
	/* gaStringNUMDATE+48 */	"123456789\000"
	/* gaStringNUMDATE+58 */	"012\000"
	/* gaStringNUMDATE+62 */	"/\000"
	/* gaStringNUMDATE+64 */	"3456789\000"
	/* gaStringNUMDATE+72 */	"23456789\000"
	/* gaStringNUMDATE+81 */	"01\000"
	/* gaStringNUMDATE+84 */	"P\000"
	/* gaStringNUMDATE+86 */	"U\000"
	/* gaStringNUMDATE+88 */	"p\000"
	/* gaStringNUMDATE+90 */	"u\000"
	/* gaStringNUMDATE+92 */	"E\000"
	/* gaStringNUMDATE+94 */	"e\000"
	/* gaStringNUMDATE+96 */	"r\000"
	/* gaStringNUMDATE+98 */	"a\000"
	/* gaStringNUMDATE+100 */	"o\000"
	/* gaStringNUMDATE+102 */	"C\000"
	/* gaStringNUMDATE+104 */	"c\000"
	/* gaStringNUMDATE+106 */	"h\000"
	/* gaStringNUMDATE+108 */	"R\000"
	/* gaStringNUMDATE+110 */	"G\000"
	/* gaStringNUMDATE+112 */	"g\000"
	/* gaStringNUMDATE+114 */	"B\000"
	/* gaStringNUMDATE+116 */	"b\000"
	/* gaStringNUMDATE+118 */	"i\000"
	/* gaStringNUMDATE+120 */	"LN\000"
	/* gaStringNUMDATE+123 */	"n\000"
	/* gaStringNUMDATE+125 */	"l\000"
	/* gaStringNUMDATE+127 */	"RY\000"
	/* gaStringNUMDATE+130 */	"y\000"
	/* gaStringNUMDATE+132 */	"V\000"
	/* gaStringNUMDATE+134 */	"v\000"
	/* gaStringNUMDATE+136 */	"t\000"
	/* gaStringNUMDATE+138 */	"d\000"
	/* gaStringNUMDATE+140 */	" \000"
	/* gaStringNUMDATE+142 */	",\000"
	/* gaStringNUMDATE+144 */	"s\000"
	/* gaStringNUMDATE+146 */	"-\000"
	/* gaStringNUMDATE+148 */	"12\000"
	/* gaStringNUMDATE+151 */	"m\000"
;

static const STATE_TRANSITION gaTNUMDATE[] = {
	{gaSNUMDATE+0,	1}, // +0: state 0 transitions
	{gaSNUMDATE+2,	2},
	{gaSNUMDATE+4,	3},
	{gaSNUMDATE+6,	4},
	{gaSNUMDATE+8,	5},
	{gaSNUMDATE+10,	6},
	{gaSNUMDATE+17,	7},
	{gaSNUMDATE+19,	8},
	{gaSNUMDATE+21,	9},
	{gaSNUMDATE+23,	10},
	{gaSNUMDATE+25,	11},
	{gaSNUMDATE+27,	12},
	{gaSNUMDATE+29,	13},
	{gaSNUMDATE+31,	14},
	{gaSNUMDATE+33,	15},
	{gaSNUMDATE+35,	16},
	{gaSNUMDATE+37,	17}, // +16: state 1 transitions
	{gaSNUMDATE+2,	18}, // +17: state 2 transitions
	{gaSNUMDATE+48,	19},
	{gaSNUMDATE+58,	19}, // +19: state 3 transitions
	{gaSNUMDATE+62,	20},
	{gaSNUMDATE+64,	21},
	{gaSNUMDATE+62,	20}, // +22: state 4 transitions
	{gaSNUMDATE+37,	21},
	{gaSNUMDATE+72,	18}, // +24: state 5 transitions
	{gaSNUMDATE+62,	20},
	{gaSNUMDATE+81,	21},
	{gaSNUMDATE+37,	18}, // +27: state 6 transitions
	{gaSNUMDATE+62,	20},
	{gaSNUMDATE+84,	22}, // +29: state 7 transitions
	{gaSNUMDATE+86,	23},
	{gaSNUMDATE+88,	24},
	{gaSNUMDATE+90,	25},
	{gaSNUMDATE+92,	26}, // +33: state 8 transitions
	{gaSNUMDATE+94,	27},
	{gaSNUMDATE+92,	28}, // +35: state 9 transitions
	{gaSNUMDATE+94,	29},
	{gaSNUMDATE+96,	30},
	{gaSNUMDATE+17,	31}, // +38: state 10 transitions
	{gaSNUMDATE+86,	32},
	{gaSNUMDATE+98,	33},
	{gaSNUMDATE+90,	34},
	{gaSNUMDATE+17,	35}, // +42: state 11 transitions
	{gaSNUMDATE+98,	36},
	{gaSNUMDATE+100,	37},
	{gaSNUMDATE+29,	38}, // +45: state 12 transitions
	{gaSNUMDATE+100,	39},
	{gaSNUMDATE+102,	40}, // +47: state 13 transitions
	{gaSNUMDATE+104,	41},
	{gaSNUMDATE+90,	37}, // +49: state 14 transitions
	{gaSNUMDATE+92,	42},
	{gaSNUMDATE+98,	43},
	{gaSNUMDATE+94,	44},
	{gaSNUMDATE+106,	45}, // +53: state 15 transitions
	{gaSNUMDATE+90,	46},
	{gaSNUMDATE+94,	47}, // +55: state 16 transitions
	{gaSNUMDATE+37,	48}, // +56: state 17 transitions
	{gaSNUMDATE+37,	49}, // +57: state 18 transitions
	{gaSNUMDATE+62,	20}, // +58: state 19 transitions
	{gaSNUMDATE+37,	49},
	{gaSNUMDATE+2,	50}, // +60: state 20 transitions
	{gaSNUMDATE+4,	51},
	{gaSNUMDATE+72,	52},
	{gaSNUMDATE+37,	49}, // +63: state 21 transitions
	{gaSNUMDATE+62,	53},
	{gaSNUMDATE+108,	54}, // +65: state 22 transitions
	{gaSNUMDATE+110,	54}, // +66: state 23 transitions
	{gaSNUMDATE+96,	55}, // +67: state 24 transitions
	{gaSNUMDATE+112,	56}, // +68: state 25 transitions
	{gaSNUMDATE+102,	54}, // +69: state 26 transitions
	{gaSNUMDATE+104,	57}, // +70: state 27 transitions
	{gaSNUMDATE+114,	54}, // +71: state 28 transitions
	{gaSNUMDATE+116,	58}, // +72: state 29 transitions
	{gaSNUMDATE+118,	59}, // +73: state 30 transitions
	{gaSNUMDATE+27,	54}, // +74: state 31 transitions
	{gaSNUMDATE+120,	54}, // +75: state 32 transitions
	{gaSNUMDATE+123,	60}, // +76: state 33 transitions
	{gaSNUMDATE+125,	61}, // +77: state 34 transitions
	{gaSNUMDATE+123,	62},
	{gaSNUMDATE+127,	54}, // +79: state 35 transitions
	{gaSNUMDATE+130,	54}, // +80: state 36 transitions
	{gaSNUMDATE+96,	63},
	{gaSNUMDATE+123,	59}, // +82: state 37 transitions
	{gaSNUMDATE+132,	54}, // +83: state 38 transitions
	{gaSNUMDATE+134,	57}, // +84: state 39 transitions
	{gaSNUMDATE+33,	54}, // +85: state 40 transitions
	{gaSNUMDATE+136,	64}, // +86: state 41 transitions
	{gaSNUMDATE+84,	54}, // +87: state 42 transitions
	{gaSNUMDATE+136,	65}, // +88: state 43 transitions
	{gaSNUMDATE+88,	66}, // +89: state 44 transitions
	{gaSNUMDATE+90,	67}, // +90: state 45 transitions
	{gaSNUMDATE+94,	68}, // +91: state 46 transitions
	{gaSNUMDATE+138,	69}, // +92: state 47 transitions
	{gaSNUMDATE+37,	70}, // +93: state 49 transitions
	{gaSNUMDATE+2,	71}, // +94: state 50 transitions
	{gaSNUMDATE+48,	72},
	{gaSNUMDATE+64,	71}, // +96: state 51 transitions
	{gaSNUMDATE+58,	72},
	{gaSNUMDATE+62,	73},
	{gaSNUMDATE+37,	71}, // +99: state 52 transitions
	{gaSNUMDATE+62,	73},
	{gaSNUMDATE+2,	74}, // +101: state 53 transitions
	{gaSNUMDATE+4,	75},
	{gaSNUMDATE+72,	76},
	{gaSNUMDATE+140,	77}, // +104: state 54 transitions
	{gaSNUMDATE+140,	77}, // +105: state 55 transitions
	{gaSNUMDATE+118,	78},
	{gaSNUMDATE+140,	77}, // +107: state 56 transitions
	{gaSNUMDATE+90,	79},
	{gaSNUMDATE+140,	77}, // +109: state 57 transitions
	{gaSNUMDATE+94,	80},
	{gaSNUMDATE+140,	77}, // +111: state 58 transitions
	{gaSNUMDATE+96,	81},
	{gaSNUMDATE+142,	82}, // +113: state 59 transitions
	{gaSNUMDATE+138,	83},
	{gaSNUMDATE+140,	77}, // +115: state 60 transitions
	{gaSNUMDATE+90,	84},
	{gaSNUMDATE+130,	54}, // +117: state 61 transitions
	{gaSNUMDATE+140,	77},
	{gaSNUMDATE+94,	54}, // +119: state 62 transitions
	{gaSNUMDATE+140,	77},
	{gaSNUMDATE+140,	77}, // +121: state 63 transitions
	{gaSNUMDATE+104,	85},
	{gaSNUMDATE+140,	77}, // +123: state 64 transitions
	{gaSNUMDATE+100,	86},
	{gaSNUMDATE+142,	82}, // +125: state 65 transitions
	{gaSNUMDATE+90,	87},
	{gaSNUMDATE+140,	77}, // +127: state 66 transitions
	{gaSNUMDATE+136,	88},
	{gaSNUMDATE+142,	82}, // +129: state 67 transitions
	{gaSNUMDATE+96,	89},
	{gaSNUMDATE+142,	82}, // +131: state 68 transitions
	{gaSNUMDATE+144,	90},
	{gaSNUMDATE+142,	82}, // +133: state 69 transitions
	{gaSNUMDATE+123,	91},
	{gaSNUMDATE+146,	92}, // +135: state 70 transitions
	{gaSNUMDATE+37,	17}, // +136: state 71 transitions
	{gaSNUMDATE+37,	17}, // +137: state 72 transitions
	{gaSNUMDATE+62,	73},
	{gaSNUMDATE+37,	93}, // +139: state 73 transitions
	{gaSNUMDATE+48,	76}, // +140: state 74 transitions
	{gaSNUMDATE+62,	73}, // +141: state 75 transitions
	{gaSNUMDATE+58,	76},
	{gaSNUMDATE+62,	73}, // +143: state 76 transitions
	{gaSNUMDATE+2,	94}, // +144: state 77 transitions
	{gaSNUMDATE+148,	95},
	{gaSNUMDATE+8,	96},
	{gaSNUMDATE+10,	97},
	{gaSNUMDATE+125,	54}, // +148: state 78 transitions
	{gaSNUMDATE+144,	98}, // +149: state 79 transitions
	{gaSNUMDATE+151,	86}, // +150: state 80 transitions
	{gaSNUMDATE+90,	84}, // +151: state 81 transitions
	{gaSNUMDATE+140,	99}, // +152: state 82 transitions
	{gaSNUMDATE+98,	100}, // +153: state 83 transitions
	{gaSNUMDATE+98,	101}, // +154: state 84 transitions
	{gaSNUMDATE+106,	54}, // +155: state 85 transitions
	{gaSNUMDATE+116,	102}, // +156: state 86 transitions
	{gaSNUMDATE+96,	90}, // +157: state 87 transitions
	{gaSNUMDATE+94,	80}, // +158: state 88 transitions
	{gaSNUMDATE+144,	90}, // +159: state 89 transitions
	{gaSNUMDATE+138,	83}, // +160: state 90 transitions
	{gaSNUMDATE+94,	89}, // +161: state 91 transitions
	{gaSNUMDATE+37,	103}, // +162: state 92 transitions
	{gaSNUMDATE+37,	71}, // +163: state 93 transitions
	{gaSNUMDATE+48,	97}, // +164: state 94 transitions
	{gaSNUMDATE+37,	97}, // +165: state 95 transitions
	{gaSNUMDATE+142,	104},
	{gaSNUMDATE+81,	97}, // +167: state 96 transitions
	{gaSNUMDATE+142,	104},
	{gaSNUMDATE+142,	104}, // +169: state 97 transitions
	{gaSNUMDATE+136,	54}, // +170: state 98 transitions
	{gaSNUMDATE+17,	7}, // +171: state 99 transitions
	{gaSNUMDATE+19,	8},
	{gaSNUMDATE+23,	10},
	{gaSNUMDATE+27,	12},
	{gaSNUMDATE+29,	13},
	{gaSNUMDATE+21,	105},
	{gaSNUMDATE+25,	106},
	{gaSNUMDATE+31,	107},
	{gaSNUMDATE+130,	108}, // +179: state 100 transitions
	{gaSNUMDATE+96,	109}, // +180: state 101 transitions
	{gaSNUMDATE+94,	110}, // +181: state 102 transitions
	{gaSNUMDATE+37,	1}, // +182: state 103 transitions
	{gaSNUMDATE+140,	92}, // +183: state 104 transitions
	{gaSNUMDATE+92,	28}, // +184: state 105 transitions
	{gaSNUMDATE+94,	29},
	{gaSNUMDATE+17,	35}, // +186: state 106 transitions
	{gaSNUMDATE+98,	36},
	{gaSNUMDATE+92,	42}, // +188: state 107 transitions
	{gaSNUMDATE+94,	44},
	{gaSNUMDATE+142,	82}, // +190: state 108 transitions
	{gaSNUMDATE+130,	54}, // +191: state 109 transitions
	{gaSNUMDATE+96,	54}, // +192: state 110 transitions
};

const STATE_DESCRIPTION aStateDescNUMDATE[111] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 16, gaTNUMDATE+0},
	/*   1 */ {0, 1, gaTNUMDATE+16},
	/*   2 */ {0, 2, gaTNUMDATE+17},
	/*   3 */ {0, 3, gaTNUMDATE+19},
	/*   4 */ {0, 2, gaTNUMDATE+22},
	/*   5 */ {0, 3, gaTNUMDATE+24},
	/*   6 */ {0, 2, gaTNUMDATE+27},
	/*   7 */ {0, 4, gaTNUMDATE+29},
	/*   8 */ {0, 2, gaTNUMDATE+33},
	/*   9 */ {0, 3, gaTNUMDATE+35},
	/*  10 */ {0, 4, gaTNUMDATE+38},
	/*  11 */ {0, 3, gaTNUMDATE+42},
	/*  12 */ {0, 2, gaTNUMDATE+45},
	/*  13 */ {0, 2, gaTNUMDATE+47},
	/*  14 */ {0, 4, gaTNUMDATE+49},
	/*  15 */ {0, 2, gaTNUMDATE+53},
	/*  16 */ {0, 1, gaTNUMDATE+55},
	/*  17 */ {0, 1, gaTNUMDATE+56},
	/*  18 */ {0, 1, gaTNUMDATE+57},
	/*  19 */ {0, 2, gaTNUMDATE+58},
	/*  20 */ {0, 3, gaTNUMDATE+60},
	/*  21 */ {0, 2, gaTNUMDATE+63},
	/*  22 */ {0, 1, gaTNUMDATE+65},
	/*  23 */ {0, 1, gaTNUMDATE+66},
	/*  24 */ {0, 1, gaTNUMDATE+67},
	/*  25 */ {0, 1, gaTNUMDATE+68},
	/*  26 */ {0, 1, gaTNUMDATE+69},
	/*  27 */ {0, 1, gaTNUMDATE+70},
	/*  28 */ {0, 1, gaTNUMDATE+71},
	/*  29 */ {0, 1, gaTNUMDATE+72},
	/*  30 */ {0, 1, gaTNUMDATE+73},
	/*  31 */ {0, 1, gaTNUMDATE+74},
	/*  32 */ {0, 1, gaTNUMDATE+75},
	/*  33 */ {0, 1, gaTNUMDATE+76},
	/*  34 */ {0, 2, gaTNUMDATE+77},
	/*  35 */ {0, 1, gaTNUMDATE+79},
	/*  36 */ {0, 2, gaTNUMDATE+80},
	/*  37 */ {0, 1, gaTNUMDATE+82},
	/*  38 */ {0, 1, gaTNUMDATE+83},
	/*  39 */ {0, 1, gaTNUMDATE+84},
	/*  40 */ {0, 1, gaTNUMDATE+85},
	/*  41 */ {0, 1, gaTNUMDATE+86},
	/*  42 */ {0, 1, gaTNUMDATE+87},
	/*  43 */ {0, 1, gaTNUMDATE+88},
	/*  44 */ {0, 1, gaTNUMDATE+89},
	/*  45 */ {0, 1, gaTNUMDATE+90},
	/*  46 */ {0, 1, gaTNUMDATE+91},
	/*  47 */ {0, 1, gaTNUMDATE+92},
	/*  48 */ {1, 0, NULL},
	/*  49 */ {0, 1, gaTNUMDATE+93},
	/*  50 */ {0, 2, gaTNUMDATE+94},
	/*  51 */ {1, 3, gaTNUMDATE+96},
	/*  52 */ {1, 2, gaTNUMDATE+99},
	/*  53 */ {0, 3, gaTNUMDATE+101},
	/*  54 */ {0, 1, gaTNUMDATE+104},
	/*  55 */ {0, 2, gaTNUMDATE+105},
	/*  56 */ {0, 2, gaTNUMDATE+107},
	/*  57 */ {0, 2, gaTNUMDATE+109},
	/*  58 */ {0, 2, gaTNUMDATE+111},
	/*  59 */ {0, 2, gaTNUMDATE+113},
	/*  60 */ {0, 2, gaTNUMDATE+115},
	/*  61 */ {0, 2, gaTNUMDATE+117},
	/*  62 */ {0, 2, gaTNUMDATE+119},
	/*  63 */ {0, 2, gaTNUMDATE+121},
	/*  64 */ {0, 2, gaTNUMDATE+123},
	/*  65 */ {0, 2, gaTNUMDATE+125},
	/*  66 */ {0, 2, gaTNUMDATE+127},
	/*  67 */ {0, 2, gaTNUMDATE+129},
	/*  68 */ {0, 2, gaTNUMDATE+131},
	/*  69 */ {0, 2, gaTNUMDATE+133},
	/*  70 */ {1, 1, gaTNUMDATE+135},
	/*  71 */ {1, 1, gaTNUMDATE+136},
	/*  72 */ {1, 2, gaTNUMDATE+137},
	/*  73 */ {0, 1, gaTNUMDATE+139},
	/*  74 */ {0, 1, gaTNUMDATE+140},
	/*  75 */ {1, 2, gaTNUMDATE+141},
	/*  76 */ {1, 1, gaTNUMDATE+143},
	/*  77 */ {0, 4, gaTNUMDATE+144},
	/*  78 */ {0, 1, gaTNUMDATE+148},
	/*  79 */ {0, 1, gaTNUMDATE+149},
	/*  80 */ {0, 1, gaTNUMDATE+150},
	/*  81 */ {0, 1, gaTNUMDATE+151},
	/*  82 */ {0, 1, gaTNUMDATE+152},
	/*  83 */ {0, 1, gaTNUMDATE+153},
	/*  84 */ {0, 1, gaTNUMDATE+154},
	/*  85 */ {0, 1, gaTNUMDATE+155},
	/*  86 */ {0, 1, gaTNUMDATE+156},
	/*  87 */ {0, 1, gaTNUMDATE+157},
	/*  88 */ {0, 1, gaTNUMDATE+158},
	/*  89 */ {0, 1, gaTNUMDATE+159},
	/*  90 */ {0, 1, gaTNUMDATE+160},
	/*  91 */ {0, 1, gaTNUMDATE+161},
	/*  92 */ {0, 1, gaTNUMDATE+162},
	/*  93 */ {0, 1, gaTNUMDATE+163},
	/*  94 */ {0, 1, gaTNUMDATE+164},
	/*  95 */ {1, 2, gaTNUMDATE+165},
	/*  96 */ {1, 2, gaTNUMDATE+167},
	/*  97 */ {1, 1, gaTNUMDATE+169},
	/*  98 */ {0, 1, gaTNUMDATE+170},
	/*  99 */ {0, 8, gaTNUMDATE+171},
	/* 100 */ {0, 1, gaTNUMDATE+179},
	/* 101 */ {0, 1, gaTNUMDATE+180},
	/* 102 */ {0, 1, gaTNUMDATE+181},
	/* 103 */ {0, 1, gaTNUMDATE+182},
	/* 104 */ {0, 1, gaTNUMDATE+183},
	/* 105 */ {0, 2, gaTNUMDATE+184},
	/* 106 */ {0, 2, gaTNUMDATE+186},
	/* 107 */ {0, 2, gaTNUMDATE+188},
	/* 108 */ {0, 1, gaTNUMDATE+190},
	/* 109 */ {0, 1, gaTNUMDATE+191},
	/* 110 */ {0, 1, gaTNUMDATE+192},
};

/**************** NUMTIME ***********************************/

// 23 states

static const unsigned char gaSNUMTIME[] = 
	/* gaStringNUMTIME+0 */	"0\000"
	/* gaStringNUMTIME+2 */	"1\000"
	/* gaStringNUMTIME+4 */	"2\000"
	/* gaStringNUMTIME+6 */	"345\000"
	/* gaStringNUMTIME+10 */	"6789\000"
	/* gaStringNUMTIME+15 */	"123456789\000"
	/* gaStringNUMTIME+25 */	":\000"
	/* gaStringNUMTIME+27 */	"012\000"
	/* gaStringNUMTIME+31 */	"3456789\000"
	/* gaStringNUMTIME+39 */	"0123\000"
	/* gaStringNUMTIME+44 */	"456789\000"
	/* gaStringNUMTIME+51 */	"0123456789\000"
	/* gaStringNUMTIME+62 */	"012345\000"
	/* gaStringNUMTIME+69 */	" \000"
	/* gaStringNUMTIME+71 */	"AP\000"
	/* gaStringNUMTIME+74 */	"ap\000"
	/* gaStringNUMTIME+77 */	"M\000"
	/* gaStringNUMTIME+79 */	"m\000"
;

static const STATE_TRANSITION gaTNUMTIME[] = {
	{gaSNUMTIME+0,	1}, // +0: state 0 transitions
	{gaSNUMTIME+2,	2},
	{gaSNUMTIME+4,	3},
	{gaSNUMTIME+6,	4},
	{gaSNUMTIME+10,	5},
	{gaSNUMTIME+15,	5}, // +5: state 1 transitions
	{gaSNUMTIME+0,	6},
	{gaSNUMTIME+25,	7},
	{gaSNUMTIME+27,	5}, // +8: state 2 transitions
	{gaSNUMTIME+31,	6},
	{gaSNUMTIME+25,	8},
	{gaSNUMTIME+39,	6}, // +11: state 3 transitions
	{gaSNUMTIME+25,	8},
	{gaSNUMTIME+44,	9},
	{gaSNUMTIME+25,	8}, // +14: state 4 transitions
	{gaSNUMTIME+51,	9},
	{gaSNUMTIME+25,	8}, // +16: state 5 transitions
	{gaSNUMTIME+25,	7}, // +17: state 6 transitions
	{gaSNUMTIME+62,	10}, // +18: state 7 transitions
	{gaSNUMTIME+62,	11}, // +19: state 8 transitions
	{gaSNUMTIME+25,	12}, // +20: state 9 transitions
	{gaSNUMTIME+51,	13}, // +21: state 10 transitions
	{gaSNUMTIME+51,	14}, // +22: state 11 transitions
	{gaSNUMTIME+62,	15}, // +23: state 12 transitions
	{gaSNUMTIME+25,	12}, // +24: state 13 transitions
	{gaSNUMTIME+69,	16}, // +25: state 14 transitions
	{gaSNUMTIME+25,	17},
	{gaSNUMTIME+51,	18}, // +27: state 15 transitions
	{gaSNUMTIME+71,	19}, // +28: state 16 transitions
	{gaSNUMTIME+74,	20},
	{gaSNUMTIME+62,	21}, // +30: state 17 transitions
	{gaSNUMTIME+77,	18}, // +31: state 19 transitions
	{gaSNUMTIME+79,	18}, // +32: state 20 transitions
	{gaSNUMTIME+51,	22}, // +33: state 21 transitions
	{gaSNUMTIME+69,	16}, // +34: state 22 transitions
};

const STATE_DESCRIPTION aStateDescNUMTIME[23] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTNUMTIME+0},
	/*   1 */ {0, 3, gaTNUMTIME+5},
	/*   2 */ {0, 3, gaTNUMTIME+8},
	/*   3 */ {0, 3, gaTNUMTIME+11},
	/*   4 */ {0, 2, gaTNUMTIME+14},
	/*   5 */ {0, 1, gaTNUMTIME+16},
	/*   6 */ {0, 1, gaTNUMTIME+17},
	/*   7 */ {0, 1, gaTNUMTIME+18},
	/*   8 */ {0, 1, gaTNUMTIME+19},
	/*   9 */ {0, 1, gaTNUMTIME+20},
	/*  10 */ {0, 1, gaTNUMTIME+21},
	/*  11 */ {0, 1, gaTNUMTIME+22},
	/*  12 */ {0, 1, gaTNUMTIME+23},
	/*  13 */ {1, 1, gaTNUMTIME+24},
	/*  14 */ {1, 2, gaTNUMTIME+25},
	/*  15 */ {0, 1, gaTNUMTIME+27},
	/*  16 */ {0, 2, gaTNUMTIME+28},
	/*  17 */ {0, 1, gaTNUMTIME+30},
	/*  18 */ {1, 0, NULL},
	/*  19 */ {0, 1, gaTNUMTIME+31},
	/*  20 */ {0, 1, gaTNUMTIME+32},
	/*  21 */ {0, 1, gaTNUMTIME+33},
	/*  22 */ {1, 1, gaTNUMTIME+34},
};

/**************** NUMCURRENCY ***********************************/

// 25 states

static const unsigned char gaSNUMCURRENCY[] = 
	/* gaStringNUMCURRENCY+0 */	"$\000"
	/* gaStringNUMCURRENCY+4 */	"0123456789\000"
	/* gaStringNUMCURRENCY+15 */	"\000"
	/* gaStringNUMCURRENCY+17 */	".\000"
	/* gaStringNUMCURRENCY+19 */	"p\000"
	/* gaStringNUMCURRENCY+22 */	"km\000"
	/* gaStringNUMCURRENCY+25 */	",\000"
	/* gaStringNUMCURRENCY+27 */	"kmp\000"
;

static const STATE_TRANSITION gaTNUMCURRENCY[] = {
	{gaSNUMCURRENCY+0,	1}, // +0: state 0 transitions
	{gaSNUMCURRENCY+4,	2},
	{gaSNUMCURRENCY+15,	3},
	{gaSNUMCURRENCY+17,	4}, // +3: state 1 transitions
	{gaSNUMCURRENCY+4,	5},
	{gaSNUMCURRENCY+4,	6}, // +5: state 2 transitions
	{gaSNUMCURRENCY+19,	7},
	{gaSNUMCURRENCY+17,	4}, // +7: state 3 transitions
	{gaSNUMCURRENCY+4,	8},
	{gaSNUMCURRENCY+4,	9}, // +9: state 4 transitions
	{gaSNUMCURRENCY+22,	7}, // +10: state 5 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	11},
	{gaSNUMCURRENCY+4,	12},
	{gaSNUMCURRENCY+19,	7}, // +14: state 6 transitions
	{gaSNUMCURRENCY+22,	7}, // +15: state 8 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	13},
	{gaSNUMCURRENCY+4,	14},
	{gaSNUMCURRENCY+4,	15}, // +19: state 9 transitions
	{gaSNUMCURRENCY+4,	16}, // +20: state 10 transitions
	{gaSNUMCURRENCY+22,	7}, // +21: state 11 transitions
	{gaSNUMCURRENCY+4,	9},
	{gaSNUMCURRENCY+22,	7}, // +23: state 12 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	11},
	{gaSNUMCURRENCY+4,	17},
	{gaSNUMCURRENCY+22,	7}, // +27: state 13 transitions
	{gaSNUMCURRENCY+4,	18},
	{gaSNUMCURRENCY+22,	7}, // +29: state 14 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	13},
	{gaSNUMCURRENCY+4,	19},
	{gaSNUMCURRENCY+22,	7}, // +33: state 15 transitions
	{gaSNUMCURRENCY+4,	20}, // +34: state 16 transitions
	{gaSNUMCURRENCY+22,	7}, // +35: state 17 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	11},
	{gaSNUMCURRENCY+4,	21},
	{gaSNUMCURRENCY+4,	22}, // +39: state 18 transitions
	{gaSNUMCURRENCY+22,	7}, // +40: state 19 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	13},
	{gaSNUMCURRENCY+4,	23},
	{gaSNUMCURRENCY+4,	24}, // +44: state 20 transitions
	{gaSNUMCURRENCY+22,	7}, // +45: state 21 transitions
	{gaSNUMCURRENCY+17,	11},
	{gaSNUMCURRENCY+4,	21},
	{gaSNUMCURRENCY+27,	7}, // +48: state 22 transitions
	{gaSNUMCURRENCY+22,	7}, // +49: state 23 transitions
	{gaSNUMCURRENCY+17,	13},
	{gaSNUMCURRENCY+4,	23},
	{gaSNUMCURRENCY+22,	7}, // +52: state 24 transitions
	{gaSNUMCURRENCY+25,	10},
	{gaSNUMCURRENCY+17,	11},
};

const STATE_DESCRIPTION aStateDescNUMCURRENCY[25] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMCURRENCY+0},
	/*   1 */ {0, 2, gaTNUMCURRENCY+3},
	/*   2 */ {0, 2, gaTNUMCURRENCY+5},
	/*   3 */ {0, 2, gaTNUMCURRENCY+7},
	/*   4 */ {0, 1, gaTNUMCURRENCY+9},
	/*   5 */ {1, 4, gaTNUMCURRENCY+10},
	/*   6 */ {0, 1, gaTNUMCURRENCY+14},
	/*   7 */ {1, 0, NULL},
	/*   8 */ {1, 4, gaTNUMCURRENCY+15},
	/*   9 */ {0, 1, gaTNUMCURRENCY+19},
	/*  10 */ {0, 1, gaTNUMCURRENCY+20},
	/*  11 */ {1, 2, gaTNUMCURRENCY+21},
	/*  12 */ {1, 4, gaTNUMCURRENCY+23},
	/*  13 */ {1, 2, gaTNUMCURRENCY+27},
	/*  14 */ {1, 4, gaTNUMCURRENCY+29},
	/*  15 */ {1, 1, gaTNUMCURRENCY+33},
	/*  16 */ {0, 1, gaTNUMCURRENCY+34},
	/*  17 */ {1, 4, gaTNUMCURRENCY+35},
	/*  18 */ {0, 1, gaTNUMCURRENCY+39},
	/*  19 */ {1, 4, gaTNUMCURRENCY+40},
	/*  20 */ {0, 1, gaTNUMCURRENCY+44},
	/*  21 */ {1, 3, gaTNUMCURRENCY+45},
	/*  22 */ {1, 1, gaTNUMCURRENCY+48},
	/*  23 */ {1, 3, gaTNUMCURRENCY+49},
	/*  24 */ {1, 3, gaTNUMCURRENCY+52},
};

/**************** NUMPHONE ***********************************/

// 9 states

static const unsigned char gaSNUMPHONE[] = 
	/* gaStringNUMPHONE+0 */	"(\000"
	/* gaStringNUMPHONE+2 */	"+\000"
	/* gaStringNUMPHONE+4 */	"0123456789\000"
	/* gaStringNUMPHONE+15 */	"-.\000"
	/* gaStringNUMPHONE+18 */	" \000"
	/* gaStringNUMPHONE+20 */	")\000"
	/* gaStringNUMPHONE+22 */	" -.\000"
;

static const STATE_TRANSITION gaTNUMPHONE[] = {
	{gaSNUMPHONE+0,	1}, // +0: state 0 transitions
	{gaSNUMPHONE+2,	2},
	{gaSNUMPHONE+4,	3},
	{gaSNUMPHONE+4,	4}, // +3: state 1 transitions
	{gaSNUMPHONE+4,	3}, // +4: state 2 transitions
	{gaSNUMPHONE+0,	1}, // +5: state 3 transitions
	{gaSNUMPHONE+15,	2},
	{gaSNUMPHONE+4,	3},
	{gaSNUMPHONE+18,	5},
	{gaSNUMPHONE+4,	4}, // +9: state 4 transitions
	{gaSNUMPHONE+20,	6},
	{gaSNUMPHONE+0,	1}, // +11: state 5 transitions
	{gaSNUMPHONE+4,	3},
	{gaSNUMPHONE+18,	7}, // +13: state 6 transitions
	{gaSNUMPHONE+4,	8},
	{gaSNUMPHONE+4,	8}, // +15: state 7 transitions
	{gaSNUMPHONE+22,	7}, // +16: state 8 transitions
	{gaSNUMPHONE+4,	8},
};

const STATE_DESCRIPTION aStateDescNUMPHONE[9] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMPHONE+0},
	/*   1 */ {0, 1, gaTNUMPHONE+3},
	/*   2 */ {0, 1, gaTNUMPHONE+4},
	/*   3 */ {1, 4, gaTNUMPHONE+5},
	/*   4 */ {0, 2, gaTNUMPHONE+9},
	/*   5 */ {0, 2, gaTNUMPHONE+11},
	/*   6 */ {0, 2, gaTNUMPHONE+13},
	/*   7 */ {0, 1, gaTNUMPHONE+15},
	/*   8 */ {1, 2, gaTNUMPHONE+16},
};

/**************** NUMMATH ***********************************/

// 148 states

static const unsigned char gaSNUMMATH[] = 
	/* gaStringNUMMATH+0 */	"(\000"
	/* gaStringNUMMATH+2 */	"+-\000"
	/* gaStringNUMMATH+5 */	".\000"
	/* gaStringNUMMATH+7 */	"0123456789\000"
	/* gaStringNUMMATH+18 */	"*+-/\000"
	/* gaStringNUMMATH+23 */	",\000"
	/* gaStringNUMMATH+25 */	"<=>\000"
	/* gaStringNUMMATH+29 */	")\000"
;

static const STATE_TRANSITION gaTNUMMATH[] = {
	{gaSNUMMATH+0,	1}, // +0: state 0 transitions
	{gaSNUMMATH+2,	2},
	{gaSNUMMATH+5,	3},
	{gaSNUMMATH+7,	4},
	{gaSNUMMATH+2,	124}, // +4: state 1 transitions
	{gaSNUMMATH+5,	125},
	{gaSNUMMATH+7,	126},
	{gaSNUMMATH+5,	3}, // +7: state 2 transitions
	{gaSNUMMATH+7,	4},
	{gaSNUMMATH+7,	123}, // +9: state 3 transitions
	{gaSNUMMATH+5,	3}, // +10: state 4 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+7,	7},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+0,	87}, // +15: state 5 transitions
	{gaSNUMMATH+2,	88},
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+7,	90},
	{gaSNUMMATH+7,	84}, // +19: state 6 transitions
	{gaSNUMMATH+5,	3}, // +20: state 7 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	82},
	{gaSNUMMATH+0,	9}, // +25: state 8 transitions
	{gaSNUMMATH+2,	10},
	{gaSNUMMATH+5,	11},
	{gaSNUMMATH+7,	12},
	{gaSNUMMATH+2,	58}, // +29: state 9 transitions
	{gaSNUMMATH+5,	59},
	{gaSNUMMATH+7,	60},
	{gaSNUMMATH+5,	11}, // +32: state 10 transitions
	{gaSNUMMATH+7,	12},
	{gaSNUMMATH+7,	57}, // +34: state 11 transitions
	{gaSNUMMATH+5,	11}, // +35: state 12 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+7,	15},
	{gaSNUMMATH+0,	21}, // +39: state 13 transitions
	{gaSNUMMATH+2,	22},
	{gaSNUMMATH+5,	23},
	{gaSNUMMATH+7,	24},
	{gaSNUMMATH+7,	18}, // +43: state 14 transitions
	{gaSNUMMATH+5,	11}, // +44: state 15 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+7,	16},
	{gaSNUMMATH+5,	11}, // +48: state 16 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+7,	17},
	{gaSNUMMATH+5,	11}, // +52: state 17 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+7,	17},
	{gaSNUMMATH+7,	19}, // +55: state 18 transitions
	{gaSNUMMATH+7,	20}, // +56: state 19 transitions
	{gaSNUMMATH+5,	11}, // +57: state 20 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+2,	33}, // +60: state 21 transitions
	{gaSNUMMATH+5,	34},
	{gaSNUMMATH+7,	35},
	{gaSNUMMATH+5,	23}, // +63: state 22 transitions
	{gaSNUMMATH+7,	24},
	{gaSNUMMATH+7,	32}, // +65: state 23 transitions
	{gaSNUMMATH+5,	23}, // +66: state 24 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	26},
	{gaSNUMMATH+7,	29}, // +69: state 25 transitions
	{gaSNUMMATH+5,	23}, // +70: state 26 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	27},
	{gaSNUMMATH+5,	23}, // +73: state 27 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	28},
	{gaSNUMMATH+5,	23}, // +76: state 28 transitions
	{gaSNUMMATH+7,	28},
	{gaSNUMMATH+7,	30}, // +78: state 29 transitions
	{gaSNUMMATH+7,	31}, // +79: state 30 transitions
	{gaSNUMMATH+5,	23}, // +80: state 31 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	32}, // +82: state 32 transitions
	{gaSNUMMATH+5,	34}, // +83: state 33 transitions
	{gaSNUMMATH+7,	35},
	{gaSNUMMATH+7,	56}, // +85: state 34 transitions
	{gaSNUMMATH+5,	34}, // +86: state 35 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+7,	38},
	{gaSNUMMATH+2,	44}, // +90: state 36 transitions
	{gaSNUMMATH+5,	45},
	{gaSNUMMATH+7,	46},
	{gaSNUMMATH+7,	41}, // +93: state 37 transitions
	{gaSNUMMATH+5,	34}, // +94: state 38 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+7,	39},
	{gaSNUMMATH+5,	34}, // +98: state 39 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+7,	40},
	{gaSNUMMATH+5,	34}, // +102: state 40 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+7,	40},
	{gaSNUMMATH+7,	42}, // +105: state 41 transitions
	{gaSNUMMATH+7,	43}, // +106: state 42 transitions
	{gaSNUMMATH+5,	34}, // +107: state 43 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+5,	45}, // +110: state 44 transitions
	{gaSNUMMATH+7,	46},
	{gaSNUMMATH+7,	55}, // +112: state 45 transitions
	{gaSNUMMATH+5,	45}, // +113: state 46 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+7,	49},
	{gaSNUMMATH+7,	52}, // +117: state 48 transitions
	{gaSNUMMATH+5,	45}, // +118: state 49 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+7,	50},
	{gaSNUMMATH+5,	45}, // +122: state 50 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+7,	51},
	{gaSNUMMATH+5,	45}, // +126: state 51 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+7,	51},
	{gaSNUMMATH+7,	53}, // +129: state 52 transitions
	{gaSNUMMATH+7,	54}, // +130: state 53 transitions
	{gaSNUMMATH+5,	45}, // +131: state 54 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+29,	47}, // +134: state 55 transitions
	{gaSNUMMATH+7,	55},
	{gaSNUMMATH+18,	36}, // +136: state 56 transitions
	{gaSNUMMATH+7,	56},
	{gaSNUMMATH+18,	13}, // +138: state 57 transitions
	{gaSNUMMATH+7,	57},
	{gaSNUMMATH+5,	59}, // +140: state 58 transitions
	{gaSNUMMATH+7,	60},
	{gaSNUMMATH+7,	81}, // +142: state 59 transitions
	{gaSNUMMATH+5,	59}, // +143: state 60 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+7,	63},
	{gaSNUMMATH+2,	69}, // +147: state 61 transitions
	{gaSNUMMATH+5,	70},
	{gaSNUMMATH+7,	71},
	{gaSNUMMATH+7,	66}, // +150: state 62 transitions
	{gaSNUMMATH+5,	59}, // +151: state 63 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+7,	64},
	{gaSNUMMATH+5,	59}, // +155: state 64 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+7,	65},
	{gaSNUMMATH+5,	59}, // +159: state 65 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+7,	65},
	{gaSNUMMATH+7,	67}, // +162: state 66 transitions
	{gaSNUMMATH+7,	68}, // +163: state 67 transitions
	{gaSNUMMATH+5,	59}, // +164: state 68 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+5,	70}, // +167: state 69 transitions
	{gaSNUMMATH+7,	71},
	{gaSNUMMATH+7,	80}, // +169: state 70 transitions
	{gaSNUMMATH+5,	70}, // +170: state 71 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+7,	74},
	{gaSNUMMATH+18,	13}, // +174: state 72 transitions
	{gaSNUMMATH+7,	77}, // +175: state 73 transitions
	{gaSNUMMATH+5,	70}, // +176: state 74 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+7,	75},
	{gaSNUMMATH+5,	70}, // +180: state 75 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+7,	76},
	{gaSNUMMATH+5,	70}, // +184: state 76 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+7,	76},
	{gaSNUMMATH+7,	78}, // +187: state 77 transitions
	{gaSNUMMATH+7,	79}, // +188: state 78 transitions
	{gaSNUMMATH+5,	70}, // +189: state 79 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+29,	72}, // +192: state 80 transitions
	{gaSNUMMATH+7,	80},
	{gaSNUMMATH+18,	61}, // +194: state 81 transitions
	{gaSNUMMATH+7,	81},
	{gaSNUMMATH+5,	3}, // +196: state 82 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	83},
	{gaSNUMMATH+5,	3}, // +201: state 83 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	83},
	{gaSNUMMATH+7,	85}, // +205: state 84 transitions
	{gaSNUMMATH+7,	86}, // +206: state 85 transitions
	{gaSNUMMATH+5,	3}, // +207: state 86 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+2,	99}, // +211: state 87 transitions
	{gaSNUMMATH+5,	100},
	{gaSNUMMATH+7,	101},
	{gaSNUMMATH+5,	89}, // +214: state 88 transitions
	{gaSNUMMATH+7,	90},
	{gaSNUMMATH+7,	98}, // +216: state 89 transitions
	{gaSNUMMATH+25,	8}, // +217: state 90 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+7,	92},
	{gaSNUMMATH+7,	95}, // +221: state 91 transitions
	{gaSNUMMATH+25,	8}, // +222: state 92 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+7,	93},
	{gaSNUMMATH+25,	8}, // +226: state 93 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+7,	94},
	{gaSNUMMATH+25,	8}, // +230: state 94 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+7,	94},
	{gaSNUMMATH+7,	96}, // +233: state 95 transitions
	{gaSNUMMATH+7,	97}, // +234: state 96 transitions
	{gaSNUMMATH+25,	8}, // +235: state 97 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+25,	8}, // +238: state 98 transitions
	{gaSNUMMATH+7,	98},
	{gaSNUMMATH+5,	100}, // +240: state 99 transitions
	{gaSNUMMATH+7,	101},
	{gaSNUMMATH+7,	122}, // +242: state 100 transitions
	{gaSNUMMATH+5,	100}, // +243: state 101 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+7,	104},
	{gaSNUMMATH+2,	110}, // +247: state 102 transitions
	{gaSNUMMATH+5,	111},
	{gaSNUMMATH+7,	112},
	{gaSNUMMATH+7,	107}, // +250: state 103 transitions
	{gaSNUMMATH+5,	100}, // +251: state 104 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+7,	105},
	{gaSNUMMATH+5,	100}, // +255: state 105 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+7,	106},
	{gaSNUMMATH+5,	100}, // +259: state 106 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+7,	106},
	{gaSNUMMATH+7,	108}, // +262: state 107 transitions
	{gaSNUMMATH+7,	109}, // +263: state 108 transitions
	{gaSNUMMATH+5,	100}, // +264: state 109 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+5,	111}, // +267: state 110 transitions
	{gaSNUMMATH+7,	112},
	{gaSNUMMATH+7,	121}, // +269: state 111 transitions
	{gaSNUMMATH+5,	111}, // +270: state 112 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+7,	115},
	{gaSNUMMATH+25,	8}, // +274: state 113 transitions
	{gaSNUMMATH+7,	118}, // +275: state 114 transitions
	{gaSNUMMATH+5,	111}, // +276: state 115 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+7,	116},
	{gaSNUMMATH+5,	111}, // +280: state 116 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+7,	117},
	{gaSNUMMATH+5,	111}, // +284: state 117 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+7,	117},
	{gaSNUMMATH+7,	119}, // +287: state 118 transitions
	{gaSNUMMATH+7,	120}, // +288: state 119 transitions
	{gaSNUMMATH+5,	111}, // +289: state 120 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+29,	113}, // +292: state 121 transitions
	{gaSNUMMATH+7,	121},
	{gaSNUMMATH+18,	102}, // +294: state 122 transitions
	{gaSNUMMATH+7,	122},
	{gaSNUMMATH+18,	5}, // +296: state 123 transitions
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	123},
	{gaSNUMMATH+5,	125}, // +299: state 124 transitions
	{gaSNUMMATH+7,	126},
	{gaSNUMMATH+7,	147}, // +301: state 125 transitions
	{gaSNUMMATH+5,	125}, // +302: state 126 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+7,	129},
	{gaSNUMMATH+2,	135}, // +306: state 127 transitions
	{gaSNUMMATH+5,	136},
	{gaSNUMMATH+7,	137},
	{gaSNUMMATH+7,	132}, // +309: state 128 transitions
	{gaSNUMMATH+5,	125}, // +310: state 129 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+7,	130},
	{gaSNUMMATH+5,	125}, // +314: state 130 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+7,	131},
	{gaSNUMMATH+5,	125}, // +318: state 131 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+7,	131},
	{gaSNUMMATH+7,	133}, // +321: state 132 transitions
	{gaSNUMMATH+7,	134}, // +322: state 133 transitions
	{gaSNUMMATH+5,	125}, // +323: state 134 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+5,	136}, // +326: state 135 transitions
	{gaSNUMMATH+7,	137},
	{gaSNUMMATH+7,	146}, // +328: state 136 transitions
	{gaSNUMMATH+5,	136}, // +329: state 137 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+7,	140},
	{gaSNUMMATH+18,	5}, // +333: state 138 transitions
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	143}, // +335: state 139 transitions
	{gaSNUMMATH+5,	136}, // +336: state 140 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+7,	141},
	{gaSNUMMATH+5,	136}, // +340: state 141 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+7,	142},
	{gaSNUMMATH+5,	136}, // +344: state 142 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+7,	142},
	{gaSNUMMATH+7,	144}, // +347: state 143 transitions
	{gaSNUMMATH+7,	145}, // +348: state 144 transitions
	{gaSNUMMATH+5,	136}, // +349: state 145 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+29,	138}, // +352: state 146 transitions
	{gaSNUMMATH+7,	146},
	{gaSNUMMATH+18,	127}, // +354: state 147 transitions
	{gaSNUMMATH+7,	147},
};

const STATE_DESCRIPTION aStateDescNUMMATH[148] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTNUMMATH+0},
	/*   1 */ {0, 3, gaTNUMMATH+4},
	/*   2 */ {0, 2, gaTNUMMATH+7},
	/*   3 */ {0, 1, gaTNUMMATH+9},
	/*   4 */ {1, 5, gaTNUMMATH+10},
	/*   5 */ {0, 4, gaTNUMMATH+15},
	/*   6 */ {0, 1, gaTNUMMATH+19},
	/*   7 */ {1, 5, gaTNUMMATH+20},
	/*   8 */ {0, 4, gaTNUMMATH+25},
	/*   9 */ {0, 3, gaTNUMMATH+29},
	/*  10 */ {0, 2, gaTNUMMATH+32},
	/*  11 */ {0, 1, gaTNUMMATH+34},
	/*  12 */ {1, 4, gaTNUMMATH+35},
	/*  13 */ {0, 4, gaTNUMMATH+39},
	/*  14 */ {0, 1, gaTNUMMATH+43},
	/*  15 */ {1, 4, gaTNUMMATH+44},
	/*  16 */ {1, 4, gaTNUMMATH+48},
	/*  17 */ {1, 3, gaTNUMMATH+52},
	/*  18 */ {0, 1, gaTNUMMATH+55},
	/*  19 */ {0, 1, gaTNUMMATH+56},
	/*  20 */ {1, 3, gaTNUMMATH+57},
	/*  21 */ {0, 3, gaTNUMMATH+60},
	/*  22 */ {0, 2, gaTNUMMATH+63},
	/*  23 */ {0, 1, gaTNUMMATH+65},
	/*  24 */ {1, 3, gaTNUMMATH+66},
	/*  25 */ {0, 1, gaTNUMMATH+69},
	/*  26 */ {1, 3, gaTNUMMATH+70},
	/*  27 */ {1, 3, gaTNUMMATH+73},
	/*  28 */ {1, 2, gaTNUMMATH+76},
	/*  29 */ {0, 1, gaTNUMMATH+78},
	/*  30 */ {0, 1, gaTNUMMATH+79},
	/*  31 */ {1, 2, gaTNUMMATH+80},
	/*  32 */ {1, 1, gaTNUMMATH+82},
	/*  33 */ {0, 2, gaTNUMMATH+83},
	/*  34 */ {0, 1, gaTNUMMATH+85},
	/*  35 */ {0, 4, gaTNUMMATH+86},
	/*  36 */ {0, 3, gaTNUMMATH+90},
	/*  37 */ {0, 1, gaTNUMMATH+93},
	/*  38 */ {0, 4, gaTNUMMATH+94},
	/*  39 */ {0, 4, gaTNUMMATH+98},
	/*  40 */ {0, 3, gaTNUMMATH+102},
	/*  41 */ {0, 1, gaTNUMMATH+105},
	/*  42 */ {0, 1, gaTNUMMATH+106},
	/*  43 */ {0, 3, gaTNUMMATH+107},
	/*  44 */ {0, 2, gaTNUMMATH+110},
	/*  45 */ {0, 1, gaTNUMMATH+112},
	/*  46 */ {0, 4, gaTNUMMATH+113},
	/*  47 */ {1, 0, NULL},
	/*  48 */ {0, 1, gaTNUMMATH+117},
	/*  49 */ {0, 4, gaTNUMMATH+118},
	/*  50 */ {0, 4, gaTNUMMATH+122},
	/*  51 */ {0, 3, gaTNUMMATH+126},
	/*  52 */ {0, 1, gaTNUMMATH+129},
	/*  53 */ {0, 1, gaTNUMMATH+130},
	/*  54 */ {0, 3, gaTNUMMATH+131},
	/*  55 */ {0, 2, gaTNUMMATH+134},
	/*  56 */ {0, 2, gaTNUMMATH+136},
	/*  57 */ {1, 2, gaTNUMMATH+138},
	/*  58 */ {0, 2, gaTNUMMATH+140},
	/*  59 */ {0, 1, gaTNUMMATH+142},
	/*  60 */ {0, 4, gaTNUMMATH+143},
	/*  61 */ {0, 3, gaTNUMMATH+147},
	/*  62 */ {0, 1, gaTNUMMATH+150},
	/*  63 */ {0, 4, gaTNUMMATH+151},
	/*  64 */ {0, 4, gaTNUMMATH+155},
	/*  65 */ {0, 3, gaTNUMMATH+159},
	/*  66 */ {0, 1, gaTNUMMATH+162},
	/*  67 */ {0, 1, gaTNUMMATH+163},
	/*  68 */ {0, 3, gaTNUMMATH+164},
	/*  69 */ {0, 2, gaTNUMMATH+167},
	/*  70 */ {0, 1, gaTNUMMATH+169},
	/*  71 */ {0, 4, gaTNUMMATH+170},
	/*  72 */ {1, 1, gaTNUMMATH+174},
	/*  73 */ {0, 1, gaTNUMMATH+175},
	/*  74 */ {0, 4, gaTNUMMATH+176},
	/*  75 */ {0, 4, gaTNUMMATH+180},
	/*  76 */ {0, 3, gaTNUMMATH+184},
	/*  77 */ {0, 1, gaTNUMMATH+187},
	/*  78 */ {0, 1, gaTNUMMATH+188},
	/*  79 */ {0, 3, gaTNUMMATH+189},
	/*  80 */ {0, 2, gaTNUMMATH+192},
	/*  81 */ {0, 2, gaTNUMMATH+194},
	/*  82 */ {1, 5, gaTNUMMATH+196},
	/*  83 */ {1, 4, gaTNUMMATH+201},
	/*  84 */ {0, 1, gaTNUMMATH+205},
	/*  85 */ {0, 1, gaTNUMMATH+206},
	/*  86 */ {1, 4, gaTNUMMATH+207},
	/*  87 */ {0, 3, gaTNUMMATH+211},
	/*  88 */ {0, 2, gaTNUMMATH+214},
	/*  89 */ {0, 1, gaTNUMMATH+216},
	/*  90 */ {1, 4, gaTNUMMATH+217},
	/*  91 */ {0, 1, gaTNUMMATH+221},
	/*  92 */ {1, 4, gaTNUMMATH+222},
	/*  93 */ {1, 4, gaTNUMMATH+226},
	/*  94 */ {1, 3, gaTNUMMATH+230},
	/*  95 */ {0, 1, gaTNUMMATH+233},
	/*  96 */ {0, 1, gaTNUMMATH+234},
	/*  97 */ {1, 3, gaTNUMMATH+235},
	/*  98 */ {1, 2, gaTNUMMATH+238},
	/*  99 */ {0, 2, gaTNUMMATH+240},
	/* 100 */ {0, 1, gaTNUMMATH+242},
	/* 101 */ {0, 4, gaTNUMMATH+243},
	/* 102 */ {0, 3, gaTNUMMATH+247},
	/* 103 */ {0, 1, gaTNUMMATH+250},
	/* 104 */ {0, 4, gaTNUMMATH+251},
	/* 105 */ {0, 4, gaTNUMMATH+255},
	/* 106 */ {0, 3, gaTNUMMATH+259},
	/* 107 */ {0, 1, gaTNUMMATH+262},
	/* 108 */ {0, 1, gaTNUMMATH+263},
	/* 109 */ {0, 3, gaTNUMMATH+264},
	/* 110 */ {0, 2, gaTNUMMATH+267},
	/* 111 */ {0, 1, gaTNUMMATH+269},
	/* 112 */ {0, 4, gaTNUMMATH+270},
	/* 113 */ {1, 1, gaTNUMMATH+274},
	/* 114 */ {0, 1, gaTNUMMATH+275},
	/* 115 */ {0, 4, gaTNUMMATH+276},
	/* 116 */ {0, 4, gaTNUMMATH+280},
	/* 117 */ {0, 3, gaTNUMMATH+284},
	/* 118 */ {0, 1, gaTNUMMATH+287},
	/* 119 */ {0, 1, gaTNUMMATH+288},
	/* 120 */ {0, 3, gaTNUMMATH+289},
	/* 121 */ {0, 2, gaTNUMMATH+292},
	/* 122 */ {0, 2, gaTNUMMATH+294},
	/* 123 */ {1, 3, gaTNUMMATH+296},
	/* 124 */ {0, 2, gaTNUMMATH+299},
	/* 125 */ {0, 1, gaTNUMMATH+301},
	/* 126 */ {0, 4, gaTNUMMATH+302},
	/* 127 */ {0, 3, gaTNUMMATH+306},
	/* 128 */ {0, 1, gaTNUMMATH+309},
	/* 129 */ {0, 4, gaTNUMMATH+310},
	/* 130 */ {0, 4, gaTNUMMATH+314},
	/* 131 */ {0, 3, gaTNUMMATH+318},
	/* 132 */ {0, 1, gaTNUMMATH+321},
	/* 133 */ {0, 1, gaTNUMMATH+322},
	/* 134 */ {0, 3, gaTNUMMATH+323},
	/* 135 */ {0, 2, gaTNUMMATH+326},
	/* 136 */ {0, 1, gaTNUMMATH+328},
	/* 137 */ {0, 4, gaTNUMMATH+329},
	/* 138 */ {1, 2, gaTNUMMATH+333},
	/* 139 */ {0, 1, gaTNUMMATH+335},
	/* 140 */ {0, 4, gaTNUMMATH+336},
	/* 141 */ {0, 4, gaTNUMMATH+340},
	/* 142 */ {0, 3, gaTNUMMATH+344},
	/* 143 */ {0, 1, gaTNUMMATH+347},
	/* 144 */ {0, 1, gaTNUMMATH+348},
	/* 145 */ {0, 3, gaTNUMMATH+349},
	/* 146 */ {0, 2, gaTNUMMATH+352},
	/* 147 */ {0, 2, gaTNUMMATH+354},
};

/**************** ZIP ***********************************/

// text generated by re2fsa at Thu Apr 18 18:20:54 2002

// the input-file of rules:
// # USA postal codes;
// zip = digit digit digit digit digit ["-" digit digit digit digit];
// digit = "0123456789";
// 
// # Canadian postal codes;
// upperchar = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
// lowerchar = "abcdefghijklmnopqrstuvwxyz";
// space = " ";
// zip = lowerchar digit lowerchar [space] digit lowerchar digit;
// zip = upperchar digit upperchar [space] digit upperchar digit;
// 
// # other WWE postal codes;
// zip = sym sym sym [sym] space sym sym sym [sym];
// sym = upperchar | digit;
// 
// = zip

// 27 states

static const unsigned char gaSZIP[] = 
	/* gaStringZIP+0 */	"0123456789\000"
	/* gaStringZIP+11 */	"ABCDEFGHIJKLMNOPQRSTUVWXYZ\000"
	/* gaStringZIP+38 */	"abcdefghijklmnopqrstuvwxyz\000"
	/* gaStringZIP+65 */	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\000"
	/* gaStringZIP+102 */	" \000"
	/* gaStringZIP+104 */	"-\000"
;

static const STATE_TRANSITION gaTZIP[] = {
	{gaSZIP+0,	1}, // +0: state 0 transitions
	{gaSZIP+11,	2},
	{gaSZIP+38,	3},
	{gaSZIP+0,	4}, // +3: state 1 transitions
	{gaSZIP+11,	5},
	{gaSZIP+11,	5}, // +5: state 2 transitions
	{gaSZIP+0,	6},
	{gaSZIP+0,	7}, // +7: state 3 transitions
	{gaSZIP+0,	8}, // +8: state 4 transitions
	{gaSZIP+11,	9},
	{gaSZIP+65,	9}, // +10: state 5 transitions
	{gaSZIP+0,	9}, // +11: state 6 transitions
	{gaSZIP+11,	10},
	{gaSZIP+38,	11}, // +13: state 7 transitions
	{gaSZIP+102,	12}, // +14: state 8 transitions
	{gaSZIP+0,	13},
	{gaSZIP+11,	14},
	{gaSZIP+102,	12}, // +17: state 9 transitions
	{gaSZIP+65,	14},
	{gaSZIP+102,	12}, // +19: state 10 transitions
	{gaSZIP+11,	14},
	{gaSZIP+0,	15},
	{gaSZIP+102,	16}, // +22: state 11 transitions
	{gaSZIP+0,	17},
	{gaSZIP+65,	18}, // +24: state 12 transitions
	{gaSZIP+102,	12}, // +25: state 13 transitions
	{gaSZIP+0,	19},
	{gaSZIP+102,	12}, // +27: state 14 transitions
	{gaSZIP+102,	12}, // +28: state 15 transitions
	{gaSZIP+11,	20},
	{gaSZIP+0,	17}, // +30: state 16 transitions
	{gaSZIP+38,	20}, // +31: state 17 transitions
	{gaSZIP+65,	21}, // +32: state 18 transitions
	{gaSZIP+104,	22}, // +33: state 19 transitions
	{gaSZIP+0,	23}, // +34: state 20 transitions
	{gaSZIP+65,	24}, // +35: state 21 transitions
	{gaSZIP+0,	25}, // +36: state 22 transitions
	{gaSZIP+65,	23}, // +37: state 24 transitions
	{gaSZIP+0,	26}, // +38: state 25 transitions
	{gaSZIP+0,	20}, // +39: state 26 transitions
};

const STATE_DESCRIPTION aStateDescZIP[27] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTZIP+0},
	/*   1 */ {0, 2, gaTZIP+3},
	/*   2 */ {0, 2, gaTZIP+5},
	/*   3 */ {0, 1, gaTZIP+7},
	/*   4 */ {0, 2, gaTZIP+8},
	/*   5 */ {0, 1, gaTZIP+10},
	/*   6 */ {0, 2, gaTZIP+11},
	/*   7 */ {0, 1, gaTZIP+13},
	/*   8 */ {0, 3, gaTZIP+14},
	/*   9 */ {0, 2, gaTZIP+17},
	/*  10 */ {0, 3, gaTZIP+19},
	/*  11 */ {0, 2, gaTZIP+22},
	/*  12 */ {0, 1, gaTZIP+24},
	/*  13 */ {0, 2, gaTZIP+25},
	/*  14 */ {0, 1, gaTZIP+27},
	/*  15 */ {0, 2, gaTZIP+28},
	/*  16 */ {0, 1, gaTZIP+30},
	/*  17 */ {0, 1, gaTZIP+31},
	/*  18 */ {0, 1, gaTZIP+32},
	/*  19 */ {1, 1, gaTZIP+33},
	/*  20 */ {0, 1, gaTZIP+34},
	/*  21 */ {0, 1, gaTZIP+35},
	/*  22 */ {0, 1, gaTZIP+36},
	/*  23 */ {1, 0, NULL},
	/*  24 */ {1, 1, gaTZIP+37},
	/*  25 */ {0, 1, gaTZIP+38},
	/*  26 */ {0, 1, gaTZIP+39},
};

// end of text generated by re2fsa

/**************** CREDITCARD ***********************************/

// 18 states (16 or 17 digits)

static const unsigned char gaSCREDITCARD[] = "0123456789";

static const STATE_TRANSITION gaTCREDITCARD[] = {
	{gaSCREDITCARD+0,	1}, // +0: state 0 transitions
	{gaSCREDITCARD+0,	2}, // +1: state 1 transitions
	{gaSCREDITCARD+0,	3}, // +2: state 2 transitions
	{gaSCREDITCARD+0,	4}, // +3: state 3 transitions
	{gaSCREDITCARD+0,	5}, // +4: state 4 transitions
	{gaSCREDITCARD+0,	6}, // +5: state 5 transitions
	{gaSCREDITCARD+0,	7}, // +6: state 6 transitions
	{gaSCREDITCARD+0,	8}, // +7: state 7 transitions
	{gaSCREDITCARD+0,	9}, // +8: state 8 transitions
	{gaSCREDITCARD+0,	10}, // +9: state 9 transitions
	{gaSCREDITCARD+0,	11}, // +10: state 10 transitions
	{gaSCREDITCARD+0,	12}, // +11: state 11 transitions
	{gaSCREDITCARD+0,	13}, // +12: state 12 transitions
	{gaSCREDITCARD+0,	14}, // +13: state 13 transitions
	{gaSCREDITCARD+0,	15}, // +14: state 14 transitions
	{gaSCREDITCARD+0,	16}, // +15: state 15 transitions
	{gaSCREDITCARD+0,	17}, // +16: state 16 transitions
};

const STATE_DESCRIPTION aStateDescCREDITCARD[18] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTCREDITCARD+0},
	/*   1 */ {0, 1, gaTCREDITCARD+1},
	/*   2 */ {0, 1, gaTCREDITCARD+2},
	/*   3 */ {0, 1, gaTCREDITCARD+3},
	/*   4 */ {0, 1, gaTCREDITCARD+4},
	/*   5 */ {0, 1, gaTCREDITCARD+5},
	/*   6 */ {0, 1, gaTCREDITCARD+6},
	/*   7 */ {0, 1, gaTCREDITCARD+7},
	/*   8 */ {0, 1, gaTCREDITCARD+8},
	/*   9 */ {0, 1, gaTCREDITCARD+9},
	/*  10 */ {0, 1, gaTCREDITCARD+10},
	/*  11 */ {0, 1, gaTCREDITCARD+11},
	/*  12 */ {0, 1, gaTCREDITCARD+12},
	/*  13 */ {0, 1, gaTCREDITCARD+13},
	/*  14 */ {0, 1, gaTCREDITCARD+14},
	/*  15 */ {0, 1, gaTCREDITCARD+15},
	/*  16 */ {1, 1, gaTCREDITCARD+16},
	/*  17 */ {1, 0, NULL},
};

/**************** DAYOFMONTH ***********************************/

// dayofmonth = "123456789" | "12" digit | "3" "01"
// digit = "0123456789"
// = dayofmonth

// 4 states

static const STATE_TRANSITION gaTDAYOFMONTH[] = {
	{"12",	1}, // +0: state 0 transitions
	{"3",	2},
	{"456789",	3},
	{"0123456789",	3}, // +3: state 1 transitions
	{"01",	3}, // +4: state 2 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFMONTH[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTDAYOFMONTH+0},
	/*   1 */ {1, 1, gaTDAYOFMONTH+3},
	/*   2 */ {1, 1, gaTDAYOFMONTH+4},
	/*   3 */ {1, 0, NULL},
};

/**************** MONTHNUM ***********************************/

// 3 states

static const STATE_TRANSITION gaTMONTHNUM[] = {
	{"1",	1}, // +0: state 0 transitions
	{"23456789",	2},
	{"012",	2}, // +2: state 1 transitions
};

const STATE_DESCRIPTION aStateDescMONTHNUM[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTMONTHNUM+0},
	/*   1 */ {1, 1, gaTMONTHNUM+2},
	/*   2 */ {1, 0, NULL},
};

/**************** YEAR ***********************************/

// 5 states

static const unsigned char gaSYEAR[] = "0123456789";

static const STATE_TRANSITION gaTYEAR[] = {
	{gaSYEAR,	1}, // +0: state 0 transitions
	{gaSYEAR,	2}, // +1: state 1 transitions
	{gaSYEAR,	3}, // +2: state 2 transitions
	{gaSYEAR,	4}, // +3: state 3 transitions
};

const STATE_DESCRIPTION aStateDescYEAR[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTYEAR+0},
	/*   1 */ {0, 1, gaTYEAR+1},
	/*   2 */ {1, 1, gaTYEAR+2},
	/*   3 */ {0, 1, gaTYEAR+3},
	/*   4 */ {1, 0, NULL},
};

/**************** SECOND ***********************************/

// 3 states

static const STATE_TRANSITION gaTSECOND[] = {
	{"06789",	1}, // +0: state 0 transitions
	{"12345",	2},
	{"0123456789",	1}, // +2: state 2 transitions
};

const STATE_DESCRIPTION aStateDescSECOND[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTSECOND+0},
	/*   1 */ {1, 0, NULL},
	/*   2 */ {1, 1, gaTSECOND+2},
};

/**************** MINUTE ***********************************/
// same as second
// 3 states

static const STATE_TRANSITION gaTMINUTE[] = {
	{"06789",	1}, // +0: state 0 transitions
	{"12345",	2},
	{"0123456789",	1}, // +2: state 2 transitions
};

const STATE_DESCRIPTION aStateDescMINUTE[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTMINUTE+0},
	/*   1 */ {1, 0, NULL},
	/*   2 */ {1, 1, gaTMINUTE+2},
};

/**************** HOUR ***********************************/
// 0 through 23

// 4 states

static const STATE_TRANSITION gaTHOUR[] = {
	{"03456789",	1}, // +0: state 0 transitions
	{"1",	2},
	{"2",	3},
	{"0123456789",	1}, // +3: state 2 transitions
	{"0123",	1}, // +4: state 3 transitions
};

const STATE_DESCRIPTION aStateDescHOUR[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTHOUR+0},
	/*   1 */ {1, 0, NULL},
	/*   2 */ {1, 1, gaTHOUR+3},
	/*   3 */ {1, 1, gaTHOUR+4},
};

/**************** SSN ***********************************/
// text generated by re2fsa at Tue Feb 06 17:23:44 2001

// the input-file of rules:
// digit = "0123456789"
// 
// ssn = digit digit digit ["-"] digit digit ["-"] digit digit digit digit
// 
// = ssn

// 12 states

static const unsigned char gaSSSN[] = 
	/* gaStringSSN+0 */	"0123456789\000"
	/* gaStringSSN+11 */	"-\000"
;

static const STATE_TRANSITION gaTSSN[] = {
	{gaSSSN+0,	1}, // +0: state 0 transitions
	{gaSSSN+0,	2}, // +1: state 1 transitions
	{gaSSSN+0,	3}, // +2: state 2 transitions
	{gaSSSN+11,	4}, // +3: state 3 transitions
	{gaSSSN+0,	5},
	{gaSSSN+0,	5}, // +5: state 4 transitions
	{gaSSSN+0,	6}, // +6: state 5 transitions
	{gaSSSN+11,	7}, // +7: state 6 transitions
	{gaSSSN+0,	8},
	{gaSSSN+0,	8}, // +9: state 7 transitions
	{gaSSSN+0,	9}, // +10: state 8 transitions
	{gaSSSN+0,	10}, // +11: state 9 transitions
	{gaSSSN+0,	11}, // +12: state 10 transitions
};

const STATE_DESCRIPTION aStateDescSSN[12] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTSSN+0},
	/*   1 */ {0, 1, gaTSSN+1},
	/*   2 */ {0, 1, gaTSSN+2},
	/*   3 */ {0, 2, gaTSSN+3},
	/*   4 */ {0, 1, gaTSSN+5},
	/*   5 */ {0, 1, gaTSSN+6},
	/*   6 */ {0, 2, gaTSSN+7},
	/*   7 */ {0, 1, gaTSSN+9},
	/*   8 */ {0, 1, gaTSSN+10},
	/*   9 */ {0, 1, gaTSSN+11},
	/*  10 */ {0, 1, gaTSSN+12},
	/*  11 */ {1, 0, NULL},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\number.h ===
// number.h
// Angshuman Guha, aguha
// Sep 18, 1998

#ifndef __INC_NUMBER_H
#define __INC_NUMBER_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescNUMBER[];
extern const STATE_DESCRIPTION aStateDescNUMSIMPLE[];
extern const STATE_DESCRIPTION aStateDescNUMNTH[];
extern const STATE_DESCRIPTION aStateDescNUMUNIT[];
extern const STATE_DESCRIPTION aStateDescNUMNUM[];
extern const STATE_DESCRIPTION aStateDescNUMPERCENT[];
extern const STATE_DESCRIPTION aStateDescNUMDATE[];
extern const STATE_DESCRIPTION aStateDescNUMTIME[];
extern const STATE_DESCRIPTION aStateDescNUMCURRENCY[];
extern const STATE_DESCRIPTION aStateDescNUMPHONE[];
extern const STATE_DESCRIPTION aStateDescNUMMATH[];
extern const STATE_DESCRIPTION aStateDescZIP[];
extern const STATE_DESCRIPTION aStateDescCREDITCARD[];
extern const STATE_DESCRIPTION aStateDescDAYOFMONTH[];
extern const STATE_DESCRIPTION aStateDescMONTHNUM[];
extern const STATE_DESCRIPTION aStateDescYEAR[];
extern const STATE_DESCRIPTION aStateDescSECOND[];
extern const STATE_DESCRIPTION aStateDescMINUTE[];
extern const STATE_DESCRIPTION aStateDescHOUR[];
extern const STATE_DESCRIPTION aStateDescSSN[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\singlech.h ===
// singlech.h
// Angshuman Guha
// aguha
// Feb 6, 2001

#ifndef __INC_SINGLE_CHAR_H
#define __INC_SINGLE_CHAR_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescUPPERCHAR[];
extern const STATE_DESCRIPTION aStateDescLOWERCHAR[];
extern const STATE_DESCRIPTION aStateDescDIGITCHAR[];
extern const STATE_DESCRIPTION aStateDescPUNCCHAR[];
extern const STATE_DESCRIPTION aStateDescONECHAR[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\suffix.c ===
// suffix.c
// Angshuman Guha
// aguha
// April 17, 2001

#include "common.h"
#include "suffix.h"

const STATE_DESCRIPTION *aStateDescSuffix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\suffix.h ===
// suffix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_SUFFIX_H
#define __INC_SUFFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescSuffix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\tpunc.h ===
// tpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_TPUNC_H
#define __INC_TPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescTPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\punc.h ===
// punc.h
// Angshuman Guha, aguha
// Sep 22, 1998
// Major mod Jan 10, 2001

#ifndef __INC_PUNC_H
#define __INC_PUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\shrtlist.h ===
// shrtlist.c
// Angshuman Guha
// aguha
// Feb 7, 2001

#ifndef __INC_SHORTLIST_H
#define __INC_SHORTLIST_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescDAYOFWEEK[];
extern const STATE_DESCRIPTION aStateDescMONTH[];
extern const STATE_DESCRIPTION aStateDescGENDER[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\singlech.c ===
// singlech.c
// Angshuman Guha
// aguha
// Feb 6, 2001

#include "common.h"
#include "singlech.h"

/**************** UPPERCHAR ***********************************/

static const STATE_TRANSITION gaTUPPERCHAR[] = { {"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1} };

const STATE_DESCRIPTION aStateDescUPPERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTUPPERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** LOWERCHAR ***********************************/

static const STATE_TRANSITION gaTLOWERCHAR[] = { {"abcdefghijklmnopqrstuvwxyz", 1} };

const STATE_DESCRIPTION aStateDescLOWERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTLOWERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** DIGITCHAR ***********************************/

static const STATE_TRANSITION gaTDIGITCHAR[] = { {"0123456789", 1} };

const STATE_DESCRIPTION aStateDescDIGITCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTDIGITCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** PUNCCHAR ***********************************/

static const STATE_TRANSITION gaTPUNCCHAR[] = { {"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", 1} };

const STATE_DESCRIPTION aStateDescPUNCCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTPUNCCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** ONECHAR ***********************************/

static const STATE_TRANSITION gaTONECHAR[] = { {"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", 1} };

const STATE_DESCRIPTION aStateDescONECHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTONECHAR },
	/*  1 */ { 1, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\shrtlist.c ===
// shrtlist.c  (factoids which are short lists of words)
// Angshuman Guha
// aguha
// Feb 7, 2001

#include "common.h"
#include "shrtlist.h"

/********************* DAYOFWEEK ********************************/

// text generated by re2fsa at Wed Feb 07 10:23:50 2001

// the input-file of rules:
// Sun
// Mon
// Tue
// Wed
// Thu
// Fri
// Sat
// Sunday
// Monday
// Tuesday
// Wednesday
// Thursday
// Friday
// Saturday

// 24 states

static const unsigned char gaSDAYOFWEEK[] = 
	/* gaStringDAYOFWEEK+0 */	"F\000"
	/* gaStringDAYOFWEEK+2 */	"M\000"
	/* gaStringDAYOFWEEK+4 */	"S\000"
	/* gaStringDAYOFWEEK+6 */	"T\000"
	/* gaStringDAYOFWEEK+8 */	"W\000"
	/* gaStringDAYOFWEEK+10 */	"r\000"
	/* gaStringDAYOFWEEK+12 */	"o\000"
	/* gaStringDAYOFWEEK+14 */	"a\000"
	/* gaStringDAYOFWEEK+16 */	"u\000"
	/* gaStringDAYOFWEEK+18 */	"h\000"
	/* gaStringDAYOFWEEK+20 */	"e\000"
	/* gaStringDAYOFWEEK+22 */	"d\000"
	/* gaStringDAYOFWEEK+24 */	"s\000"
	/* gaStringDAYOFWEEK+26 */	"y\000"
	/* gaStringDAYOFWEEK+28 */	"t\000"
	/* gaStringDAYOFWEEK+30 */	"n\000"
	/* gaStringDAYOFWEEK+32 */	"i\000"
;

static const STATE_TRANSITION gaTDAYOFWEEK[] = {
	{gaSDAYOFWEEK+0,	1}, // +0: state 0 transitions
	{gaSDAYOFWEEK+2,	3},
	{gaSDAYOFWEEK+4,	4},
	{gaSDAYOFWEEK+6,	5},
	{gaSDAYOFWEEK+8,	6},
	{gaSDAYOFWEEK+10,	17}, // +5: state 1 transitions
	{gaSDAYOFWEEK+10,	10}, // +6: state 2 transitions
	{gaSDAYOFWEEK+12,	16}, // +7: state 3 transitions
	{gaSDAYOFWEEK+14,	15}, // +8: state 4 transitions
	{gaSDAYOFWEEK+16,	16},
	{gaSDAYOFWEEK+18,	13}, // +10: state 5 transitions
	{gaSDAYOFWEEK+16,	14},
	{gaSDAYOFWEEK+20,	8}, // +12: state 6 transitions
	{gaSDAYOFWEEK+20,	9}, // +13: state 7 transitions
	{gaSDAYOFWEEK+22,	18}, // +14: state 8 transitions
	{gaSDAYOFWEEK+24,	10}, // +15: state 9 transitions
	{gaSDAYOFWEEK+22,	11}, // +16: state 10 transitions
	{gaSDAYOFWEEK+14,	12}, // +17: state 11 transitions
	{gaSDAYOFWEEK+26,	19}, // +18: state 12 transitions
	{gaSDAYOFWEEK+16,	21}, // +19: state 13 transitions
	{gaSDAYOFWEEK+20,	20}, // +20: state 14 transitions
	{gaSDAYOFWEEK+28,	23}, // +21: state 15 transitions
	{gaSDAYOFWEEK+30,	22}, // +22: state 16 transitions
	{gaSDAYOFWEEK+32,	22}, // +23: state 17 transitions
	{gaSDAYOFWEEK+30,	7}, // +24: state 18 transitions
	{gaSDAYOFWEEK+24,	10}, // +25: state 20 transitions
	{gaSDAYOFWEEK+10,	9}, // +26: state 21 transitions
	{gaSDAYOFWEEK+22,	11}, // +27: state 22 transitions
	{gaSDAYOFWEEK+16,	2}, // +28: state 23 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFWEEK[24] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTDAYOFWEEK+0},
	/*   1 */ {0, 1, gaTDAYOFWEEK+5},
	/*   2 */ {0, 1, gaTDAYOFWEEK+6},
	/*   3 */ {0, 1, gaTDAYOFWEEK+7},
	/*   4 */ {0, 2, gaTDAYOFWEEK+8},
	/*   5 */ {0, 2, gaTDAYOFWEEK+10},
	/*   6 */ {0, 1, gaTDAYOFWEEK+12},
	/*   7 */ {0, 1, gaTDAYOFWEEK+13},
	/*   8 */ {0, 1, gaTDAYOFWEEK+14},
	/*   9 */ {0, 1, gaTDAYOFWEEK+15},
	/*  10 */ {0, 1, gaTDAYOFWEEK+16},
	/*  11 */ {0, 1, gaTDAYOFWEEK+17},
	/*  12 */ {0, 1, gaTDAYOFWEEK+18},
	/*  13 */ {0, 1, gaTDAYOFWEEK+19},
	/*  14 */ {0, 1, gaTDAYOFWEEK+20},
	/*  15 */ {0, 1, gaTDAYOFWEEK+21},
	/*  16 */ {0, 1, gaTDAYOFWEEK+22},
	/*  17 */ {0, 1, gaTDAYOFWEEK+23},
	/*  18 */ {1, 1, gaTDAYOFWEEK+24},
	/*  19 */ {1, 0, NULL},
	/*  20 */ {1, 1, gaTDAYOFWEEK+25},
	/*  21 */ {1, 1, gaTDAYOFWEEK+26},
	/*  22 */ {1, 1, gaTDAYOFWEEK+27},
	/*  23 */ {1, 1, gaTDAYOFWEEK+28},
};

// end of text generated by re2fsa

/********************* MONTH ********************************/

// text generated by re2fsa at Wed Feb 07 10:32:20 2001

// the input-file of rules:
// Jan
// Feb
// Mar
// Apr
// May
// Jun
// Jul
// Aug
// Sep
// Oct
// Nov
// Dec
// January
// February
// March
// April
// May
// June
// July
// August
// September
// October
// November
// December

// 43 states

static const unsigned char gaSMONTH[] = 
	/* gaStringMONTH+0 */	"A\000"
	/* gaStringMONTH+2 */	"D\000"
	/* gaStringMONTH+4 */	"F\000"
	/* gaStringMONTH+6 */	"S\000"
	/* gaStringMONTH+8 */	"J\000"
	/* gaStringMONTH+10 */	"M\000"
	/* gaStringMONTH+12 */	"N\000"
	/* gaStringMONTH+14 */	"O\000"
	/* gaStringMONTH+16 */	"p\000"
	/* gaStringMONTH+18 */	"u\000"
	/* gaStringMONTH+20 */	"e\000"
	/* gaStringMONTH+22 */	"a\000"
	/* gaStringMONTH+24 */	"o\000"
	/* gaStringMONTH+26 */	"c\000"
	/* gaStringMONTH+28 */	"m\000"
	/* gaStringMONTH+30 */	"b\000"
	/* gaStringMONTH+32 */	"r\000"
	/* gaStringMONTH+34 */	"t\000"
	/* gaStringMONTH+36 */	"v\000"
	/* gaStringMONTH+38 */	"y\000"
	/* gaStringMONTH+40 */	"h\000"
	/* gaStringMONTH+42 */	"n\000"
	/* gaStringMONTH+44 */	"l\000"
	/* gaStringMONTH+46 */	"g\000"
	/* gaStringMONTH+48 */	"s\000"
	/* gaStringMONTH+50 */	"i\000"
;

static const STATE_TRANSITION gaTMONTH[] = {
	{gaSMONTH+0,	1}, // +0: state 0 transitions
	{gaSMONTH+2,	2},
	{gaSMONTH+4,	3},
	{gaSMONTH+6,	4},
	{gaSMONTH+8,	7},
	{gaSMONTH+10,	8},
	{gaSMONTH+12,	10},
	{gaSMONTH+14,	11},
	{gaSMONTH+16,	16}, // +8: state 1 transitions
	{gaSMONTH+18,	29},
	{gaSMONTH+20,	28}, // +10: state 2 transitions
	{gaSMONTH+20,	26}, // +11: state 3 transitions
	{gaSMONTH+20,	12}, // +12: state 4 transitions
	{gaSMONTH+20,	13}, // +13: state 5 transitions
	{gaSMONTH+20,	15}, // +14: state 6 transitions
	{gaSMONTH+22,	22}, // +15: state 7 transitions
	{gaSMONTH+18,	23},
	{gaSMONTH+22,	20}, // +17: state 8 transitions
	{gaSMONTH+22,	24}, // +18: state 9 transitions
	{gaSMONTH+24,	19}, // +19: state 10 transitions
	{gaSMONTH+26,	17}, // +20: state 11 transitions
	{gaSMONTH+16,	32}, // +21: state 12 transitions
	{gaSMONTH+28,	14}, // +22: state 13 transitions
	{gaSMONTH+30,	6}, // +23: state 14 transitions
	{gaSMONTH+32,	33}, // +24: state 15 transitions
	{gaSMONTH+32,	42}, // +25: state 16 transitions
	{gaSMONTH+34,	34}, // +26: state 17 transitions
	{gaSMONTH+34,	33}, // +27: state 18 transitions
	{gaSMONTH+36,	35}, // +28: state 19 transitions
	{gaSMONTH+38,	33}, // +29: state 20 transitions
	{gaSMONTH+32,	36},
	{gaSMONTH+40,	33}, // +31: state 21 transitions
	{gaSMONTH+42,	39}, // +32: state 22 transitions
	{gaSMONTH+44,	37}, // +33: state 23 transitions
	{gaSMONTH+42,	38},
	{gaSMONTH+32,	25}, // +35: state 24 transitions
	{gaSMONTH+38,	33}, // +36: state 25 transitions
	{gaSMONTH+30,	41}, // +37: state 26 transitions
	{gaSMONTH+18,	9}, // +38: state 27 transitions
	{gaSMONTH+26,	35}, // +39: state 28 transitions
	{gaSMONTH+46,	40}, // +40: state 29 transitions
	{gaSMONTH+48,	18}, // +41: state 30 transitions
	{gaSMONTH+44,	33}, // +42: state 31 transitions
	{gaSMONTH+34,	5}, // +43: state 32 transitions
	{gaSMONTH+24,	14}, // +44: state 34 transitions
	{gaSMONTH+20,	13}, // +45: state 35 transitions
	{gaSMONTH+26,	21}, // +46: state 36 transitions
	{gaSMONTH+38,	33}, // +47: state 37 transitions
	{gaSMONTH+20,	33}, // +48: state 38 transitions
	{gaSMONTH+18,	9}, // +49: state 39 transitions
	{gaSMONTH+18,	30}, // +50: state 40 transitions
	{gaSMONTH+32,	27}, // +51: state 41 transitions
	{gaSMONTH+50,	31}, // +52: state 42 transitions
};

const STATE_DESCRIPTION aStateDescMONTH[43] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 8, gaTMONTH+0},
	/*   1 */ {0, 2, gaTMONTH+8},
	/*   2 */ {0, 1, gaTMONTH+10},
	/*   3 */ {0, 1, gaTMONTH+11},
	/*   4 */ {0, 1, gaTMONTH+12},
	/*   5 */ {0, 1, gaTMONTH+13},
	/*   6 */ {0, 1, gaTMONTH+14},
	/*   7 */ {0, 2, gaTMONTH+15},
	/*   8 */ {0, 1, gaTMONTH+17},
	/*   9 */ {0, 1, gaTMONTH+18},
	/*  10 */ {0, 1, gaTMONTH+19},
	/*  11 */ {0, 1, gaTMONTH+20},
	/*  12 */ {0, 1, gaTMONTH+21},
	/*  13 */ {0, 1, gaTMONTH+22},
	/*  14 */ {0, 1, gaTMONTH+23},
	/*  15 */ {0, 1, gaTMONTH+24},
	/*  16 */ {0, 1, gaTMONTH+25},
	/*  17 */ {0, 1, gaTMONTH+26},
	/*  18 */ {0, 1, gaTMONTH+27},
	/*  19 */ {0, 1, gaTMONTH+28},
	/*  20 */ {0, 2, gaTMONTH+29},
	/*  21 */ {0, 1, gaTMONTH+31},
	/*  22 */ {0, 1, gaTMONTH+32},
	/*  23 */ {0, 2, gaTMONTH+33},
	/*  24 */ {0, 1, gaTMONTH+35},
	/*  25 */ {0, 1, gaTMONTH+36},
	/*  26 */ {0, 1, gaTMONTH+37},
	/*  27 */ {0, 1, gaTMONTH+38},
	/*  28 */ {0, 1, gaTMONTH+39},
	/*  29 */ {0, 1, gaTMONTH+40},
	/*  30 */ {0, 1, gaTMONTH+41},
	/*  31 */ {0, 1, gaTMONTH+42},
	/*  32 */ {1, 1, gaTMONTH+43},
	/*  33 */ {1, 0, NULL},
	/*  34 */ {1, 1, gaTMONTH+44},
	/*  35 */ {1, 1, gaTMONTH+45},
	/*  36 */ {1, 1, gaTMONTH+46},
	/*  37 */ {1, 1, gaTMONTH+47},
	/*  38 */ {1, 1, gaTMONTH+48},
	/*  39 */ {1, 1, gaTMONTH+49},
	/*  40 */ {1, 1, gaTMONTH+50},
	/*  41 */ {1, 1, gaTMONTH+51},
	/*  42 */ {1, 1, gaTMONTH+52},
};

// end of text generated by re2fsa

/********************* GENDER ********************************/

// text generated by re2fsa at Wed Feb 07 10:34:39 2001

// the input-file of rules:
// M
// F
// Male
// male
// Female
// female

// 9 states

static const unsigned char gaSGENDER[] = 
	/* gaStringGENDER+0 */	"f\000"
	/* gaStringGENDER+2 */	"m\000"
	/* gaStringGENDER+4 */	"F\000"
	/* gaStringGENDER+6 */	"M\000"
	/* gaStringGENDER+8 */	"e\000"
	/* gaStringGENDER+10 */	"a\000"
	/* gaStringGENDER+12 */	"l\000"
;

static const STATE_TRANSITION gaTGENDER[] = {
	{gaSGENDER+0,	1}, // +0: state 0 transitions
	{gaSGENDER+2,	2},
	{gaSGENDER+4,	6},
	{gaSGENDER+6,	7},
	{gaSGENDER+8,	5}, // +4: state 1 transitions
	{gaSGENDER+10,	3}, // +5: state 2 transitions
	{gaSGENDER+12,	4}, // +6: state 3 transitions
	{gaSGENDER+8,	8}, // +7: state 4 transitions
	{gaSGENDER+2,	2}, // +8: state 5 transitions
	{gaSGENDER+8,	5}, // +9: state 6 transitions
	{gaSGENDER+10,	3}, // +10: state 7 transitions
};

const STATE_DESCRIPTION aStateDescGENDER[9] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTGENDER+0},
	/*   1 */ {0, 1, gaTGENDER+4},
	/*   2 */ {0, 1, gaTGENDER+5},
	/*   3 */ {0, 1, gaTGENDER+6},
	/*   4 */ {0, 1, gaTGENDER+7},
	/*   5 */ {0, 1, gaTGENDER+8},
	/*   6 */ {1, 1, gaTGENDER+9},
	/*   7 */ {1, 1, gaTGENDER+10},
	/*   8 */ {1, 0, NULL},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\punc.c ===
// punc.c
// Angshuman Guha
// aguha
// Jan 10, 2001

#include "common.h"
#include "punc.h"

// text generated by re2fsa at Mon Apr 01 14:58:40 2002

// the input-file of rules:
// punc = comma;
// punc = dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = colon;
// punc = semicolon;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = rparen;
// punc = rparen comma;
// punc = rparen dot;
// punc = rparen colon;
// punc = rparen semicolon;
// punc = rparen question;
// punc = rparen question question;
// punc = rparen question question question;
// punc = rparen bang;
// punc = rparen bang bang;
// punc = rparen bang bang bang;
// punc = rparen rparen;
// punc = rparen rparen comma;
// punc = rparen rparen dot;
// punc = rparen rparen colon;
// punc = rparen rparen semicolon;
// punc = rparen rparen question;
// punc = rparen rparen question question;
// punc = rparen rparen question question question;
// punc = rparen rparen bang;
// punc = rparen rparen bang bang;
// punc = rparen rparen bang bang bang;
// punc = comma rparen;
// punc = dot rparen;
// punc = colon rparen;
// punc = semicolon rparen;
// punc = question rparen;
// punc = question question rparen;
// punc = question question question rparen;
// punc = bang rparen;
// punc = bang bang rparen;
// punc = bang bang bang rparen;
// punc = dot dot dot rparen;
// punc = rbracket;
// punc = rbracket comma;
// punc = rbracket dot;
// punc = rbracket colon;
// punc = rbracket semicolon;
// punc = rbracket question;
// punc = rbracket question question;
// punc = rbracket question question question;
// punc = rbracket bang;
// punc = rbracket bang bang;
// punc = rbracket bang bang bang;
// punc = rbrace;
// punc = rbrace comma;
// punc = rbrace dot;
// punc = rbrace colon;
// punc = rbrace semicolon;
// punc = rbrace question;
// punc = rbrace question question;
// punc = rbrace question question question;
// punc = rbrace bang;
// punc = rbrace bang bang;
// punc = rbrace bang bang bang;
// punc = star;
// punc = star star;
// punc = star star star;
// punc = slash;
// punc = ampersand;
// punc = dollar;
// punc = dollar dollar;
// punc = dollar dollar dollar;
// punc = euro;
// punc = pound;
// punc = yen;
// punc = equals;
// punc = dquote;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = question question question question;
// punc = question question question question question;
// punc = bslash;
// punc = bslash bslash;
// punc = lessthan;
// punc = greaterthan;
// punc = plus;
// punc = tilde;
// punc = at;
// punc = circumflex;
// punc = star;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = bang bang bang bang;
// punc = bang bang bang bang bang;
// punc = hash;
// punc = lparen plus rparen;
// punc = lparen minus rparen;
// punc = dquote bquote dquote;
// punc = dquote tilde dquote;
// punc = dquote bang dquote;
// punc = dquote at dquote;
// punc = dquote hash dquote;
// punc = dquote dollar dquote;
// punc = dquote euro dquote;
// punc = dquote pound dquote;
// punc = dquote yen dquote;
// punc = dquote percent dquote;
// punc = dquote circumflex dquote;
// punc = dquote ampersand dquote;
// punc = dquote star dquote;
// punc = dquote lparen dquote;
// punc = dquote rparen dquote;
// punc = dquote minus dquote;
// punc = dquote uscore dquote;
// punc = dquote equals dquote;
// punc = dquote plus dquote;
// punc = dquote lbracket dquote;
// punc = dquote lbrace dquote;
// punc = dquote rbracket dquote;
// punc = dquote rbrace dquote;
// punc = dquote bslash dquote;
// punc = dquote semicolon dquote;
// punc = dquote colon dquote;
// punc = dquote squote dquote;
// punc = dquote dquote dquote;
// punc = dquote comma dquote;
// punc = dquote lessthan dquote;
// punc = dquote dot dquote;
// punc = dquote greaterthan dquote;
// punc = dquote slash dquote;
// punc = dquote question dquote;
// punc = minus;
// punc = minus minus;
// punc = minus minus minus;
// punc = minus minus minus minus;
// punc = minus minus minus minus minus;
// punc = uscore;
// punc = uscore uscore;
// punc = uscore uscore uscore;
// punc = uscore uscore uscore uscore;
// punc = uscore uscore uscore uscore uscore;
// punc = dot;
// punc = dot dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = dot dot dot dot dot;
// comma = ",";
// dot = ".";
// colon = ":";
// semicolon = ";";
// question = "?";
// bang = "!";
// rparen = ")";
// lparen = "(";
// rbracket = "]";
// lbracket = "[";
// rbrace = "}";
// lbrace = "{";
// dquote = "\"";
// squote = "'";
// bquote = "`";
// tilde = "~";
// at = "@";
// hash = "#";
// dollar = "$";
// percent = "%";
// circumflex = "^";
// ampersand = "&";
// star = "*";
// plus = "+";
// minus = "-";
// uscore = "_";
// lessthan = "<";
// greaterthan = ">";
// slash = "/";
// bslash = "\\";
// equals = "=";
// pound = "";
// yen = "";
// euro = "";
// = punc

// 36 states

static const unsigned char gaSPUNC[] = 
	/* gaStringPUNC+0 */	"!\000"
	/* gaStringPUNC+2 */	"\"\000"
	/* gaStringPUNC+4 */	"#&+/<=>@^~\000"
	/* gaStringPUNC+18 */	"$\000"
	/* gaStringPUNC+20 */	"(\000"
	/* gaStringPUNC+22 */	")\000"
	/* gaStringPUNC+24 */	"*\000"
	/* gaStringPUNC+26 */	",:;\000"
	/* gaStringPUNC+30 */	"-\000"
	/* gaStringPUNC+32 */	".\000"
	/* gaStringPUNC+34 */	"?\000"
	/* gaStringPUNC+36 */	"\\\000"
	/* gaStringPUNC+38 */	"]}\000"
	/* gaStringPUNC+41 */	"_\000"
	/* gaStringPUNC+43 */	"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{}~\000"
	/* gaStringPUNC+78 */	"+-\000"
	/* gaStringPUNC+81 */	",.:;\000"
;

static const STATE_TRANSITION gaTPUNC[] = {
	{gaSPUNC+0,	1}, // +0: state 0 transitions
	{gaSPUNC+2,	2},
	{gaSPUNC+4,	3},
	{gaSPUNC+18,	4},
	{gaSPUNC+20,	5},
	{gaSPUNC+22,	6},
	{gaSPUNC+24,	7},
	{gaSPUNC+26,	8},
	{gaSPUNC+30,	9},
	{gaSPUNC+32,	10},
	{gaSPUNC+34,	11},
	{gaSPUNC+36,	12},
	{gaSPUNC+38,	13},
	{gaSPUNC+41,	14},
	{gaSPUNC+22,	3}, // +14: state 1 transitions
	{gaSPUNC+0,	15},
	{gaSPUNC+43,	16}, // +16: state 2 transitions
	{gaSPUNC+18,	17}, // +17: state 4 transitions
	{gaSPUNC+78,	18}, // +18: state 5 transitions
	{gaSPUNC+81,	3}, // +19: state 6 transitions
	{gaSPUNC+22,	13},
	{gaSPUNC+0,	19},
	{gaSPUNC+34,	20},
	{gaSPUNC+24,	21}, // +23: state 7 transitions
	{gaSPUNC+22,	3}, // +24: state 8 transitions
	{gaSPUNC+30,	22}, // +25: state 9 transitions
	{gaSPUNC+22,	3}, // +26: state 10 transitions
	{gaSPUNC+32,	23},
	{gaSPUNC+22,	3}, // +28: state 11 transitions
	{gaSPUNC+34,	24},
	{gaSPUNC+36,	3}, // +30: state 12 transitions
	{gaSPUNC+81,	3}, // +31: state 13 transitions
	{gaSPUNC+0,	19},
	{gaSPUNC+34,	20},
	{gaSPUNC+41,	25}, // +34: state 14 transitions
	{gaSPUNC+22,	3}, // +35: state 15 transitions
	{gaSPUNC+0,	26},
	{gaSPUNC+2,	3}, // +37: state 16 transitions
	{gaSPUNC+18,	3}, // +38: state 17 transitions
	{gaSPUNC+22,	3}, // +39: state 18 transitions
	{gaSPUNC+0,	27}, // +40: state 19 transitions
	{gaSPUNC+34,	28}, // +41: state 20 transitions
	{gaSPUNC+24,	3}, // +42: state 21 transitions
	{gaSPUNC+30,	29}, // +43: state 22 transitions
	{gaSPUNC+32,	30}, // +44: state 23 transitions
	{gaSPUNC+22,	3}, // +45: state 24 transitions
	{gaSPUNC+34,	31},
	{gaSPUNC+41,	32}, // +47: state 25 transitions
	{gaSPUNC+22,	3}, // +48: state 26 transitions
	{gaSPUNC+0,	27},
	{gaSPUNC+0,	3}, // +50: state 27 transitions
	{gaSPUNC+34,	3}, // +51: state 28 transitions
	{gaSPUNC+30,	33}, // +52: state 29 transitions
	{gaSPUNC+22,	3}, // +53: state 30 transitions
	{gaSPUNC+32,	34},
	{gaSPUNC+22,	3}, // +55: state 31 transitions
	{gaSPUNC+34,	28},
	{gaSPUNC+41,	35}, // +57: state 32 transitions
	{gaSPUNC+30,	3}, // +58: state 33 transitions
	{gaSPUNC+32,	3}, // +59: state 34 transitions
	{gaSPUNC+41,	3}, // +60: state 35 transitions
};

const STATE_DESCRIPTION aStateDescPUNC[36] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 14, gaTPUNC+0},
	/*   1 */ {1, 2, gaTPUNC+14},
	/*   2 */ {1, 1, gaTPUNC+16},
	/*   3 */ {1, 0, NULL},
	/*   4 */ {1, 1, gaTPUNC+17},
	/*   5 */ {0, 1, gaTPUNC+18},
	/*   6 */ {1, 4, gaTPUNC+19},
	/*   7 */ {1, 1, gaTPUNC+23},
	/*   8 */ {1, 1, gaTPUNC+24},
	/*   9 */ {1, 1, gaTPUNC+25},
	/*  10 */ {1, 2, gaTPUNC+26},
	/*  11 */ {1, 2, gaTPUNC+28},
	/*  12 */ {1, 1, gaTPUNC+30},
	/*  13 */ {1, 3, gaTPUNC+31},
	/*  14 */ {1, 1, gaTPUNC+34},
	/*  15 */ {1, 2, gaTPUNC+35},
	/*  16 */ {0, 1, gaTPUNC+37},
	/*  17 */ {1, 1, gaTPUNC+38},
	/*  18 */ {0, 1, gaTPUNC+39},
	/*  19 */ {1, 1, gaTPUNC+40},
	/*  20 */ {1, 1, gaTPUNC+41},
	/*  21 */ {1, 1, gaTPUNC+42},
	/*  22 */ {1, 1, gaTPUNC+43},
	/*  23 */ {1, 1, gaTPUNC+44},
	/*  24 */ {1, 2, gaTPUNC+45},
	/*  25 */ {1, 1, gaTPUNC+47},
	/*  26 */ {1, 2, gaTPUNC+48},
	/*  27 */ {1, 1, gaTPUNC+50},
	/*  28 */ {1, 1, gaTPUNC+51},
	/*  29 */ {1, 1, gaTPUNC+52},
	/*  30 */ {1, 2, gaTPUNC+53},
	/*  31 */ {1, 2, gaTPUNC+55},
	/*  32 */ {1, 1, gaTPUNC+57},
	/*  33 */ {1, 1, gaTPUNC+58},
	/*  34 */ {1, 1, gaTPUNC+59},
	/*  35 */ {1, 1, gaTPUNC+60},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\snet.h ===
// snet.h
// computed from <4320.net,space.ist> (172720000) by net2c at Mon Jun 25 14:55:46 2001
#ifndef __INC_SNET_H
#define __INC_SNET_H

// Time Stamp
#define NET_TIME_STAMP_S	0x3b37b362

// Type definitions

typedef short INP_HID_WEIGHT_S;
typedef short HID_BIAS_S;
typedef char HID_OUT_WEIGHT_S;
typedef short OUT_BIAS_S;
typedef unsigned short INP_BIAS_S;


// Hidden Layer
#define gcHiddenNode_S 23
#define gcHiddenWeightHeight_S 46
#define gcHiddenWeightWidth_S 3
extern int giHiddenScale_S;
extern ROMMABLE  INP_HID_WEIGHT_S grgHiddenWeight_S[gcHiddenNode_S*gcHiddenWeightHeight_S*gcHiddenWeightWidth_S];
extern ROMMABLE  HID_BIAS_S grgHiddenBias_S[gcHiddenNode_S];


// Output Layer
#define gcOutputNode_S 1
#define gcOutputWeightHeight_S 23
#define gcOutputWeightWidth_S 3
extern int giOutputScale_S;
extern ROMMABLE  HID_OUT_WEIGHT_S grgOutputWeight_S[gcOutputNode_S*gcOutputWeightHeight_S*gcOutputWeightWidth_S];
extern ROMMABLE  OUT_BIAS_S grgOutputBias_S[gcOutputNode_S];


// Input Layer
extern ROMMABLE INP_BIAS_S grgInputBias_S[gcHiddenWeightHeight_S];

#endif // __INC_SNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\tpunc.c ===
// tpunc.c (trailing punctuation)
// Angshuman Guha
// aguha
// Nov 15, 2000

// John's rules allowed a specific finite set of short strings composed of "'`,.:;?!)]}/*
// He also imposed the restriction that two identical quote marks couldn't be adjacent.
// I am allowing a string unlimited in length.
// I am enforcing two adjacent quote marks to be different.
// I am including 's and (s) here: they are allowed only at the beginning.

#include "common.h"
#include "tpunc.h"

// text generated by re2fsa at Fri Feb 02 15:37:41 2001

// the input-file of rules:
// T = DQ 
// T = t
// T = DQ t
// T = t DQ 
// T = SQ 
// T = SQ t
// T = t SQ 
// T = SQ DQ 
// T = t SQ DQ 
// T = SQ DQ t
// T = DQ SQ 
// T = t DQ SQ 
// T = DQ SQ t
// T = rparen DQ dot 
// T = rparen SQ dot 
// t = comma 
// t = dot 
// t = dot dot dot 
// t = dot dot dot dot 
// t = colon 
// t = semicolon 
// t = question 
// t = question question 
// t = question question question 
// t = exclamation 
// t = exclamation exclamation 
// t = exclamation exclamation exclamation 
// t = rparen 
// t = rparen comma 
// t = rparen dot 
// t = rparen colon 
// t = rparen semicolon 
// t = rparen question 
// t = rparen question question 
// t = rparen question question question 
// t = rparen exclamation 
// t = rparen exclamation exclamation 
// t = rparen exclamation exclamation exclamation 
// t = rparen rparen 
// t = rparen rparen comma 
// t = rparen rparen dot 
// t = rparen rparen colon 
// t = rparen rparen semicolon 
// t = rparen rparen question 
// t = rparen rparen question question 
// t = rparen rparen question question question 
// t = rparen rparen exclamation 
// t = rparen rparen exclamation exclamation 
// t = rparen rparen exclamation exclamation exclamation 
// t = comma rparen 
// t = dot rparen 
// t = colon rparen 
// t = semicolon rparen 
// t = question rparen 
// t = question question rparen 
// t = question question question rparen 
// t = exclamation rparen 
// t = exclamation exclamation rparen 
// t = exclamation exclamation exclamation rparen 
// t = dot dot dot rparen 
// t = rbracket 
// t = rbracket comma 
// t = rbracket dot 
// t = rbracket colon 
// t = rbracket semicolon 
// t = rbracket question 
// t = rbracket question question 
// t = rbracket question question question 
// t = rbracket exclamation 
// t = rbracket exclamation exclamation 
// t = rbracket exclamation exclamation exclamation 
// t = rbrace 
// t = rbrace comma 
// t = rbrace dot 
// t = rbrace colon 
// t = rbrace semicolon 
// t = rbrace question 
// t = rbrace question question 
// t = rbrace question question question 
// t = rbrace exclamation 
// t = rbrace exclamation exclamation 
// t = rbrace exclamation exclamation exclamation 
// t = "*" ["*" ["*"]]
// t = "/"
// DQ = "\""
// SQ = "'"
// rparen = ")"
// dot = "."
// comma = ","
// colon = ":"
// semicolon = ";"
// question = "?"
// exclamation = "!"
// rbracket = "]"
// rbrace = "}"
// ess = "'" "sS"
// ess = "(" "sS" ")"
// final = ess
// final = [ess] T
// = final

// 46 states

static const unsigned char gaSTPUNC[] = 
	/* gaStringTPUNC+0 */	"(\000"
	/* gaStringTPUNC+2 */	"!\000"
	/* gaStringTPUNC+4 */	"\"\000"
	/* gaStringTPUNC+6 */	"'\000"
	/* gaStringTPUNC+8 */	")\000"
	/* gaStringTPUNC+10 */	"*\000"
	/* gaStringTPUNC+12 */	",:;\000"
	/* gaStringTPUNC+16 */	".\000"
	/* gaStringTPUNC+18 */	"/\000"
	/* gaStringTPUNC+20 */	"?\000"
	/* gaStringTPUNC+22 */	"]}\000"
	/* gaStringTPUNC+25 */	"Ss\000"
	/* gaStringTPUNC+28 */	",.:;\000"
	/* gaStringTPUNC+33 */	").\000"
	/* gaStringTPUNC+36 */	"'.\000"
	/* gaStringTPUNC+39 */	"\".\000"
;

static const STATE_TRANSITION gaTTPUNC[] = {
	{gaSTPUNC+0,	1}, // +0: state 0 transitions
	{gaSTPUNC+2,	5},
	{gaSTPUNC+4,	7},
	{gaSTPUNC+6,	8},
	{gaSTPUNC+8,	9},
	{gaSTPUNC+10,	10},
	{gaSTPUNC+12,	12},
	{gaSTPUNC+16,	13},
	{gaSTPUNC+18,	14},
	{gaSTPUNC+20,	15},
	{gaSTPUNC+22,	17},
	{gaSTPUNC+25,	4}, // +11: state 1 transitions
	{gaSTPUNC+16,	25}, // +12: state 2 transitions
	{gaSTPUNC+16,	45}, // +13: state 3 transitions
	{gaSTPUNC+8,	28}, // +14: state 4 transitions
	{gaSTPUNC+2,	6}, // +15: state 5 transitions
	{gaSTPUNC+8,	14},
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+2,	12}, // +19: state 6 transitions
	{gaSTPUNC+8,	14},
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+18,	24}, // +23: state 7 transitions
	{gaSTPUNC+2,	30},
	{gaSTPUNC+6,	32},
	{gaSTPUNC+8,	33},
	{gaSTPUNC+10,	34},
	{gaSTPUNC+12,	36},
	{gaSTPUNC+16,	37},
	{gaSTPUNC+20,	38},
	{gaSTPUNC+22,	40},
	{gaSTPUNC+18,	24}, // +32: state 8 transitions
	{gaSTPUNC+25,	28},
	{gaSTPUNC+2,	30},
	{gaSTPUNC+4,	32},
	{gaSTPUNC+8,	33},
	{gaSTPUNC+10,	34},
	{gaSTPUNC+12,	36},
	{gaSTPUNC+16,	37},
	{gaSTPUNC+20,	38},
	{gaSTPUNC+22,	40},
	{gaSTPUNC+28,	14}, // +42: state 9 transitions
	{gaSTPUNC+8,	17},
	{gaSTPUNC+2,	18},
	{gaSTPUNC+20,	22},
	{gaSTPUNC+4,	26},
	{gaSTPUNC+6,	27},
	{gaSTPUNC+10,	11}, // +48: state 10 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+10,	14}, // +51: state 11 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+8,	14}, // +54: state 12 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+16,	2}, // +57: state 13 transitions
	{gaSTPUNC+8,	14},
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+4,	20}, // +61: state 14 transitions
	{gaSTPUNC+6,	21},
	{gaSTPUNC+8,	14}, // +63: state 15 transitions
	{gaSTPUNC+20,	16},
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+20,	12}, // +67: state 16 transitions
	{gaSTPUNC+8,	14},
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+28,	14}, // +71: state 17 transitions
	{gaSTPUNC+2,	18},
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+20,	22},
	{gaSTPUNC+2,	19}, // +76: state 18 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+2,	14}, // +79: state 19 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+6,	24}, // +82: state 20 transitions
	{gaSTPUNC+4,	24}, // +83: state 21 transitions
	{gaSTPUNC+4,	20}, // +84: state 22 transitions
	{gaSTPUNC+6,	21},
	{gaSTPUNC+20,	23},
	{gaSTPUNC+20,	14}, // +87: state 23 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+33,	14}, // +90: state 25 transitions
	{gaSTPUNC+4,	20},
	{gaSTPUNC+6,	21},
	{gaSTPUNC+36,	24}, // +93: state 26 transitions
	{gaSTPUNC+39,	24}, // +94: state 27 transitions
	{gaSTPUNC+2,	5}, // +95: state 28 transitions
	{gaSTPUNC+4,	7},
	{gaSTPUNC+8,	9},
	{gaSTPUNC+10,	10},
	{gaSTPUNC+12,	12},
	{gaSTPUNC+16,	13},
	{gaSTPUNC+18,	14},
	{gaSTPUNC+20,	15},
	{gaSTPUNC+22,	17},
	{gaSTPUNC+6,	29},
	{gaSTPUNC+18,	24}, // +105: state 29 transitions
	{gaSTPUNC+2,	30},
	{gaSTPUNC+4,	32},
	{gaSTPUNC+8,	33},
	{gaSTPUNC+10,	34},
	{gaSTPUNC+12,	36},
	{gaSTPUNC+16,	37},
	{gaSTPUNC+20,	38},
	{gaSTPUNC+22,	40},
	{gaSTPUNC+8,	24}, // +114: state 30 transitions
	{gaSTPUNC+2,	31},
	{gaSTPUNC+8,	24}, // +116: state 31 transitions
	{gaSTPUNC+2,	36},
	{gaSTPUNC+18,	24}, // +118: state 32 transitions
	{gaSTPUNC+2,	30},
	{gaSTPUNC+8,	33},
	{gaSTPUNC+10,	34},
	{gaSTPUNC+12,	36},
	{gaSTPUNC+16,	37},
	{gaSTPUNC+20,	38},
	{gaSTPUNC+22,	40},
	{gaSTPUNC+28,	24}, // +126: state 33 transitions
	{gaSTPUNC+8,	40},
	{gaSTPUNC+2,	41},
	{gaSTPUNC+20,	43},
	{gaSTPUNC+10,	35}, // +130: state 34 transitions
	{gaSTPUNC+10,	24}, // +131: state 35 transitions
	{gaSTPUNC+8,	24}, // +132: state 36 transitions
	{gaSTPUNC+16,	3}, // +133: state 37 transitions
	{gaSTPUNC+8,	24},
	{gaSTPUNC+8,	24}, // +135: state 38 transitions
	{gaSTPUNC+20,	39},
	{gaSTPUNC+8,	24}, // +137: state 39 transitions
	{gaSTPUNC+20,	36},
	{gaSTPUNC+28,	24}, // +139: state 40 transitions
	{gaSTPUNC+2,	41},
	{gaSTPUNC+20,	43},
	{gaSTPUNC+2,	42}, // +142: state 41 transitions
	{gaSTPUNC+2,	24}, // +143: state 42 transitions
	{gaSTPUNC+20,	44}, // +144: state 43 transitions
	{gaSTPUNC+20,	24}, // +145: state 44 transitions
	{gaSTPUNC+33,	24}, // +146: state 45 transitions
};

const STATE_DESCRIPTION aStateDescTPUNC[46] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 11, gaTTPUNC+0},
	/*   1 */ {0, 1, gaTTPUNC+11},
	/*   2 */ {0, 1, gaTTPUNC+12},
	/*   3 */ {0, 1, gaTTPUNC+13},
	/*   4 */ {0, 1, gaTTPUNC+14},
	/*   5 */ {1, 4, gaTTPUNC+15},
	/*   6 */ {1, 4, gaTTPUNC+19},
	/*   7 */ {1, 9, gaTTPUNC+23},
	/*   8 */ {1, 10, gaTTPUNC+32},
	/*   9 */ {1, 6, gaTTPUNC+42},
	/*  10 */ {1, 3, gaTTPUNC+48},
	/*  11 */ {1, 3, gaTTPUNC+51},
	/*  12 */ {1, 3, gaTTPUNC+54},
	/*  13 */ {1, 4, gaTTPUNC+57},
	/*  14 */ {1, 2, gaTTPUNC+61},
	/*  15 */ {1, 4, gaTTPUNC+63},
	/*  16 */ {1, 4, gaTTPUNC+67},
	/*  17 */ {1, 5, gaTTPUNC+71},
	/*  18 */ {1, 3, gaTTPUNC+76},
	/*  19 */ {1, 3, gaTTPUNC+79},
	/*  20 */ {1, 1, gaTTPUNC+82},
	/*  21 */ {1, 1, gaTTPUNC+83},
	/*  22 */ {1, 3, gaTTPUNC+84},
	/*  23 */ {1, 3, gaTTPUNC+87},
	/*  24 */ {1, 0, NULL},
	/*  25 */ {1, 3, gaTTPUNC+90},
	/*  26 */ {1, 1, gaTTPUNC+93},
	/*  27 */ {1, 1, gaTTPUNC+94},
	/*  28 */ {1, 10, gaTTPUNC+95},
	/*  29 */ {1, 9, gaTTPUNC+105},
	/*  30 */ {1, 2, gaTTPUNC+114},
	/*  31 */ {1, 2, gaTTPUNC+116},
	/*  32 */ {1, 8, gaTTPUNC+118},
	/*  33 */ {1, 4, gaTTPUNC+126},
	/*  34 */ {1, 1, gaTTPUNC+130},
	/*  35 */ {1, 1, gaTTPUNC+131},
	/*  36 */ {1, 1, gaTTPUNC+132},
	/*  37 */ {1, 2, gaTTPUNC+133},
	/*  38 */ {1, 2, gaTTPUNC+135},
	/*  39 */ {1, 2, gaTTPUNC+137},
	/*  40 */ {1, 3, gaTTPUNC+139},
	/*  41 */ {1, 1, gaTTPUNC+142},
	/*  42 */ {1, 1, gaTTPUNC+143},
	/*  43 */ {1, 1, gaTTPUNC+144},
	/*  44 */ {1, 1, gaTTPUNC+145},
	/*  45 */ {1, 1, gaTTPUNC+146},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\charcost.c ===
// charcost.c
// created by extracting code from beam.c
// March 11, 1999
// Angshuman Guha,  aguha

#include <limits.h>
#include "common.h"
#include "charmap.h"
#include "infernop.h"
#include "nnet.h"
#include "probcost.h"

// Global data containing the log probs of the neural network outputs, for the
// current column.
// NetContActivation() and NetFirstActivation() are macros for fetching the 2 log-probs
// associated with a particular letter.

// Initializes the log-probs of the neural network outputs in the current column,
// and recomputes the best drops for this column.

void InitColumn(int *aActivations, const REAL *pAct)
{
	int c;

	for (c = gcOutputNode; c; c--, pAct++, aActivations++)
	{
		*aActivations = PROB_TO_COST(*pAct);
	}

}

void ComputeCharacterProbs(const REAL *pActivation, int cSegment, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong)
{
	int row, col;
	unsigned char thisChar;
	const int ShortWidth = 4;
	const int LongWidth = 7;

	// short window
	memset(aCharProb, 0, 256*sizeof(REAL));
	memset(aCharBeginProb, 0, 256*sizeof(REAL));
	col = cSegment;
	if (col > ShortWidth)
		col = ShortWidth;
	for (; col; col--)
	{
		for (row=0; row<gcOutputNode; row++, pActivation++)
		{
			thisChar = Out2Char(row);
			if (*pActivation > aCharProb[thisChar])
				aCharProb[thisChar] = *pActivation;
			if (IsOutputBegin(row))
			{
				if (*pActivation > aCharBeginProb[thisChar])
					aCharBeginProb[thisChar] = *pActivation;
			}
		}
	}

	// long window
	if (!aCharProbLong || !aCharBeginProbLong)
		return;
	memcpy(aCharProbLong, aCharProb, 256*sizeof(REAL));
	memcpy(aCharBeginProbLong, aCharBeginProb, 256*sizeof(REAL));

	col = cSegment - ShortWidth;
	if (col <= 0)
		return;
	if (col > LongWidth - ShortWidth)
		col = LongWidth - ShortWidth;
	for (; col; col--)
	{
		for (row=0; row<gcOutputNode; row++, pActivation++)
		{
			thisChar = Out2Char(row);
			if (*pActivation > aCharProbLong[thisChar])
				aCharProbLong[thisChar] = *pActivation;
			if (IsOutputBegin(row))
			{
				if (*pActivation > aCharBeginProbLong[thisChar])
					aCharBeginProbLong[thisChar] = *pActivation;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\charcost.h ===
// charcost.h
// March 11, 1999
// Angshuman Guha,  aguha

// Language specific tuning constants which help with word breaking decisions in beam.c

// 1) Maximum overlap of strokes within a wordgap
#define MAX_STROKE_OVERLAP (5)

// 2) Tuning factor that turns for space node Cost (numerator and denominator)
#define IS_SPACE_NUM	(5)
#define IS_SPACE_DEN	(2)

// 3) Tuning factor  for Not space cost
#define NOT_SPACE_NUM	(5)
#define NOT_SPACE_DEN	(3)

// 4) Tuning factor to for allowing a 'Factoid Space' based on space output
#define FACTOID_SPACE_FUDGE		(90)

#define INFINITY_COST 999999999

#define NetContActivation(aActivations, ch) (ContinueChar2Out(ch) < 255 ? aActivations[ContinueChar2Out(ch)]: ZERO_PROB_COST*4)
#define NetFirstActivation(aActivations, ch) aActivations[BeginChar2Out(ch)]

// Macros that work on the activation state index
#define IsOutputBeginAct(si) (IsOutputBegin(si))
#define Out2CharAct(si) (Out2Char(si))
#define BeginChar2OutAct(si) (BeginChar2Out(si))

void InitColumn(int * aActivations, const REAL *pAct);
void ComputeCharacterProbs(const REAL *pActivation, int cSegments, REAL *aCharProb, REAL *aCharBeginProb, REAL *aCharProbLong, REAL *aCharBeginProbLong);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\uk\viterbixlate.c ===
/****************************************************
 *
 * viterbiXlate.c
 *
 * Provides translation services between activataions and supported characters
 * for the viterbi search
 *
 * This is language specific, because activations construct virtual activation USA does not therefore
 * cannot simply use net outputs activations as surrogate
 * for character activations
 *
 ********************************************************/  
#include <common.h>
#include <nfeature.h>
#include <engine.h>
#include <infernop.h>
#include "charmap.h"
#include <charcost.h>
#include <outDict.h>
#include <viterbi.h>


void BuildActiveMap(const REAL *pActivation, int cSegments, int cOutput, BYTE rgbActiveChar[C_CHAR_ACTIVATIONS])
{
	int				row, col, cActive, cIteration = 5;
	const REAL		*pAct;
	REAL			MinActivation = (REAL)
#ifdef FIXEDPOINT
	655;
#else
	0.01;
#endif

	do 
	{
		cActive = 0;
		memset(rgbActiveChar, 0, C_CHAR_ACTIVATIONS*sizeof(*rgbActiveChar));
		pAct = pActivation;

		for (col=cSegments; col; col--)
		{
			pAct++;

			for (row = 1 ; row < cOutput ; row++, pAct++)
			{
				if (*pAct > MinActivation)
				{
					rgbActiveChar[row] = 1;
					++cActive;
				}
			}
		}

		// Keep doubling the min activation if there are too many active characters
		MinActivation *= 2;

	} while ((cActive > OD_MAX_ACTIVE_CHAR) && --cIteration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\fforward.h ===
void FeedForward(FFINFO *ffinfo);
//BOOL FeedForwardNoSpace(NFEATURESET *nfeatureset, REAL *NeuralOutput);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\lpunc.c ===
// lpunc.c (leading punctuation)
// Angshuman Guha
// aguha
// Nov 15, 2000

#include "common.h"
#include "lpunc.h"

// text generated by re2fsa at Fri Feb 02 15:35:36 2001

// the input-file of rules:
// L = DQ
// L = l
// L = DQ l
// L = l DQ
// L = SQ
// L = SQ l
// L = l SQ
// L = SQ DQ
// L = DQ SQ
// L = BQ
// L = BQ l
// L = l BQ
// L = BQ DQ
// L = DQ BQ
// # L''
// # L''l
// # Ll''
// # L``
// # L``l
// # Ll``
// l = "("
// l = "["
// l = "{"
// l = "-"
// l = "." "." "."
// l = "*" ["*" ["*"]]
// DQ = "\""
// SQ = "'"
// BQ = "`"
// = L

// 13 states

static const unsigned char gaSLPUNC[] = 
	/* gaStringLPUNC+0 */	".\000"
	/* gaStringLPUNC+2 */	"\"\000"
	/* gaStringLPUNC+4 */	"'`\000"
	/* gaStringLPUNC+7 */	"(-[{\000"
	/* gaStringLPUNC+12 */	"*\000"
	/* gaStringLPUNC+14 */	"'(-[`{\000"
	/* gaStringLPUNC+21 */	"\"(-[{\000"
	/* gaStringLPUNC+27 */	"\"'`\000"
;

static const STATE_TRANSITION gaTLPUNC[] = {
	{gaSLPUNC+0,	1}, // +0: state 0 transitions
	{gaSLPUNC+2,	5},
	{gaSLPUNC+4,	6},
	{gaSLPUNC+7,	7},
	{gaSLPUNC+12,	8},
	{gaSLPUNC+0,	4}, // +5: state 1 transitions
	{gaSLPUNC+0,	3}, // +6: state 2 transitions
	{gaSLPUNC+0,	10}, // +7: state 3 transitions
	{gaSLPUNC+0,	7}, // +8: state 4 transitions
	{gaSLPUNC+0,	2}, // +9: state 5 transitions
	{gaSLPUNC+14,	10},
	{gaSLPUNC+12,	11},
	{gaSLPUNC+0,	2}, // +12: state 6 transitions
	{gaSLPUNC+21,	10},
	{gaSLPUNC+12,	11},
	{gaSLPUNC+27,	10}, // +15: state 7 transitions
	{gaSLPUNC+12,	9}, // +16: state 8 transitions
	{gaSLPUNC+27,	10},
	{gaSLPUNC+12,	7}, // +18: state 9 transitions
	{gaSLPUNC+27,	10},
	{gaSLPUNC+12,	12}, // +20: state 11 transitions
	{gaSLPUNC+12,	10}, // +21: state 12 transitions
};

const STATE_DESCRIPTION aStateDescLPUNC[13] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTLPUNC+0},
	/*   1 */ {0, 1, gaTLPUNC+5},
	/*   2 */ {0, 1, gaTLPUNC+6},
	/*   3 */ {0, 1, gaTLPUNC+7},
	/*   4 */ {0, 1, gaTLPUNC+8},
	/*   5 */ {1, 3, gaTLPUNC+9},
	/*   6 */ {1, 3, gaTLPUNC+12},
	/*   7 */ {1, 1, gaTLPUNC+15},
	/*   8 */ {1, 2, gaTLPUNC+16},
	/*   9 */ {1, 2, gaTLPUNC+18},
	/*  10 */ {1, 0, NULL},
	/*  11 */ {1, 1, gaTLPUNC+20},
	/*  12 */ {1, 1, gaTLPUNC+21},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\lpunc.h ===
// lpunc.h
// Angshuman Guha
// aguha
// Jan 9, 2001

#ifndef __INC_LPUNC_H
#define __INC_LPUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescLPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\nnet.c ===
// nnet.c

#include <common.h>

#include "nnet.h"
#include "nnet.ci"

#include "snet.h"
#include "snet.ci"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\charmap.h ===
// charmap.h
// Angshuman Guha, aguha
// Jan 12, 1999

#ifndef __CHARMAP_H
#define __CHARMAP_H

#ifdef __cplusplus
extern "C" {
#endif

// Maximum number of character activations, (ie begin and continuation activation) supported by the
// recognizer
#define C_CHAR_ACTIVATIONS		gcOutputNode

//BYTE BeginChar2Out(char);
//BYTE ContinueChar2Out(char);

extern const BYTE rgCharToOutputNode[];
extern const unsigned char rgOutputNodeToChar[];

#define BeginChar2Out(ch) rgCharToOutputNode[2*((unsigned char)(ch))]
#define ContinueChar2Out(ch) rgCharToOutputNode[2*((unsigned char)(ch))+1]

#define IsSupportedChar(ch) (BeginChar2Out(ch) < 0xFF)

#define Out2Char(i) rgOutputNodeToChar[2*(i)+1]
#define IsOutputBegin(i) rgOutputNodeToChar[2*(i)]

// There are no virtual chars in US at this moment
#define IsVirtualChar(ch)		(0)
#define BaseVirtualChar(ch)		(255)
#define AccentVirtualChar(ch)	(255)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\number.h ===
// number.h
// Angshuman Guha, aguha
// Sep 18, 1998

#ifndef __INC_NUMBER_H
#define __INC_NUMBER_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescNUMBER[];
extern const STATE_DESCRIPTION aStateDescNUMSIMPLE[];
extern const STATE_DESCRIPTION aStateDescNUMNTH[];
extern const STATE_DESCRIPTION aStateDescNUMUNIT[];
extern const STATE_DESCRIPTION aStateDescNUMNUM[];
extern const STATE_DESCRIPTION aStateDescNUMPERCENT[];
extern const STATE_DESCRIPTION aStateDescNUMDATE[];
extern const STATE_DESCRIPTION aStateDescNUMTIME[];
extern const STATE_DESCRIPTION aStateDescNUMCURRENCY[];
extern const STATE_DESCRIPTION aStateDescNUMPHONE[];
extern const STATE_DESCRIPTION aStateDescNUMMATH[];
extern const STATE_DESCRIPTION aStateDescZIP[];
extern const STATE_DESCRIPTION aStateDescCREDITCARD[];
extern const STATE_DESCRIPTION aStateDescDAYOFMONTH[];
extern const STATE_DESCRIPTION aStateDescMONTHNUM[];
extern const STATE_DESCRIPTION aStateDescYEAR[];
extern const STATE_DESCRIPTION aStateDescSECOND[];
extern const STATE_DESCRIPTION aStateDescMINUTE[];
extern const STATE_DESCRIPTION aStateDescHOUR[];
extern const STATE_DESCRIPTION aStateDescSSN[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\charmap.c ===
// charmap.c
// Angshuman Guha, aguha
// Jan 12, 1999
// Modified June 5, 2000: added  and euro, deleted a whole bunch of "continue" nodes
//Modified by Mango Dec,10,2001:added the ,,
#include "common.h"
#include "charmap.h"

#define COUTPUT 180

const BYTE rgCharToOutputNode[2*256] = {
	// the first number is the beginning-activation node
	// the second number is the continuing-activation node
	// the value 255 means there is no output node
	// Of the 95 printable ASCII, the following don't have a continuing-activation node
	//		space ' ( ) , - . / < > [ \ ] ^ _ ` { | } 
	255, 255, //0
	255, 255, //1
	255, 255,  //2
	255, 255,  //3
	255, 255,  //4
	255, 255,  //5
	255, 255,  //6
	255, 255,  //7
	255, 255,  //8
	255, 255,  //9
	255, 255,  //10
	255, 255,  //11		
	255, 255,	//12
	255, 255,	//13
	255, 255,	//14
	255, 255,	//15
	255, 255,	//16
	255, 255,	//17	
	255, 255,	//18	
	255, 255,	//19
	255, 255,	//20
	255, 255,	//21
	255, 255,	//22
	255, 255,	//23
	255, 255,	//24
	255, 255,	//25
	255, 255,	//26
	255, 255,	//27
	255, 255,	//28
	255, 255,	//29
	255, 255,	//30
	255, 255,	//31
	  0, 255, // space	//32
	  5,   6, // ! //33
	 11,  12, // " //34
	 27,  28, // # //35
	  7,   8, // $  //36
	 29,  30, // %   //37
	 31,  32, // &   //38
	  9, 255, // '   //39
	 13, 255, // (	 //40
	 14, 255, // )	//41
	 33,  34, // *	//42
	 35,  36, // +	//43
	  2, 255, // ,	//44
	 15, 255, // -	45
	  1, 255, // .  46
	 21, 255, // /	47
	 51,  52, // 0	48
	 53,  54, // 1	49
	 55,  56, // 2	50
	 57,  58, // 3	51
	 59,  60, // 4	52
	 61,  62, // 5	53
	 63,  64, // 6	54
	 65,  66, // 7	55
	 67,  68, // 8	56
	 69,  70, // 9	57
	 17,  18, // :	58
	 19,  20, // ;	59
	 37, 255, // <	60
	 38,  39, // =	61
	 40, 255, // >	62
	  3,   4, // ?	63
	 41,  42, // @	64
	123, 124, // A	65
	125, 126, // B	66
	127, 128, // C	67
	129, 130, // D  68
	131, 132, // E	69
	133, 134, // F	70
	135, 136, // G	71
	137, 138, // H	72 
	139, 140, // I	73
	141, 142, // J	74
	143, 144, // K	75
	145, 146, // L	76
	147, 148, // M	77
	149, 150, // N	78
	151, 152, // O	79
	153, 154, // P	80
	155, 156, // Q	81
	157, 158, // R	82
	159, 160, // S	83
	161, 162, // T	84
	163, 164, // U	85
	165, 166, // V	86
	167, 168, // W	87
	169, 170, // X	88
	171, 172, // Y	89
	173, 174, // Z	90
	 43, 255, // [	91
	 22, 255, // \	92
	 44, 255, // ]	93
	 45, 255, // ^	94
	 16, 255, // _	95
	 10, 255, // `	96
	 71,  72, // a	97
	 73,  74, // b	98
	 75,  76, // c	99
	 77,  78, // d	100
	 79,  80, // e  101
	 81,  82, // f  102
	 83,  84, // g  103
	 85,  86, // h  104
	 87,  88, // i	105
	 89,  90, // j	106
	 91,  92, // k	107
	 93,  94, // l	108
	 95,  96, // m	109
	 97,  98, // n	110
	 99, 100, // o	111	
	101, 102, // p	112
	103, 104, // q	113
	105, 106, // r	114
	107, 108, // s	115
	109, 110, // t	116
	111, 112, // u	117
	113, 114, // v	118
	115, 116, // w	119	
	117, 118, // x	120
	119, 120, // y	121
	121, 122, // z	122
	 46, 255, // {	123
	 47, 255, // |	124
	 48, 255, // }	125
	 49,  50, // ~	126
	255, 255,		//127
	 25,  26, // euro 128
	255, 255,	//129
	255, 255,	//130
	255, 255,	//131
	255, 255,	//132
	255, 255,	//133
	255, 255,	//134
	255, 255,	//135
	255, 255,	//136
	255, 255,	//137
	255, 255,	//138
	255, 255,	//139
	255, 255,	//140
	255, 255,	//141
	255, 255,	//142
	255, 255,	//143
	255, 255,	//144
	255, 255,	//145
	255, 255,	//146
	255, 255,	//147
	255, 255,	//148
	255, 255,	//149
	255, 255,	//150
	255, 255,	//151
	255, 255,	//152
	255, 255,	//153
	255, 255,	//154
	255, 255,	//155
	255, 255,	//156
	255, 255,	//157
	255, 255,	//158
	255, 255,	//159
	  0, 255, // NBSP maps to space //160
	255, 255,	//161
	177, 178,	// 162
	 23,  24, //  //163
	255, 255,	//164
	175, 176,  //  165
	255, 255,	//166
	255, 255,	//167
	255, 255,	//168
	255, 255,	//169
	255, 255,	//170
	255, 255,	//171
	255, 255,	//172
	255, 255,	//173
	255, 255,	//174
	255, 255,	//175
	179, 255,	//  176
	255, 255,	//177
	255, 255,	//178
	255, 255,	//179
	255, 255,	//180
	255, 255,   //181
	255, 255,	//182
	255, 255,	//183
	255, 255,	//184
	255, 255,	//185
	255, 255,	//186
	255, 255,	//187
	255, 255,	//188
	255, 255,	//189
	255, 255,	//190
	255, 255,	//191
	255, 255,	//192
	255, 255,	//193
	255, 255,	//194
	255, 255,	//195
	255, 255,	//196
	255, 255,	//197
	255, 255,	//198
	255, 255,	//199
	255, 255,	//200
	255, 255,	//201
	255, 255,	//202
	255, 255,	//203
	255, 255,	//204
	255, 255,	//205
	255, 255,	//206
	255, 255,	//207
	255, 255,	//208
	255, 255,	//209
	255, 255,	//210
	255, 255,	//211
	255, 255,	//212
	255, 255,	//213
	255, 255,	//214
	255, 255,	//215
	255, 255,	//216
	255, 255,	//217
	255, 255,	//218
	255, 255,	//219
	255, 255,	//220
	255, 255,	//221
	255, 255,	//222
	255, 255,	//223
	255, 255,	//224
	255, 255,	//225
	255, 255,	//226
	255, 255,	//227
	255, 255,	//228
	255, 255,	//229
	255, 255,	//230
	255, 255,	//231
	255, 255,	//232
	255, 255,	//233
	255, 255,	//234
	255, 255,	//235
	255, 255,	//236
	255, 255,	//237
	255, 255,	//238
	255, 255,	//239
	255, 255,	//240
	255, 255,	//241
	255, 255,	//242
	255, 255,	//243
	255, 255,	//244
	255, 255,	//245
	255, 255,	//246
	255, 255,	//247
	255, 255,	//248
	255, 255,	//249
	255, 255,	//250
	255, 255,	//251
	255, 255,	//252
	255, 255,	//253
	255, 255,	//254
	255, 255,   //255
};

const unsigned char rgOutputNodeToChar[2*COUTPUT] = {
	// the first number is 0 for char-continuation node, 1 for char-beginning node
	// the second number is the character

	// space
	1, ' ', // 0

	// common punc
	1, '.', // 1
	1, ',', // 2
	1, '?', // 3
	0, '?', // 4
	1, '!', // 5
	0, '!', // 6
	1, '$', // 7
	0, '$', // 8
	1, '\'',// 9
	1, '`', // 10
	1, '"', // 11
	0, '"', // 12
	1, '(', // 13
	1, ')', // 14
	1, '-', // 15
	1, '_', // 16
	1, ':', // 17
	0, ':', // 18
	1, ';', // 19
	0, ';', // 20
	1, '/', // 21
	1, '\\',// 22
	1, '', // 23
	0, '', // 24
	1, '', // 25 euro
	0, '', // 26 euro
	
	// rare punc
	1, '#', // 27
	0, '#', // 28
	1, '%', // 29
	0, '%', // 30
	1, '&', // 31
	0, '&', // 32
	1, '*', // 33
	0, '*', // 34
	1, '+', // 35
	0, '+', // 36
	1, '<', // 37
	1, '=', // 38
	0, '=', // 39
	1, '>', // 40
	1, '@', // 41
	0, '@', // 42
	1, '[', // 43
	1, ']', // 44
	1, '^', // 45
	1, '{', // 46
	1, '|', // 47
	1, '}', // 48
	1, '~', // 49
	0, '~', // 50

	// digits
	1, '0', // 51
	0, '0', // 52
	1, '1', // 53
	0, '1', // 54
	1, '2', // 55
	0, '2', // 56
	1, '3', // 57
	0, '3', // 58
	1, '4', // 59
	0, '4', // 60
	1, '5', // 61
	0, '5', // 62
	1, '6', // 63
	0, '6', // 64
	1, '7', // 65
	0, '7', // 66
	1, '8', // 67
	0, '8', // 68
	1, '9', // 69
	0, '9', // 70

	// lowercase alphabets
	1, 'a', // 71
	0, 'a', // 72
	1, 'b', // 73
	0, 'b', // 74
	1, 'c', // 75
	0, 'c', // 76
	1, 'd', // 77
	0, 'd', // 78
	1, 'e', // 79
	0, 'e', // 80
	1, 'f', // 81
	0, 'f', // 82
	1, 'g', // 83
	0, 'g', // 84
	1, 'h', // 85
	0, 'h', // 86
	1, 'i', // 87
	0, 'i', // 88
	1, 'j', // 89
	0, 'j', // 90
	1, 'k', // 91
	0, 'k', // 92
	1, 'l', // 93
	0, 'l', // 94
	1, 'm', // 95
	0, 'm', // 96
	1, 'n', // 97
	0, 'n', // 98
	1, 'o', // 99
	0, 'o', // 100
	1, 'p', // 101
	0, 'p', // 102
	1, 'q', // 103
	0, 'q', // 104
	1, 'r', // 105
	0, 'r', // 106
	1, 's', // 107
	0, 's', // 108
	1, 't', // 109
	0, 't', // 110
	1, 'u', // 111
	0, 'u', // 112
	1, 'v', // 113
	0, 'v', // 114
	1, 'w', // 115
	0, 'w', // 116
	1, 'x', // 117
	0, 'x', // 118
	1, 'y', // 119
	0, 'y', // 120
	1, 'z', // 121
	0, 'z', // 122

	// uppercase alphabets
	1, 'A', // 123
	0, 'A', // 124
	1, 'B', // 125
	0, 'B', // 126
	1, 'C', // 127
	0, 'C', // 128
	1, 'D', // 129
	0, 'D', // 130
	1, 'E', // 131
	0, 'E', // 132
	1, 'F', // 133
	0, 'F', // 134
	1, 'G', // 135
	0, 'G', // 136
	1, 'H', // 137
	0, 'H', // 138
	1, 'I', // 139
	0, 'I', // 140
	1, 'J', // 141
	0, 'J', // 142
	1, 'K', // 143
	0, 'K', // 144
	1, 'L', // 145
	0, 'L', // 146
	1, 'M', // 147
	0, 'M', // 148
	1, 'N', // 149
	0, 'N', // 150
	1, 'O', // 151
	0, 'O', // 152
	1, 'P', // 153
	0, 'P', // 154
	1, 'Q', // 155
	0, 'Q', // 156
	1, 'R', // 157
	0, 'R', // 158
	1, 'S', // 159
	0, 'S', // 160
	1, 'T', // 161
	0, 'T', // 162
	1, 'U', // 163
	0, 'U', // 164
	1, 'V', // 165
	0, 'V', // 166
	1, 'W', // 167
	0, 'W', // 168
	1, 'X', // 169
	0, 'X', // 170
	1, 'Y', // 171
	0, 'Y', // 172
	1, 'Z', // 173
	0, 'Z', // 174
	
	1, '', //175
	0, '', //176
	1, '', //177
	0, '', //178
	1, '', //179

};

/*
BYTE BeginChar2Out(char ch)
{
	BYTE x;

	x = rgCharToOutputNode[2*(ch)];
	ASSERT(x < COUTPUT);
	return x;
}

BYTE ContinueChar2Out(char ch)
{
	BYTE x;

	x = rgCharToOutputNode[2*(ch)+1];
	ASSERT(x < COUTPUT);
	return x;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\prefix.c ===
// prefix.c
// Angshuman Guha
// aguha
// April 17, 2001

#include "common.h"
#include "prefix.h"

const STATE_DESCRIPTION *aStateDescPrefix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\prefix.h ===
// prefix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_PREFIX_H
#define __INC_PREFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescPrefix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\punc.h ===
// punc.h
// Angshuman Guha, aguha
// Sep 22, 1998
// Major mod Jan 10, 2001

#ifndef __INC_PUNC_H
#define __INC_PUNC_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescPUNC[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\shrtlist.h ===
// shrtlist.c
// Angshuman Guha
// aguha
// Feb 7, 2001

#ifndef __INC_SHORTLIST_H
#define __INC_SHORTLIST_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescDAYOFWEEK[];
extern const STATE_DESCRIPTION aStateDescMONTH[];
extern const STATE_DESCRIPTION aStateDescGENDER[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\nnet.h ===
// nnet.h
// computed from <main.net,mixed.ist> (35840000) by net2c at Mon Mar 04 15:09:06 2002
#ifndef __INC_NNET_H
#define __INC_NNET_H

// Time Stamp
#define NET_TIME_STAMP	0x3c83fe91

// Type definitions

typedef short INP_HID_WEIGHT;
typedef short HID_BIAS;
typedef char HID_OUT_WEIGHT;
typedef short OUT_BIAS;
//typedef unsigned short INP_BIAS;


// Hidden Layer
#define gcHiddenNode 150
#define gcHiddenWeightHeight 37
#define gcHiddenWeightWidth 3
extern int giHiddenScale;
extern ROMMABLE  INP_HID_WEIGHT grgHiddenWeight[gcHiddenNode*gcHiddenWeightHeight*gcHiddenWeightWidth];
extern ROMMABLE  HID_BIAS grgHiddenBias[gcHiddenNode];


// Output Layer
#define gcOutputNode 180
#define gcOutputWeightHeight 150
#define gcOutputWeightWidth 3
extern int giOutputScale;
extern ROMMABLE  HID_OUT_WEIGHT grgOutputWeight[gcOutputNode*gcOutputWeightHeight*gcOutputWeightWidth];
extern ROMMABLE  OUT_BIAS grgOutputBias[gcOutputNode];


// Input Layer
//extern ROMMABLE INP_BIAS grgInputBias[gcHiddenWeightHeight];

#endif // __INC_NNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\singlech.c ===
// singlech.c
// Angshuman Guha
// aguha
// Feb 6, 2001

#include "common.h"
#include "singlech.h"

/**************** UPPERCHAR ***********************************/

static const STATE_TRANSITION gaTUPPERCHAR[] = { {"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1} };

const STATE_DESCRIPTION aStateDescUPPERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTUPPERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** LOWERCHAR ***********************************/

static const STATE_TRANSITION gaTLOWERCHAR[] = { {"abcdefghijklmnopqrstuvwxyz", 1} };

const STATE_DESCRIPTION aStateDescLOWERCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTLOWERCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** DIGITCHAR ***********************************/

static const STATE_TRANSITION gaTDIGITCHAR[] = { {"0123456789", 1} };

const STATE_DESCRIPTION aStateDescDIGITCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTDIGITCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** PUNCCHAR ***********************************/

static const STATE_TRANSITION gaTPUNCCHAR[] = { {"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", 1} };

const STATE_DESCRIPTION aStateDescPUNCCHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTPUNCCHAR },
	/*  1 */ { 1, 0, NULL }
};

/**************** ONECHAR ***********************************/

static const STATE_TRANSITION gaTONECHAR[] = { {"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", 1} };

const STATE_DESCRIPTION aStateDescONECHAR[2] = {
	/* state valid cTrans Trans */
	/*  0 */ { 0, 1, gaTONECHAR },
	/*  1 */ { 1, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\singlech.h ===
// singlech.h
// Angshuman Guha
// aguha
// Feb 6, 2001

#ifndef __INC_SINGLE_CHAR_H
#define __INC_SINGLE_CHAR_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION aStateDescUPPERCHAR[];
extern const STATE_DESCRIPTION aStateDescLOWERCHAR[];
extern const STATE_DESCRIPTION aStateDescDIGITCHAR[];
extern const STATE_DESCRIPTION aStateDescPUNCCHAR[];
extern const STATE_DESCRIPTION aStateDescONECHAR[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\fforward.c ===
#include "common.h"
#include "nfeature.h"
#include "engine.h"
#include "infernop.h"
#include "nnet.h"
#include "snet.h"
#include "fforward.h"

#include "math16.h"

// No loading necessary
BOOL InitInferno(HINSTANCE hInst)
{
	return TRUE;
}


/******************************Private*Routine******************************\
* GetNZSpaces
*
* Function to ount the number of non zero elements in the input array, and 
* the gaps between them. For ease of later bookeeping we also keep track of 
* the zero space counts at the start and end of each time slice.
* Returns the total number of NZ elements
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Wrote this comment header.
\**************************************************************************/
// 
int GetNZSpaces(
int		*pData,						// IN/OUT: Input Data array, on out is compacted to remove zero elements
int					cSlice,			// IN: Number of time slices
int					cLen,			// IN: Length of each time slice
unsigned short		*pNZgap,		// OUT: the gaps between the NZ elements
unsigned short		*pcNZPerCol		// OUT: Number of NZ elements per slice	
)
{
	int					i, j, k, cNZ, cGap;
	int					iLastNZ;

	i = 0;
	cNZ = cGap = 0;
	iLastNZ = 0;

	ASSERT(pData);
	ASSERT(pNZgap);
	ASSERT(pcNZPerCol);

	*pcNZPerCol = 0;

	for (k = 0 ; k < cSlice; ++k )
	{
		for (j = 0 ; j < cLen ; ++j, ++i)
		{
			if (pData[i] != 0)
			{
				pData[cNZ++] = pData[i];
				pNZgap[cGap++] = i - iLastNZ;
				(*pcNZPerCol)++;
				iLastNZ = i;
			}
		}

		++pcNZPerCol;
		*pcNZPerCol = 0;

		pNZgap[cGap++] = i - iLastNZ;
		iLastNZ = i;
	}

	return cNZ;
}

/******************************Private*Routine******************************\
* FF_HiddenLayer_General
*
* Function to do input-to-hidden layer feedforward.
* This is most general (inefficient) implementation and is used only for short inputs.
* The more efficient one is FF_HiddenLayer
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_HiddenLayer_General(
int						cWidth, 
int						*input, 
int						*output, 
int						cOutput, 
int						cWeightHeight, 
int						cWeightWidth, 
ROMMABLE INP_HID_WEIGHT *rgWeight, 
ROMMABLE HID_BIAS		*rgBias, 
int						iScale
)
{
	int leftMargin, rightMargin, col;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;
	for (col=0; col<cWidth; col++)
	{
		int *pInput;
		const short *pBias;
		int iLeft, iRight, cWeightSkip, row;

		iLeft = col-leftMargin;
		if (iLeft < 0)
			iLeft = 0;
		iRight = col+rightMargin;
		if (iRight >= cWidth)
			iRight = cWidth-1;
		cWeightSkip = leftMargin-col+iLeft;

		pInput = input + iLeft*cWeightHeight;
		pBias = rgBias;

		for (row=0; row<cOutput; row++)
		{
			const short *pWeight = rgWeight + row*cWeightHeight*cWeightWidth + cWeightSkip*cWeightHeight;
			int sum = 0;
			int *tmpInput = pInput;
			int c, iVal;

			for (c=(iRight-iLeft+1)*cWeightHeight; c; c--)
			{
				iVal = (*tmpInput++) * (*pWeight++);
				sum += iVal;
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
		}
	}
}

/******************************Private*Routine******************************\
* FF_HiddenLayer
*
* Function to do input-to-hidden layer feedforward.
*
* The lower layer (input)
* is thought of having cWidth columns one column per time slice. A columns has cWeightHeight 
* units. The upper layer (output) also has cWidth columns, with each column having cOutput units.
*
* Each output weight has incoming conections from cWeightWidth columns in the lower layer.
* In other words an output unit recieves connections from potentially cWeightHeight * cWeightWidth
* units. Columns at either left or right edge have less incoming units and are handles as edge effects
* Also, the case of int(cWeightWidth / 2) time slices is handles as a special case.
*
* Speedup tricks. The lower units are oftewn saturated, ie have max or 0 value. We
* take advantage of the case when the units are 0 and simply skip these units. The straight
* forward approach would be to include an if() statement but that would not really 
* be a time saving. So before entering this routine, we go through all the inputs, throwing
* out the zero values and keeping track of the location of non zero entries in a parallel array of offsets.
* So the 'input' array only has nonzero entries values, the parrallel array pInNZ contains the gaps between
* the nonzero entries in the **real** input space. (An entry of 1 means that values in input were
* actually adjacent in the input space.) Finally pcNZPerCol is a count of Non zero entries
* in wach input column. Now as we do the dot products we only are using non Zero input values
* taking care to use the correct weights by using the pInNZ to index to the appropriate weight
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_HiddenLayer(
int						cWidth,				// IN: Number of time slices (columns) in upper and lower layers
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE INP_HID_WEIGHT	*rgWeight,			// IN: Weight vector
ROMMABLE HID_BIAS		*rgBias,			// IN: Bias vector
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol, 		// IN: Number of non zero entries per time slice (column)
int iScale
)
{
	int				row, col;
	int *pInput;
	int				leftMargin, rightMargin;
	unsigned short	*pcNZPerColTmp, *pInNZTmp;
	int				i, iNZtoLeft;
	int	cInNZ;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;

	// special case: there are output columns for which weight matrxi goes beyond both ends of input
	if (cWidth < leftMargin + rightMargin)
	{
		FF_HiddenLayer_General(cWidth, input, output, cOutput, cWeightHeight, cWeightWidth, rgWeight, rgBias, iScale);
		return;
	}

	cInNZ = GetNZSpaces(input, cWidth, cWeightHeight, pInNZ, pcNZPerCol);
	ASSERT(cInNZ >= 0);

	// Take care of edge effects. Do all the upper layer columns
	// where we do not have leftMargin columns to the left in the lower layer

	pcNZPerColTmp = pcNZPerCol;		// Per column counts
	pInNZTmp = pInNZ;				// The NZ gap counts

	// For all columns in upper row which dont have 
	// enough cols in the lower layer to the left
	for (col = leftMargin ; col ; --col)
	{
		const short *pBias = rgBias;
		const short *pWeight = rgWeight + col * cWeightHeight;

		// For each row in the upper layer
		for (row=cOutput; row; row--)
		{
			int *tmpInput = input;
			int sum= 0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			// Iterate over each col in lower layer that connects to
			// one in the upper layer
			for (iw = cWeightWidth - leftMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);

				// Finall each row in the lower layer
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				// Compensate for gap at end of the slice
				pWeight += *(pNZInc++);
			}

			// Transfer function and clip
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
			pWeight += col * cWeightHeight;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;

	}

	// the middle chunk - has enough on either side to use all weights
	pInput = input;
	pcNZPerColTmp = pcNZPerCol;
	pInNZTmp = pInNZ;

	for (col= 0 ; col < cWidth-leftMargin-rightMargin; col++)
	{
		const short		*pBias = rgBias;
		const short		*pWeight = rgWeight;

		for (row = cOutput ; row ; row--)
		{
			int *tmpInput = pInput;
			unsigned short *pcCol = pcNZPerColTmp; 
			int sum=0;
			int c, iVal, iw;
			unsigned short	*pNZInc = pInNZTmp;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column

	}
	ASSERT(pInput - input == cInNZ - pcNZPerColTmp[0] - pcNZPerColTmp[1]);

	// the right part where the weight matrix goes beyond the right end of input
	// note: weight matrix does not go beyond left end

	pcNZPerColTmp = pcNZPerCol + cWidth - rightMargin - 1;
	
	// Count number of NZ entries in the input so we can set the pointer
	// to the first Non zero entry
	iNZtoLeft = 0;
	for (i = 0 ; i < cWidth - rightMargin -1; ++ i)
	{
		iNZtoLeft += pcNZPerCol[i];
	}

	pInput = input + iNZtoLeft;
	pInNZTmp = pInNZ + iNZtoLeft + i;

	// the left part where the weight matrix goes beyond the left end of input
	// note: weight matrix does not go beyond right end
	//for (col=leftMargin; col; col--)
	for (col = 1 ; col <= rightMargin; ++col)
	{
		const short *pBias = rgBias;
		const short *pWeight = rgWeight; 

		for (row=cOutput; row; row--)
		{
			int *tmpInput = pInput;
			int sum= 0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			for (iw = cWeightWidth - rightMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			iVal = Sigmoid16(sum);
			if (iVal > 0xFFFF)
				iVal = 0xFFFF;
			*output++ = (unsigned short) iVal;
			pWeight += col * cWeightHeight ;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;
	}
}

/******************************Private*Routine******************************\
* FF_OutputLayer_General
*
* Function to do hidden-to-output layer feedforward.
* This is most general (inefficient) implementation and is used only for short inputs.
* The more efficient one is FF_OutputLayer.
*
* Note: Unlike the input-to-hidden case, we do not apply the sigmoid function
* at the end here.  We simply compute the weighted sum of the inputs.
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_OutputLayer_General(
int						cWidth, 
int						*input, 
int						*output, 
int						cOutput, 
int						cWeightHeight, 
int						cWeightWidth, 
ROMMABLE HID_OUT_WEIGHT *rgWeight, 
ROMMABLE OUT_BIAS		*rgBias, 
int						iScale
)
{
	int leftMargin, rightMargin, col;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;
	for (col=0; col<cWidth; col++)
	{
		int *pInput;
		const short *pBias;
		int iLeft, iRight, cWeightSkip, row;

		iLeft = col-leftMargin;
		if (iLeft < 0)
			iLeft = 0;
		iRight = col+rightMargin;
		if (iRight >= cWidth)
			iRight = cWidth-1;
		cWeightSkip = leftMargin-col+iLeft;

		pInput = input + iLeft*cWeightHeight;
		pBias = rgBias;

		for (row=0; row<cOutput; row++)
		{
			const char *pWeight = rgWeight + row*cWeightHeight*cWeightWidth + cWeightSkip*cWeightHeight;
			int sum = 0;
			int *tmpInput = pInput;
			int c, iVal;

			for (c=(iRight-iLeft+1)*cWeightHeight; c; c--)
			{
				iVal = (*tmpInput++) * (*pWeight++);
				sum += iVal;
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
		}
	}
}

/******************************Private*Routine******************************\
* FF_OutputLayer
*
* Function to do hidden-to-output layer feedforward.
*
* Note: Unlike the input-to-hidden case, we do not apply the sigmoid function
* at the end here.  We simply compute the weighted sum of the inputs.
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FF_OutputLayer(
int						cWidth,				// IN: Number of time slices (columns) in upper and lower layers
int						*input,				// IN: Input array (only non zero entries)
int						*output,			// OUT: Desired output activations
int						cOutput,			// IN: Number of output units per column
int						cWeightHeight,		// IN: Number of input units per column 
int						cWeightWidth,		// IN: Width of weight sharing (centred about current column)
ROMMABLE HID_OUT_WEIGHT	*rgWeight,			// IN: Weight vector
ROMMABLE OUT_BIAS		*rgBias,			// IN: Bias vector
unsigned short			*pInNZ,				// IN: Array of gaps between non zero entries in the original input space
unsigned short			*pcNZPerCol, 		// IN: Number of non zero entries per time slice (column)
int iScale
)
{
	int				row, col;
	int *pInput;
	int				leftMargin, rightMargin;
	unsigned short	*pcNZPerColTmp, *pInNZTmp;
	int				i, iNZtoLeft;
	int	cInNZ;

	leftMargin = (cWeightWidth-1)/2;
	rightMargin = cWeightWidth - 1 - leftMargin;

	// special case: there are output columns for which weight matrxi goes beyond both ends of input
	if (cWidth < leftMargin + rightMargin)
	{
		FF_OutputLayer_General(cWidth, input, output, cOutput, cWeightHeight, cWeightWidth, rgWeight, rgBias, iScale);
		return;
	}

	cInNZ = GetNZSpaces(input, cWidth, cWeightHeight, pInNZ, pcNZPerCol);

	// Take care of edge effects. Do all the upper layer columns
	// where we do not have leftMargin columns to the left in the lower layer

	pcNZPerColTmp = pcNZPerCol;		// Per column counts
	pInNZTmp = pInNZ;				// The NZ gap counts

	// For all columns in upper row which dont have 
	// enough cols in the lower layer to the left
	for (col = leftMargin ; col ; --col)
	{
		const short *pBias = rgBias;
		const char *pWeight = rgWeight + col * cWeightHeight;

		// For each row in the upper layer
		for (row=cOutput; row; row--)
		{
			int *tmpInput = input;
			int sum=0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			// Iterate over each col in lower layer that connects to
			// one in the upper layer
			for (iw = cWeightWidth - leftMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);

				// Finall each row in the lower layer
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				// Compensate for gap at end of the slice
				pWeight += *(pNZInc++);
			}

			// Transfer function and clip
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
			pWeight += col * cWeightHeight;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;

	}

	// the middle chunk - has enough on either side to use all weights
	pInput = input;
	pcNZPerColTmp = pcNZPerCol;
	pInNZTmp = pInNZ;

	for (col= 0 ; col < cWidth-leftMargin-rightMargin; col++)
	{
		const short		*pBias = rgBias;
		const char		*pWeight = rgWeight;

		for (row = cOutput ; row ; row--)
		{
			int *tmpInput = pInput;
			unsigned short *pcCol = pcNZPerColTmp; 
			int sum=0;
			int c, iVal, iw;
			unsigned short	*pNZInc = pInNZTmp;

			for (iw = cWeightWidth ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
		}
		pInput += *pcNZPerColTmp;
		pInNZTmp += *pcNZPerColTmp++ + 1;		// There is one extra gap per column

	}
	// warning: the following assertion hold only with width of weight matrix is 3
	ASSERT(pInput - input == cInNZ - pcNZPerColTmp[0] - pcNZPerColTmp[1]);

	// the right part where the weight matrix goes beyond the right end of input
	// note: weight matrix does not go beyond left end

	pcNZPerColTmp = pcNZPerCol + cWidth - rightMargin - 1;
	
	// Count number of NZ entries in the input so we can set the pointer
	// to the first Non zero entry
	iNZtoLeft = 0;
	for (i = 0 ; i < cWidth - rightMargin -1; ++ i)
	{
		iNZtoLeft += pcNZPerCol[i];
	}

	pInput = input + iNZtoLeft;
	pInNZTmp = pInNZ + iNZtoLeft + i;

	// the left part where the weight matrix goes beyond the left end of input
	// note: weight matrix does not go beyond right end
	//for (col=leftMargin; col; col--)
	for (col = 1 ; col <= rightMargin; ++col)
	{
		const short *pBias = rgBias;
		const char *pWeight = rgWeight; 

		for (row=cOutput; row; row--)
		{
			int *tmpInput = pInput;
			int sum=0;
			int c, iVal, iw;
			unsigned short *pNZInc =  pInNZTmp;
			unsigned short *pcCol = pcNZPerColTmp; 

			for (iw = cWeightWidth - rightMargin ; iw ; --iw, ++pcCol)
			{
				ASSERT(*pcCol <= cWeightHeight);
				for (c=*pcCol; c ; --c)
				{
					pWeight += *(pNZInc++);
					ASSERT(tmpInput < input + cWeightHeight*cWeightWidth*cWidth);
					ASSERT(pWeight >= rgWeight);
					ASSERT(pWeight < rgWeight + cWeightHeight*cWeightWidth*cOutput);

					iVal = (*tmpInput++) * (*pWeight);
					sum += iVal;
				}
				pWeight += *(pNZInc++);
			}
			sum /= iScale;
			sum += ((int)(*pBias++)) << 8;
			*output++ = sum;
			pWeight += col * cWeightHeight ;
		}
		pInNZTmp += *pcNZPerColTmp + 1;		// There is one extra gap per column
		++pcNZPerColTmp;
	}
}

/******************************Private*Routine******************************\
* logP2P
*
* Function to convert the weight sums at the output nodes to activations.
* A sigmoid functions is used for Node 0.
* Other nodes use a softmax, hence the name logP2P.
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from the last checked-in version.
\**************************************************************************/
void logP2P(
int	cWidth,
int *output,
int cOutput
)
{
	int	row, col;
	int	iSigMax = (1 << 16);
	int	*pOutput;

	for (col= 0 ; col < cWidth; col++)
	{
		int sum, max;

		// first row is sigmoid
		*output = Sigmoid16(*output);
		output++;
		
		//first find max weighted-sum over all rows
		max = *output;
		pOutput = output+1;
		for (row = 2; row<cOutput; row++, pOutput++)
		{
			if (*pOutput > max)
				max = *pOutput;
		}
		// now exponentiate and compute sum of exponentials
		pOutput = output;
		sum = 0;
		for (row = 1; row<cOutput; row++, pOutput++)
		{
			int iV;

			iV = *pOutput - max;
			if (iV < 0)
			{
				iV = Sigmoid16(iV);
				iV = (iV << 16) / (iSigMax - iV);
			}
			else
			{
				iV = 1 << 16;
			}
			*pOutput = iV;
			sum += iV;
		}
		// normalize
		for (row = 1; row<cOutput; row++, output++)
		{
			*output = Div16(*output, sum);
			if (*output > 0xFFFF)
				*output = 0xFFFF;
		}
	}
}

int SumOutput(int *output, const unsigned char *pIndex)
{
	int ix = 0;

	while (*pIndex < 255)
	{
		ix += output[*pIndex];
		pIndex++;
	}

	return ix;
}

BOOL ForwardFeedNet(
unsigned short *outputReturn, 
int cWidth, 
int *input,
int *hidden, 
unsigned short *pInNZ, 
unsigned short *pHidNZ, 
unsigned short *pcInNZperCol, 
unsigned short *pcHidNZperCol,
NFEATURE *nfeature,
BOOL bDoSpace
)
{
	int *output, *p, *space, *q;
	int i;
	NFEATURE *tmp;
	const unsigned char HiPunc[] = {9, 11, 12, 45, 10, 255};
	const unsigned char LoPunc[] = {2, 1, 16, 255};
	const unsigned char MidPunc[] = {15, 38, 39, 49, 50, 33, 34, 35, 36, 255};
	const unsigned char BigPunc[] = {22, 5, 6, 27, 28, 7, 8, 29, 30, 31, 32, 13, 14, 21, 17, 18, 19, 20, 37, 40, 3, 4, 41, 42, 43, 44, 46, 48, 47, 255};
	const unsigned char Number[] =  {51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 255};
	const unsigned char UAlpha[] = {123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 255};
	const unsigned char Ascender[] = {73, 74, 77, 78, 81, 82, 85, 86, 91, 92, 93, 94, 109, 110, 255};
	const unsigned char Descender[] = {81, 82, 83, 84, 89, 90, 101, 102, 103, 104, 119, 120, 121, 122, 255};
	const unsigned char LAlpha[] = {71, 72, 75, 76, 79, 80, 87, 88, 95, 96, 97, 98, 99, 100, 105, 106, 107, 108, 111, 112, 113, 114, 115, 116, 117, 118, 255};

	output = (int *) ExternAlloc(gcOutputNode*cWidth*sizeof(int));
	if (!output)
		return FALSE;

	if (bDoSpace)
	{
		space = (int *) ExternAlloc(gcOutputNode_S*cWidth*sizeof(int));
		if (!space)
		{
			ExternFree(output);
			return FALSE;
		}
	}

	p = input;
	tmp = nfeature;
	for (i=cWidth; i; i--)
	{
		unsigned short *pFeat;
		const unsigned short *pBias;
		int j;

		ASSERT(tmp);
		pFeat = tmp->rgFeat;
		pBias = grgInputBias_S;
		for (j=CNEURALFEATURE; j; j--)
		{
			*p++ = ((int)(*pFeat++) - (int)(*pBias++));
		}
		tmp = tmp->next;
	}
	ASSERT(p - input == CNEURALFEATURE*cWidth);

	FF_HiddenLayer(cWidth, input, hidden, gcHiddenNode, gcHiddenWeightHeight, 
		gcHiddenWeightWidth, grgHiddenWeight, grgHiddenBias, pInNZ, pcInNZperCol, giHiddenScale);

	FF_OutputLayer(cWidth, hidden, output, gcOutputNode, gcOutputWeightHeight, 
		gcOutputWeightWidth, grgOutputWeight, grgOutputBias, pHidNZ, pcHidNZperCol, giOutputScale);

	logP2P(cWidth, output, gcOutputNode);

	// deal with space
	if (bDoSpace)
	{
		p = input;
		q = output;
		tmp = nfeature;
		for (i=cWidth; i; i--)
		{
			unsigned short *pFeat;
			const unsigned short *pBias;
			int j;

			ASSERT(tmp);
			pFeat = tmp->rgFeat;
			pBias = grgInputBias_S;
			for (j=CNEURALFEATURE; j; j--)
			{
				*p++ = ((int)(*pFeat++) - (int)(*pBias++));
			}
			// extra features
			*p++ = ((int)SumOutput(q, HiPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, LoPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, MidPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, BigPunc) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, Number) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, UAlpha) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, Ascender) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, Descender) - (int)(*pBias++));
			*p++ = ((int)SumOutput(q, LAlpha) - (int)(*pBias++));
			tmp = tmp->next;
			q += gcOutputNode;
		}
		ASSERT(p - input == (CNEURALFEATURE+9)*cWidth);

		FF_HiddenLayer(cWidth, input, hidden, gcHiddenNode_S, gcHiddenWeightHeight_S, 
			gcHiddenWeightWidth_S, grgHiddenWeight_S, grgHiddenBias_S, pInNZ, pcInNZperCol, giHiddenScale_S);

		FF_OutputLayer(cWidth, hidden, space, gcOutputNode_S, gcOutputWeightHeight_S, 
			gcOutputWeightWidth_S, grgOutputWeight_S, grgOutputBias_S, pHidNZ, pcHidNZperCol, giOutputScale_S);

		// now overwrite space probs in "output" with "space"
		p = output;
		q = space;
		for (i=cWidth; i; i--)
		{
			*p = Sigmoid16(*q++);
			if (*p > 0xFFFF)
				*p = 0xFFFF;
			p += gcOutputNode;
		}

		ExternFree(space);
	}  // if bDoSpace

	// now convert int's into unsigned short's
	p = output;
	for (i=cWidth*gcOutputNode; i; i--)
		*outputReturn++ = (unsigned short)*p++;
	ExternFree(output);

	return TRUE;
}


/******************************Public*Routine******************************\
* FeedForward
*
* Main public function called from outside to feed inut through the neural
* net(s).
*
* History:
*  24-Jan-2000 -by- Angshuman Guha aguha
* Modified it from an earlier checked-in version.
\**************************************************************************/
void FeedForward(FFINFO *ffinfo)
{
	NFEATURESET *nfeatureset = ffinfo->nfeatureset;
	unsigned short *output = ffinfo->NeuralOutput;
	int	*input = NULL, *hidden = NULL;
	int				cWidth = nfeatureset->cSegment, cWidth1;
	unsigned short	*pHidNZ = NULL, *pInNZ = NULL, *pcInNZperCol = NULL, *pcHidNZperCol = NULL;
	int				inputHeightMax, hiddenHeightMax;

	cWidth1 = cWidth + 1;
	ASSERT(gcHiddenWeightHeight == CNEURALFEATURE);
	ASSERT(gcOutputWeightHeight == gcHiddenNode);

	inputHeightMax = max(gcHiddenWeightHeight, gcHiddenWeightHeight_S);
	hiddenHeightMax = max(gcOutputWeightHeight, gcOutputWeightHeight_S);

	// allocate hidden layer
	input = (int *) ExternAlloc(inputHeightMax*cWidth*sizeof(int));
	hidden = (int *) ExternAlloc(hiddenHeightMax*cWidth*sizeof(int));
	pInNZ = (unsigned short *) ExternAlloc((inputHeightMax+1)*cWidth*sizeof(unsigned short));
	pHidNZ = (unsigned short *) ExternAlloc((hiddenHeightMax+1)*cWidth*sizeof(unsigned short));
	pcInNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));
	pcHidNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));


	if (!input || !hidden || !pInNZ || !pHidNZ || !pcInNZperCol || !pcHidNZperCol )
		goto fail;

	// forward feed through net

	ForwardFeedNet(ffinfo->NeuralOutput, cWidth, input, hidden, pInNZ, pHidNZ, pcInNZperCol, pcHidNZperCol, nfeatureset->head, TRUE);
fail:
	ExternFree(input);
	ExternFree(hidden);
	ExternFree(pInNZ);
	ExternFree(pHidNZ);
	ExternFree(pcInNZperCol);
	ExternFree(pcHidNZperCol);
	
	return;
}
//FeedForwardNoSpace was originally called by baseline.c--not used anymore-Mango--6/20/2001
/*BOOL FeedForwardNoSpace(NFEATURESET *nfeatureset, REAL *NeuralOutput)
{
	int	*input = NULL, *hidden = NULL;
	int				cWidth = nfeatureset->cSegment, cWidth1;
	unsigned short	*pHidNZ = NULL, *pInNZ = NULL, *pcInNZperCol = NULL, *pcHidNZperCol = NULL;
	BOOL retVal;

	cWidth1 = cWidth + 1;
	ASSERT(gcHiddenWeightHeight == CNEURALFEATURE);
	ASSERT(gcOutputWeightHeight == gcHiddenNode);

	input = (int *) ExternAlloc(gcHiddenWeightHeight*cWidth*sizeof(int));
	hidden = (int *) ExternAlloc(gcOutputWeightHeight*cWidth*sizeof(int));
	pInNZ = (unsigned short *) ExternAlloc((gcHiddenWeightHeight+1)*cWidth*sizeof(unsigned short));
	pHidNZ = (unsigned short *) ExternAlloc((gcOutputWeightHeight+1)*cWidth*sizeof(unsigned short));
	pcInNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));
	pcHidNZperCol = (unsigned short *) ExternAlloc(cWidth1*sizeof(unsigned short));


	if (!input || !hidden || !pInNZ || !pHidNZ || !pcInNZperCol || !pcHidNZperCol )
		retVal = FALSE;
	else
		// forward feed through net
		retVal = ForwardFeedNet(NeuralOutput, cWidth, input, hidden, pInNZ, pHidNZ, pcInNZperCol, pcHidNZperCol, nfeatureset->head, FALSE);

	ExternFree(input);
	ExternFree(hidden);
	ExternFree(pInNZ);
	ExternFree(pHidNZ);
	ExternFree(pcInNZperCol);
	ExternFree(pcHidNZperCol);
	
	return retVal;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\suffix.c ===
// suffix.c
// Angshuman Guha
// aguha
// April 17, 2001

#include "common.h"
#include "suffix.h"

const STATE_DESCRIPTION *aStateDescSuffix = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\number.c ===
// number.c
// Angshuman Guha, aguha
// Jan 8, 2001
//
// modified numsimple numdate and numtime, and therefore, number
// deleted compilation of numdate
// added compilation of date (called NUMDATE :-( )
// Dec 11, 2001
//
// Added more data formats
// Jan 15, 2002

#include "common.h"
#include "number.h"

/* date formats

NUMDATE (part of default) (not exported)
	3/14/2001
	3-14-2001
	3/14
	3/14/01
	3-14-01
	03/14/01
	03-14-01
	2001
	2001-2002
	'65

unsupported (we don't believe people actually write these)
	14-Mar
	14-Mar-01
	Mar-01
	14-Mar-2001

DATE (NUMDATE + some) (not part of deafult) (exported)
	3/14/2001
	3-14-2001
	3/14
	3/14/01
	3-14-01
	03/14/01
	03-14-01
	2001
	2001-2002
	'65
	March 14, 2001
	Wednesday, March 14, 2001
	March 14
*/
// text generated by re2fsa at Mon Feb 04 09:55:08 2002

// the input-file of rules:
// numsimple = [sign] integer;
// numsimple = [sign] [digit_seq] "." digit_seq;
// 
// numnth = integer [rank];
// 
// numunit = numsimple unit;
// 
// numnum = "#" integer;
// 
// numpercent = numsimple "%";
// 
// numdate = "'" digit digit;
// numdate = nummonth "/" dayofmonth ["/" year];
// numdate = nummonth "-" dayofmonth "-" year;
// numdate = digit digit digit digit ["-" digit digit digit digit];
// nummonth = ["0"] "123456789" | "1" "012";
// dayofmonth = ["0"] "123456789" | "12" digit | "3" "01";
// year = digit digit [digit digit];
// 
// longdate = [dayofweek "," space] monthname space dayofmonth [","  space digit digit digit digit];
// date = numdate | longdate;
// 
// dayofweek = "S" "u" "n" [ "d" "a" "y" ];
// dayofweek = "M" "o" "n" [ "d" "a" "y" ];
// dayofweek = "T" "u" "e" [ "s" "d" "a" "y" ];
// dayofweek = "W" "e" "d" [ "n" "e" "s" "d" "a" "y" ];
// dayofweek = "T" "h" "u" [ "r" "s" "d" "a" "y" ];
// dayofweek = "F" "r" "i" [ "d" "a" "y" ];
// dayofweek = "S" "a" "t" [ "u" "r" "d" "a" "y" ];
// monthname = "J" "a" "n" [ "u" "a" "r" "y" ];
// monthname = "J" "A" "N";
// monthname = "F" "e" "b" [ "r" "u" "a" "r" "y" ];
// monthname = "F" "E" "B";
// monthname = "M" "a" "r" [ "c" "h" ];
// monthname = "M" "A" "R";
// monthname = "A" "p" "r" [ "i" "l" ];
// monthname = "A" "P" "R";
// monthname = "M" "a" "y";
// monthname = "M" "A" "Y";
// monthname = "J" "u" "n" [ "e" ];
// monthname = "J" "U" "N";
// monthname = "J" "u" "l" [ "y" ];
// monthname = "J" "U" "L";
// monthname = "A" "u" "g" [ "u" "s" "t" ];
// monthname = "A" "U" "G";
// monthname = "S" "e" "p" [ "t" "e" "m" "b" "e" "r" ];
// monthname = "S" "E" "P";
// monthname = "O" "c" "t" [ "o" "b" "e" "r" ];
// monthname = "O" "C" "T";
// monthname = "N" "o" "v" [ "e" "m" "b" "e" "r" ];
// monthname = "N" "O" "V";
// monthname = "D" "e" "c" [ "e" "m" "b" "e" "r" ];
// monthname = "D" "E" "C";
// 
// numtime = hour ":" minutes [":" seconds] space ampm;
// numtime = militaryhour ":" minutes [":" seconds];
// numtime = minutes ":" seconds;
// hour = ["0"] "123456789" | "1" "012";
// militaryhour = ["0"] digit | "1" digit | "2" "0123";
// minutes = "012345" digit;
// seconds = "012345" digit;
// ampm = "a" "m" | "p" "m" | "A" "M" | "P" "M";
// 
// numcurrency = "$" integer ["." [digit digit]] ["k"];
// numcurrency = "$" "." digit digit ["k"];
// numcurrency = [digit] digit "";
// 
// numphone = [areacode] digit digit digit "-" digit digit digit digit;
// areacode = ["01" "-"] digit digit digit "-";
// areacode = "(" digit digit digit ")";
// 
// nummath = expr [equals expr];
// expr = term [plus term];
// term = numsimple;
// term = "(" numsimple plus numsimple ")";
// equals = "<>=";
// plus = "+-/*";
// 
// integer = digit_seq | comma_sep_integer;
// digit_seq = digit+;
// comma_sep_integer = digit [digit [digit]] ["," digit digit digit]*;
// digit = "0123456789";
// rank = "s" "t" | "n" "d" | "r" "d" | "t" "h";
// rank = "S" "T" | "N" "D" | "R" "D" | "T" "H";
// sign = "+-";
// unit = "bBkKmM\"'";
// unit = "k" "b" | "K" "b" | "K" "B" | "m" "b" | "M" "b" | "M" "B";
// unit = "s" "q" | "S" "q" | "k" "m" | "K" "m" | "i" "n" "." | "f" "t" ".";
// unit = "m" "m" ["."];
// unit = "c" "m" ["."];
// unit = "e" "r" "s";
// unit = "k" "v" | "K" "V";
// unit = "";
// 
// space = " ";
// 
// number = numsimple;
// number = numnth;
// number = numunit;
// number = numnum;
// number = numpercent;
// number = numdate;
// number = numtime;
// number = numcurrency;
// number = numphone;
// number = nummath;
// 
// = number

// 251 states

static const unsigned char gaSNUMBER[] = 
	/* gaStringNUMBER+0 */	"#\000"
	/* gaStringNUMBER+2 */	"$\000"
	/* gaStringNUMBER+7 */	"'\000"
	/* gaStringNUMBER+9 */	"(\000"
	/* gaStringNUMBER+11 */	"+-\000"
	/* gaStringNUMBER+14 */	".\000"
	/* gaStringNUMBER+16 */	"0\000"
	/* gaStringNUMBER+18 */	"1\000"
	/* gaStringNUMBER+20 */	"2\000"
	/* gaStringNUMBER+22 */	"345\000"
	/* gaStringNUMBER+26 */	"6789\000"
	/* gaStringNUMBER+31 */	"0123456789\000"
	/* gaStringNUMBER+42 */	"\"%'Bb\000"
	/* gaStringNUMBER+50 */	"*+/\000"
	/* gaStringNUMBER+54 */	",\000"
	/* gaStringNUMBER+56 */	"-\000"
	/* gaStringNUMBER+58 */	"123456789\000"
	/* gaStringNUMBER+68 */	":\000"
	/* gaStringNUMBER+70 */	"<=>\000"
	/* gaStringNUMBER+74 */	"K\000"
	/* gaStringNUMBER+76 */	"M\000"
	/* gaStringNUMBER+78 */	"NR\000"
	/* gaStringNUMBER+81 */	"S\000"
	/* gaStringNUMBER+83 */	"T\000"
	/* gaStringNUMBER+85 */	"c\000"
	/* gaStringNUMBER+87 */	"e\000"
	/* gaStringNUMBER+89 */	"f\000"
	/* gaStringNUMBER+91 */	"i\000"
	/* gaStringNUMBER+93 */	"k\000"
	/* gaStringNUMBER+95 */	"m\000"
	/* gaStringNUMBER+97 */	"nr\000"
	/* gaStringNUMBER+100 */	"s\000"
	/* gaStringNUMBER+102 */	"t\000"
	/* gaStringNUMBER+104 */	"*+\000"
	/* gaStringNUMBER+107 */	"3456789\000"
	/* gaStringNUMBER+115 */	"012\000"
	/* gaStringNUMBER+119 */	"/\000"
	/* gaStringNUMBER+121 */	"0123\000"
	/* gaStringNUMBER+126 */	"456789\000"
	/* gaStringNUMBER+133 */	"*+-/\000"
	/* gaStringNUMBER+138 */	"\"%'Bb\000"
	/* gaStringNUMBER+145 */	"Ss\000"
	/* gaStringNUMBER+148 */	"012345\000"
	/* gaStringNUMBER+155 */	"BVbm\000"
	/* gaStringNUMBER+160 */	"Bb\000"
	/* gaStringNUMBER+163 */	"D\000"
	/* gaStringNUMBER+165 */	"Tq\000"
	/* gaStringNUMBER+168 */	"H\000"
	/* gaStringNUMBER+170 */	"r\000"
	/* gaStringNUMBER+172 */	"n\000"
	/* gaStringNUMBER+174 */	"bmv\000"
	/* gaStringNUMBER+178 */	"b\000"
	/* gaStringNUMBER+180 */	"d\000"
	/* gaStringNUMBER+182 */	"qt\000"
	/* gaStringNUMBER+185 */	"h\000"
	/* gaStringNUMBER+187 */	"12\000"
	/* gaStringNUMBER+190 */	"3\000"
	/* gaStringNUMBER+192 */	"q\000"
	/* gaStringNUMBER+194 */	"23456789\000"
	/* gaStringNUMBER+203 */	"01\000"
	/* gaStringNUMBER+206 */	")\000"
	/* gaStringNUMBER+208 */	" \000"
	/* gaStringNUMBER+210 */	"AP\000"
	/* gaStringNUMBER+213 */	"ap\000"
;

static const STATE_TRANSITION gaTNUMBER[] = {
	{gaSNUMBER+0,	1}, // +0: state 0 transitions
	{gaSNUMBER+2,	2},
	{gaSNUMBER+7,	3},
	{gaSNUMBER+9,	4},
	{gaSNUMBER+11,	5},
	{gaSNUMBER+14,	6},
	{gaSNUMBER+16,	7},
	{gaSNUMBER+18,	8},
	{gaSNUMBER+20,	9},
	{gaSNUMBER+22,	10},
	{gaSNUMBER+26,	11},
	{gaSNUMBER+31,	12}, // +11: state 1 transitions
	{gaSNUMBER+14,	13}, // +12: state 2 transitions
	{gaSNUMBER+31,	14},
	{gaSNUMBER+31,	15}, // +14: state 3 transitions
	{gaSNUMBER+11,	16}, // +15: state 4 transitions
	{gaSNUMBER+14,	17},
	{gaSNUMBER+31,	18},
	{gaSNUMBER+14,	6}, // +18: state 5 transitions
	{gaSNUMBER+31,	19},
	{gaSNUMBER+31,	20}, // +20: state 6 transitions
	{gaSNUMBER+14,	6}, // +21: state 7 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+50,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+56,	24},
	{gaSNUMBER+16,	25},
	{gaSNUMBER+58,	26},
	{gaSNUMBER+68,	27},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+14,	6}, // +44: state 8 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+104,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+107,	25},
	{gaSNUMBER+115,	26},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+56,	43},
	{gaSNUMBER+119,	44},
	{gaSNUMBER+68,	45},
	{gaSNUMBER+14,	6}, // +68: state 9 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+104,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+121,	25},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+119,	44},
	{gaSNUMBER+68,	45},
	{gaSNUMBER+56,	46},
	{gaSNUMBER+126,	47},
	{gaSNUMBER+14,	6}, // +92: state 10 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+104,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+119,	44},
	{gaSNUMBER+68,	45},
	{gaSNUMBER+56,	46},
	{gaSNUMBER+31,	47},
	{gaSNUMBER+14,	6}, // +115: state 11 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+104,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+119,	44},
	{gaSNUMBER+68,	45},
	{gaSNUMBER+56,	46},
	{gaSNUMBER+31,	48},
	{gaSNUMBER+54,	49}, // +138: state 12 transitions
	{gaSNUMBER+31,	50},
	{gaSNUMBER+31,	51}, // +140: state 13 transitions
	{gaSNUMBER+93,	21}, // +141: state 14 transitions
	{gaSNUMBER+54,	52},
	{gaSNUMBER+14,	53},
	{gaSNUMBER+31,	54},
	{gaSNUMBER+31,	21}, // +145: state 15 transitions
	{gaSNUMBER+14,	17}, // +146: state 16 transitions
	{gaSNUMBER+31,	55},
	{gaSNUMBER+31,	56}, // +148: state 17 transitions
	{gaSNUMBER+14,	17}, // +149: state 18 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+54,	58},
	{gaSNUMBER+31,	59},
	{gaSNUMBER+14,	6}, // +153: state 19 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+54,	60},
	{gaSNUMBER+31,	61},
	{gaSNUMBER+145,	62},
	{gaSNUMBER+31,	20}, // +168: state 20 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+145,	62},
	{gaSNUMBER+9,	63}, // +181: state 22 transitions
	{gaSNUMBER+11,	64},
	{gaSNUMBER+14,	65},
	{gaSNUMBER+31,	66},
	{gaSNUMBER+31,	67}, // +185: state 23 transitions
	{gaSNUMBER+9,	63}, // +186: state 24 transitions
	{gaSNUMBER+11,	64},
	{gaSNUMBER+14,	65},
	{gaSNUMBER+31,	68},
	{gaSNUMBER+14,	6}, // +190: state 25 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+68,	27},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+31,	69},
	{gaSNUMBER+14,	6}, // +211: state 26 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+104,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+119,	44},
	{gaSNUMBER+68,	45},
	{gaSNUMBER+56,	46},
	{gaSNUMBER+31,	69},
	{gaSNUMBER+148,	70}, // +234: state 27 transitions
	{gaSNUMBER+9,	71}, // +235: state 28 transitions
	{gaSNUMBER+11,	72},
	{gaSNUMBER+14,	73},
	{gaSNUMBER+31,	74},
	{gaSNUMBER+155,	21}, // +239: state 29 transitions
	{gaSNUMBER+160,	21}, // +240: state 30 transitions
	{gaSNUMBER+163,	21}, // +241: state 31 transitions
	{gaSNUMBER+165,	21}, // +242: state 32 transitions
	{gaSNUMBER+168,	21}, // +243: state 33 transitions
	{gaSNUMBER+95,	75}, // +244: state 34 transitions
	{gaSNUMBER+170,	76}, // +245: state 35 transitions
	{gaSNUMBER+102,	77}, // +246: state 36 transitions
	{gaSNUMBER+172,	77}, // +247: state 37 transitions
	{gaSNUMBER+174,	21}, // +248: state 38 transitions
	{gaSNUMBER+178,	21}, // +249: state 39 transitions
	{gaSNUMBER+95,	75},
	{gaSNUMBER+180,	21}, // +251: state 40 transitions
	{gaSNUMBER+182,	21}, // +252: state 41 transitions
	{gaSNUMBER+185,	21}, // +253: state 42 transitions
	{gaSNUMBER+9,	63}, // +254: state 43 transitions
	{gaSNUMBER+11,	64},
	{gaSNUMBER+14,	65},
	{gaSNUMBER+16,	78},
	{gaSNUMBER+187,	79},
	{gaSNUMBER+190,	80},
	{gaSNUMBER+126,	81},
	{gaSNUMBER+9,	63}, // +261: state 44 transitions
	{gaSNUMBER+11,	64},
	{gaSNUMBER+14,	65},
	{gaSNUMBER+16,	82},
	{gaSNUMBER+187,	83},
	{gaSNUMBER+190,	84},
	{gaSNUMBER+126,	85},
	{gaSNUMBER+148,	86}, // +268: state 45 transitions
	{gaSNUMBER+9,	63}, // +269: state 46 transitions
	{gaSNUMBER+11,	64},
	{gaSNUMBER+14,	65},
	{gaSNUMBER+16,	87},
	{gaSNUMBER+187,	88},
	{gaSNUMBER+190,	89},
	{gaSNUMBER+126,	90},
	{gaSNUMBER+14,	6}, // +276: state 47 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+31,	69},
	{gaSNUMBER+68,	91},
	{gaSNUMBER+14,	6}, // +297: state 48 transitions
	{gaSNUMBER+42,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+31,	69},
	{gaSNUMBER+31,	92}, // +317: state 49 transitions
	{gaSNUMBER+54,	49}, // +318: state 50 transitions
	{gaSNUMBER+31,	93},
	{gaSNUMBER+31,	94}, // +320: state 51 transitions
	{gaSNUMBER+31,	95}, // +321: state 52 transitions
	{gaSNUMBER+93,	21}, // +322: state 53 transitions
	{gaSNUMBER+31,	51},
	{gaSNUMBER+93,	21}, // +324: state 54 transitions
	{gaSNUMBER+54,	52},
	{gaSNUMBER+14,	53},
	{gaSNUMBER+31,	96},
	{gaSNUMBER+14,	17}, // +328: state 55 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+54,	58},
	{gaSNUMBER+31,	97},
	{gaSNUMBER+31,	56}, // +332: state 56 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+11,	98}, // +334: state 57 transitions
	{gaSNUMBER+14,	99},
	{gaSNUMBER+31,	100},
	{gaSNUMBER+31,	101}, // +337: state 58 transitions
	{gaSNUMBER+14,	17}, // +338: state 59 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+54,	58},
	{gaSNUMBER+31,	102},
	{gaSNUMBER+31,	103}, // +342: state 60 transitions
	{gaSNUMBER+14,	6}, // +343: state 61 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+54,	60},
	{gaSNUMBER+145,	62},
	{gaSNUMBER+31,	104},
	{gaSNUMBER+192,	21}, // +358: state 62 transitions
	{gaSNUMBER+11,	105}, // +359: state 63 transitions
	{gaSNUMBER+14,	106},
	{gaSNUMBER+31,	107},
	{gaSNUMBER+14,	65}, // +362: state 64 transitions
	{gaSNUMBER+31,	66},
	{gaSNUMBER+31,	108}, // +364: state 65 transitions
	{gaSNUMBER+70,	28}, // +365: state 66 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	110},
	{gaSNUMBER+31,	111}, // +369: state 67 transitions
	{gaSNUMBER+70,	28}, // +370: state 68 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	112},
	{gaSNUMBER+14,	6}, // +374: state 69 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+50,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+56,	113},
	{gaSNUMBER+31,	114},
	{gaSNUMBER+31,	115}, // +395: state 70 transitions
	{gaSNUMBER+11,	116}, // +396: state 71 transitions
	{gaSNUMBER+14,	117},
	{gaSNUMBER+31,	118},
	{gaSNUMBER+14,	73}, // +399: state 72 transitions
	{gaSNUMBER+31,	74},
	{gaSNUMBER+31,	119}, // +401: state 73 transitions
	{gaSNUMBER+14,	73}, // +402: state 74 transitions
	{gaSNUMBER+133,	120},
	{gaSNUMBER+54,	121},
	{gaSNUMBER+31,	122},
	{gaSNUMBER+14,	21}, // +406: state 75 transitions
	{gaSNUMBER+100,	21}, // +407: state 76 transitions
	{gaSNUMBER+14,	21}, // +408: state 77 transitions
	{gaSNUMBER+70,	28}, // +409: state 78 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+16,	112},
	{gaSNUMBER+58,	123},
	{gaSNUMBER+70,	28}, // +414: state 79 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	123},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+70,	28}, // +419: state 80 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+194,	112},
	{gaSNUMBER+203,	123},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+70,	28}, // +425: state 81 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	112},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+70,	28}, // +430: state 82 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+16,	110},
	{gaSNUMBER+58,	125},
	{gaSNUMBER+70,	28}, // +435: state 83 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+119,	124},
	{gaSNUMBER+31,	125},
	{gaSNUMBER+70,	28}, // +440: state 84 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+194,	110},
	{gaSNUMBER+119,	124},
	{gaSNUMBER+203,	125},
	{gaSNUMBER+70,	28}, // +446: state 85 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	110},
	{gaSNUMBER+119,	124},
	{gaSNUMBER+31,	126}, // +451: state 86 transitions
	{gaSNUMBER+70,	28}, // +452: state 87 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+16,	110},
	{gaSNUMBER+58,	127},
	{gaSNUMBER+70,	28}, // +457: state 88 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+31,	127},
	{gaSNUMBER+70,	28}, // +462: state 89 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+194,	110},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+203,	127},
	{gaSNUMBER+70,	28}, // +468: state 90 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	110},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+148,	15}, // +473: state 91 transitions
	{gaSNUMBER+31,	128}, // +474: state 92 transitions
	{gaSNUMBER+54,	49}, // +475: state 93 transitions
	{gaSNUMBER+31,	129},
	{gaSNUMBER+93,	21}, // +477: state 94 transitions
	{gaSNUMBER+31,	130}, // +478: state 95 transitions
	{gaSNUMBER+93,	21}, // +479: state 96 transitions
	{gaSNUMBER+54,	52},
	{gaSNUMBER+14,	53},
	{gaSNUMBER+31,	131},
	{gaSNUMBER+14,	17}, // +483: state 97 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+54,	58},
	{gaSNUMBER+31,	132},
	{gaSNUMBER+14,	99}, // +487: state 98 transitions
	{gaSNUMBER+31,	100},
	{gaSNUMBER+31,	133}, // +489: state 99 transitions
	{gaSNUMBER+14,	99}, // +490: state 100 transitions
	{gaSNUMBER+206,	134},
	{gaSNUMBER+54,	135},
	{gaSNUMBER+31,	136},
	{gaSNUMBER+31,	137}, // +494: state 101 transitions
	{gaSNUMBER+14,	17}, // +495: state 102 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+54,	58},
	{gaSNUMBER+206,	138},
	{gaSNUMBER+31,	139},
	{gaSNUMBER+31,	140}, // +500: state 103 transitions
	{gaSNUMBER+14,	6}, // +501: state 104 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+54,	60},
	{gaSNUMBER+145,	62},
	{gaSNUMBER+31,	141},
	{gaSNUMBER+14,	106}, // +516: state 105 transitions
	{gaSNUMBER+31,	107},
	{gaSNUMBER+31,	142}, // +518: state 106 transitions
	{gaSNUMBER+14,	106}, // +519: state 107 transitions
	{gaSNUMBER+133,	143},
	{gaSNUMBER+54,	144},
	{gaSNUMBER+31,	145},
	{gaSNUMBER+70,	28}, // +523: state 108 transitions
	{gaSNUMBER+31,	108},
	{gaSNUMBER+31,	146}, // +525: state 109 transitions
	{gaSNUMBER+70,	28}, // +526: state 110 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	147},
	{gaSNUMBER+31,	148}, // +530: state 111 transitions
	{gaSNUMBER+70,	28}, // +531: state 112 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	149},
	{gaSNUMBER+9,	63}, // +535: state 113 transitions
	{gaSNUMBER+11,	64},
	{gaSNUMBER+14,	65},
	{gaSNUMBER+31,	150},
	{gaSNUMBER+14,	6}, // +539: state 114 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+31,	114},
	{gaSNUMBER+68,	91}, // +558: state 115 transitions
	{gaSNUMBER+14,	117}, // +559: state 116 transitions
	{gaSNUMBER+31,	118},
	{gaSNUMBER+31,	151}, // +561: state 117 transitions
	{gaSNUMBER+14,	117}, // +562: state 118 transitions
	{gaSNUMBER+133,	152},
	{gaSNUMBER+54,	153},
	{gaSNUMBER+31,	154},
	{gaSNUMBER+31,	119}, // +566: state 119 transitions
	{gaSNUMBER+133,	120},
	{gaSNUMBER+9,	155}, // +568: state 120 transitions
	{gaSNUMBER+11,	156},
	{gaSNUMBER+14,	157},
	{gaSNUMBER+31,	158},
	{gaSNUMBER+31,	159}, // +572: state 121 transitions
	{gaSNUMBER+14,	73}, // +573: state 122 transitions
	{gaSNUMBER+133,	120},
	{gaSNUMBER+54,	121},
	{gaSNUMBER+31,	160},
	{gaSNUMBER+70,	28}, // +577: state 123 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+31,	149},
	{gaSNUMBER+31,	161}, // +582: state 124 transitions
	{gaSNUMBER+70,	28}, // +583: state 125 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+119,	124},
	{gaSNUMBER+31,	147},
	{gaSNUMBER+208,	162}, // +588: state 126 transitions
	{gaSNUMBER+68,	163},
	{gaSNUMBER+70,	28}, // +590: state 127 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+56,	124},
	{gaSNUMBER+31,	147},
	{gaSNUMBER+31,	164}, // +595: state 128 transitions
	{gaSNUMBER+31,	129}, // +596: state 129 transitions
	{gaSNUMBER+31,	165}, // +597: state 130 transitions
	{gaSNUMBER+93,	21}, // +598: state 131 transitions
	{gaSNUMBER+14,	53},
	{gaSNUMBER+31,	131},
	{gaSNUMBER+14,	17}, // +601: state 132 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+54,	58},
	{gaSNUMBER+31,	139},
	{gaSNUMBER+31,	133}, // +605: state 133 transitions
	{gaSNUMBER+206,	134},
	{gaSNUMBER+133,	22}, // +607: state 134 transitions
	{gaSNUMBER+70,	28},
	{gaSNUMBER+31,	166}, // +609: state 135 transitions
	{gaSNUMBER+14,	99}, // +610: state 136 transitions
	{gaSNUMBER+206,	134},
	{gaSNUMBER+54,	135},
	{gaSNUMBER+31,	167},
	{gaSNUMBER+31,	168}, // +614: state 137 transitions
	{gaSNUMBER+31,	169}, // +615: state 138 transitions
	{gaSNUMBER+14,	17}, // +616: state 139 transitions
	{gaSNUMBER+133,	57},
	{gaSNUMBER+31,	139},
	{gaSNUMBER+31,	170}, // +619: state 140 transitions
	{gaSNUMBER+14,	6}, // +620: state 141 transitions
	{gaSNUMBER+138,	21},
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+145,	62},
	{gaSNUMBER+31,	141},
	{gaSNUMBER+31,	142}, // +634: state 142 transitions
	{gaSNUMBER+133,	143},
	{gaSNUMBER+11,	171}, // +636: state 143 transitions
	{gaSNUMBER+14,	172},
	{gaSNUMBER+31,	173},
	{gaSNUMBER+31,	174}, // +639: state 144 transitions
	{gaSNUMBER+14,	106}, // +640: state 145 transitions
	{gaSNUMBER+133,	143},
	{gaSNUMBER+54,	144},
	{gaSNUMBER+31,	175},
	{gaSNUMBER+31,	176}, // +644: state 146 transitions
	{gaSNUMBER+70,	28}, // +645: state 147 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	177},
	{gaSNUMBER+138,	21}, // +649: state 148 transitions
	{gaSNUMBER+133,	22},
	{gaSNUMBER+54,	23},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+78,	31},
	{gaSNUMBER+81,	32},
	{gaSNUMBER+83,	33},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+97,	40},
	{gaSNUMBER+100,	41},
	{gaSNUMBER+102,	42},
	{gaSNUMBER+70,	28}, // +667: state 149 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+56,	138},
	{gaSNUMBER+31,	177},
	{gaSNUMBER+70,	28}, // +672: state 150 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	178},
	{gaSNUMBER+31,	151}, // +676: state 151 transitions
	{gaSNUMBER+133,	152},
	{gaSNUMBER+11,	179}, // +678: state 152 transitions
	{gaSNUMBER+14,	180},
	{gaSNUMBER+31,	181},
	{gaSNUMBER+31,	182}, // +681: state 153 transitions
	{gaSNUMBER+14,	117}, // +682: state 154 transitions
	{gaSNUMBER+133,	152},
	{gaSNUMBER+54,	153},
	{gaSNUMBER+31,	183},
	{gaSNUMBER+11,	184}, // +686: state 155 transitions
	{gaSNUMBER+14,	185},
	{gaSNUMBER+31,	186},
	{gaSNUMBER+14,	157}, // +689: state 156 transitions
	{gaSNUMBER+31,	158},
	{gaSNUMBER+31,	129}, // +691: state 157 transitions
	{gaSNUMBER+54,	49}, // +692: state 158 transitions
	{gaSNUMBER+14,	157},
	{gaSNUMBER+31,	187},
	{gaSNUMBER+31,	188}, // +695: state 159 transitions
	{gaSNUMBER+14,	73}, // +696: state 160 transitions
	{gaSNUMBER+133,	120},
	{gaSNUMBER+54,	121},
	{gaSNUMBER+31,	189},
	{gaSNUMBER+31,	190}, // +700: state 161 transitions
	{gaSNUMBER+210,	191}, // +701: state 162 transitions
	{gaSNUMBER+213,	192},
	{gaSNUMBER+148,	193}, // +703: state 163 transitions
	{gaSNUMBER+54,	49}, // +704: state 164 transitions
	{gaSNUMBER+93,	21}, // +705: state 165 transitions
	{gaSNUMBER+54,	52},
	{gaSNUMBER+14,	53},
	{gaSNUMBER+31,	194}, // +708: state 166 transitions
	{gaSNUMBER+14,	99}, // +709: state 167 transitions
	{gaSNUMBER+206,	134},
	{gaSNUMBER+54,	135},
	{gaSNUMBER+31,	195},
	{gaSNUMBER+133,	57}, // +713: state 168 transitions
	{gaSNUMBER+54,	58},
	{gaSNUMBER+31,	196}, // +715: state 169 transitions
	{gaSNUMBER+138,	21}, // +716: state 170 transitions
	{gaSNUMBER+133,	22},
	{gaSNUMBER+70,	28},
	{gaSNUMBER+74,	29},
	{gaSNUMBER+76,	30},
	{gaSNUMBER+85,	34},
	{gaSNUMBER+87,	35},
	{gaSNUMBER+89,	36},
	{gaSNUMBER+91,	37},
	{gaSNUMBER+93,	38},
	{gaSNUMBER+95,	39},
	{gaSNUMBER+54,	60},
	{gaSNUMBER+145,	62},
	{gaSNUMBER+14,	172}, // +729: state 171 transitions
	{gaSNUMBER+31,	173},
	{gaSNUMBER+31,	197}, // +731: state 172 transitions
	{gaSNUMBER+14,	172}, // +732: state 173 transitions
	{gaSNUMBER+206,	198},
	{gaSNUMBER+54,	199},
	{gaSNUMBER+31,	200},
	{gaSNUMBER+31,	201}, // +736: state 174 transitions
	{gaSNUMBER+14,	106}, // +737: state 175 transitions
	{gaSNUMBER+133,	143},
	{gaSNUMBER+54,	144},
	{gaSNUMBER+31,	202},
	{gaSNUMBER+31,	203}, // +741: state 176 transitions
	{gaSNUMBER+70,	28}, // +742: state 177 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+31,	177},
	{gaSNUMBER+70,	28}, // +745: state 178 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	204},
	{gaSNUMBER+14,	180}, // +749: state 179 transitions
	{gaSNUMBER+31,	181},
	{gaSNUMBER+31,	205}, // +751: state 180 transitions
	{gaSNUMBER+14,	180}, // +752: state 181 transitions
	{gaSNUMBER+206,	206},
	{gaSNUMBER+54,	207},
	{gaSNUMBER+31,	208},
	{gaSNUMBER+31,	209}, // +756: state 182 transitions
	{gaSNUMBER+14,	117}, // +757: state 183 transitions
	{gaSNUMBER+133,	152},
	{gaSNUMBER+54,	153},
	{gaSNUMBER+31,	210},
	{gaSNUMBER+14,	185}, // +761: state 184 transitions
	{gaSNUMBER+31,	186},
	{gaSNUMBER+31,	211}, // +763: state 185 transitions
	{gaSNUMBER+14,	185}, // +764: state 186 transitions
	{gaSNUMBER+133,	212},
	{gaSNUMBER+54,	213},
	{gaSNUMBER+31,	214},
	{gaSNUMBER+54,	49}, // +768: state 187 transitions
	{gaSNUMBER+14,	157},
	{gaSNUMBER+31,	215},
	{gaSNUMBER+31,	216}, // +771: state 188 transitions
	{gaSNUMBER+14,	73}, // +772: state 189 transitions
	{gaSNUMBER+133,	120},
	{gaSNUMBER+31,	189},
	{gaSNUMBER+31,	15}, // +775: state 190 transitions
	{gaSNUMBER+76,	21}, // +776: state 191 transitions
	{gaSNUMBER+95,	21}, // +777: state 192 transitions
	{gaSNUMBER+31,	217}, // +778: state 193 transitions
	{gaSNUMBER+31,	218}, // +779: state 194 transitions
	{gaSNUMBER+14,	99}, // +780: state 195 transitions
	{gaSNUMBER+206,	134},
	{gaSNUMBER+31,	195},
	{gaSNUMBER+31,	219}, // +783: state 196 transitions
	{gaSNUMBER+31,	197}, // +784: state 197 transitions
	{gaSNUMBER+206,	198},
	{gaSNUMBER+70,	28}, // +786: state 198 transitions
	{gaSNUMBER+31,	220}, // +787: state 199 transitions
	{gaSNUMBER+14,	172}, // +788: state 200 transitions
	{gaSNUMBER+206,	198},
	{gaSNUMBER+54,	199},
	{gaSNUMBER+31,	221},
	{gaSNUMBER+31,	222}, // +792: state 201 transitions
	{gaSNUMBER+14,	106}, // +793: state 202 transitions
	{gaSNUMBER+133,	143},
	{gaSNUMBER+31,	202},
	{gaSNUMBER+70,	28}, // +796: state 203 transitions
	{gaSNUMBER+54,	109},
	{gaSNUMBER+70,	28}, // +798: state 204 transitions
	{gaSNUMBER+14,	65},
	{gaSNUMBER+54,	109},
	{gaSNUMBER+31,	177},
	{gaSNUMBER+56,	223},
	{gaSNUMBER+31,	205}, // +803: state 205 transitions
	{gaSNUMBER+206,	206},
	{gaSNUMBER+133,	120}, // +805: state 206 transitions
	{gaSNUMBER+31,	224}, // +806: state 207 transitions
	{gaSNUMBER+14,	180}, // +807: state 208 transitions
	{gaSNUMBER+206,	206},
	{gaSNUMBER+54,	207},
	{gaSNUMBER+31,	225},
	{gaSNUMBER+31,	226}, // +811: state 209 transitions
	{gaSNUMBER+14,	117}, // +812: state 210 transitions
	{gaSNUMBER+133,	152},
	{gaSNUMBER+31,	210},
	{gaSNUMBER+31,	211}, // +815: state 211 transitions
	{gaSNUMBER+133,	212},
	{gaSNUMBER+11,	227}, // +817: state 212 transitions
	{gaSNUMBER+14,	228},
	{gaSNUMBER+31,	229},
	{gaSNUMBER+31,	230}, // +820: state 213 transitions
	{gaSNUMBER+14,	185}, // +821: state 214 transitions
	{gaSNUMBER+133,	212},
	{gaSNUMBER+54,	213},
	{gaSNUMBER+31,	231},
	{gaSNUMBER+54,	49}, // +825: state 215 transitions
	{gaSNUMBER+14,	157},
	{gaSNUMBER+31,	232},
	{gaSNUMBER+133,	120}, // +828: state 216 transitions
	{gaSNUMBER+54,	121},
	{gaSNUMBER+208,	162}, // +830: state 217 transitions
	{gaSNUMBER+206,	134}, // +831: state 218 transitions
	{gaSNUMBER+54,	135},
	{gaSNUMBER+56,	223}, // +833: state 219 transitions
	{gaSNUMBER+31,	233}, // +834: state 220 transitions
	{gaSNUMBER+14,	172}, // +835: state 221 transitions
	{gaSNUMBER+206,	198},
	{gaSNUMBER+54,	199},
	{gaSNUMBER+31,	234},
	{gaSNUMBER+133,	143}, // +839: state 222 transitions
	{gaSNUMBER+54,	144},
	{gaSNUMBER+31,	235}, // +841: state 223 transitions
	{gaSNUMBER+31,	236}, // +842: state 224 transitions
	{gaSNUMBER+14,	180}, // +843: state 225 transitions
	{gaSNUMBER+206,	206},
	{gaSNUMBER+54,	207},
	{gaSNUMBER+31,	237},
	{gaSNUMBER+133,	152}, // +847: state 226 transitions
	{gaSNUMBER+54,	153},
	{gaSNUMBER+14,	228}, // +849: state 227 transitions
	{gaSNUMBER+31,	229},
	{gaSNUMBER+31,	238}, // +851: state 228 transitions
	{gaSNUMBER+206,	21}, // +852: state 229 transitions
	{gaSNUMBER+14,	228},
	{gaSNUMBER+54,	239},
	{gaSNUMBER+31,	240},
	{gaSNUMBER+31,	241}, // +856: state 230 transitions
	{gaSNUMBER+14,	185}, // +857: state 231 transitions
	{gaSNUMBER+133,	212},
	{gaSNUMBER+54,	213},
	{gaSNUMBER+31,	242},
	{gaSNUMBER+14,	157}, // +861: state 232 transitions
	{gaSNUMBER+31,	232},
	{gaSNUMBER+31,	243}, // +863: state 233 transitions
	{gaSNUMBER+14,	172}, // +864: state 234 transitions
	{gaSNUMBER+206,	198},
	{gaSNUMBER+31,	234},
	{gaSNUMBER+31,	3}, // +867: state 235 transitions
	{gaSNUMBER+31,	244}, // +868: state 236 transitions
	{gaSNUMBER+14,	180}, // +869: state 237 transitions
	{gaSNUMBER+206,	206},
	{gaSNUMBER+31,	237},
	{gaSNUMBER+206,	21}, // +872: state 238 transitions
	{gaSNUMBER+31,	238},
	{gaSNUMBER+31,	245}, // +874: state 239 transitions
	{gaSNUMBER+206,	21}, // +875: state 240 transitions
	{gaSNUMBER+14,	228},
	{gaSNUMBER+54,	239},
	{gaSNUMBER+31,	246},
	{gaSNUMBER+31,	247}, // +879: state 241 transitions
	{gaSNUMBER+14,	185}, // +880: state 242 transitions
	{gaSNUMBER+133,	212},
	{gaSNUMBER+31,	242},
	{gaSNUMBER+206,	198}, // +883: state 243 transitions
	{gaSNUMBER+54,	199},
	{gaSNUMBER+206,	206}, // +885: state 244 transitions
	{gaSNUMBER+54,	207},
	{gaSNUMBER+31,	248}, // +887: state 245 transitions
	{gaSNUMBER+206,	21}, // +888: state 246 transitions
	{gaSNUMBER+14,	228},
	{gaSNUMBER+54,	239},
	{gaSNUMBER+31,	249},
	{gaSNUMBER+133,	212}, // +892: state 247 transitions
	{gaSNUMBER+54,	213},
	{gaSNUMBER+31,	250}, // +894: state 248 transitions
	{gaSNUMBER+206,	21}, // +895: state 249 transitions
	{gaSNUMBER+14,	228},
	{gaSNUMBER+31,	249},
	{gaSNUMBER+206,	21}, // +898: state 250 transitions
	{gaSNUMBER+54,	239},
};

const STATE_DESCRIPTION aStateDescNUMBER[251] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 11, gaTNUMBER+0},
	/*   1 */ {0, 1, gaTNUMBER+11},
	/*   2 */ {0, 2, gaTNUMBER+12},
	/*   3 */ {0, 1, gaTNUMBER+14},
	/*   4 */ {0, 3, gaTNUMBER+15},
	/*   5 */ {0, 2, gaTNUMBER+18},
	/*   6 */ {0, 1, gaTNUMBER+20},
	/*   7 */ {1, 23, gaTNUMBER+21},
	/*   8 */ {1, 24, gaTNUMBER+44},
	/*   9 */ {1, 24, gaTNUMBER+68},
	/*  10 */ {1, 23, gaTNUMBER+92},
	/*  11 */ {1, 23, gaTNUMBER+115},
	/*  12 */ {1, 2, gaTNUMBER+138},
	/*  13 */ {0, 1, gaTNUMBER+140},
	/*  14 */ {1, 4, gaTNUMBER+141},
	/*  15 */ {0, 1, gaTNUMBER+145},
	/*  16 */ {0, 2, gaTNUMBER+146},
	/*  17 */ {0, 1, gaTNUMBER+148},
	/*  18 */ {0, 4, gaTNUMBER+149},
	/*  19 */ {1, 15, gaTNUMBER+153},
	/*  20 */ {1, 13, gaTNUMBER+168},
	/*  21 */ {1, 0, NULL},
	/*  22 */ {0, 4, gaTNUMBER+181},
	/*  23 */ {0, 1, gaTNUMBER+185},
	/*  24 */ {0, 4, gaTNUMBER+186},
	/*  25 */ {1, 21, gaTNUMBER+190},
	/*  26 */ {1, 23, gaTNUMBER+211},
	/*  27 */ {0, 1, gaTNUMBER+234},
	/*  28 */ {0, 4, gaTNUMBER+235},
	/*  29 */ {1, 1, gaTNUMBER+239},
	/*  30 */ {1, 1, gaTNUMBER+240},
	/*  31 */ {0, 1, gaTNUMBER+241},
	/*  32 */ {0, 1, gaTNUMBER+242},
	/*  33 */ {0, 1, gaTNUMBER+243},
	/*  34 */ {0, 1, gaTNUMBER+244},
	/*  35 */ {0, 1, gaTNUMBER+245},
	/*  36 */ {0, 1, gaTNUMBER+246},
	/*  37 */ {0, 1, gaTNUMBER+247},
	/*  38 */ {1, 1, gaTNUMBER+248},
	/*  39 */ {1, 2, gaTNUMBER+249},
	/*  40 */ {0, 1, gaTNUMBER+251},
	/*  41 */ {0, 1, gaTNUMBER+252},
	/*  42 */ {0, 1, gaTNUMBER+253},
	/*  43 */ {0, 7, gaTNUMBER+254},
	/*  44 */ {0, 7, gaTNUMBER+261},
	/*  45 */ {0, 1, gaTNUMBER+268},
	/*  46 */ {0, 7, gaTNUMBER+269},
	/*  47 */ {1, 21, gaTNUMBER+276},
	/*  48 */ {1, 20, gaTNUMBER+297},
	/*  49 */ {0, 1, gaTNUMBER+317},
	/*  50 */ {1, 2, gaTNUMBER+318},
	/*  51 */ {0, 1, gaTNUMBER+320},
	/*  52 */ {0, 1, gaTNUMBER+321},
	/*  53 */ {1, 2, gaTNUMBER+322},
	/*  54 */ {1, 4, gaTNUMBER+324},
	/*  55 */ {0, 4, gaTNUMBER+328},
	/*  56 */ {0, 2, gaTNUMBER+332},
	/*  57 */ {0, 3, gaTNUMBER+334},
	/*  58 */ {0, 1, gaTNUMBER+337},
	/*  59 */ {0, 4, gaTNUMBER+338},
	/*  60 */ {0, 1, gaTNUMBER+342},
	/*  61 */ {1, 15, gaTNUMBER+343},
	/*  62 */ {0, 1, gaTNUMBER+358},
	/*  63 */ {0, 3, gaTNUMBER+359},
	/*  64 */ {0, 2, gaTNUMBER+362},
	/*  65 */ {0, 1, gaTNUMBER+364},
	/*  66 */ {1, 4, gaTNUMBER+365},
	/*  67 */ {0, 1, gaTNUMBER+369},
	/*  68 */ {1, 4, gaTNUMBER+370},
	/*  69 */ {1, 21, gaTNUMBER+374},
	/*  70 */ {0, 1, gaTNUMBER+395},
	/*  71 */ {0, 3, gaTNUMBER+396},
	/*  72 */ {0, 2, gaTNUMBER+399},
	/*  73 */ {0, 1, gaTNUMBER+401},
	/*  74 */ {1, 4, gaTNUMBER+402},
	/*  75 */ {1, 1, gaTNUMBER+406},
	/*  76 */ {0, 1, gaTNUMBER+407},
	/*  77 */ {0, 1, gaTNUMBER+408},
	/*  78 */ {1, 5, gaTNUMBER+409},
	/*  79 */ {1, 5, gaTNUMBER+414},
	/*  80 */ {1, 6, gaTNUMBER+419},
	/*  81 */ {1, 5, gaTNUMBER+425},
	/*  82 */ {1, 5, gaTNUMBER+430},
	/*  83 */ {1, 5, gaTNUMBER+435},
	/*  84 */ {1, 6, gaTNUMBER+440},
	/*  85 */ {1, 5, gaTNUMBER+446},
	/*  86 */ {0, 1, gaTNUMBER+451},
	/*  87 */ {1, 5, gaTNUMBER+452},
	/*  88 */ {1, 5, gaTNUMBER+457},
	/*  89 */ {1, 6, gaTNUMBER+462},
	/*  90 */ {1, 5, gaTNUMBER+468},
	/*  91 */ {0, 1, gaTNUMBER+473},
	/*  92 */ {0, 1, gaTNUMBER+474},
	/*  93 */ {1, 2, gaTNUMBER+475},
	/*  94 */ {1, 1, gaTNUMBER+477},
	/*  95 */ {0, 1, gaTNUMBER+478},
	/*  96 */ {1, 4, gaTNUMBER+479},
	/*  97 */ {0, 4, gaTNUMBER+483},
	/*  98 */ {0, 2, gaTNUMBER+487},
	/*  99 */ {0, 1, gaTNUMBER+489},
	/* 100 */ {0, 4, gaTNUMBER+490},
	/* 101 */ {0, 1, gaTNUMBER+494},
	/* 102 */ {0, 5, gaTNUMBER+495},
	/* 103 */ {0, 1, gaTNUMBER+500},
	/* 104 */ {1, 15, gaTNUMBER+501},
	/* 105 */ {0, 2, gaTNUMBER+516},
	/* 106 */ {0, 1, gaTNUMBER+518},
	/* 107 */ {0, 4, gaTNUMBER+519},
	/* 108 */ {1, 2, gaTNUMBER+523},
	/* 109 */ {0, 1, gaTNUMBER+525},
	/* 110 */ {1, 4, gaTNUMBER+526},
	/* 111 */ {0, 1, gaTNUMBER+530},
	/* 112 */ {1, 4, gaTNUMBER+531},
	/* 113 */ {0, 4, gaTNUMBER+535},
	/* 114 */ {1, 19, gaTNUMBER+539},
	/* 115 */ {1, 1, gaTNUMBER+558},
	/* 116 */ {0, 2, gaTNUMBER+559},
	/* 117 */ {0, 1, gaTNUMBER+561},
	/* 118 */ {0, 4, gaTNUMBER+562},
	/* 119 */ {1, 2, gaTNUMBER+566},
	/* 120 */ {0, 4, gaTNUMBER+568},
	/* 121 */ {0, 1, gaTNUMBER+572},
	/* 122 */ {1, 4, gaTNUMBER+573},
	/* 123 */ {1, 5, gaTNUMBER+577},
	/* 124 */ {0, 1, gaTNUMBER+582},
	/* 125 */ {1, 5, gaTNUMBER+583},
	/* 126 */ {1, 2, gaTNUMBER+588},
	/* 127 */ {1, 5, gaTNUMBER+590},
	/* 128 */ {0, 1, gaTNUMBER+595},
	/* 129 */ {1, 1, gaTNUMBER+596},
	/* 130 */ {0, 1, gaTNUMBER+597},
	/* 131 */ {1, 3, gaTNUMBER+598},
	/* 132 */ {0, 4, gaTNUMBER+601},
	/* 133 */ {0, 2, gaTNUMBER+605},
	/* 134 */ {1, 2, gaTNUMBER+607},
	/* 135 */ {0, 1, gaTNUMBER+609},
	/* 136 */ {0, 4, gaTNUMBER+610},
	/* 137 */ {0, 1, gaTNUMBER+614},
	/* 138 */ {0, 1, gaTNUMBER+615},
	/* 139 */ {0, 3, gaTNUMBER+616},
	/* 140 */ {0, 1, gaTNUMBER+619},
	/* 141 */ {1, 14, gaTNUMBER+620},
	/* 142 */ {0, 2, gaTNUMBER+634},
	/* 143 */ {0, 3, gaTNUMBER+636},
	/* 144 */ {0, 1, gaTNUMBER+639},
	/* 145 */ {0, 4, gaTNUMBER+640},
	/* 146 */ {0, 1, gaTNUMBER+644},
	/* 147 */ {1, 4, gaTNUMBER+645},
	/* 148 */ {1, 18, gaTNUMBER+649},
	/* 149 */ {1, 5, gaTNUMBER+667},
	/* 150 */ {1, 4, gaTNUMBER+672},
	/* 151 */ {0, 2, gaTNUMBER+676},
	/* 152 */ {0, 3, gaTNUMBER+678},
	/* 153 */ {0, 1, gaTNUMBER+681},
	/* 154 */ {0, 4, gaTNUMBER+682},
	/* 155 */ {0, 3, gaTNUMBER+686},
	/* 156 */ {0, 2, gaTNUMBER+689},
	/* 157 */ {0, 1, gaTNUMBER+691},
	/* 158 */ {1, 3, gaTNUMBER+692},
	/* 159 */ {0, 1, gaTNUMBER+695},
	/* 160 */ {1, 4, gaTNUMBER+696},
	/* 161 */ {0, 1, gaTNUMBER+700},
	/* 162 */ {0, 2, gaTNUMBER+701},
	/* 163 */ {0, 1, gaTNUMBER+703},
	/* 164 */ {1, 1, gaTNUMBER+704},
	/* 165 */ {1, 3, gaTNUMBER+705},
	/* 166 */ {0, 1, gaTNUMBER+708},
	/* 167 */ {0, 4, gaTNUMBER+709},
	/* 168 */ {0, 2, gaTNUMBER+713},
	/* 169 */ {0, 1, gaTNUMBER+715},
	/* 170 */ {1, 13, gaTNUMBER+716},
	/* 171 */ {0, 2, gaTNUMBER+729},
	/* 172 */ {0, 1, gaTNUMBER+731},
	/* 173 */ {0, 4, gaTNUMBER+732},
	/* 174 */ {0, 1, gaTNUMBER+736},
	/* 175 */ {0, 4, gaTNUMBER+737},
	/* 176 */ {0, 1, gaTNUMBER+741},
	/* 177 */ {1, 3, gaTNUMBER+742},
	/* 178 */ {1, 4, gaTNUMBER+745},
	/* 179 */ {0, 2, gaTNUMBER+749},
	/* 180 */ {0, 1, gaTNUMBER+751},
	/* 181 */ {0, 4, gaTNUMBER+752},
	/* 182 */ {0, 1, gaTNUMBER+756},
	/* 183 */ {0, 4, gaTNUMBER+757},
	/* 184 */ {0, 2, gaTNUMBER+761},
	/* 185 */ {0, 1, gaTNUMBER+763},
	/* 186 */ {0, 4, gaTNUMBER+764},
	/* 187 */ {1, 3, gaTNUMBER+768},
	/* 188 */ {0, 1, gaTNUMBER+771},
	/* 189 */ {1, 3, gaTNUMBER+772},
	/* 190 */ {1, 1, gaTNUMBER+775},
	/* 191 */ {0, 1, gaTNUMBER+776},
	/* 192 */ {0, 1, gaTNUMBER+777},
	/* 193 */ {0, 1, gaTNUMBER+778},
	/* 194 */ {0, 1, gaTNUMBER+779},
	/* 195 */ {0, 3, gaTNUMBER+780},
	/* 196 */ {0, 1, gaTNUMBER+783},
	/* 197 */ {0, 2, gaTNUMBER+784},
	/* 198 */ {1, 1, gaTNUMBER+786},
	/* 199 */ {0, 1, gaTNUMBER+787},
	/* 200 */ {0, 4, gaTNUMBER+788},
	/* 201 */ {0, 1, gaTNUMBER+792},
	/* 202 */ {0, 3, gaTNUMBER+793},
	/* 203 */ {1, 2, gaTNUMBER+796},
	/* 204 */ {1, 5, gaTNUMBER+798},
	/* 205 */ {0, 2, gaTNUMBER+803},
	/* 206 */ {1, 1, gaTNUMBER+805},
	/* 207 */ {0, 1, gaTNUMBER+806},
	/* 208 */ {0, 4, gaTNUMBER+807},
	/* 209 */ {0, 1, gaTNUMBER+811},
	/* 210 */ {0, 3, gaTNUMBER+812},
	/* 211 */ {0, 2, gaTNUMBER+815},
	/* 212 */ {0, 3, gaTNUMBER+817},
	/* 213 */ {0, 1, gaTNUMBER+820},
	/* 214 */ {0, 4, gaTNUMBER+821},
	/* 215 */ {1, 3, gaTNUMBER+825},
	/* 216 */ {1, 2, gaTNUMBER+828},
	/* 217 */ {1, 1, gaTNUMBER+830},
	/* 218 */ {0, 2, gaTNUMBER+831},
	/* 219 */ {0, 1, gaTNUMBER+833},
	/* 220 */ {0, 1, gaTNUMBER+834},
	/* 221 */ {0, 4, gaTNUMBER+835},
	/* 222 */ {0, 2, gaTNUMBER+839},
	/* 223 */ {0, 1, gaTNUMBER+841},
	/* 224 */ {0, 1, gaTNUMBER+842},
	/* 225 */ {0, 4, gaTNUMBER+843},
	/* 226 */ {0, 2, gaTNUMBER+847},
	/* 227 */ {0, 2, gaTNUMBER+849},
	/* 228 */ {0, 1, gaTNUMBER+851},
	/* 229 */ {0, 4, gaTNUMBER+852},
	/* 230 */ {0, 1, gaTNUMBER+856},
	/* 231 */ {0, 4, gaTNUMBER+857},
	/* 232 */ {1, 2, gaTNUMBER+861},
	/* 233 */ {0, 1, gaTNUMBER+863},
	/* 234 */ {0, 3, gaTNUMBER+864},
	/* 235 */ {0, 1, gaTNUMBER+867},
	/* 236 */ {0, 1, gaTNUMBER+868},
	/* 237 */ {0, 3, gaTNUMBER+869},
	/* 238 */ {0, 2, gaTNUMBER+872},
	/* 239 */ {0, 1, gaTNUMBER+874},
	/* 240 */ {0, 4, gaTNUMBER+875},
	/* 241 */ {0, 1, gaTNUMBER+879},
	/* 242 */ {0, 3, gaTNUMBER+880},
	/* 243 */ {0, 2, gaTNUMBER+883},
	/* 244 */ {0, 2, gaTNUMBER+885},
	/* 245 */ {0, 1, gaTNUMBER+887},
	/* 246 */ {0, 4, gaTNUMBER+888},
	/* 247 */ {0, 2, gaTNUMBER+892},
	/* 248 */ {0, 1, gaTNUMBER+894},
	/* 249 */ {0, 3, gaTNUMBER+895},
	/* 250 */ {0, 2, gaTNUMBER+898},
};

// end of text generated by re2fsa

/**************** NUMSIMPLE ***********************************/

// 12 states

static const unsigned char gaSNUMSIMPLE[] = 
	/* gaStringNUMSIMPLE+0 */	"+-\000"
	/* gaStringNUMSIMPLE+3 */	".\000"
	/* gaStringNUMSIMPLE+5 */	"0123456789\000"
	/* gaStringNUMSIMPLE+16 */	",\000"
;

static const STATE_TRANSITION gaTNUMSIMPLE[] = {
	{gaSNUMSIMPLE+0,	1}, // +0: state 0 transitions
	{gaSNUMSIMPLE+3,	2},
	{gaSNUMSIMPLE+5,	3},
	{gaSNUMSIMPLE+3,	2}, // +3: state 1 transitions
	{gaSNUMSIMPLE+5,	3},
	{gaSNUMSIMPLE+5,	4}, // +5: state 2 transitions
	{gaSNUMSIMPLE+3,	2}, // +6: state 3 transitions
	{gaSNUMSIMPLE+16,	5},
	{gaSNUMSIMPLE+5,	6},
	{gaSNUMSIMPLE+5,	4}, // +9: state 4 transitions
	{gaSNUMSIMPLE+5,	7}, // +10: state 5 transitions
	{gaSNUMSIMPLE+3,	2}, // +11: state 6 transitions
	{gaSNUMSIMPLE+16,	5},
	{gaSNUMSIMPLE+5,	8},
	{gaSNUMSIMPLE+5,	9}, // +14: state 7 transitions
	{gaSNUMSIMPLE+3,	2}, // +15: state 8 transitions
	{gaSNUMSIMPLE+16,	5},
	{gaSNUMSIMPLE+5,	10},
	{gaSNUMSIMPLE+5,	11}, // +18: state 9 transitions
	{gaSNUMSIMPLE+3,	2}, // +19: state 10 transitions
	{gaSNUMSIMPLE+5,	10},
	{gaSNUMSIMPLE+16,	5}, // +21: state 11 transitions
};

const STATE_DESCRIPTION aStateDescNUMSIMPLE[12] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMSIMPLE+0},
	/*   1 */ {0, 2, gaTNUMSIMPLE+3},
	/*   2 */ {0, 1, gaTNUMSIMPLE+5},
	/*   3 */ {1, 3, gaTNUMSIMPLE+6},
	/*   4 */ {1, 1, gaTNUMSIMPLE+9},
	/*   5 */ {0, 1, gaTNUMSIMPLE+10},
	/*   6 */ {1, 3, gaTNUMSIMPLE+11},
	/*   7 */ {0, 1, gaTNUMSIMPLE+14},
	/*   8 */ {1, 3, gaTNUMSIMPLE+15},
	/*   9 */ {0, 1, gaTNUMSIMPLE+18},
	/*  10 */ {1, 2, gaTNUMSIMPLE+19},
	/*  11 */ {1, 1, gaTNUMSIMPLE+21},
};

/**************** NUMNTH ***********************************/

// 16 states

static const unsigned char gaSNUMNTH[] = 
	/* gaStringNUMNTH+0 */	"0123456789\000"
	/* gaStringNUMNTH+11 */	"D\000"
	/* gaStringNUMNTH+13 */	"T\000"
	/* gaStringNUMNTH+15 */	"H\000"
	/* gaStringNUMNTH+17 */	"d\000"
	/* gaStringNUMNTH+19 */	"t\000"
	/* gaStringNUMNTH+21 */	"h\000"
	/* gaStringNUMNTH+23 */	",\000"
	/* gaStringNUMNTH+25 */	"NR\000"
	/* gaStringNUMNTH+28 */	"S\000"
	/* gaStringNUMNTH+30 */	"nr\000"
	/* gaStringNUMNTH+33 */	"s\000"
;

static const STATE_TRANSITION gaTNUMNTH[] = {
	{gaSNUMNTH+0,	10}, // +0: state 0 transitions
	{gaSNUMNTH+0,	15}, // +1: state 1 transitions
	{gaSNUMNTH+0,	3}, // +2: state 2 transitions
	{gaSNUMNTH+0,	1}, // +3: state 3 transitions
	{gaSNUMNTH+11,	13}, // +4: state 4 transitions
	{gaSNUMNTH+13,	13}, // +5: state 5 transitions
	{gaSNUMNTH+15,	13}, // +6: state 6 transitions
	{gaSNUMNTH+17,	13}, // +7: state 7 transitions
	{gaSNUMNTH+19,	13}, // +8: state 8 transitions
	{gaSNUMNTH+21,	13}, // +9: state 9 transitions
	{gaSNUMNTH+23,	2}, // +10: state 10 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	11},
	{gaSNUMNTH+23,	2}, // +18: state 11 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	12},
	{gaSNUMNTH+23,	2}, // +26: state 12 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	14},
	{gaSNUMNTH+25,	4}, // +34: state 14 transitions
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
	{gaSNUMNTH+0,	14},
	{gaSNUMNTH+23,	2}, // +41: state 15 transitions
	{gaSNUMNTH+25,	4},
	{gaSNUMNTH+28,	5},
	{gaSNUMNTH+13,	6},
	{gaSNUMNTH+30,	7},
	{gaSNUMNTH+33,	8},
	{gaSNUMNTH+19,	9},
};

const STATE_DESCRIPTION aStateDescNUMNTH[16] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNTH+0},
	/*   1 */ {0, 1, gaTNUMNTH+1},
	/*   2 */ {0, 1, gaTNUMNTH+2},
	/*   3 */ {0, 1, gaTNUMNTH+3},
	/*   4 */ {0, 1, gaTNUMNTH+4},
	/*   5 */ {0, 1, gaTNUMNTH+5},
	/*   6 */ {0, 1, gaTNUMNTH+6},
	/*   7 */ {0, 1, gaTNUMNTH+7},
	/*   8 */ {0, 1, gaTNUMNTH+8},
	/*   9 */ {0, 1, gaTNUMNTH+9},
	/*  10 */ {1, 8, gaTNUMNTH+10},
	/*  11 */ {1, 8, gaTNUMNTH+18},
	/*  12 */ {1, 8, gaTNUMNTH+26},
	/*  13 */ {1, 0, NULL},
	/*  14 */ {1, 7, gaTNUMNTH+34},
	/*  15 */ {1, 7, gaTNUMNTH+41},
};

/**************** NUMUNIT ***********************************/

// 25 states

static const unsigned char gaSNUMUNIT[] = 
	/* gaStringNUMUNIT+0 */	"+-\000"
	/* gaStringNUMUNIT+3 */	".\000"
	/* gaStringNUMUNIT+5 */	"0123456789\000"
	/* gaStringNUMUNIT+16 */	"\"'Bb\000"
	/* gaStringNUMUNIT+22 */	",\000"
	/* gaStringNUMUNIT+24 */	"K\000"
	/* gaStringNUMUNIT+26 */	"M\000"
	/* gaStringNUMUNIT+28 */	"Ss\000"
	/* gaStringNUMUNIT+31 */	"c\000"
	/* gaStringNUMUNIT+33 */	"e\000"
	/* gaStringNUMUNIT+35 */	"f\000"
	/* gaStringNUMUNIT+37 */	"i\000"
	/* gaStringNUMUNIT+39 */	"k\000"
	/* gaStringNUMUNIT+41 */	"m\000"
	/* gaStringNUMUNIT+43 */	"BVbm\000"
	/* gaStringNUMUNIT+48 */	"Bb\000"
	/* gaStringNUMUNIT+51 */	"q\000"
	/* gaStringNUMUNIT+53 */	"r\000"
	/* gaStringNUMUNIT+55 */	"t\000"
	/* gaStringNUMUNIT+57 */	"n\000"
	/* gaStringNUMUNIT+59 */	"bmv\000"
	/* gaStringNUMUNIT+63 */	"b\000"
	/* gaStringNUMUNIT+65 */	"s\000"
;

static const STATE_TRANSITION gaTNUMUNIT[] = {
	{gaSNUMUNIT+0,	1}, // +0: state 0 transitions
	{gaSNUMUNIT+3,	2},
	{gaSNUMUNIT+5,	3},
	{gaSNUMUNIT+3,	2}, // +3: state 1 transitions
	{gaSNUMUNIT+5,	3},
	{gaSNUMUNIT+5,	4}, // +5: state 2 transitions
	{gaSNUMUNIT+3,	2}, // +6: state 3 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+5,	7},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	4}, // +19: state 4 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	17}, // +30: state 6 transitions
	{gaSNUMUNIT+3,	2}, // +31: state 7 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	18},
	{gaSNUMUNIT+43,	5}, // +44: state 8 transitions
	{gaSNUMUNIT+48,	5}, // +45: state 9 transitions
	{gaSNUMUNIT+51,	5}, // +46: state 10 transitions
	{gaSNUMUNIT+41,	19}, // +47: state 11 transitions
	{gaSNUMUNIT+53,	20}, // +48: state 12 transitions
	{gaSNUMUNIT+55,	21}, // +49: state 13 transitions
	{gaSNUMUNIT+57,	21}, // +50: state 14 transitions
	{gaSNUMUNIT+59,	5}, // +51: state 15 transitions
	{gaSNUMUNIT+63,	5}, // +52: state 16 transitions
	{gaSNUMUNIT+41,	19},
	{gaSNUMUNIT+5,	22}, // +54: state 17 transitions
	{gaSNUMUNIT+3,	2}, // +55: state 18 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	23},
	{gaSNUMUNIT+3,	5}, // +68: state 19 transitions
	{gaSNUMUNIT+65,	5}, // +69: state 20 transitions
	{gaSNUMUNIT+3,	5}, // +70: state 21 transitions
	{gaSNUMUNIT+5,	24}, // +71: state 22 transitions
	{gaSNUMUNIT+3,	2}, // +72: state 23 transitions
	{gaSNUMUNIT+16,	5},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
	{gaSNUMUNIT+5,	23},
	{gaSNUMUNIT+16,	5}, // +84: state 24 transitions
	{gaSNUMUNIT+22,	6},
	{gaSNUMUNIT+24,	8},
	{gaSNUMUNIT+26,	9},
	{gaSNUMUNIT+28,	10},
	{gaSNUMUNIT+31,	11},
	{gaSNUMUNIT+33,	12},
	{gaSNUMUNIT+35,	13},
	{gaSNUMUNIT+37,	14},
	{gaSNUMUNIT+39,	15},
	{gaSNUMUNIT+41,	16},
};

const STATE_DESCRIPTION aStateDescNUMUNIT[25] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMUNIT+0},
	/*   1 */ {0, 2, gaTNUMUNIT+3},
	/*   2 */ {0, 1, gaTNUMUNIT+5},
	/*   3 */ {0, 13, gaTNUMUNIT+6},
	/*   4 */ {0, 11, gaTNUMUNIT+19},
	/*   5 */ {1, 0, NULL},
	/*   6 */ {0, 1, gaTNUMUNIT+30},
	/*   7 */ {0, 13, gaTNUMUNIT+31},
	/*   8 */ {1, 1, gaTNUMUNIT+44},
	/*   9 */ {1, 1, gaTNUMUNIT+45},
	/*  10 */ {0, 1, gaTNUMUNIT+46},
	/*  11 */ {0, 1, gaTNUMUNIT+47},
	/*  12 */ {0, 1, gaTNUMUNIT+48},
	/*  13 */ {0, 1, gaTNUMUNIT+49},
	/*  14 */ {0, 1, gaTNUMUNIT+50},
	/*  15 */ {1, 1, gaTNUMUNIT+51},
	/*  16 */ {1, 2, gaTNUMUNIT+52},
	/*  17 */ {0, 1, gaTNUMUNIT+54},
	/*  18 */ {0, 13, gaTNUMUNIT+55},
	/*  19 */ {1, 1, gaTNUMUNIT+68},
	/*  20 */ {0, 1, gaTNUMUNIT+69},
	/*  21 */ {0, 1, gaTNUMUNIT+70},
	/*  22 */ {0, 1, gaTNUMUNIT+71},
	/*  23 */ {0, 12, gaTNUMUNIT+72},
	/*  24 */ {0, 11, gaTNUMUNIT+84},
};

/**************** NUMNUM ***********************************/

// 10 states

static const unsigned char gaSNUMNUM[] = 
	/* gaStringNUMNUM+0 */	"#\000"
	/* gaStringNUMNUM+2 */	"0123456789\000"
	/* gaStringNUMNUM+13 */	",\000"
;

static const STATE_TRANSITION gaTNUMNUM[] = {
	{gaSNUMNUM+0,	1}, // +0: state 0 transitions
	{gaSNUMNUM+2,	2}, // +1: state 1 transitions
	{gaSNUMNUM+13,	3}, // +2: state 2 transitions
	{gaSNUMNUM+2,	4},
	{gaSNUMNUM+2,	7}, // +4: state 3 transitions
	{gaSNUMNUM+13,	3}, // +5: state 4 transitions
	{gaSNUMNUM+2,	5},
	{gaSNUMNUM+13,	3}, // +7: state 5 transitions
	{gaSNUMNUM+2,	6},
	{gaSNUMNUM+2,	6}, // +9: state 6 transitions
	{gaSNUMNUM+2,	8}, // +10: state 7 transitions
	{gaSNUMNUM+2,	9}, // +11: state 8 transitions
	{gaSNUMNUM+13,	3}, // +12: state 9 transitions
};

const STATE_DESCRIPTION aStateDescNUMNUM[10] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTNUMNUM+0},
	/*   1 */ {0, 1, gaTNUMNUM+1},
	/*   2 */ {1, 2, gaTNUMNUM+2},
	/*   3 */ {0, 1, gaTNUMNUM+4},
	/*   4 */ {1, 2, gaTNUMNUM+5},
	/*   5 */ {1, 2, gaTNUMNUM+7},
	/*   6 */ {1, 1, gaTNUMNUM+9},
	/*   7 */ {0, 1, gaTNUMNUM+10},
	/*   8 */ {0, 1, gaTNUMNUM+11},
	/*   9 */ {1, 1, gaTNUMNUM+12},
};

/**************** NUMPERCENT ***********************************/

// 13 states

static const unsigned char gaSNUMPERCENT[] = 
	/* gaStringNUMPERCENT+0 */	"+-\000"
	/* gaStringNUMPERCENT+3 */	".\000"
	/* gaStringNUMPERCENT+5 */	"0123456789\000"
	/* gaStringNUMPERCENT+16 */	"%\000"
	/* gaStringNUMPERCENT+18 */	",\000"
;

static const STATE_TRANSITION gaTNUMPERCENT[] = {
	{gaSNUMPERCENT+0,	1}, // +0: state 0 transitions
	{gaSNUMPERCENT+3,	2},
	{gaSNUMPERCENT+5,	3},
	{gaSNUMPERCENT+3,	2}, // +3: state 1 transitions
	{gaSNUMPERCENT+5,	3},
	{gaSNUMPERCENT+5,	12}, // +5: state 2 transitions
	{gaSNUMPERCENT+3,	2}, // +6: state 3 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+5,	6},
	{gaSNUMPERCENT+5,	9}, // +10: state 5 transitions
	{gaSNUMPERCENT+3,	2}, // +11: state 6 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+5,	7},
	{gaSNUMPERCENT+3,	2}, // +15: state 7 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+5,	8},
	{gaSNUMPERCENT+3,	2}, // +19: state 8 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+5,	8},
	{gaSNUMPERCENT+5,	10}, // +22: state 9 transitions
	{gaSNUMPERCENT+5,	11}, // +23: state 10 transitions
	{gaSNUMPERCENT+3,	2}, // +24: state 11 transitions
	{gaSNUMPERCENT+16,	4},
	{gaSNUMPERCENT+18,	5},
	{gaSNUMPERCENT+16,	4}, // +27: state 12 transitions
	{gaSNUMPERCENT+5,	12},
};

const STATE_DESCRIPTION aStateDescNUMPERCENT[13] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMPERCENT+0},
	/*   1 */ {0, 2, gaTNUMPERCENT+3},
	/*   2 */ {0, 1, gaTNUMPERCENT+5},
	/*   3 */ {0, 4, gaTNUMPERCENT+6},
	/*   4 */ {1, 0, NULL},
	/*   5 */ {0, 1, gaTNUMPERCENT+10},
	/*   6 */ {0, 4, gaTNUMPERCENT+11},
	/*   7 */ {0, 4, gaTNUMPERCENT+15},
	/*   8 */ {0, 3, gaTNUMPERCENT+19},
	/*   9 */ {0, 1, gaTNUMPERCENT+22},
	/*  10 */ {0, 1, gaTNUMPERCENT+23},
	/*  11 */ {0, 3, gaTNUMPERCENT+24},
	/*  12 */ {0, 2, gaTNUMPERCENT+27},
};

// end of text generated by re2fsa


/**************** NUMDATE ***********************************/

// numsimple = [sign] integer;
// numsimple = [sign] [digit_seq] "." digit_seq;
//
// ... stuff deleted (see rules at top of this file)
//
// = date

// 109 states

static const unsigned char gaSNUMDATE[] = 
	/* gaStringNUMDATE+0 */	"'\000"
	/* gaStringNUMDATE+2 */	"0\000"
	/* gaStringNUMDATE+4 */	"1\000"
	/* gaStringNUMDATE+6 */	"23456789\000"
	/* gaStringNUMDATE+15 */	"A\000"
	/* gaStringNUMDATE+17 */	"D\000"
	/* gaStringNUMDATE+19 */	"F\000"
	/* gaStringNUMDATE+21 */	"J\000"
	/* gaStringNUMDATE+23 */	"M\000"
	/* gaStringNUMDATE+25 */	"N\000"
	/* gaStringNUMDATE+27 */	"O\000"
	/* gaStringNUMDATE+29 */	"S\000"
	/* gaStringNUMDATE+31 */	"T\000"
	/* gaStringNUMDATE+33 */	"W\000"
	/* gaStringNUMDATE+35 */	"0123456789\000"
	/* gaStringNUMDATE+46 */	"123456789\000"
	/* gaStringNUMDATE+56 */	"3456789\000"
	/* gaStringNUMDATE+64 */	"012\000"
	/* gaStringNUMDATE+68 */	"-\000"
	/* gaStringNUMDATE+70 */	"/\000"
	/* gaStringNUMDATE+72 */	"P\000"
	/* gaStringNUMDATE+74 */	"U\000"
	/* gaStringNUMDATE+76 */	"p\000"
	/* gaStringNUMDATE+78 */	"u\000"
	/* gaStringNUMDATE+80 */	"E\000"
	/* gaStringNUMDATE+82 */	"e\000"
	/* gaStringNUMDATE+84 */	"r\000"
	/* gaStringNUMDATE+86 */	"a\000"
	/* gaStringNUMDATE+88 */	"o\000"
	/* gaStringNUMDATE+90 */	"C\000"
	/* gaStringNUMDATE+92 */	"c\000"
	/* gaStringNUMDATE+94 */	"h\000"
	/* gaStringNUMDATE+96 */	"12\000"
	/* gaStringNUMDATE+99 */	"3\000"
	/* gaStringNUMDATE+101 */	"456789\000"
	/* gaStringNUMDATE+108 */	"R\000"
	/* gaStringNUMDATE+110 */	"G\000"
	/* gaStringNUMDATE+112 */	"g\000"
	/* gaStringNUMDATE+114 */	"B\000"
	/* gaStringNUMDATE+116 */	"b\000"
	/* gaStringNUMDATE+118 */	"i\000"
	/* gaStringNUMDATE+120 */	"LN\000"
	/* gaStringNUMDATE+123 */	"n\000"
	/* gaStringNUMDATE+125 */	"l\000"
	/* gaStringNUMDATE+127 */	"RY\000"
	/* gaStringNUMDATE+130 */	"y\000"
	/* gaStringNUMDATE+132 */	"V\000"
	/* gaStringNUMDATE+134 */	"v\000"
	/* gaStringNUMDATE+136 */	"t\000"
	/* gaStringNUMDATE+138 */	"d\000"
	/* gaStringNUMDATE+140 */	"01\000"
	/* gaStringNUMDATE+143 */	" \000"
	/* gaStringNUMDATE+145 */	",\000"
	/* gaStringNUMDATE+147 */	"s\000"
	/* gaStringNUMDATE+149 */	"m\000"
;

static const STATE_TRANSITION gaTNUMDATE[] = {
	{gaSNUMDATE+0,	1}, // +0: state 0 transitions
	{gaSNUMDATE+2,	2},
	{gaSNUMDATE+4,	3},
	{gaSNUMDATE+6,	4},
	{gaSNUMDATE+15,	5},
	{gaSNUMDATE+17,	6},
	{gaSNUMDATE+19,	7},
	{gaSNUMDATE+21,	8},
	{gaSNUMDATE+23,	9},
	{gaSNUMDATE+25,	10},
	{gaSNUMDATE+27,	11},
	{gaSNUMDATE+29,	12},
	{gaSNUMDATE+31,	13},
	{gaSNUMDATE+33,	14},
	{gaSNUMDATE+35,	15}, // +14: state 1 transitions
	{gaSNUMDATE+2,	16}, // +15: state 2 transitions
	{gaSNUMDATE+46,	17},
	{gaSNUMDATE+56,	16}, // +17: state 3 transitions
	{gaSNUMDATE+64,	17},
	{gaSNUMDATE+68,	18},
	{gaSNUMDATE+70,	19},
	{gaSNUMDATE+35,	16}, // +21: state 4 transitions
	{gaSNUMDATE+68,	18},
	{gaSNUMDATE+70,	19},
	{gaSNUMDATE+72,	20}, // +24: state 5 transitions
	{gaSNUMDATE+74,	21},
	{gaSNUMDATE+76,	22},
	{gaSNUMDATE+78,	23},
	{gaSNUMDATE+80,	24}, // +28: state 6 transitions
	{gaSNUMDATE+82,	25},
	{gaSNUMDATE+80,	26}, // +30: state 7 transitions
	{gaSNUMDATE+82,	27},
	{gaSNUMDATE+84,	28},
	{gaSNUMDATE+15,	29}, // +33: state 8 transitions
	{gaSNUMDATE+74,	30},
	{gaSNUMDATE+86,	31},
	{gaSNUMDATE+78,	32},
	{gaSNUMDATE+15,	33}, // +37: state 9 transitions
	{gaSNUMDATE+86,	34},
	{gaSNUMDATE+88,	35},
	{gaSNUMDATE+27,	36}, // +40: state 10 transitions
	{gaSNUMDATE+88,	37},
	{gaSNUMDATE+90,	38}, // +42: state 11 transitions
	{gaSNUMDATE+92,	39},
	{gaSNUMDATE+78,	35}, // +44: state 12 transitions
	{gaSNUMDATE+80,	40},
	{gaSNUMDATE+86,	41},
	{gaSNUMDATE+82,	42},
	{gaSNUMDATE+94,	43}, // +48: state 13 transitions
	{gaSNUMDATE+78,	44},
	{gaSNUMDATE+82,	45}, // +50: state 14 transitions
	{gaSNUMDATE+35,	46}, // +51: state 15 transitions
	{gaSNUMDATE+35,	47}, // +52: state 16 transitions
	{gaSNUMDATE+68,	18}, // +53: state 17 transitions
	{gaSNUMDATE+70,	19},
	{gaSNUMDATE+35,	47},
	{gaSNUMDATE+2,	48}, // +56: state 18 transitions
	{gaSNUMDATE+96,	49},
	{gaSNUMDATE+99,	50},
	{gaSNUMDATE+101,	51},
	{gaSNUMDATE+2,	52}, // +60: state 19 transitions
	{gaSNUMDATE+96,	53},
	{gaSNUMDATE+99,	54},
	{gaSNUMDATE+101,	55},
	{gaSNUMDATE+108,	56}, // +64: state 20 transitions
	{gaSNUMDATE+110,	56}, // +65: state 21 transitions
	{gaSNUMDATE+84,	57}, // +66: state 22 transitions
	{gaSNUMDATE+112,	58}, // +67: state 23 transitions
	{gaSNUMDATE+90,	56}, // +68: state 24 transitions
	{gaSNUMDATE+92,	59}, // +69: state 25 transitions
	{gaSNUMDATE+114,	56}, // +70: state 26 transitions
	{gaSNUMDATE+116,	60}, // +71: state 27 transitions
	{gaSNUMDATE+118,	61}, // +72: state 28 transitions
	{gaSNUMDATE+25,	56}, // +73: state 29 transitions
	{gaSNUMDATE+120,	56}, // +74: state 30 transitions
	{gaSNUMDATE+123,	62}, // +75: state 31 transitions
	{gaSNUMDATE+125,	63}, // +76: state 32 transitions
	{gaSNUMDATE+123,	64},
	{gaSNUMDATE+127,	56}, // +78: state 33 transitions
	{gaSNUMDATE+130,	56}, // +79: state 34 transitions
	{gaSNUMDATE+84,	65},
	{gaSNUMDATE+123,	61}, // +81: state 35 transitions
	{gaSNUMDATE+132,	56}, // +82: state 36 transitions
	{gaSNUMDATE+134,	59}, // +83: state 37 transitions
	{gaSNUMDATE+31,	56}, // +84: state 38 transitions
	{gaSNUMDATE+136,	66}, // +85: state 39 transitions
	{gaSNUMDATE+72,	56}, // +86: state 40 transitions
	{gaSNUMDATE+136,	67}, // +87: state 41 transitions
	{gaSNUMDATE+76,	68}, // +88: state 42 transitions
	{gaSNUMDATE+78,	69}, // +89: state 43 transitions
	{gaSNUMDATE+82,	70}, // +90: state 44 transitions
	{gaSNUMDATE+138,	71}, // +91: state 45 transitions
	{gaSNUMDATE+35,	72}, // +92: state 47 transitions
	{gaSNUMDATE+46,	51}, // +93: state 48 transitions
	{gaSNUMDATE+35,	51}, // +94: state 49 transitions
	{gaSNUMDATE+68,	73},
	{gaSNUMDATE+140,	51}, // +96: state 50 transitions
	{gaSNUMDATE+68,	73},
	{gaSNUMDATE+68,	73}, // +98: state 51 transitions
	{gaSNUMDATE+46,	55}, // +99: state 52 transitions
	{gaSNUMDATE+35,	55}, // +100: state 53 transitions
	{gaSNUMDATE+70,	73},
	{gaSNUMDATE+140,	55}, // +102: state 54 transitions
	{gaSNUMDATE+70,	73},
	{gaSNUMDATE+70,	73}, // +104: state 55 transitions
	{gaSNUMDATE+143,	74}, // +105: state 56 transitions
	{gaSNUMDATE+143,	74}, // +106: state 57 transitions
	{gaSNUMDATE+118,	75},
	{gaSNUMDATE+143,	74}, // +108: state 58 transitions
	{gaSNUMDATE+78,	76},
	{gaSNUMDATE+143,	74}, // +110: state 59 transitions
	{gaSNUMDATE+82,	77},
	{gaSNUMDATE+143,	74}, // +112: state 60 transitions
	{gaSNUMDATE+84,	78},
	{gaSNUMDATE+145,	79}, // +114: state 61 transitions
	{gaSNUMDATE+138,	80},
	{gaSNUMDATE+143,	74}, // +116: state 62 transitions
	{gaSNUMDATE+78,	81},
	{gaSNUMDATE+130,	56}, // +118: state 63 transitions
	{gaSNUMDATE+143,	74},
	{gaSNUMDATE+82,	56}, // +120: state 64 transitions
	{gaSNUMDATE+143,	74},
	{gaSNUMDATE+143,	74}, // +122: state 65 transitions
	{gaSNUMDATE+92,	82},
	{gaSNUMDATE+143,	74}, // +124: state 66 transitions
	{gaSNUMDATE+88,	83},
	{gaSNUMDATE+145,	79}, // +126: state 67 transitions
	{gaSNUMDATE+78,	84},
	{gaSNUMDATE+143,	74}, // +128: state 68 transitions
	{gaSNUMDATE+136,	85},
	{gaSNUMDATE+145,	79}, // +130: state 69 transitions
	{gaSNUMDATE+84,	86},
	{gaSNUMDATE+145,	79}, // +132: state 70 transitions
	{gaSNUMDATE+147,	87},
	{gaSNUMDATE+145,	79}, // +134: state 71 transitions
	{gaSNUMDATE+123,	88},
	{gaSNUMDATE+68,	89}, // +136: state 72 transitions
	{gaSNUMDATE+35,	90}, // +137: state 73 transitions
	{gaSNUMDATE+2,	91}, // +138: state 74 transitions
	{gaSNUMDATE+96,	92},
	{gaSNUMDATE+99,	93},
	{gaSNUMDATE+101,	94},
	{gaSNUMDATE+125,	56}, // +142: state 75 transitions
	{gaSNUMDATE+147,	95}, // +143: state 76 transitions
	{gaSNUMDATE+149,	83}, // +144: state 77 transitions
	{gaSNUMDATE+78,	81}, // +145: state 78 transitions
	{gaSNUMDATE+143,	96}, // +146: state 79 transitions
	{gaSNUMDATE+86,	97}, // +147: state 80 transitions
	{gaSNUMDATE+86,	98}, // +148: state 81 transitions
	{gaSNUMDATE+94,	56}, // +149: state 82 transitions
	{gaSNUMDATE+116,	99}, // +150: state 83 transitions
	{gaSNUMDATE+84,	87}, // +151: state 84 transitions
	{gaSNUMDATE+82,	77}, // +152: state 85 transitions
	{gaSNUMDATE+147,	87}, // +153: state 86 transitions
	{gaSNUMDATE+138,	80}, // +154: state 87 transitions
	{gaSNUMDATE+82,	86}, // +155: state 88 transitions
	{gaSNUMDATE+35,	100}, // +156: state 89 transitions
	{gaSNUMDATE+35,	101}, // +157: state 90 transitions
	{gaSNUMDATE+46,	94}, // +158: state 91 transitions
	{gaSNUMDATE+35,	94}, // +159: state 92 transitions
	{gaSNUMDATE+145,	102},
	{gaSNUMDATE+140,	94}, // +161: state 93 transitions
	{gaSNUMDATE+145,	102},
	{gaSNUMDATE+145,	102}, // +163: state 94 transitions
	{gaSNUMDATE+136,	56}, // +164: state 95 transitions
	{gaSNUMDATE+15,	5}, // +165: state 96 transitions
	{gaSNUMDATE+17,	6},
	{gaSNUMDATE+21,	8},
	{gaSNUMDATE+25,	10},
	{gaSNUMDATE+27,	11},
	{gaSNUMDATE+19,	103},
	{gaSNUMDATE+23,	104},
	{gaSNUMDATE+29,	105},
	{gaSNUMDATE+130,	106}, // +173: state 97 transitions
	{gaSNUMDATE+84,	107}, // +174: state 98 transitions
	{gaSNUMDATE+82,	108}, // +175: state 99 transitions
	{gaSNUMDATE+35,	1}, // +176: state 100 transitions
	{gaSNUMDATE+35,	15}, // +177: state 101 transitions
	{gaSNUMDATE+143,	89}, // +178: state 102 transitions
	{gaSNUMDATE+80,	26}, // +179: state 103 transitions
	{gaSNUMDATE+82,	27},
	{gaSNUMDATE+15,	33}, // +181: state 104 transitions
	{gaSNUMDATE+86,	34},
	{gaSNUMDATE+80,	40}, // +183: state 105 transitions
	{gaSNUMDATE+82,	42},
	{gaSNUMDATE+145,	79}, // +185: state 106 transitions
	{gaSNUMDATE+130,	56}, // +186: state 107 transitions
	{gaSNUMDATE+84,	56}, // +187: state 108 transitions
};

const STATE_DESCRIPTION aStateDescNUMDATE[109] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 14, gaTNUMDATE+0},
	/*   1 */ {0, 1, gaTNUMDATE+14},
	/*   2 */ {0, 2, gaTNUMDATE+15},
	/*   3 */ {0, 4, gaTNUMDATE+17},
	/*   4 */ {0, 3, gaTNUMDATE+21},
	/*   5 */ {0, 4, gaTNUMDATE+24},
	/*   6 */ {0, 2, gaTNUMDATE+28},
	/*   7 */ {0, 3, gaTNUMDATE+30},
	/*   8 */ {0, 4, gaTNUMDATE+33},
	/*   9 */ {0, 3, gaTNUMDATE+37},
	/*  10 */ {0, 2, gaTNUMDATE+40},
	/*  11 */ {0, 2, gaTNUMDATE+42},
	/*  12 */ {0, 4, gaTNUMDATE+44},
	/*  13 */ {0, 2, gaTNUMDATE+48},
	/*  14 */ {0, 1, gaTNUMDATE+50},
	/*  15 */ {0, 1, gaTNUMDATE+51},
	/*  16 */ {0, 1, gaTNUMDATE+52},
	/*  17 */ {0, 3, gaTNUMDATE+53},
	/*  18 */ {0, 4, gaTNUMDATE+56},
	/*  19 */ {0, 4, gaTNUMDATE+60},
	/*  20 */ {0, 1, gaTNUMDATE+64},
	/*  21 */ {0, 1, gaTNUMDATE+65},
	/*  22 */ {0, 1, gaTNUMDATE+66},
	/*  23 */ {0, 1, gaTNUMDATE+67},
	/*  24 */ {0, 1, gaTNUMDATE+68},
	/*  25 */ {0, 1, gaTNUMDATE+69},
	/*  26 */ {0, 1, gaTNUMDATE+70},
	/*  27 */ {0, 1, gaTNUMDATE+71},
	/*  28 */ {0, 1, gaTNUMDATE+72},
	/*  29 */ {0, 1, gaTNUMDATE+73},
	/*  30 */ {0, 1, gaTNUMDATE+74},
	/*  31 */ {0, 1, gaTNUMDATE+75},
	/*  32 */ {0, 2, gaTNUMDATE+76},
	/*  33 */ {0, 1, gaTNUMDATE+78},
	/*  34 */ {0, 2, gaTNUMDATE+79},
	/*  35 */ {0, 1, gaTNUMDATE+81},
	/*  36 */ {0, 1, gaTNUMDATE+82},
	/*  37 */ {0, 1, gaTNUMDATE+83},
	/*  38 */ {0, 1, gaTNUMDATE+84},
	/*  39 */ {0, 1, gaTNUMDATE+85},
	/*  40 */ {0, 1, gaTNUMDATE+86},
	/*  41 */ {0, 1, gaTNUMDATE+87},
	/*  42 */ {0, 1, gaTNUMDATE+88},
	/*  43 */ {0, 1, gaTNUMDATE+89},
	/*  44 */ {0, 1, gaTNUMDATE+90},
	/*  45 */ {0, 1, gaTNUMDATE+91},
	/*  46 */ {1, 0, NULL},
	/*  47 */ {0, 1, gaTNUMDATE+92},
	/*  48 */ {0, 1, gaTNUMDATE+93},
	/*  49 */ {0, 2, gaTNUMDATE+94},
	/*  50 */ {0, 2, gaTNUMDATE+96},
	/*  51 */ {0, 1, gaTNUMDATE+98},
	/*  52 */ {0, 1, gaTNUMDATE+99},
	/*  53 */ {1, 2, gaTNUMDATE+100},
	/*  54 */ {1, 2, gaTNUMDATE+102},
	/*  55 */ {1, 1, gaTNUMDATE+104},
	/*  56 */ {0, 1, gaTNUMDATE+105},
	/*  57 */ {0, 2, gaTNUMDATE+106},
	/*  58 */ {0, 2, gaTNUMDATE+108},
	/*  59 */ {0, 2, gaTNUMDATE+110},
	/*  60 */ {0, 2, gaTNUMDATE+112},
	/*  61 */ {0, 2, gaTNUMDATE+114},
	/*  62 */ {0, 2, gaTNUMDATE+116},
	/*  63 */ {0, 2, gaTNUMDATE+118},
	/*  64 */ {0, 2, gaTNUMDATE+120},
	/*  65 */ {0, 2, gaTNUMDATE+122},
	/*  66 */ {0, 2, gaTNUMDATE+124},
	/*  67 */ {0, 2, gaTNUMDATE+126},
	/*  68 */ {0, 2, gaTNUMDATE+128},
	/*  69 */ {0, 2, gaTNUMDATE+130},
	/*  70 */ {0, 2, gaTNUMDATE+132},
	/*  71 */ {0, 2, gaTNUMDATE+134},
	/*  72 */ {1, 1, gaTNUMDATE+136},
	/*  73 */ {0, 1, gaTNUMDATE+137},
	/*  74 */ {0, 4, gaTNUMDATE+138},
	/*  75 */ {0, 1, gaTNUMDATE+142},
	/*  76 */ {0, 1, gaTNUMDATE+143},
	/*  77 */ {0, 1, gaTNUMDATE+144},
	/*  78 */ {0, 1, gaTNUMDATE+145},
	/*  79 */ {0, 1, gaTNUMDATE+146},
	/*  80 */ {0, 1, gaTNUMDATE+147},
	/*  81 */ {0, 1, gaTNUMDATE+148},
	/*  82 */ {0, 1, gaTNUMDATE+149},
	/*  83 */ {0, 1, gaTNUMDATE+150},
	/*  84 */ {0, 1, gaTNUMDATE+151},
	/*  85 */ {0, 1, gaTNUMDATE+152},
	/*  86 */ {0, 1, gaTNUMDATE+153},
	/*  87 */ {0, 1, gaTNUMDATE+154},
	/*  88 */ {0, 1, gaTNUMDATE+155},
	/*  89 */ {0, 1, gaTNUMDATE+156},
	/*  90 */ {0, 1, gaTNUMDATE+157},
	/*  91 */ {0, 1, gaTNUMDATE+158},
	/*  92 */ {1, 2, gaTNUMDATE+159},
	/*  93 */ {1, 2, gaTNUMDATE+161},
	/*  94 */ {1, 1, gaTNUMDATE+163},
	/*  95 */ {0, 1, gaTNUMDATE+164},
	/*  96 */ {0, 8, gaTNUMDATE+165},
	/*  97 */ {0, 1, gaTNUMDATE+173},
	/*  98 */ {0, 1, gaTNUMDATE+174},
	/*  99 */ {0, 1, gaTNUMDATE+175},
	/* 100 */ {0, 1, gaTNUMDATE+176},
	/* 101 */ {1, 1, gaTNUMDATE+177},
	/* 102 */ {0, 1, gaTNUMDATE+178},
	/* 103 */ {0, 2, gaTNUMDATE+179},
	/* 104 */ {0, 2, gaTNUMDATE+181},
	/* 105 */ {0, 2, gaTNUMDATE+183},
	/* 106 */ {0, 1, gaTNUMDATE+185},
	/* 107 */ {0, 1, gaTNUMDATE+186},
	/* 108 */ {0, 1, gaTNUMDATE+187},
};

/**************** NUMTIME ***********************************/

// 23 states

static const unsigned char gaSNUMTIME[] = 
	/* gaStringNUMTIME+0 */	"0\000"
	/* gaStringNUMTIME+2 */	"1\000"
	/* gaStringNUMTIME+4 */	"2\000"
	/* gaStringNUMTIME+6 */	"345\000"
	/* gaStringNUMTIME+10 */	"6789\000"
	/* gaStringNUMTIME+15 */	"123456789\000"
	/* gaStringNUMTIME+25 */	":\000"
	/* gaStringNUMTIME+27 */	"012\000"
	/* gaStringNUMTIME+31 */	"3456789\000"
	/* gaStringNUMTIME+39 */	"0123\000"
	/* gaStringNUMTIME+44 */	"456789\000"
	/* gaStringNUMTIME+51 */	"0123456789\000"
	/* gaStringNUMTIME+62 */	"012345\000"
	/* gaStringNUMTIME+69 */	" \000"
	/* gaStringNUMTIME+71 */	"AP\000"
	/* gaStringNUMTIME+74 */	"ap\000"
	/* gaStringNUMTIME+77 */	"M\000"
	/* gaStringNUMTIME+79 */	"m\000"
;

static const STATE_TRANSITION gaTNUMTIME[] = {
	{gaSNUMTIME+0,	1}, // +0: state 0 transitions
	{gaSNUMTIME+2,	2},
	{gaSNUMTIME+4,	3},
	{gaSNUMTIME+6,	4},
	{gaSNUMTIME+10,	5},
	{gaSNUMTIME+15,	5}, // +5: state 1 transitions
	{gaSNUMTIME+0,	6},
	{gaSNUMTIME+25,	7},
	{gaSNUMTIME+27,	5}, // +8: state 2 transitions
	{gaSNUMTIME+31,	6},
	{gaSNUMTIME+25,	8},
	{gaSNUMTIME+39,	6}, // +11: state 3 transitions
	{gaSNUMTIME+25,	8},
	{gaSNUMTIME+44,	9},
	{gaSNUMTIME+25,	8}, // +14: state 4 transitions
	{gaSNUMTIME+51,	9},
	{gaSNUMTIME+25,	8}, // +16: state 5 transitions
	{gaSNUMTIME+25,	7}, // +17: state 6 transitions
	{gaSNUMTIME+62,	10}, // +18: state 7 transitions
	{gaSNUMTIME+62,	11}, // +19: state 8 transitions
	{gaSNUMTIME+25,	12}, // +20: state 9 transitions
	{gaSNUMTIME+51,	13}, // +21: state 10 transitions
	{gaSNUMTIME+51,	14}, // +22: state 11 transitions
	{gaSNUMTIME+62,	15}, // +23: state 12 transitions
	{gaSNUMTIME+25,	12}, // +24: state 13 transitions
	{gaSNUMTIME+69,	16}, // +25: state 14 transitions
	{gaSNUMTIME+25,	17},
	{gaSNUMTIME+51,	18}, // +27: state 15 transitions
	{gaSNUMTIME+71,	19}, // +28: state 16 transitions
	{gaSNUMTIME+74,	20},
	{gaSNUMTIME+62,	21}, // +30: state 17 transitions
	{gaSNUMTIME+77,	18}, // +31: state 19 transitions
	{gaSNUMTIME+79,	18}, // +32: state 20 transitions
	{gaSNUMTIME+51,	22}, // +33: state 21 transitions
	{gaSNUMTIME+69,	16}, // +34: state 22 transitions
};

const STATE_DESCRIPTION aStateDescNUMTIME[23] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 5, gaTNUMTIME+0},
	/*   1 */ {0, 3, gaTNUMTIME+5},
	/*   2 */ {0, 3, gaTNUMTIME+8},
	/*   3 */ {0, 3, gaTNUMTIME+11},
	/*   4 */ {0, 2, gaTNUMTIME+14},
	/*   5 */ {0, 1, gaTNUMTIME+16},
	/*   6 */ {0, 1, gaTNUMTIME+17},
	/*   7 */ {0, 1, gaTNUMTIME+18},
	/*   8 */ {0, 1, gaTNUMTIME+19},
	/*   9 */ {0, 1, gaTNUMTIME+20},
	/*  10 */ {0, 1, gaTNUMTIME+21},
	/*  11 */ {0, 1, gaTNUMTIME+22},
	/*  12 */ {0, 1, gaTNUMTIME+23},
	/*  13 */ {1, 1, gaTNUMTIME+24},
	/*  14 */ {1, 2, gaTNUMTIME+25},
	/*  15 */ {0, 1, gaTNUMTIME+27},
	/*  16 */ {0, 2, gaTNUMTIME+28},
	/*  17 */ {0, 1, gaTNUMTIME+30},
	/*  18 */ {1, 0, NULL},
	/*  19 */ {0, 1, gaTNUMTIME+31},
	/*  20 */ {0, 1, gaTNUMTIME+32},
	/*  21 */ {0, 1, gaTNUMTIME+33},
	/*  22 */ {1, 1, gaTNUMTIME+34},
};

/**************** NUMCURRENCY ***********************************/

// 17 states

static const unsigned char gaSNUMCURRENCY[] = 
	/* gaStringNUMCURRENCY+0 */	"$\000"
	/* gaStringNUMCURRENCY+5 */	"0123456789\000"
	/* gaStringNUMCURRENCY+16 */	".\000"
	/* gaStringNUMCURRENCY+18 */	"\000"
	/* gaStringNUMCURRENCY+20 */	"k\000"
	/* gaStringNUMCURRENCY+22 */	",\000"
;

static const STATE_TRANSITION gaTNUMCURRENCY[] = {
	{gaSNUMCURRENCY+0,	1}, // +0: state 0 transitions
	{gaSNUMCURRENCY+5,	2},
	{gaSNUMCURRENCY+16,	3}, // +2: state 1 transitions
	{gaSNUMCURRENCY+5,	4},
	{gaSNUMCURRENCY+5,	5}, // +4: state 2 transitions
	{gaSNUMCURRENCY+18,	6},
	{gaSNUMCURRENCY+5,	7}, // +6: state 3 transitions
	{gaSNUMCURRENCY+20,	6}, // +7: state 4 transitions
	{gaSNUMCURRENCY+22,	8},
	{gaSNUMCURRENCY+16,	9},
	{gaSNUMCURRENCY+5,	10},
	{gaSNUMCURRENCY+18,	6}, // +11: state 5 transitions
	{gaSNUMCURRENCY+5,	11}, // +12: state 7 transitions
	{gaSNUMCURRENCY+5,	12}, // +13: state 8 transitions
	{gaSNUMCURRENCY+20,	6}, // +14: state 9 transitions
	{gaSNUMCURRENCY+5,	7},
	{gaSNUMCURRENCY+20,	6}, // +16: state 10 transitions
	{gaSNUMCURRENCY+22,	8},
	{gaSNUMCURRENCY+16,	9},
	{gaSNUMCURRENCY+5,	13},
	{gaSNUMCURRENCY+20,	6}, // +20: state 11 transitions
	{gaSNUMCURRENCY+5,	14}, // +21: state 12 transitions
	{gaSNUMCURRENCY+20,	6}, // +22: state 13 transitions
	{gaSNUMCURRENCY+22,	8},
	{gaSNUMCURRENCY+16,	9},
	{gaSNUMCURRENCY+5,	15},
	{gaSNUMCURRENCY+5,	16}, // +26: state 14 transitions
	{gaSNUMCURRENCY+20,	6}, // +27: state 15 transitions
	{gaSNUMCURRENCY+16,	9},
	{gaSNUMCURRENCY+5,	15},
	{gaSNUMCURRENCY+20,	6}, // +30: state 16 transitions
	{gaSNUMCURRENCY+22,	8},
	{gaSNUMCURRENCY+16,	9},
};

const STATE_DESCRIPTION aStateDescNUMCURRENCY[17] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTNUMCURRENCY+0},
	/*   1 */ {0, 2, gaTNUMCURRENCY+2},
	/*   2 */ {0, 2, gaTNUMCURRENCY+4},
	/*   3 */ {0, 1, gaTNUMCURRENCY+6},
	/*   4 */ {1, 4, gaTNUMCURRENCY+7},
	/*   5 */ {0, 1, gaTNUMCURRENCY+11},
	/*   6 */ {1, 0, NULL},
	/*   7 */ {0, 1, gaTNUMCURRENCY+12},
	/*   8 */ {0, 1, gaTNUMCURRENCY+13},
	/*   9 */ {1, 2, gaTNUMCURRENCY+14},
	/*  10 */ {1, 4, gaTNUMCURRENCY+16},
	/*  11 */ {1, 1, gaTNUMCURRENCY+20},
	/*  12 */ {0, 1, gaTNUMCURRENCY+21},
	/*  13 */ {1, 4, gaTNUMCURRENCY+22},
	/*  14 */ {0, 1, gaTNUMCURRENCY+26},
	/*  15 */ {1, 3, gaTNUMCURRENCY+27},
	/*  16 */ {1, 3, gaTNUMCURRENCY+30},
};

/**************** NUMPHONE ***********************************/

// 26 states

static const unsigned char gaSNUMPHONE[] = 
	/* gaStringNUMPHONE+0 */	"(\000"
	/* gaStringNUMPHONE+2 */	"01\000"
	/* gaStringNUMPHONE+5 */	"23456789\000"
	/* gaStringNUMPHONE+14 */	"0123456789\000"
	/* gaStringNUMPHONE+25 */	"-\000"
	/* gaStringNUMPHONE+27 */	")\000"
;

static const STATE_TRANSITION gaTNUMPHONE[] = {
	{gaSNUMPHONE+0,	1}, // +0: state 0 transitions
	{gaSNUMPHONE+2,	2},
	{gaSNUMPHONE+5,	3},
	{gaSNUMPHONE+14,	23}, // +3: state 1 transitions
	{gaSNUMPHONE+14,	4}, // +4: state 2 transitions
	{gaSNUMPHONE+25,	15},
	{gaSNUMPHONE+14,	4}, // +6: state 3 transitions
	{gaSNUMPHONE+14,	5}, // +7: state 4 transitions
	{gaSNUMPHONE+25,	6}, // +8: state 5 transitions
	{gaSNUMPHONE+14,	7}, // +9: state 6 transitions
	{gaSNUMPHONE+14,	8}, // +10: state 7 transitions
	{gaSNUMPHONE+14,	9}, // +11: state 8 transitions
	{gaSNUMPHONE+25,	10}, // +12: state 9 transitions
	{gaSNUMPHONE+14,	11},
	{gaSNUMPHONE+14,	12}, // +14: state 10 transitions
	{gaSNUMPHONE+14,	13}, // +15: state 12 transitions
	{gaSNUMPHONE+14,	14}, // +16: state 13 transitions
	{gaSNUMPHONE+14,	11}, // +17: state 14 transitions
	{gaSNUMPHONE+14,	16}, // +18: state 15 transitions
	{gaSNUMPHONE+14,	17}, // +19: state 16 transitions
	{gaSNUMPHONE+14,	18}, // +20: state 17 transitions
	{gaSNUMPHONE+25,	19}, // +21: state 18 transitions
	{gaSNUMPHONE+14,	20}, // +22: state 19 transitions
	{gaSNUMPHONE+14,	21}, // +23: state 20 transitions
	{gaSNUMPHONE+14,	22}, // +24: state 21 transitions
	{gaSNUMPHONE+25,	10}, // +25: state 22 transitions
	{gaSNUMPHONE+14,	24}, // +26: state 23 transitions
	{gaSNUMPHONE+14,	25}, // +27: state 24 transitions
	{gaSNUMPHONE+27,	19}, // +28: state 25 transitions
};

const STATE_DESCRIPTION aStateDescNUMPHONE[26] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTNUMPHONE+0},
	/*   1 */ {0, 1, gaTNUMPHONE+3},
	/*   2 */ {0, 2, gaTNUMPHONE+4},
	/*   3 */ {0, 1, gaTNUMPHONE+6},
	/*   4 */ {0, 1, gaTNUMPHONE+7},
	/*   5 */ {0, 1, gaTNUMPHONE+8},
	/*   6 */ {0, 1, gaTNUMPHONE+9},
	/*   7 */ {0, 1, gaTNUMPHONE+10},
	/*   8 */ {0, 1, gaTNUMPHONE+11},
	/*   9 */ {0, 2, gaTNUMPHONE+12},
	/*  10 */ {0, 1, gaTNUMPHONE+14},
	/*  11 */ {1, 0, NULL},
	/*  12 */ {0, 1, gaTNUMPHONE+15},
	/*  13 */ {0, 1, gaTNUMPHONE+16},
	/*  14 */ {0, 1, gaTNUMPHONE+17},
	/*  15 */ {0, 1, gaTNUMPHONE+18},
	/*  16 */ {0, 1, gaTNUMPHONE+19},
	/*  17 */ {0, 1, gaTNUMPHONE+20},
	/*  18 */ {0, 1, gaTNUMPHONE+21},
	/*  19 */ {0, 1, gaTNUMPHONE+22},
	/*  20 */ {0, 1, gaTNUMPHONE+23},
	/*  21 */ {0, 1, gaTNUMPHONE+24},
	/*  22 */ {0, 1, gaTNUMPHONE+25},
	/*  23 */ {0, 1, gaTNUMPHONE+26},
	/*  24 */ {0, 1, gaTNUMPHONE+27},
	/*  25 */ {0, 1, gaTNUMPHONE+28},
};

/**************** NUMMATH ***********************************/

// 148 states

static const unsigned char gaSNUMMATH[] = 
	/* gaStringNUMMATH+0 */	"(\000"
	/* gaStringNUMMATH+2 */	"+-\000"
	/* gaStringNUMMATH+5 */	".\000"
	/* gaStringNUMMATH+7 */	"0123456789\000"
	/* gaStringNUMMATH+18 */	"*+-/\000"
	/* gaStringNUMMATH+23 */	",\000"
	/* gaStringNUMMATH+25 */	"<=>\000"
	/* gaStringNUMMATH+29 */	")\000"
;

static const STATE_TRANSITION gaTNUMMATH[] = {
	{gaSNUMMATH+0,	1}, // +0: state 0 transitions
	{gaSNUMMATH+2,	2},
	{gaSNUMMATH+5,	3},
	{gaSNUMMATH+7,	4},
	{gaSNUMMATH+2,	124}, // +4: state 1 transitions
	{gaSNUMMATH+5,	125},
	{gaSNUMMATH+7,	126},
	{gaSNUMMATH+5,	3}, // +7: state 2 transitions
	{gaSNUMMATH+7,	4},
	{gaSNUMMATH+7,	123}, // +9: state 3 transitions
	{gaSNUMMATH+5,	3}, // +10: state 4 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+7,	7},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+0,	87}, // +15: state 5 transitions
	{gaSNUMMATH+2,	88},
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+7,	90},
	{gaSNUMMATH+7,	84}, // +19: state 6 transitions
	{gaSNUMMATH+5,	3}, // +20: state 7 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	82},
	{gaSNUMMATH+0,	9}, // +25: state 8 transitions
	{gaSNUMMATH+2,	10},
	{gaSNUMMATH+5,	11},
	{gaSNUMMATH+7,	12},
	{gaSNUMMATH+2,	58}, // +29: state 9 transitions
	{gaSNUMMATH+5,	59},
	{gaSNUMMATH+7,	60},
	{gaSNUMMATH+5,	11}, // +32: state 10 transitions
	{gaSNUMMATH+7,	12},
	{gaSNUMMATH+7,	57}, // +34: state 11 transitions
	{gaSNUMMATH+5,	11}, // +35: state 12 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+7,	15},
	{gaSNUMMATH+0,	21}, // +39: state 13 transitions
	{gaSNUMMATH+2,	22},
	{gaSNUMMATH+5,	23},
	{gaSNUMMATH+7,	24},
	{gaSNUMMATH+7,	18}, // +43: state 14 transitions
	{gaSNUMMATH+5,	11}, // +44: state 15 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+7,	16},
	{gaSNUMMATH+5,	11}, // +48: state 16 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+7,	17},
	{gaSNUMMATH+5,	11}, // +52: state 17 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+7,	17},
	{gaSNUMMATH+7,	19}, // +55: state 18 transitions
	{gaSNUMMATH+7,	20}, // +56: state 19 transitions
	{gaSNUMMATH+5,	11}, // +57: state 20 transitions
	{gaSNUMMATH+18,	13},
	{gaSNUMMATH+23,	14},
	{gaSNUMMATH+2,	33}, // +60: state 21 transitions
	{gaSNUMMATH+5,	34},
	{gaSNUMMATH+7,	35},
	{gaSNUMMATH+5,	23}, // +63: state 22 transitions
	{gaSNUMMATH+7,	24},
	{gaSNUMMATH+7,	32}, // +65: state 23 transitions
	{gaSNUMMATH+5,	23}, // +66: state 24 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	26},
	{gaSNUMMATH+7,	29}, // +69: state 25 transitions
	{gaSNUMMATH+5,	23}, // +70: state 26 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	27},
	{gaSNUMMATH+5,	23}, // +73: state 27 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	28},
	{gaSNUMMATH+5,	23}, // +76: state 28 transitions
	{gaSNUMMATH+7,	28},
	{gaSNUMMATH+7,	30}, // +78: state 29 transitions
	{gaSNUMMATH+7,	31}, // +79: state 30 transitions
	{gaSNUMMATH+5,	23}, // +80: state 31 transitions
	{gaSNUMMATH+23,	25},
	{gaSNUMMATH+7,	32}, // +82: state 32 transitions
	{gaSNUMMATH+5,	34}, // +83: state 33 transitions
	{gaSNUMMATH+7,	35},
	{gaSNUMMATH+7,	56}, // +85: state 34 transitions
	{gaSNUMMATH+5,	34}, // +86: state 35 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+7,	38},
	{gaSNUMMATH+2,	44}, // +90: state 36 transitions
	{gaSNUMMATH+5,	45},
	{gaSNUMMATH+7,	46},
	{gaSNUMMATH+7,	41}, // +93: state 37 transitions
	{gaSNUMMATH+5,	34}, // +94: state 38 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+7,	39},
	{gaSNUMMATH+5,	34}, // +98: state 39 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+7,	40},
	{gaSNUMMATH+5,	34}, // +102: state 40 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+7,	40},
	{gaSNUMMATH+7,	42}, // +105: state 41 transitions
	{gaSNUMMATH+7,	43}, // +106: state 42 transitions
	{gaSNUMMATH+5,	34}, // +107: state 43 transitions
	{gaSNUMMATH+18,	36},
	{gaSNUMMATH+23,	37},
	{gaSNUMMATH+5,	45}, // +110: state 44 transitions
	{gaSNUMMATH+7,	46},
	{gaSNUMMATH+7,	55}, // +112: state 45 transitions
	{gaSNUMMATH+5,	45}, // +113: state 46 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+7,	49},
	{gaSNUMMATH+7,	52}, // +117: state 48 transitions
	{gaSNUMMATH+5,	45}, // +118: state 49 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+7,	50},
	{gaSNUMMATH+5,	45}, // +122: state 50 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+7,	51},
	{gaSNUMMATH+5,	45}, // +126: state 51 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+7,	51},
	{gaSNUMMATH+7,	53}, // +129: state 52 transitions
	{gaSNUMMATH+7,	54}, // +130: state 53 transitions
	{gaSNUMMATH+5,	45}, // +131: state 54 transitions
	{gaSNUMMATH+29,	47},
	{gaSNUMMATH+23,	48},
	{gaSNUMMATH+29,	47}, // +134: state 55 transitions
	{gaSNUMMATH+7,	55},
	{gaSNUMMATH+18,	36}, // +136: state 56 transitions
	{gaSNUMMATH+7,	56},
	{gaSNUMMATH+18,	13}, // +138: state 57 transitions
	{gaSNUMMATH+7,	57},
	{gaSNUMMATH+5,	59}, // +140: state 58 transitions
	{gaSNUMMATH+7,	60},
	{gaSNUMMATH+7,	81}, // +142: state 59 transitions
	{gaSNUMMATH+5,	59}, // +143: state 60 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+7,	63},
	{gaSNUMMATH+2,	69}, // +147: state 61 transitions
	{gaSNUMMATH+5,	70},
	{gaSNUMMATH+7,	71},
	{gaSNUMMATH+7,	66}, // +150: state 62 transitions
	{gaSNUMMATH+5,	59}, // +151: state 63 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+7,	64},
	{gaSNUMMATH+5,	59}, // +155: state 64 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+7,	65},
	{gaSNUMMATH+5,	59}, // +159: state 65 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+7,	65},
	{gaSNUMMATH+7,	67}, // +162: state 66 transitions
	{gaSNUMMATH+7,	68}, // +163: state 67 transitions
	{gaSNUMMATH+5,	59}, // +164: state 68 transitions
	{gaSNUMMATH+18,	61},
	{gaSNUMMATH+23,	62},
	{gaSNUMMATH+5,	70}, // +167: state 69 transitions
	{gaSNUMMATH+7,	71},
	{gaSNUMMATH+7,	80}, // +169: state 70 transitions
	{gaSNUMMATH+5,	70}, // +170: state 71 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+7,	74},
	{gaSNUMMATH+18,	13}, // +174: state 72 transitions
	{gaSNUMMATH+7,	77}, // +175: state 73 transitions
	{gaSNUMMATH+5,	70}, // +176: state 74 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+7,	75},
	{gaSNUMMATH+5,	70}, // +180: state 75 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+7,	76},
	{gaSNUMMATH+5,	70}, // +184: state 76 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+7,	76},
	{gaSNUMMATH+7,	78}, // +187: state 77 transitions
	{gaSNUMMATH+7,	79}, // +188: state 78 transitions
	{gaSNUMMATH+5,	70}, // +189: state 79 transitions
	{gaSNUMMATH+29,	72},
	{gaSNUMMATH+23,	73},
	{gaSNUMMATH+29,	72}, // +192: state 80 transitions
	{gaSNUMMATH+7,	80},
	{gaSNUMMATH+18,	61}, // +194: state 81 transitions
	{gaSNUMMATH+7,	81},
	{gaSNUMMATH+5,	3}, // +196: state 82 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	83},
	{gaSNUMMATH+5,	3}, // +201: state 83 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	83},
	{gaSNUMMATH+7,	85}, // +205: state 84 transitions
	{gaSNUMMATH+7,	86}, // +206: state 85 transitions
	{gaSNUMMATH+5,	3}, // +207: state 86 transitions
	{gaSNUMMATH+18,	5},
	{gaSNUMMATH+23,	6},
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+2,	99}, // +211: state 87 transitions
	{gaSNUMMATH+5,	100},
	{gaSNUMMATH+7,	101},
	{gaSNUMMATH+5,	89}, // +214: state 88 transitions
	{gaSNUMMATH+7,	90},
	{gaSNUMMATH+7,	98}, // +216: state 89 transitions
	{gaSNUMMATH+25,	8}, // +217: state 90 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+7,	92},
	{gaSNUMMATH+7,	95}, // +221: state 91 transitions
	{gaSNUMMATH+25,	8}, // +222: state 92 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+7,	93},
	{gaSNUMMATH+25,	8}, // +226: state 93 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+7,	94},
	{gaSNUMMATH+25,	8}, // +230: state 94 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+7,	94},
	{gaSNUMMATH+7,	96}, // +233: state 95 transitions
	{gaSNUMMATH+7,	97}, // +234: state 96 transitions
	{gaSNUMMATH+25,	8}, // +235: state 97 transitions
	{gaSNUMMATH+5,	89},
	{gaSNUMMATH+23,	91},
	{gaSNUMMATH+25,	8}, // +238: state 98 transitions
	{gaSNUMMATH+7,	98},
	{gaSNUMMATH+5,	100}, // +240: state 99 transitions
	{gaSNUMMATH+7,	101},
	{gaSNUMMATH+7,	122}, // +242: state 100 transitions
	{gaSNUMMATH+5,	100}, // +243: state 101 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+7,	104},
	{gaSNUMMATH+2,	110}, // +247: state 102 transitions
	{gaSNUMMATH+5,	111},
	{gaSNUMMATH+7,	112},
	{gaSNUMMATH+7,	107}, // +250: state 103 transitions
	{gaSNUMMATH+5,	100}, // +251: state 104 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+7,	105},
	{gaSNUMMATH+5,	100}, // +255: state 105 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+7,	106},
	{gaSNUMMATH+5,	100}, // +259: state 106 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+7,	106},
	{gaSNUMMATH+7,	108}, // +262: state 107 transitions
	{gaSNUMMATH+7,	109}, // +263: state 108 transitions
	{gaSNUMMATH+5,	100}, // +264: state 109 transitions
	{gaSNUMMATH+18,	102},
	{gaSNUMMATH+23,	103},
	{gaSNUMMATH+5,	111}, // +267: state 110 transitions
	{gaSNUMMATH+7,	112},
	{gaSNUMMATH+7,	121}, // +269: state 111 transitions
	{gaSNUMMATH+5,	111}, // +270: state 112 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+7,	115},
	{gaSNUMMATH+25,	8}, // +274: state 113 transitions
	{gaSNUMMATH+7,	118}, // +275: state 114 transitions
	{gaSNUMMATH+5,	111}, // +276: state 115 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+7,	116},
	{gaSNUMMATH+5,	111}, // +280: state 116 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+7,	117},
	{gaSNUMMATH+5,	111}, // +284: state 117 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+7,	117},
	{gaSNUMMATH+7,	119}, // +287: state 118 transitions
	{gaSNUMMATH+7,	120}, // +288: state 119 transitions
	{gaSNUMMATH+5,	111}, // +289: state 120 transitions
	{gaSNUMMATH+29,	113},
	{gaSNUMMATH+23,	114},
	{gaSNUMMATH+29,	113}, // +292: state 121 transitions
	{gaSNUMMATH+7,	121},
	{gaSNUMMATH+18,	102}, // +294: state 122 transitions
	{gaSNUMMATH+7,	122},
	{gaSNUMMATH+18,	5}, // +296: state 123 transitions
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	123},
	{gaSNUMMATH+5,	125}, // +299: state 124 transitions
	{gaSNUMMATH+7,	126},
	{gaSNUMMATH+7,	147}, // +301: state 125 transitions
	{gaSNUMMATH+5,	125}, // +302: state 126 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+7,	129},
	{gaSNUMMATH+2,	135}, // +306: state 127 transitions
	{gaSNUMMATH+5,	136},
	{gaSNUMMATH+7,	137},
	{gaSNUMMATH+7,	132}, // +309: state 128 transitions
	{gaSNUMMATH+5,	125}, // +310: state 129 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+7,	130},
	{gaSNUMMATH+5,	125}, // +314: state 130 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+7,	131},
	{gaSNUMMATH+5,	125}, // +318: state 131 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+7,	131},
	{gaSNUMMATH+7,	133}, // +321: state 132 transitions
	{gaSNUMMATH+7,	134}, // +322: state 133 transitions
	{gaSNUMMATH+5,	125}, // +323: state 134 transitions
	{gaSNUMMATH+18,	127},
	{gaSNUMMATH+23,	128},
	{gaSNUMMATH+5,	136}, // +326: state 135 transitions
	{gaSNUMMATH+7,	137},
	{gaSNUMMATH+7,	146}, // +328: state 136 transitions
	{gaSNUMMATH+5,	136}, // +329: state 137 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+7,	140},
	{gaSNUMMATH+18,	5}, // +333: state 138 transitions
	{gaSNUMMATH+25,	8},
	{gaSNUMMATH+7,	143}, // +335: state 139 transitions
	{gaSNUMMATH+5,	136}, // +336: state 140 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+7,	141},
	{gaSNUMMATH+5,	136}, // +340: state 141 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+7,	142},
	{gaSNUMMATH+5,	136}, // +344: state 142 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+7,	142},
	{gaSNUMMATH+7,	144}, // +347: state 143 transitions
	{gaSNUMMATH+7,	145}, // +348: state 144 transitions
	{gaSNUMMATH+5,	136}, // +349: state 145 transitions
	{gaSNUMMATH+29,	138},
	{gaSNUMMATH+23,	139},
	{gaSNUMMATH+29,	138}, // +352: state 146 transitions
	{gaSNUMMATH+7,	146},
	{gaSNUMMATH+18,	127}, // +354: state 147 transitions
	{gaSNUMMATH+7,	147},
};

const STATE_DESCRIPTION aStateDescNUMMATH[148] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 4, gaTNUMMATH+0},
	/*   1 */ {0, 3, gaTNUMMATH+4},
	/*   2 */ {0, 2, gaTNUMMATH+7},
	/*   3 */ {0, 1, gaTNUMMATH+9},
	/*   4 */ {1, 5, gaTNUMMATH+10},
	/*   5 */ {0, 4, gaTNUMMATH+15},
	/*   6 */ {0, 1, gaTNUMMATH+19},
	/*   7 */ {1, 5, gaTNUMMATH+20},
	/*   8 */ {0, 4, gaTNUMMATH+25},
	/*   9 */ {0, 3, gaTNUMMATH+29},
	/*  10 */ {0, 2, gaTNUMMATH+32},
	/*  11 */ {0, 1, gaTNUMMATH+34},
	/*  12 */ {1, 4, gaTNUMMATH+35},
	/*  13 */ {0, 4, gaTNUMMATH+39},
	/*  14 */ {0, 1, gaTNUMMATH+43},
	/*  15 */ {1, 4, gaTNUMMATH+44},
	/*  16 */ {1, 4, gaTNUMMATH+48},
	/*  17 */ {1, 3, gaTNUMMATH+52},
	/*  18 */ {0, 1, gaTNUMMATH+55},
	/*  19 */ {0, 1, gaTNUMMATH+56},
	/*  20 */ {1, 3, gaTNUMMATH+57},
	/*  21 */ {0, 3, gaTNUMMATH+60},
	/*  22 */ {0, 2, gaTNUMMATH+63},
	/*  23 */ {0, 1, gaTNUMMATH+65},
	/*  24 */ {1, 3, gaTNUMMATH+66},
	/*  25 */ {0, 1, gaTNUMMATH+69},
	/*  26 */ {1, 3, gaTNUMMATH+70},
	/*  27 */ {1, 3, gaTNUMMATH+73},
	/*  28 */ {1, 2, gaTNUMMATH+76},
	/*  29 */ {0, 1, gaTNUMMATH+78},
	/*  30 */ {0, 1, gaTNUMMATH+79},
	/*  31 */ {1, 2, gaTNUMMATH+80},
	/*  32 */ {1, 1, gaTNUMMATH+82},
	/*  33 */ {0, 2, gaTNUMMATH+83},
	/*  34 */ {0, 1, gaTNUMMATH+85},
	/*  35 */ {0, 4, gaTNUMMATH+86},
	/*  36 */ {0, 3, gaTNUMMATH+90},
	/*  37 */ {0, 1, gaTNUMMATH+93},
	/*  38 */ {0, 4, gaTNUMMATH+94},
	/*  39 */ {0, 4, gaTNUMMATH+98},
	/*  40 */ {0, 3, gaTNUMMATH+102},
	/*  41 */ {0, 1, gaTNUMMATH+105},
	/*  42 */ {0, 1, gaTNUMMATH+106},
	/*  43 */ {0, 3, gaTNUMMATH+107},
	/*  44 */ {0, 2, gaTNUMMATH+110},
	/*  45 */ {0, 1, gaTNUMMATH+112},
	/*  46 */ {0, 4, gaTNUMMATH+113},
	/*  47 */ {1, 0, NULL},
	/*  48 */ {0, 1, gaTNUMMATH+117},
	/*  49 */ {0, 4, gaTNUMMATH+118},
	/*  50 */ {0, 4, gaTNUMMATH+122},
	/*  51 */ {0, 3, gaTNUMMATH+126},
	/*  52 */ {0, 1, gaTNUMMATH+129},
	/*  53 */ {0, 1, gaTNUMMATH+130},
	/*  54 */ {0, 3, gaTNUMMATH+131},
	/*  55 */ {0, 2, gaTNUMMATH+134},
	/*  56 */ {0, 2, gaTNUMMATH+136},
	/*  57 */ {1, 2, gaTNUMMATH+138},
	/*  58 */ {0, 2, gaTNUMMATH+140},
	/*  59 */ {0, 1, gaTNUMMATH+142},
	/*  60 */ {0, 4, gaTNUMMATH+143},
	/*  61 */ {0, 3, gaTNUMMATH+147},
	/*  62 */ {0, 1, gaTNUMMATH+150},
	/*  63 */ {0, 4, gaTNUMMATH+151},
	/*  64 */ {0, 4, gaTNUMMATH+155},
	/*  65 */ {0, 3, gaTNUMMATH+159},
	/*  66 */ {0, 1, gaTNUMMATH+162},
	/*  67 */ {0, 1, gaTNUMMATH+163},
	/*  68 */ {0, 3, gaTNUMMATH+164},
	/*  69 */ {0, 2, gaTNUMMATH+167},
	/*  70 */ {0, 1, gaTNUMMATH+169},
	/*  71 */ {0, 4, gaTNUMMATH+170},
	/*  72 */ {1, 1, gaTNUMMATH+174},
	/*  73 */ {0, 1, gaTNUMMATH+175},
	/*  74 */ {0, 4, gaTNUMMATH+176},
	/*  75 */ {0, 4, gaTNUMMATH+180},
	/*  76 */ {0, 3, gaTNUMMATH+184},
	/*  77 */ {0, 1, gaTNUMMATH+187},
	/*  78 */ {0, 1, gaTNUMMATH+188},
	/*  79 */ {0, 3, gaTNUMMATH+189},
	/*  80 */ {0, 2, gaTNUMMATH+192},
	/*  81 */ {0, 2, gaTNUMMATH+194},
	/*  82 */ {1, 5, gaTNUMMATH+196},
	/*  83 */ {1, 4, gaTNUMMATH+201},
	/*  84 */ {0, 1, gaTNUMMATH+205},
	/*  85 */ {0, 1, gaTNUMMATH+206},
	/*  86 */ {1, 4, gaTNUMMATH+207},
	/*  87 */ {0, 3, gaTNUMMATH+211},
	/*  88 */ {0, 2, gaTNUMMATH+214},
	/*  89 */ {0, 1, gaTNUMMATH+216},
	/*  90 */ {1, 4, gaTNUMMATH+217},
	/*  91 */ {0, 1, gaTNUMMATH+221},
	/*  92 */ {1, 4, gaTNUMMATH+222},
	/*  93 */ {1, 4, gaTNUMMATH+226},
	/*  94 */ {1, 3, gaTNUMMATH+230},
	/*  95 */ {0, 1, gaTNUMMATH+233},
	/*  96 */ {0, 1, gaTNUMMATH+234},
	/*  97 */ {1, 3, gaTNUMMATH+235},
	/*  98 */ {1, 2, gaTNUMMATH+238},
	/*  99 */ {0, 2, gaTNUMMATH+240},
	/* 100 */ {0, 1, gaTNUMMATH+242},
	/* 101 */ {0, 4, gaTNUMMATH+243},
	/* 102 */ {0, 3, gaTNUMMATH+247},
	/* 103 */ {0, 1, gaTNUMMATH+250},
	/* 104 */ {0, 4, gaTNUMMATH+251},
	/* 105 */ {0, 4, gaTNUMMATH+255},
	/* 106 */ {0, 3, gaTNUMMATH+259},
	/* 107 */ {0, 1, gaTNUMMATH+262},
	/* 108 */ {0, 1, gaTNUMMATH+263},
	/* 109 */ {0, 3, gaTNUMMATH+264},
	/* 110 */ {0, 2, gaTNUMMATH+267},
	/* 111 */ {0, 1, gaTNUMMATH+269},
	/* 112 */ {0, 4, gaTNUMMATH+270},
	/* 113 */ {1, 1, gaTNUMMATH+274},
	/* 114 */ {0, 1, gaTNUMMATH+275},
	/* 115 */ {0, 4, gaTNUMMATH+276},
	/* 116 */ {0, 4, gaTNUMMATH+280},
	/* 117 */ {0, 3, gaTNUMMATH+284},
	/* 118 */ {0, 1, gaTNUMMATH+287},
	/* 119 */ {0, 1, gaTNUMMATH+288},
	/* 120 */ {0, 3, gaTNUMMATH+289},
	/* 121 */ {0, 2, gaTNUMMATH+292},
	/* 122 */ {0, 2, gaTNUMMATH+294},
	/* 123 */ {1, 3, gaTNUMMATH+296},
	/* 124 */ {0, 2, gaTNUMMATH+299},
	/* 125 */ {0, 1, gaTNUMMATH+301},
	/* 126 */ {0, 4, gaTNUMMATH+302},
	/* 127 */ {0, 3, gaTNUMMATH+306},
	/* 128 */ {0, 1, gaTNUMMATH+309},
	/* 129 */ {0, 4, gaTNUMMATH+310},
	/* 130 */ {0, 4, gaTNUMMATH+314},
	/* 131 */ {0, 3, gaTNUMMATH+318},
	/* 132 */ {0, 1, gaTNUMMATH+321},
	/* 133 */ {0, 1, gaTNUMMATH+322},
	/* 134 */ {0, 3, gaTNUMMATH+323},
	/* 135 */ {0, 2, gaTNUMMATH+326},
	/* 136 */ {0, 1, gaTNUMMATH+328},
	/* 137 */ {0, 4, gaTNUMMATH+329},
	/* 138 */ {1, 2, gaTNUMMATH+333},
	/* 139 */ {0, 1, gaTNUMMATH+335},
	/* 140 */ {0, 4, gaTNUMMATH+336},
	/* 141 */ {0, 4, gaTNUMMATH+340},
	/* 142 */ {0, 3, gaTNUMMATH+344},
	/* 143 */ {0, 1, gaTNUMMATH+347},
	/* 144 */ {0, 1, gaTNUMMATH+348},
	/* 145 */ {0, 3, gaTNUMMATH+349},
	/* 146 */ {0, 2, gaTNUMMATH+352},
	/* 147 */ {0, 2, gaTNUMMATH+354},
};

/**************** ZIP ***********************************/

// 11 states

static const unsigned char gaSZIP[] = "0123456789";

static const STATE_TRANSITION gaTZIP[] = {
	{gaSZIP,	1}, // +0: state 0 transitions
	{gaSZIP,	2}, // +1: state 1 transitions
	{gaSZIP,	3}, // +2: state 2 transitions
	{gaSZIP,	4}, // +3: state 3 transitions
	{gaSZIP,	5}, // +4: state 4 transitions
	{"-",		6}, // +5: state 5 transitions
	{gaSZIP,	7}, // +6: state 6 transitions
	{gaSZIP,	8}, // +7: state 7 transitions
	{gaSZIP,	9}, // +8: state 8 transitions
	{gaSZIP,	10}, // +9: state 9 transitions
};

const STATE_DESCRIPTION aStateDescZIP[11] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTZIP+0},
	/*   1 */ {0, 1, gaTZIP+1},
	/*   2 */ {0, 1, gaTZIP+2},
	/*   3 */ {0, 1, gaTZIP+3},
	/*   4 */ {0, 1, gaTZIP+4},
	/*   5 */ {1, 1, gaTZIP+5},
	/*   6 */ {0, 1, gaTZIP+6},
	/*   7 */ {0, 1, gaTZIP+7},
	/*   8 */ {0, 1, gaTZIP+8},
	/*   9 */ {0, 1, gaTZIP+9},
	/*  10 */ {1, 0, NULL},
};

/**************** CREDITCARD ***********************************/

// 18 states (16 or 17 digits)

static const unsigned char gaSCREDITCARD[] = "0123456789";

static const STATE_TRANSITION gaTCREDITCARD[] = {
	{gaSCREDITCARD+0,	1}, // +0: state 0 transitions
	{gaSCREDITCARD+0,	2}, // +1: state 1 transitions
	{gaSCREDITCARD+0,	3}, // +2: state 2 transitions
	{gaSCREDITCARD+0,	4}, // +3: state 3 transitions
	{gaSCREDITCARD+0,	5}, // +4: state 4 transitions
	{gaSCREDITCARD+0,	6}, // +5: state 5 transitions
	{gaSCREDITCARD+0,	7}, // +6: state 6 transitions
	{gaSCREDITCARD+0,	8}, // +7: state 7 transitions
	{gaSCREDITCARD+0,	9}, // +8: state 8 transitions
	{gaSCREDITCARD+0,	10}, // +9: state 9 transitions
	{gaSCREDITCARD+0,	11}, // +10: state 10 transitions
	{gaSCREDITCARD+0,	12}, // +11: state 11 transitions
	{gaSCREDITCARD+0,	13}, // +12: state 12 transitions
	{gaSCREDITCARD+0,	14}, // +13: state 13 transitions
	{gaSCREDITCARD+0,	15}, // +14: state 14 transitions
	{gaSCREDITCARD+0,	16}, // +15: state 15 transitions
	{gaSCREDITCARD+0,	17}, // +16: state 16 transitions
};

const STATE_DESCRIPTION aStateDescCREDITCARD[18] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTCREDITCARD+0},
	/*   1 */ {0, 1, gaTCREDITCARD+1},
	/*   2 */ {0, 1, gaTCREDITCARD+2},
	/*   3 */ {0, 1, gaTCREDITCARD+3},
	/*   4 */ {0, 1, gaTCREDITCARD+4},
	/*   5 */ {0, 1, gaTCREDITCARD+5},
	/*   6 */ {0, 1, gaTCREDITCARD+6},
	/*   7 */ {0, 1, gaTCREDITCARD+7},
	/*   8 */ {0, 1, gaTCREDITCARD+8},
	/*   9 */ {0, 1, gaTCREDITCARD+9},
	/*  10 */ {0, 1, gaTCREDITCARD+10},
	/*  11 */ {0, 1, gaTCREDITCARD+11},
	/*  12 */ {0, 1, gaTCREDITCARD+12},
	/*  13 */ {0, 1, gaTCREDITCARD+13},
	/*  14 */ {0, 1, gaTCREDITCARD+14},
	/*  15 */ {0, 1, gaTCREDITCARD+15},
	/*  16 */ {1, 1, gaTCREDITCARD+16},
	/*  17 */ {1, 0, NULL},
};

/**************** DAYOFMONTH ***********************************/

// dayofmonth = "123456789" | "12" digit | "3" "01"
// digit = "0123456789"
// = dayofmonth

// 4 states

static const STATE_TRANSITION gaTDAYOFMONTH[] = {
	{"12",	1}, // +0: state 0 transitions
	{"3",	2},
	{"456789",	3},
	{"0123456789",	3}, // +3: state 1 transitions
	{"01",	3}, // +4: state 2 transitions
};

const STATE_DESCRIPTION aStateDescDAYOFMONTH[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTDAYOFMONTH+0},
	/*   1 */ {1, 1, gaTDAYOFMONTH+3},
	/*   2 */ {1, 1, gaTDAYOFMONTH+4},
	/*   3 */ {1, 0, NULL},
};

/**************** MONTHNUM ***********************************/

// 3 states

static const STATE_TRANSITION gaTMONTHNUM[] = {
	{"1",	1}, // +0: state 0 transitions
	{"23456789",	2},
	{"012",	2}, // +2: state 1 transitions
};

const STATE_DESCRIPTION aStateDescMONTHNUM[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTMONTHNUM+0},
	/*   1 */ {1, 1, gaTMONTHNUM+2},
	/*   2 */ {1, 0, NULL},
};

/**************** YEAR ***********************************/

// 5 states

static const unsigned char gaSYEAR[] = "0123456789";

static const STATE_TRANSITION gaTYEAR[] = {
	{gaSYEAR,	1}, // +0: state 0 transitions
	{gaSYEAR,	2}, // +1: state 1 transitions
	{gaSYEAR,	3}, // +2: state 2 transitions
	{gaSYEAR,	4}, // +3: state 3 transitions
};

const STATE_DESCRIPTION aStateDescYEAR[5] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTYEAR+0},
	/*   1 */ {0, 1, gaTYEAR+1},
	/*   2 */ {1, 1, gaTYEAR+2},
	/*   3 */ {0, 1, gaTYEAR+3},
	/*   4 */ {1, 0, NULL},
};

/**************** SECOND ***********************************/

// 3 states

static const STATE_TRANSITION gaTSECOND[] = {
	{"06789",	1}, // +0: state 0 transitions
	{"12345",	2},
	{"0123456789",	1}, // +2: state 2 transitions
};

const STATE_DESCRIPTION aStateDescSECOND[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTSECOND+0},
	/*   1 */ {1, 0, NULL},
	/*   2 */ {1, 1, gaTSECOND+2},
};

/**************** MINUTE ***********************************/
// same as second
// 3 states

static const STATE_TRANSITION gaTMINUTE[] = {
	{"06789",	1}, // +0: state 0 transitions
	{"12345",	2},
	{"0123456789",	1}, // +2: state 2 transitions
};

const STATE_DESCRIPTION aStateDescMINUTE[3] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 2, gaTMINUTE+0},
	/*   1 */ {1, 0, NULL},
	/*   2 */ {1, 1, gaTMINUTE+2},
};

/**************** HOUR ***********************************/
// 0 through 23

// 4 states

static const STATE_TRANSITION gaTHOUR[] = {
	{"03456789",	1}, // +0: state 0 transitions
	{"1",	2},
	{"2",	3},
	{"0123456789",	1}, // +3: state 2 transitions
	{"0123",	1}, // +4: state 3 transitions
};

const STATE_DESCRIPTION aStateDescHOUR[4] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 3, gaTHOUR+0},
	/*   1 */ {1, 0, NULL},
	/*   2 */ {1, 1, gaTHOUR+3},
	/*   3 */ {1, 1, gaTHOUR+4},
};

/**************** SSN ***********************************/
// text generated by re2fsa at Tue Feb 06 17:23:44 2001

// the input-file of rules:
// digit = "0123456789"
// 
// ssn = digit digit digit ["-"] digit digit ["-"] digit digit digit digit
// 
// = ssn

// 12 states

static const unsigned char gaSSSN[] = 
	/* gaStringSSN+0 */	"0123456789\000"
	/* gaStringSSN+11 */	"-\000"
;

static const STATE_TRANSITION gaTSSN[] = {
	{gaSSSN+0,	1}, // +0: state 0 transitions
	{gaSSSN+0,	2}, // +1: state 1 transitions
	{gaSSSN+0,	3}, // +2: state 2 transitions
	{gaSSSN+11,	4}, // +3: state 3 transitions
	{gaSSSN+0,	5},
	{gaSSSN+0,	5}, // +5: state 4 transitions
	{gaSSSN+0,	6}, // +6: state 5 transitions
	{gaSSSN+11,	7}, // +7: state 6 transitions
	{gaSSSN+0,	8},
	{gaSSSN+0,	8}, // +9: state 7 transitions
	{gaSSSN+0,	9}, // +10: state 8 transitions
	{gaSSSN+0,	10}, // +11: state 9 transitions
	{gaSSSN+0,	11}, // +12: state 10 transitions
};

const STATE_DESCRIPTION aStateDescSSN[12] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 1, gaTSSN+0},
	/*   1 */ {0, 1, gaTSSN+1},
	/*   2 */ {0, 1, gaTSSN+2},
	/*   3 */ {0, 2, gaTSSN+3},
	/*   4 */ {0, 1, gaTSSN+5},
	/*   5 */ {0, 1, gaTSSN+6},
	/*   6 */ {0, 2, gaTSSN+7},
	/*   7 */ {0, 1, gaTSSN+9},
	/*   8 */ {0, 1, gaTSSN+10},
	/*   9 */ {0, 1, gaTSSN+11},
	/*  10 */ {0, 1, gaTSSN+12},
	/*  11 */ {1, 0, NULL},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\punc.c ===
// punc.c
// Angshuman Guha
// aguha
// Jan 10, 2001

#include "common.h"
#include "punc.h"

// text generated by re2fsa at Mon Apr 01 14:58:40 2002

// the input-file of rules:
// punc = comma;
// punc = dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = colon;
// punc = semicolon;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = rparen;
// punc = rparen comma;
// punc = rparen dot;
// punc = rparen colon;
// punc = rparen semicolon;
// punc = rparen question;
// punc = rparen question question;
// punc = rparen question question question;
// punc = rparen bang;
// punc = rparen bang bang;
// punc = rparen bang bang bang;
// punc = rparen rparen;
// punc = rparen rparen comma;
// punc = rparen rparen dot;
// punc = rparen rparen colon;
// punc = rparen rparen semicolon;
// punc = rparen rparen question;
// punc = rparen rparen question question;
// punc = rparen rparen question question question;
// punc = rparen rparen bang;
// punc = rparen rparen bang bang;
// punc = rparen rparen bang bang bang;
// punc = comma rparen;
// punc = dot rparen;
// punc = colon rparen;
// punc = semicolon rparen;
// punc = question rparen;
// punc = question question rparen;
// punc = question question question rparen;
// punc = bang rparen;
// punc = bang bang rparen;
// punc = bang bang bang rparen;
// punc = dot dot dot rparen;
// punc = rbracket;
// punc = rbracket comma;
// punc = rbracket dot;
// punc = rbracket colon;
// punc = rbracket semicolon;
// punc = rbracket question;
// punc = rbracket question question;
// punc = rbracket question question question;
// punc = rbracket bang;
// punc = rbracket bang bang;
// punc = rbracket bang bang bang;
// punc = rbrace;
// punc = rbrace comma;
// punc = rbrace dot;
// punc = rbrace colon;
// punc = rbrace semicolon;
// punc = rbrace question;
// punc = rbrace question question;
// punc = rbrace question question question;
// punc = rbrace bang;
// punc = rbrace bang bang;
// punc = rbrace bang bang bang;
// punc = star;
// punc = star star;
// punc = star star star;
// punc = slash;
// punc = ampersand;
// punc = dollar;
// punc = dollar dollar;
// punc = dollar dollar dollar;
// punc = euro;
// punc = pound;
// punc = yen;
// punc = equals;
// punc = dquote;
// punc = question;
// punc = question question;
// punc = question question question;
// punc = question question question question;
// punc = question question question question question;
// punc = bslash;
// punc = bslash bslash;
// punc = lessthan;
// punc = greaterthan;
// punc = plus;
// punc = tilde;
// punc = at;
// punc = circumflex;
// punc = star;
// punc = bang;
// punc = bang bang;
// punc = bang bang bang;
// punc = bang bang bang bang;
// punc = bang bang bang bang bang;
// punc = hash;
// punc = lparen plus rparen;
// punc = lparen minus rparen;
// punc = dquote bquote dquote;
// punc = dquote tilde dquote;
// punc = dquote bang dquote;
// punc = dquote at dquote;
// punc = dquote hash dquote;
// punc = dquote dollar dquote;
// punc = dquote euro dquote;
// punc = dquote pound dquote;
// punc = dquote yen dquote;
// punc = dquote percent dquote;
// punc = dquote circumflex dquote;
// punc = dquote ampersand dquote;
// punc = dquote star dquote;
// punc = dquote lparen dquote;
// punc = dquote rparen dquote;
// punc = dquote minus dquote;
// punc = dquote uscore dquote;
// punc = dquote equals dquote;
// punc = dquote plus dquote;
// punc = dquote lbracket dquote;
// punc = dquote lbrace dquote;
// punc = dquote rbracket dquote;
// punc = dquote rbrace dquote;
// punc = dquote bslash dquote;
// punc = dquote semicolon dquote;
// punc = dquote colon dquote;
// punc = dquote squote dquote;
// punc = dquote dquote dquote;
// punc = dquote comma dquote;
// punc = dquote lessthan dquote;
// punc = dquote dot dquote;
// punc = dquote greaterthan dquote;
// punc = dquote slash dquote;
// punc = dquote question dquote;
// punc = minus;
// punc = minus minus;
// punc = minus minus minus;
// punc = minus minus minus minus;
// punc = minus minus minus minus minus;
// punc = uscore;
// punc = uscore uscore;
// punc = uscore uscore uscore;
// punc = uscore uscore uscore uscore;
// punc = uscore uscore uscore uscore uscore;
// punc = dot;
// punc = dot dot;
// punc = dot dot dot;
// punc = dot dot dot dot;
// punc = dot dot dot dot dot;
// comma = ",";
// dot = ".";
// colon = ":";
// semicolon = ";";
// question = "?";
// bang = "!";
// rparen = ")";
// lparen = "(";
// rbracket = "]";
// lbracket = "[";
// rbrace = "}";
// lbrace = "{";
// dquote = "\"";
// squote = "'";
// bquote = "`";
// tilde = "~";
// at = "@";
// hash = "#";
// dollar = "$";
// percent = "%";
// circumflex = "^";
// ampersand = "&";
// star = "*";
// plus = "+";
// minus = "-";
// uscore = "_";
// lessthan = "<";
// greaterthan = ">";
// slash = "/";
// bslash = "\\";
// equals = "=";
// pound = "";
// yen = "";
// euro = "";
// = punc

// 36 states

static const unsigned char gaSPUNC[] = 
	/* gaStringPUNC+0 */	"!\000"
	/* gaStringPUNC+2 */	"\"\000"
	/* gaStringPUNC+4 */	"#&+/<=>@^~\000"
	/* gaStringPUNC+18 */	"$\000"
	/* gaStringPUNC+20 */	"(\000"
	/* gaStringPUNC+22 */	")\000"
	/* gaStringPUNC+24 */	"*\000"
	/* gaStringPUNC+26 */	",:;\000"
	/* gaStringPUNC+30 */	"-\000"
	/* gaStringPUNC+32 */	".\000"
	/* gaStringPUNC+34 */	"?\000"
	/* gaStringPUNC+36 */	"\\\000"
	/* gaStringPUNC+38 */	"]}\000"
	/* gaStringPUNC+41 */	"_\000"
	/* gaStringPUNC+43 */	"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{}~\000"
	/* gaStringPUNC+78 */	"+-\000"
	/* gaStringPUNC+81 */	",.:;\000"
;

static const STATE_TRANSITION gaTPUNC[] = {
	{gaSPUNC+0,	1}, // +0: state 0 transitions
	{gaSPUNC+2,	2},
	{gaSPUNC+4,	3},
	{gaSPUNC+18,	4},
	{gaSPUNC+20,	5},
	{gaSPUNC+22,	6},
	{gaSPUNC+24,	7},
	{gaSPUNC+26,	8},
	{gaSPUNC+30,	9},
	{gaSPUNC+32,	10},
	{gaSPUNC+34,	11},
	{gaSPUNC+36,	12},
	{gaSPUNC+38,	13},
	{gaSPUNC+41,	14},
	{gaSPUNC+22,	3}, // +14: state 1 transitions
	{gaSPUNC+0,	15},
	{gaSPUNC+43,	16}, // +16: state 2 transitions
	{gaSPUNC+18,	17}, // +17: state 4 transitions
	{gaSPUNC+78,	18}, // +18: state 5 transitions
	{gaSPUNC+81,	3}, // +19: state 6 transitions
	{gaSPUNC+22,	13},
	{gaSPUNC+0,	19},
	{gaSPUNC+34,	20},
	{gaSPUNC+24,	21}, // +23: state 7 transitions
	{gaSPUNC+22,	3}, // +24: state 8 transitions
	{gaSPUNC+30,	22}, // +25: state 9 transitions
	{gaSPUNC+22,	3}, // +26: state 10 transitions
	{gaSPUNC+32,	23},
	{gaSPUNC+22,	3}, // +28: state 11 transitions
	{gaSPUNC+34,	24},
	{gaSPUNC+36,	3}, // +30: state 12 transitions
	{gaSPUNC+81,	3}, // +31: state 13 transitions
	{gaSPUNC+0,	19},
	{gaSPUNC+34,	20},
	{gaSPUNC+41,	25}, // +34: state 14 transitions
	{gaSPUNC+22,	3}, // +35: state 15 transitions
	{gaSPUNC+0,	26},
	{gaSPUNC+2,	3}, // +37: state 16 transitions
	{gaSPUNC+18,	3}, // +38: state 17 transitions
	{gaSPUNC+22,	3}, // +39: state 18 transitions
	{gaSPUNC+0,	27}, // +40: state 19 transitions
	{gaSPUNC+34,	28}, // +41: state 20 transitions
	{gaSPUNC+24,	3}, // +42: state 21 transitions
	{gaSPUNC+30,	29}, // +43: state 22 transitions
	{gaSPUNC+32,	30}, // +44: state 23 transitions
	{gaSPUNC+22,	3}, // +45: state 24 transitions
	{gaSPUNC+34,	31},
	{gaSPUNC+41,	32}, // +47: state 25 transitions
	{gaSPUNC+22,	3}, // +48: state 26 transitions
	{gaSPUNC+0,	27},
	{gaSPUNC+0,	3}, // +50: state 27 transitions
	{gaSPUNC+34,	3}, // +51: state 28 transitions
	{gaSPUNC+30,	33}, // +52: state 29 transitions
	{gaSPUNC+22,	3}, // +53: state 30 transitions
	{gaSPUNC+32,	34},
	{gaSPUNC+22,	3}, // +55: state 31 transitions
	{gaSPUNC+34,	28},
	{gaSPUNC+41,	35}, // +57: state 32 transitions
	{gaSPUNC+30,	3}, // +58: state 33 transitions
	{gaSPUNC+32,	3}, // +59: state 34 transitions
	{gaSPUNC+41,	3}, // +60: state 35 transitions
};

const STATE_DESCRIPTION aStateDescPUNC[36] = {
	/* state valid cTrans Trans */
	/*   0 */ {0, 14, gaTPUNC+0},
	/*   1 */ {1, 2, gaTPUNC+14},
	/*   2 */ {1, 1, gaTPUNC+16},
	/*   3 */ {1, 0, NULL},
	/*   4 */ {1, 1, gaTPUNC+17},
	/*   5 */ {0, 1, gaTPUNC+18},
	/*   6 */ {1, 4, gaTPUNC+19},
	/*   7 */ {1, 1, gaTPUNC+23},
	/*   8 */ {1, 1, gaTPUNC+24},
	/*   9 */ {1, 1, gaTPUNC+25},
	/*  10 */ {1, 2, gaTPUNC+26},
	/*  11 */ {1, 2, gaTPUNC+28},
	/*  12 */ {1, 1, gaTPUNC+30},
	/*  13 */ {1, 3, gaTPUNC+31},
	/*  14 */ {1, 1, gaTPUNC+34},
	/*  15 */ {1, 2, gaTPUNC+35},
	/*  16 */ {0, 1, gaTPUNC+37},
	/*  17 */ {1, 1, gaTPUNC+38},
	/*  18 */ {0, 1, gaTPUNC+39},
	/*  19 */ {1, 1, gaTPUNC+40},
	/*  20 */ {1, 1, gaTPUNC+41},
	/*  21 */ {1, 1, gaTPUNC+42},
	/*  22 */ {1, 1, gaTPUNC+43},
	/*  23 */ {1, 1, gaTPUNC+44},
	/*  24 */ {1, 2, gaTPUNC+45},
	/*  25 */ {1, 1, gaTPUNC+47},
	/*  26 */ {1, 2, gaTPUNC+48},
	/*  27 */ {1, 1, gaTPUNC+50},
	/*  28 */ {1, 1, gaTPUNC+51},
	/*  29 */ {1, 1, gaTPUNC+52},
	/*  30 */ {1, 2, gaTPUNC+53},
	/*  31 */ {1, 2, gaTPUNC+55},
	/*  32 */ {1, 1, gaTPUNC+57},
	/*  33 */ {1, 1, gaTPUNC+58},
	/*  34 */ {1, 1, gaTPUNC+59},
	/*  35 */ {1, 1, gaTPUNC+60},
};

// end of text generated by re2fsa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\suffix.h ===
// suffix.h
// Angshuman Guha
// aguha
// April 17, 2001

#ifndef __INC_SUFFIX_H
#define __INC_SUFFIX_H

#include "fsa.h"

#ifdef __cplusplus
extern "C" {
#endif

extern const STATE_DESCRIPTION *aStateDescSuffix;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\inferno\src\usa\langprob.c ===
// Probability model file.
// Computer generated, don't edit.
#include "common.h"
#include "common.h"

const LOGPROB	g_aNumberModel[] = {
  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,
  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,
  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,
  16,  16,  14,  17,  16,  15,  17,  15,  16,  16,  16,  14,  10,  18,  16,  17,
  16,  17,  17,  17,  15,  15,  12,  16,  16,  16,  16,  16,  16,  16,  16,  16,
  15,  19,  16,  17,  17,  14,  18,  17,  15,  11,  14,  16,  16,  16,  15,  13,
  16,  16,  16,  16,  13,  16,  16,  16,  16,  15,  16,  16,  16,  16,  12,  16,
  15,  17,  17,  16,  16,  17,  15,  16,  14,  16,  16,  16,  15,  15,  16,  16,
  16,  16,  17,   8,  14,  17,  16,  14,  17,  20,  19,  21,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,
  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,
  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  13,  16,
  15,  14,  16,  14,  15,  15,  15,  13,  11,  18,  17,  18,  18,  18,  17,  18,
  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  17,  19,  17,  18,
  18,  15,  18,  19,  18,  18,  17,  19,  19,  19,  18,  16,  18,  19,  19,  19,
  17,  19,  19,  19,  19,  18,  19,  19,  19,  19,  15,  19,  17,  19,  19,  18,
  18,  19,  17,  18,  17,  19,  19,  19,  18,  18,  19,  19,  19,  19,  17,  18,
  15,  14,  16,  14,  13,  16,  15,  16,
};

const LOGPROB	g_aGammarModel[] = {
  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
  21,  21,  21,  21,  21,  21,   4,   4,   4,   4,  14,  14,  14,  14,  14,  14,
  14,  13,   0,   0,   0,   0,   0,   0,   0,   0,  19,  19,  19,  19,  19,  19,
  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  18,   0,   4,   4,   0,   0,
   4,   4,   0,   7,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   9,   9,   9,   9,  31,  22,  33,   5,   5,  33,  29,  25,  27,  31,  33,
  12,  12,  12,  12,  12,  12,   0,   0,   0,   0,  12,  12,  12,  12,  12,  12,
   0,   0,   0,   0,   4,   4,   4,   4,   0,   0,   0,   4,   5,   0,   4,   4,
   0,   0,   0,  15,  15,   9,  11,  15,  15,  15,   0,   0,  12,  12,  12,  12,
  12,  12,   0,   0,   0,   0,   0,   0,   4,   4,   4,   4,   0,   4,   4,   6,
   6,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  20,
  19,  20,  20,  19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,
  20,  20,   0,   0,   0,   4,   4,   0,   0,  24,  24,  24,  24,  24,  24,  24,
  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,
  24,  24,  24,  24,  24,  24,  24,  24,  24,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,  11,   4,   4,   0,   0,  11,
   1,  14,  14,  14,  14,  14,  14,  14,  14,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   4,   4,   0,   0,   4,   4,   9,   9,   9,   9,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   9,   9,   9,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,  16,  15,  16,  14,  16,
   0,   0,   0,   0,  12,  12,  12,  12,  12,  12,  27,  27,  27,  27,  27,  27,
  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,   9,   9,
   9,   9,   0,   0,   0,   0,   0,  47,   0,   0,   0,  27,  30,  32,   0,   2,
   8,   4,   4,   0,   4,   4,   0,   0,   7,   7,   7,   0,   0,   6,   3,   0,
   7,   2,  21,  17,  21,  21,  21,   3,  21,  21,   4,   4,  11,  11,  11,  11,
  11,   0,   0,   0,   7,   7,   7,   4,   4,   0,   0,   0,   7,   7,   7,   4,
   4,   0,   0,   0,   4,   4,   4,   4,   0,   9,   9,   9,   9,   7,   7,   7,
   0,   7,   7,   7,   4,   4,   7,   7,   7,   0,   0,  18,  14,  18,  18,  18,
  18,  18,  18,  18,  18,  16,  17,  16,   4,   4,   4,   4,   4,   4,   0,   0,
   0,   4,   4,   7,   7,   7,   0,   0,   4,   4,   0,   0,   0,   0,   7,   7,
   7,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   7,   7,   7,   4,   4,   0,   0,   0,   7,   7,   7,   4,
   4,   0,   0,   0,   4,   4,   4,   4,   0,  10,   7,  10,  10,   7,   7,   7,
   0,   7,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   3,
   7,   7,   7,   0,   0,   0,   7,   7,   7,   4,   4,   0,   0,   0,   0,   7,
   7,   7,   4,   4,   0,   0,   0,   0,   4,   4,   4,   4,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   7,  14,  16,   5,   7,   7,   7,   0,   0,   7,
   7,   7,   0,   7,   7,   7,   0,   7,   7,   7,   4,   4,   0,   0,   4,   4,
   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   4,   4,
   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   4,   4,
   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   4,   4,
   0,   0,   4,   4,   0,   0,  47,  33,  30,  40,   0,  32,   0,   0,   0,   0,
  10,   1,   0,   0,  16,  10,   2,   7,   3,   0,   0,   0,   7,   3,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   7,   0,
   0,   0,   0,   0,   0,   9,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   6,  11,   4,   0,   0,   0,   3,   1,   4,  12,  13,
   4,   0,   0,   0,   0,   4,   4,   0,   4,   0,   4,   0,   0,   0,   0,   4,
   4,   0,   4,   0,   0,   7,   0,   4,   0,   0,   0,   0,   0,   7,   0,   0,
   0,   4,   0,   4,  13,   0,   0,   0,   0,   4,   4,   0,   4,   0,   0,   0,
   0,   4,   4,   0,   4,   0,   4,   0,   7,   0,   4,   0,   0,   0,   0,   3,
   3,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
   0,   5,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   0,
   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   0,   0,
  23,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   6,   6,   0,   0,   2,
   6,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   6,   0,   0,   0,  12,   0,  11,   0,   0,
   0,   0,   0,   9,   0,   7,   0,   4,   0,   0,   0,   9,   0,   7,   0,   4,
   0,   0,   0,   7,   7,   0,   4,   0,   0,   0,   9,   0,   0,   0,   0,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   0,   4,   0,   0,   0,   9,   0,   7,   0,   4,
   0,   0,   0,   7,   7,   0,   4,   0,   0,   0,   7,   0,   0,   0,   0,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,
   7,   0,   0,   0,   0,   8,   0,   7,   0,   0,   0,   4,   0,   0,   9,   0,
   7,   0,   0,   0,   4,   0,   0,   7,   7,   0,   0,   0,   4,   0,   0,   0,
   4,   0,   0,   4,   0,   0,   4,   8,   9,   3,   0,   4,   4,   0,   0,   0,
   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,
   4,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   4,   0,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   2,   0,   0,   0,   0,   0,   4,   0,
   0,   0,   4,   0,   0,   7,   2,   0,   0,   0,   4,   0,   0,   0,   4,   0,
   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   4,   0,
};

const LOGPROB	g_aDictionaryModel[] = {
   0,   0,   0,   0,  23,   0,   0,   0,   0,  24,   0,   0,   0,  27,   0,   0,
   0,   0,  28,   0,   0,   0,   0,   0,  19,   0,   0,   0,  30,   0,   0,   0,
   0,   0,  25,   0,   0,   0,  27,   0,   0,   0,  17,   0,   0,   0,  29,   0,
   0,   0,   0,   0,  23,   0,   0,   0,   0,   0,  26,   0,   0,   0,   0,  26,
   0,   0,   0,  32,   0,   0,   0,  31,   0,   0,   0,   0,  35,   0,   0,   0,
   0,  23,   0,   0,   0,   0,  25,   0,   0,   0,  32,   0,   0,   0,   0,  39,
   0,   0,   0,   0,  43,   0,   0,   0,  40,   0,   0,   0,  48,   0,   0,   0,
  49,   0,   0,   0,   0,  45,   0,   0,   0,  41,   0,   0,   0,  49,   0,   0,
   0,  42,   0,   0,   0,  49,   0,   0,   0,  52,   0,   0,   0,  52,   0,   0,
   0,  49,   0,   0,   0,  50,   0,   0,   0,  46,   0,   0,   0,  49,   0,   0,
   0,  49,   0,   0,   0,   0,  36,   0,   0,   0,  49,   0,   0,   0,  49,   0,
   0,   0,  48,   0,   0,   0,   0,  47,   0,   0,   0,  52,   0,   0,   0,  49,
   0,   0,   0,  52,   0,   0,  50,   0,   0,   0,  52,   0,   0,   0,  52,   0,
   0,  49,   0,   0,  52,   0,   0,  52,   0,   0,   0,  52,   0,  52,   0,  25,
   0,  25,   0,  25,   0,  25,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,
   0,   0,   0,  11,   0,   0,  17,   0,   0,  15,   0,   0,  17,   0,  16,   0,
   0,  22,   0,   0,  19,   0,   0,   0,   0,   0,  15,   0,   0,  18,   0,   0,
  27,   0,   0,  28,   0,   0,  27,   0,  21,   0,   0,  27,   0,  29,   0,  28,
   0,  30,   0,  30,   0,   0,   0,  24,   0,   8,   0,   0,  11,   0,   0,  18,
   0,  12,   0,  15,   0,  13,   0,  19,   0,   8,   0,   0,  10,   0,   0,  10,
  10,   0,   0,   0,   0,  22,   0,   0,   7,   0,   0,   8,   0,  15,   0,   0,
   0,  15,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,  17,
   0,  12,   0,  18,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  20,
   0,  20,   0,  20,   0,  21,   0,  20,   0,  21,   0,  21,   0,   0,   0,   0,
  19,   0,   0,  25,   0,   0,   0,   0,  14,   0,  18,   0,  18,   0,  18,   0,
   0,  18,   0,  18,   0,  18,   0,   0,  18,   0,   0,   0,   0,   0,  18,   0,
  18,   0,  18,   0,   0,  17,   0,  38,   0,  37,   0,   0,   0,   0,  11,   0,
  10,   0,  11,   0,   0,   0,  11,   0,   4,   4,   0,   0,  24,   0,   0,   0,
   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,  14,   8,   0,   0,   4,   0,
   0,   0,  19,   0,   5,   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,
   0,   5,   0,  11,   0,  12,   0,   0,  11,   0,   0,   0,  10,   0,   0,   0,
  11,   0,  11,  11,   0,   0,   4,   4,   0,   0,   4,   0,   4,   0,   0,   4,
   0,   0,   0,   0,   0,   0,   8,   0,  14,   0,  14,   0,  14,   0,  14,   0,
  13,  14,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   4,   0,   0,   0,
   0,   4,   0,   0,   4,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   8,   0,   0,  10,   0,   0,   0,  10,   9,   0,   0,   0,   0,   0,
   8,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,
  38,   0,   0,  37,   0,   0,   0,   9,   0,  11,   0,  11,   0,   0,  11,   0,
  14,   0,  14,   0,  14,   0,  13,   0,   0,  14,   0,  14,   0,   0,   0,  14,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   6,   0,   6,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  13,   0,   0,   5,   0,   0,   5,   0,  38,   0,  38,   0,   0,   0,
   0,   0,  38,   0,  38,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,  14,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,
   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   5,   0,  13,   0,  13,   0,
  13,   0,   0,  13,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,  25,   0,   0,  38,   0,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,   0,
   0,  25,   0,   0,   0,   0,   7,   0,   7,   0,   0,   7,   0,   7,   7,   0,
   5,   0,  13,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,  13,   0,   0,
  13,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  37,   0,   0,  25,
   0,   0,  25,   0,   7,   0,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  13,
   0,  11,   0,  12,   0,  13,  15,   0,   0,   0,   0,   0,  12,   0,  16,   0,
  14,   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,   0,   0,  16,   0,   0,
   0,  16,  16,   0,   0,   0,   0,   6,   0,   8,   0,   9,   0,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,   0,  10,   0,  10,
   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   5,
   0,   0,   7,   0,   0,   7,   0,  38,   0,  26,   0,   0,   0,   0,   0,   0,
  10,   0,   0,  10,   0,   9,   0,   0,  11,   0,  11,   0,  11,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,   0,
  15,   0,   0,   0,  25,   0,   0,   0,  25,   0,  24,   0,   0,   0,   0,   0,
  14,   0,  14,   0,  13,   0,  14,   0,  14,   0,   0,  14,   0,  14,  14,   0,
   6,   0,   0,  24,   0,  38,   0,  38,   0,  38,   0,  38,   0,   0,  38,   0,
  38,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,  15,   0,   0,   0,  15,
   0,  13,   0,   0,   0,   4,   0,   0,   4,   4,   0,   0,   0,   0,   0,  12,
   0,  12,   0,   0,  11,   0,   0,   4,   0,   0,   4,   0,  38,   0,   0,  38,
   0,  24,   0,   0,   0,   0,   5,   0,   0,   4,   5,   0,   0,   0,   0,   0,
   0,  10,   0,   0,   0,  10,   0,  14,   0,  14,   0,  14,   0,  15,   0,  12,
   0,   0,   0,   0,  15,   0,   0,   0,  15,  15,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   5,   0,   0,   4,   0,  38,   0,   0,  38,   0,
   0,   6,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,  15,   0,   0,   0,  15,
   0,   0,  25,   0,   0,   0,   0,   9,   0,   0,   0,   0,   9,   0,   9,   9,
   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,   6,   0,
  12,   0,   0,  14,   0,  14,   0,  13,   0,  14,   0,   0,  14,   0,   0,   0,
   0,   0,  25,   0,   5,   0,   0,   0,   3,   0,  11,   0,   0,  11,   0,   0,
  11,   0,  11,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  37,   0,   0,   0,   0,  16,   0,  17,   0,  16,   0,
  17,   0,   0,   0,  17,   0,   0,   4,   5,   0,   0,   0,  38,   0,   0,  38,
   0,   4,   0,   4,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,
   0,   4,   0,   0,   0,   5,   0,  17,   0,  17,   0,  16,   0,   0,  17,   0,
  17,   0,   0,  17,   0,   0,  15,   0,  17,   0,  17,   0,   0,   0,  17,   0,
   0,   0,  17,  17,   0,   0,   0,  12,   0,   0,  11,   0,  11,   0,  11,   0,
   0,   0,  11,   0,  17,   0,  17,   0,  17,   0,   0,  17,   0,   0,   0,   0,
   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   8,   0,   0,
   0,   8,   0,  25,   0,  25,   0,   0,   0,   0,   0,  11,   0,   0,  11,   0,
  11,   0,  11,  11,   0,   0,   6,   0,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  14,   0,  14,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,  25,   0,  25,   0,  25,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   5,   0,   0,  12,
   0,   0,  11,   0,  12,   0,  12,   0,  38,   0,   0,  38,   0,   0,  25,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,
  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,  16,
   0,  16,   0,   0,  16,   0,  16,   0,   0,   0,  16,   0,   0,   0,  16,   0,
  16,   0,  16,   0,   0,  16,  16,   0,   0,   0,   0,   0,   7,   0,   0,   0,
   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   0,   0,   4,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   5,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   8,   0,   0,
   0,   0,  24,   0,   7,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   7,   0,  14,   0,  19,   0,  18,   0,   0,  18,   0,
  18,   0,  17,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,  19,   0,  19,
   0,   0,   0,  19,   0,  19,  19,   0,   0,   0,   0,   0,  13,   0,   0,  14,
   0,  10,   0,  14,   0,   0,   0,  11,   0,   0,   4,   0,   0,   0,   0,   0,
   0,  12,   0,   0,  12,   0,  12,   0,  12,   0,   0,   0,  12,   0,   0,   0,
   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   0,   0,   0,   5,   0,   0,   4,   0,  16,   0,  16,   0,  16,   0,  16,
   0,   0,   0,  16,   0,  16,   0,  16,   0,   0,   0,  16,   0,  16,   0,   0,
   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,  25,   0,   0,  25,   0,   0,  25,   0,   0,  25,
   0,   0,   0,   0,   0,  25,   0,   8,   0,   0,   7,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   0,  23,   0,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,  10,   0,   9,   0,   0,   0,  10,   0,   0,   0,   0,  25,   0,   0,
   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   4,   0,   0,   0,  24,   0,   0,   0,  18,   0,  18,   0,  18,   0,
  16,   0,  19,   0,  18,   0,  19,   0,  19,   0,   0,   0,  19,   0,   0,  19,
   0,   9,   0,   0,  10,   0,  26,   0,  26,   0,   0,   0,   0,  26,   0,  25,
   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  18,   0,  18,   0,  18,   0,   0,
  18,   0,  17,   0,   0,   0,  18,   0,   0,   0,   0,   7,   0,   0,   5,   0,
   0,   4,   0,   0,  25,   0,   0,   0,   0,  14,   0,   0,   0,   5,   0,   0,
   0,   0,   8,   8,   0,   0,   0,   0,   0,   0,  25,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   7,   0,   7,   0,   7,   0,   0,   0,   6,   0,   0,
   8,   0,   6,   0,   0,  12,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  10,   0,  17,   0,  16,   0,  17,   0,  17,
   0,  16,   0,  17,   0,  17,   0,   0,  17,   0,   0,   4,   4,   0,   0,   5,
   0,   0,  15,   0,  21,   0,  24,   0,  25,   0,   0,  25,   0,   0,   0,  22,
   0,   0,   0,   0,   0,   0,   0,   7,   2,   0,   0,   0,   6,   0,   3,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,   4,   0,   5,   0,   0,
  26,   0,   7,   0,   0,  37,   0,  25,   0,   0,  25,   0,  25,   0,  25,   0,
   0,   0,  25,   0,   0,   5,   0,  24,   0,  16,   0,   0,  16,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   4,   0,
   0,   4,   0,   0,   0,  18,   0,   0,  15,   0,  17,   0,   0,  19,   0,  15,
   0,  21,   0,   0,  19,   0,  19,   0,  19,   0,  20,   0,  21,   0,  21,   0,
  21,   0,   0,  21,   0,  21,   0,  21,  21,   0,   0,   0,   0,   0,   0,   7,
   0,  20,   0,  20,   0,  20,   0,  20,   0,  21,   0,  21,   0,  21,   0,  21,
   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,
   0,  21,   0,  21,   0,  21,   0,   0,  21,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,  13,   0,  14,   0,  14,   0,  14,   0,  14,   0,  14,
   0,  14,  14,   0,   0,   0,   4,   0,   6,   0,   8,   8,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   8,   0,   4,   0,   8,   0,   0,   8,   6,   0,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,   7,   0,   0,   0,   4,
   4,   0,  14,   0,  14,   0,  16,   0,   0,   0,  16,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   4,   0,  13,   0,  13,   0,  13,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,  10,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   4,   0,   0,   0,
   4,   0,   0,   0,   5,   0,   0,   0,   4,   0,   0,   4,   0,   7,   0,   7,
   7,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  24,   0,  38,   0,   0,   0,
  38,   0,   9,   0,   0,   9,   0,   0,   0,   9,   9,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,  15,   0,
   0,   4,   4,   0,   0,   0,   6,   0,   7,   0,   0,   7,   7,   0,   0,   0,
   4,   0,   4,   4,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,  14,
   0,   7,   0,   0,   0,   7,   7,   0,   0,   4,   4,   0,   0,   0,   7,   0,
   4,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   4,   4,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   7,   0,   0,   0,   0,   0,   8,   0,   0,   0,   8,   0,   7,
   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   5,   0,
   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,  25,
   0,   4,   4,   0,   0,   0,   0,   6,   0,   0,  13,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,  20,   0,   0,   0,  25,   0,  25,   0,   4,
   5,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  18,
   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,   0,  19,   0,   0,
   0,  19,   0,   0,  19,   0,   0,  19,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,  11,
   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   9,   0,   9,   0,   0,   0,
   0,   0,   9,   0,   4,   4,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,
  24,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   8,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   0,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,
   0,   0,   7,   0,   7,   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,
   0,   4,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  36,   0,  33,
   0,  38,   0,  38,   0,   0,   0,   0,   0,  38,   0,   9,   0,   9,   0,   9,
   0,   0,   9,   0,   0,   0,   4,   0,   0,   0,   7,   0,   7,   7,   0,   0,
   0,   0,  11,   0,   0,  10,   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   3,   6,   0,   5,   0,   4,   0,   0,   0,  24,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   8,
   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,
   0,  16,   0,   0,  16,   0,   0,   0,   0,   0,   0,  17,   0,   0,  16,   0,
  18,   0,  17,   0,  18,   0,   0,  17,   0,  18,   0,  18,   0,  18,   0,  18,
   0,  15,   0,   4,   5,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,  38,
   0,   0,  38,   0,   0,  10,   0,  10,   0,   0,   0,   8,   9,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   5,
   4,   0,   5,   4,   0,   0,   0,   0,  25,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  24,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,  36,   0,   0,   0,
  38,   0,   0,   0,   0,   7,   0,   7,   7,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   8,   0,   4,   5,   0,   0,   0,   0,   0,  25,   0,   0,  25,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,   0,  12,
   0,   0,   0,  12,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  11,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,
   0,  16,   0,   0,  16,   0,  16,   0,   0,  16,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   6,   0,   0,  23,   0,  11,   0,  11,   0,   0,   0,  11,   0,   0,  11,
   0,   0,   0,  11,   0,  11,   0,   0,   0,  11,   0,   0,   0,  11,  11,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   4,   4,   0,
   0,   0,  10,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,   0,   0,  12,   0,   0,  12,   0,   0,   0,
   0,   0,   0,   8,   0,  11,   0,   0,  25,   0,   0,   0,   0,  24,   0,   8,
   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   8,   0,   0,   9,   9,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   0,   0,   0,   4,   0,   6,   0,   0,   0,   9,   0,   9,   0,   9,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,
   0,   0,   0,   0,   7,   0,   0,   0,  25,   0,   0,  25,   0,   0,   5,   0,
   0,   0,   0,   0,   0,   0,   0,   5,   0,   4,   4,   0,   0,   0,  24,   0,
   0,  24,   0,   0,   0,   0,   0,  13,   0,   8,   0,   0,   9,   0,   0,   0,
   9,   0,  24,   0,   0,   5,   0,   7,   0,   9,   0,   8,   0,   9,   9,   0,
   0,   0,   0,   0,  25,   0,   4,   4,   0,   0,   5,   0,   0,   0,   0,   9,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  38,   0,   0,  38,   0,  11,   0,  10,   0,  11,   0,  11,  11,   0,   0,   0,
   0,   4,   5,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   5,   4,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   8,   0,   0,   0,   0,   8,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,
  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  11,   0,   9,   0,   0,  11,   0,   0,  11,  11,   0,   0,   0,   5,
   0,   0,  24,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  23,   0,  25,   0,  25,   0,   0,   0,   0,
   0,   5,   4,   0,   0,   0,   0,   0,   8,   0,   0,   7,   0,   8,   0,   0,
   9,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,
  26,   0,   0,  26,   0,   0,  19,   0,   0,   0,   4,   0,   4,   0,  15,   0,
   0,  15,   0,  38,   0,   0,   0,  38,   0,  38,   0,   0,   0,  38,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,
   0,   7,   0,   0,   0,   0,   7,   0,   0,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,   0,   4,   0,   0,   0,   8,   0,   0,
   0,   0,   0,   0,   0,  24,   0,  17,   0,  17,   0,   0,   0,  18,   0,   0,
   0,  19,   0,  22,   0,   0,   0,  15,   0,  22,   0,  21,   0,   0,   0,  21,
   0,  17,   0,  22,   0,  18,   0,  22,   0,   0,  21,   0,  21,   0,  21,   0,
   0,  21,  22,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,  13,
   0,  15,   0,  17,   0,   0,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,
   0,   0,   0,  17,   0,   0,   0,   0,  17,  17,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   0,   8,   0,  10,  10,   0,   0,   0,   0,  10,   0,   9,   0,
  11,   0,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,  36,   0,  14,
   0,  14,   0,   0,  13,   0,   0,   0,  12,   0,  10,   0,   0,  11,   0,  24,
   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,   0,   0,  12,   0,  11,   0,
   0,   0,  12,   0,   0,  11,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   9,
   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   4,   4,
   0,   0,   0,   0,   0,  11,   0,   0,  12,   0,   0,  13,   0,  11,   0,  12,
  13,   0,   0,   0,   4,   0,   0,   4,   0,  11,   0,  11,   0,  11,   0,   0,
   0,   9,  11,   0,   0,  25,   0,   0,  25,   0,   0,   0,  15,   0,  15,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   0,   0,   7,   0,   8,   0,  10,   0,   7,   0,   0,   7,   7,
   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   5,   4,   0,   0,  36,   0,   0,   0,   0,  25,   0,   0,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,  25,   0,  14,   0,  12,   0,  13,   0,  14,
   0,  11,   0,  14,  14,   0,   0,   0,   0,   0,   4,   4,   0,   0,   7,   0,
   7,   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,  10,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,
   0,  24,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,  24,   0,   0,   0,
   0,   0,   0,   0,   5,   0,   4,   0,   0,   0,  13,   0,  12,   0,  13,   0,
  13,   0,   0,  13,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  37,   0,  38,   0,   0,
  38,   0,   0,  37,   0,   0,   0,   0,   0,  16,   0,  17,   0,  17,   0,   0,
  17,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,  18,   0,   0,
   0,  18,   0,  18,  18,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,
   9,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   9,
   0,   4,   0,   0,   5,   0,   0,   0,  17,   0,  17,   0,   0,   0,  17,   0,
   0,   0,   0,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,  38,   0,   0,   7,
   0,   0,   7,   0,   8,   0,   0,   0,   0,   8,   0,   0,   4,   0,   0,   4,
   0,   0,   0,   0,   4,   0,   0,   4,   0,   4,   0,  38,   0,   0,  38,   0,
   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,  11,   0,   0,
   0,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,
  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,  18,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   5,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   4,
   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,   7,   7,
   0,   0,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  10,   0,   0,  15,   0,   0,  14,   0,   0,  14,   0,   0,
   0,   0,  16,   0,   0,   0,   0,  16,   0,   0,  16,   0,  16,   0,   0,  13,
  16,   0,   0,   0,   0,  17,   0,   0,  17,   0,   0,   0,  17,   0,   0,   0,
   0,   0,   9,   0,   9,   0,   8,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,
  11,   0,  11,   0,   7,   0,   0,   0,   7,   0,   0,   7,   0,   0,   7,   0,
   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,  24,   0,   0,   5,   0,   0,   0,   0,   0,
   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,  10,   0,  11,   0,  11,   0,
  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  10,   0,  10,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,  18,   0,  18,
   0,  18,   0,   0,   0,  18,   0,  18,   0,   0,   0,  18,   0,  18,   0,  17,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,   0,  12,
   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,   0,   0,  12,
   0,   0,  12,   0,  12,   0,   0,   0,  13,  12,   0,   0,   0,   0,   0,   6,
   3,   0,   0,   0,  24,   0,  24,   0,   0,   0,  25,   0,   7,   0,   0,   8,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,
   9,   0,   0,   0,   0,  12,   0,   0,  12,   0,  12,   0,   0,  12,   0,   0,
   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   5,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   7,   0,   0,
   0,   0,  38,   0,   0,  38,   0,   0,   3,   0,   6,   0,   0,  25,   0,  25,
   0,   9,   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  21,   0,   0,  25,   0,   0,   0,   0,  25,   0,   0,
   0,   3,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,
   7,   0,   0,   4,   0,   0,   4,   0,   8,   0,   8,   0,   0,   0,   0,   7,
   0,   0,   4,   4,   0,   0,   0,  38,   0,  12,   0,   0,  12,   0,   0,  12,
   0,  11,   0,   0,  12,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   4,   0,   4,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,  14,   0,
  11,   0,  10,   0,   0,  11,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,
   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,
   9,   9,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   6,   0,   0,   4,   0,   0,   0,   0,   0,
  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,
   0,   0,  13,   0,  14,   0,  15,   0,  16,   0,  16,   0,  18,   0,  18,   0,
  18,   0,  38,   0,   0,   0,   0,   0,   0,  11,   0,  18,   0,  17,   0,  18,
   0,  18,   0,  16,   0,   0,   0,  18,   0,  25,   0,  19,   0,   0,  25,   0,
  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   8,   0,   0,   0,
   7,   0,   0,   0,   7,   7,   0,   9,   0,   9,   0,   0,   0,   9,   9,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  11,   0,  13,   0,   0,   7,   0,  13,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   4,   4,   0,   0,   0,
   9,   0,  38,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   7,   0,   0,   0,   0,   7,   0,  18,
   0,   0,  18,   0,   0,   0,  18,   0,  18,   0,  18,   0,   0,   0,   0,   0,
  18,   0,   5,   0,   0,   4,   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,
   5,   4,   0,  14,   0,   5,   0,   0,   0,  26,   0,   0,   0,  26,   0,   0,
   0,   0,   0,   0,   9,   0,   0,   0,   0,   0,   9,   0,  25,   0,   0,   0,
  25,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   5,   0,  25,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  15,   0,
  14,   0,   0,  15,   0,  15,   0,  14,   0,  15,  15,   0,   0,   0,   0,   0,
   0,  16,   0,  16,   0,   0,  12,   0,  15,   0,   0,   0,  14,   0,   0,   0,
   7,   0,   0,   7,   7,   0,   7,   0,   0,   7,   0,   7,   0,   0,  10,   0,
   0,  11,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,
   0,  13,   0,   0,  13,   0,  25,   0,   0,  25,   0,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  37,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,
   0,  38,   0,   0,   0,   0,   5,   4,   0,   8,   0,   0,   0,   0,   6,   0,
   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,  25,   0,  15,   0,  14,
   0,   0,  15,   0,  16,   0,  16,   0,  16,   0,   0,   0,  15,   0,  16,   0,
  16,  16,   0,   0,   0,   0,   0,   0,  18,   0,  18,   0,  17,   0,  17,   0,
  18,   0,   0,  18,   0,   0,   8,   0,   0,   0,   0,   0,   8,   0,   0,   0,
  25,   0,   4,   0,   5,   0,  13,   0,  15,   0,  15,   0,   4,   4,   0,   0,
   0,   0,   0,   7,   0,   0,   0,  38,   0,  38,   0,  38,   0,  37,   0,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,
   8,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,  38,   0,   0,
  38,   0,   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,  13,   0,
   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  16,   0,   0,  16,   0,  14,   0,  17,   0,  16,   0,  17,   0,  17,
   0,  17,   0,   0,  17,   0,   0,   0,  17,   0,   0,  10,   0,   0,  11,   0,
  11,   0,   0,   0,   0,   0,  11,   0,   0,   0,   0,   0,   0,  14,   0,   0,
   0,  14,   0,   0,   0,   0,   0,   0,   0,  16,   0,   0,  25,   0,  25,   0,
  25,   0,  25,   0,   0,  25,   0,   4,   0,   0,   4,   0,   0,   0,   3,   6,
   0,   0,   0,   0,   0,  15,   0,   0,   0,  15,   0,   0,   0,   0,  15,   0,
  25,   0,   0,  25,   0,   0,   0,  25,   0,   0,   5,   0,   4,   0,  24,   0,
   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  13,
   0,  12,   0,  13,   0,   0,  13,  12,   0,   0,   0,   0,   8,   0,  10,   0,
   0,  10,   0,   0,   0,   7,   0,   0,   0,   8,   0,   0,   0,   0,   0,  16,
   0,  16,   0,   0,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,  25,   0,
   0,   0,   0,   0,  14,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,  14,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   4,   0,   0,   0,   4,   0,  11,   0,   9,   0,  11,   0,  11,
  11,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,   0,  15,   0,   7,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  12,   0,   0,  12,   0,  12,   0,  12,   0,  10,   0,   0,   0,  10,   0,   0,
   0,  25,   0,   0,  25,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,   0,
   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   7,   0,   0,   0,   7,   0,   0,   4,   0,   7,   0,   0,
   0,   0,   0,   0,  11,   0,   0,   7,   0,  12,   0,   8,   0,   0,  15,   0,
   0,   0,  13,   0,  18,   0,  16,   0,   0,  18,   0,   0,  18,   0,  38,   0,
  38,   0,   0,   0,  38,   0,  15,   0,  19,   0,  19,   0,  19,   0,  17,   0,
  18,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,
   0,  19,   0,   0,  19,   0,   0,  10,   0,   0,   0,   0,  13,   0,   0,   0,
  13,   0,   0,  13,   0,   0,   0,  12,   0,   0,  11,   0,  11,   0,   0,   0,
  11,   0,  11,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,  14,
   0,  14,   0,   0,  14,   0,   0,  26,   0,  26,   0,   0,   0,  26,   0,   0,
  26,   0,   0,  26,   0,  26,   0,   0,  26,   0,  25,   0,   0,  25,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,  25,   0,   0,   0,  24,   0,  25,   0,
   0,   0,   0,  38,   0,   0,   0,  38,   0,   0,   0,   0,   0,  16,   0,  15,
   0,  16,   0,   0,   0,   0,  16,   0,   0,  25,   0,   0,  25,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  35,   0,  13,   0,  13,   0,  13,
   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,  10,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,   8,
   0,   8,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,
   0,  25,   0,   0,   0,   0,   0,   0,  15,   0,   0,  19,   0,   0,  19,   0,
  16,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  17,   0,   0,
  19,   0,   0,  19,   0,   0,   0,  14,   0,  19,   0,  19,   0,  20,   0,   0,
  20,   0,  20,   0,  20,   0,  20,   0,   0,  20,   0,   0,  20,   0,  20,   0,
   0,  18,   0,   0,  20,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,
   0,   4,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,  38,   0,
   0,  34,   0,  38,   0,  37,   0,  38,   0,   0,  38,   0,  38,   0,   0,   0,
  37,   0,  38,   0,   0,   0,   0,  38,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   0,  25,   0,   0,   0,  10,   0,   0,  10,   0,   0,   0,
   0,  10,   0,  14,   0,   0,   0,   0,  13,   0,   0,  24,   0,   0,   5,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,
  26,   0,   0,  26,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,  38,   0,
  38,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   4,   0,   4,   0,
   0,   0,   0,  12,   0,  12,   0,   0,  12,   0,  12,   0,   0,   0,   0,  12,
   0,   0,   0,  12,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   3,
   6,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   8,   0,   0,   8,   6,   0,   0,   0,   0,   0,   0,   0,  26,   0,   0,
  26,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  16,   0,   0,  15,   0,  16,   0,
  16,   0,  16,   0,  16,   0,  16,   0,   0,   0,  16,   0,  16,   0,  16,   0,
   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,  26,   0,  25,   0,   0,   0,
  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,
   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,  13,   0,  13,   0,   0,
  13,   0,   0,  13,   0,  12,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  15,   0,  15,   0,   0,  15,   0,  38,   0,   0,
  38,   0,   0,   0,  38,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,  13,
   0,   0,   0,   0,   0,  16,   0,   0,  16,   0,  16,   0,   0,  16,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,
   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,   0,  16,   0,  16,   0,
   0,   0,   5,   0,   0,  10,   0,   0,  10,   0,   0,  10,   0,   0,   4,   0,
   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,   0,  38,   0,   0,   0,
   4,   0,   0,  13,   0,   0,  12,   0,   0,  13,   0,   0,   0,   0,   0,   9,
   0,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,  26,
   0,   0,   0,   9,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,   0,   9,
   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  24,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,
  11,   0,  11,   0,  10,   0,  11,  11,   0,   0,   0,   4,   0,   4,   0,  13,
   0,  13,   0,  13,   0,  13,   0,  13,   0,   0,  13,   0,  38,   0,  25,   0,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,  24,   0,   0,  35,   0,   0,  25,   0,   0,  25,
   0,   7,   0,   7,   7,   0,   0,   0,   0,  24,   0,   0,   0,   0,  24,   0,
   0,   0,  38,   0,   0,   0,   0,  12,   0,  12,   0,   0,  12,   0,   0,  12,
   0,   0,   0,  10,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,  23,   0,
  38,   0,  36,   0,  36,   0,   0,   0,  10,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,   0,  25,   0,   0,   0,  38,   0,   0,   0,   4,   0,  14,   0,
  15,   0,  14,   0,  15,   0,  16,   0,  12,   0,  16,   0,   0,   0,   0,  16,
  16,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,  11,   0,  10,
  11,   0,  16,   0,   0,   0,  16,   0,  16,   0,  16,   0,   0,   0,   0,   0,
  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,
   0,  11,   0,   0,   0,  12,  12,   0,   0,  14,   0,   0,  14,   0,  25,   0,
   0,  25,   0,   0,  25,   0,  15,   0,   0,  15,   0,   0,   0,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   9,   0,
   9,   0,   9,   9,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,
  20,   0,  38,   0,   0,   0,  37,   0,   0,   0,  26,   0,   0,   0,  26,   0,
   0,   0,  26,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,   0,  12,   0,
  12,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,
  25,   0,   5,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   6,   0,   0,   0,   8,   8,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   0,   0,   8,   0,  25,   0,   0,   0,   0,
  25,   0,   0,   0,  25,   0,   0,  25,   0,   0,  25,   0,   0,   0,  25,   0,
   0,   0,   0,   0,  15,   0,  15,   0,  16,   0,  15,   0,  16,   0,  16,   0,
  16,   0,  16,   0,  16,  16,   0,   0,   0,   0,   0,   0,   0,  26,   0,  25,
   0,  26,   0,   0,  26,   0,  26,   0,   0,  26,   0,   0,  26,   0,  26,   0,
   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,  25,   0,   0,   0,   0,   0,  18,   0,  18,   0,   0,  17,   0,
   0,  18,   0,  18,   0,   0,   0,  18,   0,   0,   0,   0,   0,   0,   6,   0,
   0,   9,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   9,   0,   9,   0,   9,   9,   0,   4,   0,   0,   0,   0,  25,   0,   0,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,  24,
   0,  37,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  24,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,  12,   0,  14,   0,
  14,   0,  14,   0,  14,   0,   0,  14,   0,  14,  14,   0,   0,   0,   0,   0,
   0,   0,   6,   0,   8,   8,   0,   0,   0,   0,   0,   0,   6,   0,   0,   3,
   0,  37,   0,  38,   0,  38,   0,   0,   0,  38,   0,  38,   0,  38,   0,   0,
  38,   0,  38,   0,   0,  38,   0,   0,   0,   5,   4,   0,   8,   0,   0,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,  38,   0,   0,   0,  38,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   4,   0,   0,   4,   0,
   7,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,
  14,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,   0,   0,
   0,   0,   0,  15,   0,   0,  11,   0,   0,  12,   0,   0,   0,   0,  12,   0,
  12,   0,   0,   0,  12,  12,   0,   0,   0,   7,   0,  12,   0,   0,  12,   0,
  12,   0,  12,   0,   0,   0,  11,   0,   7,   0,   0,   0,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,  14,   0,  14,   0,  14,   0,  14,   0,   0,
   0,  14,   0,  14,   0,  14,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,  25,   0,   0,   0,   0,   0,   0,  26,   0,   0,  26,   0,
   0,  38,   0,   0,   0,  38,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   5,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,  24,   0,
   9,   0,  14,   0,  14,   0,   0,   0,  14,   0,  14,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   3,   6,   0,   0,   0,   0,   0,   0,   3,   0,
   3,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,   0,   0,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  21,   0,  21,   0,   0,  19,   0,   0,
  20,   0,  22,   0,   0,  22,   0,  22,   0,  18,   0,  21,   0,  22,   0,  15,
   0,  20,   0,  22,   0,  21,   0,   0,   0,   0,  20,   0,  21,   0,   0,  22,
   0,   0,   0,  19,   0,   0,   0,  22,  22,   0,   0,   0,   0,  16,   0,  16,
   0,   0,  16,   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  15,   0,  16,
  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,
   0,   9,   0,   0,   0,   0,   0,   9,   0,   7,   0,   7,   0,   0,   0,   0,
   0,  38,   0,   0,   0,   0,  12,   0,   0,  12,   0,   0,  12,   0,   0,  12,
   0,  12,   0,   4,   4,   0,   6,   0,   4,   0,   0,   0,   0,   0,   0,  13,
   0,  13,   0,  13,   0,   0,   0,  13,   0,  13,   0,   0,   0,  13,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,
   0,   0,   0,   0,   0,   0,   0,   0,  18,   0,  18,   0,  18,   0,   0,  18,
   0,  18,   0,   0,   0,  18,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   9,   0,
   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,
   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,
   0,   0,  25,   0,   0,  25,   0,   0,   0,  25,   0,  19,   0,  19,   0,  19,
   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,   0,  19,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   0,   4,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,  10,   0,
   0,   0,  10,   0,  10,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,
   0,   0,   0,   8,   0,   0,   8,   0,  12,   0,  13,   0,  13,   0,  13,   0,
  13,   0,   0,  13,  13,   0,   0,   0,  11,   0,  10,   0,  11,   0,  11,  11,
   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   7,   7,   0,   0,   0,  23,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  12,   0,   0,   5,   0,   5,   0,   0,   0,   0,  25,   0,   0,
   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,  25,   0,  25,   0,  24,   0,  10,   0,  11,   0,  10,   0,  11,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,
   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,  11,   0,
  11,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,  38,   0,  26,
   0,   0,   0,  26,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  11,   0,   0,  11,   0,   0,  11,   0,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,  38,   0,  26,
   0,   0,   0,  26,   0,   0,   0,   0,   4,   0,  12,   0,  12,   0,   0,  12,
   0,  12,   0,  12,  12,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   6,   0,
  14,   0,   0,   0,  14,   0,  14,   0,  14,   0,   0,   0,  14,   0,   0,   0,
  10,  14,   0,   0,   7,   0,   6,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  13,   0,  13,   0,
   0,  13,   0,  13,   0,  13,  13,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  13,   0,  13,   0,  13,   0,  13,   0,   0,  13,   0,  13,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  10,   0,   0,   4,  10,   0,   0,   0,  25,   0,   0,
  25,   0,   0,  25,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,  25,
   0,   0,   6,   0,   0,   0,   8,   8,   0,   0,   0,   0,   0,  14,   0,  14,
   0,   0,  14,   0,  14,   0,  14,   0,  12,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,  13,   0,
  13,   0,   0,   0,  15,   0,   0,  15,   0,   0,   0,  19,   0,  25,   0,  25,
   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,
   0,   0,   0,   0,   0,  26,   0,   0,  26,   0,   0,  26,   0,   0,  26,   0,
   0,   0,  26,   0,   0,  26,   0,   4,   4,   0,   0,   0,   0,  10,   0,  11,
   0,  11,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,  13,
   0,   0,   0,   0,  13,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,
   0,  20,   0,  19,   0,  23,   0,  20,   0,  13,   0,   0,  22,   0,  22,   0,
  23,   0,  23,   0,  23,   0,  20,   0,  23,   0,   0,  22,   0,  21,   0,  19,
   0,  23,   0,  23,   0,   0,  23,   0,   0,   0,   0,  14,   0,   0,  14,   0,
  14,   0,   0,  14,   0,  14,   0,   0,   0,   0,  14,   0,   0,   0,  14,  13,
   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  17,   0,   0,  17,   0,  17,
   0,  17,   0,  16,   0,   5,   4,   0,   4,   5,   0,   0,   0,   0,   0,  10,
   0,   0,   0,  26,   0,  26,   0,   0,  26,   0,   0,   0,   0,   0,  12,   0,
  12,   0,   0,  12,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,  26,
   0,   0,  26,   0,   0,  26,   0,  26,   0,   0,   9,   0,   0,   0,   0,   0,
   0,   8,   0,  38,   0,   0,  37,   0,  25,   0,  25,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  13,   0,  14,   0,  15,   0,   0,  15,   0,  15,   0,   0,
  15,   0,  15,   0,   0,   0,  15,  15,   0,   0,   0,   0,   0,   0,   0,   9,
   0,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,
   0,   0,  13,   0,  13,   0,   0,  13,   0,  13,   0,  13,   0,   0,   0,   0,
   0,  11,   0,   0,  26,   0,   0,   0,  26,   0,  25,   0,  26,   0,   0,   0,
   0,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,   0,   0,   0,
   0,   0,   0,   0,   9,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,  15,
   0,   0,  15,   0,  15,   0,   0,  15,   0,  15,   0,  15,   0,   0,   0,  15,
   0,   0,   0,  15,   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,   9,   0,
   9,   0,   0,   9,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,  12,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,   0,   0,   5,   0,   8,
   0,   8,   0,   0,   0,   0,  14,   0,   6,   0,   8,   7,   0,   0,   8,   0,
   0,   0,   7,   0,   0,   0,   0,   0,   0,   4,   0,  25,   0,   0,   0,  25,
   0,   8,   0,   0,   0,   8,   0,   0,   0,   0,   4,   0,   0,   4,   0,   9,
   0,   9,   0,   0,   9,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   0,  14,   0,  14,   0,   0,   0,   0,  14,  14,   0,
   0,   0,   0,   0,  14,   0,  13,   0,  14,   0,  14,   0,  14,   0,  14,   0,
  14,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,  13,   0,  13,
   0,  13,   0,  13,   0,   0,  13,   0,   0,   0,  12,   0,   0,   9,   0,   0,
   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,  25,
   0,  25,   0,  25,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   9,   0,   9,
   0,   0,   9,   0,  17,   0,   0,  17,   0,   0,   0,   0,  17,   0,   0,   4,
   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,  25,
   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   6,   0,   3,   0,   0,   0,   0,   5,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,  25,   0,   0,   0,
   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   5,   0,   6,   3,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  17,   0,  17,   0,  20,   0,  14,   0,  17,
   0,   0,  20,   0,   0,  18,   0,   0,   0,  18,   0,   0,  20,   0,  20,   0,
  20,   0,  20,   0,  17,   0,  20,  20,   0,   0,   0,   0,   0,   0,   0,   0,
  16,   0,   0,  17,   0,  14,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,
   0,  17,   0,  17,   0,   0,   0,   4,   4,   0,   0,  13,   0,   0,   0,   0,
  13,   0,  10,   0,  11,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,
   0,   0,  37,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  25,   0,  10,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   4,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   9,   0,  11,   0,  11,   0,  11,  11,   0,   0,   0,   0,   0,
   0,   0,   0,   9,   0,   6,   0,   8,   0,   7,   0,   6,   0,  11,   0,   0,
   0,  11,   0,   0,  11,   0,   0,  11,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,  16,   0,   0,   7,   0,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,  16,
   0,  15,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,  38,   0,
  25,   0,  25,   0,   0,   0,  25,   0,   0,   0,   7,   0,   0,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,  38,   0,  25,
   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,
  10,   0,   0,   0,   0,   3,   0,  14,   0,  10,   0,   0,  14,   0,  14,   0,
  12,  10,   0,   0,   0,   9,   0,   0,   0,   4,   0,   4,   0,  10,   0,  10,
   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,
   9,   0,   0,   0,   0,   9,   0,   0,   0,   0,  38,   0,   0,   6,   0,   0,
   9,   0,   0,  18,   0,  18,   0,  18,   0,   0,   0,  18,   0,  18,   0,   0,
  18,   0,  18,   0,   0,  18,   0,   0,  18,   0,  18,   0,   4,   4,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,  11,   0,   0,  11,
   0,   0,   0,  11,   0,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   6,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  12,   0,  12,   0,  12,   0,   0,  12,   0,   0,   0,  12,   0,
   0,   0,   0,   0,   0,   0,  26,   0,   0,   0,   0,   0,  25,   0,   0,  26,
   0,  26,   0,  25,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,  13,   0,  13,   0,
   9,   0,   0,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,  25,   0,  25,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,
   0,   0,   0,  11,   0,   7,   0,   7,   0,   0,   0,   0,   9,   0,   0,   9,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,
   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,  34,   0,  38,   0,   0,  38,
   0,   0,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  12,   0,  13,   0,  11,   0,  11,   0,   0,  13,  12,   0,  16,   0,  17,   0,
  17,   0,   0,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,   0,  24,   0,
   7,   0,   0,  25,   0,  25,   0,  25,   0,   8,   0,   0,   0,   0,   8,   0,
   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  21,   0,  21,   0,  21,   0,  20,   0,  21,   0,  21,   0,   0,   0,
  21,   0,   0,  21,   0,  21,   0,  21,   0,  21,   0,   0,  21,   0,   0,  21,
   0,   0,  21,   0,   0,   0,   9,   0,   7,   0,   0,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,
   4,   0,  13,   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   0,  15,   0,   0,  15,   0,  15,   0,  15,
   0,  15,   0,  15,   0,   0,  15,   0,  15,   0,   0,   0,   0,   0,   0,   0,
   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,   0,  11,  11,   0,   0,   0,
   0,   4,   0,  38,   0,  38,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   4,   0,   0,   4,   0,   0,  25,   0,  25,   0,  25,   0,
  25,   0,   0,   0,  38,   0,   4,   0,   4,   0,  38,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,  38,   0,   0,  25,
   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  14,   0,  13,   0,  14,   0,
  14,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   9,   0,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,  25,
   0,  24,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,
   0,   0,   0,   0,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,
  19,   0,  19,   0,  19,   0,   0,   0,  17,   0,  26,   0,   0,   0,  26,   0,
   0,  26,   0,  26,   0,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  25,   0,  25,   0,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,  11,   0,  10,  11,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  13,   0,  13,
   0,  13,   0,  13,   0,   0,   0,  13,   0,  19,   0,  19,   0,  19,   0,  19,
   0,  19,   0,  19,   0,   0,  19,   0,   0,   7,   0,   7,   0,   0,   0,   7,
   0,   0,   7,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   7,   0,
   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,  11,   0,  11,   0,
   0,  11,   0,   0,  11,   0,   0,  38,   0,   0,  38,   0,  24,   0,  14,   0,
   0,   0,   0,  14,   0,   0,   0,   0,   0,  15,   0,  14,   0,  15,   0,  15,
   0,  15,   0,  15,   0,  14,   0,   0,  15,   0,   0,   0,   0,   7,   0,   0,
   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,  14,   0,  14,   0,  16,
   0,   0,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,
   5,   0,   7,   0,  24,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,
   0,  13,   0,  13,   0,  13,   0,   0,   0,  13,   0,   0,   0,  13,   0,   0,
  13,  13,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,   0,   0,   0,   0,
   0,   0,   0,   5,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   7,   0,
   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,   0,  25,   0,  11,   0,   9,   0,  11,   0,  11,  12,   0,   0,   0,
   0,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,   0,   0,   0,  16,   0,
  17,   0,   0,  17,   0,   0,   0,  17,   0,  17,   0,   0,  17,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,   9,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,  16,   0,  16,   0,
   0,  16,   0,  15,   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,   0,   0,
  16,   0,   0,   0,   0,   0,   0,  16,   0,   0,   9,   0,   9,   0,   0,   0,
   0,   9,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
  38,   0,  38,   0,  38,   0,   0,  38,   0,   0,   0,  12,   0,   0,   0,   6,
   0,   0,   5,   4,   0,   0,   0,   5,   4,   0,   0,   0,  24,   0,   0,   0,
  25,   0,   0,   0,  25,   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,  11,
  10,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,
   4,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,
  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,  26,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,  16,   0,  16,   0,   0,   0,  16,   0,   0,  16,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,  11,
   0,   0,   0,  11,   0,   9,   0,   9,   0,   0,   0,   0,   9,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  14,   0,  16,   0,  11,   0,  16,   0,  15,
   0,  16,  16,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  12,   0,  13,
   0,   8,   0,  13,  13,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   9,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   3,   0,   4,   5,   0,   0,   4,   0,   0,   0,   0,   0,   4,   5,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,
   0,   0,   9,   0,   0,   0,   0,   0,  25,   0,   0,   2,   7,   0,   0,   0,
  24,   0,   0,   0,   0,  12,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
  14,   0,   0,   0,   0,  14,   0,   7,   0,   7,   8,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   5,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   7,   0,   7,   0,  38,   0,
   0,   0,  38,   0,   7,   0,   7,   7,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   8,   0,   8,   0,   0,   0,   6,   0,   0,   4,   0,   4,
   0,  24,   0,   0,   0,   0,   0,   2,   7,   0,   0,   0,  20,   0,   0,   0,
   0,   8,   0,   6,   8,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  24,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   9,   0,   0,   0,  11,   0,  11,   0,  11,  11,   0,
   4,   4,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  27,   0,  27,   0,  27,   0,  26,   0,   0,   0,  27,   0,  27,   0,   0,
   0,  27,   0,   0,  27,   0,  27,   0,  27,   0,   0,   7,   0,  25,   0,  25,
   0,  25,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,
   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   9,   0,   0,   0,   0,   9,
   0,  24,   0,   8,   0,   0,   0,   8,   0,   0,   0,   8,   0,   0,   0,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,   0,
   0,  12,   0,  12,   0,  12,  11,   0,   0,   0,   0,   9,   0,   0,   4,   4,
   0,   5,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,   0,  12,   0,   0,  12,
   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,
   0,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,  11,   0,  11,  11,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  13,   0,  13,   0,   0,  13,   0,  13,   0,   0,   0,  13,   0,   0,
  13,   0,   0,   0,   0,   0,   5,   0,   0,   0,  38,   0,   0,  38,   0,   0,
   0,   0,  38,   0,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,
   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,   0,   0,  11,
   0,  11,   0,   0,   0,  11,   0,   0,   4,   0,   0,   4,   0,   0,   0,  38,
   0,   0,  38,   0,   9,   0,   9,   0,   0,   0,   9,   9,   0,   7,   0,   7,
   0,   7,   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,
   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   7,
   0,   7,   7,   0,   0,  14,   0,   0,   0,  14,   0,   0,   0,   0,   0,   0,
  24,   0,   0,   0,  19,   0,   0,   7,   0,   7,   8,   0,   7,   0,   7,   7,
   0,   4,   4,   0,   0,  38,   0,   0,  24,   0,   0,   7,   0,   0,   0,   0,
   0,   0,   7,   0,  14,   0,  13,   0,  13,   0,   0,  14,   0,   0,  14,   0,
  14,   0,   0,  14,   0,  14,   0,  24,   0,   8,   0,   8,   0,   0,   8,   0,
   0,  37,   0,   0,  14,   0,   0,   0,   0,   0,  14,   0,  24,   0,   0,   0,
  38,   0,   0,   0,  24,   0,   0,  24,   0,  12,   0,   0,   0,  13,   0,   0,
  13,   0,   0,  13,   0,   0,   0,   0,   0,  13,   0,   0,  38,   0,   0,   0,
  37,   0,   0,  38,   0,   0,   0,  10,   0,   8,   0,   0,  10,   0,   0,  16,
   0,   0,  19,   0,   0,  21,   0,   0,   0,  22,   0,   0,  21,   0,   0,  22,
   0,  29,   0,   0,  29,   0,  29,   0,  29,   0,  29,   0,   0,  29,   0,  29,
   0,   0,   0,  24,   0,   0,   0,   0,  11,   0,   0,  12,   0,   0,  26,   0,
   0,  17,   0,   0,  20,   0,   0,  26,   0,  25,   0,  26,   0,  24,   0,  26,
   0,   0,   0,  26,   0,  26,   0,  24,   0,  26,   0,  26,   0,  26,   0,  26,
   0,  26,   0,  18,   0,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,   0,
  26,   0,   0,  26,   0,  14,   0,   0,   0,   0,  14,   0,  14,   0,   0,  15,
   0,  18,   0,  19,   0,  17,   0,  21,   0,  23,   0,  21,   0,  23,   0,  23,
   0,  23,   0,  23,   0,   0,  23,   0,  22,   0,  11,   0,  11,   0,  10,   0,
  11,  11,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,  11,   0,  11,
   0,   0,   0,  11,   0,   0,  11,   0,   0,  11,   0,   0,  25,   0,   0,  25,
   0,   7,   0,   0,   0,   7,   0,   7,   0,   0,  25,   0,  25,   0,   0,   0,
   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   5,   0,   0,   0,   0,
   0,  24,   0,   0,   0,   0,   0,  12,   0,  12,   0,  24,   0,   0,   0,   0,
  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   0,   0,   0,   7,   7,   0,   0,   0,  25,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  13,   0,  10,   0,  12,   0,
  14,  14,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  10,   0,  10,   0,   7,  11,   0,   0,   0,   0,   0,   0,  14,   0,  15,
   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,   0,  15,  15,   0,   0,
   0,   0,   7,   0,   0,   7,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,
  11,   0,  11,   0,  11,   0,   0,  11,   0,   0,  16,   0,  16,   0,   0,   0,
   0,  16,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,  10,   0,   0,   0,  10,   0,   0,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,
   0,   3,   0,   4,   5,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   5,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  11,   0,  10,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,
   6,   0,   7,   0,   7,   0,   7,   0,   4,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   4,   0,   4,   0,   0,   4,   5,
   0,   0,   0,   0,   0,   0,   9,   0,  10,   0,   0,  10,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,
   0,   6,   3,   0,   6,   0,   0,   0,   9,   8,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  11,   0,  11,   0,   0,   9,   0,   0,  11,   0,  24,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   8,   0,  10,   0,
   0,   0,  10,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,
   0,   8,  10,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,  12,   0,
  14,   0,  14,   0,  11,   0,  16,   0,  16,   0,  16,  16,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   8,   0,  10,   0,   8,  10,   0,   0,   0,   4,   4,
   0,   0,   0,   6,   0,   8,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,
   0,   0,   5,   4,   0,   5,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   3,   5,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,  10,   0,  10,   9,   0,
   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   0,   4,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   4,   0,   7,   0,   0,   8,   7,   0,  25,   0,   0,  24,
   0,  25,   0,   0,  25,   0,   0,   0,  24,   0,   0,   4,   0,   0,   4,   0,
   0,   0,   0,  38,   0,  37,   0,  37,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   5,   0,  24,   0,   0,   0,   0,   0,  25,   0,   9,   0,
   6,   7,   0,   0,   0,   0,   7,   0,   7,   7,   0,   5,   4,   0,   5,   0,
   4,   0,   0,   0,   0,  10,   0,   0,  10,   0,   0,   0,  25,   0,   0,   0,
  25,   0,   0,   0,   0,  10,   0,   9,   0,   0,   0,   0,  10,   0,   4,   5,
   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,
   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   4,   4,   0,   4,   4,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  11,   0,  15,   0,  15,   0,  15,   0,  14,   0,  15,   0,
   0,   0,  15,  15,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,  13,
   0,  14,   0,  14,   0,  13,   0,  15,   0,  15,   0,   0,   0,  15,  15,   0,
  38,   0,   0,   0,   0,  24,   0,   0,   5,   0,   3,   0,   8,   0,   6,   8,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,   0,   0,  11,   0,
  11,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,
   4,   0,   0,   0,  38,   0,   0,  37,   0,   0,   0,   0,   0,   0,   0,   0,
   5,   3,   0,   0,   0,   0,   0,   0,   7,   0,   8,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   0,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,
   7,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   4,   5,   0,   0,
  38,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   0,   0,  13,
   0,  14,   0,  14,   0,  11,   0,  13,   0,  14,  14,   0,   0,   0,   0,   0,
   0,   0,  24,   0,  11,   0,  11,   0,   0,   0,  11,   0,   0,   0,  11,  10,
   0,   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,  38,   0,  38,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,  11,  11,
   0,   0,   0,   0,   0,   0,   0,  24,   0,  25,   0,   0,  25,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,  15,
   0,   7,   0,   0,   0,   0,   7,   0,   8,   0,   0,   8,   6,   0,   0,   0,
   0,   0,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,
   5,   4,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   7,   0,   7,
   7,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   0,   0,  11,   0,   8,   0,  11,   8,   0,   9,   0,   0,
   5,   0,   0,   0,   0,   0,   0,  10,   0,   0,   0,  10,   0,   7,  10,   0,
   0,   0,   4,   0,   4,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,
   0,   3,   0,  12,   0,   0,   9,   0,  24,   0,  23,   0,  25,   0,  25,   0,
   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   9,   0,   0,   0,  25,   0,
  25,   0,   0,  25,   0,  38,   0,   0,   0,   0,   0,   0,   0,  24,   0,   8,
   0,  10,   0,   0,  10,  10,   0,   0,   0,   0,   0,   0,   6,   0,   8,   8,
   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,
   0,  15,   0,  15,   0,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,
   0,   0,   0,   9,   0,   9,   9,   0,   0,  24,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,
   0,   7,   7,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  25,   0,   0,  25,   0,   0,   4,   4,   0,   0,   0,  10,   0,   0,   0,
  10,   0,   0,   0,   0,   0,   0,   9,   0,  11,   0,  11,   0,  11,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,  15,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  16,   0,   0,   0,   0,   0,  16,   0,   0,   0,   4,   4,   0,   0,   0,
   8,   0,   0,  11,   0,   0,  15,   0,   0,   0,  15,   0,  17,   0,  17,   0,
  18,  18,   0,   0,   0,  24,   0,  21,   0,  26,   0,  24,   0,  23,   0,  26,
   0,  26,   0,  26,   0,  21,   0,   4,   0,   0,   9,   9,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,
   0,   0,   4,   0,  25,   0,   0,   0,   0,   0,  19,   0,   0,   0,   0,   0,
   0,   6,   0,  10,   0,  10,   0,   9,   0,   0,  10,   0,  10,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   6,   0,   0,   0,   8,   8,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   5,   0,   0,   5,   0,   0,   0,  25,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,
   0,   0,   5,   0,   4,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,  25,
   0,  11,   0,  10,   0,  11,   0,  11,  11,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   0,   0,   9,   9,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   5,   4,   0,   0,   0,   5,   4,   0,   0,   0,  38,   0,  38,
   0,   0,  38,   0,   0,   0,  26,   0,   0,   0,  26,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,   0,   0,  11,   0,  10,   0,  11,   0,   0,
   0,   0,   0,  38,   0,   0,  37,   0,  11,   0,  11,   0,   0,  11,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,
   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,   8,   0,
   3,   0,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,  12,   0,   0,  12,   0,   0,
   0,   0,   0,  24,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,   9,   0,  11,   0,
   9,  13,   0,  24,   0,   0,   0,  13,   0,   0,   0,  13,   0,  13,   0,  13,
   0,   0,  13,   0,   8,   0,   0,   0,   0,   8,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,
   9,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,  38,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   6,   0,   0,   0,
   0,   0,   0,  12,   0,   9,   0,  16,   0,  15,   0,  17,   0,   0,  17,   0,
   0,   0,  17,   0,   0,   0,   7,   0,   0,   8,   0,   7,   0,   0,  14,   0,
   0,   0,   0,   0,   0,   0,   5,   0,   4,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   4,   0,   0,   0,   0,   0,   0,  10,   0,   0,   0,   0,  10,   0,
   0,  10,   0,   8,   0,  25,   0,  23,   0,  38,   0,  36,   0,   4,   0,   5,
   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,
   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   5,   0,   0,  14,   0,  14,
   0,  14,   0,   0,   0,   0,  14,   0,   0,   0,  12,   0,  13,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,
  14,   0,   5,   0,   0,   0,   0,   0,   0,  24,   0,  24,   0,   0,  25,   0,
  25,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,  36,   0,   0,   0,
   0,   0,  37,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,  15,   0,  15,
   0,   0,  14,   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   7,   7,   0,   8,   0,   0,   0,   0,   8,   0,   0,   0,   0,   0,  15,
   0,  13,   0,   0,   0,   0,  25,   0,  24,   0,   0,   0,  25,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   8,   0,   8,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  18,   0,   0,  18,   0,  18,   0,  18,
   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,  18,   0,  18,   0,  18,   0,
  18,   0,  18,   0,  18,  18,   0,   0,  15,   0,   0,   0,   0,  11,   0,  11,
   0,  11,   0,   0,   0,  11,  11,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,   0,   0,  25,
   0,   0,   0,   0,  15,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,  25,
   0,  25,   0,   0,  16,   0,   0,   0,   0,  16,   0,   7,   0,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  19,
   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,   0,  19,   0,   0,
   0,  19,   0,  19,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,
  14,   0,  38,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,   0,   0,
   4,   0,  26,   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,   0,
   0,  16,   0,  16,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
  15,   0,   0,   0,  25,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,  12,   0,  12,   0,  15,   0,  12,   0,  15,   0,  16,   0,  16,
  16,   0,   0,   0,   0,   0,   0,   4,   0,   9,   9,   0,   0,   0,   0,   0,
   0,  14,   0,  11,   0,  15,   0,   0,  15,   0,  15,   0,  15,   0,   0,   0,
  15,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   0,  18,   0,
  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  17,   0,  18,   0,  18,   0,
  18,   0,  18,   0,  18,   0,   0,  18,  18,   0,   0,   0,   0,   0,   0,   0,
  11,   0,   0,   0,  11,   0,   0,   0,  11,   0,   0,  11,  11,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   9,   9,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,
  15,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   4,   4,   0,   0,   0,   0,  13,   0,   0,  13,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   3,   0,   0,   6,   3,
   0,   0,   0,   0,   7,   0,   7,   0,   4,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,   9,
   0,   9,   0,   0,   0,   8,   0,  13,   0,  13,   0,   0,  13,   0,  13,   0,
   0,   0,   0,  13,   0,   0,   0,  13,   0,  13,   0,   0,   0,   0,   0,  13,
   0,   0,   0,  36,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,
  24,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   5,   0,   0,   0,   9,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,  11,   0,  16,
   0,  16,   0,  16,   0,   0,   0,   0,   0,  15,   0,   0,   0,   0,  16,   0,
  16,  16,   0,   0,   0,   0,   0,  10,   0,  10,   0,  11,   0,  11,  11,   0,
   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,   0,  11,   0,  11,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   8,   0,   0,   0,   0,  26,   0,   0,   0,  26,   0,   0,   0,   0,   4,
   0,   0,   0,   4,   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   4,   4,
   0,   0,   0,  12,   0,   0,  12,   0,   0,   0,   0,   0,  25,   0,  25,   0,
   0,  25,   0,   9,   0,   0,   9,   0,   0,   9,   0,   0,   4,   0,   0,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,   0,  11,
   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   7,   0,   0,
   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   8,   0,  11,   0,  12,   0,  12,  12,   0,   0,   0,  14,   0,
  14,   0,  14,   0,  14,   0,  14,   0,   0,   0,  11,   0,   0,   8,   0,   0,
   8,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,
   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,  24,   0,  25,   0,  25,
   0,   0,  25,   0,  14,   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   7,   0,   7,   0,   0,
   0,   7,   0,   8,   0,   8,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,  16,   0,  16,
   0,   0,   0,  16,   0,  16,   0,  16,   0,   0,   0,  16,   0,  12,   0,  12,
   0,   0,  12,   0,   0,  12,   0,   0,   0,   0,  12,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,
   0,   0,  11,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  26,   0,   0,  26,   0,   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,
  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,   0,  25,   0,   0,
   0,  25,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,
   0,  25,   0,   0,   0,   0,   0,   8,   0,   0,   0,   0,   8,   0,   0,   0,
   0,   0,   0,   8,   0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   4,   0,
   0,   4,   0,   0,  14,   0,  13,   0,   0,  14,   0,  14,   0,  14,   0,  14,
   0,   0,  14,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,
   0,   0,   0,  25,   0,  24,   0,   0,   0,   0,   0,   0,  26,   0,  25,   0,
   0,   0,  26,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  10,   0,   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,   0,  10,   0,  12,   0,
   0,  12,   0,  12,  12,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,
   0,   0,   0,  11,   0,  11,   0,   0,   0,  11,   0,  11,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   5,   0,  11,   0,  11,   0,  11,   0,   9,
  11,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,
  11,   0,   0,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,   0,  19,   0,
  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,
   0,  19,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,
   0,   0,  13,   0,   0,  13,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,
   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,  38,   0,  38,   0,  38,   0,   0,  38,   0,  38,   0,  38,
   0,  38,   0,   0,   0,  38,   0,   0,   0,  38,   0,  38,   0,   0,   0,  38,
   0,   0,   0,  38,   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,   0,   7,
   0,   0,   7,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,
   0,  14,   0,  14,   0,  14,   0,  14,   0,  14,   0,  14,   0,  14,  14,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,   0,   0,   0,   0,  25,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   6,   0,
   0,   4,   4,   0,   0,   0,   0,   0,  23,   0,   0,   0,   0,  25,   0,  25,
   0,   0,   0,  25,   0,   0,   0,  12,   0,  12,   0,  11,   0,  12,   0,   0,
   0,  12,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  24,   0,  26,   0,
   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,   0,   0,   0,  26,
   0,  15,   0,   0,   0,  15,   0,   0,   0,   0,  15,   0,  15,   0,  15,   0,
   0,  15,   0,   0,   0,   0,   0,   0,  11,   0,   0,  11,   0,  11,   0,   0,
   0,   0,  38,   0,  38,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,  38,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,  25,   0,   0,   0,  25,   0,  25,   0,  25,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,  38,
   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,
   0,   0,  25,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   4,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,
   0,   0,   0,   3,   0,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,  25,
   0,  25,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,  17,   0,   0,   0,   0,  11,   0,   0,
  21,   0,  15,   0,   0,  20,   0,  21,   0,  21,   0,  20,   0,   0,   0,  24,
   0,  24,   0,  24,   0,  21,   0,  24,   0,  24,   0,  24,   0,  24,   0,  24,
   0,  24,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,  24,   0,  20,   0,
   0,  17,   0,  21,   0,   0,  21,   0,  21,   0,  21,   0,  21,   0,  17,   0,
  20,   0,  21,   0,  21,   0,  21,   0,   0,  20,   0,   0,  21,   0,   0,  21,
   0,  21,   0,  21,   0,   0,   0,   0,  19,  21,   0,   0,   0,   0,   7,   0,
   7,   7,   0,   0,   0,   0,   0,  10,   0,  11,   0,  11,   0,   0,  11,   0,
   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,   8,   0,   0,   0,   8,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,  13,   0,  13,   0,   0,  14,   0,  14,   0,   0,   0,  14,   0,  14,
   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,
  25,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,  25,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  12,   0,  12,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  12,   0,   0,  12,   0,  12,   0,   0,  12,   0,
   0,   0,  12,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,   0,
  11,   0,   0,  11,   0,   0,  38,   0,   0,   0,   0,   0,  38,   0,   0,   0,
   0,   9,   0,   9,   0,   0,   0,   9,   0,   7,   0,   0,   7,   0,  11,   0,
  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,
  10,   0,   8,   0,   0,   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  15,   0,  15,   0,   0,  15,   0,  15,   0,   0,  15,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  23,   0,   0,   0,  26,   0,
   0,   0,  12,   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   7,   0,  17,   0,   0,  17,   0,   0,   0,  17,   0,   0,  17,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   0,  25,   0,  27,   0,  23,   0,  27,   0,
  27,   0,  21,   0,  27,   0,  27,   0,  27,   0,   0,  27,   0,   0,  27,   0,
   0,   0,   0,   0,  27,   0,  15,   0,  16,   0,  16,   0,  15,   0,   0,   0,
   4,   5,   0,  26,   0,   0,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,   0,  13,   0,   0,
   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,  25,   0,   0,  25,   0,
   0,   0,   0,   0,  26,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  13,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  12,   0,   8,   0,  12,   0,   0,   0,  12,   0,   0,  38,
   0,  16,   0,   0,  16,   0,   0,  16,   0,   0,  16,   0,   0,   0,  16,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  24,   0,   7,   0,   7,   7,   0,   0,   0,
   0,   0,  24,   0,   8,   0,   0,   8,   0,   0,   9,   0,   0,   9,   0,   0,
   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,  13,   0,   0,   0,
  25,   0,   0,   0,  25,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,  18,   0,  18,   0,  16,   0,  18,   0,  18,   0,  18,   0,  18,
   0,   0,  18,   0,   0,  18,   0,   0,   0,   0,   0,  17,   0,   0,  18,   0,
   0,   0,  18,   0,   0,   0,   0,   0,   0,  18,   0,  15,   0,  15,   0,  15,
   0,  15,   0,   0,   0,  15,   0,  15,   0,  15,   0,  15,  15,   0,   0,   0,
   0,   0,   9,   0,   0,   0,   9,   0,   9,   9,   0,   0,   0,   7,   0,   0,
   7,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   7,   7,   0,   0,   0,   0,   4,   4,   0,   0,   0,  25,   0,   0,   0,
   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   7,   0,   0,
   0,   0,   7,   0,   0,   6,   0,   3,   0,  16,   0,   0,  16,   0,   0,   0,
   0,  16,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,
  15,   0,  15,   0,  15,   0,   0,   0,   0,   4,   0,   4,   0,   0,   4,   0,
   4,   0,  18,   0,   0,  11,   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,
  18,   0,  18,   0,   0,  18,   0,   0,   0,  18,   0,   0,  18,   0,   7,   0,
   0,   0,   0,   0,   7,   0,   7,   0,   7,   7,   0,   0,   0,   0,   9,   0,
   0,   9,   0,   0,   0,   0,   0,   9,   0,   0,   7,   0,   0,   0,   0,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  14,   0,  14,   0,   0,  14,   0,  14,   0,  12,   8,   0,   0,
   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   7,   0,   7,   0,   0,
   0,   0,   7,   0,  11,   0,  11,   0,   0,  11,   0,  11,  11,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
  15,   0,  15,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,  17,   0,  18,   0,
  18,   0,  18,   0,   0,   0,   0,   0,  18,   0,  18,   0,   0,  18,   0,  18,
   0,  18,   0,   0,  18,   0,  18,   0,   0,   0,   0,   0,   0,  10,   0,  10,
   0,   8,   0,   0,   0,   0,   0,   0,   0,  35,   0,   4,   5,   0,   0,   0,
   0,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,
   4,   0,   0,   0,   6,   0,   0,   0,   8,   8,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,
   7,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,  14,   0,   0,  12,   0,  15,
   0,   0,   0,  15,   0,  15,   0,  15,   0,   0,   0,   0,  15,   0,   0,   0,
  15,  15,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,  25,   0,
   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  17,   0,  17,   0,   0,  17,   0,   0,  17,   0,  17,   0,  16,
   0,  17,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   5,   0,   7,
   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,
   0,   0,  14,   0,   0,   0,  12,   0,  14,   0,  14,   0,  14,   0,  14,   0,
   0,   0,   0,  14,  14,   0,   0,   0,   0,   0,  13,   0,  14,   0,   0,   0,
  14,   0,   0,   0,   0,  14,   0,   0,  14,   0,   0,  14,   0,   0,  14,   0,
   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   9,   0,   9,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,
   0,   0,   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,  13,   0,  13,   0,   0,   0,  13,   0,
  13,  12,   0,   0,   0,   0,  10,   0,  10,   0,   0,   0,  10,   0,   7,   0,
   7,   0,   0,   0,   7,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,
   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  26,   0,  26,   0,  26,   0,  25,   0,  26,   0,   0,   0,  26,   0,   0,
  26,   0,   0,   0,   4,   4,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   8,   0,
  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   9,   0,   0,   9,   9,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,
   0,  16,   0,  16,   0,   0,   0,  16,   0,  26,   0,  26,   0,  26,   0,  26,
   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  12,   0,  12,   0,   0,   8,   0,  12,  12,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   9,   0,   9,   0,
   0,   9,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,  10,   0,   0,   0,
   9,   0,   0,  13,   0,  16,   0,  18,   0,  16,   0,   0,   0,  18,  18,   0,
   0,   0,  12,   0,  12,   0,   0,   0,  12,   0,  12,   0,   0,  12,  12,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   8,   0,   0,   0,   4,   0,
   0,   0,   4,   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  17,   0,  14,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,
  15,   0,  18,   0,  18,   0,  18,   0,  18,  18,   0,   0,   0,   0,   0,  26,
   0,  27,   0,   0,  27,   0,  26,   0,   0,  27,   0,  27,   0,  27,   0,  27,
   0,   0,  27,   0,  27,   0,   0,  27,   0,   0,   0,  13,   0,  13,   0,  12,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,
  25,   0,   0,   0,   0,   0,   0,   0,  37,   0,  12,   0,  12,   0,   0,  11,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,   9,   0,  13,   0,  13,   0,
  13,  13,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,  15,   0,
  14,   0,  14,   0,   0,  13,   0,  24,   0,   0,   0,   4,   0,   4,   0,   0,
   0,   5,   0,   4,   0,   0,   0,  12,   0,   0,  12,   0,   0,  12,   0,  12,
   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,
  11,   0,   0,   0,   4,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,  38,   0,
   0,  38,   0,   0,  38,   0,  11,   0,  11,   0,  11,   0,  11,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  38,   0,   0,  37,   0,  38,   0,   0,  38,   0,   0,   0,  38,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,
  25,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,
   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   9,   0,   0,   5,   0,  37,   0,   0,  38,   0,  35,   0,   0,
   0,  38,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  12,   0,   0,  18,   0,   0,  19,   0,  19,
   0,  19,   0,  19,   0,   0,  19,   0,  19,   0,  17,   0,  19,   0,   0,  19,
   0,  19,   0,  19,  19,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,
   0,   0,  11,   0,   0,  11,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  13,   0,  13,   0,  13,   0,  13,   0,   8,  13,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,  26,   0,  26,   0,   0,   0,  25,   0,  26,   0,  26,
   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,
   0,   0,   9,   0,  25,   0,   0,  25,   0,  25,   0,   0,   0,  25,   0,   0,
   0,   0,   0,  38,   0,   0,  38,   0,   0,  38,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   0,   0,   7,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,  38,   0,  24,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,   0,   0,
   0,  14,   0,   0,  14,   0,  25,   0,   0,  25,   0,   0,   0,   0,  25,   0,
  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   0,  25,   0,   0,   0,   0,   4,   0,   4,   0,   0,
   0,   0,   0,   0,  17,   0,  16,   0,  17,   0,  15,   0,  17,   0,  14,   0,
  17,   0,  17,   0,   0,  17,   0,   0,   0,  17,   0,  25,   0,  25,   0,   0,
   0,   0,   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,  11,   0,  25,   0,
   0,  25,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,  15,   0,   0,   0,   0,
  38,   0,  38,   0,  38,   0,  38,   0,   0,  38,   0,  38,   0,   0,  38,   0,
  37,   0,   0,  38,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,
   0,  11,   0,   0,  11,  10,   0,   0,   0,  37,   0,   0,  23,   0,   0,   0,
  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   3,   6,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   6,   3,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   7,   0,
   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  15,   0,
   0,  16,   0,  16,  15,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,   0,
  12,   0,   0,   0,   0,  12,  12,   0,   0,   0,   8,   0,   0,   8,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,  25,   0,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,  14,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,
   0,  15,   0,   0,  15,  15,   0,   0,   0,   8,   0,   0,   0,   8,   0,   0,
   0,   0,   0,  13,   0,  13,   0,  13,   0,  13,   0,   0,  13,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,  14,   0,
   0,   7,   0,   6,   0,   8,   8,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   5,   3,   0,   5,   3,   0,   0,   0,   0,   0,   0,   0,
   5,   0,   0,   7,   0,   0,   0,   0,   0,   0,   7,   0,  13,   0,  13,   0,
  13,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  10,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  10,   0,  14,   0,   8,   0,  15,   0,  13,   0,   0,  15,
   0,  11,   0,  11,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  24,   0,   4,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,
  14,   0,   8,   0,   0,   8,   0,   9,   0,   0,   9,   0,   0,   9,   0,   0,
   4,   4,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  25,   0,  25,   0,   0,   0,   0,   6,   0,   0,  25,   0,   0,  25,
   0,  15,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  17,
   0,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,   0,
   0,  12,   0,   0,  12,   0,  14,   0,  14,   0,   0,  14,   0,   0,  14,   0,
   0,  16,   0,   0,  16,   0,   0,   0,   0,   0,   0,  16,   0,   0,  16,   0,
   0,  16,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,
  25,   0,   0,   0,  25,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  15,   0,  15,   0,   0,   4,   4,   0,   0,   0,   4,   0,   0,   0,   4,
   0,  15,   0,   0,   0,   0,  15,   0,  15,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   4,   0,  38,   0,   0,   0,   0,   0,  25,   0,  25,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   8,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,   0,
  16,   0,  16,   0,  16,   0,  16,   0,   0,  16,  16,   0,   0,   0,   0,   0,
   0,   0,  10,   0,   0,  10,   0,   9,   0,   9,   0,   0,   0,   9,   0,   9,
   0,   9,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,
   0,  11,   0,  11,   0,   0,   0,   0,   0,  11,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,
   7,   0,   0,   0,  10,   0,   0,   9,   0,   0,  10,   0,  25,   0,   0,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,  15,   0,   0,  15,   0,   0,
   0,   0,   0,  15,   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,   0,   7,
   0,   4,   0,   0,   0,   4,   0,  18,   0,  18,   0,   0,  18,   0,  18,   0,
  18,   0,   0,  15,   0,  18,   0,  18,   0,  15,   0,  15,   0,  18,   0,   0,
   0,  18,  18,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,   0,  10,   0,  10,   0,
   0,   0,   0,   0,   0,   0,  26,   0,   0,  26,   0,  26,   0,   0,   0,   0,
  26,   0,  38,   0,   0,  38,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   7,   0,   8,   0,   0,   0,
   8,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,  14,   0,   0,   0,
   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,   0,
  16,   0,   0,  16,   0,   0,  16,   0,   0,   0,  16,   0,   0,   0,   0,  15,
   0,  15,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,
   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   7,
   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  14,   0,  14,   0,  12,   0,  14,   0,  14,   0,   0,   0,  14,   0,  14,
   0,  14,   0,  24,   0,   0,   0,   0,   9,   0,   0,   0,   9,   0,   0,   9,
   9,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,   0,
  25,   0,   7,   0,   7,   0,   0,   0,   4,   0,   0,   4,   0,   8,   0,   0,
   8,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   0,   0,   4,   0,  10,   0,   0,   8,   0,   0,   0,   9,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   8,   0,   0,   0,   0,
   8,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,  10,   0,  10,
  13,   0,   0,   0,  14,   0,  14,   0,  14,   0,   0,   0,  14,   0,   0,  14,
   0,   0,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,  11,   0,   0,
  11,   0,  11,   0,   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  16,   0,  19,   0,  19,   0,  19,   0,  18,   0,  19,   0,  19,   0,  19,   0,
   0,  19,   0,   0,  19,   0,   0,  19,   0,   0,   0,   0,   0,  19,   0,   0,
   0,  19,   0,   0,   0,   0,  19,   0,   0,  24,   0,   0,   8,   0,   0,   0,
   0,   6,   0,  16,   0,  17,   0,  17,   0,  17,   0,  17,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  15,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,  11,   0,   0,   0,  11,   0,  11,   0,   0,
   0,  11,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,   0,   0,  12,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,
   0,  10,   0,   0,   0,  10,   0,   0,   0,   9,   0,  25,   0,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  18,   0,  17,   0,  19,   0,  18,
   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,  19,   0,   0,   0,  19,   0,
  19,   0,   0,   0,  19,   0,   0,   0,  19,   0,  19,   0,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   8,   0,   9,   0,   0,  10,   0,   0,   0,   0,
   0,   0,   0,   0,  13,   0,  13,   0,  13,   0,   0,  13,   0,  13,   0,   0,
   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,
   0,   0,  12,   0,  14,   0,  14,   0,   0,  14,   0,  14,   0,  14,   0,  14,
  14,   0,   0,   0,   0,   0,   0,  14,   0,   0,  16,   0,  16,   0,   0,   0,
  16,   0,   0,   0,   0,   0,  23,   0,   0,  24,   0,   0,   0,  38,   0,  14,
   0,   0,   0,  14,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,   7,
   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,  24,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  12,   0,
  13,   0,  14,   0,   0,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,   0,
  14,   0,   0,   0,  11,   0,  14,   0,   0,   0,   0,  12,   0,  12,   0,   0,
  12,   0,  12,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  25,   0,   8,   0,   0,   0,   7,   0,   8,   0,   0,   0,   0,   0,   6,
   8,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,
   4,   0,   0,   4,   0,  17,   0,  14,   0,  19,   0,  19,   0,  18,   0,   0,
  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,  16,
   0,  16,   0,   0,   0,  16,   0,   0,  16,   0,   0,  16,   0,  16,   0,   0,
  16,   0,  16,   0,   0,   0,   0,  16,   0,  11,   0,  11,   0,  11,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,  17,   0,  15,   0,  17,   0,  17,   0,  17,   0,  17,   0,  16,   0,
   0,   0,  17,   0,  17,   0,   0,  17,   0,   0,  17,  17,   0,   0,   0,   0,
   0,   0,   0,  10,   0,  10,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,
   0,  10,   0,   8,   0,   0,   0,  10,   0,  38,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   3,
   0,  24,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,  11,   0,
   0,   0,  11,   0,  16,   0,  16,   0,   0,   0,  16,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,
   0,   0,   7,   0,  15,   0,   0,   0,   0,   0,  15,   0,  15,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   8,   0,   7,   0,  14,
   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,  11,   0,   0,   0,  16,   0,  15,   0,   0,  16,   0,  16,   0,
   0,  16,   0,   0,   0,   0,   0,  16,   0,  21,   0,  24,   0,   0,  36,   0,
   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   9,   0,   5,   0,   0,   0,
   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  10,   0,  10,   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,
  25,   0,  25,   0,  16,   0,   0,   0,  16,   0,   0,  16,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,   0,  14,   0,   0,
  14,   0,  14,   0,  14,   0,   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  12,   0,  12,   0,  16,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,
   0,  17,  17,   0,   0,   0,   0,   0,   0,   0,   4,   0,   9,   9,   0,   0,
   4,   0,   0,   4,   0,  11,   0,  12,   0,  13,   0,  13,   0,   0,  11,   0,
   0,   4,   5,   0,   0,   0,   0,   0,   8,   0,  10,   0,  10,   0,  10,   0,
   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   4,   0,   0,
   4,   0,   0,  38,   0,   0,  38,   0,  38,   0,  38,   0,   0,  38,   0,   0,
  37,   0,   9,   0,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   9,   0,   9,   0,   0,   4,
   0,   0,   4,   0,   0,   7,   0,   0,   0,   7,   0,  15,   0,   0,  15,   0,
  12,   0,   9,   0,  13,   0,  12,   0,   0,   0,  13,  13,   0,   0,   0,   0,
   9,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   5,   0,   0,   7,   0,   0,   7,   0,   6,   3,   0,   0,   0,
   0,   0,   0,   4,   5,   0,   0,   0,   6,   0,   0,   8,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   4,
   0,   4,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,   0,
  12,   0,  12,   0,  12,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   0,   7,   0,   7,   0,   8,   0,   0,   0,   0,   0,
   8,   0,  12,   0,  12,   0,   0,   0,   0,   0,   0,   0,  38,   0,  25,   0,
   0,  25,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  16,   0,  13,
   0,  16,   0,  17,   0,  17,   0,   0,  17,   0,  12,   0,   0,   0,  17,   0,
   0,  17,   0,   7,   0,   0,   7,   0,   0,   0,   4,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   5,   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   6,   0,   0,   0,   0,   8,   8,   0,   0,  38,
   0,   0,   0,   0,   0,   9,   0,  10,   0,   9,   0,  12,   0,  13,   0,  13,
   0,  13,   0,  13,   0,  13,  13,   0,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,   0,
  26,   0,  10,   0,  12,   0,  12,   0,   0,   0,   0,  12,   0,   0,   0,   9,
   0,   0,   4,   4,   0,   0,   0,   0,   0,  16,   0,  15,   0,  15,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  10,   0,   0,   0,
  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   5,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   2,   7,   0,
   0,   0,   0,   0,   0,   0,  15,   0,  16,   0,  16,   0,  16,   0,  16,   0,
  16,   0,   0,  16,   0,   0,  16,   0,  16,  16,   0,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   5,   0,  11,   0,
  11,   0,   0,  11,   0,   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   0,
  14,   0,   0,  13,   0,   0,  14,   0,   0,   0,  20,   0,   0,  17,   0,   0,
  22,   0,   0,  22,   0,  26,   0,  27,   0,  27,   0,   0,  27,   0,   0,  27,
   0,  27,   0,  27,   0,  27,   0,  10,   0,  11,   0,   0,   0,  11,   0,   0,
   0,  11,  11,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,  24,
   0,   0,   0,   9,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   8,   0,   0,   0,   5,   0,   0,   9,   0,   0,  15,   0,  18,   0,
   0,  20,  20,   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  20,   0,  22,   0,  20,   0,
  22,   0,  21,   0,  19,   0,  22,   0,  19,   0,  17,   0,  22,   0,  15,   0,
  21,   0,  22,   0,  23,   0,  23,   0,  23,   0,   0,  23,   0,   0,  23,   0,
  23,   0,  23,   0,   0,   0,  23,  23,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,  26,   0,  26,   0,  23,   0,  26,   0,  26,   0,  26,   0,   0,   0,
   0,   0,   0,  26,   0,   9,   0,   0,   9,   0,   9,   9,   0,   0,   0,   0,
   0,   0,  38,   0,   0,  37,   0,   0,   0,   0,   0,   0,   4,   0,   7,   0,
   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,
   8,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   5,   8,   0,   0,   0,
  24,   0,   0,   0,   0,   3,   5,   0,   0,   0,   5,   4,   0,   0,   0,   0,
   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,  17,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  16,   0,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,
   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,  24,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,
   0,  13,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,
   0,   0,   0,   0,  10,   0,  14,   0,  14,   0,  14,   0,  14,   0,  14,  14,
   0,   0,   0,   0,   0,   6,   0,   8,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   8,   0,   0,   0,   4,   0,   0,   0,   4,   0,   4,
   0,   5,   0,   0,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  38,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   0,   0,   0,   4,   0,   4,   4,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  11,   0,  11,   0,
  11,  10,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  11,
   0,   0,   0,  11,   0,  11,  11,   0,   0,   0,   0,   0,   0,  24,   0,  25,
   0,  25,   0,   0,   0,  24,   0,  14,   0,  15,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,   0,  38,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,  25,   0,   0,  25,   0,  16,   0,   0,
   0,  16,   0,  14,   0,  14,   0,   0,   0,  14,   0,  14,   0,   0,   0,   0,
   0,   0,   0,   0,  14,   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  11,   0,  13,   0,  13,   0,
  13,   0,  13,  13,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   7,   0,   7,   0,   0,   0,  38,   0,   0,   0,  38,   0,
  38,   0,   0,  38,   0,   0,   0,   6,   0,   0,   8,   8,   0,   0,   0,   0,
   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   0,  10,   0,  11,   0,   0,  10,   0,
  10,   0,   0,   0,  10,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   5,
   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   3,   6,   0,   0,   0,   0,  12,   0,  12,   0,   0,  11,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,  38,
   0,   0,  38,   0,   0,  10,   0,   9,   0,  10,   0,   0,   0,   0,   0,   7,
   0,   0,   7,   0,   7,   0,  25,   0,  25,   0,  25,   0,  25,   0,  25,   0,
   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,
   0,   0,   9,   0,   9,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,
   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   5,
   0,   9,   9,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   6,   3,
   0,   0,   0,   0,   3,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  24,   0,  13,   0,  10,   0,  15,   0,  15,   0,   0,   0,   0,
   0,   0,   0,   6,   3,   0,   6,   3,   0,   0,   3,   0,   6,   0,   0,   0,
   4,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   4,   0,   0,   0,   0,   0,
   0,  11,   0,  10,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,
  25,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,  25,   0,  17,   0,   0,   0,   6,   0,   0,   0,
  10,   0,   7,   0,   8,   0,   0,   0,   0,   0,   8,   0,   4,   5,   0,   5,
   4,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,  14,
   0,   0,   0,   0,  14,   0,  11,   0,  11,   0,  11,   0,   0,   9,  11,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,  24,   0,  38,   0,  25,
   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   9,   0,   0,   0,   0,   0,
   9,   0,   0,   9,   0,   0,   9,   0,  16,   0,   0,   0,  16,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  17,
   0,  20,   0,  20,   0,  20,   0,   0,  21,   0,  21,   0,  20,   0,  21,   0,
  17,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,
  20,   0,  21,   0,  21,   0,   0,   0,   0,   0,   0,  15,   0,   0,  16,   0,
  15,   0,  13,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,   0,
   0,   4,   4,   0,  38,   0,   0,  38,   0,   0,   4,   0,   0,   0,   4,   0,
   0,   0,   0,   0,   0,   8,   0,   0,   9,   0,   0,   9,   0,   0,  38,   0,
   0,  38,   0,   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   4,   0,  12,   0,  12,   0,  12,   0,   0,   0,  12,   0,   0,
   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  12,   0,  12,   0,   0,   0,  12,   0,  12,   0,   0,  12,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,
   0,   0,   0,   6,   0,   8,   8,   0,   0,   0,   0,   0,   0,   5,   4,   0,
   5,   4,   0,   0,   0,  36,   0,   0,  24,   0,   0,   0,   0,   0,   3,   6,
   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  11,   0,  12,   0,  12,   0,  12,   0,  12,  12,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,
   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   0,   7,   7,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,
  25,   0,   0,   0,   4,   4,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   9,   0,  10,   0,
   8,  10,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   9,   0,
   0,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   4,   5,   0,   7,
   0,   7,   0,   0,  12,   0,   0,  12,   0,  25,   0,   0,  25,   0,   0,   0,
   0,  24,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,   8,   8,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,  25,   0,  25,
   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   9,
   0,   0,   0,   0,   9,   0,   0,   8,   0,   6,   8,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,
   7,   0,   0,   0,   0,   0,   0,   4,   4,   0,   4,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,  17,
   0,  17,   0,  17,   0,  17,   0,   0,  17,   0,  17,   0,   0,  17,   0,  17,
   0,   0,   0,   0,  17,   0,  17,   0,  17,  17,   0,   0,   0,   0,   0,  11,
   0,   0,   0,   0,  11,   0,  11,   0,  11,  11,   0,   0,   0,   0,   0,   7,
   0,   7,   7,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,
   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,  11,   0,   0,  11,  11,   0,
   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,   7,   0,  24,   0,   0,   0,
   0,   0,   4,   5,   0,   0,   0,  24,   0,  25,   0,  25,   0,   0,  25,   0,
   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  10,   0,   0,  11,   0,   0,  11,  11,   0,
   4,   4,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,
  11,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,  10,
   0,   0,  10,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   5,   4,   0,
   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   4,
   0,   0,   0,   0,   8,   0,   0,   0,   8,   0,   4,   4,   0,   0,   0,   0,
   0,  11,   0,   6,   0,  10,  11,   0,   0,   0,   0,   0,   4,   0,   4,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   3,   0,   0,   0,  24,   0,   0,   0,  25,   0,  24,   0,   0,   0,  15,   0,
  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,
  25,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  15,   0,   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   7,   0,
   7,   7,   0,   0,   0,   4,   0,   4,   0,  24,   0,   0,   0,   0,   0,   4,
   0,   4,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   7,   0,   7,
   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,
   5,   4,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   7,   0,
   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  16,
   0,  14,   0,  16,   0,  16,   0,  15,   0,  17,   0,  17,   0,  17,   0,  17,
   0,   0,  17,   0,   0,  38,   0,  25,   0,  25,   0,   0,   0,   0,  38,   0,
   6,   0,   0,   0,   0,   0,   0,   0,  14,   0,  15,   0,  15,   0,   0,  15,
   0,   0,  15,   0,  15,   0,  15,   0,   0,   0,  11,   0,  11,   0,   0,  11,
   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   0,   4,   0,   0,  12,   0,  11,   0,  12,   0,  12,   0,   0,  12,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   5,   0,   0,   0,   0,   0,   0,
   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,  15,
   0,  15,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   5,   4,   0,   5,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  37,
   0,   0,   0,   0,   0,   7,   0,   7,   0,   7,   0,  10,   0,   0,   0,  10,
   0,   0,   0,   0,  10,   8,   0,   0,   0,  24,   0,   0,   3,   0,   0,   0,
   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,
   0,  24,   0,  16,   0,  17,   0,  17,   0,  16,   0,  17,   0,  17,   0,   0,
   0,  17,   0,  17,   0,  17,   0,  17,   0,   0,   0,  17,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  38,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   5,   0,   0,   0,   0,   0,   0,  37,   0,  24,   0,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,
   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,  17,   0,  20,   0,   0,
  21,   0,  20,   0,  20,   0,  21,   0,  17,   0,   0,   0,  18,   0,  21,   0,
  21,   0,  21,   0,   0,  21,   0,  21,   0,  21,   0,  21,   0,   0,   0,   0,
  21,  21,   0,   0,   0,   0,  19,   0,   0,   0,  13,   0,  19,   0,  19,   0,
  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,   0,  17,   0,  19,
   0,  19,   0,  19,  19,   0,   0,   0,  16,   0,  17,   0,  17,   0,  17,   0,
  17,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,   0,   0,   0,   0,  17,
  17,   0,   0,   0,   9,   0,   0,   0,   9,   0,   0,   0,   9,   9,   0,   0,
   7,   0,   0,   0,   7,   0,   4,   4,   0,   0,   0,   0,   0,  25,   0,  25,
   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,
   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,   0,
   0,  15,   0,   0,   0,   0,  24,   0,   9,   0,   9,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,  11,   0,   0,   0,  11,   0,
  11,   0,  11,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,
   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  17,   0,  17,   0,  17,   0,
  17,   0,   0,   0,   0,  17,   0,   0,   0,  17,   0,   0,  17,   0,   0,   0,
  17,   0,  16,  17,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,
  14,   0,  15,   0,  14,   0,   0,  15,   0,   0,   0,   0,  15,   0,   9,   0,
   5,   8,   0,   0,   0,   4,   5,   0,   0,   0,   0,   0,   8,   0,   0,   8,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  38,   0,   0,   0,  14,   0,   0,  15,   0,  15,   0,   0,  15,   0,
   0,   4,   5,   0,   0,   0,  11,   0,  38,   0,  38,   0,   0,  37,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  12,   0,  12,   0,   0,  12,   0,  12,   0,  12,  12,   0,   0,   0,   0,
   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  11,   0,   0,  11,   0,   0,  11,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,
   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   0,   0,  12,   0,   0,   0,  12,   0,  12,   0,   0,
  12,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   4,   0,   0,   0,   0,   0,   0,  12,   0,   0,   0,  12,   0,  12,   0,   0,
  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  15,   0,  15,   0,   0,   0,  14,   0,  14,   0,  15,   0,  15,   0,  15,
  11,   0,   8,   0,  12,   0,   0,   0,   0,   0,  12,   0,   0,   0,   6,   0,
   3,   0,   0,   0,   0,   4,   4,   0,  11,   0,  11,   0,  11,   0,  11,  11,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   4,   0,   0,   0,   4,   0,
   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,
  25,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,   0,
   0,   0,   0,  25,   0,   0,   0,   0,  12,   0,  25,   0,  25,   0,  25,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   8,   0,
   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,  38,   0,  38,   0,   0,  38,
   0,   0,   0,   0,   0,   0,  12,   0,   0,   0,  12,   0,  12,   0,  12,   0,
   0,  12,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,  13,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  16,   0,  16,   0,  16,   0,   0,
   0,   0,  16,   0,   0,   0,   0,   0,  16,   0,   0,  16,   0,  16,   0,  16,
   0,  16,   0,   0,  16,   0,  16,   0,   0,   0,   0,  14,   0,  16,  16,   0,
   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,   0,  12,   0,  12,   0,
   0,   0,  12,  12,   0,   0,   0,   0,   0,   0,  14,   0,  14,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  17,   0,   0,  17,   0,  17,   0,  17,   0,
   0,   0,  17,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,  25,   0,  25,   0,   0,
  25,   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,
   0,   4,   4,   0,   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,  25,
   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  18,   0,  18,   0,  17,   0,  18,   0,  18,   0,  18,   0,
  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,  18,   0,   0,  18,   0,
  18,   0,   0,   0,   0,   0,   0,  14,   0,  14,   0,  14,   0,  14,   0,   0,
  14,   0,  14,   0,   0,  14,   0,   0,   4,   4,   0,   0,   0,   0,   0,  11,
   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,  25,   0,   0,   0,  25,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,  24,
   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   8,   0,  10,  10,   0,   0,
   0,   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,  26,   0,   0,
  38,   0,   0,   0,  38,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,
  26,   0,   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,  11,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,  13,   0,   0,
  13,   0,   0,  13,   0,   0,   0,   0,  13,   0,   9,   0,   0,   0,   9,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,  10,   0,
   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   5,
   0,   8,   0,   0,   0,   0,   0,   8,   0,   7,   0,   0,   7,   0,   0,   0,
   0,   0,   0,   0,  13,   0,   0,  14,   0,  14,   0,   0,   0,  14,   0,  11,
   0,  11,   0,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,   0,   0,   0,  12,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  11,   0,   0,   0,
  12,   0,   0,   0,   0,  12,   0,   0,   0,  12,   0,   0,   0,  12,  12,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,  38,   0,
   0,   0,  38,   0,  37,   0,   0,  38,   0,   0,   0,   4,   0,   4,   0,   0,
   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,
   0,   0,   0,   4,   0,   0,   9,   0,   0,   0,   0,   0,  12,   0,  12,   0,
   0,   0,   0,   0,  12,   0,  38,   0,  38,   0,  37,   0,   0,  36,   0,   0,
  38,   0,  25,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  16,   0,   0,  16,   0,  16,   0,   0,  16,   0,
  16,   0,  16,   0,  16,   0,  14,   0,   0,  15,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   9,   9,   0,
   0,   0,   0,   0,  15,   0,   0,  15,   0,   0,  15,   0,   0,   0,   0,  11,
   0,  11,   0,   0,  11,   0,  11,  11,   0,   0,  38,   0,   0,  24,   0,   0,
   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,
  25,   0,  16,   0,   0,   0,  16,   0,  38,   0,   0,   0,   0,   0,   0,   0,
   0,  26,   0,   0,  26,   0,  38,   0,   0,   0,   0,   0,  38,   0,   0,   0,
   0,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  12,   0,   0,   0,  21,   0,  21,   0,  17,   0,  21,   0,  22,   0,  22,
   0,  22,   0,  22,   0,  22,   0,  15,   0,  22,   0,   0,  22,   0,   0,   0,
  22,   0,  22,   0,  22,   0,   0,   0,   0,  22,   0,  22,  22,   0,   0,   0,
   0,   0,  17,   0,  18,   0,  19,   0,  16,   0,  20,   0,  21,   0,  21,   0,
  21,   0,  20,   0,  21,   0,  21,   0,   0,  21,   0,  21,   0,  21,   0,  21,
   0,   0,   0,   0,  21,   0,   0,   0,  21,   0,   0,   0,  21,  21,   0,   0,
   0,   0,   0,   0,   9,   0,  13,   0,  13,   0,  13,   0,  13,  13,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,  10,   0,   9,   9,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,  24,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   4,   0,   0,   0,   4,   0,   7,   0,   0,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  17,
   0,  17,   0,  13,   0,   0,   0,   0,  17,   0,  17,   0,  17,   0,  17,   0,
  17,   0,  17,   0,   0,  17,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   8,   0,   8,   6,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,   9,   0,   9,   0,  10,
  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   6,   0,
  24,   0,   0,  25,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,  11,
   0,   4,   5,   0,   0,   9,   0,   0,   0,  25,   0,   0,  25,   0,   0,  25,
   0,   0,   0,  25,   0,   0,  15,   0,  15,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   7,   0,   0,   0,   7,   0,   8,   0,   0,   0,  13,   0,  13,   0,
  13,   0,  13,  13,   0,   0,   0,   0,   8,   0,   9,   5,   0,   0,   0,  25,
   0,   0,  25,   0,   0,   0,   0,   0,   0,   5,   4,   0,   7,   0,   0,   0,
   8,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  24,   0,
  25,   0,   0,   0,   0,   0,  25,   0,   4,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   8,   0,   0,   0,   5,
   4,   0,   0,   0,   5,   4,   0,   0,   0,   5,   0,   4,   0,   0,   0,  24,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,   0,  10,   0,  10,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,  18,   0,  18,   0,  18,
   0,  18,   0,  17,   0,  18,   0,  18,   0,  18,   0,   0,  18,   0,   0,  18,
   0,   0,   0,  18,   0,   0,   0,   0,  18,   0,   0,  18,   0,   9,   0,   9,
   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   7,   0,   0,   7,   0,  13,   0,  13,   0,   0,  13,   0,
  13,   0,  13,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,
   0,  11,   0,  11,   0,  11,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,
  10,   0,   0,   0,   0,   0,   9,   0,   0,   9,   0,   0,   9,   0,   0,   0,
   0,   0,  26,   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,  26,
   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  24,   0,   7,   0,   7,   0,   9,   0,   9,
   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,
   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   8,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  12,   0,  16,   0,   0,  17,   0,   0,   0,   0,
  17,   0,  17,   0,  17,   0,  17,   0,   0,   0,  17,   0,   0,   0,  17,   0,
   0,   5,   0,   0,   0,   0,   0,   0,   9,   0,   0,  11,   0,  10,   0,   0,
   0,   0,  11,   0,   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  25,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  11,   0,
  11,   0,   0,  11,   0,   0,  10,   0,  10,   0,   8,   0,   0,  10,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,  26,   0,  26,   0,
  26,   0,   0,  26,   0,  26,   0,   0,  26,   0,   0,   0,  26,   0,  25,   0,
  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  38,   0,  38,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,  14,   0,   0,   0,  14,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,
  12,   0,   0,  12,   0,  12,   0,  25,   0,   0,   0,  25,   0,   7,   0,   0,
   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,
  11,   0,  11,   0,  11,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  14,   0,  14,   0,  14,   0,  14,   0,  14,   0,   0,   0,   0,   0,   9,
   0,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   4,   0,   0,   0,   0,   2,   8,   0,   0,   0,   0,   0,   0,
  31,   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,
   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   9,   0,  15,   0,   0,  15,   0,  21,   0,   0,  21,   0,  18,   0,
  22,   0,  20,   0,   0,  20,   0,  22,   0,  21,   0,  22,   0,  22,   0,  22,
   0,  22,   0,   0,   0,  21,   0,  22,   0,  22,   0,  20,   0,   6,   0,   0,
   8,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,  37,   0,  38,   0,   0,
  38,   0,  38,   0,   0,  37,   0,   0,   0,   0,   0,  15,   0,  13,   0,  10,
   0,   0,  14,   0,  15,   0,  15,   0,   0,   0,   0,  15,   0,  15,   0,   0,
   0,   0,   0,   0,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,   0,  17,
   0,  17,   0,   0,  17,   0,  17,   0,  17,   0,  17,  17,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,  24,   0,
   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   8,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   0,   4,   0,   0,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  17,   0,  17,   0,  17,   0,  15,   0,   0,  15,
   0,  15,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,
   0,   0,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,  25,
   0,   0,   0,  25,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,  12,   0,
  12,   0,   7,   0,   0,  12,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   8,   0,   0,   7,   0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,
  15,   0,   0,  14,   0,  15,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,  13,   0,  14,   0,   0,   0,   0,   0,  17,   0,  17,   0,   0,  17,   0,
  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,
  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,   0,  19,   0,   0,  19,
   0,  19,  19,   0,   0,   0,   0,   0,   0,   4,   4,   0,  38,   0,   0,   0,
  38,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,
   0,  11,   0,   0,  11,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   8,   0,   5,   0,   0,   3,   6,   0,   0,   0,   0,   4,
   5,   0,   0,   0,   0,   5,   0,   0,   4,   0,   0,   0,   0,   0,   7,   0,
   7,   0,  14,   0,   0,   0,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  38,   0,  38,   0,   0,  38,   0,  38,   0,  38,   0,
  38,   0,  38,   0,   0,  37,   0,  25,   0,  26,   0,  26,   0,  26,   0,  26,
   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,  25,   0,   0,  25,   0,  13,   0,   0,  14,   0,   0,   0,   0,   0,
  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,
   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,  15,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   9,   0,   0,   0,   9,   0,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   4,   0,   5,   0,  15,   0,
  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,
   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   0,   4,   0,   0,   4,   0,  16,   0,  16,   0,  16,   0,   0,
  16,   0,   0,  16,   0,   0,   0,  16,   0,   0,  16,   0,  12,   0,   0,   5,
   0,   0,   9,   0,   0,   7,   0,   8,   0,   0,   5,   3,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,   0,  25,
   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,  13,   0,   0,  13,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  10,   0,  13,   0,  13,   0,   0,  13,   0,   0,  13,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,
   0,   0,   0,  25,   0,   0,   4,   0,   0,   4,   0,   6,   0,   8,   8,   0,
   0,   0,   0,   0,   0,   3,   6,   0,   0,   0,   0,   0,   0,  15,   0,  15,
   0,  16,   0,   0,  15,   0,   0,   0,   5,   0,   0,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,
   0,   7,   0,   7,   0,  11,   0,   0,  11,   0,   0,  11,   0,  11,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,
   0,  12,   0,  12,   0,   0,  12,   0,   0,   7,   0,   0,   0,   7,   0,  38,
   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   4,   4,   0,   4,   0,   0,
   0,   0,   4,   0,  13,   0,   0,  13,   0,   0,   0,  13,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,
   0,  18,   0,  18,   0,  18,   0,   0,  20,   0,   0,   0,  21,   0,   0,  19,
   0,  21,   0,  21,   0,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,
  21,   0,  21,   0,  19,   0,   0,  21,   0,   0,   0,  21,  21,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  18,   0,   0,  19,   0,  19,   0,  19,   0,
   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,  19,   0,  19,   0,   0,  19,
   0,  19,   0,  19,   0,   0,  19,   0,  19,   0,   0,   0,  19,   0,   0,   7,
   0,   8,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   7,   0,   0,   7,   0,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  13,   0,  13,   0,  13,   0,  13,   0,  13,   0,  11,   0,   5,   4,   0,
   0,   0,  36,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,
  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,  24,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  25,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,  14,   0,  15,   0,   0,  15,   0,  15,   0,
  15,   0,  15,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,
   0,   0,  25,   0,  25,   0,   4,   0,   4,   0,   0,   0,  24,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,
  26,   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,  26,   0,   0,   0,
  11,   0,   0,  11,   0,  11,   0,   0,   0,  11,   0,  25,   0,   0,   0,   0,
  25,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,  10,   0,   0,  38,   0,
  38,   0,   0,   0,   0,   0,   0,   0,   7,   0,  25,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,
   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,   0,  15,   0,
   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,  24,   0,  25,   0,  25,   0,   0,   0,  25,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,
   0,  14,   0,  14,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,
   0,   0,  14,   0,  14,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,  10,   0,   7,
   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,
   8,   0,   8,   0,   0,   4,   4,   0,   0,   0,   0,   0,  25,   0,  25,   0,
   0,  25,   0,  26,   0,   0,  26,   0,   0,   0,   0,   0,   0,   7,   0,   0,
   0,   7,   0,   7,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,  24,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,   7,   0,   0,   0,  38,   0,
  38,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,  24,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,   5,   0,   0,  15,
   0,  14,   0,  15,   0,  15,   0,  15,   0,   0,  38,   0,   0,   0,  12,   0,
   0,  11,   0,  17,   0,  17,   0,  17,   0,  16,   0,  17,   0,  17,   0,   0,
   0,  17,   0,  18,   0,  18,   0,  18,   0,  18,   0,  14,   0,  18,   0,   0,
   0,   0,  18,   0,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,
  18,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   7,   0,   0,   7,
   0,   0,   0,   7,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   4,   0,
   4,   0,   3,   0,   6,   0,   0,   0,   0,   0,   0,   0,  37,   0,  38,   0,
  38,   0,  38,   0,  38,   0,  38,   0,   0,  32,   0,  10,   0,   0,   0,  10,
   0,   0,   8,   0,   8,   0,   7,   0,   0,   0,   0,   0,   0,   0,  15,   0,
  14,   0,   0,  15,   0,   8,   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,  25,   0,   0,   0,  25,
   0,   0,   0,   8,   0,   0,  16,   0,  16,   0,   0,  16,   0,   0,  16,   0,
   0,  16,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,
   0,   0,   4,   0,   0,   0,  16,   0,   0,  16,   0,   0,   0,  16,   0,   0,
  16,   0,  16,   0,  16,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   0,   4,   0,  11,   0,   0,  11,   0,   0,   0,  11,   0,  12,   0,   0,
  12,   0,   0,  12,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   8,   0,   0,   7,   0,   8,   0,   8,   6,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,  15,   0,  15,   0,  15,
   0,  15,   0,  15,   0,   0,  15,   0,   0,   0,   0,  15,   0,   0,  15,  15,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,   0,  26,   0,   0,  26,
   0,  26,   0,   0,   0,  26,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,
  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  13,   0,   0,  13,   0,
   0,   0,  16,   0,  16,   0,  16,   0,   0,  14,   0,  16,   0,  16,   0,  16,
   0,  16,   0,   0,  16,  16,   0,   0,   0,   0,  10,   0,  10,   0,   9,   0,
   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,
   0,   7,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
  13,   0,   0,   0,  13,   0,  13,   0,   0,  13,   0,   0,   0,  13,   0,   0,
  11,   0,  11,   0,   0,  11,   0,  11,   0,   0,   0,   0,  12,   0,   0,   0,
  12,   0,   0,   0,  12,   0,  12,   0,   0,  12,  12,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  18,   0,  19,   0,  19,   0,  19,   0,   0,  18,   0,  16,
   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,   0,  19,
   0,   0,  19,   0,   0,   0,  38,   0,  25,   0,   0,  25,   0,  16,   0,  17,
   0,  17,   0,   0,  17,   0,  17,   0,  17,   0,  16,   0,   0,   0,  17,   0,
  17,   0,  17,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   5,
   0,   0,   0,   0,   4,   0,   0,   0,   5,   4,   0,   0,   5,   0,   4,   0,
  14,   0,  14,   0,   0,  13,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,
   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  12,   0,  12,   0,   0,   0,   0,   0,   0,  12,   0,   0,   4,   4,
   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,
   0,  18,   0,   4,   4,   0,  38,   0,   0,  38,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   5,   0,   0,
   0,   0,   5,   0,  10,   0,   0,   0,   0,  10,   0,   0,  38,   0,   0,   0,
   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  37,   0,  38,
   0,  38,   0,  38,   0,  38,   0,  38,   0,   0,   0,   0,   0,   0,  24,   0,
  25,   0,  25,   0,   0,   0,   0,  25,   0,  12,   0,   0,   0,   0,  12,   0,
   0,   0,   0,  38,   0,   0,   0,  38,   0,   0,   0,   0,   0,  25,   0,   0,
  25,   0,  12,   0,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  18,   0,  18,   0,   0,
  18,   0,   0,  18,   0,  18,   0,   0,  18,   0,   0,  18,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  13,   0,   0,  13,   0,   0,   4,   4,   0,   0,
   0,   0,   0,  11,   0,  11,   0,   0,   0,   0,  11,   0,   0,  11,  11,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,
  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,
   0,   0,  25,   0,  22,   0,   0,   0,   0,   0,   3,   5,   0,   0,   7,   0,
   0,   0,   7,   0,  24,   0,   0,  25,   0,  25,   0,  25,   0,   0,   0,  25,
   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   0,   4,   0,  25,   0,  25,   0,  25,   0,   9,   0,   0,   0,   0,   9,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  11,   0,  11,   0,   0,   0,  11,   0,  25,   0,   0,  25,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,
  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   4,   0,
   0,   4,   0,   0,   0,   0,   0,  12,   0,   0,  12,   0,  14,   0,  11,   0,
  14,   0,  14,  14,   0,   4,   4,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  12,   0,  12,   0,   0,   0,
  12,   0,   0,  12,  12,   0,   0,   4,   0,   0,   0,   0,   0,  17,   0,  17,
   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,
   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   5,   4,
   0,   0,   0,  15,   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   7,   0,   7,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,  10,   0,   0,  10,   0,   0,
  12,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,
   0,   0,   0,   7,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   9,   0,
   6,   0,   0,   8,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   8,   0,   7,   7,   0,   0,   0,   0,   0,  13,   0,   0,  13,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  12,   0,  12,   0,  12,   0,  12,   0,   0,  12,  12,   0,   0,
   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,  15,
   0,   0,  15,   0,  15,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,
   3,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   8,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,
  14,   0,   0,   0,  10,   0,   8,   0,   0,  10,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,
   0,   7,   7,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,  14,   0,   0,   8,   0,
   0,   8,   0,  13,   0,   0,  13,   0,   0,   0,   0,   0,   9,   0,  11,   0,
  11,   0,  11,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,   8,
   8,   0,   0,   0,   0,   0,   0,   0,   7,   0,  14,   0,  14,   0,  14,   0,
  15,   0,  15,   0,  15,   0,  15,   0,   0,  15,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,
   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   5,   4,   0,   4,   5,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   0,   4,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,  11,
   0,   0,   0,   0,   0,  12,   0,   0,  17,   0,   0,  16,   0,   0,  19,   0,
   0,  26,   0,  26,   0,  26,   0,  26,   0,  26,   0,  25,   0,  10,   0,  11,
   0,   0,   0,  11,   0,   0,  11,  11,   0,   0,  38,   0,   0,   0,   0,   0,
   0,  38,   0,  14,   0,   0,  14,   0,   5,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   7,   0,   0,   0,   0,   7,   0,
  12,   0,  12,   0,  12,   0,  12,   0,   0,   0,  12,  12,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  17,   0,   0,  19,   0,  17,
   0,  22,   0,  17,   0,  21,   0,  22,   0,  23,   0,  19,   0,  19,   0,  20,
   0,  23,   0,  23,   0,  23,   0,  23,   0,  21,   0,  23,   0,  23,   0,   0,
  23,   0,   0,  23,   0,  23,   0,  23,   0,   0,   0,   0,   0,   0,   0,  14,
   0,  13,   0,  14,   0,  13,   0,  12,   0,  15,   0,   0,  15,  15,   0,   0,
   0,   0,  14,   0,  14,   0,  14,   0,  14,   0,   0,   0,  14,   0,   0,   0,
  14,   0,  14,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  16,   0,
  16,   0,  16,   0,  14,   0,   0,  16,   0,  16,   0,   0,   0,  16,   0,   0,
   0,  16,   0,  16,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  24,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   5,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,
  13,   0,   0,   0,  13,   0,  12,   0,  13,   0,  13,  13,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  13,   0,  11,   0,  13,   0,   0,  13,   0,   0,
  13,   0,  13,  13,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   9,
   0,   0,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,
   0,   5,   0,   8,   8,   0,   0,   0,   0,   8,   0,   0,   0,   9,   0,   0,
   0,  10,  10,   0,   0,   0,   0,   0,   6,   0,   0,   8,   0,  11,   0,   0,
  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,  38,
   0,   0,   0,   0,   0,   0,  38,   0,   7,   0,   7,   0,   7,   0,   0,   0,
  38,   0,  11,   0,  11,   0,   0,  11,   0,   0,  11,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  26,   0,   0,  26,   0,  13,   0,  13,   0,  15,   0,  15,   0,  15,
   0,  15,   0,   0,  15,   0,  15,   0,   0,   0,   0,   0,   9,   0,  10,   0,
  10,   8,   0,   0,   0,   0,  23,   0,   0,   0,   0,  25,   0,   4,   0,   5,
   0,   0,  25,   0,  25,   0,   0,   0,  25,   0,   5,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  13,   0,  11,   0,   0,  13,   0,   0,  13,   0,  11,   0,   0,   8,   0,
   6,   0,   0,   5,   4,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   9,   0,   0,   0,   9,   9,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,  25,   0,   0,   0,  25,
   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,
   0,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,  25,   0,
   0,   0,   0,  25,   0,  14,   0,  16,   0,  15,   0,  15,   0,  15,   0,  16,
   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,   0,   0,  24,   0,   9,   0,
  11,   0,  11,   0,   0,  11,   0,  38,   0,   0,  37,   0,   0,  38,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,   0,   0,  38,   0,  35,   0,
   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,   0,   0,   0,  15,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,
   9,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   0,   9,   0,   0,   0,
   9,   9,   0,   0,   0,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   7,   0,   8,   0,  10,   0,   0,  10,
  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,
   5,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   6,   0,   8,   8,   0,   0,   0,   0,   4,   4,   0,
  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   6,   0,   8,   8,   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   0,
   0,   0,   0,   0,   0,   4,   4,   0,  13,   0,  13,   0,   0,  13,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,  14,   0,  14,
   0,  14,   0,  13,   0,  13,   0,  14,   0,  14,  14,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,  24,   0,
   7,   0,   0,   7,   7,   0,   0,   0,   9,   0,   9,   0,   9,   0,   0,   0,
   9,   0,   0,   0,   9,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  12,   0,   0,   0,  12,   0,   0,   0,   0,   0,   0,
   0,  12,   0,   0,  12,   0,   0,   0,  12,   0,  12,   0,   0,   0,  12,  12,
   0,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   4,   4,   0,   0,   0,   0,
  26,   0,   0,  26,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   9,
   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   7,   0,  13,   0,  13,   0,  13,   0,
  13,  13,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,  25,
   0,  21,   0,   0,   0,  26,   0,  26,   0,  26,   0,   0,  26,   0,   0,   0,
  26,   0,   0,   0,  26,   0,   0,  26,   0,   8,   0,   0,   6,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   5,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   9,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,
   0,   0,  14,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,
  13,   0,  13,   0,  13,   0,  13,   0,  13,   0,  13,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,  25,   0,  25,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,  26,   0,   0,  14,   0,  15,   0,  16,   0,   0,   0,
  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,  16,   0,  26,   0,  26,
   0,  24,   0,  26,   0,  26,   0,  26,   0,  26,   0,  25,   0,   0,   0,   0,
  25,   0,  25,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,  11,   0,  11,   0,  11,  11,   0,   0,
   0,   0,   0,   0,   8,   0,  10,   0,  10,  10,   0,   0,   0,   0,   0,   0,
   0,  23,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,  25,   0,   4,
   0,   0,   7,   0,   8,   0,   7,   0,   0,   0,  11,   0,   0,  11,   0,  10,
   0,  10,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,
   0,   0,  25,   0,   0,  15,   0,  15,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,   4,   0,   4,
   0,  38,   0,   0,  38,   0,   0,   0,  15,   0,  15,   0,  15,   0,  15,   0,
  15,   0,  15,   0,   0,  15,   0,   0,   0,  15,  15,   0,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,  12,   0,  12,   0,   0,   0,  12,   0,  12,   0,   0,  12,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,  11,   0,   0,
   0,  11,   0,   0,   0,  11,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,   0,  10,   0,   0,
   0,   0,  10,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  13,   0,  11,
   0,  14,   0,   0,   0,  14,   0,   0,  13,   0,   0,   0,   0,   0,  14,   0,
  14,   0,  25,   0,   0,  25,   0,  14,   0,  14,   0,   0,   0,  14,   0,  14,
   0,   0,  14,   0,   0,   0,  14,   0,  14,   0,   0,   0,   0,   0,   0,  10,
   0,   0,  10,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,  25,   0,
  25,   0,   0,   0,   4,   0,   4,   0,   0,   0,  14,   0,   0,   0,  14,   0,
   0,   0,   0,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  10,   0,  10,   0,   0,   0,  10,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,  10,   7,   0,
   0,   0,   0,   0,   0,  11,   0,  12,   0,  14,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,  11,
   0,  38,   0,   0,  38,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,  25,
   0,   0,  25,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   0,
   5,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,
  15,   0,  15,   0,  15,   0,   0,  11,   0,   0,   0,  15,   0,  15,  15,   0,
   0,   0,   0,   0,  11,   0,   0,   0,  11,   0,  11,   0,  11,  11,   0,   0,
   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,  38,   0,   0,
   0,   0,   0,   7,   0,   0,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   8,   0,   0,
   7,   0,  14,   0,  13,   0,  14,   0,  14,   0,  14,   0,   0,  14,   0,  14,
  14,   0,   0,   8,   0,   0,   0,   8,   0,   7,   0,   7,   0,  38,   0,   0,
  38,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   5,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,  38,   0,   0,   0,  38,   0,   0,
   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   4,   0,
   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   4,   0,   4,   5,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,   0,   0,
   0,  24,   0,   0,   0,  12,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   8,   0,   0,   0,   0,  10,   0,   0,  10,   0,
   0,   0,   4,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,  24,   0,
   0,   8,   0,   0,   0,   8,   0,   0,  11,   0,   0,  11,   0,  11,   0,   0,
   0,  11,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,
  25,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   8,   0,   0,   8,
   0,   4,   4,   0,   0,   0,   0,   0,   0,  13,   0,   0,  22,   0,  22,   0,
  21,   0,  17,   0,  23,   0,  17,   0,   0,  22,   0,  22,   0,  23,   0,  23,
   0,   0,  19,   0,  23,   0,  23,   0,   0,   0,  20,   0,  23,   0,  23,   0,
  23,   0,   0,  23,   0,   0,   0,   4,   0,   0,   4,   0,   0,  19,   0,   0,
  20,   0,  20,   0,  20,   0,  22,   0,  16,   0,   0,   0,  22,   0,  22,   0,
  19,   0,  22,   0,  22,   0,  22,   0,  22,   0,  22,   0,  22,   0,  22,   0,
  22,   0,  22,   0,  22,   0,   0,  22,  22,   0,   0,   0,   0,   0,   0,   0,
  24,   0,  25,   0,  26,   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,  26,
   0,  24,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,  26,
   0,  26,   0,  26,   0,  26,   0,   0,   0,  26,   0,  26,   0,   0,   0,  26,
   0,  26,   0,  26,   0,   0,   0,   0,  24,   0,  25,   0,   0,   0,  25,   0,
   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,   0,  13,
   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   8,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,
   4,   0,   0,   0,   0,   0,   0,  11,   0,   0,   0,  12,   0,   0,   8,   0,
   0,   0,   7,   0,   9,   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,  38,   0,   0,   0,   0,  38,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  38,   0,  13,   0,  13,   0,  13,   0,  12,   0,  13,   0,  13,
  13,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,  12,
   0,   0,   0,   0,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   5,   0,
   0,   0,   0,   0,   0,  11,   0,   5,   0,   0,   4,   0,   0,  38,   0,   0,
  37,   0,  38,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  38,   0,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,  16,
   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,
   0,  16,  16,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,  25,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,
  25,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   4,   0,   0,   4,
   0,   4,   0,   4,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,
   8,   0,   0,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,  25,   0,   0,
   0,   0,   0,   0,   0,  37,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,
  11,   0,  12,   0,  12,   0,  12,  12,   0,   0,   0,   0,   0,   0,   0,   0,
   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   8,   0,   4,   4,   0,   0,   0,   0,  25,   0,
   0,   0,  25,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   8,   0,   0,   0,   8,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   9,   0,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,  38,   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,  11,   0,  11,   0,  11,   0,  11,  11,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,   0,   0,
   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   7,
   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,
  11,   0,  11,   0,  11,   5,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   0,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,  38,   0,  38,
   0,  38,   0,  38,   0,   0,  38,   0,   0,   0,  38,   0,   0,  38,   0,  38,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  14,   0,  14,   0,   0,   0,  14,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,  11,
  11,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,  25,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   5,   0,   8,   8,   0,   0,   0,   0,   0,
   0,   8,   0,   5,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  25,   0,   0,   0,  25,   0,   7,   0,   0,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   0,   9,   9,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   8,   0,   0,   0,   8,   0,
   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   0,   0,   7,   7,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,  38,   0,   0,   0,  38,   0,   0,   4,   0,   0,  24,   0,   4,   4,
   0,   0,   0,   0,   0,  38,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,  16,   0,
  16,   0,  16,   0,   0,  16,  16,   0,   0,   0,   0,   0,  25,   0,  25,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  38,   0,   7,   0,   0,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,   0,   0,   0,
  13,   0,   0,   0,   0,   0,   8,   0,   8,   0,   7,   0,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,
  14,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  12,   0,  11,   0,  12,
   0,  12,   0,  12,  12,   0,   0,   0,  38,   0,   0,   0,   0,  13,   0,  13,
   0,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,
   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   7,   0,   0,   0,   7,   0,   0,   7,   0,   7,   0,
   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  16,   0,  16,   0,
   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,  24,   0,  25,   0,   0,   0,  25,   0,
  25,   0,   0,   0,   4,   0,   0,   0,   4,   0,   0,  25,   0,   0,   0,  25,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   4,   4,   0,   9,   0,   0,   9,   0,   7,   0,  12,   0,  12,
   0,   0,  12,   0,   0,   4,   0,   0,   0,   4,   0,   8,   0,  13,   0,   0,
   0,  13,   0,   0,   0,  23,   0,  25,   0,   0,   0,  24,   0,  26,   0,   0,
  26,   0,   0,   0,  17,   0,   0,   0,   0,  17,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,
   0,   0,   0,   0,   0,  38,   0,  38,   0,   7,   0,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,  14,
   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,
   7,   0,   0,   6,   0,  11,   0,  10,  11,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,  25,   0,  26,   0,   0,   0,  26,   0,  26,   0,  26,   0,   0,
  26,   0,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,  25,
   0,  26,   0,  26,   0,   0,   0,  26,   0,   0,  26,   0,   0,   0,   0,   0,
  25,   0,   0,   0,   0,  25,   0,  37,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,   0,  11,  11,   0,
   0,   0,   4,   4,   0,   0,   0,   0,  13,   0,   0,   0,   0,  13,   0,   4,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  12,   0,  12,   0,  12,   0,  12,   0,  12,   0,   0,   0,   0,   4,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   4,   0,   0,   4,
   0,  14,   0,   0,   0,  14,   0,   0,   0,  14,   0,  14,   0,  12,   0,   0,
  13,   0,  25,   0,  25,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,
   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,
   0,   9,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,   0,   4,   0,   0,
   4,   0,   0,   0,   0,   0,  19,   0,  22,   0,  19,   0,   0,   0,  20,   0,
   0,   0,  21,   0,  22,   0,  22,   0,   0,  17,   0,  22,   0,   0,  22,   0,
  22,   0,  22,   0,  22,   0,  22,   0,  19,   0,   0,  22,   0,  22,   0,   0,
  22,   0,   0,  22,   0,  22,   0,  19,   0,  34,   0,   0,   0,   0,   0,   0,
   0,   0,  10,   0,  14,   0,  14,   0,   0,  14,   0,   0,  14,   0,  20,   0,
  20,   0,  20,   0,   0,   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,   0,
   0,  20,   0,   0,   0,  20,   0,   0,  20,   0,   0,  20,   0,   0,   4,   4,
   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,  11,  11,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   4,   4,   0,   0,   0,  10,   0,   0,   0,   0,   0,   0,   5,
   0,   0,   4,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  10,   0,  11,
   0,   0,  11,   0,   0,  11,   0,   4,   0,   5,   0,  11,   0,  11,   0,  11,
   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  37,   0,   0,
   0,  38,   0,   9,   0,   9,   0,   0,   9,   0,  24,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,  15,   0,   0,  15,
   0,   7,   0,   9,   0,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   5,   3,   0,  15,   0,   0,  17,   0,  17,
   0,   0,   0,   0,  17,   0,   5,   3,   0,   0,   0,   5,   0,   0,   4,   0,
   0,   8,   0,   8,   0,   0,   0,   0,   0,  11,   0,  10,   0,   0,   0,  11,
   0,  11,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,   0,   0,   0,
  38,   0,  38,   0,  38,   0,  38,   0,   0,  38,   0,   0,   0,   0,   4,   5,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,  38,   0,   0,  37,
   0,   0,   0,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,   0,   0,  14,
   0,   0,   0,  15,   0,   0,   0,   0,  15,   0,  14,   0,   0,   0,  14,   0,
   4,   0,   0,   4,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,
   0,   7,   0,   7,   0,   7,   0,   0,   0,   0,   0,   0,  13,   0,  12,   0,
   0,  13,   0,   0,  13,   0,  13,   0,   0,  13,   0,  13,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   5,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,  38,   0,  38,
   0,   0,   0,   0,  37,   0,   0,  38,   0,  38,   0,   0,   0,  38,   0,  17,
   0,  17,   0,   0,   0,  17,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,   0,
  26,   0,   0,  21,   0,   0,   0,  25,   0,   0,   0,  26,   0,   0,   9,   0,
   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,
   0,   0,   9,   9,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  38,   0,  14,   0,  14,   0,   0,   0,   0,  14,   0,   0,   0,   0,
  17,   0,   0,  17,   0,  25,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,
   0,   0,   0,   9,   0,   0,   0,   9,   0,   0,   0,   0,   9,   0,   0,   0,
   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,
  25,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   5,   4,   0,   0,   0,   0,   0,   0,   0,   0,  13,
   0,  13,   0,  12,   0,   9,   0,  13,   0,   0,  13,   0,  13,   0,  12,   0,
  13,   0,   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,  18,   0,   0,   0,
  18,   0,  18,   0,  17,   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,   0,
  18,   0,   0,  18,   0,  18,   0,   0,   0,  18,   0,   0,   0,   0,   0,  18,
   0,  25,   0,  25,   0,  25,   0,   4,   0,   0,   0,   0,   4,   0,   0,   0,
   7,   0,   0,   0,   7,   0,  14,   0,  14,   0,   0,   0,   0,  14,   0,  14,
   0,   0,  14,   0,   0,   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,  15,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  23,   0,  23,   0,   0,   0,
   5,   4,   0,   0,   0,   0,   7,   0,   0,   0,   9,   0,   0,   0,   0,   0,
  38,   0,   0,   0,  25,   0,   0,   0,  26,   0,   0,   0,   0,   7,   0,   0,
   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  12,
   0,  12,   0,  12,   0,   0,  12,  12,   0,   0,   0,  16,   0,   0,   0,  16,
   0,  16,   0,   0,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,
   0,   8,   7,   0,  26,   0,  26,   0,   0,   0,   0,   0,  26,   0,   0,   0,
   0,   0,  16,   0,  16,   0,   0,   0,  16,   0,   0,   0,   0,   0,  16,   0,
   0,  16,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   7,
   0,   0,  14,   0,  16,   0,  16,   0,  16,   0,  16,   0,   0,  15,   0,  16,
   0,   0,  16,   0,   0,  15,   0,   0,   0,   0,   0,   0,   8,   0,   9,   0,
   0,   0,   0,   0,   9,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  14,   0,   0,  14,   0,   0,   0,   0,   0,
   0,   0,   0,  13,   0,  15,   0,  15,   0,  11,   0,  15,   0,  15,   0,  15,
  14,   0,   8,   0,   0,   8,   0,   0,   4,   5,   0,   0,   0,   0,   0,  25,
   0,   0,   0,   0,  24,   0,   0,  24,   0,  25,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  11,   0,  11,   0,   0,  11,   0,   0,   0,   0,   0,   0,   0,
   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,   0,
   0,  11,   0,  13,   0,   0,   0,  13,   0,  13,   0,   0,   0,   0,   0,  11,
   0,  11,   0,  11,   0,   0,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,
   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  38,   0,   0,   0,   0,  19,   0,  18,   0,  21,
   0,   0,   0,   0,  16,   0,  19,   0,  21,   0,  18,   0,  21,   0,  21,   0,
  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,  21,   0,
   0,   0,  21,   0,  21,   0,  25,   0,   0,  25,   0,  14,   0,   0,  17,   0,
   0,  17,   0,  17,   0,  17,   0,   0,   0,   0,   0,   0,  24,   0,   6,   3,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,   0,   0,   0,   0,   0,  10,
   0,   0,  12,   0,  13,   0,  13,   0,   0,   0,   0,   0,   0,  13,   0,   0,
  25,   0,  25,   0,  25,   0,  25,   0,   0,  25,   0,   0,  37,   0,   0,   0,
   0,   0,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,  14,   0,  14,   0,   0,  14,   0,  11,   0,  11,   0,  11,
   0,   0,  11,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,   0,  13,
   0,  13,   0,   0,   0,   0,   0,   0,  11,   0,  13,  13,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,
   0,   0,   7,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,  11,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,
   0,   9,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   8,   0,   0,   0,   8,   0,  10,   0,   0,  15,   0,   9,   0,   9,
   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,
   0,   0,   0,  38,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   7,
   0,   0,   7,   0,   0,   0,   0,   0,   0,   4,   0,   0,   4,   0,  14,   0,
  14,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,   0,
   0,   0,  14,   0,   0,   0,   0,   0,  14,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,
   0,   0,  17,   0,  20,   0,  15,   0,  20,   0,  20,   0,  20,   0,  20,   0,
  20,   0,  20,   0,  20,   0,   0,  20,   0,   0,   0,   0,   0,   0,   0,  11,
   0,  11,   0,  11,   0,  11,  11,   0,   0,   0,   0,   0,   0,   0,  13,   0,
   0,  13,   0,  13,   0,   0,   0,   0,  16,   0,   0,   0,   0,  16,   0,   9,
   0,   0,   0,   9,   0,   0,   0,   9,   9,   0,  25,   0,  25,   0,   0,   0,
  25,   0,   0,   0,   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,   0,
   0,  26,   0,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,  25,   0,  25,
   0,  25,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,  25,
   0,   0,  25,   0,   7,   0,   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,
   0,  14,   0,   0,   0,  14,   0,   0,  26,   0,   0,   0,  26,   0,   0,   4,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,   6,   0,   0,  11,
   0,   0,   0,   7,   0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   7,
   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,  25,   0,
   0,   0,  25,   0,   0,  18,   0,   0,  14,   0,   0,   0,   0,  18,   0,   0,
  21,   0,   0,  25,   0,   0,   0,   0,  30,   0,   0,  27,   0,   0,   0,   0,
  18,   0,  26,   0,  25,   0,  30,   0,  28,   0,  33,   0,  30,   0,  32,   0,
   0,  33,   0,  33,   0,  33,   0,   0,  33,   0,  33,   0,  33,   0,  33,   0,
   0,  33,   0,   0,   0,   0,   0,  33,  33,   0,   0,   0,   0,   0,   0,  26,
   0,  27,   0,  26,   0,  27,   0,  25,   0,  25,   0,  27,   0,  22,   0,   0,
   0,   3,   0,  27,   0,  26,   0,   0,  26,   0,  27,   0,   0,  27,   0,  27,
   0,   0,   0,   0,  23,   0,  13,   0,  13,   0,   0,   0,  13,   0,  13,   0,
  13,   0,   0,  12,   0,   0,   0,   8,   0,   0,   7,   0,   0,   0,   0,   0,
   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  12,   0,  13,   0,  13,   0,  13,   0,   0,
   0,  13,   0,   0,  13,   0,   0,   0,   0,   0,   0,   0,   0,  20,   0,  20,
   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,   0,  20,
   0,  20,   0,  20,   0,  19,   0,  19,   0,  20,   0,  20,   0,  20,   0,  20,
  20,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,
  26,   0,   0,   0,  26,   0,   0,  26,   0,  26,   0,  26,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,  12,   0,
  12,   0,  12,  12,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,   0,  12,   0,  12,
   0,  12,  12,   0,   0,   0,   0,   0,   0,   0,   0,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   8,   0,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,  11,
   0,  11,   0,   0,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,
   0,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   7,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   7,   0,   0,   7,   7,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   9,   0,   0,   9,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,
   9,   0,   9,   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  26,   0,  26,   0,  26,   0,  26,
   0,   0,  26,   0,  26,   0,  26,   0,  26,   0,  26,   0,   0,   4,   0,   0,
   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,  15,   0,  15,   0,  15,   0,  15,   0,  15,
   0,  15,   0,  15,   0,   0,   0,  15,  15,   0,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   7,   0,   7,   7,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  12,   0,  12,   0,   0,   0,
   0,   0,   0,  25,   0,  25,   0,  25,   0,   0,  25,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   7,   0,   7,   7,   0,   0,   0,   0,   4,   0,   4,   0,   4,   4,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,
   0,   0,  10,   0,  11,   0,  11,   0,   0,  11,  10,   0,   4,   5,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,   0,  11,
   0,  11,   0,   0,   0,   0,  25,   0,  25,   0,  25,   0,   0,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   7,   0,
   7,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,  25,   0,  25,   0,   0,
   0,   0,   0,   0,   7,   0,   7,   0,   7,   0,   0,   0,   0,  13,   0,  13,
   0,  13,   0,  13,   0,  13,   0,  13,  13,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   7,   0,   7,   7,   0,   0,   0,   0,   0,  14,   0,  14,   0,
   0,   0,  14,   0,   0,   0,  25,   0,   0,   0,   0,   0,   0,   0,   4,   0,
   4,   0,   7,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   4,   0,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   8,   0,   0,  10,   0,  10,  10,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,  25,   0,   0,  25,   0,   8,   0,   0,  10,
   0,   0,   0,   0,  10,   0,  25,   0,   0,  23,   0,   0,   0,   0,  25,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,   6,   0,  14,
   0,  14,   0,  14,   0,  14,   0,  14,   0,   0,   0,  14,   0,   0,   0,  14,
  12,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   7,   0,   0,   0,   7,
   0,   7,   0,   0,   7,   0,   0,   7,   0,   4,   0,   0,  14,   0,   0,  14,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  13,   0,  13,   0,  13,
   0,  13,   0,   0,   0,  13,   0,   0,   0,  13,   0,   0,   0,   0,   4,   4,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,   0,   0,
   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   9,   0,   8,   5,   0,   0,   0,   7,   3,   0,   0,   0,   0,
   0,   0,   4,   0,   4,   0,  25,   0,  25,   0,   0,  25,   0,  25,   0,   0,
   0,  25,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,
   9,   0,   0,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   0,   9,   0,   0,   0,   0,   4,   5,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  16,   0,
   0,  15,   0,  19,   0,  18,   0,  19,   0,   0,  19,   0,  16,   0,  18,   0,
  19,   0,  19,   0,  19,   0,  19,   0,   0,  19,   0,  12,   0,  11,   0,  12,
   0,  12,   0,  12,  12,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  11,   0,  10,   0,   0,  11,   0,   0,  11,   0,   4,   4,   0,   0,   0,   0,
   0,   0,   0,   9,   0,   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   9,   0,
   0,   9,   0,   4,   4,   0,   0,   4,   0,   4,   0,   0,   8,   0,   8,   0,
   0,   8,   0,   0,  24,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  25,   0,  24,   0,   0,   5,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  11,   0,  11,   0,  10,
   0,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,
   0,  15,   0,   0,   0,  25,   0,   0,   0,  25,   0,   0,   0,   0,   0,  25,
   0,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   8,
   0,   0,   0,   0,   8,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   4,   4,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   4,   4,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   4,   4,   0,   4,   4,   0,   0,   0,   0,   4,
   4,   0,   0,   4,   4,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  11,   0,  13,   0,   0,  13,   0,  13,   0,   0,  10,
   0,   0,   0,   6,   0,   0,   8,   0,   0,   0,   0,   0,   0,   0,   5,   3,
   0,   0,   0,   7,   0,   8,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,
   4,   0,   8,   0,   0,   8,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   0,   9,   0,   0,   0,   9,
   9,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,   0,   7,   0,   0,   0,
   7,   0,  25,   0,   0,  25,   0,   9,   0,   9,   0,   9,   0,   9,   0,   0,
   5,   0,   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  24,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,  15,   0,   0,   0,  15,   0,  25,   0,   0,  25,   0,  25,   0,   0,
   0,   0,   0,   0,   8,   0,   0,   8,   0,  25,   0,  25,   0,   9,   0,   9,
   0,   0,   0,   0,   0,   9,   0,   8,   0,   8,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  15,   0,
  14,   0,   0,   0,   0,   0,  15,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   6,   0,   0,   8,
   8,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   9,   0,  13,   0,   0,
   0,   0,   0,   0,  13,   0,   0,   9,   0,   0,   9,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   9,   0,   0,   0,   0,   9,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  38,   0,   0,  38,   0,  25,
   0,   0,   0,  25,   0,  17,   0,  16,   0,  17,   0,   0,  16,   0,  15,   0,
  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,  18,   0,   0,   0,  18,  18,
   0,   0,   0,   9,   0,   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,
   0,   9,   0,   9,   0,   8,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   4,   4,   0,   0,   0,  25,   0,  25,   0,   0,   0,  38,   0,   0,
  38,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,   7,   7,   0,   8,
   0,   0,   0,   8,   0,   0,   0,   4,   0,   0,   4,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,  38,
   0,  38,   0,  38,   0,   0,  25,   0,   0,  25,   0,  25,   0,   0,   0,  25,
   0,   0,  25,   0,   0,   4,   5,   0,   0,   0,   0,  38,   0,  13,   0,   0,
  13,   0,   0,  37,   0,  11,   0,  12,   0,   0,  12,   0,   0,   0,   0,   5,
   0,   8,   0,  10,   0,  10,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,
   0,   0,  11,   0,  10,   0,  11,   0,   0,   0,   0,  11,   0,  10,   0,  24,
   0,  38,   0,  38,   0,   0,   0,   0,   8,   0,   8,   0,   0,   0,   0,   0,
   0,   0,   7,   0,   0,   7,   0,   0,   0,   0,   4,   5,   0,   0,   0,   0,
  24,   0,   0,   0,  11,   0,   0,   0,   0,  12,   0,  14,   0,  15,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   8,   0,   0,   8,   0,   8,   0,
   9,   0,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,  11,   0,  10,
   0,   0,  11,   0,   0,  11,  11,   0,   0,   0,   0,   0,   0,  24,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,  25,   0,   0,  25,   0,
  25,   0,   0,   0,   0,   0,   0,   0,   4,   4,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  24,   0,  25,   0,
  24,   0,  25,   0,   0,  25,   0,   0,   0,  38,   0,  38,   0,   0,   0,   0,
   0,   0,   0,   0,   8,