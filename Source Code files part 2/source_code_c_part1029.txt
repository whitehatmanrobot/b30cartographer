h
    while (low <= high && cmp != 0)
    {
        i = (low + high) / 2;
        cmp = _stricmp(*ppchName, (const char *)(*(lpTable + i)).szName);

        if (cmp == 0)
            *ppchName = (*(lpTable + i)).chAbbrev;
        else if (cmp < 0)
            high = i - 1;
        else
            low = i + 1;
    }

    return !cmp;
}

/***
*void GetLcidFromLangCountry - get LCIDs from language and country strings
*
*Purpose:
*   Match the best LCIDs to the language and country string given.
*   After global variables are initialized, the LangCountryEnumProc
*   routine is registered as an EnumSystemLocalesA callback to actually
*   perform the matching as the LCIDs are enumerated.
*
*Entry:
*   pchLanguage     - language string
*   bAbbrevLanguage - language string is a three-letter abbreviation
*   pchCountry      - country string
*   bAbbrevCountry  - country string ia a three-letter abbreviation
*   iPrimaryLen     - length of language string with primary name
*
*Exit:
*   lcidLanguage - LCID of language string
*   lcidCountry  - LCID of country string
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromLangCountry (void)
{
    //  initialize static variables for callback use
    bAbbrevLanguage = strlen(pchLanguage) == 3;
    bAbbrevCountry = strlen(pchCountry) == 3;
    lcidLanguage = 0;
    iPrimaryLen = bAbbrevLanguage ? 2 : GetPrimaryLen(pchLanguage);

    EnumSystemLocalesA(LangCountryEnumProc, LCID_INSTALLED);

    //  locale value is invalid if the language was not installed or the language
    //  was not available for the country specified
    if (!(iLcidState & __LCID_LANGUAGE) || !(iLcidState & __LCID_EXISTS) ||
                !(iLcidState & (__LCID_FULL | __LCID_PRIMARY | __LCID_DEFAULT)))
        iLcidState = 0;
}

/***
*BOOL CALLBACK LangCountryEnumProc - callback routine for GetLcidFromLangCountry
*
*Purpose:
*   Determine if LCID given matches the language in pchLanguage
*   and country in pchCountry.
*
*Entry:
*   lpLcidString   - pointer to string with decimal LCID
*   pchCountry     - pointer to country name
*   bAbbrevCountry - set if country is three-letter abbreviation
*
*Exit:
*   iLcidState   - status of match
*       __LCID_FULL - both language and country match (best match)
*       __LCID_PRIMARY - primary language and country match (better)
*       __LCID_DEFAULT - default language and country match (good)
*       __LCID_LANGUAGE - default primary language exists
*       __LCID_EXISTS - full match of language string exists
*       (Overall match occurs for the best of FULL/PRIMARY/DEFAULT
*        and LANGUAGE/EXISTS both set.)
*   lcidLanguage - LCID matched
*   lcidCountry  - LCID matched
*   FALSE if match occurred to terminate enumeration, else TRUE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL CALLBACK LangCountryEnumProc (LPSTR lpLcidString)
{
    LCID    lcid = LcidFromHexString(lpLcidString);
    char    rgcInfo[120];

    //  test locale country against input value
    if ((*pfnGetLocaleInfoA)(lcid, bAbbrevCountry ? LOCALE_SABBREVCTRYNAME
                                                  : LOCALE_SENGCOUNTRY,
                       rgcInfo, sizeof(rgcInfo)) == 0)
    {
        //  set error condition and exit
        iLcidState = 0;
        return TRUE;
    }
    if (!_stricmp(pchCountry, rgcInfo))
    {
        //  country matched - test for language match
        if ((*pfnGetLocaleInfoA)(lcid, bAbbrevLanguage ? LOCALE_SABBREVLANGNAME
                                                       : LOCALE_SENGLANGUAGE,
                           rgcInfo, sizeof(rgcInfo)) == 0)
        {
            //  set error condition and exit
            iLcidState = 0;
            return TRUE;
        }
        if (!_stricmp(pchLanguage, rgcInfo))
        {
            //  language matched also - set state and value
            iLcidState |= (__LCID_FULL | __LCID_LANGUAGE | __LCID_EXISTS);
            lcidLanguage = lcidCountry = lcid;
        }

        //  test if match already for primary langauage
        else if (!(iLcidState & __LCID_PRIMARY))
        {
            //  if not, use iPrimaryLen to partial match language string
            if (iPrimaryLen && !_strnicmp(pchLanguage, rgcInfo, iPrimaryLen))
            {
                //  primary language matched - set state and country LCID
                iLcidState |= __LCID_PRIMARY;
                lcidCountry = lcid;

                //  if language is primary only (no subtype), set language LCID
                if ((int)strlen(pchLanguage) == iPrimaryLen)
                    lcidLanguage = lcid;
            }

            //  test if default language already defined
            else if (!(iLcidState & __LCID_DEFAULT))
            {
                //  if not, test if locale language is default for country
                if (TestDefaultCountry(lcid))
                {
                    //  default language for country - set state, value
                    iLcidState |= __LCID_DEFAULT;
                    lcidCountry = lcid;
                }
            }
        }
    }
    //  test if input language both exists and default primary language defined
    if ((iLcidState & (__LCID_LANGUAGE | __LCID_EXISTS)) !=
                      (__LCID_LANGUAGE | __LCID_EXISTS))
    {
        //  test language match to determine whether it is installed
        if ((*pfnGetLocaleInfoA)(lcid, bAbbrevLanguage ? LOCALE_SABBREVLANGNAME
                                                       : LOCALE_SENGLANGUAGE,
                           rgcInfo, sizeof(rgcInfo)) == 0)
        {
            //  set error condition and exit
            iLcidState = 0;
            return TRUE;
        }

        if (!_stricmp(pchLanguage, rgcInfo))
        {
            //  language matched - set bit for existance
            iLcidState |= __LCID_EXISTS;

            if (bAbbrevLanguage)
            {
                //  abbreviation - set state
                //  also set language LCID if not set already
                iLcidState |= __LCID_LANGUAGE;
                if (!lcidLanguage)
                    lcidLanguage = lcid;
            }

            //  test if language is primary only (no sublanguage)
            else if (iPrimaryLen && ((int)strlen(pchLanguage) == iPrimaryLen))
            {
                //  primary language only - test if default LCID
                if (TestDefaultLanguage(lcid, TRUE))
                {
                    //  default primary language - set state
                    //  also set LCID if not set already
                    iLcidState |= __LCID_LANGUAGE;
                    if (!lcidLanguage)
                        lcidLanguage = lcid;
                }
            }
            else
            {
                //  language with sublanguage - set state
                //  also set LCID if not set already
                iLcidState |= __LCID_LANGUAGE;
                if (!lcidLanguage)
                    lcidLanguage = lcid;
            }
        }
        else if (!bAbbrevLanguage && iPrimaryLen
                               && !_strnicmp(pchLanguage, rgcInfo, iPrimaryLen))
        {
            //  primary language match - test for default language only
            if (TestDefaultLanguage(lcid, FALSE))
            {
                //  default primary language - set state
                //  also set LCID if not set already
                iLcidState |= __LCID_LANGUAGE;
                if (!lcidLanguage)
                    lcidLanguage = lcid;
            }
        }
    }

    //  if LOCALE_FULL set, return FALSE to stop enumeration,
    //  else return TRUE to continue
    return (iLcidState & __LCID_FULL) == 0;
}

/***
*void GetLcidFromLanguage - get LCIDs from language string
*
*Purpose:
*   Match the best LCIDs to the language string given.  After global
*   variables are initialized, the LanguageEnumProc routine is
*   registered as an EnumSystemLocalesA callback to actually perform
*   the matching as the LCIDs are enumerated.
*
*Entry:
*   pchLanguage     - language string
*   bAbbrevLanguage - language string is a three-letter abbreviation
*   iPrimaryLen     - length of language string with primary name
*
*Exit:
*   lcidLanguage - lcidCountry  - LCID of language with default
*                                 country
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromLanguage (void)
{
    //  initialize static variables for callback use
    bAbbrevLanguage = strlen(pchLanguage) == 3;
    iPrimaryLen = bAbbrevLanguage ? 2 : GetPrimaryLen(pchLanguage);

    EnumSystemLocalesA(LanguageEnumProc, LCID_INSTALLED);

    //  locale value is invalid if the language was not installed
    //  or the language was not available for the country specified
    if (!(iLcidState & __LCID_FULL))
        iLcidState = 0;
}

/***
*BOOL CALLBACK LanguageEnumProc - callback routine for GetLcidFromLanguage
*
*Purpose:
*   Determine if LCID given matches the default country for the
*   language in pchLanguage.
*
*Entry:
*   lpLcidString    - pointer to string with decimal LCID
*   pchLanguage     - pointer to language name
*   bAbbrevLanguage - set if language is three-letter abbreviation
*
*Exit:
*   lcidLanguage - lcidCountry - LCID matched
*   FALSE if match occurred to terminate enumeration, else TRUE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL CALLBACK LanguageEnumProc (LPSTR lpLcidString)
{
    LCID    lcid = LcidFromHexString(lpLcidString);
    char    rgcInfo[120];

    //  test locale for language specified
    if ((*pfnGetLocaleInfoA)(lcid, bAbbrevLanguage ? LOCALE_SABBREVLANGNAME
                                                   : LOCALE_SENGLANGUAGE,
                       rgcInfo, sizeof(rgcInfo)) == 0)
    {
        //  set error condition and exit
        iLcidState = 0;
        return TRUE;
    }

    if (!_stricmp(pchLanguage, rgcInfo))
    {
        //  language matched - test if locale country is default
        //  or if locale is implied in the language string
        if (bAbbrevLanguage || TestDefaultLanguage(lcid, TRUE))
        {
            //  this locale has the default country
            lcidLanguage = lcidCountry = lcid;
            iLcidState |= __LCID_FULL;
        }
    }
    else if (!bAbbrevLanguage && iPrimaryLen
                              && !_strnicmp(pchLanguage, rgcInfo, iPrimaryLen))
    {
        //  primary language matched - test if locale country is default
        if (TestDefaultLanguage(lcid, FALSE))
        {
            //  this is the default country
            lcidLanguage = lcidCountry = lcid;
            iLcidState |= __LCID_FULL;
        }
    }

    return (iLcidState & __LCID_FULL) == 0;
}

/***
*void GetLcidFromCountry - get LCIDs from country string
*
*Purpose:
*   Match the best LCIDs to the country string given.  After global
*   variables are initialized, the CountryEnumProc routine is
*   registered as an EnumSystemLocalesA callback to actually perform
*   the matching as the LCIDs are enumerated.
*
*Entry:
*   pchCountry     - country string
*   bAbbrevCountry - country string is a three-letter abbreviation
*
*Exit:
*   lcidLanguage - lcidCountry  - LCID of country with default
*                                 language
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromCountry (void)
{
    bAbbrevCountry = strlen(pchCountry) == 3;

    EnumSystemLocalesA(CountryEnumProc, LCID_INSTALLED);

    //  locale value is invalid if the country was not defined or
    //  no default language was found
    if (!(iLcidState & __LCID_FULL))
        iLcidState = 0;
}

/***
*BOOL CALLBACK CountryEnumProc - callback routine for GetLcidFromCountry
*
*Purpose:
*   Determine if LCID given matches the default language for the
*   country in pchCountry.
*
*Entry:
*   lpLcidString   - pointer to string with decimal LCID
*   pchCountry     - pointer to country name
*   bAbbrevCountry - set if country is three-letter abbreviation
*
*Exit:
*   lcidLanguage - lcidCountry - LCID matched
*   FALSE if match occurred to terminate enumeration, else TRUE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL CALLBACK CountryEnumProc (LPSTR lpLcidString)
{
    LCID    lcid = LcidFromHexString(lpLcidString);
    char    rgcInfo[120];

    //  test locale for country specified
    if ((*pfnGetLocaleInfoA)(lcid, bAbbrevCountry ? LOCALE_SABBREVCTRYNAME
                                                  : LOCALE_SENGCOUNTRY,
                       rgcInfo, sizeof(rgcInfo)) == 0)
    {
        //  set error condition and exit
        iLcidState = 0;
        return TRUE;
    }
    if (!_stricmp(pchCountry, rgcInfo))
    {
        //  language matched - test if locale country is default
        if (TestDefaultCountry(lcid))
        {
            //  this locale has the default language
            lcidLanguage = lcidCountry = lcid;
            iLcidState |= __LCID_FULL;
        }
    }
    return (iLcidState & __LCID_FULL) == 0;
}

/***
*void GetLcidFromDefault - get default LCIDs
*
*Purpose:
*   Set both language and country LCIDs to the system default.
*
*Entry:
*   None.
*
*Exit:
*   lcidLanguage - set to system LCID
*   lcidCountry  - set to system LCID
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromDefault (void)
{
    iLcidState |= (__LCID_FULL | __LCID_LANGUAGE);
    lcidLanguage = lcidCountry = GetUserDefaultLCID();
}

/***
*int ProcessCodePage - convert codepage string to numeric value
*
*Purpose:
*   Process codepage string consisting of a decimal string, or the
*   special case strings "ACP" and "OCP", for ANSI and OEM codepages,
*   respectively.  Null pointer or string returns the ANSI codepage.
*
*Entry:
*   lpCodePageStr - pointer to codepage string
*
*Exit:
*   Returns numeric value of codepage.
*
*Exceptions:
*
*******************************************************************************/
static int ProcessCodePage (LPSTR lpCodePageStr)
{
    char    chCodePage[8];

    if (!lpCodePageStr || !*lpCodePageStr || !strcmp(lpCodePageStr, "ACP"))
    {
        //  get ANSI codepage for the country LCID
        if ((*pfnGetLocaleInfoA)(lcidCountry, LOCALE_IDEFAULTANSICODEPAGE,
                                 chCodePage, sizeof(chCodePage)) == 0)
            return 0;
        lpCodePageStr = chCodePage;
    }
    else if (!strcmp(lpCodePageStr, "OCP"))
    {
        //  get OEM codepage for the country LCID
        if ((*pfnGetLocaleInfoA)(lcidCountry, LOCALE_IDEFAULTCODEPAGE,
                                 chCodePage, sizeof(chCodePage)) == 0)
            return 0;
        lpCodePageStr = chCodePage;
    }
    
    //  convert decimal string to numeric value
    return (int)atol(lpCodePageStr);
}

/***
*BOOL TestDefaultCountry - determine if default locale for country
*
*Purpose:
*   Using a hardcoded list, determine if the locale of the given LCID
*   has the default sublanguage for the locale primary language.  The
*   list contains the locales NOT having the default sublanguage.
*
*Entry:
*   lcid - LCID of locale to test
*
*Exit:
*   Returns TRUE if default sublanguage, else FALSE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL TestDefaultCountry (LCID lcid)
{
    LANGID  langid = LANGIDFROMLCID(lcid);
    int     i;

    for (i = 0; i < sizeof(__rglangidNotDefault) / sizeof(LANGID); i++)
    {
        if (langid == __rglangidNotDefault[i])
            return FALSE;
    }
    return TRUE;
}

/***
*BOOL TestDefaultLanguage - determine if default locale for language
*
*Purpose:
*   Determines if the given LCID has the default sublanguage.
*   If bTestPrimary is set, also allow TRUE when string contains an
*   implicit sublanguage.
*
*Entry:
*   LCID         - lcid of locale to test
*   bTestPrimary - set if testing if language is primary
*
*Exit:
*   Returns TRUE if sublanguage is default for locale tested.
*   If bTestPrimary set, TRUE is language has implied sublanguge.
*
*Exceptions:
*
*******************************************************************************/
static BOOL TestDefaultLanguage (LCID lcid, BOOL bTestPrimary)
{
    char    rgcInfo[120];
    LCID    lcidDefault = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(lcid)),
                                                  SUBLANG_DEFAULT), SORT_DEFAULT);

    if ((*pfnGetLocaleInfoA)(lcidDefault, LOCALE_ILANGUAGE, rgcInfo,
                                          sizeof(rgcInfo)) == 0)
        return FALSE;

    if (lcid != LcidFromHexString(rgcInfo))
    {
        //  test if string contains an implicit sublanguage by
        //  having a character other than upper/lowercase letters.
        if (bTestPrimary && GetPrimaryLen(pchLanguage) == (int)strlen(pchLanguage))
            return FALSE;
    }
    return TRUE;
}


/***
*int crtGetLocalInfoA - get locale information for Win95
*
*Purpose:
*   For Win95, some calls to GetLocaleInfoA return incorrect results.
*       Simulate these calls with values looked up in a hard-coded table.
*   
*Entry:
*       lcid - LCID of locale to get information from
*       lctype - index of information selection
*   lpdata - pointer to output string
*       cchdata - size of output string (including null)
*
*Exit:
*   lpdata - return string of locale information
*   returns TRUE if successful, else FALSE
*
*Exceptions:
*
*******************************************************************************/
static int __stdcall crtGetLocaleInfoA (LCID lcid, LCTYPE lctype, LPSTR lpdata,
                                                                  int cchdata)
{
    int          i;
    int          low = 0;
    int          high = sizeof(__rgLocInfo) / sizeof(RGLOCINFO) - 1;
    const char * pchResult = NULL;

    //  typical binary search - do until no more to search
    while (low <= high)
    {
        i = (low + high) / 2;
        if (lcid == __rgLocInfo[i].lcid)
        {
            //  LCID matched - test for valid LCTYPE to simulate call
            switch (lctype)
            {
                case LOCALE_ILANGUAGE:
                    pchResult = __rgLocInfo[i].chILanguage;
                    break;
                case LOCALE_SENGLANGUAGE:
                    pchResult = __rgLocInfo[i].pchSEngLanguage;
                    break;
                case LOCALE_SABBREVLANGNAME:
                    pchResult = __rgLocInfo[i].chSAbbrevLangName;
                    break;
                case LOCALE_SENGCOUNTRY:
                    pchResult = __rgLocInfo[i].pchSEngCountry;
                    break;
                case LOCALE_SABBREVCTRYNAME:
                    pchResult = __rgLocInfo[i].chSAbbrevCtryName;
                    break;
                case LOCALE_IDEFAULTCODEPAGE:
                    pchResult = __rgLocInfo[i].chIDefaultCodepage;
                    break;
                case LOCALE_IDEFAULTANSICODEPAGE:
                    pchResult = __rgLocInfo[i].chIDefaultAnsiCodepage;
                default:
                    break;
            }
            if (!pchResult || cchdata < 1)
                //      if LCTYPE did not match, break to use normal routine
                break;
            else
            {
                //      copy data as much as possible to result and null-terminate
                strncpy(lpdata, pchResult, cchdata - 1);
                *(lpdata + cchdata - 1) = '\0';
                return 1;
            }
        }
        else if (lcid < __rgLocInfo[i].lcid)
            high = i - 1;
        else
            low = i + 1;
    }
    //  LCID not found or LCTYPE not simulated
    return GetLocaleInfoA(lcid,lctype, lpdata, cchdata);
}


/***
*LCID LcidFromHexString - convert hex string to value for LCID
*
*Purpose:
*   LCID values returned in hex ANSI strings - straight conversion
*
*Entry:
*   lpHexString - pointer to hex string to convert
*
*Exit:
*   Returns LCID computed.
*
*Exceptions:
*
*******************************************************************************/
static LCID LcidFromHexString (LPSTR lpHexString)
{
    char    ch;
    DWORD   lcid = 0;

    while (ch = *lpHexString++)
    {
        if (ch >= 'a' && ch <= 'f')
            ch += '9' + 1 - 'a';
        else if (ch >= 'A' && ch <= 'F')
            ch += '9' + 1 - 'A';
        lcid = lcid * 0x10 + ch - '0';
    }

    return (LCID)lcid;
}

/***
*int GetPrimaryLen - get length of primary language name
*
*Purpose:
*   Determine primary language string length by scanning until
*   first non-alphabetic character.
*
*Entry:
*   pchLanguage - string to scan
*
*Exit:
*   Returns length of primary language string.
*
*Exceptions:
*
*******************************************************************************/
static int GetPrimaryLen (LPSTR pchLanguage)
{
    int     len = 0;
    char    ch;

    ch = *pchLanguage++;
    while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))
    {
        len++;
        ch = *pchLanguage++;
    }

    return len;
}

#endif  //if defined(_POSIX_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\initctyp.c ===
/***
*initctyp.c - contains __init_ctype
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_ctype().
*
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*Revision History:
*       12-08-91  ETC   Created.
*       12-20-91  ETC   Updated to use new NLSAPI GetLocaleInfo.
*       12-18-92  CFW   Ported to Cuda tree, changed _CALLTYPE4 to _CRTAPI3.
*       01-19-03  CFW   Move to _NEWCTYPETABLE, remove switch.
*       02-08-93  CFW   Bug fixes under _INTL switch.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-20-93  CFW   Check return val.
*       05-20-93  GJF   Include windows.h, not individual win*.h files
*       05-24-93  CFW   Clean up file (brief is evil).
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-15-93  CFW   Fix size parameters.
*       09-17-93  CFW   Use unsigned chars.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-22-93  CFW   NT merge.
*       11-09-93  CFW   Add code page for __crtxxx().
*       03-31-94  CFW   Include awint.h.
*       04-15-94  GJF   Made definitions of ctype1 and wctype1 conditional
*                       on DLL_FOR_WIN32S.
*       04-18-94  CFW   Pass lcid to _crtGetStringType.
*       09-06-94  CFW   Remove _INTL switch.
*       01-10-95  CFW   Debug CRT allocs.
*       02-02-95  BWT   Update POSIX support
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       11-25-97  GJF   When necessary, use LOCALE_IDEFAULTANSICODEPAGE,
*                       not LOCALE_IDEFAULTCODEPAGE.
*       06-29-98  GJF   Changed to support multithread scheme - old ctype
*                       tables must be kept around until all affected threads
*                       have updated or terminated.
*       03-05-99  GJF   Added __ctype1_refcount for use in cleaning up 
*                       per-thread ctype info.
*       09-06-00  GB    Made pwctype independent of locale.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*       07-07-01  BWT   Cleanup malloc/free abuse - Only free __ctype1/refcount/
*                       newctype1/cbuffer if they're no zero.  Init refcount to zero
*
*******************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <ctype.h>
#include <malloc.h>
#include <limits.h>
#include <awint.h>
#include <dbgint.h>
#ifdef _MT
#include <mtdll.h>
#endif

#define _CTABSIZE   257     /* size of ctype tables */

#ifdef  _MT
/* 
 * Keep track of how many threads are using a instance of the ctype info. Only
 * used for non-'C' locales.
 */
int *__ctype1_refcount;
#endif

unsigned short  *__ctype1;  /* keep around until next time */

/***
*int __init_ctype() - initialization for LC_CTYPE locale category.
*
*Purpose:
*       In non-C locales, preread ctype tables for chars and wide-chars.
*       Old tables are freed when new tables are fully established, else
*       the old tables remain intact (as if original state unaltered).
*       The leadbyte table is implemented as the high bit in ctype1.
*
*       In the C locale, ctype tables are freed, and pointers point to
*       the static ctype table.
*
*       Tables contain 257 entries: -1 to 256.
*       Table pointers point to entry 0 (to allow index -1).
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_ctype (
        void
        )
{
#if     defined(_POSIX_)
        return(0);
#else   /* _POSIX_ */
#ifdef  _MT
        int *refcount = NULL;
#endif
        /* non-C locale table for char's    */
        unsigned short *newctype1 = NULL;          /* temp new table */

        /* non-C locale table for wchar_t's */

        unsigned char *cbuffer = NULL;      /* char working buffer */

        int i;                              /* general purpose counter */
        unsigned char *cp;                  /* char pointer */
        CPINFO lpCPInfo;                    /* struct for use with GetCPInfo */

        /* allocate and set up buffers before destroying old ones */
        /* codepage will be restored by setlocale if error */

        if (__lc_handle[LC_CTYPE] != _CLOCALEHANDLE)
        {
            if (__lc_codepage == 0)
            { /* code page was not specified */
                if ( __getlocaleinfo( LC_INT_TYPE,
                                      MAKELCID(__lc_id[LC_CTYPE].wLanguage, SORT_DEFAULT),
                                      LOCALE_IDEFAULTANSICODEPAGE,
                                      (char **)&__lc_codepage ) )
                    goto error_cleanup;
            }

#ifdef  _MT
            /* allocate a new (thread) reference counter */
            refcount = (int *)_malloc_crt(sizeof(int));
#endif

            /* allocate new buffers for tables */
            newctype1 = (unsigned short *)
                _malloc_crt(_CTABSIZE * sizeof(unsigned short));
            cbuffer = (unsigned char *)
                _malloc_crt (_CTABSIZE * sizeof(char));

#ifdef  _MT
            if (!refcount || !newctype1 || !cbuffer )
#else
            if (!newctype1 || !cbuffer )
#endif
                goto error_cleanup;

#ifdef  _MT
            *refcount = 0;
#endif

            /* construct string composed of first 256 chars in sequence */
            for (cp=cbuffer, i=0; i<_CTABSIZE-1; i++)
                *cp++ = (unsigned char)i;

            if (GetCPInfo( __lc_codepage, &lpCPInfo) == FALSE)
                goto error_cleanup;

            if (lpCPInfo.MaxCharSize > MB_LEN_MAX)
                goto error_cleanup;

            __mb_cur_max = (unsigned short) lpCPInfo.MaxCharSize;

            /* zero out leadbytes so GetStringType doesn't interpret as multi-byte chars */
            if (__mb_cur_max > 1)
            {
                for (cp = (unsigned char *)lpCPInfo.LeadByte; cp[0] && cp[1]; cp += 2)
                {
                    for (i = cp[0]; i <= cp[1]; i++)
                        cbuffer[i] = 0;
                }
            }

            /* convert to newctype1 table - ignore invalid char errors */
            if ( __crtGetStringTypeA( CT_CTYPE1,
                                      cbuffer,
                                      _CTABSIZE-1,
                                      newctype1+1,
                                      0,
                                      0,
                                      FALSE ) == FALSE )
                goto error_cleanup;
            *newctype1 = 0; /* entry for EOF */

            /* ignore DefaultChar */

            /* mark lead-byte entries in newctype1 table */
            if (__mb_cur_max > 1)
            {
                for (cp = (unsigned char *)lpCPInfo.LeadByte; cp[0] && cp[1]; cp += 2)
                {
                    for (i = cp[0]; i <= cp[1]; i++)
                        newctype1[i+1] = _LEADBYTE;
                }
            }

            /* set pointers to point to entry 0 of tables */
            _pctype = newctype1 + 1;

#ifdef  _MT
            __ctype1_refcount = refcount;
#endif

            /* free old tables */
#ifndef _MT
            if (__ctype1)
                _free_crt (__ctype1);
#endif
            __ctype1 = newctype1;

            /* cleanup and return success */
            _free_crt (cbuffer);
            return 0;

error_cleanup:
#ifdef  _MT
            if (refcount)
                _free_crt (refcount);
#endif
            if (newctype1)
                _free_crt (newctype1);

            if (cbuffer)
                _free_crt (cbuffer);

            return 1;

        } else {

            /* set pointers to static C-locale table */
            _pctype = _ctype + 1;

#ifndef _MT
            /* free dynamic locale-specific tables */
            if (__ctype1)
                _free_crt (__ctype1);
#endif

#ifdef  _MT
            __ctype1_refcount = NULL;
#endif

            __ctype1 = NULL;

            return 0;
        }
#endif   /* _POSIX_ */
}

/* Define a number of functions which exist so, under _STATIC_CPPLIB, the
 * static multithread C++ Library libcpmt.lib can access data found in the
 * main CRT DLL without using __declspec(dllimport).
 */

_CRTIMP int __cdecl ___mb_cur_max_func(void)
{
        return __mb_cur_max;
}


_CRTIMP UINT __cdecl ___lc_codepage_func(void)
{
#ifdef _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return ptloci->lc_codepage;
#else
        return __lc_codepage;
#endif
}


_CRTIMP UINT __cdecl ___lc_collate_cp_func(void)
{
#ifdef _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return ptloci->lc_collate_cp;
#else
        return __lc_collate_cp;
#endif
}


_CRTIMP LCID* __cdecl ___lc_handle_func(void)
{
#ifdef _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return ptloci->lc_handle;
#else
        return __lc_handle;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\initcoll.c ===
/***
*initcoll.c - contains __init_collate
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains the locale-category initialization function: __init_collate().
*	
*	Each initialization function sets up locale-specific information
*	for their category, for use by functions which are affected by
*	their locale category.
*
*	*** For internal use by setlocale() only ***
*
*Revision History:
*	12-08-91  ETC	Created.
*	12-20-91  ETC	Minor beautification for consistency.
*	12-18-92  CFW	Ported to Cuda tree, changed _CALLTYPE4 to _CRTAPI3.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	05-20-93  GJF	Include windows.h, not individual win*.h files
*	05-24-93  CFW	Clean up file (brief is evil).
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-06-94  CFW   Remove _INTL switch.
*
*******************************************************************************/

#include <windows.h>
#include <locale.h>
#include <setlocal.h>

/***
*int __init_collate() - initialization for LC_COLLATE locale category.
*
*Purpose:
*	The LC_COLLATE category currently requires no initialization.
*
*Entry:
*	None.
*
*Exit:
*	0 success
*	1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_collate (
	void
	)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\initcrit.c ===
/***
*initcrit.c - CRT wrapper for InitializeCriticalSectionAndSpinCount
*
*       Copyright (c) 1999-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains __crtInitCritSecAndSpinCount, a wrapper for
*       the Win32 API InitializeCriticalSectionAndSpinCount which is only
*       available on NT4SP3 or better.
*
*       *** For internal use only ***
*
*Revision History:
*       10-14-99  PML   Created.
*       02-20-01  PML   __crtInitCritSecAndSpinCount now returns on failure
*                       Also, call InitializeCriticalSectionAndSpinCount if
*                       available, instead of calling InitializeCriticalSection
*                       and then SetCriticalSectionSpinCount. (vs7#172586)
*       04-24-01  PML   Use GetModuleHandle, not LoadLibrary/FreeLibrary which
*                       aren't safe during DLL_PROCESS_ATTACH (vs7#244210)
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <windows.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>

typedef
BOOL
(WINAPI * PFN_INIT_CRITSEC_AND_SPIN_COUNT) (
    PCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);

/***
*void __crtInitCritSecNoSpinCount() - InitializeCriticalSectionAndSpinCount
*                                     wrapper
*
*Purpose:
*       For systems where the Win32 API InitializeCriticalSectionAndSpinCount
*       is unavailable, this is called instead.  It just calls
*       InitializeCriticalSection and ignores the spin count.
*
*Entry:
*       PCRITICAL_SECTION lpCriticalSection - ptr to critical section
*       DWORD dwSpinCount - initial spin count setting
*
*Exit:
*       Always returns TRUE
*
*Exceptions:
*       InitializeCriticalSection can raise a STATUS_NO_MEMORY exception.
*
*******************************************************************************/

static BOOL WINAPI __crtInitCritSecNoSpinCount (
    PCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    )
{
    InitializeCriticalSection(lpCriticalSection);
    return TRUE;
}

/***
*int __crtInitCritSecAndSpinCount() - initialize critical section
*
*Purpose:
*       Calls InitializeCriticalSectionAndSpinCount, if available, otherwise
*       InitializeCriticalSection.  On multiprocessor systems, a spin count
*       should be used with critical sections, but the appropriate APIs are
*       only available on NT4SP3 or later.
*
*       Also handles the out of memory condition which is possible with
*       InitializeCriticalSection[AndSpinCount].
*
*Entry:
*       PCRITICAL_SECTION lpCriticalSection - ptr to critical section
*       DWORD dwSpinCount - initial spin count setting
*
*Exit:
*       Returns FALSE and sets Win32 last-error code to ERROR_NOT_ENOUGH_MEMORY
*       if InitializeCriticalSection[AndSpinCount] fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtInitCritSecAndSpinCount (
    PCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    )
{
    static PFN_INIT_CRITSEC_AND_SPIN_COUNT __crtInitCritSecAndSpinCount = NULL;
    int ret;

    if (__crtInitCritSecAndSpinCount == NULL) {
        /*
         * First time through, see if InitializeCriticalSectionAndSpinCount
         * is available.  If not, use a wrapper over InitializeCriticalSection
         * instead.
         */
        if (_osplatform == VER_PLATFORM_WIN32_WINDOWS) {
            /*
             * Win98 and WinME export InitializeCriticalSectionAndSpinCount,
             * but it is non-functional (it should return a BOOL, but is
             * VOID instead, returning a useless return value).  Use the
             * dummy API instead.
             */
            __crtInitCritSecAndSpinCount = __crtInitCritSecNoSpinCount;
        }
        else {
            HINSTANCE hKernel32 = GetModuleHandle("kernel32.dll");
            if (hKernel32 != NULL) {
                __crtInitCritSecAndSpinCount = (PFN_INIT_CRITSEC_AND_SPIN_COUNT)
                    GetProcAddress(hKernel32,
                                   "InitializeCriticalSectionAndSpinCount");

                if (__crtInitCritSecAndSpinCount == NULL) {
                    /*
                     * InitializeCriticalSectionAndSpinCount not available,
                     * use dummy API
                     */
                    __crtInitCritSecAndSpinCount = __crtInitCritSecNoSpinCount;
                }
            }
            else {
                /*
                 * GetModuleHandle failed (should never happen),
                 * use dummy API
                 */
                __crtInitCritSecAndSpinCount = __crtInitCritSecNoSpinCount;
            }
        }
    }

    __try {
        /*
         * Call the real InitializeCriticalSectionAndSpinCount, or the
         * wrapper which just calls InitializeCriticalSection if the newer
         * API is not available.
         */
        ret = __crtInitCritSecAndSpinCount(lpCriticalSection, dwSpinCount);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        /*
         * Initialization failed by raising an exception, which is probably
         * STATUS_NO_MEMORY.  It is not safe to set the CRT errno to ENOMEM,
         * since the per-thread data may not yet exist.  Instead, set the Win32
         * error which can be mapped to ENOMEM later.
         */
        if (GetExceptionCode() == STATUS_NO_MEMORY) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
        ret = FALSE;
    }

    return ret;
}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\initmon.c ===
/***
*initmon.c - contains __init_monetary
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_monetary().
*       
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*Revision History:
*       12-08-91  ETC   Created.
*       12-20-91  ETC   Updated to use new NLSAPI GetLocaleInfo.
*       12-18-92  CFW   Ported to Cuda tree, changed _CALLTYPE4 to _CRTAPI3.
*       12-29-92  CFW   Updated to use new _getlocaleinfo wrapper function.
*       01-25-93  KRS   Changed _getlocaleinfo interface again.
*       02-08-93  CFW   Added _lconv_static_*.
*       02-17-93  CFW   Removed debugging print statement.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-20-93  CFW   Check return val.
*       05-20-93  GJF   Include windows.h, not individual win*.h files
*       05-24-93  CFW   Clean up file (brief is evil).
*       06-11-93  CFW   Now inithelp takes void *.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  GJF   Merged NT SDK and Cuda versions.
*       04-15-94  GJF   Removed declarations of __lconv and __lconv_c (both
*                       are declared in setlocal.h). Made definition of
*                       __lconv_intl conditional on DLL_FOR_WIN32S.
*       08-02-94  CFW   Change "3;0" to "\3" for grouping as per ANSI.
*       09-06-94  CFW   Remove _INTL switch.
*       01-10-95  CFW   Debug CRT allocs.
*       06-30-98  GJF   Changed to support new multithread scheme - old lconv
*                       structs must be kept around until all affected threads
*                       have updated or terminated.
*       12-08-98  GJF   Fixed logic in __free_lconv_mon.
*       03-15-99  GJF   Added __lconv_mon_refcount
*       04-24-99  PML   Added __lconv_intl_refcount
*       10-12-00  PML   Don't call fix_grouping if error detected (vs7#169596)
*
*******************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <malloc.h>
#include <limits.h>
#include <dbgint.h>

void __cdecl __free_lconv_mon(struct lconv *);
static void fix_grouping(char *);

/* Pointer to non-C locale lconv */
struct lconv *__lconv_intl = NULL;

#ifdef  _MT
/*
 * Reference counter for locale info. The value is non-NULL iff the 
 * info is not from the C locale.
 */
int *__lconv_intl_refcount;

/*
 * Reference counter for monetary locale info. The value is non-NULL iff the 
 * monetary info is not from the C locale.
 */
int *__lconv_mon_refcount;
#endif

/*
 *  Note that __lconv_c is used when the monetary category is in the C locale
 *  but the numeric category may not necessarily be in the C locale.
 */


/***
*int __init_monetary() - initialization for LC_MONETARY locale category.
*
*Purpose:
*       In non-C locales, read the localized monetary strings into
*       __lconv_intl, and also copy the numeric strings from __lconv into
*       __lconv_intl.  Set __lconv to point to __lconv_intl.  The old 
*       __lconv_intl is not freed until the new one is fully established.
*
*       In the C locale, the monetary fields in lconv are filled with
*       contain C locale values.  Any allocated __lconv_intl fields are freed.
*
*       At startup, __lconv points to a static lconv structure containing
*       C locale strings.  This structure is never used again if
*       __init_monetary is called.
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_monetary (
        void
        )
{
        struct lconv *lc;
        int ret;
        LCID ctryid;
#ifdef  _MT
        int *lc_refcount;
#endif

        if ( (__lc_handle[LC_MONETARY] != _CLOCALEHANDLE) ||
             (__lc_handle[LC_NUMERIC] != _CLOCALEHANDLE) )
        {
            /* 
             * Allocate structure filled with NULL pointers 
             */
            if ( (lc = (struct lconv *)
                 _calloc_crt(1, sizeof(struct lconv))) == NULL )
                return 1;

#ifdef  _MT
            /*
             * Allocate a new reference counter for the lconv structure
             */
            if ( (lc_refcount = _malloc_crt(sizeof(int))) == NULL )
            {
                _free_crt(lc);
                return 1;
            }
            *lc_refcount = 0;
#endif

            if ( __lc_handle[LC_MONETARY] != _CLOCALEHANDLE )
            {
#ifdef  _MT
                /*
                 * Allocate a new reference counter for the monetary info
                 */
                if ( (__lconv_mon_refcount = _malloc_crt(sizeof(int))) == NULL )
                {
                    _free_crt(lc);
                    _free_crt(lc_refcount);
                    return 1;
                }
                *__lconv_mon_refcount = 0;

#endif
                /* 
                 * Currency is country--not language--dependent. NT 
                 * work-around.
                 */
                ctryid = MAKELCID(__lc_id[LC_MONETARY].wCountry, SORT_DEFAULT);

                ret = 0;

                ret |= __getlocaleinfo( LC_STR_TYPE, ctryid,
                        LOCALE_SINTLSYMBOL, (void *)&lc->int_curr_symbol );
                ret |= __getlocaleinfo( LC_STR_TYPE, ctryid, 
                        LOCALE_SCURRENCY, (void *)&lc->currency_symbol );
                ret |= __getlocaleinfo( LC_STR_TYPE, ctryid,
                        LOCALE_SMONDECIMALSEP, (void *)&lc->mon_decimal_point );
                ret |= __getlocaleinfo( LC_STR_TYPE, ctryid,
                        LOCALE_SMONTHOUSANDSEP, (void *)&lc->mon_thousands_sep );
                ret |= __getlocaleinfo(LC_STR_TYPE, ctryid,
                        LOCALE_SMONGROUPING, (void *)&lc->mon_grouping );

                ret |= __getlocaleinfo( LC_STR_TYPE, ctryid,
                        LOCALE_SPOSITIVESIGN, (void *)&lc->positive_sign);
                ret |= __getlocaleinfo( LC_STR_TYPE, ctryid,
                        LOCALE_SNEGATIVESIGN, (void *)&lc->negative_sign);

                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_IINTLCURRDIGITS, (void *)&lc->int_frac_digits);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_ICURRDIGITS, (void *)&lc->frac_digits);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_IPOSSYMPRECEDES, (void *)&lc->p_cs_precedes);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_IPOSSEPBYSPACE, (void *)&lc->p_sep_by_space);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_INEGSYMPRECEDES, (void *)&lc->n_cs_precedes);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_INEGSEPBYSPACE, (void *)&lc->n_sep_by_space);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_IPOSSIGNPOSN, (void *)&lc->p_sign_posn);
                ret |= __getlocaleinfo( LC_INT_TYPE, ctryid,
                        LOCALE_INEGSIGNPOSN, (void *)&lc->n_sign_posn);

                if ( ret != 0 ) {
                    __free_lconv_mon(lc);
                    _free_crt(lc);
#ifdef  _MT
                    _free_crt(lc_refcount);
#endif
                    return 1;
                }

                fix_grouping(lc->mon_grouping);
            }
            else {
                /*
                 * C locale for monetary category (the numeric category fields,
                 * which are NOT of the C locale, get fixed up below). Note 
                 * that __lconv_c is copied, rather than directly assigning
                 * the fields of lc because of the uncertainty of the values of
                 * the int_frac_digits,..., n_sign_posn fields (SCHAR_MAX or
                 * UCHAR_MAX, depending on whether or a compliand was built
                 * with -J.
                 */
                *lc = __lconv_c;
#ifdef  _MT
                /*
                 * NULL out the reference count pointer
                 */
                __lconv_mon_refcount = NULL;
#endif
            }

            /* 
             * Copy the numeric locale fields from the old struct
             */
            lc->decimal_point = __lconv->decimal_point;
            lc->thousands_sep = __lconv->thousands_sep;
            lc->grouping = __lconv->grouping;

            __lconv = lc;                       /* point to new one */
#ifdef  _MT
            __lconv_intl_refcount = lc_refcount;
#else
            __free_lconv_mon(__lconv_intl);  /* free the old one */
            _free_crt(__lconv_intl);
#endif
            __lconv_intl = lc;

        }
        else {
            /*
             * C locale for BOTH monetary and numeric categories.
             */
#ifdef  _MT
            /*
             * NULL out the reference count pointer
             */
            __lconv_mon_refcount = NULL;
            __lconv_intl_refcount = NULL;
#else
            __free_lconv_mon(__lconv_intl);     /* free the old one */
            _free_crt(__lconv_intl);
#endif
            __lconv = &__lconv_c;               /* point to new one */
            __lconv_intl = NULL;

        }

        return 0;
}

static void fix_grouping(
        char *grouping
        )
{
        /*
         * ANSI specifies that the fields should contain "\3" [\3\0] to indicate
         * thousands groupings (100,000,000.00 for example).
         * NT uses "3;0"; ASCII 3 instead of value 3 and the ';' is extra.
         * So here we convert the NT version to the ANSI version.
         */

        while (*grouping)
        {
            /* convert '3' to '\3' */
            if (*grouping >= '0' && *grouping <= '9')
            {    
                *grouping = *grouping - '0';
                grouping++;
            }

            /* remove ';' */
            else if (*grouping == ';')
            {
                char *tmp = grouping;

                do
                    *tmp = *(tmp+1);
                while (*++tmp);
            }

            /* unknown (illegal) character, ignore */
            else
                grouping++;
        }
}


/*
 *  Free the lconv monetary strings.
 *  Numeric values do not need to be freed.
 */
void __cdecl __free_lconv_mon(
        struct lconv *l
        )
{
        if (l == NULL)
            return;

#ifdef  _MT
        if ( (l->int_curr_symbol != __lconv->int_curr_symbol) &&
             (l->int_curr_symbol != __lconv_c.int_curr_symbol) )
#else
        if ( l->int_curr_symbol != __lconv_c.int_curr_symbol )
#endif
            _free_crt(l->int_curr_symbol);

#ifdef  _MT
        if ( (l->currency_symbol != __lconv->currency_symbol) &&
             (l->currency_symbol != __lconv_c.currency_symbol) )
#else
        if ( l->currency_symbol != __lconv_c.currency_symbol )
#endif
            _free_crt(l->currency_symbol);

#ifdef  _MT
        if ( (l->mon_decimal_point != __lconv->mon_decimal_point) &&
             (l->mon_decimal_point != __lconv_c.mon_decimal_point) )
#else
        if ( l->mon_decimal_point != __lconv_c.mon_decimal_point )
#endif
            _free_crt(l->mon_decimal_point);

#ifdef  _MT
        if ( (l->mon_thousands_sep != __lconv->mon_thousands_sep) &&
             (l->mon_thousands_sep != __lconv_c.mon_thousands_sep) )
#else
        if ( l->mon_thousands_sep != __lconv_c.mon_thousands_sep )
#endif
            _free_crt(l->mon_thousands_sep);

#ifdef  _MT
        if ( (l->mon_grouping != __lconv->mon_grouping) &&
             (l->mon_grouping != __lconv_c.mon_grouping) )
#else
        if ( l->mon_grouping != __lconv_c.mon_grouping )
#endif
            _free_crt(l->mon_grouping);

#ifdef  _MT
        if ( (l->positive_sign != __lconv->positive_sign) &&
             (l->positive_sign != __lconv_c.positive_sign) )
#else
        if ( l->positive_sign != __lconv_c.positive_sign )
#endif
            _free_crt(l->positive_sign);

#ifdef  _MT
        if ( (l->negative_sign != __lconv->negative_sign) &&
             (l->negative_sign != __lconv_c.negative_sign) )
#else
        if ( l->negative_sign != __lconv_c.negative_sign )
#endif
            _free_crt(l->negative_sign);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\inithelp.c ===
/***
*inithelp.c - Contains the __getlocaleinfo helper routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*  Contains the __getlocaleinfo helper routine.
*
*Revision History:
*       12-28-92  CFW   Module created, _getlocaleinfo ported to Cuda tree.
*       12-29-92  CFW   Update for new GetLocaleInfoW, add LC_*_TYPE handling.
*       01-25-93  KRS   Change category argument to LCID.
*       02-02-93  CFW   Optimized INT case, bug fix in STR case.
*       02-08-93  CFW   Optimized GetQualifiedLocale call, cast to remove warnings.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-20-93  CFW   JonM's GetLocaleInfoW fixup, cast to avoid trashing memory.
*       05-24-93  CFW   Clean up file (brief is evil).
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-22-93  CFW   NT merge.
*       11-09-93  CFW   Add code page for __crtxxx().
*       03-31-94  CFW   Include awint.h.
*       04-15-94  GJF   Made definition of wcbuffer conditional on
*                       DLL_FOR_WIN32S
*       09-06-94  CFW   Remove _INTL switch.
*       01-10-95  CFW   Debug CRT allocs.
*       02-02-95  BWT   Update POSIX support.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <stdlib.h>
#include <cruntime.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

/***
*__getlocaleinfo - return locale data
*
*Purpose:
*       Return locale data appropriate for the setlocale init functions.
*       In particular, wide locale strings are converted to char strings
*       or numeric depending on the value of the first parameter.
*
*       Memory is allocated for the char version of the data, and the
*       calling function's pointer is set to it.  This pointer should later
*       be used to free the data.  The wide-char data is fetched using
*       GetLocaleInfo and converted to multibyte using WideCharToMultiByte.
*
*       *** For internal use by the __init_* functions only ***
*
*       *** Future optimization ***
*       When converting a large number of wide-strings to multibyte, do
*       not query the size of the result, but convert them one after
*       another into a large character buffer.  The entire buffer can
*       also be freed with one pointer.
*
*Entry:
*       int lc_type - LC_STR_TYPE for string data, LC_INT_TYPE for numeric data
*       LCID localehandle - LCID based on category and lang or ctry of __lc_id
*       LCTYPE fieldtype - int or string value
*       void *address - cast to either char * or char**
*
*Exit:
*        0  success
*       -1  failure
*
*Exceptions:
*
*******************************************************************************/

#if NO_ERROR == -1 /*IFSTRIP=IGN*/
#error Need to use another error return code in __getlocaleinfo
#endif

#define STR_CHAR_CNT    128
#define INT_CHAR_CNT    4

int __cdecl __getlocaleinfo (
        int lc_type,
        LCID localehandle,
        LCTYPE fieldtype,
        void *address
        )
{
#if !defined(_POSIX_)
        if (lc_type == LC_STR_TYPE)
        {
            char **straddress = (char **)address;
            unsigned char cbuffer[STR_CHAR_CNT];
            unsigned char *pcbuffer = cbuffer;
            int bufferused = 0; /* 1 indicates buffer points to malloc'ed memory */
            int buffersize = STR_CHAR_CNT;
            int outsize;

            if ((outsize = __crtGetLocaleInfoA(localehandle, fieldtype, pcbuffer, buffersize, 0))
                == 0)
            {
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    goto error;

                /* buffersize too small, get required size and malloc new buffer */

                if ((buffersize = __crtGetLocaleInfoA (localehandle, fieldtype, NULL, 0, 0))
                    == 0)
                    goto error;

                if ((pcbuffer = (unsigned char *) _malloc_crt (buffersize * sizeof(unsigned char)))
                    == NULL)
                    goto error;

                bufferused = 1;

                if ((outsize = __crtGetLocaleInfoA (localehandle, fieldtype, pcbuffer, buffersize, 0))
                    == 0)
                    goto error;
            }

            if ((*straddress = (char *) _malloc_crt (outsize * sizeof(char))) == NULL)
                goto error;

            strncpy(*straddress, pcbuffer, outsize);

            if (bufferused)
                _free_crt (pcbuffer);

            return 0;

error:
            if (bufferused)
                _free_crt (pcbuffer);
            return -1;

        } else if (lc_type == LC_INT_TYPE)
        {
            int i;
            char c;
            static wchar_t wcbuffer[INT_CHAR_CNT];
            const int buffersize = INT_CHAR_CNT;
            char *charaddress = (char *)address;

            if (__crtGetLocaleInfoW (localehandle, fieldtype, (LPWSTR)&wcbuffer, buffersize, 0) == 0)
                return -1;

            *(char *)charaddress = 0;

            /* assume GetLocaleInfoW returns valid ASCII integer in wcstr format */
            for (i = 0; i < INT_CHAR_CNT; i++)
            {
                if (isdigit(((unsigned char)c = (unsigned char)wcbuffer[i])))
                    *(unsigned char *)charaddress = (unsigned char)(10 * (int)(*charaddress) + (c - '0'));
                else
                    break;
            }
            return 0;
        }
#endif  /* _POSIX_ */
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\inittime.c ===
/***
*inittime.c - contains __init_time
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_time().
*       
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*Revision History:
*       12-08-91  ETC   Created.
*       12-20-91  ETC   Updated to use new NLSAPI GetLocaleInfo.
*       12-18-92  CFW   Ported to Cuda tree, changed _CALLTYPE4 to _CRTAPI3.
*       12-29-92  CFW   Updated to use new _getlocaleinfo wrapper function.
*       01-25-93  KRS   Adapted to use ctry or lang dependent data, as approp.
*       02-08-93  CFW   Casts to remove warnings.
*       02-16-93  CFW   Added support for date and time strings.
*       03-09-93  CFW   Use char* time_sep in storeTimeFmt.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-20-93  GJF   Include windows.h, not individual win*.h files
*       05-24-93  CFW   Clean up file (brief is evil).
*       06-11-93  CFW   Now inithelp takes void *.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  GJF   Merged NT SDK and Cuda versions.
*       04-11-94  GJF   Made declaration of __lc_time_curr, and definition of
*                       __lc_time_intl conditional on ndef DLL_FOR_WIN32S.
*                       Also, made storeTimeFmt() into a static function.
*       09-06-94  CFW   Remove _INTL switch.
*       01-10-95  CFW   Debug CRT allocs.
*       08-20-97  GJF   Get time format string from Win32 rather than making
*                       up our own.
*       06-26-98  GJF   Changed to support multithread scheme - an old 
*                       __lc_time_data struct must be kept around until all
*                       affected threads have updated or terminated.
*       03-25-01  PML   Add ww_caltype & ww_lcid to __lc_time_data (vs7#196892)
*
*******************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <malloc.h>
#include <dbgint.h>

static int __cdecl _get_lc_time(struct __lc_time_data *lc_time);
void __cdecl __free_lc_time(struct __lc_time_data *lc_time);

/* C locale time strings */
extern struct __lc_time_data __lc_time_c;

/* Pointer to current time strings */
extern struct __lc_time_data *__lc_time_curr;

/* Pointer to non-C locale time strings */
struct __lc_time_data *__lc_time_intl = NULL;

/***
*int __init_time() - initialization for LC_TIME locale category.
*
*Purpose:
*       In non-C locales, read the localized time/date strings into
*       __lc_time_intl, and set __lc_time_curr to point to it.  The old
*       __lc_time_intl is not freed until the new one is fully established.
*       
*       In the C locale, __lc_time_curr is made to point to __lc_time_c.
*       Any allocated __lc_time_intl structures are freed.
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_time (
        void
        )
{
        /* Temporary date/time strings */
        struct __lc_time_data *lc_time;

        if ( __lc_handle[LC_TIME] != _CLOCALEHANDLE )
        {
                /* Allocate structure filled with NULL pointers */
                if ( (lc_time = (struct __lc_time_data *) 
                     _calloc_crt(1, sizeof(struct __lc_time_data))) == NULL )
                        return 1;

                if (_get_lc_time (lc_time))
                {
                        __free_lc_time (lc_time);
                        _free_crt (lc_time);
                        return 1;
                }

                __lc_time_curr = lc_time;           /* point to new one */
#ifndef _MT
                __free_lc_time (__lc_time_intl);    /* free the old one */
                _free_crt (__lc_time_intl);
#endif
                __lc_time_intl = lc_time;
                return 0;

        } else {
                __lc_time_curr = &__lc_time_c;      /* point to new one */
#ifndef _MT
                __free_lc_time (__lc_time_intl);    /* free the old one */
                _free_crt (__lc_time_intl);
#endif
                __lc_time_intl = NULL;
                return 0;
        }
}

/*
 *  Get the localized time strings.
 *  Of course, this can be beautified with some loops!
 */
static int __cdecl _get_lc_time (
        struct __lc_time_data *lc_time
        )
{
        int ret = 0;

        /* Some things are language-dependent and some are country-dependent.
        This works around an NT limitation and lets us distinguish the two. */

        LCID langid = MAKELCID(__lc_id[LC_TIME].wLanguage, SORT_DEFAULT);
        LCID ctryid = MAKELCID(__lc_id[LC_TIME].wCountry, SORT_DEFAULT);

        if (lc_time == NULL)
                return -1;

        /* All the text-strings are Language-dependent: */

        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME1, (void *)&lc_time->wday_abbr[1]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME2, (void *)&lc_time->wday_abbr[2]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME3, (void *)&lc_time->wday_abbr[3]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME4, (void *)&lc_time->wday_abbr[4]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME5, (void *)&lc_time->wday_abbr[5]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME6, (void *)&lc_time->wday_abbr[6]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME7, (void *)&lc_time->wday_abbr[0]);

        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME1, (void *)&lc_time->wday[1]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME2, (void *)&lc_time->wday[2]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME3, (void *)&lc_time->wday[3]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME4, (void *)&lc_time->wday[4]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME5, (void *)&lc_time->wday[5]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME6, (void *)&lc_time->wday[6]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SDAYNAME7, (void *)&lc_time->wday[0]);

        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME1, (void *)&lc_time->month_abbr[0]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME2, (void *)&lc_time->month_abbr[1]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME3, (void *)&lc_time->month_abbr[2]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME4, (void *)&lc_time->month_abbr[3]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME5, (void *)&lc_time->month_abbr[4]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME6, (void *)&lc_time->month_abbr[5]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME7, (void *)&lc_time->month_abbr[6]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME8, (void *)&lc_time->month_abbr[7]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME9, (void *)&lc_time->month_abbr[8]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME10, (void *)&lc_time->month_abbr[9]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME11, (void *)&lc_time->month_abbr[10]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME12, (void *)&lc_time->month_abbr[11]);

        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME1, (void *)&lc_time->month[0]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME2, (void *)&lc_time->month[1]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME3, (void *)&lc_time->month[2]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME4, (void *)&lc_time->month[3]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME5, (void *)&lc_time->month[4]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME6, (void *)&lc_time->month[5]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME7, (void *)&lc_time->month[6]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME8, (void *)&lc_time->month[7]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME9, (void *)&lc_time->month[8]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME10, (void *)&lc_time->month[9]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME11, (void *)&lc_time->month[10]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_SMONTHNAME12, (void *)&lc_time->month[11]);

        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_S1159, (void *)&lc_time->ampm[0]);
        ret |= __getlocaleinfo(LC_STR_TYPE, langid, LOCALE_S2359, (void *)&lc_time->ampm[1]);


/* The following relate to time format and are Country-dependent: */

        ret |= __getlocaleinfo(LC_STR_TYPE, ctryid, LOCALE_SSHORTDATE, (void *)&lc_time->ww_sdatefmt);
        ret |= __getlocaleinfo(LC_STR_TYPE, ctryid, LOCALE_SLONGDATE, (void *)&lc_time->ww_ldatefmt);

        ret |= __getlocaleinfo(LC_STR_TYPE, ctryid, LOCALE_STIMEFORMAT, (void *)&lc_time->ww_timefmt);

        ret |= __getlocaleinfo(LC_INT_TYPE, ctryid, LOCALE_ICALENDARTYPE, (void *)&lc_time->ww_caltype);

        lc_time->ww_lcid = ctryid;

        return ret;
}

/*
 *  Free the localized time strings.
 *  Of course, this can be beautified with some loops!
 */
void __cdecl __free_lc_time (
        struct __lc_time_data *lc_time
        )
{
        if (lc_time == NULL)
                return;

        _free_crt (lc_time->wday_abbr[1]);
        _free_crt (lc_time->wday_abbr[2]);
        _free_crt (lc_time->wday_abbr[3]);
        _free_crt (lc_time->wday_abbr[4]);
        _free_crt (lc_time->wday_abbr[5]);
        _free_crt (lc_time->wday_abbr[6]);
        _free_crt (lc_time->wday_abbr[0]);

        _free_crt (lc_time->wday[1]);
        _free_crt (lc_time->wday[2]);
        _free_crt (lc_time->wday[3]);
        _free_crt (lc_time->wday[4]);
        _free_crt (lc_time->wday[5]);
        _free_crt (lc_time->wday[6]);
        _free_crt (lc_time->wday[0]);

        _free_crt (lc_time->month_abbr[0]);
        _free_crt (lc_time->month_abbr[1]);
        _free_crt (lc_time->month_abbr[2]);
        _free_crt (lc_time->month_abbr[3]);
        _free_crt (lc_time->month_abbr[4]);
        _free_crt (lc_time->month_abbr[5]);
        _free_crt (lc_time->month_abbr[6]);
        _free_crt (lc_time->month_abbr[7]);
        _free_crt (lc_time->month_abbr[8]);
        _free_crt (lc_time->month_abbr[9]);
        _free_crt (lc_time->month_abbr[10]);
        _free_crt (lc_time->month_abbr[11]);

        _free_crt (lc_time->month[0]);
        _free_crt (lc_time->month[1]);
        _free_crt (lc_time->month[2]);
        _free_crt (lc_time->month[3]);
        _free_crt (lc_time->month[4]);
        _free_crt (lc_time->month[5]);
        _free_crt (lc_time->month[6]);
        _free_crt (lc_time->month[7]);
        _free_crt (lc_time->month[8]);
        _free_crt (lc_time->month[9]);
        _free_crt (lc_time->month[10]);
        _free_crt (lc_time->month[11]);

        _free_crt (lc_time->ampm[0]);
        _free_crt (lc_time->ampm[1]);

        _free_crt (lc_time->ww_sdatefmt);
        _free_crt (lc_time->ww_ldatefmt);
        _free_crt (lc_time->ww_timefmt);
/* Don't need to make these pointers NULL */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\initnum.c ===
/***
*initnum.c - contains __init_numeric
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_numeric().
*       
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*Revision History:
*       12-08-91  ETC   Created.
*       12-20-91  ETC   Updated to use new NLSAPI GetLocaleInfo.
*       12-18-92  CFW   Ported to Cuda tree, changed _CALLTYPE4 to _CRTAPI3.
*       12-29-92  CFW   Updated to use new _getlocaleinfo wrapper function.
*       01-25-93  KRS   Change interface to _getlocaleinfo again.
*       02-08-93  CFW   Added _lconv_static_*.
*       02-17-93  CFW   Removed debugging print statement.
*       03-17-93  CFW   C locale thousands sep is "", not ",".
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-08-93  SKS   Replace strdup() with ANSI-conforming _strdup()
*       04-20-93  CFW   Check return val.
*       05-20-93  GJF   Include windows.h, not individual win*.h files
*       05-24-93  CFW   Clean up file (brief is evil).
*       06-11-93  CFW   Now inithelp takes void *.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-23-93  GJF   Merged NT SDK and Cuda versions.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-06-94  GJF   Removed declaration of __lconv (it is declared in
*                       setlocal.h). Renamed static vars, decimal_point
*                       thousands_sep and grouping to dec_pnt, thous_sep
*                       and grping (resp.). Made the definitions of these
*                       conditional on DLL_FOR_WIN32S.
*       08-02-94  CFW   Change "3;0" to "\3" for grouping as per ANSI.
*       09-06-94  CFW   Remove _INTL switch.
*       01-10-95  CFW   Debug CRT allocs.
*       01-18-95  GJF   Fixed bug introduced with the change above - resetting
*                       to the C locale didn't reset the thousand_sep and
*                       grouping fields correctly.
*       02-06-95  CFW   assert -> _ASSERTE.
*       07-06-98  GJF   Changed to support new multithread scheme - old lconv
*                       structs must be kept around until all affected threads
*                       have updated or terminated.
*       12-08-98  GJF   Fixed logic in __free_lconv_num.
*       01-25-99  GJF   No, I didn't!  Try again...
*       03-15-99  GJF   Added __lconv_num_refcount
*       04-24-99  PML   Added __lconv_intl_refcount
*       09-08-00  GB    Fixed leak of __lconv_intl in init_numeric for single
*                       thread case.
*       10-12-00  PML   Don't call fix_grouping if error detected (vs7#169596)
*       11-05-00  PML   Fixed double-free of __lconv_intl (vs7#181380)
*
*******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <malloc.h>
#include <nlsint.h>
#include <dbgint.h>

void __cdecl __free_lconv_num(struct lconv *);

extern struct lconv *__lconv_intl;

#ifdef  _MT
/*
 * Reference counter for numeric locale info. The value is non-NULL iff the 
 * numeric info is not from the C locale.
 */
int *__lconv_num_refcount;

extern int *__lconv_intl_refcount;
#endif

static void fix_grouping(
        char *grouping
        )
{
        /*
         * ANSI specifies that the fields should contain "\3" [\3\0] to indicate
         * thousands groupings (100,000,000.00 for example).
         * NT uses "3;0"; ASCII 3 instead of value 3 and the ';' is extra.
         * So here we convert the NT version to the ANSI version.
         */

        while (*grouping)
        {
            /* convert '3' to '\3' */
            if (*grouping >= '0' && *grouping <= '9')
            {    
                *grouping = *grouping - '0';
                grouping++;
            }

            /* remove ';' */
            else if (*grouping == ';')
            {
                char *tmp = grouping;

                do
                    *tmp = *(tmp+1);
                while (*++tmp);
            }

            /* unknown (illegal) character, ignore */
            else
                grouping++;
        }
}

/***
*int __init_numeric() - initialization for LC_NUMERIC locale category.
*
*Purpose:
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_numeric (
        void
        )
{
        struct lconv *lc;
        int ret = 0;
        LCID ctryid;
#ifdef  _MT
        int *lc_refcount;
#endif

        if ( (__lc_handle[LC_NUMERIC] != _CLOCALEHANDLE) ||
             (__lc_handle[LC_MONETARY] != _CLOCALEHANDLE) )
        {
            /*
             * Allocate structure filled with NULL pointers
             */
            if ( (lc = (struct lconv *)_calloc_crt(1, sizeof(struct lconv)))
                 == NULL )
                return 1;

            /*
             * Copy over all fields (esp., the monetary category)
             */
            *lc = *__lconv;

#ifdef  _MT
            /*
             * Allocate a new reference counter for the lconv structure
             */
            if ( (lc_refcount = _malloc_crt(sizeof(int))) == NULL )
            {
                _free_crt(lc);
                return 1;
            }
            *lc_refcount = 0;
#endif

            if ( __lc_handle[LC_NUMERIC] != _CLOCALEHANDLE )
            {
#ifdef  _MT
                /*
                 * Allocate a new reference counter for the numeric info
                 */
                if ( (__lconv_num_refcount = _malloc_crt(sizeof(int))) == NULL )
                {
                    _free_crt(lc);
                    _free_crt(lc_refcount);
                    return 1;
                }
                *__lconv_num_refcount = 0;
#endif

                /* 
                 * Numeric data is country--not language--dependent. NT
                 * work-around.
                 */
                ctryid = MAKELCID(__lc_id[LC_NUMERIC].wCountry, SORT_DEFAULT);

                ret |= __getlocaleinfo(LC_STR_TYPE, ctryid, LOCALE_SDECIMAL,
                        (void *)&lc->decimal_point);
                ret |= __getlocaleinfo(LC_STR_TYPE, ctryid, LOCALE_STHOUSAND,
                        (void *)&lc->thousands_sep);
                ret |= __getlocaleinfo(LC_STR_TYPE, ctryid, LOCALE_SGROUPING,
                        (void *)&lc->grouping);

                if (ret) {
                        /* Clean up before returning failure */
                        __free_lconv_num(lc);
                        _free_crt(lc);
#ifdef  _MT
                        _free_crt(lc_refcount);
#endif
                        return -1;
                }

                fix_grouping(lc->grouping);
            }
            else {
                /*
                 * C locale for just the numeric category.
                 */
#ifdef  _MT
                /*
                 * NULL out the reference count pointer
                 */
                __lconv_num_refcount = NULL;
#endif
                lc->decimal_point = __lconv_c.decimal_point;
                lc->thousands_sep = __lconv_c.thousands_sep;
                lc->grouping = __lconv_c.grouping;
            }

            /*
             * Clean up old __lconv and reset it to lc
             */
#ifdef  _MT
            /*
             * If this is part of LC_ALL, then we need to free the old __lconv
             * set up in init_monetary() before this.
             */
            if ( (__lconv_intl_refcount != NULL) &&
                 (*__lconv_intl_refcount == 0) &&
                 (__lconv_intl_refcount != __ptlocinfo->lconv_intl_refcount) )
            {
                _free_crt(__lconv_intl_refcount);
                _free_crt(__lconv_intl);
            }
            __lconv_intl_refcount = lc_refcount;
#else
            __free_lconv_num(__lconv);

            /*
             * Recall that __lconv is dynamically allocated (hence must be
             * freed) iff __lconv and __lconv_intl are equal iff __lconv_intl
             * is non-NULL.
             */
            _free_crt(__lconv_intl);
#endif

            __lconv = __lconv_intl = lc;

        }
        else {
            /*
             * C locale for BOTH numeric and monetary categories.
             */
#ifdef  _MT
            /*
             * If this is part of LC_ALL, then we need to free the old __lconv
             * set up in init_monetary() before this.
             */
            if ( (__lconv_intl_refcount != NULL) &&
                 (*__lconv_intl_refcount == 0) &&
                 (__lconv_intl_refcount != __ptlocinfo->lconv_intl_refcount) )
            {
                _free_crt(__lconv_intl_refcount);
                _free_crt(__lconv_intl);
            }
            /*
             * NULL out the reference count pointer
             */
            __lconv_num_refcount = NULL;
            __lconv_intl_refcount = NULL;
#else
            __free_lconv_num(__lconv);

            /*
             * Recall that __lconv is dynamically allocated (hence must be
             * freed) iff __lconv and __lconv_intl are equal iff __lconv_intl
             * is non-NULL.
             */
            _free_crt(__lconv_intl);
#endif
            __lconv = &__lconv_c;           /* point to new one */
            __lconv_intl = NULL;

        }

        /* 
         * set global decimal point character
         */
        *__decimal_point = *__lconv->decimal_point;
        __decimal_point_length = 1;

        return 0;

}

/*
 *  Free the lconv numeric strings.
 *  Numeric values do not need to be freed.
 */
void __cdecl __free_lconv_num(
        struct lconv *l
        )
{
        if (l == NULL)
            return;

#ifdef  _MT
        if ( (l->decimal_point != __lconv->decimal_point) &&
             (l->decimal_point != __lconv_c.decimal_point) )
#else
        if ( l->decimal_point != __lconv_c.decimal_point )
#endif
            _free_crt(l->decimal_point);

#ifdef  _MT
        if ( (l->thousands_sep != __lconv->thousands_sep) &&
             (l->thousands_sep != __lconv_c.thousands_sep) )
#else
        if ( l->thousands_sep != __lconv_c.thousands_sep )
#endif
            _free_crt(l->thousands_sep);

#ifdef  _MT
        if ( (l->grouping != __lconv->grouping) &&
             (l->grouping != __lconv_c.grouping) )
#else
        if ( l->grouping != __lconv_c.grouping )
#endif
            _free_crt(l->grouping);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\lcnvinit.c ===
/***
*lcnvinit.c - called at startup to initialize lconv structure
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       initialize lconv structure to CHAR_MAX
*
*       According to ANSI, certain elements of the lconv structure must be
*       initialized to CHAR_MAX and the value of CHAR_MAX changes when
*       the user compiles -J.  To reflect this change in the lconv structure,
*       we initialize the structure to SCHAR_MAX, and when any of the users
*       modules are compiled -J, the structure is updated.
*
*       Note that this is not done for DLLs linked to the CRT DLL, because
*       we do not want such DLLs to override the -J setting for an EXE
*       linked to the CRT DLL.  See comments in crtexe.c.
*
*       Files involved:
*
*       locale.h - if -J, generates an unresolved external to _charmax
*       charmax.c - defines _charmax and sets to UCHAR_MAX (255), places
*               __lconv_init in startup initializer table if pulled in by -J
*       lconv.c - initializes lconv structure to SCHAR_MAX (127),
*               since libraries built without -J
*       lcnvinit.c - sets lconv members to 25.
**
*Revision History:
*       04-06-93  CFW   Module created.
*       04-14-93  CFW   Cleanup.
*       09-15-93  CFW   Use ANSI conformant "__" names, get rid of warnings.
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
*******************************************************************************/

#include <limits.h>
#include <locale.h>
#include <setlocal.h>

int __lconv_init(void)
{
        __lconv_c.int_frac_digits = (char)UCHAR_MAX;
        __lconv_c.frac_digits = (char)UCHAR_MAX;
        __lconv_c.p_cs_precedes = (char)UCHAR_MAX;
        __lconv_c.p_sep_by_space = (char)UCHAR_MAX;
        __lconv_c.n_cs_precedes = (char)UCHAR_MAX;
        __lconv_c.n_sep_by_space = (char)UCHAR_MAX;
        __lconv_c.p_sign_posn = (char)UCHAR_MAX;
        __lconv_c.n_sign_posn = (char)UCHAR_MAX;

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\labs.c ===
/***
*labs.c - find absolute value of a long integer
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines labs() - find absolute value of a long integer.
*
*Revision History:
*	03-15-84  RN	initial version
*	04-22-87  JMB	added function pragma for conversion to C 5.0 compiler
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	03-14-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	10-04-90  GJF	New-style function declarator.
*	12-28-90  SRW	Added _CRUISER_ conditional around function pragma
*	04-01-91  SRW	Enable #pragma function for i386 _WIN32_ builds too.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*			No _CRTIMP for CRT DLL model due to intrinsic
*	12-03-93  GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma function(labs)
#endif

/***
*long labs(lnumber) - find absolute value of long.
*
*Purpose:
*	Find the absolute value of a long integer (lnumber if lnumber >= 0),
*	-lnumber if lnumber < 0).
*
*Entry:
*	long lnumber - number to find absolute value of
*
*Exit:
*	returns the absolute value of lnumber
*
*Exceptions:
*
*******************************************************************************/

long __cdecl labs (
	long lnumber
	)
{
	return( lnumber>=0L ? lnumber : -lnumber );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\lconv.c ===
/***
*lconv.c - Contains the localeconv function
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the localeconv() function.
*
*Revision History:
*       03-21-89  JCR   Module created.
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       03-14-90  GJF   Replaced _cdecl _LOAD_DS with _CALLTYPE1 and added
*                       #include <cruntime.h>. Also, fixed the copyright.
*       10-04-90  GJF   New-style function declarator.
*       10-04-91  ETC   Changed _c_lconv to __lconv (locale support).
*                       _lconv no longer static.
*       12-20-91  ETC   Changed _lconv to _lconv_c (C locale structure).
*                       Created _lconv pointer to point to current lconv.
*       02-08-93  CFW   Added _lconv_static_*.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-14-94  GJF   Made definitions of __lconv and __lconv_c conditional
*                       on ndef DLL_FOR_WIN32S. Include setlocal.h.
*       01-07-95  CFW   Mac merge.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>

/* pointer to original static to avoid freeing */
char __lconv_static_decimal[] = ".";
char __lconv_static_null[] = "";

/* lconv settings for "C" locale */
struct lconv __lconv_c = {
                __lconv_static_decimal, /* decimal_point */
                __lconv_static_null,       /* thousands_sep */
                __lconv_static_null,       /* grouping */
                __lconv_static_null,       /* int_curr_symbol */
                __lconv_static_null,       /* currency_symbol */
                __lconv_static_null,       /* mon_decimal_point */
                __lconv_static_null,       /* mon_thousands_sep */
                __lconv_static_null,       /* mon_grouping */
                __lconv_static_null,       /* positive_sign */
                __lconv_static_null,       /* negative_sign */
                CHAR_MAX,                           /* int_frac_digits */
                CHAR_MAX,                           /* frac_digits */
                CHAR_MAX,                           /* p_cs_precedes */
                CHAR_MAX,                           /* p_sep_by_space */
                CHAR_MAX,                           /* n_cs_precedes */
                CHAR_MAX,                           /* n_sep_by_space */
                CHAR_MAX,                           /* p_sign_posn */
                CHAR_MAX                               /* n_sign_posn */
                };


/* pointer to current lconv structure */

struct lconv *__lconv = &__lconv_c;

/***
*struct lconv *localeconv(void) - Return the numeric formatting convention
*
*Purpose:
*       The localeconv() routine returns the numeric formatting conventions
*       for the current locale setting.  [ANSI]
*
*Entry:
*       void
*
*Exit:
*       struct lconv * = pointer to struct indicating current numeric
*                        formatting conventions.
*
*Exceptions:
*
*******************************************************************************/

struct lconv * __cdecl localeconv (
        void
        )
{
        /* the work is done by setlocale() */

        return(__lconv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\makepath.c ===
/***
*makepath.c - create path name from components
*
*	Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	To provide support for creation of full path names from components
*
*Revision History:
*	06-13-87  DFW	initial version
*	08-05-87  JCR	Changed appended directory delimeter from '/' to '\'.
*	09-24-87  JCR	Removed 'const' from declarations (caused cl warnings).
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	11-20-89  GJF	Fixed copyright, indents. Added const to types of
*			appropriate args.
*	03-14-90  GJF	Replaced _LOAD_DS with _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-04-90  GJF	New-style function declarator.
*	06-09-93  KRS	Add _MBCS support.
*	12-07-93  CFW	Wide char enable.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#ifdef _MBCS
#include <mbdata.h>
#include <mbstring.h>
#endif
#include <tchar.h>

/***
*void _makepath() - build path name from components
*
*Purpose:
*	create a path name from its individual components
*
*Entry:
*	_TSCHAR *path  - pointer to buffer for constructed path
*	_TSCHAR *drive - pointer to drive component, may or may not contain
*		      trailing ':'
*	_TSCHAR *dir   - pointer to subdirectory component, may or may not include
*		      leading and/or trailing '/' or '\' characters
*	_TSCHAR *fname - pointer to file base name component
*	_TSCHAR *ext   - pointer to extension component, may or may not contain
*		      a leading '.'.
*
*Exit:
*	path - pointer to constructed path name
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _tmakepath (
	register _TSCHAR *path,
	const _TSCHAR *drive,
	const _TSCHAR *dir,
	const _TSCHAR *fname,
	const _TSCHAR *ext
	)
{
	register const _TSCHAR *p;

	/* we assume that the arguments are in the following form (although we
	 * do not diagnose invalid arguments or illegal filenames (such as
	 * names longer than 8.3 or with illegal characters in them)
	 *
	 *  drive:
	 *	A	    ; or
	 *	A:
	 *  dir:
	 *	\top\next\last\     ; or
	 *	/top/next/last/     ; or
	 *	either of the above forms with either/both the leading
	 *	and trailing / or \ removed.  Mixed use of '/' and '\' is
	 *	also tolerated
	 *  fname:
	 *	any valid file name
	 *  ext:
	 *	any valid extension (none if empty or null )
	 */

	/* copy drive */

	if (drive && *drive) {
		*path++ = *drive;
		*path++ = _T(':');
	}

	/* copy dir */

	if ((p = dir) && *p) {
		do {
			*path++ = *p++;
		}
		while (*p);
#ifdef _MBCS
		if (*(p=_mbsdec(dir,p)) != _T('/') && *p != _T('\\')) {
#else
		if (*(p-1) != _T('/') && *(p-1) != _T('\\')) {
#endif
			*path++ = _T('\\');
		}
	}

	/* copy fname */

	if (p = fname) {
		while (*p) {
			*path++ = *p++;
		}
	}

	/* copy ext, including 0-terminator - check to see if a '.' needs
	 * to be inserted.
	 */

	if (p = ext) {
		if (*p && *p != _T('.')) {
			*path++ = _T('.');
		}
		while (*path++ = *p++)
			;
	}
	else {
		/* better add the 0-terminator */
		*path = _T('\0');
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ldiv.c ===
/***
*ldiv.c - contains the ldiv routine
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Performs a signed divide on longs and returns quotient
*	and remainder.
*
*Revision History:
*	06-02-89  PHG	module created
*	03-14-90  GJF	Made calling type _CALLTYPE1 and added #include
*			<cruntime.h>. Also, fixed the copyright.
*	10-04-90  GJF	New-style function declarator.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

/***
*ldiv_t div(long numer, long denom) - do signed divide
*
*Purpose:
*	This routine does an long divide and returns the results.
*	Since we don't know how the Intel 860 does division, we'd
*	better make sure that we have done it right.
*
*Entry:
*	long numer - Numerator passed in on stack
*	long denom - Denominator passed in on stack
*
*Exit:
*	returns quotient and remainder in structure
*
*Exceptions:
*	No validation is done on [denom]* thus, if [denom] is 0,
*	this routine will trap.
*
*******************************************************************************/

ldiv_t __cdecl ldiv (
	long numer,
	long denom
	)
{
	ldiv_t result;

	result.quot = numer / denom;
	result.rem = numer % denom;

	if (numer < 0 && result.rem > 0) {
		/* did division wrong; must fix up */
		++result.quot;
		result.rem -= denom;
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\mbtowenv.c ===
/***
*mbtowenv.c - convert multibyte environment block to wide
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __mbtow_environ(). Create a wide character equivalent of
*       an existing multibyte environment block.
*
*Revision History:
*       11-30-93  CFW   initial version
*       02-07-94  CFW   POSIXify.
*       01-10-95  CFW   Debug CRT allocs.
*       08-28-98  GJF   Use CP_ACP instead of CP_OEMCP.
*       07-06-01  BWT   Free wenvp before exiting on MultiByteToWideChar failure
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <dbgint.h>

/***
*__mbtow_environ - copy multibyte environment block to wide environment block
*
*Purpose:
*       Create a wide character equivalent of an existing multibyte
*       environment block.
*
*Entry:
*       Assume _environ (global pointer) points to existing multibyte
*       environment block.
*
*Exit:
*       If success, every multibyte environment variable has been added to
*       the wide environment block and returns 0.
*       If failure, returns -1.
*
*Exceptions:
*       If space cannot be allocated, returns -1.
*
*******************************************************************************/

int __cdecl __mbtow_environ (
        void
        )
{
        int size;
        wchar_t *wenvp;
        char **envp = _environ;

        /*
         * For every environment variable in the multibyte environment,
         * convert it and add it to the wide environment.
         */

        while (*envp)
        {
            /* find out how much space is needed */
            if ((size = MultiByteToWideChar(CP_ACP, 0, *envp, -1, NULL, 0)) == 0)
                return -1;

            /* allocate space for variable */
            if ((wenvp = (wchar_t *) _malloc_crt(size * sizeof(wchar_t))) == NULL)
                return -1;

            /* convert it */
            if ((size = MultiByteToWideChar(CP_ACP, 0, *envp, -1, wenvp, size)) == 0) {
                _free_crt(wenvp);
                return -1;
            }

            /* set it - this is not primary call, so set primary == 0 */
            __crtwsetenv(wenvp, 0);

            envp++;
        }

        return 0;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\lfind.c ===
/***
*lfind.c - do a linear search
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _lfind() - do a linear search of an array.
*
*Revision History:
*	06-19-85  TC	initial version
*	02-05-87  BM	changed <= to < in while condition to fix bug
*			of looking one element too far
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	01-21-88  JCR	Backed out _LOAD_DS...
*	10-30-89  JCR	Added _cdecl to prototypes
*	03-14-90  GJF	Replaced _cdecl with _CALLTYPE1, added #include
*			<cruntime.h>, removed #include <register.h> and
*			fixed the copyright. Also, cleaned up the formatting
*			a bit.
*	04-05-90  GJF	Added #include <search.h> and fixed the resulting
*			compilation errors and warnings. Also, removed an
*			unreferenced local variable.
*	07-25-90  SBM	Replaced <stdio.h> by <stddef.h>
*	10-04-90  GJF	New-style function declarator.
*	01-17-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <search.h>
#include <stddef.h>

/***
*char *_lfind(key, base, num, width, compare) - do a linear search
*
*Purpose:
*	Performs a linear search on the array, looking for the value key
*	in an array of num elements of width bytes in size.  Returns
*	a pointer to the array value if found, NULL if not found.
*
*Entry:
*	char *key - key to search for
*	char *base - base of array to search
*	unsigned *num - number of elements in array
*	int width - number of bytes in each array element
*	int (*compare)() - pointer to function that compares two
*		array values, returning 0 if they are equal and non-0
*		if they are different.	Two pointers to array elements
*		are passed to this function.
*
*Exit:
*	if key found:
*		returns pointer to array element
*	if key not found:
*		returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _lfind (
	REG2 const void *key,
	REG1 const void *base,
	REG3 unsigned int *num,
	unsigned int width,
	int (__cdecl *compare)(const void *, const void *)
	)
{
	unsigned int place = 0;
	while (place < *num )
		if (!(*compare)(key,base))
			return( (void *)base );
		else
		{
			base = (char *)base + width;
			place++;
		}
	return( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\lsearch.c ===
/***
*lsearch.c - linear search of an array
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains the _lsearch() function - linear search of an array
*
*Revision History:
*	06-19-85  TC	initial version
*	05-14-87  JMB	added function pragma for memcpy in compact/large mode
*			for huge pointer support
*			include sizeptr.h for SIZED definition
*	08-01-87  SKS	Add include file for prototype of memcpy()
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	01-21-88  JCR	Backed out _LOAD_DS...
*	10-30-89  JCR	Added _cdecl to prototypes
*	03-14-90  GJF	Replaced _cdecl with _CALLTYPE1, added #include
*			<cruntime.h>, removed #include <register.h> and
*			fixed the copyright. Also, cleaned up the formatting
*			a bit.
*	04-05-90  GJF	Added #include <search.h> and fixed the resulting
*			compiler errors and warnings. Removed unreferenced
*			local variable. Also, removed #include <sizeptr.h>.
*	07-25-90  SBM	Replaced <stdio.h> by <stddef.h>
*	10-04-90  GJF	New-style function declarator.
*	01-17-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <search.h>
#include <memory.h>

/***
*char *_lsearch(key, base, num, width, compare) - do a linear search
*
*Purpose:
*	Performs a linear search on the array, looking for the value key
*	in an array of num elements of width bytes in size.  Returns
*	a pointer to the array value if found; otherwise adds the
*	key to the end of the list.
*
*Entry:
*	char *key - key to search for
*	char *base - base of array to search
*	unsigned *num - number of elements in array
*	int width - number of bytes in each array element
*	int (*compare)() - pointer to function that compares two
*		array values, returning 0 if they are equal and non-0
*		if they are different. Two pointers to array elements
*		are passed to this function.
*
*Exit:
*	if key found:
*		returns pointer to array element
*	if key not found:
*		adds the key to the end of the list, and increments
*		*num.
*		returns pointer to new element.
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _lsearch (
	REG2 const void *key,
	REG1 void *base,
	REG3 unsigned int *num,
	unsigned int width,
	int (__cdecl *compare)(const void *, const void *)
	)
{
	unsigned int place = 0;
	while (place < *num )
		if (!(*compare)(key,base))
			return(base);
		else
		{
			base = (char *)base + width;
			place++;
		}
	(void) memcpy( base, key, width );
	(*num)++;
	return( base );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\mtest.c ===
/***
* mtest.c - Multi-thread debug testing module
*
*	Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This source contains a group of routines used for multi-thread
*	testing.  In order to use the debug flavor of these routines, you
*	MUST link special debug versions of multi-thread crt0dat.obj and
*	mlock.obj into your program.
*
*	[NOTE:	This source module is NOT included in the C runtime library;
*	it is used only for testing and must be explicitly linked into the
*	test program.]
*
*Revision History:
*	12-??-87   JCR	Module created.
*	06-17-88   JCR	Misc. bug fixes.
*	08-03-88   JCR	Use the stdio.h value of _NFILE
*	10-03-88   JCR	386: Use SYS calls, not DOS calls
*	10-04-88   JCR	386: Removed 'far' keyword
*	10-10-88   GJF	Made API names match DOSCALLS.H
*	06-08-89   JCR	New 386 _beginthread interface; also brought
*			lots of new options across from the C600 tree.
*	07-11-89   JCR	Added _POPEN_LOCK to _locknames[] array
*	07-14-89   JCR	Added _LOCKTAB_LOCK support
*	07-24-90   SBM	Removed '32' from API names
*	09-06-94   CFW	Change M_I386 to _M_IX86.
*
*******************************************************************************/

#ifdef _M_IX86
#ifdef STACKALLOC
#error Can't define STACKALLOC in 386 mode
#endif
#endif

#ifdef _M_IX86
#ifdef _DOSCREATETHREAD_
#error Currently can't define _DOSCREATETHREAD_ in 386 mode
#endif
#endif

#ifdef _DOSCREATETHREAD_
#ifndef STACKALLOC
#error Can't define _DOSCREATETHREAD_ without STACKALLOC
#endif
#endif

/*
Multi-thread core tester module.
*/
#include <malloc.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <io.h>
#include <mtest.h>
#ifdef DEBUG
#include <mtdll.h>
#include <file2.h>
#endif

/* Define FAR to be blank for the 386 and far otherwise. */

#undef	FAR
#ifdef	_M_IX86
#define FAR
#else
#define FAR	far
#endif

/* define stack size */
#ifdef _M_IX86
#define _STACKSIZE_ 8192
#else
#define _STACKSIZE_ 2048
#endif


/* routines */
#ifdef _M_IX86
unsigned _syscall DOSSLEEP (unsigned long) ;
#else
unsigned FAR pascal DOSSLEEP (unsigned long) ;
#endif
int main ( int argc , char * * argv ) ;
int minit(void);
void childcode ( void FAR * arg ) ;
#ifdef _DOSCREATETHREAD_
#ifndef _M_IX86
void childcode ( void ) ;
unsigned FAR pascal DOSCREATETHREAD (void FAR *, void FAR *, void FAR *);
#endif
#else
void childcode ( void FAR * arg ) ;
#endif
int mterm(void);

/* global data */
char Result [ _THREADMAX_ ] ;
unsigned Synchronize ;

#ifdef DEBUG
/* Array of lock names.  This order must match the declarations in
   mtdll.h and mtdll.inc. */

char *_locknames[] = {
	"** NO LOCK 0 ** ",    /* lock values are 1-based */
	"_SIGNAL_LOCK    ",
	"_IOB_SCAN_LOCK  ",
	"_TMPNAM_LOCK    ",
	"_INPUT_LOCK     ",
	"_OUTPUT_LOCK    ",
	"_CSCANF_LOCK    ",
	"_CPRINTF_LOCK   ",
	"_CONIO_LOCK     ",
	"_HEAP_LOCK      ",
	"_BHEAP_LOCK     ",
	"_TIME_LOCK      ",
	"_ENV_LOCK       ",
	"_EXIT_LOCK1     ",
	"_EXIT_LOCK2     ",
	"_THREADDATA_LOCK",
	"_POPEN_LOCK     ",
	"_SSCANF_LOCK    ",
	"_SPRINTF_LOCK   ",
#ifdef _M_IX86
	"_VSPRINTF_LOCK  ",
	"_LOCKTAB_LOCK   "
#else
	"_VSPRINTF_LOCK  "
#endif
	};

/* Minimal sanity check on above array. */
#ifdef _M_IX86

#if ((_LOCKTAB_LOCK+1)-_STREAM_LOCKS)
#error *** _locknames[] does agree with lock values ***
#endif

#else	/* !_M_IX86 */

#if ((_VSPRINTF_LOCK+1)-_STREAM_LOCKS)
#error *** _locknames[] does agree with lock values ***
#endif

#endif	/* _M_IX86 */

#endif	/* DEBUG */


/***
* main() - Main mthread testing shell
*
*Purpose:
*	Provides a general purpose shell for mthread testing.
*	The module does the following:
*
*		(1) Call minit() to perform test initialization operations.
*
*		(2) Begins one thread for each argument passed to the
*		program.  Each thread is passed the corresponding argument.
*		Thread begin location is assumed to be at routine childcode();
*
*		(3) Waits for all threads to terminate.
*
*		(4) Calls mterm() to perform termination operations.
*
*	Note that minit(), childcode(), and mterm() are routines that
*	are external to this source.  Again, this source doesn't care
*	what their purpose or operation is.
*
*	Also, childcode() is expected to conform to the following rules:
*
*		(1) The childcode should not start running until
*		the variable 'Synchronize' becomes non-zero.
*
*		(2) When the thread is done executing, it should set
*		the value Result[threadid] to a non-zero value so the
*		parent (i.e., this routine) knows it has completed.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int main ( int argc , char * * argv )
{
    int rc ;
    unsigned result = 0 ;
    long ChildCount ;
    int NumThreads ;
    int t ;
    int r ;
    int MaxThread = 0 ;
    long LoopCount ;
#ifdef THREADLOOP
    char **argvsave;
#endif
#ifndef  _M_IX86
    char * stackbottom ;
#endif

#ifdef DEBUG
    if ( argc > MAXTHREADID) {
	printf("*** ERROR: Mthread debugging only supports %u threads ***\n", MAXTHREADID);
	return(-1);
	}
#endif

    if ( -- argc > (_THREADMAX_-1) )
    {
	printf ( "*** Error: Too many arguments***\n" ) ;
	return (-1) ;
    }

	/* Call the initiation routine */
	
	if (minit() != 0) {
		printf("*** Error: From minit() routine ***\n");
		return(-1);
		}

	/* Bring up the threads */

    printf ( "Process ID = %u, Thread ID = %d, ArgCount= %d\r\n" ,
	getpid ( ) , * _threadid , argc ) ;

#ifndef _M_IX86
#ifdef STACKALLOC
	printf( "(thread stacks allocated explicilty by mtest suite)\r\n");
#else
	printf( "(thread stacks allocated implicitly via _beginthread)\r\n");
#endif
#endif

#ifdef	THREADLOOP
    /* Bring up all the threads several times (so tids get re-used) */
    argvsave=argv;
    for (threadloop=1;threadloop<=_THREADLOOPCNT_;threadloop++) {
	printf("\nThreadloop = %i\n", threadloop);
	argv=argvsave;
#endif

    NumThreads = 0 ;

    while ( * ++ argv )
    {

	ChildCount = atol ( * argv ) ;

#ifdef _M_IX86

	rc = _beginthread ( (void FAR *) childcode , _STACKSIZE_ ,
		(void FAR *) ChildCount ) ;

	if ( rc == -1 )

#else	/* !_M_IX86 */

#ifdef STACKALLOC
	if ( ! ( stackbottom = _fmalloc ( _STACKSIZE_ ) ) )
	{
	    printf ( "*** Error: Could not allocate a stack ***\n" ) ;
	    break ;
	}
#else
	stackbottom = (void FAR *) NULL;
#endif

#ifdef	_DOSCREATETHREAD_
	stackbottom+=_STACKSIZE_-16;	  /* point to end of malloc'd block */
	rc1 = DOSCREATETHREAD( (void FAR *) childcode, &rc,
		(void FAR *) stackbottom);

	if (rc1 != 0)
#else
	rc = _beginthread ( (void FAR *) childcode , (void FAR *) stackbottom ,
	    _STACKSIZE_ , (void FAR *) ChildCount ) ;

	if ( rc == -1 )
#endif

#endif	/* _M_IX86 */

	{
	    printf ("*** Error: Could not Spawn %d-th Thread (argument=%ld) ***\n" ,
		NumThreads + 1 , ChildCount ) ;
	    break ;
	}

	if ( rc > MaxThread )
	    MaxThread = rc ;

	printf ( "Spawning %d-th Thread %d with argument=%ld\r\n" ,
	    ++ NumThreads , rc , ChildCount ) ;
    }

    printf ( "NumThreads = %d, MaxThread = %d\r\n" ,
	NumThreads, MaxThread ) ;

	/* Let the threads begin and wait for them to term. */

    LoopCount = 0L ;

    Synchronize = 1 ;

    for ( t = 0 ; t < NumThreads ; ++ t )
    {
	r = 0 ;
	while ( ! Result [ r ] )
	{
	    DOSSLEEP ( 0L ) ;
	    if ( ++ r > MaxThread )
	    {
		r = 0 ;
		printf ( "%ld\r" , LoopCount ++ ) ;
	    }
	}

	printf ( "%d: Thread %d Done.\r\n" , t , r) ;

	Result [ r ] = '\0' ;
    }
#ifdef	THREADLOOP
    }
#endif

	/* All the threads have completed.  Call the term routine and return. */

	if (mterm() != 0) {
		printf("*** Error: From mterm() routine ***\n");
		return(-1);
		}

	printf("\nDone!\n");
    return 0 ;
}


#ifdef DEBUG

/***
* Debug Print Routines - Display useful mthread lock data
*
*Purpose:
*	The following routines extract information from the multi-thread
*	debug data bases and print them out in various formats.
*	In order to use these routines, you MUST link special debug
*	versions of multi-thread crt0dat.obj and mlock.obj into your program.
*
*Entry:
*
*Exit:
*	0 = success
*	0! = failure
*
*Exceptions:
*
*******************************************************************************/

/*--- Print lock routine ---*/
int printlock(int locknum)
{
	int retval;

#ifdef	_INIT_LOCKS
	if (locknum >= _STREAM_LOCKS)
		printf("\nValidating lock #%i (%s):\n",locknum, "not a 'single lock'");
	else
		printf("\nValidating lock #%i: %s\n",locknum, _locknames[locknum]);
#else
	printf("\nValidating lock #%i (%s, %s):\n",
		locknum,
		(locknum >= _STREAM_LOCKS ?
			"not a 'single' lock" : _locknames[locknum]),
		(_lock_exist(locknum) ?
			"initialized" : "NOT initialized")
		);
#endif

	retval = _check_lock(locknum);
	printf("\tLock count = %u\r\n", _lock_cnt(locknum));
	printf("\tCollision count = %u\r\n", _collide_cnt(locknum));

	if (retval != 0)
		printf("\t*** ERROR: Checking lock ***\n");

	return(retval);
}


/*--- Printf single locks ---*/
int print_single_locks(void)
{
	int locknum;
	int retval=0;
	int lockval;

	printf("\n--- Single Locks ---\n");

#ifdef _INIT_LOCKS
	printf("\t\t\t\tlock count\tcollide count\n");
	for (locknum=1;locknum<_STREAM_LOCKS;locknum++) {
		if (lockval = (_check_lock(locknum) != 0))
			retval++;
		printf("#%i / %s\t\t%u\t\t%u\t%s\n",
		    locknum, _locknames[locknum], _lock_cnt(locknum),
		    _collide_cnt(locknum), (lockval ? "*LOCK ERROR*" : "") );
		}
#else
	printf("\t\t\t\tlock count\tcollide count\texists?\n");
	for (locknum=1;locknum<_STREAM_LOCKS;locknum++) {
		if (lockval = (_check_lock(locknum) != 0))
			retval++;
		printf("#%i / %s\t\t%u\t\t%u\t\t%s\t%s\n",
		    locknum, _locknames[locknum], _lock_cnt(locknum),
		    _collide_cnt(locknum),
		    (_lock_exist(locknum) ? "YES" : "NO"),
		    (lockval ? "*LOCK ERROR*" : "") );
		}
#endif

	return(retval);
}


/*--- Print all stdio locks ---*/
int print_stdio_locks(void)
{
	int i;
	int locknum;
	int retval=0;
	int lockval;

	printf("\n--- Stdio Locks ---\n");

#ifdef _INIT_LOCKS
	printf("stream\t\tlock count\tcollide count\n");
	for (i=0;i<_NFILE;i++) {
		locknum = _stream_locknum(i);
		if (lockval = (_check_lock(locknum) != 0))
			retval++;
		printf("%i\t\t%u\t\t%u\t%s\n",
			i, _lock_cnt(locknum), _collide_cnt(locknum),
			(lockval ? "*LOCK ERROR*" : "") );
		}
#else
	printf("stream\t\tlock count\tcollide count\texists?\n");
	for (i=0;i<_NFILE;i++) {
		locknum = _stream_locknum(i);
		if (lockval = (_check_lock(locknum) != 0))
			retval++;
		printf("%i\t\t%u\t\t%u\t\t%s\t%s\n",
			i, _lock_cnt(locknum), _collide_cnt(locknum),
			(_lock_exist(locknum) ? "YES" : "NO"),
			(lockval ? "*LOCK ERROR*" : "") );
		}
#endif

	return(retval);
}


/*--- Print all lowio locks ---*/
int print_lowio_locks(void)
{
	int i;
	int locknum;
	int retval=0;
	int lockval;

	printf("\n--- Lowio locks ---\n");

#ifdef _INIT_LOCKS
	printf("fh\t\tlock count\tcollide count\n");
	for (i=0;i<_NFILE;i++) {
		locknum = _fh_locknum(i);
		if (lockval = (_check_lock(locknum) != 0))
			retval++;
		printf("%i\t\t%u\t\t%u\t%s\n",
			i, _lock_cnt(locknum), _collide_cnt(locknum),
			(lockval ? "*LOCK ERROR*" : "") );
		}
#else
	printf("fh\t\tlock count\tcollide count\texists?\n");
	for (i=0;i<_NFILE;i++) {
		locknum = _fh_locknum(i);
		if (lockval = (_check_lock(locknum) != 0))
			retval++;
		printf("%i\t\t%u\t\t%u\t\t%s\t%s\n",
			i, _lock_cnt(locknum), _collide_cnt(locknum),
			(_lock_exist(locknum) ? "YES" : "NO"),
			(lockval ? "*LOCK ERROR*" : "") );
		}
#endif

	return(retval);
}


/*--- Print all I/O locks ---*/
int print_iolocks(void)
{
	int retval=0;

	retval += print_stdio_locks();
	retval += print_lowio_locks();

	return(retval);
}


/*--- Print all Locks ---*/
int print_locks(void)
{
	int retval=0;

	retval += print_single_locks();
	retval += print_iolocks();

	return(retval);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\nlsdata1.c ===
/***
*nlsdata1.c - globals for international library - small globals
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the globals:  __mb_cur_max, _decimal_point,
*       _decimal_point_length.  This module is always required.
*       This module is separated from nlsdatax.c for granularity.
*
*Revision History:
*       12-01-91  ETC   Created.
*       04-03-92  PLM   Changes tdef.h to tchar.h
*       08-18-92  KRS   Rip out _tflag--not used.
*       04-14-93  SKS   Change __mb_cur_max from unsigned short to int
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-08-94  GJF   Added conditional so these definitions are not built
*                       for the Win32s version of msvcrt*.dll.
*       09-06-94  CFW   Remove _INTL switch.
*       09-27-94  CFW   Don't overwrite static string.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <stdlib.h>
#include <nlsint.h>

/*
 *  Value of MB_CUR_MAX macro.
 */
int __mb_cur_max = 1;

/*
 *  Localized decimal point string.
 */
char __decimal_point[] = ".";

/*
 *  Decimal point length, not including terminating null.
 */
size_t __decimal_point_length = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\nlsdata3.c ===
/***
*nlsdata3.c - globals for international library - locale id's
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the definition of locale id's.  These id's and
*       this file should only be visible to the _init_(locale category)
*       functions.  This module is separated from nlsdatax.c for granularity.
*       
*Revision History:
*       12-01-91  ETC   Created.
*       01-25-93  KRS   Updated.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-12-94  GJF   Modified conditional so the definition of __lc_id is
*                       not built for the Win32s version of msvcrt*.dll.
*       09-06-94  CFW   Remove _INTL switch.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <locale.h>
#include <setlocal.h>

/*
 *  Locale id's.
 */
/* UNDONE: define struct consisting of LCID/LANGID, CTRY ID, and CP. */
LC_ID __lc_id[LC_MAX-LC_MIN+1] = {
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\nlsdata2.c ===
/***
*nlsdata2.c - globals for international library - locale handles and code page
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module defines the locale handles and code page.  The handles are
*       required by almost all locale dependent functions.  This module is
*       separated from nlsdatax.c for granularity.
*
*Revision History:
*       12-01-91  ETC   Created.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-12-94  GJF   Made definitions of __lc_handle and __lc_codepage
*                       conditional on ndef DLL_FOR_WIN32S
*       01-12-98  GJF   Added __lc_collate_cp.
*       26-01-00  GB    Added __lc_clike.
*
*******************************************************************************/

#include <locale.h>
#include <setlocal.h>

/*
 *  Locale handles.
 */
LCID __lc_handle[LC_MAX-LC_MIN+1] = { 
        _CLOCALEHANDLE,
        _CLOCALEHANDLE,
        _CLOCALEHANDLE,
        _CLOCALEHANDLE,
        _CLOCALEHANDLE,
        _CLOCALEHANDLE
};

/*
 *  Code page.
 */
UINT __lc_codepage = _CLOCALECP;                /* CP_ACP */

/*
 * Code page for LC_COLLATE
 */
UINT __lc_collate_cp = _CLOCALECP;

/* if this locale has first 127 character set same as CLOCALE.
 */
int __lc_clike = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\perror.c ===
/***
*perror.c - print system error message
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines perror() - print system error message
*       System error message are indexed by errno; conforms to XENIX
*       standard, with much compatability with 1983 uniforum draft standard.
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       12-29-87  JCR   Multi-thread support
*       05-31-88  PHG   Merged DLL and normal versions
*       06-03-88  JCR   Added <io.h> to so _write_lk evaluates correctly and
*                       added (char *)message casts to get rid of warnings
*       03-15-90  GJF   Replace _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and fixed
*                       the copyright. Also, cleaned up the formatting a bit.
*       04-05-90  GJF   Added #include <string.h>.
*       08-14-90  SBM   Removed unneeded #include <errmsg.h>
*       10-04-90  GJF   New-style function declarator.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       10-16-92  XY    Mac version: use buffered fprintf, can't assume stderr
*                       is 2
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-16-95  JWM   Mac merge.
*       03-29-95  BWT   Add write_lk prototype for POSIX build.
*       09-26-97  BWT   Fix POSIX
*       01-06-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syserr.h>
#include <mtdll.h>
#include <io.h>

/***
*void perror(message) - print system error message
*
*Purpose:
*       prints user's error message, then follows it with ": ", then the system
*       error message, then a newline.  All output goes to stderr.  If user's
*       message is NULL or a null string, only the system error message is
*       printer.  If errno is weird, prints "Unknown error".
*
*Entry:
*       const char *message - users message to prefix system error message
*
*Exit:
*       Prints message; no return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl perror (
        REG1 const char *message
        )
{

#if     !defined(_POSIX_)
        REG2 int fh = 2;

#ifdef  _MT
        _lock_fh( fh );         /* acquire file handle lock */
        __try {
#endif

#endif  /* !_POSIX_ */

        if (message && *message)
        {

#if     !defined(_POSIX_)
            _write_lk(fh,(char *)message,(unsigned int)strlen(message));
            _write_lk(fh,": ",2);
#else   /* !_POSIX_ */
            fprintf(stderr,"%s", (char *)message);
            fprintf(stderr,": ");
#endif  /* !_POSIX_ */
        }

        message = _sys_err_msg( errno );

#if     !defined(_POSIX_)
        _write_lk(fh,(char *)message,(unsigned int)strlen(message));
        _write_lk(fh,"\n",1);

#ifdef  _MT
        }
        __finally {
            _unlock_fh( fh );   /* release file handle lock */
        }
#endif

#else   /* !_POSIX_ */
        fprintf(stderr,"%s\n", (char *)message);
#endif  /* !_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\purevirt.c ===
/***
*purevirt.c - stub to trap pure virtual function calls
*
*	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _purecall() -
*
*Revision History:
*	09-30-92  GJF	Module created
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>

/***
*void _purecall(void) -
*
*Purpose:
*
*Entry:
*	No arguments
*
*Exit:
*	Never returns
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _purecall(
	void
	)
{
	_amsg_exit(_RT_PUREVIRT);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\onexit.c ===
/***
*onexit.c - save function for execution on exit
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _onexit(), atexit() - save function for execution at exit
*
*       In order to save space, the table is allocated via malloc/realloc,
*       and only consumes as much space as needed.  __onexittable is
*       set to point to the table if onexit() is ever called.
*
*Revision History:
*       06-30-89  PHG   module created, based on asm version
*       03-15-90  GJF   Replace _cdecl with _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also,
*                       cleaned up the formatting a bit.
*       05-21-90  GJF   Fixed compiler warning.
*       10-04-90  GJF   New-style function declarators.
*       12-28-90  SRW   Added casts of func for Mips C Compiler
*       01-21-91  GJF   ANSI naming.
*       09-09-91  GJF   Revised for C++ needs.
*       03-20-92  SKS   Revamped for new initialization model
*       04-01-92  XY    add init code reference for MAC version
*       04-23-92  DJM   POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-24-93  SKS   Add __dllonexit for DLLs using MSVCRT10.DLL
*       09-15-93  GJF   Merged NT SDK and Cuda versions. This amounted to
*                       resurrecting and cleaning up the Posix verion (which
*                       may prove obsolete after later review).
*       10-28-93  GJF   Define entry for initialization section (used to be
*                       in i386\cinitone.asm).
*       04-12-94  GJF   Made declarations of _onexitbegin and _onexitend
*                       conditional on ndef DLL_FOR_WIN32S.
*       05-19-94  GJF   For DLL_FOR_WIN32S, changed the reallocation of the
*                       onexit/atexit table in __dllonexit to use malloc and
*                       __mark_block_as_free, instead of realloc.
*       06-06-94  GJF   Replaced 5-19-94 code with use of GlobalAlloc and
*                       GlobalFree.
*       07-18-94  GJF   Must specify GMEM_SHARE in GlobalAlloc.
*       08-22-94  GJF   Fixed table size test to remove implicit assumption
*                       that the heap allocation granularity is at least
*                       sizeof(_PVFV). This removes a barrier to working with
*                       a user-supplied, or third party, heap manager.
*       01-10-95  CFW   Debug CRT allocs.
*       02-02-95  BWT   Update POSIX support (it's the same as Win32 now)
*       02-14-95  CFW   Debug CRT allocs.
*       02-16-95  JWM   Spliced _WIN32 & Mac versions.
*       03-29-95  BWT   Add _msize prototype to fix POSIX build.
*       08-01-96  RDK   Changed initialization pointer data type, changed
*                       _onexit and added _dllonexit to parallel x86
*                       functionality.
*       03-06-98  GJF   Exception-safe locking.
*       12-01-98  GJF   Grow the atexit table much more rapidly.
*       12-18-98  GJF   Changes for 64-bit size_t.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <mtdll.h>
#include <stdlib.h>
#include <internal.h>
#include <malloc.h>
#include <rterr.h>
#include <windows.h>
#include <dbgint.h>

#ifdef  _POSIX_
_CRTIMP size_t __cdecl _msize(void *);
#endif

int __cdecl __onexitinit(void);

#ifdef  _MSC_VER

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __onexitinit;

#pragma data_seg()

#endif  /* _MSC_VER */

/*
 * Define pointers to beginning and end of the table of function pointers
 * manipulated by _onexit()/atexit().
 */
extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;

/*
 * Define increments (in entries) for growing the _onexit/atexit table
 */
#define MININCR     4
#define MAXINCR     512

#ifdef  _MT
static _onexit_t __cdecl _onexit_lk(_onexit_t);
static _onexit_t __cdecl __dllonexit_lk(_onexit_t, _PVFV **, _PVFV **);
#endif

/***
*_onexit(func), atexit(func) - add function to be executed upon exit
*
*Purpose:
*       The _onexit/atexit functions are passed a pointer to a function
*       to be called when the program terminate normally.  Successive
*       calls create a register of functions that are executed last in,
*       first out.
*
*Entry:
*       void (*func)() - pointer to function to be executed upon exit
*
*Exit:
*       onexit:
*           Success - return pointer to user's function.
*           Error - return NULL pointer.
*       atexit:
*           Success - return 0.
*           Error - return non-zero value.
*
*Notes:
*       This routine depends on the behavior of _initterm() in CRT0DAT.C.
*       Specifically, _initterm() must not skip the address pointed to by
*       its first parameter, and must also stop before the address pointed
*       to by its second parameter.  This is because _onexitbegin will point
*       to a valid address, and _onexitend will point at an invalid address.
*
*Exceptions:
*
*******************************************************************************/

_onexit_t __cdecl _onexit (
        _onexit_t func
        )
{
#ifdef  _MT
        _onexit_t retval;

        _lockexit();

        __try {
            retval = _onexit_lk(func);
        }
        __finally {
            _unlockexit();
        }

        return retval;
}


static _onexit_t __cdecl _onexit_lk (
        _onexit_t func
        )
{
#endif
        _PVFV * p;
        size_t  oldsize;

        /*
         * First, make sure the table has room for a new entry
         */
        if ( (oldsize = _msize_crt(__onexitbegin))
                < ((size_t)((char *)__onexitend -
            (char *)__onexitbegin) + sizeof(_PVFV)) ) 
        {
            /*
             * not enough room, try to grow the table. first, try to double it.
             */
            if ( (p = (_PVFV *)_realloc_crt(__onexitbegin, oldsize + 
                 __min(oldsize, (MAXINCR * sizeof(_PVFV))))) == NULL )
            {
                /*
                 * failed, try to grow by MININCR
                 */
                if ( (p = (_PVFV *)_realloc_crt(__onexitbegin, oldsize +
                     MININCR * sizeof(_PVFV))) == NULL )
                    /*
                     * failed again. don't do anything rash, just fail
                     */
                    return NULL;
            }

            /*
             * update __onexitend and __onexitbegin
             */
            __onexitend = p + (__onexitend - __onexitbegin);
            __onexitbegin = p;
        }

        /*
         * Put the new entry into the table and update the end-of-table
         * pointer.
         */
         *(__onexitend++) = (_PVFV)func;

        return func;
}

int __cdecl atexit (
        _PVFV func
        )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}


/***
* void __onexitinit(void) - initialization routine for the function table
*       used by _onexit() and atexit().
*
*Purpose:
*       Allocate the table with room for 32 entries (minimum required by
*       ANSI). Also, initialize the pointers to the beginning and end of
*       the table.
*
*Entry:
*       None.
*
*Exit:
*       Returns _RT_ONEXIT if the table cannot be allocated.
*
*Notes:
*       This routine depends on the behavior of doexit() in CRT0DAT.C.
*       Specifically, doexit() must not skip the address pointed to by
*       __onexitbegin, and it must also stop before the address pointed
*       to by __onexitend.  This is because _onexitbegin will point
*       to a valid address, and _onexitend will point at an invalid address.
*
*       Since the table of onexit routines is built in forward order, it
*       must be traversed by doexit() in CRT0DAT.C in reverse order.  This
*       is because these routines must be called in last-in, first-out order.
*
*       If __onexitbegin == __onexitend, then the onexit table is empty!
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __onexitinit (
        void
        )
{
        if ( (__onexitbegin = (_PVFV *)_malloc_crt(32 * sizeof(_PVFV))) == NULL )
            /*
             * cannot allocate minimal required size. return
             * fatal runtime error.
             */
            return _RT_ONEXIT;

        *(__onexitbegin) = (_PVFV) NULL;
        __onexitend = __onexitbegin;

        return 0;
}


#ifdef  CRTDLL

/***
*__dllonexit(func, pbegin, pend) - add function to be executed upon DLL detach
*
*Purpose:
*       The _onexit/atexit functions in a DLL linked with MSVCRT.LIB
*       must maintain their own atexit/_onexit list.  This routine is
*       the worker that gets called by such DLLs.  It is analogous to
*       the regular _onexit above except that the __onexitbegin and
*       __onexitend variables are not global variables visible to this
*       routine but rather must be passed as parameters.
*
*Entry:
*       void (*func)() - pointer to function to be executed upon exit
*       void (***pbegin)() - pointer to variable pointing to the beginning
*                   of list of functions to execute on detach
*       void (***pend)() - pointer to variable pointing to the end of list
*                   of functions to execute on detach
*
*Exit:
*       Success - return pointer to user's function.
*       Error - return NULL pointer.
*
*Notes:
*       This routine depends on the behavior of _initterm() in CRT0DAT.C.
*       Specifically, _initterm() must not skip the address pointed to by
*       its first parameter, and must also stop before the address pointed
*       to by its second parameter.  This is because *pbegin will point
*       to a valid address, and *pend will point at an invalid address.
*
*Exceptions:
*
*******************************************************************************/

_onexit_t __cdecl __dllonexit (
        _onexit_t func,
        _PVFV ** pbegin,
        _PVFV ** pend
        )
{
#ifdef  _MT
        _onexit_t retval;

        _lockexit();

        __try {
            retval = __dllonexit_lk(func, pbegin, pend);
        }
        __finally {
            _unlockexit();
        }

        return retval;
}

static _onexit_t __cdecl __dllonexit_lk (
        _onexit_t func,
        _PVFV ** pbegin,
        _PVFV ** pend
        )
{
#endif
        _PVFV   *p;
        size_t oldsize;

        /*
         * First, make sure the table has room for a new entry
         */
        if ( (oldsize = _msize_crt(*pbegin)) <= (size_t)((char *)(*pend) -
            (char *)(*pbegin)) )
        {
            /*
             * not enough room, try to grow the table
             */
            if ( (p = (_PVFV *)_realloc_crt((*pbegin), oldsize + 
                 __min(oldsize, MAXINCR * sizeof(_PVFV)))) == NULL )
            {
                /*
                 * failed, try to grow by ONEXITTBLINCR
                 */
                if ( (p = (_PVFV *)_realloc_crt((*pbegin), oldsize +
                     MININCR * sizeof(_PVFV))) == NULL )
                    /*
                     * failed again. don't do anything rash, just fail
                     */
                    return NULL;
            }

            /*
             * update (*pend) and (*pbegin)
             */
            (*pend) = p + ((*pend) - (*pbegin));
            (*pbegin) = p;
        }

        /*
         * Put the new entry into the table and update the end-of-table
         * pointer.
         */
         *((*pend)++) = (_PVFV)func;

        return func;

}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\putenv.c ===
/***
*putenv.c - put an environment variable into the environment
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putenv() - adds a new variable to environment; does not
*       change global environment, only the process' environment.
*
*Revision History:
*       08-08-84  RN    initial version
*       02-23-88  SKS   check for environment containing only the NULL string
*       05-31-88  PHG   Merged DLL and normal versions
*       07-14-88  JCR   Much simplified since (1) __setenvp always uses heap, and
*                       (2) envp array and env strings are in seperate heap blocks
*       07-03-89  PHG   Now "option=" string removes string from environment
*       08-17-89  GJF   Removed _NEAR_, _LOAD_DS and fixed indents.
*       09-14-89  KRS   Don't give error if 'option' not defined in "option=".
*       11-20-89  GJF   Added const to arg type. Also, fixed copyright.
*       03-15-90  GJF   Made the calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       04-05-90  GJF   Made findenv() _CALLTYPE4.
*       04-26-90  JCR   Bug fix if environ is NULL (stubbed out _setenvp)
*       07-25-90  SBM   Removed redundant include (stdio.h)
*       10-04-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       02-06-91  SRW   Added _WIN32_ conditional for SetEnvironmentVariable
*       02-18-91  SRW   Changed _WIN32_ conditional for SetEnvironmentVariable
*                       to be in addition to old logic instead of replacement
*       04-23-92  GJF   Made findenv insensitive to the case of name for Win32.
*                       Also added support for 'current drive' environment
*                       strings in Win32.
*       04-29-92  GJF   Repackaged so that _putenv_lk could be easily added for
*                       for Win32.
*       05-05-92  DJM   POSIX not supported.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-05-92  PLM   Added _MAC_ 
*       11-24-93  CFW   Rip out Cruiser, disallow "=C:=C:\foo" format putenvs.
*       11-29-93  CFW   Wide char enable, convert between wide and narrow
*                       types. Mucho code moved to setenv.c
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       01-15-94  CFW   Use _tcsnicoll for global match.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-14-95  CFW   Debug CRT allocs for Mac version.
*       02-16-95  JWM   Spliced _WIN32 & Mac versions.
*       06-01-95  CFW   Copy environment string before passing to _crt[w]setenv.
*       07-09-97  GJF   Added a check that the environment initialization has
*                       been executed. Also, cleaned up the format a bit and 
*                       got rid of obsolete _CALLTYPE* macros.
*       03-03-98  RKP   Added 64 bit support.
*       03-05-98  GJF   Exception-safe locking.
*       08-28-98  GJF   Use CP_ACP instead of CP_OEMCP.
*       05-17-99  PML   Remove all Macintosh support.
*       05-25-99  GJF   Free up buffers allocated to hold env string when there
*                       there is a failure.
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef CRTDLL

/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
extern int __env_initialized;

#endif

/***
*int _putenv(option) - add/replace/remove variable in environment
*
*Purpose:
*       option should be of the form "option=value".  If a string with the
*       given option part already exists, it is replaced with the given
*       string; otherwise the given string is added to the environment.
*       If the string is of the form "option=", then the string is
*       removed from the environment, if it exists.  If the string has
*       no equals sign, error is returned.
*
*Entry:
*       char *option - option string to set in the environment list.
*           should be of the form "option=value".
*
*Exit:
*       returns 0 if OK, -1 if fails.
*
*Exceptions:
*
*Warning:
*       This code will not work if variables are removed from the
*       environment by deleting them from environ[].  Use _putenv("option=")
*       to remove a variable.
*
*******************************************************************************/

#ifdef  _MT

#ifdef  WPRFLAG
int __cdecl _wputenv (
#else
int __cdecl _putenv (
#endif
        const _TSCHAR *option
        )
{
        int retval;

        _mlock( _ENV_LOCK );

        __try {
#ifdef  WPRFLAG
            retval = _wputenv_lk(option);
#else
            retval = _putenv_lk(option);
#endif
        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return retval;
}

#ifdef  WPRFLAG
int __cdecl _wputenv_lk (
#else
int __cdecl _putenv_lk (
#endif
        const _TSCHAR *option
        )

#else   /* ndef _MT */

#ifdef  WPRFLAG
int __cdecl _wputenv (
#else
int __cdecl _putenv (
#endif
        const _TSCHAR *option
        )

#endif  /* _MT */

{
        int size;
        _TSCHAR * newoption;

#ifndef CRTDLL
        /*
         * Make sure the environment is initialized.
         */
        if  ( !__env_initialized )
            return -1;
#endif  /* CRTDLL */

        /*
         * At startup, we obtain the 'native' flavor of environment strings
         * from the OS. So a "main" program has _environ and a "wmain" has
         * _wenviron loaded at startup. Only when the user gets or puts the
         * 'other' flavor do we convert it.
         */

        /* copy the new environent string */
        if ( (newoption = (_TSCHAR *)_malloc_crt((_tcslen(option)+1) * 
             sizeof(_TSCHAR))) == NULL )
            return -1;

        _tcscpy(newoption, option);

#ifdef  WPRFLAG
        if ( __crtwsetenv(newoption, 1) != 0 )
        {
            _free_crt(newoption);
            return -1;
        }

        /* If other environment type exists, set it */
        if (_environ)
        {
            char *mboption;

            /* find out how much space is needed */
            if ( (size = WideCharToMultiByte(CP_ACP, 0, option, -1, NULL,
                 0, NULL, NULL)) == 0 )
                return -1;

            /* allocate space for variable */
            if ((mboption = (char *) _malloc_crt(size * sizeof(char))) == NULL)
                return -1;

            /* convert it */
            if ( WideCharToMultiByte(CP_ACP, 0, option, -1, mboption, size,
                 NULL, NULL) == 0 )
            {
                _free_crt(mboption);
                return -1;
            }

            /* set it - this is not primary call, so set primary == 0 */
            if ( __crtsetenv(mboption, 0) != 0 )
            {
                _free_crt(mboption);
                return -1;
            }
        }
#else
        /* Set requested environment type, primary call */
        if ( __crtsetenv(newoption, 1) != 0 )
        {
            _free_crt(newoption);
            return -1;
        }

        /* If other environment type exists, set it */
        if (_wenviron)
        {
            wchar_t *woption;

            /* find out how much space is needed */
            if ( (size = MultiByteToWideChar(CP_ACP, 0, option, -1, NULL, 0))
                 == 0 )
                return -1;

            /* allocate space for variable */
            if ( (woption = (wchar_t *) _malloc_crt(size * sizeof(wchar_t)))
                 == NULL )
                return -1;

            /* convert it */
            if ( MultiByteToWideChar(CP_ACP, 0, option, -1, woption, size)
                 == 0 )
            {
                _free_crt(woption);
                return -1;
            }

            /* set it - this is not primary call, so set primary == 0 */
            if ( __crtwsetenv(woption, 0) != 0 )
            {
                _free_crt(woption);
                return -1;
            }
        }
#endif

        return 0;
}



/***
*int findenv(name, len) - [STATIC]
*
*Purpose:
*       Scan for the given string within the environment
*
*Entry:
*
*Exit:
*       Returns the offset in "environ[]" of the given variable
*       Returns the negative of the length of environ[] if not found.
*       Returns 0 if the environment is empty.
*
*       [NOTE: That a 0 return can mean that the environment is empty
*       or that the string was found as the first entry in the array.]
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
static int __cdecl wfindenv (
#else
static int __cdecl findenv (
#endif
        const _TSCHAR *name,
        int len
        )
{
        _TSCHAR **env;

        for ( env = _tenviron ; *env != NULL ; env++ ) {
            /*
             * See if first len characters match, up to case
             */
            if ( _tcsnicoll(name, *env, len) == 0 )
                /*
                 * the next character of the environment string must
                 * be an '=' or a '\0'
                 */
                if ( (*env)[len] == _T('=') || (*env)[len] == _T('\0') )
                    return(int)(env - _tenviron);
//
// We cannot break here since findenv must report the total number of strings.
//              else
//                  break;
        }

        return(-(int)(env - _tenviron));
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\rand.c ===
/***
*rand.c - random number generator
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines rand(), srand() - random number generator
*
*Revision History:
*	03-16-84  RN	initial version
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-31-88  PHG	Merged DLL and normal versions
*	06-06-89  JCR	386 mthread support
*	03-15-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	04-05-90  GJF	Added #include <stdlib.h>.
*	10-04-90  GJF	New-style function declarators.
*	07-17-91  GJF	Multi-thread support for Win32 [_WIN32_].
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	09-06-94  CFW	Remove Cruiser support.
*	09-06-94  CFW	Replace MTHREAD with _MT.
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>

#ifndef _MT
static long holdrand = 1L;
#endif

/***
*void srand(seed) - seed the random number generator
*
*Purpose:
*	Seeds the random number generator with the int given.  Adapted from the
*	BASIC random number generator.
*
*Entry:
*	unsigned seed - seed to seed rand # generator with
*
*Exit:
*	None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl srand (
	unsigned int seed
	)
{
#ifdef	_MT

	_getptd()->_holdrand = (unsigned long)seed;

#else
	holdrand = (long)seed;
#endif
}


/***
*int rand() - returns a random number
*
*Purpose:
*	returns a pseudo-random number 0 through 32767.
*
*Entry:
*	None.
*
*Exit:
*	Returns a pseudo-random number 0 through 32767.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl rand (
	void
	)
{
#ifdef	_MT

	_ptiddata ptd = _getptd();

	return( ((ptd->_holdrand = ptd->_holdrand * 214013L
	    + 2531011L) >> 16) & 0x7fff );

#else
	return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\qsort.c ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To implement the qsort() routine for sorting arrays.
*
*Revision History:
*       06-22-84  RN    author
*       03-25-85  RN    added pre-check for elements already in order to
*                       eliminate worst-case behavior.
*       05-18-86  TC    changed to recurse on the smallest piece to avoid
*                       piece. unneccesary stack usage, and to iterate on
*                       largest
*       01-09-87  BCM   fixed huge-array case where (num-1) * wid computation
*                       was overflowing (large/compact models only)
*       06-13-89  PHG   made more efficient, many more comments, removed
*                       recursion
*       10-30-89  JCR   Added _cdecl to prototypes
*       03-15-90  GJF   Replaced _cdecl with _CALLTYPE1 and added #include
*                       <cruntime.h>. Also, fixed the copyright.
*       04-05-90  GJF   Made shortsort() and swap() _CALLTYPE4. Also, added
*                       #include <search.h>.
*       10-04-90  GJF   New-style function declarators.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragmas
*       01-24-91  SRW   Added missing close comment in swap procedure
*       11-19-91  GJF   Do the swap one character at a time to avoid alignment
*                       woes.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-27-98  RKP   Add 64 bit support.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-10-00  PML   Performance improvements - middle-of-3 pivot choice,
*                       widen middle range equal to pivot, don't swap pivot to
*                       beginning (vs7#99674).
*       08-08-00  PML   Avoid calling comp(p,p), since some existing code
*                       doesn't expect that (vs7#123134).
*
*******************************************************************************/

#include <stdlib.h>
#include <search.h>
#ifdef NEW_QSORT_NAME
#define qsort NEW_QSORT_NAME
#endif

/* Always compile this module for speed, not size */
#pragma optimize("t", on)

/* prototypes for local routines */
static void __cdecl shortsort(char *lo, char *hi, size_t width,
                int (__cdecl *comp)(const void *, const void *));
static void __cdecl swap(char *p, char *q, size_t width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */

/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*       maximum array size is number of elements times size of elements,
*       but is limited by the virtual address space of the processor
*
*Entry:
*       char *base = pointer to base of array
*       size_t num  = number of elements in the array
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

#define STKSIZ (8*sizeof(void*) - 2)

void __cdecl qsort (
    void *base,
    size_t num,
    size_t width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    /* Note: the number of stack entries required is no more than
       1 + log2(num), so 30 is sufficient for any array */
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    size_t size;                /* size of the sub-array */
    char *lostk[STKSIZ], *histk[STKSIZ];
    int stkptr;                 /* stack for saving sub-array to be processed */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       preserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
        shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partitioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the median
           of the values, but also that we select one fast.  We choose the
           median of the first, middle, and last elements, to avoid bad
           performance in the face of already sorted data, or data that is made
           up of multiple sorted runs appended together.  Testing shows that a
           median-of-three algorithm provides better performance than simply
           picking the middle element for the latter case. */

        mid = lo + (size / 2) * width;      /* find middle element */

        /* Sort the first, middle, last elements into order */
        if (comp(lo, mid) > 0) {
            swap(lo, mid, width);
        }
        if (comp(lo, hi) > 0) {
            swap(lo, hi, width);
        }
        if (comp(mid, hi) > 0) {
            swap(mid, hi, width);
        }

        /* We now wish to partition the array into three pieces, one consisting
           of elements <= partition element, one of elements equal to the
           partition element, and one of elements > than it.  This is done
           below; comments indicate conditions established at every step. */

        loguy = lo;
        higuy = hi;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi,
               A[i] <= A[mid] for lo <= i <= loguy,
               A[i] > A[mid] for higuy <= i < hi,
               A[hi] >= A[mid] */

            /* The doubled loop is to avoid calling comp(mid,mid), since some
               existing comparison funcs don't work when passed the same
               value for both pointers. */

            if (mid > loguy) {
                do  {
                    loguy += width;
                } while (loguy < mid && comp(loguy, mid) <= 0);
            }
            if (mid <= loguy) {
                do  {
                    loguy += width;
                } while (loguy <= hi && comp(loguy, mid) <= 0);
            }

            /* lo < loguy <= hi+1, A[i] <= A[mid] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[mid] */

            do  {
                higuy -= width;
            } while (higuy > mid && comp(higuy, mid) > 0);

            /* lo <= higuy < hi, A[i] > A[mid] for higuy < i < hi,
               either higuy == lo or A[higuy] <= A[mid] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy == lo, then we would have exited, so
               A[loguy] > A[mid], A[higuy] <= A[mid],
               loguy <= hi, higuy > lo */

            swap(loguy, higuy, width);

            /* If the partition element was moved, follow it.  Only need
               to check for mid == higuy, since before the swap,
               A[loguy] > A[mid] implies loguy != mid. */

            if (mid == higuy)
                mid = loguy;

            /* A[loguy] <= A[mid], A[higuy] > A[mid]; so condition at top
               of loop is re-established */
        }

        /*     A[i] <= A[mid] for lo <= i < loguy,
               A[i] > A[mid] for higuy < i < hi,
               A[hi] >= A[mid]
               higuy < loguy
           implying:
               higuy == loguy-1
               or higuy == hi - 1, loguy == hi + 1, A[hi] == A[mid] */

        /* Find adjacent elements equal to the partition element.  The
           doubled loop is to avoid calling comp(mid,mid), since some
           existing comparison funcs don't work when passed the same value
           for both pointers. */

        higuy += width;
        if (mid < higuy) {
            do  {
                higuy -= width;
            } while (higuy > mid && comp(higuy, mid) == 0);
        }
        if (mid >= higuy) {
            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, mid) == 0);
        }

        /* OK, now we have the following:
              higuy < loguy
              lo <= higuy <= hi
              A[i]  <= A[mid] for lo <= i <= higuy
              A[i]  == A[mid] for higuy < i < loguy
              A[i]  >  A[mid] for loguy <= i < hi
              A[hi] >= A[mid] */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - lo >= hi - loguy ) {
            if (lo < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo < higuy) {
                hi = higuy;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl shortsort (
    char *lo,
    char *hi,
    size_t width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       size_t width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    size_t width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\rotl.c ===
/***
*rotl.c - rotate an unsigned integer left
*
*   Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines _rotl() - performs a rotate left on an unsigned integer.
*
*Revision History:
*   06-02-89  PHG   Module created
*   11-03-89  JCR   Added _lrotl
*   03-15-90  GJF   Made calling type _CALLTYPE1, added #include
*                   <cruntime.h> and fixed the copyright. Also, cleaned
*                   up the formatting a bit.
*   10-04-90  GJF   New-style function declarators.
*   04-01-91  SRW   Enable #pragma function for i386 _WIN32_ builds too.
*   09-02-92  GJF   Don't build for POSIX.
*   04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                   No _CRTIMP for CRT DLL model due to intrinsic
*   12-03-93  GJF   Turn on #pragma function for all MS front-ends (esp.,
*                   Alpha compiler).
*   01-04-01  GB    Rewrote rotl functions and added __int64 version.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

#ifdef _MSC_VER
#pragma function(_lrotl,_rotl, _rotl64)
#endif

#if UINT_MAX != 0xffffffff /*IFSTRIP=IGN*/
#error This module assumes 32-bit integers
#endif

#if UINT_MAX != ULONG_MAX /*IFSTRIP=IGN*/
#error This module assumes sizeof(int) == sizeof(long)
#endif

/***
*unsigned _rotl(val, shift) - int rotate left
*
*Purpose:
*   Performs a rotate left on an unsigned integer.
*
*   [Note:  The _lrotl entry is based on the assumption
*   that sizeof(int) == sizeof(long).]
*Entry:
*   unsigned val:   value to rotate
*   int    shift:   number of bits to shift by
*
*Exit:
*   returns rotated value
*
*Exceptions:
*   None.
*
*******************************************************************************/

unsigned long __cdecl _lrotl (
    unsigned long val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val>>(0x20 - shift)) | (val << shift);
    return val;
}

unsigned __cdecl _rotl (
    unsigned val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val>>(0x20 - shift)) | (val << shift);
    return val;
}

unsigned __int64 __cdecl _rotl64 (
    unsigned __int64 val,
    int shift
    )
{
    shift &= 0x3f;
    val = (val>>(0x40 - shift)) | (val << shift);
    return val;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\rotr.c ===
/***
*rotr.c - rotate an unsigned integer right
*
*   Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines _rotr() - performs a rotate right on an unsigned integer.
*
*Revision History:
*   06-02-89  PHG   Module created
*   11-03-89  JCR   Added _lrotl
*   03-15-90  GJF   Made calling type _CALLTYPE1, added #include
*                   <cruntime.h> and fixed the copyright. Also, cleaned
*                   up the formatting a bit.
*   10-04-90  GJF   New-style function declarators.
*   04-01-91  SRW   Enable #pragma function for i386 _WIN32_ builds too.
*   09-02-92  GJF   Don't build for POSIX.
*   04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                   No _CRTIMP for CRT DLL model due to intrinsic
*   12-03-93  GJF   Turn on #pragma function for all MS front-ends (esp.,
*                      Alpha compiler).
*   01-04-01  GB    Rewrote rotr functions and added __int64 version.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

#ifdef _MSC_VER
#pragma function(_lrotr,_rotr, _rotr64)
#endif

#if UINT_MAX != 0xffffffff /*IFSTRIP=IGN*/
#error This module assumes 32-bit integers
#endif

#if UINT_MAX != ULONG_MAX /*IFSTRIP=IGN*/
#error This module assumes sizeof(int) == sizeof(long)
#endif

/***
*unsigned _rotr(val, shift) - int rotate right
*
*Purpose:
*   Performs a rotate right on an unsigned integer.
*
*   [Note:  The _lrotl entry is based on the assumption
*   that sizeof(int) == sizeof(long).]
*Entry:
*   unsigned val:   value to rotate
*   int    shift:   number of bits to shift by
*
*Exit:
*   returns rotated value
*
*Exceptions:
*   None.
*
*******************************************************************************/

unsigned long __cdecl _lrotr (
    unsigned long val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val<<(0x20 - shift)) | (val >> shift);
    return val;
}

unsigned __cdecl _rotr (
    unsigned val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val<<(0x20 - shift)) | (val >> shift);
    return val;
}

unsigned __int64 __cdecl _rotr64 (
    unsigned __int64 val,
    int shift
    )
{
    shift &= 0x3f;
    val = (val<<(0x40 - shift)) | (val >> shift);
    return val;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\searchen.c ===
/***
*searchenv.c - find a file using paths from an environment variable
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       to search a set a directories specified by an environment variable
*       for a specified file name.  If found the full path name is returned.
*
*Revision History:
*       06-15-87  DFW   initial implementation
*       08-06-87  JCR   Changed directory delimeter from '/' to '\'.
*       09-24-87  JCR   Removed 'const' from declarations (caused cl warnings).
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-17-88  JCR   Added 'const' copy_path local to get rid of cl warning.
*       07-19-88  SKS   Fixed bug if root directory is current directory
*       08-03-89  JCR   Allow quoted strings in file/path names
*       08-29-89  GJF   Changed copy_path() to _getpath() and moved it to it's
*                       own source file. Also fixed handling of multiple semi-
*                       colons.
*       11-20-89  GJF   Added const attribute to types of fname and env_var.
*       03-15-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>. Also, cleaned up the formatting a bit.
*       07-25-90  SBM   Removed redundant include (stdio.h)
*       10-04-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-31-95  GJF   Use _fullpath instead of _getcwd, to convert a file
*                       that exists relative to the current directory, to a
*                       fully qualified path.
*       02-16-95  JWM   Mac merge.
*       03-29-95  BWT   Fix POSIX build by sticking with getcwd.
*       10-20-95  GJF   Use local buffer instead of the caller's buffer to
*                       build the pathname (Olympus0 9336).
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <direct.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <internal.h>
#include <tchar.h>

/***
*_searchenv() - search for file along paths from environment variable
*
*Purpose:
*       to search for a specified file in the directory(ies) specified by
*       a given environment variable, and, if found, to return the full
*       path name of the file.  The file is first looked for in the current
*       working directory, prior to looking in the paths specified by env_var.
*
*Entry:
*       fname - name of file to search for
*       env_var - name of environment variable to use for paths
*       path - pointer to storage for the constructed path name
*
*Exit:
*       path - pointer to constructed path name, if the file is found, otherwise
*              it points to the empty string.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _tsearchenv (
        const _TSCHAR *fname,
        const _TSCHAR *env_var,
        _TSCHAR *path
        )
{
        register _TSCHAR *p;
        register int c;
        _TSCHAR *env_p;
        size_t len;
        _TSCHAR pathbuf[_MAX_PATH + 4];

        if (_taccess(fname, 0) == 0) {

#if     !defined(_POSIX_)
            /* exists, convert it to a fully qualified pathname and
               return */
            if ( _tfullpath(path, fname, _MAX_PATH) == NULL )
                *path = _T('\0');
#else   /* !_POSIX_ */
            /* exists in this directory - get cwd and concatenate file
               name */
#if     defined(_POSIX_)
            if (getcwd(path, _MAX_PATH))
#else
            if (_tgetcwd(path, _MAX_PATH))
#endif
            {
                _tcscat(path, fname);
            }
#endif  /* !_POSIX_ */

            return;
        }

        if ((env_p = _tgetenv(env_var)) == NULL) {
            /* no such environment var. and not in cwd, so return empty
               string */
            *path = _T('\0');
            return;
        }

#ifdef  _UNICODE
        while ( (env_p = _wgetpath(env_p, pathbuf, _MAX_PATH)) && *pathbuf ) {
#else
        while ( (env_p = _getpath(env_p, pathbuf, _MAX_PATH)) && *pathbuf ) {
#endif
            /* path now holds nonempty pathname from env_p, concatenate
               the file name and go */

            len = _tcslen(pathbuf);
            p = pathbuf + len;
            if ( ((c = *(p - 1)) != _T('/')) && (c != _T('\\')) &&
                 (c != _T(':')) )
            {
                /* add a trailing '\' */
                *p++ = _T('\\');
                len++;
            }
            /* p now points to character following trailing '/', '\'
               or ':' */

            if ( (len + _tcslen(fname)) <= _MAX_PATH ) {
                _tcscpy(p, fname);
                if ( _taccess(pathbuf, 0) == 0 ) {
                    /* found a match, copy the full pathname into the caller's
                       buffer */
                    _tcscpy(path, pathbuf);
                    return;
                }
            }
        }
        /* if we get here, we never found it, return empty string */
        *path = _T('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\seccinit.c ===
/***
*seccinit.c - initialize the global buffer overrun security cookie
*
*       Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Define __security_init_cookie, which is called at startup to initialize
*       the global buffer overrun security cookie used by the /GS compile flag.
*
*       NOTE: The ATLMINCRT library includes a version of this file.  If any
*       changes are made here, they should be duplicated in the ATL version.
*
*Revision History:
*       01-24-00  PML   Created.
*       09-16-00  PML   Make sure cookie never initialized to zero (vs7#162619)
*       09-20-00  PML   Use a better cookie initialization (vs7#165188)
*
*******************************************************************************/

#include <internal.h>
#include <windows.h>

/*
 * The global security cookie.  This name is known to the compiler.
 */
extern DWORD_PTR __security_cookie;

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
    unsigned __int64 ft_scalar;
    FILETIME ft_struct;
} FT;

/***
*__security_init_cookie(cookie) - init buffer overrun security cookie.
*
*Purpose:
*       Initialize the global buffer overrun security cookie which is used by
*       the /GS compile switch to detect overwrites to local array variables
*       the potentially corrupt the return address.  This routine is called
*       at EXE/DLL startup.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __security_init_cookie(void)
{
    DWORD_PTR cookie;
    FT systime;
    LARGE_INTEGER perfctr;

    /*
     * Initialize the global cookie with an unpredictable value which is
     * different for each module in a process.  Combine a number of sources
     * of randomness.
     */

    GetSystemTimeAsFileTime(&systime.ft_struct);
#if !defined(_WIN64)
    cookie = systime.ft_struct.dwLowDateTime;
    cookie ^= systime.ft_struct.dwHighDateTime;
#else
    cookie = systime.ft_scalar;
#endif

    cookie ^= GetCurrentProcessId();
    cookie ^= GetCurrentThreadId();
    cookie ^= GetTickCount();

    QueryPerformanceCounter(&perfctr);
#if !defined(_WIN64)
    cookie ^= perfctr.LowPart;
    cookie ^= perfctr.HighPart;
#else
    cookie ^= perfctr.QuadPart;
#endif

    /*
     * Make sure the global cookie is never initialized to zero, since in that
     * case an overrun which sets the local cookie and return address to the
     * same value would go undetected.
     */

    __security_cookie = cookie ? cookie : 0xBB40E64E;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\secfail.c ===
/***
*secfail.c - Report a /GS security check failure
*
*       Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Define function used to report a security check failure, along with a
*       routine for registering a new handler.
*
*       Entrypoints:
*       __security_error_handler
*       _set_security_error_handler
*
*       NOTE: The ATLMINCRT library includes a version of this file.  If any
*       changes are made here, they should be duplicated in the ATL version.
*
*Revision History:
*       01-24-00  PML   Created.
*       08-09-00  PML   Never return from failure reporting.
*       08-29-00  PML   Rename handlers, add extra parameters
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <windows.h>
#include <stdlib.h>
#include <awint.h>
#include <dbgint.h>

/*
 * User-registered failure reporting routine.
 */

static _secerr_handler_func user_handler;

/*
 * Default messagebox string components
 */

#define PROGINTRO   "Program: "
#define DOTDOTDOT   "..."

#define BOXINTRO_0  "Unknown security failure detected!"
#define MSGTEXT_0   \
    "A security error of unknown cause has been detected which has\n"      \
    "corrupted the program's internal state.  The program cannot safely\n" \
    "continue execution and must now be terminated.\n"

#define BOXINTRO_1  "Buffer overrun detected!"
#define MSGTEXT_1   \
    "A buffer overrun has been detected which has corrupted the program's\n"  \
    "internal state.  The program cannot safely continue execution and must\n"\
    "now be terminated.\n"

#define MAXLINELEN  60 /* max length for line in message box */

/***
*__security_error_handler() - Report security error.
*
*Purpose:
*       A /GS security error has been detected.  If a user-registered failure
*       reporting function is available, call it, otherwise bring up a default
*       message box describing the problem and terminate the program.
*
*Entry:
*       int code - security failure code
*       void *data - code-specific data
*
*Exit:
*       Does not return.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __security_error_handler(
    int code,
    void *data)
{
    /* Use user-registered handler if available. */
    if (user_handler != NULL) {
        __try {
            user_handler(code, data);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            /*
             * If user handler raises an exception, capture it and terminate
             * the program, since the EH stack may be corrupted above this
             * point.
             */
        }
    }
    else {
        char progname[MAX_PATH + 1];
        char * pch;
        char * outmsg;
        char * boxintro;
        char * msgtext;
        size_t subtextlen;

        switch (code) {
        default:
            /*
             * Unknown failure code, which probably means an older CRT DLL is
             * being used with a newer compiler.
             */
            boxintro = BOXINTRO_0;
            msgtext = MSGTEXT_0;
            subtextlen = sizeof(BOXINTRO_0) + sizeof(MSGTEXT_0);
            break;
        case _SECERR_BUFFER_OVERRUN:
            /*
             * Buffer overrun detected which may have overwritten a return
             * address.
             */
            boxintro = BOXINTRO_1;
            msgtext = MSGTEXT_1;
            subtextlen = sizeof(BOXINTRO_1) + sizeof(MSGTEXT_1);
            break;
        }

        /*
         * In debug CRT, report error with ability to call the debugger.
         */
        _RPT0(_CRT_ERROR, msgtext);

        progname[MAX_PATH] = '\0';
        if (!GetModuleFileName(NULL, progname, MAX_PATH))
            strcpy(progname, "<program name unknown>");

        pch = progname;

        /* sizeof(PROGINTRO) includes the NULL terminator */
        if (sizeof(PROGINTRO) + strlen(progname) + 1 > MAXLINELEN)
        {
            pch += (sizeof(PROGINTRO) + strlen(progname) + 1) - MAXLINELEN;
            strncpy(pch, DOTDOTDOT, sizeof(DOTDOTDOT) - 1);
        }

        outmsg = (char *)_alloca(subtextlen - 1 + 2
                                 + sizeof(PROGINTRO) - 1
                                 + strlen(pch) + 2);

        strcpy(outmsg, boxintro);
        strcat(outmsg, "\n\n");
        strcat(outmsg, PROGINTRO);
        strcat(outmsg, pch);
        strcat(outmsg, "\n\n");
        strcat(outmsg, msgtext);

        __crtMessageBoxA(
            outmsg,
            "Microsoft Visual C++ Runtime Library",
            MB_OK|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
    }

    _exit(3);
}

/***
*_set_security_error_handler(handler) - Register user handler
*
*Purpose:
*       Register a user failure reporting function.
*
*Entry:
*       _secerr_handler_func handler - the user handler
*
*Exit:
*       Returns the previous user handler
*
*Exceptions:
*
*******************************************************************************/

_secerr_handler_func __cdecl _set_security_error_handler(
    _secerr_handler_func handler)
{
    _secerr_handler_func old_handler;

    old_handler = user_handler;
    user_handler = handler;

    return old_handler;
}

/* TEMPORARY - old handler name, to be removed when tools are updated. */
void __cdecl __buffer_overrun()
{
    __security_error_handler(_SECERR_BUFFER_OVERRUN, NULL);
}

/* TEMPORARY - old handler name, to be removed when tools are updated. */
_secerr_handler_func __cdecl __set_buffer_overrun_handler(
    _secerr_handler_func handler)
{
    return _set_security_error_handler(handler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\seccook.c ===
/***
*seccook.c - defines and checks buffer overrun security cookie
*
*       Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines per-module global variable __security_cookie and compiler
*       helper __security_check_cookie, which are used by the /GS compile
*       switch to detect local buffer variable overrun bugs/attacks.
*
*       When compiling /GS, the compiler injects code to detect when a local
*       array variable has been overwritten, potentially overwriting the
*       return address (on machines like x86 where the return address is on
*       the stack).  A local variable is allocated directly before the return
*       address and initialized on entering the function.  When exiting the
*       function, the compiler inserts code to verify that the local variable
*       has not been modified.  If it has, then an error reporting routine
*       is called.
*
*       NOTE: The ATLMINCRT library includes a version of this file.  If any
*       changes are made here, they should be duplicated in the ATL version.
*
*Revision History:
*       01-24-00  PML   Created.
*       08-09-00  PML   Preserve EAX on non-failure case (VS7#147203).  Also
*                       make sure failure case never returns.
*       08-29-00  PML   Rename handlers, add extra parameters.  Move most of
*                       system CRT version over to seclocf.c.
*       09-16-00  PML   Initialize global cookie earlier, and give it a nonzero
*                       static initialization (vs7#162619).
*
*******************************************************************************/

#include <sect_attribs.h>
#include <internal.h>
#include <windows.h>
#include <stdlib.h>

/*
 * The global security cookie.  This name is known to the compiler.
 * Initialize to a garbage non-zero value just in case we have a buffer overrun
 * in any code that gets run before __security_init_cookie() has a chance to
 * initialize the cookie to the final value.
 */

DWORD_PTR __security_cookie = 0xBB40E64E;

/*
 * Trigger initialization of the global security cookie on program startup.
 * Force initialization before any #pragma init_seg() inits by using .CRT$XCAA
 * as the startup funcptr section.
 */

#pragma data_seg(".CRT$XCAA")
extern void __cdecl __security_init_cookie(void);
static _CRTALLOC(".CRT$XCAA") _PVFV init_cookie = __security_init_cookie;
#pragma data_seg()

static void __cdecl report_failure(void);

#if !defined(_SYSCRT) || !defined(CRTDLL)
/*
 * The routine called if a cookie check fails.
 */
#define REPORT_ERROR_HANDLER    __security_error_handler
#else
/*
 * When using an older system CRT, use a local cookie failure reporting
 * routine, with a default implementation that calls __security_error_handler
 * if available, otherwise displays a default message box.
 */
#define REPORT_ERROR_HANDLER    __local_security_error_handler
#endif

extern void __cdecl REPORT_ERROR_HANDLER(int, void *);

/***
*__security_check_cookie(cookie) - check for buffer overrun
*
*Purpose:
*       Compiler helper.  Check if a local copy of the security cookie still
*       matches the global value.  If not, then report the fatal error.
*
*       The actual reporting is split out into static helper report_failure,
*       since the cookie check routine must be minimal code that preserves
*       any registers used in returning the callee's result.
*
*Entry:
*       DWORD_PTR cookie - local security cookie to check
*
*Exit:
*       Returns immediately if the local cookie matches the global version.
*       Otherwise, calls the failure reporting handler and exits.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _M_IX86

void __fastcall __security_check_cookie(DWORD_PTR cookie)
{
    /* Immediately return if the local cookie is OK. */
    if (cookie == __security_cookie)
        return;

    /* Report the failure */
    report_failure();
}

#else

void __declspec(naked) __fastcall __security_check_cookie(DWORD_PTR cookie)
{
    /* x86 version written in asm to preserve all regs */
    __asm {
        cmp ecx, __security_cookie
        jne failure
        ret
failure:
        jmp report_failure
    }
}

#endif

static void __cdecl report_failure(void)
{
    /* Report the failure */
    __try {
        REPORT_ERROR_HANDLER(_SECERR_BUFFER_OVERRUN, NULL);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        /* nothing */
    }

    ExitProcess(3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\setenv.c ===
/***
*setenv.c -set an environment variable in the environment
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __crtsetenv() - adds a new variable to environment.
*       Internal use only.
*
*Revision History:
*       11-30-93  CFW   Module created, most of it grabbed from putenv.c.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       01-15-94  CFW   Use _tcsnicoll for global match.
*       01-28-94  CFW   Copy environment when re-alloc.
*       03-25-94  GJF   Declaration of __[w]initenv moved to internal.h.
*       01-10-95  CFW   Debug CRT allocs.
*       01-18-95  GJF   Must replace _tcsdup with _malloc_crt/_tcscpy for
*                       _DEBUG build.
*       06-01-95  CFW   Free strings for removed environemnt variables.
*       03-03-98  RKP   Add support for 64 bit
*       05-28-99  GJF   When appropriate, free up the option string.
*       08-03-99  PML   Fix use-after-free bug in __crtsetenv()
*       02-23-00  GB    Fix __crtwsetenv() so as to work on Win9x.
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       05-23-00  GB    return error (-1) for API returning error
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <tchar.h>
#include <rterr.h>
#include <dbgint.h>

static _TSCHAR **copy_environ(_TSCHAR **);

#ifdef  WPRFLAG
static int __cdecl wfindenv(const wchar_t *name, int len);
#define USE_W   1
#define USE_A   0
#else
static int __cdecl findenv(const char *name, int len);
#endif

/***
*int __crtsetenv(option) - add/replace/remove variable in environment
*
*Purpose:
*       option should be of the form "option=value".  If a string with the
*       given option part already exists, it is replaced with the given
*       string; otherwise the given string is added to the environment.
*       If the string is of the form "option=", then the string is
*       removed from the environment, if it exists.  If the string has
*       no equals sign, error is returned.
*
*Entry:
*       char *option - option string to set in the environment list.
*           should be of the form "option=value".
*       int primary - Only the primary call to _crt[w]setenv needs to
*           create new copies or set the OS environment.
*           1 indicates that this is the primary call.
*
*Exit:
*       returns 0 if OK, -1 if fails.
*
*Exceptions:
*
*Warnings:
*       This code will not work if variables are removed from the environment
*       by deleting them from environ[].  Use _putenv("option=") to remove a 
*       variable.
*
*       The option argument may be freed!
*
*******************************************************************************/

#ifdef  WPRFLAG
int __cdecl __crtwsetenv (
#else
int __cdecl __crtsetenv (
#endif
        _TSCHAR *option,
        const int primary
        )
{
#ifdef  WPRFLAG
        static int f_use = USE_W;
#endif
        int ix;
        int retval = 0;
        int remove; /* 1 if variable is to be removed */
        _TSCHAR **env;
        _TSCHAR *name, *value;
        const _TSCHAR *equal;

        /*
         * check that the option string is valid, find the equal sign
         * and verify '=' is not the first character in string.
         */
        if ( (option == NULL) || ((equal = _tcschr(option, _T('='))) == NULL)
            || option == equal)
            return(-1);

        /* if the character following '=' is null, we are removing the
         * the environment variable. Otherwise, we are adding or updating
         * an environment variable.
         */
        remove = (*(equal + 1) == _T('\0'));

        /*
         * the first time _[w]putenv() is called, copy the environment
         * block that was passed to [w]main to avoid making a
         * dangling pointer if the block is re-alloced.
         */
#ifdef  WPRFLAG
        if (_wenviron == __winitenv)
            _wenviron = copy_environ(_wenviron);
#else
        if (_environ == __initenv)
            _environ = copy_environ(_environ);
#endif

        /* see if requested environment array exists */
        if (_tenviron == NULL) {

            /*
             * The requested type of environment does not exist.
             * See if other type exists, if so convert it to requested type.
             * The functions that convert the enviroment (__mbtow_environ and
             * __wtomb_environ) will call this function (__crt[w]setenv) once
             * for each of the pre-existing environment variables. To avoid
             * an infinite loop, test the primary flag.
             */

#ifdef  WPRFLAG
            if (primary && _environ)
            {
                if (__mbtow_environ() != 0)
                    return -1;
            }
#else
            if (primary && _wenviron)
            {
                if (__wtomb_environ() != 0)
                    return -1;
            }
#endif
            else {
                /* nothing to remove, return */
                if ( remove )
                    return 0;
                else {
                    /* create ones that do not exist */

                    if (_environ == NULL)
                    {
                        if ( (_environ = _malloc_crt(sizeof(char *))) == NULL)
                            return -1;
                        *_environ = NULL;
                    }

                    if (_wenviron == NULL)
                    {
                        if ( (_wenviron = _malloc_crt(sizeof(wchar_t *))) == NULL)
                            return -1;
                        *_wenviron = NULL;
                    }
                }
            }
        }

        /*
         * At this point, the two types of environments are in sync (as much
         * as they can be anyway). The only way they can get out of sync
         * (besides users directly modifiying the environment) is if there
         * are conversion problems: If the user sets two Unicode EVs,
         * "foo1" and "foo2" and converting then to multibyte yields "foo?"
         * and "foo?", then the environment blocks will differ.
         */

        /* init env pointers */
        env = _tenviron;

        /* See if the string is already in the environment */
#ifdef  WPRFLAG
        ix = wfindenv(option, (int)(equal - option));
#else
        ix = findenv(option, (int)(equal - option));
#endif

        if ((ix >= 0) && (*env != NULL)) {
            /* 
             * String is already in the environment. Free up the original
             * string. Then, install the new string or shrink the environment,
             * whichever is warranted.
             */
            _free_crt(env[ix]);

            if (remove) {

                /* removing -- move all the later strings up */
                for ( ; env[ix] != NULL; ++ix) {
                    env[ix] = env[ix+1];
                }

                /* shrink the environment memory block
                   (ix now has number of strings, including NULL) --
                   this realloc probably can't fail, since we're
                   shrinking a mem block, but we're careful anyway. */
                if (env = (_TSCHAR **) _realloc_crt(env, ix * sizeof(_TSCHAR *)))
                    _tenviron = env;
            }
            else {
                /* replace the option */
                env[ix] = (_TSCHAR *) option;
            }
        }
        else {
            /*
             * String is NOT in the environment
             */
            if ( !remove )  {
                /*
                 * Append the string to the environ table. Note that
                 * table must be grown to do this.
                 */
                if (ix < 0)
                    ix = -ix;    /* ix = length of environ table */

                if ( (env = (_TSCHAR **)_realloc_crt(env, sizeof(_TSCHAR *) *
                    (ix + 2))) == NULL )
                    return -1;

                env[ix] = (_TSCHAR *)option;
                env[ix + 1] = NULL;

                _tenviron = env;
            }
            else {
                /*
                 * We are asked to remove an environment var that isn't there.
                 * Free the option string and return success.
                 */
                _free_crt(option);
                return 0;
            }
        }

        /*
         * Update the OS environment. Don't give an error if this fails
         * since the failure will not affect the user unless he/she is making
         * direct API calls. Only need to do this for one type, OS converts
         * to other type automatically.
         */
        if ( primary &&
            (name = (_TSCHAR *)_malloc_crt((_tcslen(option) + 2) * sizeof(_TSCHAR))) != NULL )
        {
            _tcscpy(name, option);
            value = name + (equal - option);
            *value++ = _T('\0');
#ifdef WPRFLAG
            if (f_use == USE_W)
            {
                if ( SetEnvironmentVariableW(name, remove ? NULL : value) == 0)
                {
                    if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                        f_use = USE_A;
                    else
                        retval = -1;
                }
            }
            if (f_use == USE_A)
            {
                int size;
                char *c_name = NULL, *c_value = NULL;
                if ((size = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL)) == 0)
                    retval = -1;
                
                /* allocate space for variable */
                else if ((c_name = (char *) _malloc_crt(size * sizeof(char))) == NULL)
                    retval = -1;
                
                /* convert it */
                else if (WideCharToMultiByte(CP_ACP, 0, name, -1, c_name, size, NULL, NULL) == 0)
                    retval = -1;
            
                else if ( !remove )
                {
                    if ((size = WideCharToMultiByte(CP_ACP, 0, value, -1, NULL, 0, NULL, NULL)) == 0)
                        retval = -1;                    
                    /* allocate space for variable */
                    else if ((c_value = (char *) _malloc_crt(size * sizeof(char))) == NULL)
                        retval = -1;
                    /* convert it */
                    else if (WideCharToMultiByte(CP_ACP, 0, value, -1, c_value, size, NULL, NULL) == 0)
                        retval = -1;
                }

                if (retval != -1)
                    if (SetEnvironmentVariableA(c_name, remove ? NULL : c_value) == 0)
                        retval = -1;

                _free_crt(c_value);
                _free_crt(c_name);
            }
#else
            if (SetEnvironmentVariable(name, remove ? NULL : value) == 0)
                retval = -1;
#endif
            _free_crt(name);
        }

        if (remove) {
            /* free option string since it won't be used anymore */
            _free_crt(option);
        }

        return retval;
}


/***
*int findenv(name, len) - [STATIC]
*
*Purpose:
*       Scan for the given string within the environment
*
*Entry:
*
*Exit:
*       Returns the offset in "environ[]" of the given variable
*       Returns the negative of the length of environ[] if not found.
*       Returns 0 if the environment is empty.
*
*       [NOTE: That a 0 return can mean that the environment is empty
*       or that the string was found as the first entry in the array.]
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
static int __cdecl wfindenv (
#else
static int __cdecl findenv (
#endif
        const _TSCHAR *name,
        int len
        )
{
        _TSCHAR **env;

        for ( env = _tenviron ; *env != NULL ; env++ ) {
            /*
             * See if first len characters match, up to case
             */
            if ( _tcsnicoll(name, *env, len) == 0 )
                /*
                 * the next character of the environment string must
                 * be an '=' or a '\0'
                 */
                if ( (*env)[len] == _T('=') || (*env)[len] == _T('\0') )
                    return(int)(env - _tenviron);
//
// We cannot break here since findenv must report the total number of strings.
//              else
//                  break;
        }

        return(-(int)(env - _tenviron));
}


/***
*copy_environ - copy an environment block
*
*Purpose:
*       Create a copy of an environment block.
*
*Entry:
*       _TSCHAR **oldenviron - pointer to enviroment to be copied.
*
*Exit:
*       Returns a pointer to newly created environment.
*
*Exceptions:
*
*******************************************************************************/

static _TSCHAR **copy_environ(_TSCHAR **oldenviron)
{
        int cvars = 0;
        _TSCHAR **oldenvptr = oldenviron;
        _TSCHAR **newenviron, **newenvptr;

        /* no environment */
        if (oldenviron == NULL)
            return NULL;

        /* count number of environment variables */
        while (*oldenvptr++)
            cvars++;

        /* need pointer for each string, plus one null ptr at end */
        if ( (newenviron = newenvptr = (_TSCHAR **)
            _malloc_crt((cvars+1) * sizeof(_TSCHAR *))) == NULL )
            _amsg_exit(_RT_SPACEENV);

        /* duplicate the environment variable strings */
        oldenvptr = oldenviron;
        while (*oldenvptr)
#ifdef  _DEBUG
        {
            if ( (*newenvptr = _malloc_crt((_tcslen(*oldenvptr)+1)
                  * sizeof(_TSCHAR))) != NULL )
                _tcscpy(*newenvptr, *oldenvptr);
            oldenvptr++;
            newenvptr++;
        }
#else   /* ndef _DEBUG */
            *newenvptr++ = _tcsdup(*oldenvptr++);
#endif  /* _DEBUG */

        *newenvptr = NULL;

        return newenviron;
}

#endif  /* POSIX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\seclocf.c ===
/***
*seclocf.c - Report /GS security check failure, local system CRT version
*
*       Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Define function used to report a security check failure.  This
*       version is only used when linking against the system CRT DLL,
*       msvcrt.dll (or msvcrtd.dll).  If that DLL does not export the global
*       failure handler __security_error_handler, then a default local
*       handler is used instead.
*
*       This version does not use any other CRT functions, so it can be used
*       to compile code /GS which does not want to use the CRT.
*
*       Entrypoints:
*       __local_security_error_handler
*
*Revision History:
*       01-24-00  PML   Created.
*       08-30-00  PML   Rename handlers, add extra parameters.  Extensively
*                       rework, moving the GetProcAddress of
*                       __security_error_handler from seccook.c to here.
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
*******************************************************************************/

#if defined(_SYSCRT) && defined(CRTDLL)

#include <windows.h>
#include <stdlib.h>

/*
 * Default messagebox string components
 */

#define PROGINTRO   "Program: "
#define DOTDOTDOT   "..."

#define BOXINTRO_0  "Unknown security failure detected!"
#define MSGTEXT_0   \
    "A security error of unknown cause has been detected which has\n"      \
    "corrupted the program's internal state.  The program cannot safely\n" \
    "continue execution and must now be terminated.\n"

#define BOXINTRO_1  "Buffer overrun detected!"
#define MSGTEXT_1   \
    "A buffer overrun has been detected which has corrupted the program's\n"  \
    "internal state.  The program cannot safely continue execution and must\n"\
    "now be terminated.\n"

#define MAXLINELEN  60 /* max length for line in message box */

/***
*__local_security_error_handler() - Report security error
*
*Purpose:
*       A /GS security error has been detected, and the global failure handler
*       is not available from msvcrt.dll.  Pop up a message box and terminate
*       the program.
*
*Entry:
*       int code - security failure code
*       void *data - code-specific data
*
*Exit:
*       Calls ExitProcess.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __local_security_error_handler(
    int code,
    void *data)
{
    char progname[MAX_PATH + 1];
    char * pch;
    char * outmsg;
    char * boxintro;
    char * msgtext;
    size_t subtextlen;

    HANDLE hCRT;
    _secerr_handler_func pfnSecErrorHandler;
    HANDLE hUser32;
    int (APIENTRY *pfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);

    /*
     * Check if the system CRT DLL implements the process-wide security
     * failure handler, and use it instead if available.
     */
#ifdef  _DEBUG
    hCRT = GetModuleHandle("msvcrtd.dll");
#else
    hCRT = GetModuleHandle("msvcrt.dll");
#endif
    if (hCRT != NULL) {
        pfnSecErrorHandler = (_secerr_handler_func)
                             GetProcAddress(hCRT, "__security_error_handler");
        if (pfnSecErrorHandler != NULL) {
            pfnSecErrorHandler(code, data);
            ExitProcess(3);
        }
    }

    /*
     * DLL-resident handler not available.  Use a local version that just
     * pops up a message box.
     */

    switch (code) {
    default:
        /*
         * Unknown failure code, which probably means an older CRT is
         * being used with a newer compiler.
         */
        boxintro = BOXINTRO_0;
        msgtext = MSGTEXT_0;
        subtextlen = sizeof(BOXINTRO_0) + sizeof(MSGTEXT_0);
        break;
    case _SECERR_BUFFER_OVERRUN:
        /*
         * Buffer overrun detected which may have overwritten a return
         * address.
         */
        boxintro = BOXINTRO_1;
        msgtext = MSGTEXT_1;
        subtextlen = sizeof(BOXINTRO_1) + sizeof(MSGTEXT_1);
        break;
    }

    progname[MAX_PATH] = '\0';
    if (!GetModuleFileName(NULL, progname, MAX_PATH))
        lstrcpy(progname, "<program name unknown>");

    pch = progname;

    /* sizeof(PROGINTRO) includes the NULL terminator */
    if (sizeof(PROGINTRO) + lstrlen(progname) + 1 > MAXLINELEN)
    {
        pch += (sizeof(PROGINTRO) + lstrlen(progname) + 1) - MAXLINELEN;
        CopyMemory(pch, DOTDOTDOT, sizeof(DOTDOTDOT) - 1);
    }

    outmsg = (char *)_alloca(subtextlen - 1 + 2
                             + sizeof(PROGINTRO) - 1
                             + lstrlen(pch)
                             + 2);

    lstrcpy(outmsg, boxintro);
    lstrcat(outmsg, "\n\n");
    lstrcat(outmsg, PROGINTRO);
    lstrcat(outmsg, pch);
    lstrcat(outmsg, "\n\n");
    lstrcat(outmsg, msgtext);

    hUser32 = LoadLibrary("user32.dll");

    if (hUser32 != NULL) {

        pfnMessageBoxA = (int (APIENTRY *)(HWND, LPCSTR, LPCSTR, UINT))
            GetProcAddress(hUser32, "MessageBoxA");

        if (pfnMessageBoxA != NULL) {
            pfnMessageBoxA(
                NULL, 
                outmsg,
                "Microsoft Visual C++ Runtime Library",
                MB_OK|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
        }

        FreeLibrary(hUser32);
    }

    ExitProcess(3);
}

#endif  /* defined(_SYSCRT) && defined(CRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wcserror.c ===
/***
*wcserror.c - Contains the _wcserror C runtime.
*
*	Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The _wcserror runtime accepts an error number as input
*	and returns the corresponding error string.
*	(wide char version of strerror)
*
*Revision History:
*   11-30-99  GB    Module Created
*
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "strerror.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\umask.c ===
/***
*umask.c - set file permission mask
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _umask() - sets file permission mask of current process*
*	affecting files created by creat, open, or sopen.
*
*Revision History:
*	06-02-89  PHG	module created
*	03-16-90  GJF	Made calling type _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	04-05-90  GJF	Added #include <io.h>.
*	10-04-90  GJF	New-style function declarator.
*	01-17-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <io.h>

/***
*int _umask(mode) - set the file mode mask
*
*Purpose:
*	Sets the file-permission mask of the current process* which
*	modifies the permission setting of new files created by creat,
*	open, or sopen.
*
*Entry:
*	int mode - new file permission mask
*		   may contain S_IWRITE, S_IREAD, S_IWRITE | S_IREAD.
*		   The S_IREAD bit has no effect under Win32
*
*Exit:
*	returns the previous setting of the file permission mask.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _umask (
	int mode
	)
{
	register int oldmode;		/* old umask value */

	mode &= 0x180;			/* only user read/write permitted */
	oldmode = _umaskval;		/* remember old value */
	_umaskval = mode;		/* set new value */
	return oldmode; 		/* return old value */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\setlocal.c ===
/***
*setlocal.c - Contains the setlocale function
*
*       Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains the setlocale() function.
*
*Revision History:
*       03-21-89  JCR   Module created.
*       09-25-89  GJF   Fixed copyright. Checked for compatibility with Win 3.0
*       09-25-90  KRS   Major rewrite--support more than "C" locale if _INTL.
*       11-05-91  ETC   Get 09-25-90 working for C and "" locales; separate
*                       setlocal.h; add Init functions.
*       12-05-91  ETC   Separate nlsdata.c; add mt support; remove calls to
*                       itself.
*       12-20-91  ETC   Added _getlocaleinfo api interface function.
*       09-25-92  KRS   Fix for latest NLSAPI changes, etc.
*       01-25-93  KRS   Fix for latest changes, clean up code, etc.
*       02-02-93  CFW   Many modifications and bug fixes (all under _INTL).
*       02-08-93  CFW   Bug fixes and casts to avoid warnings (all under _INTL).
*       02-17-93  CFW   Removed re-call of init() functions in case of failure.
*       03-01-93  CFW   Check GetQualifiedLocale return value.
*       03-02-93  CFW   Added POSIX conformance, check environment variables.
*       03-09-93  CFW   Set CP to CP_ACP when changing to C locale.
*       03-17-93  CFW   Change expand to expandlocale, prepend _ to internal
*                       functions, lots of POSIX fixup.
*       03-23-93  CFW   Add _ to GetQualifiedLocale call.
*       03-24-93  CFW   Change to _get_qualified_locale, support ".codepage".
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-10-93  CFW   Disallow setlocale(LC_*, ".").
*       05-24-93  CFW   Clean up file (brief is evil).
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       02-04-94  CFW   Remove unused param.
*       04-15-94  GJF   Moved prototypes for locale category initialization
*                       functions to setlocal.h. Made definitions for
*                       __lc_category, cacheid, cachecp, cachein and cacheout
*                       conditional on DLL_FOR_WIN32S. Made _clocalestr into
*                       a global for DLL_FOR_WIN32S so that crtlib.c may use
*                       it.
*       09-06-94  CFW   Remove _INTL switch.
*       09-06-94  CFW   Merge non-Win32.
*       01-10-95  CFW   Debug CRT allocs.
*       09-25-95  GJF   New locking scheme for functions which set or 
*                       reference locale information.
*       05-02-96  SKS   Variables _setlc_active and __unguarded_readlc_active
*                       are used by MSVCP42*.DLL and so must be _CRTIMP.
*       07-09-97  GJF   Made __lc_category selectany. Also, removed obsolete
*                       DLL_FOR_WIN32S support.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       02-27-98  RKP   Add 64 bit support.
*       09-10-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-21-98  GJF   No need to lock or update threadlocinfo for setlocale
*                       calls which only read info.
*       11-06-98  GJF   In __lc_strtolc, make sure you don't overflow
*                       names->szCodePage.
*       12-08-98  GJF   Fixed __updatetlocinfo (several errors).
*       01-04-99  GJF   Changes for 64-bit size_t.
*       01-18-99  GJF   In MT models, setlocale needs to check if the old 
*                       __ptlocinfo needs to be freed up. Also, unrelated,
*                       have _setlocale_get_all return NULL if malloc fails.
*       03-02-99  KRS   Partially back out previous fix for now. (per BryanT)
*       03-20-99  GJF   Added more reference counters (restoring fix)
*       04-24-99  PML   Added __lconv_intl_refcount
*       01-26-00  GB    Modified _setlocale_cat. Added _first_127char,
*                       _ctype_loc_style and __lc_clike
*       08-18-00  GB    Fixed problems with __lc_clike stuff.
*       09-06-00  GB    Made pwctype independent of locale.
*       10-12-00  GB    Compared requested locale to current locale for
*                       requested category in setlocale-set_cat. Performance
*                       enhancement.
*       11-05-00  PML   Fixed double-free of __lconv_mon_refcount and
*                       lconv_num_refcount (vs7#181380)
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <locale.h>

#if     !defined(_WIN32) && !defined(_POSIX_)

static char _clocalestr[] = "C";

#else   /* _WIN32/_POSIX_ */

#include <cruntime.h>
#include <mtdll.h>
#include <malloc.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h> /* for strtol */
#include <setlocal.h>
#include <dbgint.h>
#include <ctype.h>
#include <awint.h>

/* C locale */
static char _clocalestr[] = "C";

#ifdef  _POSIX_
static char _posixlocalestr[] = "POSIX";
#endif

#define _LOC_CCACHE 5   // Cache of last 5 locale changed and if they are clike.

__declspec(selectany) struct {
        const char * catname;
        char * locale;
        int (* init)(void);
} __lc_category[LC_MAX-LC_MIN+1] = {
        /* code assumes locale initialization is "_clocalestr" */
        { "LC_ALL",     NULL,           __init_dummy /* never called */ },
        { "LC_COLLATE", _clocalestr,    __init_collate  },
        { "LC_CTYPE",   _clocalestr,    __init_ctype    },
        { "LC_MONETARY",_clocalestr,    __init_monetary },
        { "LC_NUMERIC", _clocalestr,    __init_numeric  },
        { "LC_TIME",    _clocalestr,    __init_time }
};

struct _is_ctype_compatible {
        unsigned long id;
        int is_clike;
};
        /* First 127 character type for CLOCALE */
static const short _ctype_loc_style[] = {
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _SPACE | _CONTROL | _BLANK,
        _SPACE | _CONTROL,
        _SPACE | _CONTROL,
        _SPACE | _CONTROL,
        _SPACE | _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _CONTROL,
        _SPACE | _BLANK,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _DIGIT | _HEX,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _UPPER | _HEX | C1_ALPHA,
        _UPPER | _HEX | C1_ALPHA,
        _UPPER | _HEX | C1_ALPHA,
        _UPPER | _HEX | C1_ALPHA,
        _UPPER | _HEX | C1_ALPHA,
        _UPPER | _HEX | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _UPPER | C1_ALPHA,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _LOWER | _HEX | C1_ALPHA,
        _LOWER | _HEX | C1_ALPHA,
        _LOWER | _HEX | C1_ALPHA,
        _LOWER | _HEX | C1_ALPHA,
        _LOWER | _HEX | C1_ALPHA,
        _LOWER | _HEX | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _LOWER | C1_ALPHA,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _PUNCT,
        _CONTROL
};

static const char _first_127char[] = {
        1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17,
        18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
        69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
        86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100,101,102,
        103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
        120,121,122,123,124,125,126,127
};

#ifdef  _MT

extern unsigned short *__ctype1;                /* defined in initctyp.c */
extern struct __lc_time_data __lc_time_c;       /* defined in strftime.c */
extern struct __lc_time_data *__lc_time_curr;   /* defined in strftime.c */
extern struct __lc_time_data *__lc_time_intl;   /* defined in inittime.c */

/*
 * initial locale information struct, set to the C locale. Used only until the
 * first call to setlocale()
 */
threadlocinfo __initiallocinfo = {
        1,                  /* refcount            */
        _CLOCALECP,         /* lc_codepage         */
        _CLOCALECP,         /* lc_collate_cp       */
        { _CLOCALEHANDLE,   /* lc_handle[6]        */
          _CLOCALEHANDLE,
          _CLOCALEHANDLE,
          _CLOCALEHANDLE,
          _CLOCALEHANDLE,
          _CLOCALEHANDLE },
        1,                  /* lc_clike            */
        1,                  /* mb_cur_max          */
        NULL,               /* lconv_intl_refcount */
        NULL,               /* lconv_num_refcount  */
        NULL,               /* lconv_mon_refcount  */
        &__lconv_c,         /* lconv               */
        NULL,               /* lconv_intl          */
        NULL,               /* ctype1_refcount     */
        NULL,               /* ctype1              */
        _ctype + 1,         /* pctype              */
        &__lc_time_c,       /* lc_time_curr        */
        NULL                /* lc_time_intl        */
};

/* 
 * global pointer to the current per-thread locale information structure.
 */
pthreadlocinfo __ptlocinfo = &__initiallocinfo;

/*
 * Flag indicating whether or not setlocale() is active. Its value is the 
 * number of setlocale() calls currently active.
 */
_CRTIMP int __setlc_active;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___setlc_active_func(void)
{
    return __setlc_active;
}

/*
 * Flag indicating whether or not a function which references the locale
 * without having locked it is active. Its value is the number of such
 * functions. 
 */
_CRTIMP int __unguarded_readlc_active;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int * __cdecl ___unguarded_readlc_active_add_func(void)
{
    return &__unguarded_readlc_active;
}

#endif  /* _MT */

/* helper function prototypes */
char * _expandlocale(char *, char *, LC_ID *, UINT *, int);
void _strcats(char *, int, ...);
void __lc_lctostr(char *, const LC_STRINGS *);
int __lc_strtolc(LC_STRINGS *, const char *);
static char * __cdecl _setlocale_set_cat(int, const char *);
static char * __cdecl _setlocale_get_all(void);

#ifdef  _MT
extern int * __lconv_intl_refcount;
extern int * __lconv_num_refcount;
extern int * __lconv_mon_refcount;
extern int * __ctype1_refcount;
static pthreadlocinfo __cdecl __updatetlocinfo_lk(void);
static char * __cdecl _setlocale_lk(int, const char *);
void __cdecl __free_lconv_mon(struct lconv *);
void __cdecl __free_lconv_num(struct lconv *);
void __cdecl __free_lc_time(struct __lc_time_data *);
#endif

#endif  /* _WIN32/_POSIX_ */


#ifdef  _MT

/***
*__freetlocinfo() - free threadlocinfo
*
*Purpose:
*       Free up the per-thread locale info structure specified by the passed
*       pointer.
*
*Entry:
*       pthreadlocinfo ptloci
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __freetlocinfo (
        pthreadlocinfo ptloci
        )
{
        /*
         * Free up lconv struct
         */
        if ( (ptloci->lconv_intl != __lconv_intl) && 
             (ptloci->lconv_intl != NULL) &&
             (*(ptloci->lconv_intl_refcount) == 0))
        {
            if ( (ptloci->lconv_mon_refcount != NULL) &&
                 (*(ptloci->lconv_mon_refcount) == 0) &&
                 (ptloci->lconv_mon_refcount != __lconv_mon_refcount) )
            {
                _free_crt(ptloci->lconv_mon_refcount);
                __free_lconv_mon(ptloci->lconv_intl);
            }

            if ( (ptloci->lconv_num_refcount != NULL) &&
                 (*(ptloci->lconv_num_refcount) == 0) &&
                 (ptloci->lconv_num_refcount != __lconv_num_refcount) )
            {
                _free_crt(ptloci->lconv_num_refcount);
                __free_lconv_num(ptloci->lconv_intl);
            }

            _free_crt(ptloci->lconv_intl_refcount);
            _free_crt(ptloci->lconv_intl);
        }

        /*
         * Free up ctype tables
         */
        if ( (ptloci->ctype1_refcount != __ctype1_refcount) &&
             (ptloci->ctype1_refcount != NULL) &&
             (*(ptloci->ctype1_refcount) == 0) )
        {
            _free_crt(ptloci->ctype1_refcount);
            _free_crt(ptloci->ctype1);
        }

        /*
         * Free up the __lc_time_data struct
         */
        if ( (ptloci->lc_time_intl != __lc_time_intl) &&
             (ptloci->lc_time_intl != NULL) &&
             ((ptloci->lc_time_intl->refcount) == 0) )
        {
            __free_lc_time(ptloci->lc_time_intl);
            _free_crt(ptloci->lc_time_intl);
        }

        /*
         * Free up the threadlocinfo struct
         */
        _free_crt(ptloci);
}


/***
*__updatetlocinfo() - refresh the thread's locale info
*
*Purpose:
*       Update the current thread's reference to the locale information to
*       match the current global locale info. Decrement the reference on the
*       old locale information struct and if this count is now zero (so that no
*       threads are using it), free it.
*
*Entry:
*
*Exit:
*       _getptd()->ptlocinfo == __ptlocinfo
*
*Exceptions:
*
*******************************************************************************/

pthreadlocinfo __cdecl __updatetlocinfo(void)
{
        pthreadlocinfo ptloci;

        _mlock(_SETLOCALE_LOCK);
        __try 
        {
            ptloci = __updatetlocinfo_lk();
        }
        __finally
        {
            _munlock(_SETLOCALE_LOCK);
        }

        return ptloci;
}

static pthreadlocinfo __cdecl __updatetlocinfo_lk(void)
{
        pthreadlocinfo ptloci;
        _ptiddata ptd = _getptd();

        if ( (ptloci = ptd->ptlocinfo) != __ptlocinfo )
        {
            /*
             * Decrement the reference counts in the old locale info
             * structure.
             */
            if ( ptloci != NULL )
            {
                (ptloci->refcount)--;

                if ( ptloci->lconv_intl_refcount != NULL )
                    (*(ptloci->lconv_intl_refcount))--;

                if ( ptloci->lconv_mon_refcount != NULL )
                    (*(ptloci->lconv_mon_refcount))--;

                if ( ptloci->lconv_num_refcount != NULL )
                    (*(ptloci->lconv_num_refcount))--;

                if ( ptloci->ctype1_refcount != NULL )
                    (*(ptloci->ctype1_refcount))--;

                (ptloci->lc_time_curr->refcount)--;
            }

            /*
             * Update to the current locale info structure and increment the
             * reference counts.
             */
            ptd->ptlocinfo = __ptlocinfo;
            (__ptlocinfo->refcount)++;

            if ( __ptlocinfo->lconv_intl_refcount != NULL )
                (*(__ptlocinfo->lconv_intl_refcount))++;

            if ( __ptlocinfo->lconv_mon_refcount != NULL )
                (*(__ptlocinfo->lconv_mon_refcount))++;

            if ( __ptlocinfo->lconv_num_refcount != NULL )
                (*(__ptlocinfo->lconv_num_refcount))++;

            if ( __ptlocinfo->ctype1_refcount != NULL )
                (*(__ptlocinfo->ctype1_refcount))++;

            (__ptlocinfo->lc_time_curr->refcount)++;

            /*
             * Free the old locale info structure, if necessary.  Must be done
             * after incrementing reference counts in current locale in case
             * any refcounts are shared with the old locale.
             */
            if ( (ptloci != NULL) &&
                 (ptloci->refcount == 0) &&
                 (ptloci != &__initiallocinfo) )
                __freetlocinfo(ptloci);
        }

        return ptd->ptlocinfo;
}

#endif


/***
*char * setlocale(int category, char *locale) - Set one or all locale categories
*
*Purpose:
*       The setlocale() routine allows the user to set one or more of
*       the locale categories to the specific locale selected by the
*       user.  [ANSI]
*
*       NOTE: Under !_INTL, the C libraries only support the "C" locale.
*       Attempts to change the locale will fail.
*
*Entry:
*       int category = One of the locale categories defined in locale.h
*       char *locale = String identifying a specific locale or NULL to
*                  query the current locale.
*
*Exit:
*       If supplied locale pointer == NULL:
*
*           Return pointer to current locale string and do NOT change
*           the current locale.
*
*       If supplied locale pointer != NULL:
*
*           If locale string is '\0', set locale to default.
*
*           If desired setting can be honored, return a pointer to the
*           locale string for the appropriate category.
*
*           If desired setting can NOT be honored, return NULL.
*
*Exceptions:
*       Compound locale strings of the form "LC_COLLATE=xxx;LC_CTYPE=xxx;..."
*       are allowed for the LC_ALL category.  This is to support the ability
*       to restore locales with the returned string, as specified by ANSI.
*       Setting the locale with a compound locale string will succeed unless
*       *all* categories failed.  The returned string will reflect the current
*       locale.  For example, if LC_CTYPE fails in the above string, setlocale
*       will return "LC_COLLATE=xxx;LC_CTYPE=yyy;..." where yyy is the
*       previous locale (or the C locale if restoring the previous locale
*       also failed).  Unrecognized LC_* categories are ignored.
*
*******************************************************************************/

#if     !defined(_WIN32) && !defined(_POSIX_) /* trivial ANSI support */

char * __cdecl setlocale (
        int _category,
        const char *_locale
        )
{
        if ( (_locale == NULL) ||
             (_locale[0] == '\0') ||
             ( (_locale[0]=='C') && (_locale[1]=='\0'))  )
            return(_clocalestr);
        else
            return(NULL);
}

#else   /* _WIN32/_POSIX_ */

char * __cdecl setlocale (
        int _category,
        const char *_locale
        )
{
        char * retval;
#ifdef  _MT
        pthreadlocinfo ptloci;
        int i;

        /* Validate category */
        if ( (_category < LC_MIN) || (_category > LC_MAX) )
            return NULL;

        if ( _locale == NULL  )
            return _setlocale_lk(_category, NULL);

        _mlock(_SETLOCALE_LOCK);

        __try {

            if ( (ptloci = _malloc_crt( sizeof(threadlocinfo) )) == NULL )
                retval = NULL;

            if ( (ptloci != NULL) && (retval = _setlocale_lk(_category, _locale)) )
            {
                ptloci->refcount = 0;
                ptloci->lc_codepage = __lc_codepage;
                ptloci->lc_collate_cp = __lc_collate_cp;

                for ( i = 0 ; i <= LC_MAX - LC_MIN ; i++ )
                    ptloci->lc_handle[i] = __lc_handle[i];

                ptloci->lc_clike = __lc_clike;
                ptloci->mb_cur_max = __mb_cur_max;

                ptloci->lconv_intl_refcount = __lconv_intl_refcount;
                ptloci->lconv_num_refcount = __lconv_num_refcount;
                ptloci->lconv_mon_refcount = __lconv_mon_refcount;
                ptloci->lconv = __lconv;
                ptloci->lconv_intl = __lconv_intl;

                ptloci->ctype1_refcount = __ctype1_refcount;
                ptloci->ctype1 = __ctype1;
                ptloci->pctype = _pctype;

                ptloci->lc_time_curr = __lc_time_curr;
                ptloci->lc_time_intl = __lc_time_intl;

                if ( (__ptlocinfo->refcount == 0) &&
                     (__ptlocinfo != &__initiallocinfo) )
                     __freetlocinfo(__ptlocinfo);

                __ptlocinfo = ptloci;

                (void)__updatetlocinfo_lk();
            }

            if ( (retval == NULL) && (ptloci != NULL) )
                _free_crt(ptloci);

        }
        __finally {
            _munlock(_SETLOCALE_LOCK);
        }

        return retval;
}

static char * __cdecl _setlocale_lk(
        int _category,
        const char *_locale
        )
{
        char * retval;
#else
        /* Validate category */
        if ((_category < LC_MIN) || (_category > LC_MAX))
            return NULL;
#endif
        /* Interpret locale */

        if (_category != LC_ALL)
        {
            retval = (_locale) ? _setlocale_set_cat(_category,_locale) :
                __lc_category[_category].locale;

        } else { /* LC_ALL */
            char lctemp[MAX_LC_LEN];
            int i;
            int same = 1;
            int fLocaleSet = 0; /* flag to indicate if anything successfully set */

            if (_locale != NULL)
            {
                if ( (_locale[0]=='L') && (_locale[1]=='C') && (_locale[2]=='_') )
                {
                    /* parse compound locale string */
                    size_t len;
                    const char * p = _locale;  /* start of string to parse */
                    const char * s;

                    do {
                        s = strpbrk(p,"=;");

                        if ((s==(char *)NULL) || (!(len=(size_t)(s-p))) || (*s==';'))
                            return NULL;  /* syntax error */

                        /* match with known LC_ strings, if possible, else ignore */
                        for (i=LC_ALL+1; i<=LC_MAX; i++)
                        {
                            if ((!strncmp(__lc_category[i].catname,p,len))
                                && (len==strlen(__lc_category[i].catname)))
                            {
                                break;  /* matched i */
                            }
                        } /* no match if (i>LC_MAX) -- just ignore */

                        if ((!(len = strcspn(++s,";"))) && (*s!=';'))
                            return NULL;  /* syntax error */

                        if (i<=LC_MAX)
                        {
                            strncpy(lctemp, s, len);
                            lctemp[len]='\0';   /* null terminate string */

                            /* don't fail unless all categories fail */
                            if (_setlocale_set_cat(i,lctemp))
                                fLocaleSet++;       /* record a success */
                        }
                        if (*(p = s+len)!='\0')
                            p++;  /* skip ';', if present */

                    } while (*p);

                    retval = (fLocaleSet) ? _setlocale_get_all() : NULL;

                } else { /* simple LC_ALL locale string */

                    /* confirm locale is supported, get expanded locale */
                    if (retval = _expandlocale((char *)_locale, lctemp, NULL, NULL, _category))
                    {
                        for (i=LC_MIN; i<=LC_MAX; i++)
                        {
                            if (i!=LC_ALL)
                            {
                                if (strcmp(lctemp, __lc_category[i].locale))
                                {
                                    if (_setlocale_set_cat(i, lctemp))
                                    {
                                        fLocaleSet++;   /* record a success */
                                    }
                                    else
                                    {
                                        same = 0;       /* record a failure */
                                    }
                                }
                                else
                                    fLocaleSet++;   /* trivial succcess */
                            }
                        }
#ifdef  _POSIX_
                        /* special case for POSIX - since LC_ALL expands,
                            one LC_ALL call may set many different categories,
                            must assume not same, get full string */
                        same = 0;
#endif
                        if (same) /* needn't call setlocale_get_all() if all the same */
                        {
                            retval = _setlocale_get_all();
                            /* retval set above */
                            _free_crt(__lc_category[LC_ALL].locale);
                            __lc_category[LC_ALL].locale = NULL;
                        }
                        else
                            retval = (fLocaleSet) ? _setlocale_get_all() : NULL;
                    }
                }
            } else { /* LC_ALL & NULL */
                retval = _setlocale_get_all ();
            }
        }

        /* common exit point */
        return retval;

} /* setlocale */


static char * __cdecl _setlocale_set_cat (
        int category,
        const char * locale
        )
{
        char * oldlocale;
        LCID oldhandle;
        UINT oldcodepage;
        LC_ID oldid;

        LC_ID idtemp;
        UINT cptemp;
        char lctemp[MAX_LC_LEN];
        char * pch;
        
        static struct _is_ctype_compatible _Lcid_c[_LOC_CCACHE] = {{0,1}};
        struct _is_ctype_compatible buf1, buf2;
        int i;
        short out[sizeof(_first_127char)];

        if (!_expandlocale((char *)locale, lctemp, &idtemp, &cptemp, category))
        {
            return NULL;            /* unrecognized locale */
        }
        if (!strcmp(lctemp, __lc_category[category].locale))
        {
            return __lc_category[category].locale;
        }

        if (!(pch = (char *)_malloc_crt(strlen(lctemp)+1)))
        {
            return NULL;  /* error if malloc fails */
        }

        oldlocale = __lc_category[category].locale; /* save for possible restore*/
        oldhandle = __lc_handle[category];
        memcpy((void *)&oldid, (void *)&__lc_id[category], sizeof(oldid));
        oldcodepage = __lc_codepage;

        /* update locale string */
        __lc_category[category].locale = strcpy(pch,lctemp);
        __lc_handle[category] = MAKELCID(idtemp.wLanguage, SORT_DEFAULT);
        memcpy((void *)&__lc_id[category], (void *)&idtemp, sizeof(idtemp));

        /* To speedup locale based comparisions, we identify if the current
         * local has first 127 character set same as CLOCALE. If yes then
         * __lc_clike = TRUE. Also we keep this info. in a cache of cache
         * size = _LOC_CCACHE, so that every time the locale is switched, we
         * don't have to call time consuming GetStringTypeA.
         */

        if (category==LC_CTYPE)
        {
            __lc_codepage = cptemp;
            buf1 = _Lcid_c[_LOC_CCACHE -1];
            /* brings the recently used codepage to the top. or else shifts
             * every thing down by one so that new _Lcid_c can be placed at
             * the top.
             */
            for ( i = 0; i < _LOC_CCACHE; i++)
            {
                if (__lc_codepage == _Lcid_c[i].id)
                {
                    _Lcid_c[0] = _Lcid_c[i];
                    _Lcid_c[i] = buf1;
                    break;
                }
                else
                {
                    buf2 = _Lcid_c[i];
                    _Lcid_c[i] = buf1;
                    buf1 = buf2;
                }
            }
            if ( i == _LOC_CCACHE)
            {
                if ( __crtGetStringTypeA(CT_CTYPE1,
                                          _first_127char,
                                          sizeof(_first_127char),
                                          out,
                                          __lc_codepage,
                                          __lc_handle[LC_CTYPE],
                                          TRUE ))
                {
                    if ( !memcmp(out, _ctype_loc_style, sizeof(_ctype_loc_style)))
                        _Lcid_c[0].is_clike = TRUE;
                    else
                        _Lcid_c[0].is_clike = FALSE;
                }
                else
                    _Lcid_c[0].is_clike = FALSE;
                _Lcid_c[0].id = __lc_codepage;
            }
            __lc_clike = _Lcid_c[0].is_clike;
        }

        if ( category == LC_COLLATE )
            __lc_collate_cp = cptemp;

        if (__lc_category[category].init())
        {
            /* restore previous state! */
            __lc_category[category].locale = oldlocale;
            _free_crt(pch);
            __lc_handle[category] = oldhandle;
            __lc_codepage = oldcodepage;

            return NULL; /* error if non-zero return */
        }

        /* locale set up successfully */
        /* Cleanup */
        if ((oldlocale != _clocalestr)
#ifdef  _POSIX_
            && (oldlocale!=_posixlocalestr)
#endif
            )
            _free_crt(oldlocale);

        return __lc_category[category].locale;

} /* _setlocale_set_cat */



static char * __cdecl _setlocale_get_all (
        void
        )
{
        int i;
        int same = 1;
        /* allocate memory if necessary */
        if ( (__lc_category[LC_ALL].locale == NULL) &&
             ((__lc_category[LC_ALL].locale =
               _malloc_crt((MAX_LC_LEN+1) * (LC_MAX-LC_MIN+1) + CATNAMES_LEN))
               == NULL) )
            return NULL;

        __lc_category[LC_ALL].locale[0] = '\0';
        for (i=LC_MIN+1; ; i++)
        {
            _strcats(__lc_category[LC_ALL].locale, 3, __lc_category[i].catname,"=",__lc_category[i].locale);
            if (i<LC_MAX)
            {
                strcat(__lc_category[LC_ALL].locale,";");
                if (strcmp(__lc_category[i].locale, __lc_category[i+1].locale))
                    same=0;
            }
            else
            {
                if (!same)
                    return __lc_category[LC_ALL].locale;
                else
                {
                    _free_crt(__lc_category[LC_ALL].locale);
                    __lc_category[LC_ALL].locale = (char *)NULL;
                    return __lc_category[LC_CTYPE].locale;
                }
            }
        }
} /* _setlocale_get_all */


char * _expandlocale (
        char *expr,
        char * output,
        LC_ID * id,
        UINT * cp,
        int category
        )
{
        static  LC_ID   cacheid = {0, 0, 0};
        static  UINT    cachecp = 0;
        static  char cachein[MAX_LC_LEN] = "C";
        static  char cacheout[MAX_LC_LEN] = "C";

        if (!expr)
            return NULL; /* error if no input */

#ifdef  _POSIX_
        if (!*expr)
        {
            /* POSIX: when locale=="", look first at the environment variables:
               1) use LC_ALL EV if defined and not null (LC_ALL expands to LC_*)
               2) use EV that matches category and is not null
               3) use LANG EV if defined and not null
               otherwise, we fall through to get system default */

            char *envar;

            if (category == LC_ALL && (envar = getenv("LC_ALL")))
            {
                if (!*envar)
                {
                    /* LC_ALL expands to LC_*, set output to "", each category will be
                       expanded individually */
                    *output = '\0';
                    return output;
                }
                else {
                    expr = envar;
                }
            }
            else {
                if ((envar = getenv(__lc_category[category].catname)) && *envar ||
                    (envar = getenv("LANG")) && *envar)
                {
                    expr = envar;
                }
            }
        }
#endif  /* _POSIX_ */

        if (((*expr=='C') && (!expr[1]))
#ifdef  _POSIX_
            || (!strcmp(expr, _posixlocalestr))
#endif
            )  /* for "C" locale, just return */
        {
#ifdef  _POSIX_
            strcpy(output, _posixlocalestr);
#else
            *output = 'C';
            output[1] = '\0';
#endif
            if (id)
            {
                id->wLanguage = 0;
                id->wCountry  = 0;
                id->wCodePage = 0;
            }
            if (cp)
            {
                *cp = CP_ACP; /* return to ANSI code page */
            }
            return output; /* "C" */
        }

        /* first, make sure we didn't just do this one */
        if (strcmp(cacheout,expr) && strcmp(cachein,expr))
        {
            /* do some real work */
            LC_STRINGS names;

            if (__lc_strtolc((LC_STRINGS *)&names, (const char *)expr))
                return NULL;  /* syntax error */

            if (!__get_qualified_locale((LPLC_STRINGS)&names,
                (LPLC_ID)&cacheid, (LPLC_STRINGS)&names))
                return NULL;    /* locale not recognized/supported */

            /* begin: cache atomic section */

            cachecp = cacheid.wCodePage;

            __lc_lctostr((char *)cacheout, &names);

            /* Don't cache "" empty string */
            if (*expr)
                strcpy(cachein, expr);
            else
                strcpy(cachein, cacheout);

            /* end: cache atomic section */
        }
        if (id)
            memcpy((void *)id, (void *)&cacheid, sizeof(cacheid));   /* possibly return LC_ID */
        if (cp)
            memcpy((void *)cp, (void *)&cachecp, sizeof(cachecp));   /* possibly return cp */

        strcpy(output,cacheout);
        return cacheout; /* return fully expanded locale string */
}

/* helpers */

int __cdecl __init_dummy(void)  /* default routine for locale initializer */
{
        return 0;
}

void _strcats
        (
        char *outstr,
        int n,
        ...
        )
{
        int i;
        va_list substr;

        va_start (substr, n);

        for (i =0; i<n; i++)
        {
            strcat(outstr, va_arg(substr, char *));
        }
        va_end(substr);
}

int __lc_strtolc
   (
   LC_STRINGS *names,
   const char *locale
   )
{
        int i;
        size_t len;
        char ch;

        memset((void *)names, '\0', sizeof(LC_STRINGS));  /* clear out result */

        if (*locale=='\0')
            return 0; /* trivial case */

        /* only code page is given */
        if (locale[0] == '.' && locale[1] != '\0')
        {
            strcpy((char *)names->szCodePage, &locale[1]);
            return 0;
        }

        for (i=0; ; i++)
        {
            if (!(len=strcspn(locale,"_.,")))
                return -1;  /* syntax error */

            ch = locale[len];

            if ((i==0) && (len<MAX_LANG_LEN) && (ch!='.'))
                strncpy((char *)names->szLanguage, locale, len);

            else if ((i==1) && (len<MAX_CTRY_LEN) && (ch!='_'))
                strncpy((char *)names->szCountry, locale, len);

            else if ((i==2) && (len<MAX_CP_LEN) && (ch=='\0' || ch==','))
                strncpy((char *)names->szCodePage, locale, len);

            else
                return -1;  /* error parsing locale string */

            if (ch==',')
            {
                /* modifier not used in current implementation, but it
                   must be parsed to for POSIX/XOpen conformance */
            /*  strncpy(names->szModifier, locale, MAX_MODIFIER_LEN-1); */
                break;
            }

            if (!ch)
                break;
            locale+=(len+1);
        }
        return 0;
}

void __lc_lctostr
(
        char *locale,
        const LC_STRINGS *names
        )
{
        strcpy(locale, (char *)names->szLanguage);
        if (*(names->szCountry))
            _strcats(locale, 2, "_", names->szCountry);
        if (*(names->szCodePage))
            _strcats(locale, 2, ".", names->szCodePage);
/*      if (names->szModifier)
        _strcats(locale, 2, ",", names->szModifier); */
}


#endif /* _WIN32/_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wgetenv.c ===
/***
*wgetenv.c - get the value of an environment variable (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wgetenv() - searches the environment for a string variable
*	and returns the value of it.
*
*Revision History:
*	11-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "getenv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\splitpat.c ===
/***
*splitpath.c - break down path name into components
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To provide support for accessing the individual components of an
*       arbitrary path name
*
*Revision History:
*       06-14-87  DFW   initial implementation
*       09-23-87  JCR   Removed 'const' from declarations (fixed cl warnings)
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed indents, copyright. Added const attribute to
*                       type of path.
*       03-15-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       07-25-90  SBM   Removed redundant include (stdio.h), replaced local
*                       MIN macro with standard min macro
*       10-04-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       11-20-92  KRS   Port _MBCS support from 16-bit tree.
*       05-12-93  KRS   Add fix for MBCS max path handling.
*       12-07-93  CFW   Wide char enable.
*       10-15-95  BWT   _NTSUBSET_ doesn't do MBCS here.
*       09-09-96  JWM   Test length of input string before accessing (Orion 7985).
*       04-28-98  GJF   No more _ISLEADBYTE macro.
*
*******************************************************************************/

#ifdef _NTSUBSET_
#undef _MBCS
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <string.h>
#ifdef _MBCS
#include <mbstring.h>
#include <mbctype.h>
#include <mbdata.h>
#endif
#include <tchar.h>

/***
*_splitpath() - split a path name into its individual components
*
*Purpose:
*       to split a path name into its individual components
*
*Entry:
*       path  - pointer to path name to be parsed
*       drive - pointer to buffer for drive component, if any
*       dir   - pointer to buffer for subdirectory component, if any
*       fname - pointer to buffer for file base name component, if any
*       ext   - pointer to buffer for file name extension component, if any
*
*Exit:
*       drive - pointer to drive string.  Includes ':' if a drive was given.
*       dir   - pointer to subdirectory string.  Includes leading and trailing
*           '/' or '\', if any.
*       fname - pointer to file base name
*       ext   - pointer to file extension, if any.  Includes leading '.'.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _tsplitpath (
        register const _TSCHAR *path,
        _TSCHAR *drive,
        _TSCHAR *dir,
        _TSCHAR *fname,
        _TSCHAR *ext
        )
{
        register _TSCHAR *p;
        _TSCHAR *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((_tcslen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == _T(':'))) {
            if (drive) {
                _tcsncpy(drive, path, _MAX_DRIVE - 1);
                *(drive + _MAX_DRIVE-1) = _T('\0');
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = _T('\0');
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (_TSCHAR *)path; *p; p++) {
#ifdef _MBCS
            if (_ismbblead(*p))
                p++;
            else {
#endif
            if (*p == _T('/') || *p == _T('\\'))
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == _T('.'))
                dot = p;
#ifdef _MBCS
            }
#endif
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = __min((unsigned)(((char *)last_slash - (char *)path) / sizeof(_TSCHAR)),
                    (_MAX_DIR - 1));
                _tcsncpy(dir, path, len);
                *(dir + len) = _T('\0');
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = _T('\0');
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = __min((unsigned)(((char *)dot - (char *)path) / sizeof(_TSCHAR)),
                    (_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = __min((unsigned)(((char *)p - (char *)dot) / sizeof(_TSCHAR)),
                    (_MAX_EXT - 1));
                _tcsncpy(ext, dot, len);
                *(ext + len) = _T('\0');
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = __min((unsigned)(((char *)p - (char *)path) / sizeof(_TSCHAR)),
                    (_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            if (ext) {
                *ext = _T('\0');
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\strerror.c ===
/***
*strerror.c - Contains the strerror C runtime.
*
*	Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The strerror runtime accepts an error number as input
*	and returns the corresponding error string.
*
*	NOTE: The "old" strerror C runtime resides in file _strerr.c
*	and is now called _strerror.  The new strerror runtime
*	conforms to the ANSI standard.
*
*Revision History:
*	02-24-87  JCR	Module created.
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	01-04-87  JCR	Improved code.
*	01-05-87  JCR	Multi-thread support
*	05-31-88  PHG	Merge DLL and normal versions
*	06-06-89  JCR	386 mthread support
*	03-16-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	10-04-90  GJF	New-style function declarator.
*	07-18-91  GJF	Multi-thread support for Win32 [_WIN32_].
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	09-06-94  CFW	Remove Cruiser support.
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	01-10-95  CFW	Debug CRT allocs.
*	11-24-99  GB    Added support for wide char by adding wcserror()
*
*******************************************************************************/

#include <cruntime.h>
#include <errmsg.h>
#include <stdlib.h>
#include <syserr.h>
#include <string.h>
#include <mtdll.h>
#include <tchar.h>
#ifdef _MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <dbgint.h>

/* [NOTE: The _MT error message buffer is shared by both strerror
   and _strerror so must be the max length of both. */
#ifdef	_MT
/* Max length of message = user_string(94)+system_string+2 */
#define _ERRMSGLEN_ 94+_SYS_MSGMAX+2
#else
/* Max length of message = system_string+2 */
#define _ERRMSGLEN_ _SYS_MSGMAX+2
#endif

#ifdef _UNICODE
#define _terrmsg    _werrmsg
#else
#define _terrmsg    _errmsg
#endif

/***
*char *strerror(errnum) - Map error number to error message string.
*
*Purpose:
*	The strerror runtime takes an error number for input and
*	returns the corresponding error message string.  This routine
*	conforms to the ANSI standard interface.
*
*Entry:
*	int errnum - Integer error number (corresponding to an errno value).
*
*Exit:
*	char * - Strerror returns a pointer to the error message string.
*	This string is internal to the strerror routine (i.e., not supplied
*	by the user).
*
*Exceptions:
*	None.
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * cdecl _wcserror(
#else
char * __cdecl strerror (
#endif
	int errnum
	)
{
#ifdef	_MT

	_ptiddata ptd = _getptd();

	_TCHAR *errmsg;
	static _TCHAR errmsg_backup[_SYS_MSGMAX+2];

#else

	static _TCHAR errmsg[_ERRMSGLEN_];  /* Longest errmsg + \0 */

#endif

#ifdef	_MT

	if ( (ptd->_terrmsg == NULL) && ((ptd->_terrmsg =
            _malloc_crt(_ERRMSGLEN_ * sizeof(_TCHAR)))
	    == NULL) )
		errmsg = errmsg_backup; /* error: use backup */
	else
		errmsg = ptd->_terrmsg;

#endif
#ifdef _UNICODE
    mbstowcs(errmsg, _sys_err_msg(errnum), _ERRMSGLEN_);
#else
	strcpy(errmsg, _sys_err_msg(errnum));
#endif
	return(errmsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\syserr.c ===
/***
*syserr.c - system error list
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the System Error List, containing the full messages for
*       all errno values set by the library routines.
*       Defines sys_errlist, sys_nerr.
*
*Revision History:
*       08-07-87  PHG   removed obsolete definition of sys_msgmax.
*       04-06-90  GJF   Added #include <cruntime.h>. Also, fixed the copyright.
*       01-21-91  GJF   ANSI naming.
*       07-11-91  JCR   Changed "core" to "memory" in ENOMEM message
*       01-23-92  GJF   Added #include <stdlib.h> (contains decl of sys_nerr).
*       09-30-92  GJF   Made POSIX compatible. Non-POSIX errno values are
*                       mapped to "Unknown error" for now. Next step is to
*                       delete these and renumber to eliminate the gaps, after
*                       the beta release.
*       04-08-93  CFW   Added EILSEQ (42) message.
*       02-22-95  CFW   Mac merge.
*       06-14-95  CFW   Change "Error 0" to "No Error" for Mac.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#ifdef _WIN32

char *_sys_errlist[] =
{
    /*  0              */  "No error",
    /*  1 EPERM        */  "Operation not permitted",
    /*  2 ENOENT       */  "No such file or directory",
    /*  3 ESRCH        */  "No such process",
    /*  4 EINTR        */  "Interrupted function call",
    /*  5 EIO          */  "Input/output error",
    /*  6 ENXIO        */  "No such device or address",
    /*  7 E2BIG        */  "Arg list too long",
    /*  8 ENOEXEC      */  "Exec format error",
    /*  9 EBADF        */  "Bad file descriptor",
    /* 10 ECHILD       */  "No child processes",
    /* 11 EAGAIN       */  "Resource temporarily unavailable",
    /* 12 ENOMEM       */  "Not enough space",
    /* 13 EACCES       */  "Permission denied",
    /* 14 EFAULT       */  "Bad address",
    /* 15 ENOTBLK      */  "Unknown error",                     /* not POSIX */
    /* 16 EBUSY        */  "Resource device",
    /* 17 EEXIST       */  "File exists",
    /* 18 EXDEV        */  "Improper link",
    /* 19 ENODEV       */  "No such device",
    /* 20 ENOTDIR      */  "Not a directory",
    /* 21 EISDIR       */  "Is a directory",
    /* 22 EINVAL       */  "Invalid argument",
    /* 23 ENFILE       */  "Too many open files in system",
    /* 24 EMFILE       */  "Too many open files",
    /* 25 ENOTTY       */  "Inappropriate I/O control operation",
    /* 26 ETXTBSY      */  "Unknown error",                     /* not POSIX */
    /* 27 EFBIG        */  "File too large",
    /* 28 ENOSPC       */  "No space left on device",
    /* 29 ESPIPE       */  "Invalid seek",
    /* 30 EROFS        */  "Read-only file system",
    /* 31 EMLINK       */  "Too many links",
    /* 32 EPIPE        */  "Broken pipe",
    /* 33 EDOM         */  "Domain error",
    /* 34 ERANGE       */  "Result too large",
    /* 35 EUCLEAN      */  "Unknown error",                     /* not POSIX */
    /* 36 EDEADLK      */  "Resource deadlock avoided",
    /* 37 UNKNOWN      */  "Unknown error",
    /* 38 ENAMETOOLONG */  "Filename too long",
    /* 39 ENOLCK       */  "No locks available",
    /* 40 ENOSYS       */  "Function not implemented",
    /* 41 ENOTEMPTY    */  "Directory not empty",
    /* 42 EILSEQ       */  "Illegal byte sequence",
    /* 43              */  "Unknown error"

};

#else /* _WIN32 */

#error ERROR - ONLY WIN32 TARGET SUPPORTED!

#endif /* _WIN32 */                

int _sys_nerr = sizeof( _sys_errlist ) / sizeof( _sys_errlist[ 0 ] ) - 1;

/* The above array contains all the errors including unknown error # 37
   which is used if msg_num is unknown */


/* ***NOTE: Parameter _SYS_MSGMAX (in file syserr.h) indicates the length of
   the longest systerm error message in the above table.  When you add or
   modify a message, you must update the value _SYS_MSGMAX, if appropriate. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wmakepat.c ===
/***
*wmakepth.c - create path name from components (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	To provide support for creation of full path names from components
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "makepath.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wgetpath.c ===
/***
*wgetpath.c - extract a pathname from an environment variable (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Extract pathnames from a string of semicolon delimited pathnames
*	(generally the value of an environment variable such as PATH).
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "getpath.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\winxfltr.c ===
/***
*winxfltr.c - startup exception filter
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _XcptFilter(), the function called by the exception filter
*       expression in the startup code.
*
*Revision History:
*       10-31-91  GJF   Module created. Copied from the original xcptfltr.c
*                       then extensively revised.
*       11-08-91  GJF   Cleaned up header files usage.
*       12-13-91  GJF   Fixed multi-thread build.
*       01-17-92  GJF   Changed default handling under Win32 - unhandled
*                       exceptions are now passed to UnhandledExceptionFilter.
*                       Dosx32 behavior in unchanged. Also, used a couple of
*                       local macros to simplify handling of single-thread vs
*                       multi-thread code [_Win32_].
*       02-16-93  GJF   Changed for new _getptd().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-19-93  SKS   Move XcptActTabSize under MTHREAD switch
*       04-27-93  GJF   Removed (commented out) entries in _XcptActTab which
*                       corresponded to C RTEs. These will now simply be
*                       passed on through to the system exception handler.
*       07-28-93  GJF   For SIGFPE, must reset the XcptAction field for all
*                       FPE entries to SIG_DFL before calling the user's
*                       handler.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       08-16-96  GJF   Fixed potential overrun of _XcptActTab. Also, detab-ed.
*       08-21-96  GJF   Fixed _MT part of overrun fix.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <float.h>
#include <mtdll.h>
#include <oscalls.h>
#include <signal.h>
#include <stddef.h>


/*
 * special code denoting no signal.
 */
#define NOSIG   -1


struct _XCPT_ACTION _XcptActTab[] = {

/*
 * Exceptions corresponding to the same signal (e.g., SIGFPE) must be grouped
 * together.
 *
 *        XcptNum                                        SigNum    XcptAction
 *        -------------------------------------------------------------------
 */
        { (unsigned long)STATUS_ACCESS_VIOLATION,         SIGSEGV, SIG_DFL },

        { (unsigned long)STATUS_ILLEGAL_INSTRUCTION,      SIGILL,  SIG_DFL },

        { (unsigned long)STATUS_PRIVILEGED_INSTRUCTION,   SIGILL,  SIG_DFL },

/*      { (unsigned long)STATUS_NONCONTINUABLE_EXCEPTION, NOSIG,   SIG_DIE },
 */
/*      { (unsigned long)STATUS_INVALID_DISPOSITION,      NOSIG,   SIG_DIE },
 */
        { (unsigned long)STATUS_FLOAT_DENORMAL_OPERAND,   SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_DIVIDE_BY_ZERO,     SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_INEXACT_RESULT,     SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_INVALID_OPERATION,  SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_OVERFLOW,           SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_STACK_CHECK,        SIGFPE,  SIG_DFL },

        { (unsigned long)STATUS_FLOAT_UNDERFLOW,          SIGFPE,  SIG_DFL },

/*      { (unsigned long)STATUS_INTEGER_DIVIDE_BY_ZERO,   NOSIG,   SIG_DIE },
 */
/*      { (unsigned long)STATUS_STACK_OVERFLOW,           NOSIG,   SIG_DIE }
 */
};

/*
 * WARNING!!!! The definition below amounts to defining that:
 *
 *                  XcptActTab[ _First_FPE_Indx ]
 *
 * is the very FIRST entry in the table corresponding to a floating point
 * exception. Whenever the definition of the XcptActTab[] table is changed,
 * this #define must be review to ensure correctness.
 */
int _First_FPE_Indx = 3;

/*
 * There are _Num_FPE (currently, 7) entries in XcptActTab corresponding to
 * floating point exceptions.
 */
int _Num_FPE = 7;

#ifdef _MT

/*
 * size of the exception-action table (in bytes)
 */
int _XcptActTabSize = sizeof _XcptActTab;

#endif

/*
 * number of entries in the exception-action table
 */
int _XcptActTabCount = (sizeof _XcptActTab)/sizeof(_XcptActTab[0]);


#ifdef _MT

/*
 * the FPECODE and PXCPTINFOPTRS macros are intended to simplify some of
 * single vs multi-thread code in the filter function. basically, each macro
 * is conditionally defined to be a global variable or the corresponding
 * field in the per-thread data structure. NOTE THE ASSUMPTION THAT THE
 * _ptiddata VARIABLE IS ALWAYS NAMED ptd!!!!
 */

#define FPECODE         ptd->_tfpecode

#define PXCPTINFOPTRS   ptd->_tpxcptinfoptrs

#else

/*
 * global variable containing the floating point exception code
 */
int _fpecode = _FPE_EXPLICITGEN;

#define FPECODE         _fpecode

/*
 * global variable holding _PEXCEPTION_INFO_PTRS value
 */
void * _pxcptinfoptrs = NULL;

#define PXCPTINFOPTRS   _pxcptinfoptrs

#endif  /* _MT */

/*
 * function to look up the exception action table (_XcptActTab[]) corresponding
 * to the given exception
 */

#ifdef  _MT

static struct _XCPT_ACTION * __cdecl xcptlookup(
        unsigned long,
        struct _XCPT_ACTION *
        );

#else   /* ndef _MT */

static struct _XCPT_ACTION * __cdecl xcptlookup(
        unsigned long
        );

#endif  /* _MT */

#ifdef  DEBUG

/*
 * prototypes for debugging routines
 */
void prXcptActTabEntry(struct _XCPT_ACTION *);
void prXcptActTab(void);

#endif  /* DEBUG */

/***
*int _XcptFilter(xcptnum, pxcptptrs) - Identify exception and the action to
*       be taken with it
*
*Purpose:
*       _XcptFilter() is called by the exception filter expression of the
*       _try - _except statement, in the startup code, which guards the call
*       to the user's main(). _XcptFilter() consults the _XcptActTab[] table
*       to identify the exception and determine its disposition. The
*       is disposition of an exception corresponding to a C signal may be
*       modified by a call to signal(). There are three broad cases:
*
*       (1) Unrecognized exceptions and exceptions for which the XcptAction
*           value is SIG_DFL.
*
#ifndef DOSX32
*           In both of these cases, UnhandledExceptionFilter() is called and
*           its return value is returned.
#else
*           In both of these cases, EXCEPTION_CONTINUE_SEARCH is returned to
*           cause the OS exception dispatcher to pass the exception onto the
*           next exception handler in the chain (usually a system default
*           handler).
#endif
*
*       (2) Exceptions corresponding to C signals with an XcptAction value
*           NOT equal to SIG_DFL.
*
*           These are the C signals whose disposition has been affected by a
*           call to signal() or whose default semantics differ slightly from
*           from the corresponding OS exception. In all cases, the appropriate
*           disposition of the C signal is made by the function (e.g., calling
*           a user-specified signal handler). Then, EXCEPTION_CONTINUE_EXECU-
*           TION is returned to cause the OS exception dispatcher to dismiss
*           the exception and resume execution at the point where the
*           exception occurred.
*
*       (3) Exceptions for which the XcptAction value is SIG_DIE.
*
*           These are the exceptions corresponding to fatal C runtime errors.
*           _XCPT_HANDLE is returned to cause control to pass into the
*           _except-block of the _try - _except statement. There, the runtime
*           error is identified, an appropriate error message is printed out
*           and the program is terminated.
*
*Entry:
*
*Exit:
*
*Exceptions:
*       That's what it's all about!
*
*******************************************************************************/

int __cdecl _XcptFilter (
        unsigned long xcptnum,
        PEXCEPTION_POINTERS pxcptinfoptrs
        )
{
        struct _XCPT_ACTION * pxcptact;
        _PHNDLR phandler;
        void *oldpxcptinfoptrs;
        int oldfpecode;
        int indx;

#ifdef  _MT
        _ptiddata ptd = _getptd();
#endif  /* _MT */

        /*
         * first, take care of all unrecognized exceptions and exceptions with
         * XcptAction values of SIG_DFL.
         */
#ifdef  _MT
        if ( ((pxcptact = xcptlookup(xcptnum, ptd->_pxcptacttab)) == NULL)
            || (pxcptact->XcptAction == SIG_DFL) )
#else   /* not _MT */
        if ( ((pxcptact = xcptlookup(xcptnum)) == NULL) ||
            (pxcptact->XcptAction == SIG_DFL) )
#endif  /* _MT */

#ifndef DOSX32
                /*
                 * pass the buck to the UnhandledExceptionFilter
                 */
                return( UnhandledExceptionFilter(pxcptinfoptrs) );
#else
                /*
                 * pass the buck to the next level exception handler
                 */
                return(EXCEPTION_CONTINUE_SEARCH);
#endif

#ifdef  DEBUG
        prXcptActTabEntry(pxcptact);
#endif  /* DEBUG */

        /*
         * next, weed out all of the exceptions that need to be handled by
         * dying, perhaps with a runtime error message
         */
        if ( pxcptact->XcptAction == SIG_DIE ) {
                /*
                 * reset XcptAction (in case of recursion) and drop into the
                 * except-clause.
                 */
                pxcptact->XcptAction = SIG_DFL;
                return(EXCEPTION_EXECUTE_HANDLER);
        }

        /*
         * next, weed out all of the exceptions that are simply ignored
         */
        if ( pxcptact->XcptAction == SIG_IGN )
                /*
                 * resume execution
                 */
                return(EXCEPTION_CONTINUE_EXECUTION);

        /*
         * the remaining exceptions all correspond to C signals which have
         * signal handlers associated with them. for some, special setup
         * is required before the signal handler is called. in all cases,
         * if the signal handler returns, -1 is returned by this function
         * to resume execution at the point where the exception occurred.
         */
        phandler = pxcptact->XcptAction;

        /*
         * save the old value of _pxcptinfoptrs (in case this is a nested
         * exception/signal) and store the current one.
         */
        oldpxcptinfoptrs = PXCPTINFOPTRS;
        PXCPTINFOPTRS = pxcptinfoptrs;

        /*
         * call the user-supplied signal handler
         *
         * floating point exceptions must be handled specially since, from
         * the C point-of-view, there is only one signal. the exact identity
         * of the exception is passed in the global variable _fpecode.
         */
        if ( pxcptact->SigNum == SIGFPE ) {

                /*
                 * reset the XcptAction field to the default for all entries
                 * corresponding to SIGFPE.
                 */
                for ( indx = _First_FPE_Indx ;
                      indx < _First_FPE_Indx + _Num_FPE ;
                      indx++ )
                {
#ifdef  _MT
                        ( (struct _XCPT_ACTION *)(ptd->_pxcptacttab) +
                          indx )->XcptAction = SIG_DFL;
#else
                        _XcptActTab[indx].XcptAction = SIG_DFL;
#endif
                }

                /*
                 * Save the current _fpecode in case it is a nested floating
                 * point exception (not clear that we need to support this,
                 * but it's easy).
                 */
                oldfpecode = FPECODE;

                /*
                 * there are no exceptions corresponding to
                 * following _FPE_xxx codes:
                 *
                 *      _FPE_UNEMULATED
                 *      _FPE_SQRTNEG
                 *
                 * futhermore, STATUS_FLOATING_STACK_CHECK is
                 * raised for both floating point stack under-
                 * flow and overflow. thus, the exception does
                 * not distinguish between _FPE_STACKOVERLOW
                 * and _FPE_STACKUNDERFLOW. arbitrarily, _fpecode
                 * is set to the former value.
                 *
                 * the following should be a switch statement but, alas, the
                 * compiler doesn't like switching on unsigned longs...
                 */
                if ( pxcptact->XcptNum == STATUS_FLOAT_DIVIDE_BY_ZERO )

                        FPECODE = _FPE_ZERODIVIDE;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_INVALID_OPERATION )

                        FPECODE = _FPE_INVALID;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_OVERFLOW )

                        FPECODE = _FPE_OVERFLOW;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_UNDERFLOW )

                        FPECODE = _FPE_UNDERFLOW;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_DENORMAL_OPERAND )

                        FPECODE = _FPE_DENORMAL;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_INEXACT_RESULT )

                        FPECODE = _FPE_INEXACT;

                else if ( pxcptact->XcptNum == STATUS_FLOAT_STACK_CHECK )

                        FPECODE = _FPE_STACKOVERFLOW;

                /*
                 * call the SIGFPE handler. note the special code to support
                 * old MS-C programs whose SIGFPE handlers expect two args.
                 *
                 * NOTE: THE CAST AND CALL BELOW DEPEND ON __cdecl BEING
                 * CALLER CLEANUP!
                 */
                (*(void (__cdecl *)(int, int))phandler)(SIGFPE, FPECODE);

                /*
                 * restore the old value of _fpecode
                 */
                FPECODE = oldfpecode;
        }
        else {
                /*
                 * reset the XcptAction field to the default, then call the
                 * user-supplied handler
                 */
                pxcptact->XcptAction = SIG_DFL;
                (*phandler)(pxcptact->SigNum);
        }

        /*
         * restore the old value of _pxcptinfoptrs
         */
        PXCPTINFOPTRS = oldpxcptinfoptrs;

        return(EXCEPTION_CONTINUE_EXECUTION);

}


/***
*struct _XCPT_ACTION * xcptlookup(xcptnum, pxcptrec) - look up exception-action
*       table entry for xcptnum
*
*Purpose:
*       Find the in _XcptActTab[] whose Xcptnum field is xcptnum.
*
*Entry:
*       unsigned long xcptnum            - exception type
*
*       _PEXCEPTIONREPORTRECORD pxcptrec - pointer to exception report record
*       (used only to distinguish different types of XCPT_SIGNAL)
*
*Exit:
*       If successful, pointer to the table entry. If no such entry, NULL is
*       returned.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _MT

static struct _XCPT_ACTION * __cdecl xcptlookup (
        unsigned long xcptnum,
        struct _XCPT_ACTION * pxcptacttab
        )

#else   /* not _MT */

static struct _XCPT_ACTION * __cdecl xcptlookup (
        unsigned long xcptnum
        )

#endif  /* _MT */

{
#ifdef  _MT
        struct _XCPT_ACTION *pxcptact = pxcptacttab;
#else   /* ndef _MT */
        struct _XCPT_ACTION *pxcptact = _XcptActTab;
#endif  /* _MT */

        /*
         * walk thru the _xcptactab table looking for the proper entry
         */
#ifdef  _MT

        while ( (pxcptact->XcptNum != xcptnum) && 
                (++pxcptact < pxcptacttab + _XcptActTabCount) ) ;

#else   /* not _MT */

        while ( (pxcptact->XcptNum != xcptnum) && 
                (++pxcptact < _XcptActTab + _XcptActTabCount) ) ;

#endif  /* _MT */

        /*
         * if no table entry was found corresponding to xcptnum, return NULL
         */
#ifdef  _MT
        if ( (pxcptact >= pxcptacttab + _XcptActTabCount) ||
#else   /* not _MT */
        if ( (pxcptact >= _XcptActTab + _XcptActTabCount) ||
#endif  /* _MT */
             (pxcptact->XcptNum != xcptnum) )
                return(NULL);

        return(pxcptact);
}

#ifdef DEBUG

/*
 * DEBUGGING TOOLS!
 */
struct xcptnumstr {
        unsigned long num;
        char *str;
};

struct xcptnumstr XcptNumStr[] = {

        { (unsigned long)STATUS_DATATYPE_MISALIGNMENT,
            "STATUS_DATATYPE_MISALIGNMENT" },

        { (unsigned long)STATUS_ACCESS_VIOLATION,
            "STATUS_ACCESS_VIOLATION" },

        { (unsigned long)STATUS_ILLEGAL_INSTRUCTION,
            "STATUS_ILLEGAL_INSTRUCTION" },

        { (unsigned long)STATUS_NONCONTINUABLE_EXCEPTION,
            "STATUS_NONCONTINUABLE_EXCEPTION" },

        { (unsigned long)STATUS_INVALID_DISPOSITION,
            "STATUS_INVALID_DISPOSITION" },

        { (unsigned long)STATUS_FLOAT_DENORMAL_OPERAND,
            "STATUS_FLOAT_DENORMAL_OPERAND" },

        { (unsigned long)STATUS_FLOAT_DIVIDE_BY_ZERO,
            "STATUS_FLOAT_DIVIDE_BY_ZERO" },

        { (unsigned long)STATUS_FLOAT_INEXACT_RESULT,
            "STATUS_FLOAT_INEXACT_RESULT" },

        { (unsigned long)STATUS_FLOAT_INVALID_OPERATION,
            "STATUS_FLOAT_INVALID_OPERATION" },

        { (unsigned long)STATUS_FLOAT_OVERFLOW,
            "STATUS_FLOAT_OVERFLOW" },

        { (unsigned long)STATUS_FLOAT_STACK_CHECK,
            "STATUS_FLOAT_STACK_CHECK" },

        { (unsigned long)STATUS_FLOAT_UNDERFLOW,
            "STATUS_FLOAT_UNDERFLOW" },

        { (unsigned long)STATUS_INTEGER_DIVIDE_BY_ZERO,
            "STATUS_INTEGER_DIVIDE_BY_ZERO" },

        { (unsigned long)STATUS_PRIVILEGED_INSTRUCTION,
            "STATUS_PRIVILEGED_INSTRUCTION" },

        { (unsigned long)_STATUS_STACK_OVERFLOW,
            "_STATUS_STACK_OVERFLOW" }
};

#define XCPTNUMSTR_SZ   ( sizeof XcptNumStr / sizeof XcptNumStr[0] )

/*
 * return string mnemonic for exception
 */
char * XcptNumToStr (
        unsigned long xcptnum
        )
{
        int indx;

        for ( indx = 0 ; indx < XCPTNUMSTR_SZ ; indx++ )
                if ( XcptNumStr[indx].num == xcptnum )
                        return(XcptNumStr[indx].str);

        return(NULL);
}

struct signumstr {
        int num;
        char *str;
};

struct signumstr SigNumStr[] = {
        { SIGINT,       "SIGINT" },
        { SIGILL,       "SIGILL" },
        { SIGFPE,       "SIGFPE" },
        { SIGSEGV,      "SIGSEGV" },
        { SIGTERM,      "SIGTERM" },
        { SIGBREAK,     "SIGBREAK" },
        { SIGABRT,      "SIGABRT" }
};

#define SIGNUMSTR_SZ   ( sizeof SigNumStr / sizeof SigNumStr[0] )

/*
 * return string mnemonic for signal
 */
char * SigNumToStr (
        int signum
        )
{
        int indx;

        for ( indx = 0 ; indx < SIGNUMSTR_SZ ; indx++ )
                if ( SigNumStr[indx].num == signum )
                        return(SigNumStr[indx].str);

        return(NULL);
}

struct actcodestr {
        _PHNDLR code;
        char *str;
};

struct actcodestr ActCodeStr[] = {
        { SIG_DFL,      "SIG_DFL" },
        { SIG_IGN,      "SIG_IGN" },
        { SIG_DIE,      "SIG_DIE" }
};

#define ACTCODESTR_SZ   ( sizeof ActCodeStr / sizeof ActCodeStr[0] )

/*
 * return string mnemonic for action code
 */
char * ActCodeToStr (
        _PHNDLR action
        )
{
        int indx;

        for ( indx = 0 ; indx < ACTCODESTR_SZ ; indx++ )
                if ( ActCodeStr[indx].code == action)
                        return(ActCodeStr[indx].str);

        return("FUNCTION ADDRESS");
}

/*
 * print out exception-action table entry
 */
void prXcptActTabEntry (
        struct _XCPT_ACTION *pxcptact
        )
{
        printf("XcptNum    = %s\n", XcptNumToStr(pxcptact->XcptNum));
        printf("SigNum     = %s\n", SigNumToStr(pxcptact->SigNum));
        printf("XcptAction = %s\n", ActCodeToStr(pxcptact->XcptAction));
}

/*
 * print out all entries in the exception-action table
 */
void prXcptActTab (
        void
        )
{
        int indx;

        for ( indx = 0 ; indx < _XcptActTabCount ; indx++ ) {
                printf("\n_XcptActTab[%d] = \n", indx);
                prXcptActTabEntry(&_XcptActTab[indx]);
        }
}

#endif  /* DEBUG */

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wputenv.c ===
/***
*wputenv.c - put an environment variable into the environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wputenv() - adds a new variable to environment; does not
*	change global environment, only the process' environment.
*
*Revision History:
*	11-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "putenv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\winsig.c ===
/***
*winsig.c - C signal support
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines signal(), raise() and supporting functions.
*
*Revision History:
*       10-21-91  GJF   Signal for Win32 and Dosx32. Copied from old signal.c
*                       (the Cruiser implementation with some revisions for
*                       Win32), then extensively rewritten.
*       11-08-91  GJF   Cleaned up header files usage.
*       12-13-91  GJF   Fixed multi-thread build.
*       09-30-92  SRW   Add WINAPI keyword to CtrlC handler
*       02-17-93  GJF   Changed for new _getptd().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-29-93  GJF   Must reset the action for all FPE-s to SIG_DFL when
*                       SIGFPE is raised.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       08-16-96  GJF   Fixed overruns of _XctActTab. Also, detab-ed.
*       08-21-96  GJF   Fixed _MT part of overrun fix.
*       03-05-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <errno.h>
#include <float.h>
#include <malloc.h>
#include <mtdll.h>
#include <oscalls.h>
#include <signal.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <dbgint.h>

/*
 * look up the first entry in the exception-action table corresponding to
 * the given signal
 */
#ifdef  _MT
static struct _XCPT_ACTION * __cdecl siglookup(int, struct _XCPT_ACTION *);
#else   /* not _MT */
static struct _XCPT_ACTION * __cdecl siglookup(int);
#endif  /* _MT */

/*
 * variables holding action codes (and code pointers) for SIGINT, SIGBRK,
 * SIGABRT and SIGTERM.
 *
 * note that the disposition (i.e., action to be taken upon receipt) of
 * these signals is defined on a per-process basis (not per-thread)!!
 */

static _PHNDLR ctrlc_action       = SIG_DFL;    /* SIGINT   */
static _PHNDLR ctrlbreak_action   = SIG_DFL;    /* SIGBREAK */
static _PHNDLR abort_action       = SIG_DFL;    /* SIGABRT  */
static _PHNDLR term_action        = SIG_DFL;    /* SIGTERM  */

/*
 * flag indicated whether or not a handler has been installed to capture
 * ^C and ^Break events.
 */
static int ConsoleCtrlHandler_Installed = 0;


/***
*static BOOL WINAPI ctrlevent_capture(DWORD CtrlType) - capture ^C and ^Break events
*
*Purpose:
*       Capture ^C and ^Break events from the console and dispose of them
*       according the values in ctrlc_action and ctrlbreak_action, resp.
*       This is the routine that evokes the user-defined action for SIGINT
*       (^C) or SIGBREAK (^Break) installed by a call to signal().
*
*Entry:
*       DWORD CtrlType  - indicates type of event, two values:
*                               CTRL_C_EVENT
*                               CTRL_BREAK_EVENT
*
*Exit:
*       Returns TRUE to indicate the event (signal) has been handled.
*       Otherwise, returns FALSE.
*
*Exceptions:
*
*******************************************************************************/

static BOOL WINAPI ctrlevent_capture (
        DWORD CtrlType
        )
{
        _PHNDLR ctrl_action;
        _PHNDLR *pctrl_action;
        int sigcode;

#ifdef  _MT
        _mlock(_SIGNAL_LOCK);
        __try {
#endif  /* _MT */

        /*
         * Identify the type of event and fetch the corresponding action
         * description.
         */

        if ( CtrlType == CTRL_C_EVENT ) {
                ctrl_action = *(pctrl_action = &ctrlc_action);
                sigcode = SIGINT;
        }
        else {
                ctrl_action = *(pctrl_action = &ctrlbreak_action);
                sigcode = SIGBREAK;
        }

#ifdef  _MT
        if ( !(ctrl_action == SIG_DFL) && !(ctrl_action == SIG_IGN) )
                /*
                 * Reset the action to be SIG_DFL
                 */
                *pctrl_action = SIG_DFL;

        }
        __finally {
                _munlock(_SIGNAL_LOCK);
        }
#endif  /* _MT */

        if ( ctrl_action == SIG_DFL )
                /*
                 * return FALSE, indicating the event has NOT been handled
                 */
                return FALSE;

        if ( ctrl_action != SIG_IGN ) {
#ifndef _MT
                /*
                 * Reset the action to be SIG_DFL and call the user's handler.
                 */
                *pctrl_action = SIG_DFL;
#endif  /* ndef _MT */
                (*ctrl_action)(sigcode);
        }

        /*
         * Return TRUE, indicating the event has been handled (which may
         * mean it's being ignored)
         */
        return TRUE;
}



/***
*_PHNDLR signal(signum, sigact) - Define a signal handler
*
*Purpose:
*       The signal routine allows the user to define what action should
*       be taken when various signals occur. The Win32/Dosx32 implementation
*       supports seven signals, divided up into three general groups
*
*       1. Signals corresponding to OS exceptions. These are:
*                       SIGFPE
*                       SIGILL
*                       SIGSEGV
*          Signal actions for these signals are installed by altering the
*          XcptAction and SigAction fields for the appropriate entry in the
*          exception-action table (XcptActTab[]).
*
*       2. Signals corresponding to ^C and ^Break. These are:
*                       SIGINT
*                       SIGBREAK
*          Signal actions for these signals are installed by altering the
*          _ctrlc_action and _ctrlbreak_action variables.
*
*       3. Signals which are implemented only in the runtime. That is, they
*          occur only as the result of a call to raise().
*                       SIGABRT
*                       SIGTERM
*
*
*Entry:
*       int signum      signal type. recognized signal types are:
*
*                       SIGABRT         (ANSI)
*                       SIGBREAK
*                       SIGFPE          (ANSI)
*                       SIGILL          (ANSI)
*                       SIGINT          (ANSI)
*                       SIGSEGV         (ANSI)
*                       SIGTERM         (ANSI)
*
*       _PHNDLR sigact  signal handling function or action code. the action
*                       codes are:
*
*                       SIG_DFL - take the default action, whatever that may
*                       be, upon receipt of this type type of signal.
*
*                       SIG_DIE - *** ILLEGAL ***
*                       special code used in the XcptAction field of an
*                       XcptActTab[] entry to indicate that the runtime is
*                       to terminate the process upon receipt of the exception.
*                       not accepted as a value for sigact.
*
*                       SIG_IGN - ignore this type of signal
*
*                       [function address] - transfer control to this address
*                       when a signal of this type occurs.
*
*Exit:
*       Good return:
*       Signal returns the previous value of the signal handling function
*       (e.g., SIG_DFL, SIG_IGN, etc., or [function address]). This value is
*       returned in DX:AX.
*
*       Error return:
*       Signal returns -1 and errno is set to EINVAL. The error return is
*       generally taken if the user submits bogus input values.
*
*Exceptions:
*       None.
*
*******************************************************************************/

_PHNDLR __cdecl signal(
        int signum,
        _PHNDLR sigact
        )
{
        struct _XCPT_ACTION *pxcptact;
        _PHNDLR oldsigact;
#ifdef  _MT
        _ptiddata ptd;
#endif

        /*
         * Check for values of sigact supported on other platforms but not
         * on this one. Also, make sure sigact is not SIG_DIE
         */
        if ( (sigact == SIG_ACK) || (sigact == SIG_SGE) )
                goto sigreterror;

        /*
         * Take care of all signals which do not correspond to exceptions
         * in the host OS. Those are:
         *
         *                      SIGINT
         *                      SIGBREAK
         *                      SIGABRT
         *                      SIGTERM
         *
         */
        if ( (signum == SIGINT) || (signum == SIGBREAK) || (signum == SIGABRT)
            || (signum == SIGTERM) ) {

#ifdef  _MT
                _mlock( _SIGNAL_LOCK );
                __try {
#endif

                /*
                 * if SIGINT or SIGBREAK, make sure the handler is installed
                 * to capture ^C and ^Break events.
                 */
                if ( ((signum == SIGINT) || (signum == SIGBREAK)) &&
                    !ConsoleCtrlHandler_Installed )
                        if ( SetConsoleCtrlHandler(ctrlevent_capture, TRUE)
                            == TRUE )
                                ConsoleCtrlHandler_Installed = TRUE;
                        else {
                                _doserrno = GetLastError();
                                _munlock(_SIGNAL_LOCK);
                                goto sigreterror;
                        }

                switch (signum) {

                        case SIGINT:
                                oldsigact = ctrlc_action;
                                ctrlc_action = sigact;
                                break;

                        case SIGBREAK:
                                oldsigact = ctrlbreak_action;
                                ctrlbreak_action = sigact;
                                break;

                        case SIGABRT:
                                oldsigact = abort_action;
                                abort_action = sigact;
                                break;

                        case SIGTERM:
                                oldsigact = term_action;
                                term_action = sigact;
                                break;
                }

#ifdef  _MT
                }
                __finally {
                        _munlock( _SIGNAL_LOCK );
                }
#endif
                goto sigretok;
        }

        /*
         * If we reach here, signum is supposed to be one the signals which
         * correspond to exceptions in the host OS. Those are:
         *
         *                      SIGFPE
         *                      SIGILL
         *                      SIGSEGV
         */

        /*
         * Make sure signum is one of the remaining supported signals.
         */
        if ( (signum != SIGFPE) && (signum != SIGILL) && (signum != SIGSEGV) )
                goto sigreterror;


#ifdef  _MT
        /*
         * Fetch the tid data table entry for this thread
         */
        ptd = _getptd();

        /*
         * Check that there a per-thread instance of the exception-action
         * table for this thread. if there isn't, create one.
         */
        if ( ptd->_pxcptacttab == _XcptActTab )
                /*
                 * allocate space for an exception-action table
                 */
                if ( (ptd->_pxcptacttab = _malloc_crt(_XcptActTabSize)) != NULL )
                        /*
                         * initialize the table by copying over the contents
                         * of _XcptActTab[]
                         */
                        (void) memcpy(ptd->_pxcptacttab, _XcptActTab,
                            _XcptActTabSize);
                else
                        /*
                         * cannot create exception-action table, return
                         * error to caller
                         */
                        goto sigreterror;

#endif  /* _MT */

        /*
         * look up the proper entry in the exception-action table. note that
         * if several exceptions are mapped to the same signal, this returns
         * the pointer to first such entry in the exception action table. it
         * is assumed that the other entries immediately follow this one.
         */
#ifdef  _MT
        if ( (pxcptact = siglookup(signum, ptd->_pxcptacttab)) == NULL )
#else   /* not _MT */
        if ( (pxcptact = siglookup(signum)) == NULL )
#endif  /* _MT */
                goto sigreterror;

        /*
         * SIGSEGV, SIGILL and SIGFPE all have more than one exception mapped
         * to them. the code below depends on the exceptions corresponding to
         * the same signal being grouped together in the exception-action
         * table.
         */

        /*
         * store old signal action code for return value
         */
        oldsigact = pxcptact->XcptAction;

        /*
         * loop through all entries corresponding to the
         * given signal and update the SigAction and XcptAction
         * fields as appropriate
         */
        while ( pxcptact->SigNum == signum ) {
                /*
                 * take care of the SIG_IGN and SIG_DFL action
                 * codes
                 */
                pxcptact->XcptAction = sigact;

                /*
                 * make sure we don't run off the end of the table
                 */
#ifdef  _MT
                if ( ++pxcptact >= ((struct _XCPT_ACTION *)(ptd->_pxcptacttab) 
                                   + _XcptActTabCount) )
#else   /* not _MT */
                if ( ++pxcptact >= (_XcptActTab + _XcptActTabCount) )
#endif  /* _MT */
                    break;
        }

sigretok:
        return(oldsigact);

sigreterror:
        errno = EINVAL;
        return(SIG_ERR);
}

/***
*int raise(signum) - Raise a signal
*
*Purpose:
*       This routine raises a signal (i.e., performs the action currently
*       defined for this signal). The action associated with the signal is
*       evoked directly without going through intermediate dispatching or
*       handling.
*
*Entry:
*       int signum - signal type (e.g., SIGINT)
*
*Exit:
*       returns 0 on good return, -1 on bad return.
*
*Exceptions:
*       May not return.  Raise has no control over the action
*       routines defined for the various signals.  Those routines may
*       abort, terminate, etc.  In particular, the default actions for
*       certain signals will terminate the program.
*
*******************************************************************************/


int __cdecl raise (
        int signum
        )
{
        _PHNDLR sigact;
        _PHNDLR *psigact;
        PEXCEPTION_POINTERS oldpxcptinfoptrs;
        int oldfpecode;
        int indx;

#ifdef  _MT
        int siglock = 0;
        _ptiddata ptd;
#endif

        switch (signum) {

                case SIGINT:
                        sigact = *(psigact = &ctrlc_action);
#ifdef  _MT
                        siglock++;
#endif
                        break;

                case SIGBREAK:
                        sigact = *(psigact = &ctrlbreak_action);
#ifdef  _MT
                        siglock++;
#endif
                        break;

                case SIGABRT:
                        sigact = *(psigact = &abort_action);
#ifdef  _MT
                        siglock++;
#endif
                        break;

                case SIGTERM:
                        sigact = *(psigact = &term_action);
#ifdef  _MT
                        siglock++;
#endif
                        break;

                case SIGFPE:
                case SIGILL:
                case SIGSEGV:
#ifdef  _MT
                        ptd = _getptd();
                        sigact = *(psigact = &(siglookup( signum,
                            ptd->_pxcptacttab )->XcptAction));
#else
                        sigact = *(psigact = &(siglookup( signum )->
                            XcptAction));
#endif
                        break;

                default:
                        /*
                         * unsupported signal, return an error
                         */
                        return (-1);
        }

        /*
         * If the current action is SIG_IGN, just return
         */
        if ( sigact == SIG_IGN )
                return(0);

        /*
         * If the current action is SIG_DFL, take the default action
         */
        if ( sigact == SIG_DFL ) {
                /*
                 * The current default action for all of the supported
                 * signals is to terminate with an exit code of 3.
                 */
                _exit(3);
        }

#ifdef  _MT
        /*
         * if signum is one of the 'process-wide' signals (i.e., SIGINT,
         * SIGBREAK, SIGABRT or SIGTERM), assert _SIGNAL_LOCK.
         */
        if ( siglock )
                _mlock(_SIGNAL_LOCK);

        __try {
#endif


        /*
         * From here on, sigact is assumed to be a pointer to a user-supplied
         * handler.
         */

        /*
         * For signals which correspond to exceptions, set the pointer
         * to the EXCEPTION_POINTERS structure to NULL
         */
        if ( (signum == SIGFPE) || (signum == SIGSEGV) ||
            (signum == SIGILL) ) {
#ifdef  _MT
                oldpxcptinfoptrs = ptd->_tpxcptinfoptrs;
                ptd->_tpxcptinfoptrs = NULL;
#else
                oldpxcptinfoptrs = _pxcptinfoptrs;
                _pxcptinfoptrs = NULL;
#endif

                 /*
                  * If signum is SIGFPE, also set _fpecode to
                  * _FPE_EXPLICITGEN
                  */
                if ( signum == SIGFPE ) {
#ifdef  _MT
                        oldfpecode = ptd->_tfpecode;
                        ptd->_tfpecode = _FPE_EXPLICITGEN;
#else
                        oldfpecode = _fpecode;
                        _fpecode = _FPE_EXPLICITGEN;
#endif
                }
        }

        /*
         * Reset the action to SIG_DFL and call the user specified handler
         * routine.
         */
        if ( signum == SIGFPE )
                /*
                 * for SIGFPE, must reset the action for all of the floating
                 * point exceptions
                 */
                for ( indx = _First_FPE_Indx ;
                      indx < _First_FPE_Indx + _Num_FPE ;
                      indx++ )
                {
#ifdef  _MT
                        ( (struct _XCPT_ACTION *)(ptd->_pxcptacttab) +
                          indx )->XcptAction = SIG_DFL;
#else
                        _XcptActTab[indx].XcptAction = SIG_DFL;
#endif
                }
        else
                *psigact = SIG_DFL;

#ifdef  _MT
        }
        __finally {
                if ( siglock )
                        _munlock(_SIGNAL_LOCK);
        }
#endif

        if ( signum == SIGFPE )
                /*
                 * Special code to support old SIGFPE handlers which
                 * expect the value of _fpecode as the second argument.
                 */
#ifdef  _MT
                (*(void (__cdecl *)(int,int))sigact)(SIGFPE,
                    ptd->_tfpecode);
#else
                (*(void (__cdecl *)(int,int))sigact)(SIGFPE, _fpecode);
#endif
        else
                (*sigact)(signum);

        /*
         * For signals which correspond to exceptions, restore the pointer
         * to the EXCEPTION_POINTERS structure.
         */
        if ( (signum == SIGFPE) || (signum == SIGSEGV) ||
            (signum == SIGILL) ) {
#ifdef  _MT
                ptd->_tpxcptinfoptrs = oldpxcptinfoptrs;
#else
                _pxcptinfoptrs = oldpxcptinfoptrs;
#endif

                 /*
                  * If signum is SIGFPE, also restore _fpecode
                  */
                if ( signum == SIGFPE )
#ifdef  _MT
                        ptd->_tfpecode = oldfpecode;
#else
                        _fpecode = oldfpecode;
#endif
        }

        return(0);
}


/***
*struct _XCPT_ACTION *siglookup(int signum) - look up exception-action table
*       entry for signal.
*
*Purpose:
*       Find the first entry int _XcptActTab[] whose SigNum field is signum.
*
*Entry:
*       int signum - C signal type (e.g., SIGINT)
*
*Exit:
*       If successful, pointer to the table entry. If no such entry, NULL is
*       returned.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _MT

static struct _XCPT_ACTION * __cdecl siglookup (
        int signum,
        struct _XCPT_ACTION *pxcptacttab
        )
{
        struct _XCPT_ACTION *pxcptact = pxcptacttab;

#else   /* not _MT */

static struct _XCPT_ACTION * __cdecl siglookup(int signum)
{
        struct _XCPT_ACTION *pxcptact = _XcptActTab;

#endif  /* _MT */
        /*
         * walk thru the _xcptactab table looking for the proper entry. note
         * that in the case where more than one exception corresponds to the
         * same signal, the first such instance in the table is the one
         * returned.
         */
#ifdef  _MT

        while ( (pxcptact->SigNum != signum) && 
                (++pxcptact < pxcptacttab + _XcptActTabCount) ) ;

#else   /* not _MT */

        while ( (pxcptact->SigNum != signum) && 
                (++pxcptact < _XcptActTab + _XcptActTabCount) ) ;

#endif  /* _MT */

#ifdef  _MT
        if ( (pxcptact < (pxcptacttab + _XcptActTabCount)) && 
#else   /* not _MT */
        if ( (pxcptact < (_XcptActTab + _XcptActTabCount)) && 
#endif  /* _MT */
             (pxcptact->SigNum == signum) )
                /*
                 * found a table entry corresponding to the signal
                 */
                return(pxcptact);
        else
                /*
                 * found no table entry corresponding to the signal
                 */
                return(NULL);
}

#ifdef  _MT

/***
*int *__fpecode(void) - return pointer to _fpecode field of the tidtable entry
*       for the current thread
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int * __cdecl __fpecode (
        void
        )
{
        return( &(_getptd()->_tfpecode) );
}


/***
*void **__pxcptinfoptrs(void) - return pointer to _pxcptinfoptrs field of the
*       tidtable entry for the current thread
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void ** __cdecl __pxcptinfoptrs (
        void
        )
{
        return( &(_getptd()->_tpxcptinfoptrs) );
}

#endif

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wperror.c ===
/***
*wperror.c - print system error message (wchar_t version)
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wperror() - print wide system error message
*       System error message are indexed by errno.
*
*Revision History:
*       12-07-93  CFW   Module created from perror.
*       02-07-94  CFW   POSIXify.
*       01-10-95  CFW   Debug CRT allocs.
*       01-06-98  GJF   Exception-safe locking.
*       09-23-98  GJF   Fixed handling of NULL or empty string arg.
*       01-06-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syserr.h>
#include <mtdll.h>
#include <io.h>
#include <dbgint.h>

/***
*void _wperror(wmessage) - print system error message
*
*Purpose:
*       prints user's error message, then follows it with ": ", then the system
*       error message, then a newline.  All output goes to stderr.  If user's
*       message is NULL or a null string, only the system error message is
*       printer.  If errno is weird, prints "Unknown error".
*
*Entry:
*       const wchar_t *wmessage - users message to prefix system error message
*
*Exit:
*       Prints message; no return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _wperror (
        const wchar_t *wmessage
        )
{
        int fh = 2;
        size_t size;
        char *amessage;

        /* convert WCS string into ASCII string */

        if ( wmessage && *wmessage )
        {
            size = wcslen(wmessage) + 1;

            if ( NULL == (amessage = (char *)_malloc_crt(size * sizeof(char))) )
                return;

            if ( 0 >= wcstombs(amessage, wmessage, size) )
            {
                _free_crt(amessage);
                return;
            }
        }
        else
            amessage = NULL;

#ifdef  _MT
        _lock_fh( fh );         /* acquire file handle lock */
        __try {
#endif

        if ( amessage )
        {
                _write_lk(fh,(char *)amessage,(unsigned)strlen(amessage));
                _write_lk(fh,": ",2);
        }

        _free_crt(amessage);    /* note: freeing NULL is legal and benign */

        amessage = _sys_err_msg( errno );
        _write_lk(fh,(char *)amessage,(unsigned)strlen(amessage));
        _write_lk(fh,"\n",1);

#ifdef  _MT
        }
        __finally {
            _unlock_fh( fh );   /* release file handle lock */
        }
#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wsearche.c ===
/***
*wsearche.c - find a file using paths from an environment variable (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	to search a set a directories specified by an environment variable
*	for a specified file name.  If found the full path name is returned.
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "searchen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wrt2err.c ===
/***
*wrt2err.c - write an LSTRING to stderr (Win32 version)
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module contains a routine __wrt2err that writes an LSTRING
*	(one byte length followed by the several bytes of the string)
*	to the standard error handle (2).  This is a helper routine used
*	for MATH error messages (and also FORTRAN error messages).
*
*Revision History:
*	06-30-89  PHG	module created, based on asm version
*	03-16-90  GJF	Made calling type _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	07-24-90  SBM	Removed '32' from API names
*	10-04-90  GJF	New-style function declarator.
*	12-04-90  SRW	Changed to include <oscalls.h> instead of <doscalls.h>
*	04-26-91  SRW	Removed level 3 warnings
*	07-18-91  GJF	Replaced call to DbgPrint with WriteFile to standard
*			error handle [_WIN32_].
*	04-06-93  SKS	Add __cdecl keyword
*	09-06-94  CFW	Remove Cruiser support.
*	12-03-94  SKS	Clean up OS/2 references
*	06-13-95  GJF	Replaced _osfhnd[] with _osfhnd() (macro referencing
*			field in ioinfo struct).
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>

/***
*__wrt2err(msg) - write an LSTRING to stderr
*
*Purpose:
*	Takes a pointer to an LSTRING which is to be written to standard error.
*	An LSTRING is a one-byte length followed by that many bytes for the
*	character string (as opposed to a null-terminated string).
*
*Entry:
*	char *msg = pointer to LSTRING to write to standard error.
*
*Exit:
*	Nothing returned.
*
*Exceptions:
*	None handled.
*
*******************************************************************************/

void __cdecl __wrt2err (
	char *msg
	)
{
	unsigned long length;		/* length of string to write */
	unsigned long numwritten;	/* number of bytes written */

	length = *msg++;		/* 1st byte is length */

	/* write the message to stderr */

	WriteFile((HANDLE)_osfhnd(2), msg, length, &numwritten, NULL);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wsplitpa.c ===
/***
*wsplitpt.c - break down path name into components (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	To provide support for accessing the individual components of an
*	arbitrary path name
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "splitpat.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wsetenv.c ===
/***
*setenv.c -set an environment variable in the environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines __crtwsetenv() - adds a new variable to environment.
*       Internal use only.
*
*Revision History:
*	11-30-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "setenv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wtombenv.c ===
/***
*wtombenv.c - convert wide environment block to multibyte
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __wtomb_environ(). Create a multibyte equivalent of
*       an existing wide character environment block.
*
*Revision History:
*       11-30-93  CFW   initial version
*       02-07-94  CFW   POSIXify.
*       01-10-95  CFW   Debug CRT allocs.
*       08-28-98  GJF   Use CP_ACP instead of CP_OEMCP.
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <dbgint.h>

/***
*__wtomb_environ - copy wide environment block to multibyte environment block
*
*Purpose:
*       Create a multibyte equivalent of an existing wide character
*       environment block.
*
*Entry:
*       Assume _wenviron (global pointer) points to existing wide
*       environment block.
*
*Exit:
*       If success, every wide environment variable has been added to
*       the multibyte environment block and returns 0.
*       If failure, returns -1.
*
*Exceptions:
*       If space cannot be allocated, returns -1.
*
*******************************************************************************/

int __cdecl __wtomb_environ (
        void
        )
{
        char *envp;
        wchar_t **wenvp = _wenviron;

        /*
         * For every environment variable in the multibyte environment,
         * convert it and add it to the wide environment.
         */

        while (*wenvp)
        {
            int size;

            /* find out how much space is needed */
            if ((size = WideCharToMultiByte(CP_ACP, 0, *wenvp, -1, NULL, 0, NULL, NULL)) == 0)
                return -1;

            /* allocate space for variable */
            if ((envp = (char *) _malloc_crt(size * sizeof(char))) == NULL)
                return -1;

            /* convert it */
            if (WideCharToMultiByte(CP_ACP, 0, *wenvp, -1, envp, size, NULL, NULL) == 0)
                return -1;

            /* set it - this is not primary call, so set primary == 0 */
            __crtsetenv(envp, 0);

            wenvp++;
        }

        return 0;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\w_cmp.c ===
/***
*w_cmp.c - W versions of CompareString.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either CompareStringA or CompareStringW depending on which is 
*       available
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       02-23-94  CFW   Use W flavor whenever possible.
*       03-31-94  CFW   Include awint.h.
*       05-09-94  CFW   Do not let CompareString compare past NULL.
*       06-03-94  CFW   Test for empty string early.
*       11/01-94  CFW   But not too early for MB strings.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-15-97  RDK   For narrow comparsion, try W version first so Windows NT
*                       can process nonANSI codepage correctly.
*       05-15-97  GJF   Split off from aw_cmp.c. Replaced use of _malloc_crt
*                       and _free_crt with _alloca. Also, detab-ed and cleaned
*                       up the code a bit.
*       05-27-98  GJF   Changed wcsncnt() so that it will never examine the
*                       (cnt + 1)-th byte of the string.
*       08-18-98  GJF   Use _malloc_crt if _alloca fails.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       08-23-00  GB    Fixed bug with non Ansi CP on Win9x.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <dbgint.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl wcsncnt - count wide characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before NULL.
*       If NULL not found in n chars, then return n.
*
*Entry:
*       const wchar_t *string   - start of string
*       int n                   - byte count
*
*Exit:
*       returns number of wide characaters from start of string to
*       NULL (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl wcsncnt (
        const wchar_t *string,
        int cnt
        )
{
        int n = cnt;
        wchar_t *cp = (wchar_t *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}

/***
*int __cdecl __crtCompareStringW - Get type information about a wide string.
*
*Purpose:
*  Internal support function. Assumes info in wide string format. Tries
*  to use NLS API call CompareStringW if available and uses CompareStringA
*  if it must. If neither are available it fails and returns 0.
*
*Entry:
*  LCID     Locale      - locale context for the comparison.
*  DWORD    dwCmpFlags  - see NT\Chicago docs
*  LPCWSTR  lpStringn   - wide string to be compared
*  int      cchCountn   - wide char (word) count (NOT including NULL)
*                       (-1 if NULL terminated)
*  int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*  Success: 1 - if lpString1 <  lpString2
*           2 - if lpString1 == lpString2
*           3 - if lpString1 >  lpString2
*  Failure: 0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtCompareStringW(
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCWSTR  lpString1,
        int      cchCount1,
        LPCWSTR  lpString2,
        int      cchCount2,
        int      code_page
        )
{
        static int f_use = 0;

        /* 
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */
    
        if (0 == f_use)
        {
            if (0 != CompareStringW(0, 0, L"\0", 1, L"\0", 1))
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /*
         * CompareString will compare past NULL. Must find NULL if in string
         * before cchCountn wide characters.
         */

        if (cchCount1 > 0)
            cchCount1= wcsncnt(lpString1, cchCount1);
        if (cchCount2 > 0)
            cchCount2= wcsncnt(lpString2, cchCount2);

        if (!cchCount1 || !cchCount2)
            return (cchCount1 - cchCount2 == 0) ? 2 :
                   (cchCount1 - cchCount2 < 0) ? 1 : 3;

        /* Use "W" version */

        if (USE_W == f_use)
        {
            return CompareStringW( Locale,
                                   dwCmpFlags,
                                   lpString1,
                                   cchCount1,
                                   lpString2,
                                   cchCount2 );
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            int buff_size1;
            int buff_size2;
            unsigned char *buffer1;
            unsigned char *buffer2;
            int retcode = 0;
            int malloc_flag1 = 0;
            int malloc_flag2 = 0;
            int AnsiCP;

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == Locale)
                Locale = __lc_handle[LC_CTYPE];
            if (0 == code_page)
                code_page = __lc_codepage;

            /*
             * Always use Ansi codepage with Ansi WinAPI because they use
             * Ansi codepage
             */
            if ( code_page != (AnsiCP = __ansicp(Locale)))
            {
                if (AnsiCP != -1)
                    code_page = AnsiCP;
            }

            /*
             * Convert strings and return the requested information.
             */

            /* find out how big a buffer we need (includes NULL if any) */
            if ( 0 == (buff_size1 = WideCharToMultiByte( code_page,
                                                         0,
                                                         lpString1,
                                                         cchCount1,
                                                         NULL,
                                                         0,
                                                         NULL,
                                                         NULL )) )
                return 0;

            /* allocate enough space for chars */
            __try {
                buffer1 = (unsigned char *)_alloca( buff_size1 * sizeof(char) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer1 = NULL;
            }

            if ( buffer1 == NULL ) {
                if ( (buffer1 = (unsigned char *)_malloc_crt(buff_size1 * sizeof(char)))
                     == NULL )
                    return 0;
                malloc_flag1++;
            }

            /* do the conversion */
            if ( 0 == WideCharToMultiByte( code_page, 
                                           0,
                                           lpString1,
                                           cchCount1,
                                           buffer1, 
                                           buff_size1,
                                           NULL,
                                           NULL ) )
                goto error_cleanup;

            /* find out how big a buffer we need (includes NULL if any) */
            if ( 0 == (buff_size2 = WideCharToMultiByte( code_page,
                                                         0,
                                                         lpString2, 
                                                         cchCount2, 
                                                         NULL, 
                                                         0, 
                                                         NULL, 
                                                         NULL )) )
                goto error_cleanup;

            /* allocate enough space for chars */
            __try {
                buffer2 = (unsigned char *)_alloca( buff_size2 * sizeof(char) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer2 = NULL;
            }

            if ( buffer2 == NULL ) {
                if ( (buffer2 = (unsigned char *)_malloc_crt(buff_size2 * sizeof(char)))
                     == NULL )
                    goto error_cleanup;
                malloc_flag2++;
            }

            /* do the conversion */
            if ( 0 != WideCharToMultiByte( code_page, 
                                           0,
                                           lpString2,
                                           cchCount2,
                                           buffer2,
                                           buff_size2,
                                           NULL,
                                           NULL ) )
                retcode = CompareStringA( Locale,
                                          dwCmpFlags,
                                          buffer1,
                                          buff_size1,
                                          buffer2,
                                          buff_size2 );

            if ( malloc_flag2 )
                _free_crt(buffer2);

error_cleanup:
            if ( malloc_flag1 )
                _free_crt(buffer1);

            return retcode;
        }
        else   /* f_use is neither USE_A nor USE_W */
            return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\wsetloca.c ===
/***
*wsetlocal.c - Contains the setlocale function (wchar_t version)
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the _wsetlocale() function.
*
*Revision History:
*       10-29-93  CFW   Module created.
*       01-03-94  CFW   Fix for NULL locale string.
*       02-07-94  CFW   POSIXify.
*       04-15-94  GJF   Made definition off outwlocale conditional on
*                       DLL_FOR_WIN32S.
*       07-26-94  CFW   Fix for bug #14663.
*       01-10-95  CFW   Debug CRT allocs.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#ifndef _POSIX_

#include <wchar.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <dbgint.h>

wchar_t * __cdecl _wsetlocale (
        int _category,
        const wchar_t *_wlocale
        )
{
        size_t size;
        char *inlocale = NULL;
        char *outlocale;
        static wchar_t *outwlocale = NULL;

        /* convert WCS string into ASCII string */

        if (_wlocale)
        {
            size = wcslen(_wlocale) + 1;
            if (NULL == (inlocale = (char *)_malloc_crt(size * sizeof(char))))
                return NULL;
            if (-1 == wcstombs(inlocale, _wlocale, size))
            {
                _free_crt (inlocale);
                return NULL;
            }
        }

        /* set the locale and get ASCII return string */

        outlocale = setlocale(_category, inlocale);
        _free_crt (inlocale);
        if (NULL == outlocale)
            return NULL;

        /* get space for WCS return value */

        _free_crt(outwlocale);

        if (-1 == (size = mbstowcs(NULL, outlocale, 0)))
            return NULL;

        size++;

        if (NULL == (outwlocale = (wchar_t *)_malloc_crt(size * sizeof(wchar_t))))
            return NULL;

        /* convert return value to WCS */

        if (-1 == mbstowcs(outwlocale, outlocale, size))
        {
            _free_crt(outwlocale);
            return NULL;
        }

        return outwlocale;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\w_loc.c ===
/***
*w_loc.c - W version of GetLocaleInfo.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetLocaleInfoA or GetLocaleInfoW depending on which is 
*       available
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       03-31-94  CFW   Include awint.h.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-15-97  RDK   For narrow locale info, try W version first so
*                       Windows NT can process nonANSI codepage correctly.
*       05-16-97  GJF   Split off W version into this file (w_loc.c). Replaced
*                       use of _malloc_crt/_free_crt with _alloca. Also,
*                       detab-ed and cleaned up the code.
*       08-19-98  GJF   Use _malloc_crt if _alloca fails.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl __crtGetLocaleInfoW - Get locale info and return it as a wide 
*       string
*
*Purpose:
*       Internal support function. Assumes info in wide string format. Tries
*       to use NLS API call GetLocaleInfoW if available (NT) and uses 
*       GetLocaleInfoA if it must (Chicago). If neither are available it fails
*       and returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       LCTYPE   LCType      - see NT\Chicago docs
*       LPWSTR   lpLCData    - pointer to memory to return data
*       int      cchData     - wide char (word) count of buffer (including 
*                              NULL) (if 0, lpLCData is not referenced, size
*                              needed is returned)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*       Success: the number of characters copied (including NULL).
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtGetLocaleInfoW(
        LCID    Locale,
        LCTYPE  LCType,
        LPWSTR  lpLCData,
        int     cchData,
        int     code_page
        )
{
        static int f_use = 0;

        /*
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */
    
        if (0 == f_use)
        {
            if (0 != GetLocaleInfoW(0, LOCALE_ILANGUAGE, NULL, 0))
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if (USE_W == f_use)
        {
            return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            int retval = 0;
            int buff_size;
            unsigned char *buffer;
            int malloc_flag = 0;

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == code_page)
                code_page = __lc_codepage;

            /* find out how big buffer needs to be */
            if (0 == (buff_size = GetLocaleInfoA(Locale, LCType, NULL, 0)))
                return 0;

            /* allocate buffer */
            __try {
                buffer = (unsigned char *)_alloca( buff_size * sizeof(char) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer = NULL;
            }

            if ( buffer == NULL ) {
                if ( (buffer = (unsigned char *)_malloc_crt(buff_size * sizeof(char)))
                     == NULL )
                    return 0;
                malloc_flag++;
            }

            /* get the info in ANSI format */
            if (0 == GetLocaleInfoA(Locale, LCType, buffer, buff_size))
                goto error_cleanup;

            if (0 == cchData)
            {
                /* find out how much space needed */
                retval = MultiByteToWideChar( code_page,
                                              MB_PRECOMPOSED,
                                              buffer,
                                              -1,
                                              NULL,
                                              0 );
            }
            else {
                /* convert into user buffer */
                retval = MultiByteToWideChar( code_page,
                                              MB_PRECOMPOSED,
                                              buffer,
                                              -1,
                                              lpLCData,
                                              cchData );
            }

error_cleanup:
            if ( malloc_flag )
                _free_crt(buffer);

            return retval;

        }
        else   /* f_use is neither USE_A nor USE_W */
            return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\w_map.c ===
/***
*w_map.c - W version of LCMapString.
*
*       Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use either LCMapStringA or LCMapStringW depending on which is available
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       02-23-94  CFW   Use W flavor whenever possible.
*       03-31-94  CFW   Include awint.h.
*       07-26-94  CFW   Bug fix #14730, LCMapString goes past NULLs.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-15-97  RDK   For narrow mapping, try W version first so Windows NT
*                       can process nonANSI codepage correctly.
*       03-16-97  RDK   Added error flag to __crtLCMapStringA.
*       05-09-97  GJF   Split off from aw_map.c. Revised to use _alloca
*                       instead of malloc. Also, reformatted.
*       05-27-98  GJF   Changed wcsncnt() so that it will never examine the
*                       (cnt + 1)-th byte of the string.
*       08-18-98  GJF   Use _malloc_crt if _alloca fails.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       08-23-00  GB    Fixed bug with non Ansi CP on Win9x.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl wcsncnt - count wide characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before
*       null. If null not found in n chars, then return n.
*
*Entry:
*       const wchar_t *string   - start of string
*       int n                - byte count
*
*Exit:
*       returns number of wide characaters from start of string to
*       null (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl wcsncnt (
        const wchar_t *string,
        int cnt
        )
{
        int n = cnt;
        wchar_t *cp = (wchar_t *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}

/***
*int __cdecl __crtLCMapStringW - Get type information about a wide string.
*
*Purpose:
*       Internal support function. Assumes info in wide string format. Tries
*       to use NLS API call LCMapStringW if available and uses LCMapStringA
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       DWORD    dwMapFlags  - see NT\Chicago docs
*       LPCWSTR  lpSrcStr    - pointer to string to be mapped
*       int      cchSrc      - wide char (word) count of input string 
*                              (including NULL if any)
*                              (-1 if NULL terminated) 
*       LPWSTR   lpDestStr   - pointer to memory to store mapping
*       int      cchDest     - wide char (word) count of buffer (including NULL)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*       NOTE:    if LCMAP_SORTKEY is specified, then cchDest refers to number 
*                of BYTES, not number of wide chars. The return string will be
*                a series of bytes with a NULL byte terminator.
*
*Exit:
*       Success: if LCMAP_SORKEY:
*                   number of bytes written to lpDestStr (including NULL byte 
*                   terminator)
*               else
*                   number of wide characters written to lpDestStr (including 
*                   NULL)
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtLCMapStringW(
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCWSTR  lpSrcStr,
        int      cchSrc,
        LPWSTR   lpDestStr,
        int      cchDest,
        int      code_page
        )
{
        static int f_use = 0;

        /* 
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */
    
        if (0 == f_use) {
            if (0 != LCMapStringW(0, LCMAP_LOWERCASE, L"\0", 1, NULL, 0))
                f_use = USE_W;
            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /*
         * LCMapString will map past NULL. Must find NULL if in string
         * before cchSrc wide characters.
         */
        if (cchSrc > 0)
            cchSrc = wcsncnt(lpSrcStr, cchSrc);

        /* Use "W" version */

        if (USE_W == f_use) {
            return LCMapStringW( Locale, dwMapFlags, lpSrcStr, cchSrc, 
                                 lpDestStr, cchDest );
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0) {

            int retval = 0;
            int inbuff_size;
            int outbuff_size;
            unsigned char *inbuffer;
            unsigned char *outbuffer;
            int malloc_flag1 = 0;
            int malloc_flag2 = 0;
            int AnsiCP = 0;

            /*
             * Convert string and return the requested information. Note that 
             * we are converting to a multibyte string so there is not a 
             * one-to-one correspondence between number of wide chars in the 
             * input string and the number of *bytes* in the buffer. However, 
             * there had *better be* a one-to-one correspondence between the 
             * number of wide characters and the number of multibyte characters 
             * (enforced by WC_SEPCHARS) in the buffer or the resulting mapped 
             * string will be worthless to the user.
             * 
             */

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == Locale)
                Locale = __lc_handle[LC_CTYPE];
            if (0 == code_page)
                code_page = __lc_codepage;

            /*
             * Always use Ansi codepage with Ansi WinAPI because they use
             * Ansi codepage
             */
            if ( code_page != (AnsiCP = __ansicp(Locale)))
            {
                if (AnsiCP != -1)
                    code_page = AnsiCP;
            }

            /* find out how big a buffer we need (includes NULL if any) */
            if ( 0 == (inbuff_size = WideCharToMultiByte( code_page, 
                                                          0,
                                                          lpSrcStr, 
                                                          cchSrc, 
                                                          NULL, 
                                                          0, 
                                                          NULL, 
                                                          NULL )) )
                return 0;

            /* allocate enough space for chars */
            __try {
                inbuffer = (unsigned char *)_alloca( inbuff_size * sizeof(char) );
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                _resetstkoflw();
                inbuffer = NULL;
            }

            if ( inbuffer == NULL ) {
                if ( (inbuffer = (unsigned char *)_malloc_crt(inbuff_size * sizeof(char)))
                     == NULL )
                    return 0;
                malloc_flag1++;
            }

            /* do the conversion */
            if ( 0 ==  WideCharToMultiByte( code_page, 
                                            0,
                                            lpSrcStr, 
                                            cchSrc, 
                                            inbuffer, 
                                            inbuff_size, 
                                            NULL, 
                                            NULL ) )
                goto error_cleanup;

            /* get size required for string mapping */
            if ( 0 == (outbuff_size = LCMapStringA( Locale, 
                                                    dwMapFlags, 
                                                    inbuffer, 
                                                    inbuff_size, 
                                                    NULL, 
                                                    0 )) )
                goto error_cleanup;

            /* allocate enough space for chars and NULL */
            __try {
                outbuffer = (unsigned char *)_alloca( outbuff_size * sizeof(char) );
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                _resetstkoflw();
                outbuffer = NULL;
            }

            if ( outbuffer == NULL ) {
                if ( (outbuffer = (unsigned char *)_malloc_crt(outbuff_size * sizeof(char)))
                     == NULL )
                    goto error_cleanup;
                malloc_flag2++;
            }

            /* do string mapping */
            if ( 0 == LCMapStringA( Locale, 
                                    dwMapFlags, 
                                    inbuffer, 
                                    inbuff_size, 
                                    outbuffer, 
                                    outbuff_size ) )
                goto error_cleanup;

            if (dwMapFlags & LCMAP_SORTKEY) {

                /* outbuff_size > cchDest is allowed */
                retval = outbuff_size;

                if (0 != cchDest)
                    /* SORTKEY returns BYTES, just copy */
                    strncpy( (char *)lpDestStr, 
                             (char *)outbuffer, 
                             cchDest < outbuff_size ? cchDest : outbuff_size );
            }
            else {
                if (0 == cchDest) {
                    /* get size required */
                    if ( 0 == (retval = MultiByteToWideChar( code_page, 
                                                             MB_PRECOMPOSED, 
                                                             outbuffer, 
                                                             outbuff_size, 
                                                             NULL, 
                                                             0 )) )
                        goto error_cleanup;
                } 
                else {
                    /* convert mapping */
                    if ( 0 == (retval = MultiByteToWideChar( code_page, 
                                                             MB_PRECOMPOSED, 
                                                             outbuffer, 
                                                             outbuff_size, 
                                                             lpDestStr, 
                                                             cchDest )) )
                        goto error_cleanup;
                }
            }

error_cleanup:
            if ( malloc_flag2 )
                _free_crt(outbuffer);

            if ( malloc_flag1 )
                _free_crt(inbuffer);

            return retval;
        }
        else   /* f_use is neither USE_A nor USE_W */
            return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\w_env.c ===
/***
*w_env.c - W version of GetEnvironmentStrings.
*
*       Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use GetEnvironmentStringsW if available, otherwise use A version.
*
*Revision History:
*       03-29-94  CFW   Module created.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       04-07-95  CFW   Create __crtGetEnvironmentStringsA.
*       07-03-95  GJF   Modified to always malloc a buffer for the 
*                       environment strings, and to free the OS's buffer.
*       06-10-96  GJF   Initialize aEnv and wEnv to NULL in
*                       __crtGetEnvironmentStringsA. Also, detab-ed.
*       05-14-97  GJF   Split off from aw_env.c.
*       03-03-98  RKP   Supported 64 bits
*       08-21-98  GJF   Use CP_ACP instead of __lc_codepage.
*       01-08-99  GJF   Changes for 64-bit size_t.
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

#define USE_W   1
#define USE_A   2

/***
*LPVOID __cdecl __crtGetEnvironmentStringsW - Get wide environment.
*
*Purpose:
*       Internal support function. Tries to use NLS API call
*       GetEnvironmentStringsW if available and uses GetEnvironmentStringsA
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       VOID
*
*Exit:
*       LPVOID - pointer to environment block
*
*Exceptions:
*
*******************************************************************************/

LPVOID __cdecl __crtGetEnvironmentStringsW(
        VOID
        )
{
        static int f_use = 0;
        void *penv = NULL;
        char *pch;
        wchar_t *pwch;
        wchar_t *wbuffer;
        int total_size = 0;
        int str_size;

        /*
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */

        if ( 0 == f_use )
        {
            if ( NULL != (penv = GetEnvironmentStringsW()) )
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if ( USE_W == f_use )
        {
            if ( NULL == penv )
                if ( NULL == (penv = GetEnvironmentStringsW()) )
                    return NULL;

            /* find out how big a buffer is needed */

            pwch = penv;
            while ( *pwch != L'\0' ) {
                if ( *++pwch == L'\0' )
                    pwch++;
            }

            total_size = (int)((char *)pwch - (char *)penv) +
                         (int)sizeof( wchar_t );

            /* allocate the buffer */

            if ( NULL == (wbuffer = _malloc_crt( total_size )) ) {
                FreeEnvironmentStringsW( penv );
                return NULL;
            }

            /* copy environment strings to buffer */

            memcpy( wbuffer, penv, total_size );

            FreeEnvironmentStringsW( penv );

            return (LPVOID)wbuffer;
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            /*
             * Convert strings and return the requested information.
             */
            if ( NULL == penv )
                if ( NULL == (penv = GetEnvironmentStringsA()) )
                    return NULL;

            pch = penv;

            /* find out how big a buffer we need */
            while ( *pch != '\0' )
            {
                if ( 0 == (str_size =
                      MultiByteToWideChar( CP_ACP,
                                           MB_PRECOMPOSED,
                                           pch,
                                           -1,
                                           NULL,
                                           0 )) )
                    return 0;

                total_size += str_size;
                pch += strlen(pch) + 1;
            }

            /* room for final NULL */
            total_size++;

            /* allocate enough space for chars */
            if ( NULL == (wbuffer = (wchar_t *)
                 _malloc_crt( total_size * sizeof( wchar_t ) )) )
            {
                FreeEnvironmentStringsA( penv );
                return NULL;
            }

            /* do the conversion */
            pch = penv;
            pwch = wbuffer;
            while (*pch != '\0')
            {
                if ( 0 == MultiByteToWideChar( CP_ACP,
                                               MB_PRECOMPOSED,
                                               pch,
                                               -1,
                                               pwch,
                                               total_size - (int)(pwch -
                                                 wbuffer) ) )
                {
                    _free_crt( wbuffer );
                    FreeEnvironmentStringsA( penv );
                    return NULL;
                }

                pch += strlen(pch) + 1;
                pwch += wcslen(pwch) + 1;
            }
            *pwch = L'\0';

            FreeEnvironmentStringsA( penv );
            
            return (LPVOID)wbuffer;

        }
        else   /* f_use is neither USE_A nor USE_W */
            return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\_wcserr.c ===
/***
*_wcserr.c - routine for indexing into system error list
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Returns system error message index by errno; conforms to the
*	XENIX standard, much compatibility with 1983 uniforum draft standard.
*	(wide char version of _strerror())
*
*Revision History:
*   11-30-99  GB    Module Created
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "_strerr.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\_strerr.c ===
/***
*_strerr.c - routine for indexing into system error list
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Returns system error message index by errno; conforms to the
*   XENIX standard, much compatibility with 1983 uniforum draft standard.
*
*Revision History:
*   02-24-87  JCR   Renamed this routine from "strerror" to "_strerror"
*                   for MS. The new "strerror" routine conforms to the
*                   ANSI interface.
*   11-10-87  SKS   Remove IBMC20 switch
*   12-11-87  JCR   Added "_LOAD_DS" to declaration
*   01-05-87  JCR   Mthread support
*   05-31-88  PHG   Merged DLL and normal versions
*   06-06-89  JCR   386 mthread support
*   11-20-89  GJF   Fixed copyright, indents. Removed unreferenced local.
*                   Added const attribute to type of message
*   03-13-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                   <cruntime.h> and removed #include <register.h>
*   07-25-90  SBM   Removed redundant include (stdio.h)
*   10-04-90  GJF   New-style function declarator.
*   07-18-91  GJF   Multi-thread support for Win32 [_WIN32_].
*   02-17-93  GJF   Changed for new _getptd().
*   04-06-93  SKS   Replace _CRTAPI* with __cdecl
*   09-06-94  CFW   Remove Cruiser support.
*   09-06-94  CFW   Replace MTHREAD with _MT.
*   01-10-95  CFW   Debug CRT allocs.
*   29-11-99  GB    Added support for wide char by adding _wcserror() 
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <errmsg.h>
#include <syserr.h>
#include <string.h>
#include <tchar.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>

/* Max length of message = user_string(94)+system_string+2 */
/* [NOTE: The mthread error message buffer is shared by both strerror
   and _strerror so must be the max length of both. */
#define _ERRMSGLEN_ 94+_SYS_MSGMAX+2

#ifdef _UNICODE
#define _terrmsg    _werrmsg
#else
#define _terrmsg    _errmsg
#endif


/***
*char *_strerror(message) - get system error message
*
*Purpose:
*   builds an error message consisting of the users error message
*   (the message parameter), followed by ": ", followed by the system
*   error message (index through errno), followed by a newline.  If
*   message is NULL or a null string, returns a pointer to just
*   the system error message.
*
*Entry:
*   char *message - user's message to prefix system error message
*
*Exit:
*   returns pointer to static memory containing error message.
*   returns NULL if malloc() fails in multi-thread versions.
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * __cdecl __wcserror(
#else
char * __cdecl _strerror (
#endif
    REG1 const _TCHAR *message
    )
{
#ifdef  _MT

    _ptiddata ptd = _getptd();
    _TCHAR *bldmsg;

#else

    static _TCHAR bldmsg[_ERRMSGLEN_];

#endif


#ifdef  _MT

    /* Use per thread buffer area (malloc space, if necessary) */
    /* [NOTE: This buffer is shared between _strerror and streror.] */

    if ( (ptd->_terrmsg == NULL) && ((ptd->_terrmsg =
            _malloc_crt(_ERRMSGLEN_ * sizeof(_TCHAR))) == NULL) )
            return(NULL);
    bldmsg = ptd->_terrmsg;

#endif

    /* Build the error message */

    bldmsg[0] = '\0';

    if (message && *message) {
        _tcscat( bldmsg, message );
        _tcscat( bldmsg, _T(": "));
    }

#ifdef _UNICODE
    mbstowcs(bldmsg + wcslen(bldmsg), _sys_err_msg( errno ), _ERRMSGLEN_ - wcslen(bldmsg));
#else
    strcat( bldmsg, _sys_err_msg( errno ) );
#endif
    return( _tcscat( bldmsg, _T("\n")) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\amd64\chandler.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    chandler.c

Abstract:

    This module implements the C specific exception handler that provides
    structured condition handling for the C language.

Author:

    David N. Cutler (davec) 28-Oct-2000

Environment:

    Any mode.

--*/

#include "nt.h"

EXCEPTION_DISPOSITION
__C_specific_handler (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
    )

/*++

Routine Description:

    This function scans the scope tables associated with the specified
    procedure and calls exception and termination handlers as necessary.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    EstablisherFrame - Supplies a pointer to frame of the establisher function.

    ContextRecord - Supplies a pointer to a context record.

    DispatcherContext - Supplies a pointer to the exception dispatcher or
        unwind dispatcher context.

Return Value:

    If an exception is being dispatched and the exception is handled by one
    of the exception filter routines, then there is no return from this
    routine and RtlUnwind is called. Otherwise, an exception disposition
    value of continue execution or continue search is returned.

    If an unwind is being dispatched, then each termination handler is called
    and a value of continue search is returned.

--*/

{

    ULONG64 ControlPc;
    PEXCEPTION_FILTER ExceptionFilter;
    EXCEPTION_POINTERS ExceptionPointers;
    ULONG64 ImageBase;
    ULONG Index;
    PSCOPE_TABLE ScopeTable;
    ULONG64 TargetPc;
    PTERMINATION_HANDLER TerminationHandler;
    LONG Value;

    //
    // Get the image base address. compute the relative address of where
    // control left the establisher, and get the address of the scope table.
    //

    ImageBase =  DispatcherContext->ImageBase;
    ControlPc = DispatcherContext->ControlPc - ImageBase;
    ScopeTable = (PSCOPE_TABLE)(DispatcherContext->HandlerData);

    //
    // If an unwind is not in progress, then scan the scope table and call
    // the appropriate exception filter routines. Otherwise, scan the scope
    // table and call the appropriate termination handlers using the target
    // PC obtained from the dispatcher context.
    // are called.
    //

    if (IS_DISPATCHING(ExceptionRecord->ExceptionFlags)) {

        //
        // Scan the scope table and call the appropriate exception filter
        // routines.
        //

        ExceptionPointers.ExceptionRecord = ExceptionRecord;
        ExceptionPointers.ContextRecord = ContextRecord;
        for (Index = 0; Index < ScopeTable->Count; Index += 1) {
            if ((ControlPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                (ControlPc < ScopeTable->ScopeRecord[Index].EndAddress) &&
                (ScopeTable->ScopeRecord[Index].JumpTarget != 0)) {

                //
                // If the Call the exception filter routine.
                //

                if (ScopeTable->ScopeRecord[Index].HandlerAddress == 1) {
                    Value = EXCEPTION_EXECUTE_HANDLER;

                } else {
                    ExceptionFilter =
                        (PEXCEPTION_FILTER)(ScopeTable->ScopeRecord[Index].HandlerAddress + ImageBase);

                    Value = (ExceptionFilter)(&ExceptionPointers, EstablisherFrame);
                }

                //
                // If the return value is less than zero, then dismiss the
                // exception. Otherwise, if the value is greater than zero,
                // then unwind to the target exception handler. Otherwise,
                // continue the search for an exception filter.
                //

                if (Value < 0) {
                    return ExceptionContinueExecution;

                } else if (Value > 0) {
                    RtlUnwindEx(EstablisherFrame,
                                (PVOID)(ScopeTable->ScopeRecord[Index].JumpTarget + ImageBase),
                                ExceptionRecord,
                                (PVOID)((ULONG64)ExceptionRecord->ExceptionCode),
                                DispatcherContext->ContextRecord,
                                DispatcherContext->HistoryTable);
                }
            }
        }

    } else {

        //
        // Scan the scope table and call the appropriate termination handler
        // routines.
        //

        TargetPc = DispatcherContext->TargetIp - ImageBase;
        for (Index = 0; Index < ScopeTable->Count; Index += 1) {
            if ((ControlPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                (ControlPc < ScopeTable->ScopeRecord[Index].EndAddress)) {

                //
                // If the target PC is within the same scope as the control PC,
                // then this is an uplevel goto out of an inner try scope or a
                // long jump back into a try scope. Terminate the scan for a
                // termination handler.
                //
                // N.B. The target PC can be just beyond the end of the scope,
                //      in which case it is a leave from the scope.
                //


                if ((TargetPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                   (TargetPc <= ScopeTable->ScopeRecord[Index].EndAddress)) {
                    break;

                } else {

                    //
                    // If the scope table entry describes an exception filter
                    // and the associated exception handler is the target of
                    // the unwind, then terminate the scan for termination
                    // handlers. Otherwise, if the scope table entry describes
                    // a termination handler, then record the address of the
                    // end of the scope as the new control PC address and call
                    // the termination handler.
                    //

                    if (ScopeTable->ScopeRecord[Index].JumpTarget != 0) {
                        if (TargetPc == ScopeTable->ScopeRecord[Index].JumpTarget) {
                            break;
                        }

                    } else {
                        DispatcherContext->ControlPc =
                            ImageBase + ScopeTable->ScopeRecord[Index].EndAddress;

                        TerminationHandler =
                            (PTERMINATION_HANDLER)(ScopeTable->ScopeRecord[Index].HandlerAddress + ImageBase);

                        (TerminationHandler)(TRUE, EstablisherFrame);
                    }
                }
            }
        }
    }

    //
    // Continue search for exception or termination handlers.
    //

    return ExceptionContinueSearch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\w_str.c ===
/***
*w_str.c - W version of GetStringType.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetStringTypeA or GetStringTypeW depending on which is
*       unstubbed.
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       10-22-93  CFW   Remove bad verification test from "A" version.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       02-23-94  CFW   Use W flavor whenever possible.
*       03-31-94  CFW   Include awint.h.
*       04-18-94  CFW   Use lcid value if passed in.
*       04-18-94  CFW   Use calloc and don't test the NULL.
*       10-24-94  CFW   Must verify GetStringType return.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-15-97  RDK   For narrow string type, try W version first so
*                       Windows NT can process nonANSI codepage correctly.
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       05-12-97  GJF   Split off from old aw_str.c and moved into a separate
*                       file. Revised to use _alloca instead of malloc. Also,
*                       removed some silly code and reformatted.
*       08-19-98  GJF   Use _malloc_crt if _alloca fails.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       08-23-00  GB    Fixed bug with non Ansi CP on Win9x.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl __crtGetStringTypeW - Get type information about a wide string.
*
*Purpose:
*       Internal support function. Assumes info in wide string format. Tries
*       to use NLS API call GetStringTypeW if available and uses GetStringTypeA
*       if it must. If neither are available it fails and returns FALSE.
*
*Entry:
*       DWORD    dwInfoType  - see NT\Chicago docs
*       LPCWSTR  lpSrcStr    - wide string for which character types are 
*                              requested
*       int      cchSrc      - wide char (word) count of lpSrcStr (including 
*                              NULL if any)
*       LPWORD   lpCharType  - array to receive character type information
*                              (must be same size as lpSrcStr)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*       int      lcid        - for A call, specify LCID, If 0, use 
*                              __lc_handle[LC_CTYPE].
*
*Exit:
*       Success: TRUE
*       Failure: FALSE
*
*Exceptions:
*
*******************************************************************************/

BOOL __cdecl __crtGetStringTypeW(
        DWORD    dwInfoType,
        LPCWSTR  lpSrcStr,
        int      cchSrc,
        LPWORD   lpCharType,
        int      code_page,
        int      lcid
        )
{                      
        static int f_use = 0;

        /* 
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */

        if (0 == f_use)
        {
            unsigned short dummy;

            if (0 != GetStringTypeW(CT_CTYPE1, L"\0", 1, &dummy))
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if (USE_W == f_use)
        {
            return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            int buff_size;
            BOOL retbool;
            unsigned char *buffer;
            WORD * pwCharInfo;
            int malloc_flag1 = 0;
            int malloc_flag2 = 0;
            int AnsiCP;

            /*
             * Convert string and return the requested information. Note that 
             * we are converting to a multibyte string so there is not a 
             * one-to-one correspondence between number of wide chars in the 
             * input string and the number of *bytes* in the buffer. However, 
             * there had *better be* a one-to-one correspondence between the 
             * number of wide characters and the number of WORDs in the
             * return buffer.
             */

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == lcid)
                lcid = __lc_handle[LC_CTYPE];
            if (0 == code_page)
                code_page = __lc_codepage;

            /*
             * Always use Ansi codepage with Ansi WinAPI because they use
             * Ansi codepage
             */
            if ( code_page != (AnsiCP = __ansicp(lcid)))
            {
                if (AnsiCP != -1)
                    code_page = AnsiCP;
            }

            /* find out how big a buffer we need */
            if ( 0 == (buff_size = WideCharToMultiByte( code_page,
                                                        0,
                                                        lpSrcStr,
                                                        cchSrc,
                                                        NULL,
                                                        0,
                                                        NULL,
                                                        NULL )) )
                return FALSE;

            /* allocate enough space for chars */
            __try {
                buffer = (unsigned char *)_alloca( sizeof(char) * buff_size );
                (void)memset( buffer, 0, sizeof(char) * buff_size );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer = NULL;
            }

            if ( buffer == NULL ) {
                if ( (buffer = (unsigned char *)_calloc_crt(sizeof(char), buff_size))
                    == NULL )
                    return FALSE;
                malloc_flag1++;
            }

            /* do the conversion */
            if ( 0 == WideCharToMultiByte( code_page, 
                                           0,
                                           lpSrcStr,
                                           cchSrc, 
                                           buffer,
                                           buff_size,
                                           NULL,
                                           NULL ) )
                goto error_cleanup;

            /* allocate enough space for result (+1 for sanity check) */
            __try {
                pwCharInfo = (WORD *)_alloca( sizeof(WORD) * (buff_size + 1) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                pwCharInfo = NULL;
            }

            if ( pwCharInfo == NULL ) {
                if ( (pwCharInfo = (WORD *)_malloc_crt(sizeof(WORD) * (buff_size + 1)))
                    == NULL )
                    goto error_cleanup;
                malloc_flag2++;
            }

            /* do we use default lcid */
            if (0 == lcid)
                lcid = __lc_handle[LC_CTYPE];

            /* set to known value */
            pwCharInfo[cchSrc - 1] = pwCharInfo[cchSrc] = 0xFFFF;

            /* obtain result */
            retbool = GetStringTypeA( lcid, dwInfoType, buffer, buff_size,
                                      pwCharInfo );

            /*
             * GetStringTypeA does not reveal how many WORDs have been
             * modifed - to be safe we use another buffer and then
             * verify that EXACTLY cchSrc WORDs were modified. Note that
             * not all multibyte LCID/codepage combos are guaranteed to work.
             */
            if ( (pwCharInfo[cchSrc - 1] == 0xFFFF) || (pwCharInfo[cchSrc] != 0xFFFF) )
                retbool = FALSE;
            else
                memmove(lpCharType, pwCharInfo, cchSrc * sizeof(WORD));

            if ( malloc_flag2 )
                _free_crt(pwCharInfo);

error_cleanup:
            if ( malloc_flag1 )
                _free_crt(buffer);

            return retbool;
        }
        else   /* f_use is neither USE_A nor USE_W */
            return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\amd64\jmpuwind.asm ===
title   "Jump Unwind"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   jmpunwind.asm
;
; Abstract:
;
;   This module implements the AMD64 specific routine to perform jump unwind.
;
; Author:
;
;   David N. Cutler (davec) 22-Dec-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        extern  RtlUnwindEx:proc

        subttl  "Jump Unwind"
;++
;
; VOID
; _local_unwind (
;     IN PVOID TargetFrame,
;     IN PVOID TargetIp
;     )
;
; Routine Description:
;
;    This function performs a transfer of control to unwind for local unwinds.
;
; Arguments:
;
;    TargetFrame (rcx) - Supplies the establisher frame pointer of the
;        target of the unwind.
;
;    TargetIp (rdx) - Supplies the target instruction address where control
;        is to be transferred to after the unwind operation is complete.
;
; Return Value:
;
;    None.
;
;--

        NESTED_ENTRY _local_unwind, _TEXT$00

	alloc_stack (CONTEXT_FRAME_LENGTH + 8) ; allocate stack 

        END_PROLOGUE

;
; The first two arguments to the unwind routine are the same as the two
; arguments to this routine.
;

        xor     r8, r8                  ; set NULL exception record address
        xor     r9, r9                  ; set zero return value

;
; The context frame has space allocated for six argument home addresses.
;

        mov     CxP5Home[rsp], rsp      ; set context frame address argument
        mov     CxP6Home[rsp], r8       ; set NULL history table address
        call    RtlUnwindEx             ; perform unwind operation
        add     rsp, CONTEXT_FRAME_LENGTH + 8 ; deallocate stack frame
        ret                             ; return

        NESTED_END _local_unwind, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\amd64\longjmp.asm ===
title   "Long Jump"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   longjmp.asm
;
; Abstract:
;
;   This module implements the AMD64 specific routine to perform a long
;   jump.
;
;   N.B. This routine conditionally provides unsafe handling of long jump if
;        structured exception handling is not being used. The determination
;        is made based on the contents of the jump buffer.
;
; Author:
;
;   David N. Cutler (davec) 4-Jul-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        extern  RtlUnwindEx:proc

        subttl  "Long Jump"
;++
;
; VOID
; longjmp (
;     IN jmp_buf Jumpbuffer
;     IN int ReturnValue
;     )
;
; Routine Description:
;
;    This function performs a long jump to the context specified by the
;    jump buffer.
;
; Arguments:
;
;    JumpBuffer (rcx) - Supplies the address of a jump buffer.
;
;    ReturnValue (edx) - Supplies the value that is to be returned to the
;        caller of set jump.
;
; Return Value:
;
;    None.
;
;--

LjFrame struct
        P1Home  dq ?                    ; target frame home address
        P2Home  dq ?                    ; target IP home address
        P3Home  dq ?                    ; exception record address home address
        P4Home  dq ?                    ; return value home address
        P5Home  dq ?                    ; context record address parameter
        P6Home  dq ?                    ; history table address
        Excode  dd ?                    ; exception code
        Flags   dd ?                    ; exception flags
        Associate dq ?                  ; associated exception record
        Address dq ?                    ; exception address
        Number  dd ?                    ; number of parameters
        Fill1   dd ?                    ; fill to qword boundary
        Jmpbuf  dq ?                    ; address of jump buffer
        Fill2   dq ?                    ; align to 0 mod 16
        Context db CONTEXT_FRAME_LENGTH dup (?) ; context record
        Fill3   dq ?                    ; align to 8 mod 16
LjFrame ends

        NESTED_ENTRY longjmp, _TEXT$00

        alloc_stack (sizeof LjFrame)    ; allocate stack frame

        END_PROLOGUE

        test    rdx, rdx                ; test if return value nonzero
        jnz     short LJ10              ; if nz, return value not zero
        inc     rdx                     ; set nonzero return value
LJ10:   xor     r10, r10                ; generate zero value
        cmp     JbFrame[rcx], r10       ; check for safe/unsafe long jump
        jne     LJ20                    ; if ne, safe long jump

;
; Provide unsafe handling of long jump.
;


        mov     rax, rdx                ; set return value
        mov     rbx, JbRbx[rcx]         ; restore nonvolatile integer registers
        mov     rsi, JbRsi[rcx]         ;
        mov     rdi, JbRdi[rcx]         ;
        mov     r12, JbR12[rcx]         ;
        mov     r13, JbR13[rcx]         ;
        mov     r14, JbR14[rcx]         ;
        mov     r15, JbR15[rcx]         ;

        movdqa  xmm6, JbXmm6[rcx]       ; save nonvolatile floating registers
        movdqa  xmm7, JbXmm7[rcx]       ;
        movdqa  xmm8, JbXmm8[rcx]       ;
        movdqa  xmm9, JbXmm9[rcx]       ;
        movdqa  xmm10, JbXmm10[rcx]     ;
        movdqa  xmm11, JbXmm11[rcx]     ;
        movdqa  xmm12, JbXmm12[rcx]     ;
        movdqa  xmm13, JbXmm13[rcx]     ;
        movdqa  xmm14, JbXmm14[rcx]     ;
        movdqa  xmm15, JbXmm15[rcx]     ;
        mov     rdx, JbRip[rcx]         ; get return address
        mov     rbp, JbRbp[rcx]         ; set frame pointer
        mov     rsp, JbRsp[rcx]         ; set stack pointer
        jmp     rdx                     ; jump back to set jump site

;
; Provide safe handling of long jump.
;
; An exception record is constructed that contains a long jump status
; code and the first exception information parameter is a pointer to
; the jump buffer.
;

LJ20:   mov     LjFrame.Excode[rsp], STATUS_LONGJUMP ; set exception code
        mov     LjFrame.Flags[rsp], r10d ; zero exception flags
        mov     LjFrame.Associate[rsp], r10 ; zero associated record address
        mov     LjFrame.Address[rsp], r10 ; zero exception address
        mov     LjFrame.P6Home[rsp], r10 ; set address of history table
        inc     r10d                    ; set number of parameters
        mov     LjFrame.Number[rsp], r10d ;
        mov     LjFrame.Jmpbuf[rsp], rcx ; set jump buffer address
        lea     rax, LjFrame.Context[rsp] ; set address of context record
        mov     LjFrame.P5Home[rsp], rax ;
        mov     r9, rdx                 ; set return value
        lea     r8, LjFrame.Excode[rsp] ; set address of exception record
        mov     rdx, JbRip[rcx]         ; set target IP
        mov     rcx, JbFrame[rcx]       ; set target frame
        call    RtlUnwindEx             ; unwind to set jump target
        jmp     short LJ20              ;

        NESTED_END longjmp, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\amd64\setjmp.asm ===
title   "Set Jump Buffer"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   setjmp.asm
;
; Abstract:
;
;   This module implements the AMD64 specific routine to perform unsafe set
;   jump.
;
;   N.B. This module conditionally provides unsafe handling of setjmp if
;        structured exception handling is not being used. The determination
;        is made based on whether an uninitialized variable has been set to
;        the address of the safe set jump routine.
;
; Author:
;
;   David N. Cutler (davec) 3-Nov-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

;
; Define variable that will cause setjmp/longjmp to be safe or unsafe with
;  respect to structured exception handling.
;

_setjmp_ segment para common 'DATA'

_setjmpexused	dq	?		;

_setjmp_ ends

        subttl  "Unsafe Set Jump"
;++
;
; int
; _setjmp (
;     IN jmp_buf JumpBuffer,
;     IN ULONG64 FrameBase
;     )
;
; Routine Description:
;
;    This function saved the current nonvolatile register state in the
;    specified jump buffer and returns a function vlaue of zero.
;
; Arguments:
;
;    JumpBuffer (rcx) - Supplies a pointer to a jump buffer.
;
;    Framebase (rdx) - Supplies the base of the caller frame.
;
; Return Value:
;
;    A value of zero is returned.
;
;--

        LEAF_ENTRY _setjmp, _TEXT$00

        mov     rax, _setjmpexused      ; get address of safe set jump routine
        test    rax, rax                ; test is safe set jump specified
        jnz     SJ10                    ; if nz, safe set jump specified

;
; Structured exception handling is not being used - use unsafe set jump.
;

        mov     JbFrame[rcx], rax       ; zero frame register
        mov     JbRbx[rcx], rbx         ; save nonvolatile integer registers
        mov     JbRbp[rcx], rbp         ;
        mov     JbRsi[rcx], rsi         ;
        mov     JbRdi[rcx], rdi         ;
        mov     JbR12[rcx], r12         ;
        mov     JbR13[rcx], r13         ;
        mov     JbR14[rcx], r14         ;
        mov     JbR15[rcx], r15         ;
        lea     r8, 8[rsp]              ; save caller stack pointer
        mov     JbRsp[rcx], r8          ;
        mov     r8, [rsp]               ; save caller return address
        mov     JbRip[rcx], r8          ;

        movdqa  JbXmm6[rcx], xmm6       ; save nonvolatile floating registers
        movdqa  JbXmm7[rcx], xmm7       ;
        movdqa  JbXmm8[rcx], xmm8       ;
        movdqa  JbXmm9[rcx], xmm9       ;
        movdqa  JbXmm10[rcx], xmm10     ;
        movdqa  JbXmm11[rcx], xmm11     ;
        movdqa  JbXmm12[rcx], xmm12     ;
        movdqa  JbXmm13[rcx], xmm13     ;
        movdqa  JbXmm14[rcx], xmm14     ;
        movdqa  JbXmm15[rcx], xmm15     ;
        ret                             ; return

;
; Structured exception handling is being used - use safe set jump.
;

SJ10:   jmp     rax                     ; execute safe set jump

        LEAF_END _setjmp, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\amd64\setjmpex.asm ===
title   "Set Jump Buffer"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   setjmpex.asm
;
; Abstract:
;
;   This module implements the AMD64 specific routine to perform safe set
;   jump.
;
; Author:
;
;   David N. Cutler (davec) 3-Nov-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

;
; Define variable that will cause setjmp/longjmp to be safe or unsafe with
; respect to structured exception handling.
;

_setjmp_ segment para common 'DATA'

        dq      _setjmpex               ;

_setjmp_ ends

        subttl  "Safe Set Jump"
;++
;
; int
; _setjmpex (
;     IN jmp_buf JumpBuffer,
;     IN ULONG64 FrameBase
;     )
;
; Routine Description:
;
;    This function saves the current nonvolatile register state in the
;    specified jump buffer and returns a function vlaue of zero.
;
; Arguments:
;
;    JumpBuffer (rcx) - Supplies a pointer to a jump buffer.
;
;    FrameBase (rdx) - Supplies the base address of the caller frame.
;
; Return Value:
;
;    A value of zero is returned.
;
;--

        LEAF_ENTRY _setjmpex, _TEXT$00

;
; Save the nonvolatile register state so these registers to be restored to
; their value at the call to setjmp. If these registers were not saved, then
; they would be restored to their current value in the target function which
; would be incorrect.
;

        mov     JbFrame[rcx], rdx       ; set frame base
        mov     JbRbx[rcx], rbx         ; save nonvolatile integer registers
        mov     JbRbp[rcx], rbp         ;
        mov     JbRsi[rcx], rsi         ;
        mov     JbRdi[rcx], rdi         ;
        mov     JbR12[rcx], r12         ;
        mov     JbR13[rcx], r13         ;
        mov     JbR14[rcx], r14         ;
        mov     JbR15[rcx], r15         ;
        lea     r8, 8[rsp]              ; save caller stack pointer
        mov     JbRsp[rcx], r8          ;
        mov     r8, [rsp]               ; save caller return address
        mov     JbRip[rcx], r8          ;

        movdqa  JbXmm6[rcx], xmm6       ; save nonvolatile floating registers
        movdqa  JbXmm7[rcx], xmm7       ;
        movdqa  JbXmm8[rcx], xmm8       ;
        movdqa  JbXmm9[rcx], xmm9       ;
        movdqa  JbXmm10[rcx], xmm10     ;
        movdqa  JbXmm11[rcx], xmm11     ;
        movdqa  JbXmm12[rcx], xmm12     ;
        movdqa  JbXmm13[rcx], xmm13     ;
        movdqa  JbXmm14[rcx], xmm14     ;
        movdqa  JbXmm15[rcx], xmm15     ;
        xor     eax, eax                ; set return value
        ret                             ; return

        LEAF_END _setjmpex, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\longjmp.asm ===
;***
;longjmp.asm
;
;	Copyright (C) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmp(), longjmp() & raisex() routines;
;	split from exsup.asm for granularity purposes.
;
;Notes:
;
;Revision History:
;	01-12-94  PML	Split from setjmp.asm, added C9.0 generic EH
;			callback for unwind.
;	01-11-95  SKS	Remove MASM 5.X support
;	04-11-95  JWM	Added NLG support
;	06-07-95  JWM	__SetNLGCode() used, for multithread safety.
;	06-20-95  JWM	__SetNLGCode() removed, code passed on stack (11803).
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

BeginDATA

COMM    __setjmpexused:dword

EndDATA

extern __NLG_Destination:_NLG_INFO

assumes DS,DATA
assumes FS,DATA

BeginCODE

; Following symbols defined in exsup.asm, sehsupp.c
extrn __except_list:near
extrn __global_unwind2:near
extrn __local_unwind2:near
extrn __rt_probe_read4@4:near
extrn __NLG_Notify:near
;EXTERN C __SetNLGCode:near

; int
; longjmp (
;	IN jmp_buf env
;	IN int val)
;
; Routine Description:
;
;	Restore the stack and register environment saved by _setjmp.
;	Reloads callee-save registers and stack pointer to that saved in
;	the jmp_buf, then returns to the point of the _setjmp call.
;
;	If exception unwinding is enabled, also reload the exception state
;	from the jmp_buf by doing an unwind (both global and local) back
;	to the old state.  Do so by checking for a new-format (C9.0)
;	jmp_buf, and call the EH longjmp unwinder saved therein if
;	found, else assume a C8.0-vintage jmp_buf and SEH.
;
; Arguments:
;
;	env - Address of the buffer holding the reload state
;	val - Value to return from the _setjmp callsite (if nonzero)
;
; Return Value:
;
;	None.  longjmp does not return directly, but instead continues
;	execution from the point of the _setjmp used to initialize the
;	jmp_buf.  That call will return the 'val' parameter if nonzero,
;	else a one.

cProc longjmp,<C,PUBLIC>
cBegin
        mov     ebx, [esp+4]            ;get jmp_buf

        ;restore ebp before possible call to local_unwind-er
        ; the call to global/local unwind will preserve this (callee save).
	mov	ebp, [ebx.saved_ebp]	;set up bp
ifdef	_NTSDK
	cmp	__setjmpexused, 0
        je      short _lj_no_unwind
endif
        mov     esi, [ebx.saved_xregistration]
        cmp     esi, dword ptr fs:__except_list
	je	short _lj_local_unwind

        push    esi
        call    __global_unwind2
        add     esp,4

_lj_local_unwind:
        cmp     esi, 0
	je	short _lj_no_unwind

	; Check if called with old or new format jmp_buf.  Look for the
	; version cookie that's only present in the new format.
	lea	eax, [ebx.version_cookie]
	push	eax
	call	__rt_probe_read4@4
	or	eax, eax
	jz	short _lj_old_unwind
	mov	eax, [ebx.version_cookie]
	cmp	eax, JMPBUF_COOKIE
	jnz	short _lj_old_unwind

	; Called with a new-format jmp_buf.  Call unwind function supplied
	; to the jmp_buf at setjmp time.
	mov	eax, [ebx.unwind_func]
	or	eax, eax
	jz	short _lj_no_unwind	;no local unwind necessary
	push	ebx
	call	eax
	jmp	short _lj_no_unwind

	; Called with an old-format jmp_buf.  Duplicate old longjmp behavior,
	; assuming there's a C8.0 SEH node at top.
_lj_old_unwind:
        mov	eax, [ebx.saved_trylevel]
	push	eax
        push    esi
        call    __local_unwind2
        add     esp, 8

_lj_no_unwind:
        push    0h
        mov     eax, [ebx.saved_return]
        call    __NLG_Notify

        mov     edx, ebx
        mov     ebx, [edx.saved_ebx]    ;recover registers...
        mov     edi, [edx.saved_edi]
        mov     esi, [edx.saved_esi]

        mov     eax, [esp+8]		;load the return value
	cmp	eax, 1			;make sure it's not 0
	adc	eax, 0

        mov     esp, [edx.saved_esp]    ;here, sp gets scorched
        add     esp, 4                  ;punt the (old) return address
        jmp     [edx.saved_return]      ;return
cEnd

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\chkesp.c ===
/***
*chkesp.c
*
*       Copyright (c) 1997-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines _chkesp() and other run-time error checking support routines.
*
*Revision History:
*       05-22-98  JWM   Support added for KFrei's RTC work; header added.
*       07-28-98  JWM   RTC update.
*       10-30-98  KBF   Quit messing with the CRT's Debug Heap flags
*       11-19-98  KBF   Added stuff to handle multiple callbacks
*       11-24-98  KBF   Added 3rd callback for memory/string function checks
*       12-03-98  KBF   Added 4th callback to disable mem/string function
*                       checks temporarily
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*
*******************************************************************************/

#include <malloc.h>
#include <dbgint.h>
#include <windows.h>
#include <rtcsup.h>

/***
*void __chkesp() - check to make sure esp was properly restored
*
*Purpose:
*       A debugging check called after every function call to make sure esp has
*       the same value before and after the call.
*
*Entry:
*       condition code: the ZF flag should be cleared if esp has changed
*
*Return:
*       <void>
*
*******************************************************************************/
void __declspec(naked) _chkesp() {
    __asm {
        jne esperror    ; 
        ret

    esperror:
        ; function prolog

        push ebp
        mov ebp, esp
        sub esp, __LOCAL_SIZE

        push eax        ; save the old return value
        push edx

        push ebx
        push esi
        push edi
    }

    /**
     * let the user know that there is a problem, and allow them to debug the
     * program.
     */
#ifdef _DEBUG
    if (_CrtDbgReport(_CRT_ERROR, __FILE__, __LINE__, "", 
        "The value of ESP was not properly saved across a function "
        "call.  This is usually a result of calling a function "
        "declared with one calling convention with a function "
        "pointer declared with a different calling convention. "     ) == 1) 
#endif    
    {

        /* start the debugger */
        __asm int 3;
    }

    __asm {
        ; function epilog

        pop edi
        pop esi
        pop ebx

        pop edx         ; restore the old return value
        pop eax

        mov esp, ebp
        pop ebp
        ret
    }
}

#ifdef  _RTC
/***
*void __CRT_RTC_INIT() - Initialize the RTC subsystem (in section .CRT$XIC)
*
*Purpose:
*       Setup anything involving the RTC subsystem
*
*Entry:
*       The allocation hook - function to use to allocate memory
*       The release hook - function to use to release memory
*
*Return:
*       The default error reporting function
*
*******************************************************************************/

#ifdef _RTC_ADVMEM
// This stuff is currently disabled
#define mk_list(type)                   \
    typedef struct type##_l {           \
        int version;                    \
        type##_hook_fp funcptr;         \
    } type##_l;                         \
    static struct {                     \
        int size;                       \
        int max;                        \
        type##_l *hooks;                \
    } type##_list = {0,0,0};            \
    type##_hook_fp type##_hook = 0;     \
    static int type##_version = 0

mk_list(_RTC_Allocate);
mk_list(_RTC_Free);
mk_list(_RTC_MemCheck);
mk_list(_RTC_FuncCheckSet);
HANDLE _RTC_api_change_mutex = NULL;

#define add_func(type, vers, fp) {                                       \
    if (type##_version < vers)                                           \
    {                                                                    \
        type##_version = vers;                                           \
        type##_hook = (type##_hook_fp)fp;                                \
    }                                                                    \
    if (!type##_list.hooks)                                              \
    {                                                                    \
        type##_list.hooks = (type##_l*)                                  \
            VirtualAlloc(0, 65536, MEM_RESERVE, PAGE_READWRITE);         \
    }                                                                    \
    if (type##_list.size == type##_list.max)                             \
    {                                                                    \
        type##_list.max += 4096/sizeof(type##_l);                        \
        VirtualAlloc(type##_list.hooks, type##_list.max*sizeof(type##_l),\
                     MEM_COMMIT, PAGE_READWRITE);                        \
    }                                                                    \
    type##_list.hooks[type##_list.size].funcptr = (type##_hook_fp)fp;    \
    type##_list.hooks[type##_list.size++].version = vers;                \
}

#define del_func(type, fp) {                                                    \
    int i;                                                                      \
    for (i = 0; i < type##_list.size; i++)                                      \
    {                                                                           \
        if (type##_list.hooks[i].funcptr == fp)                                 \
        {                                                                       \
            for (i++; i < type##_list.size; i++)                                \
            {                                                                   \
                type##_list.hooks[i-1].funcptr = type##_list.hooks[i].funcptr;  \
                type##_list.hooks[i-1].version = type##_list.hooks[i].version;  \
            }                                                                   \
            type##_list.size--;                                                 \
            break;                                                              \
        }                                                                       \
    }                                                                           \
    if (fp == (void*)type##_hook)                                               \
    {                                                                           \
        int hiver = 0;                                                          \
        type##_hook_fp candidate = 0;                                           \
        for (i = 0; i < type##_list.size; i++)                                  \
        {                                                                       \
            if (type##_list.hooks[i].version > hiver)                           \
            {                                                                   \
                hiver = type##_list.hooks[i].version;                           \
                candidate = type##_list.hooks[i].funcptr;                       \
            }                                                                   \
        }                                                                       \
        type##_hook = candidate;                                                \
        type##_version = hiver;                                                 \
    }                                                                           \
}

#endif

/*
    funcs is a list of function pointers that are currently defined as:
    funcs[0] = Allocation hook
    funcs[1] = Free hook
    funcs[2] = Memory Check hook
    funcs[3] = Function Check enabler/disabler hook
 */

_RTC_error_fn __cdecl 
_CRT_RTC_INIT(HANDLE mutex, void **funcs, int funccount, int version, int unloading)
{
#ifdef _RTC_ADVMEM
    // This stuff is currently disabled
    if (mutex && !_RTC_api_change_mutex)
        _RTC_api_change_mutex = mutex;
    if (funccount > 0)
    {
        if (!unloading)
        {
            switch (funccount)
            {
            default:
            case 4:
                add_func(_RTC_FuncCheckSet, version, funcs[3]);
            case 3:
                add_func(_RTC_MemCheck, version, funcs[2]);
            case 2:
                add_func(_RTC_Free, version, funcs[1]);
            case 1:
                add_func(_RTC_Allocate, version, funcs[0]);
            }
        } else {
            switch (funccount)
            {
            default:
            case 4:
                del_func(_RTC_FuncCheckSet, funcs[3]);
            case 3:
                del_func(_RTC_MemCheck, funcs[2]);
            case 2:
                del_func(_RTC_Free, funcs[1]);
            case 1:
                del_func(_RTC_Allocate, funcs[0]);
            }
        }
    }
#endif

#ifdef _DEBUG
    return &_CrtDbgReport;
#else
    return 0;
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\exsup.asm ===
;***
;exsup.asm
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This file contains those routines
;	common to both C8.0 and C9.0.
;
;Notes:
;
;Revision History:
;	04-13-93  JWM	setjmp(), longjmp() & raisex() moved to setjmp.asm;
;                       common data definitions moved to exsup.inc.
;	10-18-93  GJF	Ensure direction flag is clear in _except_handler2
;	12-16-93  PML	Accept <0,0,>0 from except filter, not just -1,0,+1
;	01-10-94  PML	Moved C8-specific __except_handler2 to exsup2.inc.
;			Only C8/C9 common routines left here.
;	01-20-94  GJF	Gave _EXCEPTION_REGISTRATION a _COMMON suffix (fix
;			from SteveWo).
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not 0.
;	01-11-95  SKS	Remove MASM 5.X support
;	04-18-95  JWM	Added NLG support
;	04-21-95  JWM	NLG routines moved from setjmp.asm, NLG data from
;			frame.cpp.
;	04-25-95  JWM	Added __NLG_Return2 label.
;	06-07-95  JWM	NLG now multithread safe.
;	06-20-95  JWM	dwCode passed on stack (11803).
;	07-11-95  JWM	unwanted prologue removed from NLG_Notify (11803).
;	07-21-95  JWM	Added new entry point, _NLG_Notify1 (16585).
;	03-09-01  PML   Add FPO directives for proper callstacks (vs7#221754)
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?
ifndef _BUILD_DLL_LIB_
extrn _RtlUnwind@16:near
endif           ; _BUILD_DLL_LIB_

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
_EXCEPTION_REGISTRATION_COMMON struc	; C8.0/C9.0 common only
                        dd      ?	; prev (OS-req, def'd in exsup.inc)
                        dd      ?	; handler (ditto)
;private:
    scopetable          dd      ?	; C8/C9 common
    trylevel            dd      ?	; C8/C9 common
_EXCEPTION_REGISTRATION_COMMON ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

assumes DS,DATA
assumes FS,DATA

public __except_list
__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginDATA

__NLG_Destination _NLG_INFO <>
PUBLIC __NLG_Destination

EndDATA

BeginCODE

ifndef _BUILD_DLL_LIB_

;NB: call to RtlUnwind appears to trash ebx! and possibly others so just
; to be safe, we save all callee save regs.
cProc _global_unwind2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  stop
cBegin
        push    0                       ; ReturnValue
        push    0                       ; ExceptionRecord
        push    offset flat:_gu_return  ; TargetIp
        push    stop                    ; TargetFrame

        call    _RtlUnwind@16
_gu_return:
cEnd

endif           ; _BUILD_DLL_LIB_

;_unwind_handler(
;  PEXCEPTION_RECORD xr,
;  PREGISTRATION_RECORD establisher,
;  PCONTEXT context,
;  PREGISTRATION_RECORD dispatcher);
;
;this is a special purpose handler used to guard our local unwinder.
; its job is to catch collided unwinds.
;
;NB: this code is basically stolen from the NT routine xcptmisc.asm
; and is basically the same method used by the system unwinder (RtlUnwind).
;
cProc _unwind_handler,<C>
cBegin
        mov     ecx, dword ptr [esp+4]
        test    dword ptr [ecx.exception_flags], EXCEPTION_UNWIND_CONTEXT
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jz      short _uh_return

    ; We collide in a _local_unwind.  We set the dispatched to the
    ; establisher just before the local handler so we can unwind
    ; any future local handlers.

        mov     eax, [esp+8]            ; Our establisher is the one
                                        ; in front of the local one

        mov     edx, [esp+16]
        mov     [edx], eax              ; set dispatcher to local_unwind2

        mov     eax, DISPOSITION_COLLIDED_UNWIND
_uh_return:
cEnd

;/* _LOCAL_UNWIND2 - run all termination handlers listed in the scope table
; * associated with the given registration record, from the current lexical
; * level through enclosing levels up to, but not including the given 'stop'
; * level.
; */
;void _local_unwind2(PEXCEPTION_REGISTRATION xr, int stop)
;{
;    int ix;
;
;    for(ix=xr->trylevel; ix!=-1 && ix!=stop; ix=xr->xscope[i].enclosing_level){
;       /* NULL indicates that this entry is for a termination handler */
;       if(xr->xscope[i].filter==NULL){
;           /* NB: call to the termination handler may trash callee save regs */
;           (*xr->xscope[i].specific_handler)();
;       }
;    }
;    xr->trylevel=stop;
;}
;/* NOTE: frame (ebp) is setup by caller of __local_unwind2 */

PUBLIC	__NLG_Return2

cProc _local_unwind2,<C,PUBLIC>
cBegin
        .FPO    (0,2,3,3,0,0)
        push    ebx
        push    esi
        push    edi     ;call to the handler may trash, so we must save it

        mov     eax, [esp+16]           ; (eax) = PEXCEPTION_REGISTRATION

        ;link in a handler to guard our unwind
	push	eax
        push    TRYLEVEL_INVALID
        push    OFFSET FLAT:__unwind_handler
        push    fs:__except_list
        mov     fs:__except_list, esp

_lu_top:
        mov     eax, [esp+32]           ; (eax) = PEXCEPTION_REGISTRATION
        mov     ebx, [eax.scopetable]
        mov     esi, [eax.trylevel]

        cmp     esi, -1                 ; REVIEW: do we need this extra check?
        je      short _lu_done
        cmp     esi, [esp+36]
        je      short _lu_done

        lea     esi, [esi+esi*2]        ; esi*= 3

        mov     ecx, [(ebx+esi*4).enclosing_level]
        mov     [esp+8], ecx            ; save enclosing level
        mov     [eax.trylevel], ecx

        cmp     dword ptr [(ebx+esi*4).filter], 0
        jnz     short _lu_continue

        push    0101h
        mov     eax, [(ebx+esi*4).specific_handler]
        call    _NLG_Notify

        call    [(ebx+esi*4).specific_handler]

__NLG_Return2::
_lu_continue:
        jmp     short _lu_top
_lu_done:
        pop     fs:__except_list
        add     esp, 4*3                ; cleanup stack

        pop     edi                     ; restore c-runtime registers
        pop     esi
        pop     ebx
cEnd

;/* _ABNORMAL_TERMINATION - return TRUE if __finally clause entered via
; * _local_unwind2.
; */
;BOOLEAN _abnormal_termination(void);
cProc _abnormal_termination,<C,PUBLIC>
cBegin
        .FPO    (0,0,0,0,0,0)
        xor     eax, eax                ; assume FALSE

        mov     ecx, fs:__except_list
        cmp     [ecx.handler], offset FLAT:__unwind_handler
        jne     short _at_done          ; UnwindHandler first?

        mov     edx, [ecx+12]           ; establisher of local_unwind2
        mov     edx, [edx.trylevel]     ; is trylevel the same as the
        cmp     [ecx+8], edx            ; local_unwind level?
        jne     short _at_done          ; no - then FALSE

        mov     eax, 1                  ; currently in _abnormal_termination
_at_done:
cEnd

;
; NLG entrypoints, for debugger support
; On entry: address of non-local goto in eax
;

public __NLG_Dispatch

OPTION PROLOGUE:NONE
OPTION EPILOGUE:NONE

_NLG_Notify1 PROC C PUBLIC
        push ebx
        push ecx
        mov  ebx, OFFSET __NLG_Destination
	jmp  __NLG_go		; ecx is already set
_NLG_Notify1 ENDP

_NLG_Notify PROC C PUBLIC, dwInCode:DWORD
        push ebx
        push ecx
        mov  ebx, OFFSET __NLG_Destination
        mov  ecx, dwInCode
__NLG_Go:
        mov  [ebx.dwCode], ecx
        mov  [ebx.uoffDestination], eax
        mov  [ebx.uoffFramePointer], ebp
__NLG_Dispatch::
        pop  ecx
        pop  ebx
        ret  4
_NLG_Notify ENDP

OPTION PROLOGUE:PROLOGUEDEF
OPTION EPILOGUE:EPILOGUEDEF

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\exsup3.asm ===
;***
;exsup3.asm
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This is just the C9.0 version of
;	the language-specific exception handler.  The C8.0 version is
;	found in exsup2.asm, and the routines common to both C8 and C9
;	are found in exsup.asm.
;
;Notes:
;
;Revision History:
;	01-10-94  PML	Create VC/C++ 2.0 (C9.0) version from C8.0 original
;	01-11-95  SKS	Remove MASM 5.X support
;	04-18-95  JWM	Added NLG support
;	06-07-95  JWM	__SetNLGCode() used, for multithread safety.
;	06-20-95  JWM	__SetNLGCode() removed, code passed on stack (11803).
;	03-09-01  PML   Add FPO directives for proper callstacks (vs7#221754)
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near
extrn __NLG_Notify:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;/* _esp, xpointers at negative offset */
;     int _esp;
;     PEXCEPTION_POINTERS xpointers;
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
;private (at negative offsets from node ptr)
    _esp		=	-8
    xpointers		=	-4
_C9_EXCEPTION_REGISTRATION struc	; C9.0 version
;public:
                        dd      ?	; prev (common)
                        dd      ?	; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
_C9_EXCEPTION_REGISTRATION ends
FRAME_EBP_OFFSET equ 16

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

extern __NLG_Destination:_NLG_INFO

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE

;EXTERN C __SetNLGCode:near

;/* _EXCEPT_HANDLER3 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler3(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
	db	'VC20'	;; VC/C++ 2.0/32-bit (C9.0) version
	db	'XC00'	;; so debugger can recognize this proc (cuda:3936)

xrecord      equ [ebp+8]
registration equ [ebp+12]
context      equ [ebp+16]
dispatcher   equ [ebp+20]

xp           equ [ebp-8]

_except_handler3 proc C
	; FPO = 0 dwords locals allocated in prolog
	;       3 dword parameters
	;       10 bytes in prolog
	;       7 registers saved (includes locals to work around debugger bug)
	;       1 EBP is used
	;       0 frame type = FPO
	.FPO    (0,3,10,7,1,0)
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	push	ebp

	;4*4b for callee saves + 4b return address + 4b param = 24

	;DF in indeterminate state at time of exception, so clear it
	cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

	lea	ebp, FRAME_EBP_OFFSET[ebx]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

	; Accept <0, 0, >0 instead of just -1, 0, +1
	or	eax, eax
	jz	short _lh_continue
	js	short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
	lea	ebp, FRAME_EBP_OFFSET[ebx]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8
        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3

        push    01h
        mov     eax, [(edi+ecx*4).specific_handler]
        call    __NLG_Notify

; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
	lea	ebp, FRAME_EBP_OFFSET[ebx]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
_except_handler3 endp

public __seh_longjmp_unwind@4
__seh_longjmp_unwind@4 proc near
	push	ebp
	mov	ecx, 8[esp]
	mov	ebp, [ecx.saved_ebp]
	mov	eax, [ecx.saved_trylevel]
	push	eax
	mov	eax, [ecx.saved_xregistration]
	push	eax
	call	__local_unwind2
	add	esp, 8
	pop	ebp
	ret	4
__seh_longjmp_unwind@4 endp

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\exsup2.asm ===
;***
;exsup2.asm
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This is just the C8.0 version of
;	the language-specific exception handler.  The C9.0 version is
;	found in exsup3.asm, and the routines common to both C8 and C9
;	are found in exsup.asm.
;
;Notes:
;
;Revision History:
;	01-10-94  PML	Created with __except_handler2 from exsup.asm
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_C8_EXCEPTION_REGISTRATION struc	; C8.0 version
                        dd      ?	; prev (common)
                        dd      ?	; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
    _ebp                dd      ?
    xpointers           dd      ?
_C8_EXCEPTION_REGISTRATION ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE

;/* _EXCEPT_HANDLER2 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler2(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
	db	'VC10'	;; VC/C++ 1.0/32-bit (C8.0) version
	db	'XC00'	;; so debugger can recognize this proc (cuda:3936)
cProc _except_handler2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  xrecord
        parmDP  registration
        parmDP  context
        parmDP  dispatcher
        localV  xp,SIZEOF_EXCEPTION_POINTERS
cBegin
	;4*4b for callee saves + 4b return address + 4b param = 24

	;DF in indeterminate state at time of exception, so clear it
	cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     short _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

        mov     ebp, [ebx._ebp]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

	; Accept <0, 0, >0 instead of just -1, 0, +1
	or	eax, eax
	jz	short _lh_continue
	js	short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
        mov     ebp, [ebx._ebp]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8

        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3
; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
        mov     ebp, [ebx._ebp]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
cEnd

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\sehsupp.c ===
/***
*sehsupp.c - helper functions for Structured Exception Handling support
*
*	Copyright (C) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains _rt_probe_read.  Helper for the SEH runtime support
*	routines (longjmp in particular).  Much of the SEH code is written
*	in asm, so these routines are available when probing memory in ways
*	that must be guarded with __try/__except in case of access violation.
*
*Revision History:
*	12-05-93  PML	Module created.
*	12-22-93  GJF	Made #define WIN32_LEAN_AND_MEAN conditional.
*	01-12-94  PML	Rewritten - still need helpers, just different ones
*
*******************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>

/***
*BOOL __stdcall _rt_probe_read4 - Check if a DWORD is readable
*
*Purpose:
*  Internal support function called by longjmp.  Check if a DWORD is
*  readable under a __try/__except.
*
*Entry:
*  DWORD * p - Pointer to DWORD to be probed
*
*Exit:
*  Success: TRUE - Able to read
*  Failure: FALSE - Access violation while reading
*
******************************************************************************/

BOOL __stdcall _rt_probe_read4(
    DWORD * ptr)
{
    BOOL readable;

    __try
    {
	*(volatile DWORD *)ptr;
	readable = TRUE;
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
		? EXCEPTION_EXECUTE_HANDLER
		: EXCEPTION_CONTINUE_SEARCH)
    {
	readable = FALSE;
    }

    return readable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\sehprolg.asm ===
;***
;sehprolog.asm   - defines __SEH_prolog and __SEH_epilog
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       SEH prolog/epilog helper function. Sets up the frame for a function 
;	with SEH try block.
;
;Revision History:
;	03-28-2000  LL	Module created.
;
;*******************************************************************************
	title	sehprolog.asm
	.386P

.model FLAT

	ASSUME	FS: FLAT

PUBLIC	__SEH_prolog
PUBLIC	__SEH_epilog
EXTRN	__except_handler3:DWORD

_TEXT	SEGMENT


; First argument:  local frame size
; Second argument: address of SEH try table

__SEH_prolog PROC NEAR
	push	OFFSET FLAT:__except_handler3	; push address of SEH handler
	mov	eax, DWORD PTR fs:0		
	push	eax				; push previous except list head
	mov	DWORD PTR fs:0, esp		; link this node to except list
	mov	eax, DWORD PTR [esp+16]		; load frame size
	mov	DWORD PTR [esp+16], ebp		; save off EBP
	lea	ebp, [esp+16]			; setup base pointer
	sub	esp, eax			; allocate frame
	push	ebx				; push callee save regs
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebp-8]		; load return address
	mov	DWORD PTR [ebp-24], esp		; save off ESP in except record
	push	eax				; push back return address
	mov	eax, DWORD PTR [ebp-4]		; load SEH table address
	mov	DWORD PTR [ebp-4], -1		; initialize SEH state index
	mov	DWORD PTR [ebp-8], eax		; Move SEH table addr to the right place
	ret	0
__SEH_prolog ENDP


__SEH_epilog PROC NEAR
	mov	ecx, DWORD PTR [ebp-16]		; unlink from except list
	mov	DWORD PTR fs:0, ecx
	pop	ecx				; pop return address
	pop	edi				; pop callee save regs
	pop	esi
	pop	ebx
	leave
	push	ecx				; push back return address
	ret	0
__SEH_epilog ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\setjmp.asm ===
;***
;setjmp.asm
;
;	Copyright (C) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmp();
;	split from exsup.asm for granularity purposes.
;
;Notes:
;
;Revision History:
;	04-13-93  JWM	Module created.
;	10-14-93  GJF	Merged in NT verson.
;	01-12-94  PML	Added C9.0 generic EH callback for unwind.  Split
;			into setjmp.asm, setjmp3.asm, and longjmp.asm.
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not 0.
;	01-11-95  GJF	Purged raisex(). Nobody uses it. Nobody even remembers
;			what it was used for (it was part of the test harness
;			for early EH unit testing).
;	01-11-95  SKS	Remove MASM 5.X support
;	01-13-95  JWM	Added NLG routines for debugger support.
;	04-11-95  JWM	NLG_Return moved to lowhelpr.asm.
;	04-21-95  JWM	NLG routines moved to exsup.asm.
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list


assumes DS,DATA
assumes FS,DATA

BeginCODE

; Following symbol defined in exsup.asm
extrn __except_list:near

; int
; _setjmp (
;	OUT jmp_buf env)
;
; Routine Description:
;
;	(Old) implementation of setjmp intrinsic.  Saves the current
;	nonvolatile register state in the specified jump buffer and returns
;	a function value of zero.
;
;	Saves the callee-save registers, stack pointer and return address.
;	Also saves the exception registration list head.
;
;	This code is only present for old apps that link to the DLL runtimes,
;	or old object files compiles with C8.0.  It intentionally duplicates
;	the old setjmp bugs, blindly assuming that the topmost EH node is a
;	C8.0 SEH node.
;
; Arguments:
;
;	env - Address of the buffer for storing the state information
;
; Return Value:
;
;	A value of zero is returned.

public __setjmp
__setjmp PROC NEAR
        mov     edx, [esp+4]
        mov     [edx.saved_ebp], ebp    ; old bp and the rest
        mov     [edx.saved_ebx], ebx
        mov     [edx.saved_edi], edi
        mov     [edx.saved_esi], esi
        mov     [edx.saved_esp], esp

        mov     eax, [esp]              ; return address
        mov     [edx.saved_return], eax

        mov     eax, dword ptr fs:__except_list
        mov     [edx.saved_xregistration], eax

	cmp	eax, -1 		; -1 means no higher-level handler
	jnz	short _sj_save_trylevel
        mov     dword ptr [edx.saved_trylevel], -1 ;something invalid
	jmp	short _sj_done

_sj_save_trylevel:
        mov     eax, [eax + C8_TRYLEVEL]
        mov     [edx.saved_trylevel], eax

_sj_done:
        sub     eax, eax
        ret
__setjmp ENDP


EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\setjmp3.asm ===
;***
;setjmp3.asm
;
;	Copyright (C) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmp(), longjmp() & raisex() routines;
;	split from exsup.asm for granularity purposes.
;
;Notes:
;
;Revision History:
;	01-12-94  PML	Split from setjmp.asm, added C9.0 generic EH
;			callback for unwind.
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not 0.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

assumes DS,DATA
assumes FS,DATA

BeginCODE

; Following symbol defined in exsup.asm
extrn __except_list:near

; int
; _setjmp3 (
;	OUT jmp_buf env,
;	int count,
;	...)
;
; Routine Description:
;
;	(New) implementation of setjmp intrinsic.  Saves the current
;	nonvolatile register state in the specified jump buffer and returns
;	a function value of zero.
;
;	Saves the callee-save registers, stack pointer and return address.
;	Also saves the exception registration list head.  If setjmp is
;	called from a function using any form of exception handling, then
;	additional data is also saved allowing some form of local unwind
;	at longjmp time to restore the proper exception handling state.
;
; Arguments:
;
;	env - Address of the buffer for storing the state information
;	count - count of additional DWORDs of information.  Zero if setjmp
;		not called from a function with any form of EH.
;	...	Additional data pushed by the setjmp intrinsic if called
;		from a function with any form of EH.  The first DWORD is
;		a function ptr which will be called at longjmp time to do
;		the local unwind.  The second DWORD is the try level to be
;		restored (if applicable).  Any further data is saved in the
;		generic data array in the jmp_buf for use by the local
;		unwind function.
;
; Return Value:
;
;	A value of zero is returned.

public __setjmp3
__setjmp3 PROC NEAR
        mov     edx, [esp+4]
        mov     [edx.saved_ebp], ebp    ; old bp and the rest
        mov     [edx.saved_ebx], ebx
        mov     [edx.saved_edi], edi
        mov     [edx.saved_esi], esi
        mov     [edx.saved_esp], esp

        mov     eax, [esp]              ; return address
        mov     [edx.saved_return], eax

	mov	dword ptr [edx.version_cookie], JMPBUF_COOKIE
	mov	dword ptr [edx.unwind_func], 0

        mov     eax, dword ptr fs:__except_list
        mov     [edx.saved_xregistration], eax

	cmp	eax, -1 		; -1 means no higher-level handler
	jnz	short _s3_get_count
        mov     dword ptr [edx.saved_trylevel], -1 ;something invalid
	jmp	short _s3_done

_s3_get_count:
	mov	ecx, [esp+8]		; count of additional data
	or	ecx, ecx
	jz	short _s3_default_trylevel

	mov	eax, [esp+12]		; func to do local unwind at longjmp
	mov	[edx.unwind_func], eax
	dec	ecx
	jnz	_s3_save_trylevel

	; Not called from a function with any form of EH, or no trylevel
	; passed.  Save the TryLevel from the topmost EH node anyway,
	; assuming a C8.0 SEH node.  If we're linked to an obsolete CRTDLL
	; and call the old longjmp, then we'll still do the right thing.
_s3_default_trylevel:
        mov     eax, [eax + C8_TRYLEVEL]
        mov     [edx.saved_trylevel], eax
	jmp	short _s3_done

_s3_save_trylevel:
	mov	eax, [esp+16]		; try level to unwind to
	mov	[edx.saved_trylevel], eax
	dec	ecx
	jz	short _s3_done

	push	esi
	push	edi
	lea	esi, [esp+20+8]
	lea	edi, [edx.unwind_data]
	cmp	ecx, 6			; save up to 6 more DWORDs in jmp_buf
	jbe	_s3_save_data
	mov	ecx, 6

_s3_save_data:
	rep movsd
	pop	edi
	pop	esi

_s3_done:
        sub     eax, eax
        ret
__setjmp3 ENDP

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\jmpuwind.s ===
//++
//
// Module Name:
//
//    jmpuwind.s
//
// Abstract:
//
//    This module implements the IA64 specific routine to jump to the runtime
//    time library unwind routine.
//
// Author:
//
//    William K. Cheung (wcheung) 4-Jan-1996
//
//   
//    based on the version by David N. Cutler (davec) 12-Sep-1990
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "ksia64.h"

//++
//
// LONG
// __C_ExecuteExceptionFilter (
//    ULONGLONG MemoryStack,
//    ULONGLONG BackingStore,
//    NTSTATUS ExceptionCode,
//    PEXCEPTION_POINTERS ExceptionPointers,
//    ULONGLONG ExceptionFilter,
//    ULONGLONG GlobalPointer
//    )
//
// Routine Description:
//
//    This function sets the gp register and transfers control to the specified
//    exception filter routine.
//
// Arguments:
//
//    MemoryStack (a0) - memory stack pointer of establisher frame
//
//    BackingStore (a1) - backing store pointer of establisher frame
//
//    ExceptionCode (a2) - Exception Code.
//
//    ExceptionPointers (a3) - Supplies a pointer to the exception pointers
//       structure.
//
//    ExceptionFilter (a4) - Entry point of exception filter
//
//    GlobalPointer (a5) - GP of exception filter
//
// Return Value:
//
//    The value returned by the exception filter routine.
//
//--

        LEAF_ENTRY(__C_ExecuteExceptionFilter)

        mov     gp = a5
        mov     bt0 = a4
        br      bt0                           // branch to exception filter
        ;;

        LEAF_EXIT(__C_ExecuteExceptionFilter)

//++
//
// VOID
// __C_ExecuteTerminationHandler (
//    ULONGLONG MemoryStack,
//    ULONGLONG BackingStore,
//    BOOLEAN AbnormalTermination,
//    ULONGLONG TerminationHandler,
//    ULONGLONG GlobalPointer
//    )
//
// Routine Description:
//
//    This function sets the gp register and transfers control to the specified
//    termination handler routine.
//
// Arguments:
//
//    MemoryStack (a0) - memory stack pointer of establisher frame
//
//    BackingStore (a1) - backing store pointer of establisher frame
//
//    AbnormalTermination (a2) - Supplies a boolean value that determines
//       whether the termination is abnormal.
//
//    TerminationHandler (a3) - Entry point of termination handler
//
//    GlobalPointer (a4) - GP of termination handler
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(__C_ExecuteTerminationHandler)

        mov     gp = a4
        mov     bt0 = a3
        br      bt0                           // branch to termination handler
        ;;

        LEAF_EXIT(__C_ExecuteTerminationHandler)

//++
//
// VOID
// __jump_unwind (
//    IN PVOID TargetMsFrame,
//    IN PVOID TargetBsFrame,
//    IN PVOID TargetPc,
//    )
//
// Routine Description:
//
//    This function transfer control to unwind. It is used by the MIPS
//    compiler when a goto out of the body or a try statement occurs.
//
// Arguments:
//
//    TargetMsFrame (a0) - Supplies the memory stack frame pointer of the
//       target of the unwind.
//
//    TargetBsFrame (a1) - Supplies the backing store frame pointer of the
//       target of the unwind.
//
//    TargetPc (a2) - Supplies the target instruction address where control
//       is to be transfered to after the unwind operation is complete.
//
// Return Value:
//
//    None.
//
// N.B. The first 2 input registers are reused for local while the third
//      input register is reused as output register.
//
//--

         .global     RtlUnwind2
         .type       RtlUnwind2, @function
         .global     RtlPcToFileHeader
         .type       RtlPcToFileHeader, @function

         NESTED_ENTRY(__jump_unwind)

         .regstk   3, 2, 6, 0
         .prologue 0xC, loc0
         .fframe   ContextFrameLength, Jn10

         alloc     loc0 = ar.pfs, 3, 3, 6, 0
         mov       loc1 = brp
[Jn10:]  add       sp = -ContextFrameLength, sp
         ;;

         mov       loc2 = gp

         PROLOGUE_END

//
// Call RtlPcToFileHeader to get the image base of caller
// The image base is returned in memory location STACK_SCRATCH_AREA, sp
// and also in register v0
//
         mov       out0 = brp
         add       out1 = STACK_SCRATCH_AREA, sp
         br.call.sptk brp = RtlPcToFileHeader
         ;;

         mov       gp = loc2
//
// Add image base to image relative offset passed in a2
//
         add       out2 = v0, a2
//
// Setup rest of arguments to RtlUnwind2
//
         add       out5 = STACK_SCRATCH_AREA, sp
         mov       out4 = zero
         mov       out3 = zero
         mov       out1 = a1
         mov       out0 = a0
         br.call.sptk brp = RtlUnwind2
         ;;

         .restore  Jn20

[Jn20:]  add       sp = ContextFrameLength, sp
         nop.f     0
         mov       ar.pfs = loc0

         nop.m     0
         mov       brp = loc1
         br.ret.sptk brp

         NESTED_EXIT(__jump_unwind)


//++
// VOID
// _NLG_Notify(
//    IN PVOID Funclet
//    IN FRAME_POINTERS EstablisherFrame,
//    IN ULONG NLGCode
//    )
//
// Routine Description:
//
//    Provides the handler/longjmp addresses to the debugger
//
// Arguments:
//
//    Funclet          (a0)    - Supplies the target address of non-local goto
//    EstablisherFrame (a1,a2) - Supplies a pointer to frame of the establisher 
//                               function
//    NLGCode          (a3)    - Supplies NLG identifying value
//
// Return Value:
//
//    None.
//
//--
         .global __NLG_Dispatch
         .global __NLG_Destination

         .sdata
__NLG_Destination::
         data8  0x19930520     // signature
         data8  0              // handler address
         data8  0              // code
         data8  0              // memory stack frame pointer
         data8  0              // register stack frame pointer

         LEAF_ENTRY(_NLG_Notify)

         add       t0 = @gprel(__NLG_Destination+0x8), gp
         add       t1 = @gprel(__NLG_Destination+0x10), gp
         nop.i     0
         ;;

         st8       [t0] = a0, 16
         st8       [t1] = a3, 16
         nop.i     0
         ;;

         st8       [t0] = a1
         st8       [t1] = a2
         nop.i     0
       
__NLG_Dispatch::
         nop.m     0
         nop.i     0
         br.ret.sptk b0

         LEAF_EXIT(_NLG_Notify)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\longjmp.s ===
//++
//
// Module Name:
//
//    longjmp.s
//
// Abstract:
//
//    This module implements the IA64 specific routine to perform a long
//    jump operation.
//
//    N.B. This routine conditionally provides SAFE & UNSAFE handling of longjmp
//         which is NOT integrated with structured exception handling. The
//         determination is made based on whether the Type field
//         has been set to a nonzero value.
//
//    N.B. Currently, this routine assumes the setjmp site is EM.
//         Support for iA setjmp site is to be finished.
//
// Author:
//
//    William K. Cheung (wcheung) 30-Jan-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Updated to EAS2.1.
//
//--

#include "ksia64.h"

//++
//
// int
// longjmp (
//    IN jmp_buf JumpBuffer,
//    IN int ReturnValue
//    )
//
// Routine Description:
//
//    This function performs a long jump to the context specified by the
//    jump buffer.
//
// Arguments:
//
//    JumpBuffer (a0) - Supplies the address of a jump buffer that contains
//       jump information.
//
//    ReturnValue (a1) - Supplies the value that is to be returned to the
//       caller of set jump.
//
// Return Value:
//
//    None.
//
//--

        .global  RtlUnwind2
        .type    RtlUnwind2, @function

        NESTED_ENTRY(longjmp)

        NESTED_SETUP(2, 2, 6, 0)
        .fframe    ExceptionRecordLength+ContextFrameLength
        add        sp = -ExceptionRecordLength-ContextFrameLength, sp
        ARGPTR(a0)

        PROLOGUE_END

        mov        t4 = ar.rsc
        cmp.eq     pt1, pt0 = zero, a1
        add        t6 = JbUnwindData, a0
        ;;

        ld8        out0 = [t6], 8               // get the UnwindData
        mov        t2 = ar.bsp
        add        t0 = JbIntNats, a0
        ;;

//
// If address of registration record is not equal to zero,
// a safe longjmp is to be performed.
//

        cmp.ne     pt2, pt3 = zero, out0
        add        t1 = JbBrS0, a0
        add        t22 = JbIntS0, a0
        ;;

 (pt1)  add        a1 = 1, r0
        shr.u      t22 = t22, 3
        ;;
        mov        v0 = a1

//
// before restoring integer registers, restore their NaT bits so that
// the load fills will recover them correctly.
//

 (pt3)  ld8        t7 = [t0], JbStIIP - JbIntNats
 (pt3)  and        t22 = 0x3f, t22
 (pt2)  br.spnt    Lj30

        mov        ar.rsc = zero              // put RSE in lazy mode
        ;;
        mov        t3 = ar.bspstore
        cmp4.ge    pt1, pt0 = 4, t22
        ;;

//
// at the same time, compute and shift the loaded preserved integer
// registers' NaTs to the proper location.
//

        ld8.nt1    t15 = [t0], JbBrS1 - JbStIIP
        ld8.nt1    t16 = [t1], JbBrS2 - JbBrS0
 (pt0)  add        t21 = -4, t22
        ;;

        ld8.nt1    t17 = [t0], JbBrS3 - JbBrS1
        ld8.nt1    t18 = [t1], JbBrS4 - JbBrS2
 (pt0)  add        t6 = 68, t22
        ;;

        ld8.nt1    t19 = [t0], JbRsBSP - JbBrS3
        ld8.nt1    t20 = [t1], JbRsPFS - JbBrS4
 (pt1)  sub        t21 = 4, t22
        ;;

        ld8.nt1    t10 = [t0], JbApUNAT - JbRsBSP
        ld8.nt1    t11 = [t1], JbApLC - JbRsPFS
 (pt0)  shl        t5 = t7, t21
        ;;

        ld8.nt1    t12 = [t0]
        ld8.nt1    t13 = [t1], JbPreds - JbApLC
 (pt0)  shr.u      t8 = t7, t6
        ;;

        ld8.nt1    t14 = [t1]
 (pt1)  shr        t9 = t7, t21
 (pt0)  or         t9 = t8, t5
        ;;

        extr.u     t5 = t11, 7, 7         // local frame size
        extr.u     t6 = t10, 3, 6         // rnat index
        ;;

        sub        t8 = 63, t6
        mov        t1 = t5
        ;;
        cmp.le     pt2, pt1 = t8, t5
        ;;

(pt2)   add        t1 = 1, t1
(pt2)   sub        t5 = t5, t8
(pt1)   br.sptk    Lj50
        ;;

Lj40:
        cmp.le     pt2, pt3 = 63, t5
        ;;
(pt2)   add        t5 = -63, t5
(pt2)   add        t1 = 1, t1
(pt2)   br.cond.dpnt Lj40
        ;;

Lj50:
        shladd     t10 = t1, 3, t10

//
// t2 = current bsp
// t3 = current bspstore
// t4 = saved rsc
// t9 = NaTs of sp, s0 - s3
// t10 = setjmp's bsp
// t11 = setjmp's pfs
// t12 = setjmp's unat
// t13 = setjmp's loop counter
// t14 = setjmp's predicates
// t15 = setjmp's brp (StIIP)
// t16 = setjmp's bs0
// t17 = setjmp's bs1
// t18 = setjmp's bs2
// t19 = setjmp's bs3
// t20 = setjmp's bs4
//
// Now UNAT contains the NaTs of the preserved integer registers
// at bit positions corresponding to the locations from which the
// integer registers can be restored (with load fill operations)
//
// Restore predicates and loop counter.
//

        mov        ar.unat = t9
        mov        pr = t14, -1
        mov        ar.lc = t13

        add        t0 = JbFltS0, a0
        add        t1 = JbFltS1, a0
        mov        ar.pfs = t11
        ;;

//
// scratch registers t5 - t9, t11, t13, t14 are available for use.
//
// load preserved floating point states from jump buffer
// move the loaded branch register states to the corresponding br registers
//

        ldf.fill.nt1 fs0 = [t0], JbFltS2 - JbFltS0
        ldf.fill.nt1 fs1 = [t1], JbFltS3 - JbFltS1
        nop.i      0
        ;;

        ldf.fill.nt1 fs2 = [t0], JbFltS4 - JbFltS2
        ldf.fill.nt1 fs3 = [t1], JbFltS5 - JbFltS3
        mov        brp = t15
        ;;
          
        ldf.fill.nt1 fs4 = [t0], JbFltS6 - JbFltS4
        ldf.fill.nt1 fs5 = [t1], JbFltS7 - JbFltS5
        mov        bs0 = t16
        ;;
          
        ldf.fill.nt1 fs6 = [t0], JbFltS8 - JbFltS6
        ldf.fill.nt1 fs7 = [t1], JbFltS9 - JbFltS7
        mov        bs1 = t17
        ;;
          
        ldf.fill.nt1 fs8 = [t0], JbFltS10 - JbFltS8
        ldf.fill.nt1 fs9 = [t1], JbFltS11 - JbFltS9
        mov        bs2 = t18
        ;;
          
        ldf.fill.nt1 fs10 = [t0], JbFltS12 - JbFltS10
        ldf.fill.nt1 fs11 = [t1], JbFltS13 - JbFltS11
        mov        bs3 = t19
        ;;
          
        ldf.fill.nt1 fs12 = [t0], JbFltS14 - JbFltS12
        ldf.fill.nt1 fs13 = [t1], JbFltS15 - JbFltS13
        mov        bs4 = t20
        ;;
          
        ldf.fill.nt1 fs14 = [t0], JbFltS16 - JbFltS14
        ldf.fill.nt1 fs15 = [t1], JbFltS17 - JbFltS15
        brp.ret.sptk brp, Lj20
        ;;
          
//
// scratch registers t6 - t9, t11, t13 - t20 are available for use
//
// t2 is current bsp
// t3 is current bspstore
// t4 is saved rsc
// t5 is the setjmp's fpsr
// t10 is the setjmp's bsp
// t12 is the setjmp's unat
//

        ldf.fill.nt1 fs16 = [t0], JbFltS18 - JbFltS16
        ldf.fill.nt1 fs17 = [t1], JbFltS19 - JbFltS17
        cmp.lt     p0, pt1 = t3, t10          // current bspstore < setjmp's bsp
        ;;
          
        ldf.fill.nt1 fs18 = [t0], JbFPSR - JbFltS18
        ldf.fill.nt1 fs19 = [t1], JbIntS1 - JbFltS19
        dep        t9 = 1, t10, 3, 6          // OR 1s to get desired RNAT location
        ;;                                    // t9 = OR(0x1f8, t10)
          
        mov        t11 = ar.rnat              // save rnat for later use
        ld8.nt1    t5 = [t0], JbIntS0 - JbFPSR
  (pt1) br.cond.spnt Lj10
        ;;

        flushrs                               // Flush the RSE and move up
        nop.m      0
        mov        t3 = t2                    // the current bspstore
        ;;

Lj10:

        // 
        // t3 is top of backing store in memory
        // t9 is desired RNAT collection location
        //

        ld8.fill.nt1 s0 = [t0], JbIntS2 - JbIntS0
        ld8.fill.nt1 s1 = [t1], JbIntS3 - JbIntS1
        cmp.lt     pt1, pt2 = t3, t9          // current top of backing store
        ;;                                    // is smaller than desired RNAT
                                              // collection location?
                                              // pt1: use RNAT app. register
                                              // pt2: load RNAT from bstore

        ld8.fill.nt1 s2 = [t0], JbIntSp - JbIntS2
        ld8.fill.nt1 s3 = [t1]
        nop.i      0
        ;;

        ld8.fill.nt1 t17 = [t0]               // load setjmp's sp
 (pt2)  ld8.nt1    t15 = [t9]                 // load desired RNAT
        nop.i      0
        ;;

        loadrs                                // invalidates dirty registers
        ;;
        mov        ar.bspstore = t10          // set bspstore register
        ;;

        invala
        mov        ar.unat = t12              // set unat
        mov        sp = t17                   // set stack pointer

 (pt2)  mov        ar.rnat = t15              // set rnat to loaded value
 (pt1)  mov        ar.rnat = t11              // reuse rnat content
        nop.i      0

Lj20:
        mov        ar.rsc = t4                // restore RSC
        ;;
        mov        ar.fpsr = t5               // restore FPSR
        br.ret.sptk.clr brp                   // return to setjmp site


Lj30:

//
// t6 -> UnwindData+8
// out0 - target psp
// out1 - target bsp
// out2 - target ip (setjmp's StIIP)
// out3 - exception record address
// out4 - return value
// out5 - context record address
//

        add         t5 = JbStIIP, a0
        add         t0 = ErExceptionCode+STACK_SCRATCH_AREA, sp
        add         t1 = ErExceptionFlags+STACK_SCRATCH_AREA, sp
        ;;

        ld8         out1 = [t6]               // target bsp
        movl        v0 = STATUS_LONGJUMP      // get long jump status code

        ld8         out2 = [t5]               // target ip
        st4         [t1] = zero, ErExceptionAddress - ErExceptionFlags
        add         out3 = STACK_SCRATCH_AREA, sp
        ;;

        st4         [t0] = v0, ErExceptionInformation - ErExceptionCode
        STPTRINC(t1, zero, ErExceptionRecord - ErExceptionAddress)
        mov         out4 = a1
        ;;

        STPTR(t0, a0)
        STPTRINC(t1, zero, ErNumberParameters - ErExceptionRecord)
        mov         t4 = 1                    // set to 1 argument
        ;;

        st4         [t1] = t4
        add         out5 = STACK_SCRATCH_AREA+ExceptionRecordLength, sp
        br.call.sptk.many brp = RtlUnwind2    // call RtlUnwind2

        NESTED_EXIT(longjmp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\setjmp.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
// Module Name:
//
//    setjmp.s
//
// Abstract:
//
//    This module implements the IA64 specific routine to perform a setjmp.
//
//    N.B. This module has two entry points that provide SAFE and UNSAFE 
//         handling of setjmp.
//
// Author:
//
//    William K. Cheung (wcheung) 27-Jan-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Modified to support mixed ISA.
//
//--

#include "ksia64.h"


        .global     _setjmpexused
        .common     _setjmpexused,8,8

//++
//
// int
// setjmp (
//    IN jmp_buf JumpBuffer
//    )
//
// Routine Description:
//
//    This function saved the current nonvolatile register state in the
//    specified jump buffer and returns a function vlaue of zero.
//
// Arguments:
//
//    JumpBuffer (a0) - Supplies the address of a jump buffer to store the
//       jump information.
//
//    MemoryStackFp (a1) - Supplies the memory stack frame pointer (psp)
//       of the caller.  It's an optional argument.
//
// Return Value:
//
//    A value of zero is returned.
//
//--

        LEAF_ENTRY(setjmp)
        ALTERNATE_ENTRY(_setjmp)
        LEAF_SETUP(3, 0, 0, 0)

        rUnat       = t8
        rFpsr       = t9
        rLc         = t10
        rPr         = t11
        rBrp        = t21
        rPfs        = t22

        rPsp        = a1
        rBsp        = a2


        mov         rUnat = ar.unat
        add         t1 = JbUnwindData, a0
        add         t0 = @gprel(_setjmpexused), gp
        ;;

        mov         rFpsr = ar.fpsr
        ld8         t0 = [t0]                   // load the entry point of
        ;;                                      // the safe setjmp version.
        cmp.ne      pt1, pt0 = zero, t0
        ;;

 (pt0)  st8.nta     [t1] = zero
        mov         bt0 = t0
 (pt1)  br.cond.spnt.many bt0                   // branch if non-zero


        ALTERNATE_ENTRY(_setjmp_common)

//
// rUnat & rFpsr have been set to content of ar.unat and ar.fpsr
//
// Save the non-volatile EM state in the jump buffer
//
// 1) Save preserved floating point registers 
// 2) Move preserved branch registers and application registers into general
//    registers that are later saved into the corresponding fields in the
//    jump buffer.
// 3) Save preserved integer registers.
// 4) At the same time, compute the bit position at which the NaTs of preserved
//    integer registers are saved and rotate them such that the bit positions 
//    of the saved NaTs and corresponding registers have a one-to-one mapping.
//
 
        add         t0 = JbFltS0, a0
        add         t1 = JbFltS1, a0
        mov         rBrp = brp
        ;;

        stf.spill.nta [t0] = fs0, JbFltS2 - JbFltS0
        stf.spill.nta [t1] = fs1, JbFltS3 - JbFltS1
        mov         t13 = bs0
        ;;

        stf.spill.nta [t0] = fs2, JbFltS4 - JbFltS2
        stf.spill.nta [t1] = fs3, JbFltS5 - JbFltS3
        mov         t14 = bs1
        ;;

        stf.spill.nta [t0] = fs4, JbFltS6 - JbFltS4
        stf.spill.nta [t1] = fs5, JbFltS7 - JbFltS5
        mov         t15 = bs2
        ;;

        stf.spill.nta [t0] = fs6, JbFltS8 - JbFltS6
        stf.spill.nta [t1] = fs7, JbFltS9 - JbFltS7
        mov         t16 = bs3
        ;;

        stf.spill.nta [t0] = fs8, JbFltS10 - JbFltS8
        stf.spill.nta [t1] = fs9, JbFltS11 - JbFltS9
        mov         t17 = bs4
        ;;

        stf.spill.nta [t0] = fs10, JbFltS12 - JbFltS10
        stf.spill.nta [t1] = fs11, JbFltS13 - JbFltS11
        mov         rLc = ar.lc
        ;;

        stf.spill.nta [t0] = fs12, JbFltS14 - JbFltS12
        stf.spill.nta [t1] = fs13, JbFltS15 - JbFltS13
        mov         rPr = pr
        ;;

        stf.spill.nta [t0] = fs14, JbFltS16 - JbFltS14
        stf.spill.nta [t1] = fs15, JbFltS17 - JbFltS15
        add         t2 = JbIntS0, a0
        ;;

        stf.spill.nta [t0] = fs16, JbFltS18 - JbFltS16
        stf.spill.nta [t1] = fs17, JbFltS19 - JbFltS17
        shr.u       t2 = t2, 3
        ;;

        stf.spill.nta [t0] = fs18, JbIntS0 - JbFltS18
        stf.spill.nta [t1] = fs19, JbIntS1 - JbFltS19
        and         t2 = 0x3f, t2
        ;;

        .mem.offset 0,0
        st8.spill.nta [t0] = s0, JbIntS2 - JbIntS0
        .mem.offset 0,8
        st8.spill.nta [t1] = s1, JbIntS3 - JbIntS1
        cmp4.ge     pt1, pt0 = 4, t2
        ;;

        .mem.offset 0,0
        st8.spill.nta [t0] = s2, JbIntSp - JbIntS2
        .mem.offset 0,8
        st8.spill.nta [t1] = s3, JbPreds - JbIntS3
  (pt0) add         t5 = -4, t2
        ;;

        st8.spill.nta [t0] = sp, JbStIIP - JbIntSp
        st8.nta     [t1] = rPr, JbBrS0 - JbPreds
  (pt0) sub         t6 = 68, t2
        ;;

        mov         t7 = ar.unat
        st8.nta     [t0] = rBrp, JbBrS1 - JbStIIP
  (pt1) sub         t5 = 4, t2
        ;;

        st8.nta     [t1] = t13, JbBrS2 - JbBrS0
        mov         rPfs = ar.pfs
  (pt1) shl         t2 = t7, t5
        ;;

        st8.nta     [t0] = t14, JbBrS3 - JbBrS1
        st8.nta     [t1] = t15, JbBrS4 - JbBrS2
  (pt0) shr.u       t3 = t7, t5
        ;;

        st8.nta     [t0] = t16, JbRsBSP - JbBrS3
        st8.nta     [t1] = t17, JbRsPFS - JbBrS4
  (pt0) shl         t4 = t7, t6
        ;;

        st8.nta     [t0] = rBsp, JbApUNAT - JbRsBSP
        st8.nta     [t1] = rPfs, JbApLC - JbRsPFS
  (pt0) or          t2 = t3, t4
        ;;

        st8.nta     [t0] = rUnat, JbIntNats - JbApUNAT
        st8.nta     [t1] = rLc, JbFPSR-JbApLC
        mov         v0 = zero
        ;;

        st8.nta     [t0] = t2                   // save integer nats.
        st8.nta     [t1] = rFpsr                // save the fpsr

        mov         ar.unat = rUnat             // restore ar.unat
        br.ret.sptk brp

        LEAF_EXIT(setjmp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\miscs.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
// Module Name:
//
//    miscs.s
//
// Abstract:
//
//    This module implements the IA64 intrinsics.
//
// Author:
//
//    William K. Cheung (wcheung) 18-Mar-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "ksia64.h"

//++
//
// ULONGLONG
// _P32ToP64 (
//    ULONG Pointer
//    )
//
// Routine Description:
//
//    This function swizzles a pointer.
//
// Arguments:
//
//    Pointer (a0) - 32-bit pointer.
//
// Return Value:
//
//    Swizzle pointer value.
//
//--
        LEAF_ENTRY(_P32ToP64)

        nop.m     0
        sxt4      v0 = a0
  (p0)  br.ret.sptk brp

        LEAF_EXIT(_P32ToP64)

//++
//
// struct _TEB *
// _read_teb (
//    VOID
//    )
//
// Routine Description:
//
//    This function swizzles a pointer.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    TEB pointer.
//
//--
        LEAF_ENTRY(_read_teb)

        nop.m     0
        mov       v0 = teb
        br.ret.sptk brp

        LEAF_EXIT(_read_teb)


        LEAF_ENTRY(_mf)

        mf
        nop.m    0
        br.ret.sptk brp

        LEAF_EXIT(_mf)


        LEAF_ENTRY(InterlockedExchange)
        ALTERNATE_ENTRY(_InterlockedExchange)

        sxt4        a0 = a0
        nop.m       0
        nop.i       0
        ;;

        xchg4.nt1   v0 = [a0], a1
        nop.i       0
        br.ret.sptk.clr brp

        LEAF_EXIT(_InterlockedExchange)


//++
//
// PVOID
// InterlockedCompareExchange (
//     IN OUT PVOID *Destination,
//     IN PVOID Exchange,
//     IN PVOID Comperand
//     )
//
// Routine Description:
//
//     This function performs an interlocked compare of the destination
//     value with the comperand value. If the destination value is equal
//     to the comperand value, then the exchange value is stored in the
//     destination. Otherwise, no operation is performed.
//
// Arguments:
//
//     Destination - Supplies a pointer to destination value.
//
//     Exchange - Supplies the exchange value.
//
//     Comperand - Supplies the comperand value.
//
// Return Value:
//
//     (r8) - The initial destination value.
//
//--

        LEAF_ENTRY(InterlockedCompareExchange)
        ALTERNATE_ENTRY(_InterlockedCompareExchange)

        mov         ar.ccv = a2
        ARGPTR(a0)
        ;;

        cmpxchg4.acq v0 = [a0], a1, ar.ccv
        br.ret.sptk.clr brp

        LEAF_EXIT(_InterlockedCompareExchange)

//++
//
// LONG
// InterlockedIncrement(
//    IN PLONG Addend
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of one to the addend variable.
//
//    No checking is done for overflow.
//
// Arguments:
//
//    Addend - Supplies a pointer to a variable whose value is to be
//       incremented by one.
//
// Return Value:
//
//   (v0) < 0 (but not necessarily -1) if result of add < 0
//   (v0) == 0 if result of add == 0
//   (v0) > 0 (but not necessarily +1) if result of add > 0
//
//--
        LEAF_ENTRY(InterlockedIncrement)
        ALTERNATE_ENTRY(_InterlockedIncrement)
        LEAF_SETUP(1, 0, 0, 0)

        rAddend     = in0
        rRetValue   = v0

        ARGPTR(rAddend)
        fetchadd4.acq  rRetValue = [rAddend], 1
        ;;
        add         rRetValue = 1, rRetValue
        br.ret.sptk brp

        LEAF_EXIT(_InterlockedIncrement)

//++
//
// LONG
// InterlockedDecrement(
//    IN PLONG Addend
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of -1 to the addend variable.
//
//    No checking is done for overflow
//
// Arguments:
//
//    Addend - Supplies a pointer to a variable whose value is to be
//       decremented by one.
//
// Return Value:
//
//   (v0) < 0 (but not necessarily -1) if result of dec < 0
//   (v0) == 0 if result of dec == 0
//   (v0) > 0 (but not necessarily +1) if result of dec > 0
//
//--
        LEAF_ENTRY(InterlockedDecrement)
        ALTERNATE_ENTRY(_InterlockedDecrement)
        LEAF_SETUP(1, 0, 0, 0)

        rAddend     = in0
        rRetValue   = v0

        ARGPTR(rAddend)
        fetchadd4.acq  rRetValue = [rAddend], -1
        ;;
        sub         rRetValue = rRetValue, zero, 1
        br.ret.sptk brp

        LEAF_EXIT(_InterlockedDecrement)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\i386\setjmpex.asm ===
;***
;setjmpex.asm
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmpex().
;
;Notes:
;
;Revision History:
;	10-14-93  GJF	Grabbed from NT SDK tree, cleaned up a bit and this
;			header was added.
;	01-13-94  PML	Trigger off __longjmpex instead of __setjmpex, since
;			_setjmp is an intrinsic, but longjmp isn't.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
.list


extrn _longjmp:near

;
; If setjmpex is included then set __setjmpexused = 1.
;

BeginDATA
            public  __setjmpexused
__setjmpexused  dd      1
EndDATA

BeginCODE

public __longjmpex
__longjmpex PROC NEAR
        jmp     _longjmp
__longjmpex ENDP

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\cinitone.s ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//      page    ,132
//      title   cinitone - C Run-Time Initialization for _onexit/atexit
//
// cinitone.asm - WIN32 C Run-Time Init for _onexit()/atexit() routines
//
//       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
//
// Purpose:
//       Initialization entry for the _onexit()/atexit() functions.
//       This module adds an entry for _onexitinit() to the initializer table.
//       ONEXIT.C references the dummy variable __c_onexit in order to force
//       the loading of this module.
//
// Notes:
//
// Revision History:
//       03-19-92  SKS   Module created.
//       03-24-92  SKS   Added MIPS support (NO_UNDERSCORE)
//       04-30-92  SKS   Add "offset FLAT:" to get correct fixups for OMF objs
//       08-06-92  SKS   Revised to use new section names and macros
//
// *****************************************************************************

#include "kxia64.h"

		.global	__onexitinit
                .type   __onexitinit, @function

beginSection(XIC)

		data8	@fptr(__onexitinit)

endSection(XIC)


	.sdata
        .global  __c_onexit

__c_onexit:      data4   0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\chandler.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation
Copyright (c) 1990-2001, Microsoft Corporation

Module Name:

    chandler.c

Abstract:

    This module implements the C specific exception handler that provides
    structured condition handling for the C language.

Author:

    William K. Cheung (wcheung) 29-Dec-1995

    Based on the version by David N. Cutler (davec) 11-Sep-1990

Environment:

    Any mode.

Revision History:

--*/

#ifndef _IA64_
#define _IA64_
#endif

#include "nt.h"
#include <excpt.h>


//
// Define procedure prototypes for exception filter and termination handler
// execution routines defined in jmpunwnd.s
//

VOID _NLG_Notify (
    IN PVOID uoffDestination,
    IN FRAME_POINTERS uoffFramePointer,
    IN ULONG dwCode
);

LONG
__C_ExecuteExceptionFilter (
    ULONGLONG MemoryStack,
    ULONGLONG BackingStore,
    NTSTATUS ExceptionCode,
    PEXCEPTION_POINTERS ExceptionPointers,
    ULONGLONG ExceptionFilter,
    ULONGLONG GlobalPointer
    );

VOID
__C_ExecuteTerminationHandler (
    ULONGLONG MemoryStack,
    ULONGLONG BackingStore,
    BOOLEAN AbnormalTermination,
    ULONGLONG TerminationHandler,
    ULONGLONG GlobalPointer
    );

EXCEPTION_DISPOSITION
__C_specific_handler (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONGLONG MemoryStackFp,
    IN ULONGLONG BackingStoreFp,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext,
    IN ULONGLONG TargetGp
    )

/*++

Routine Description:

    This function scans the scope tables associated with the specified
    procedure and calls exception and termination handlers as necessary.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    MemoryStackFp - Supplies a pointer to memory stack frame of the
        establisher function.

    BackingStoreFp - Supplies a pointer to RSE stack frame of the
        establisher function.

    ContextRecord - Supplies a pointer to a context record.

    DispatcherContext - Supplies a pointer to the exception dispatcher or
        unwind dispatcher context.

    TargetGp - Global pointer of the current module.

Return Value:

    If the exception is handled by one of the exception filter routines, then
    there is no return from this routine and RtlUnwind is called. Otherwise,
    an exception disposition value of continue execution or continue search is
    returned.

--*/

{
    ULONGLONG ImageBase;
    ULONGLONG ControlPc;
    ULONGLONG TargetPc;
    ULONGLONG Handler;
    ULONG TargetHandler;
    LONG Value;
    CONTEXT ContextRecordEm;
    EXCEPTION_POINTERS ExceptionPointers;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG Index;
    PSCOPE_TABLE ScopeTable;
    FRAME_POINTERS EstablisherFrame = { MemoryStackFp, BackingStoreFp };


    //
    // Get address of where control left the establisher, the address of the
    // function table entry that describes the function, and the address of
    // the scope table.
    //

    FunctionEntry = DispatcherContext->FunctionEntry;
    ImageBase = DispatcherContext->ImageBase;
    ScopeTable = (PSCOPE_TABLE) (ImageBase + *(PULONG) 
                     GetLanguageSpecificData(FunctionEntry, ImageBase));

    ControlPc = DispatcherContext->ControlPc - ImageBase;

    //
    // If an unwind is not in progress, then scan the scope table and call
    // the appropriate exception filter routines. Otherwise, scan the scope
    // table and call the appropriate termination handlers using the target
    // PC obtained from the context record.
    // are called.
    //

    if (IS_DISPATCHING(ExceptionRecord->ExceptionFlags)) {

        //
        // Scan the scope table and call the appropriate exception filter
        // routines.
        //

        ExceptionPointers.ExceptionRecord = ExceptionRecord;
        ExceptionPointers.ContextRecord = ContextRecord;
        for (Index = 0; Index < ScopeTable->Count; Index += 1) {
            if ((ControlPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                (ControlPc < ScopeTable->ScopeRecord[Index].EndAddress) &&
                (ScopeTable->ScopeRecord[Index].JumpTarget != 0)) {

                //
                // Call the exception filter routine.
                //

                ULONG Offset = ScopeTable->ScopeRecord[Index].HandlerAddress;

                switch (Offset & 0x7) {

                case 7:
                    Value = EXCEPTION_EXECUTE_HANDLER;
                    break;

                case 5:
                    Value = EXCEPTION_CONTINUE_SEARCH;
                    break;

                case 3:
                    Value = EXCEPTION_CONTINUE_EXECUTION;
                    break;

                default:
                    Value = __C_ExecuteExceptionFilter(
                                MemoryStackFp,
                                BackingStoreFp,
                                ExceptionRecord->ExceptionCode,
                                &ExceptionPointers,
                                (ImageBase + Offset),
                                TargetGp);
                    break;
                }


                //
                // If the return value is less than zero, then dismiss the
                // exception. Otherwise, if the value is greater than zero,
                // then unwind to the target exception handler. Otherwise,
                // continue the search for an exception filter.
                //

                if (Value < 0) {
                    return ExceptionContinueExecution;

                } else if (Value > 0) {

                    //
                    // Tell the debugger we are about to pass control to an 
                    // exception handler and pass the handler's address to
                    // NLG_Notify.
                    //

                    Handler = ImageBase + ScopeTable->ScopeRecord[Index].JumpTarget;

                    _NLG_Notify((PVOID)Handler, EstablisherFrame, 0x1);

                    RtlUnwind2(EstablisherFrame,
                               (PVOID)Handler,
                               ExceptionRecord,
			       // IA64 assumption:
                               // RtlUnwind2 will not use this as an address
                               (PVOID)(unsigned __int64)ExceptionRecord->ExceptionCode,
                               &ContextRecordEm);
                }
            }
        }

    } else {

        //
        // Scan the scope table and call the appropriate termination handler
        // routines.
        //

        PUNWIND_INFO Unw;

        Unw = (PUNWIND_INFO)(FunctionEntry->UnwindInfoAddress + ImageBase);
        TargetPc = ContextRecord->StIIP - ImageBase;

        TargetHandler = 0;
        if (Unw->Flags & 0x1000) {
            for (Index = 0; Index < ScopeTable->Count; Index += 1) {
                if ((TargetPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                   (TargetPc < ScopeTable->ScopeRecord[Index].EndAddress)) 
                {
                    TargetHandler = ScopeTable->ScopeRecord[Index].HandlerAddress;
                    break;
                }
            }
        }
        

        for (Index = 0; Index < ScopeTable->Count; Index += 1) {
            if ((ControlPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                (ControlPc < ScopeTable->ScopeRecord[Index].EndAddress)) {

                //
                // If the target PC is within the same scope the control PC
                // is within, then this is an uplevel goto out of an inner try
                // scope or a long jump back into a try scope. Terminate the
                // scan termination handlers.
                //
                // N.B. The target PC can be just beyond the end of the scope,
                //      in which case it is a leave from the scope.
                //


                if ((TargetPc >= ScopeTable->ScopeRecord[Index].BeginAddress) &&
                   (TargetPc < ScopeTable->ScopeRecord[Index].EndAddress)) {
                    break;

                } else {

                    //
                    // If the scope table entry describes an exception filter
                    // and the associated exception handler is the target of
                    // the unwind, then terminate the scan for termination
                    // handlers. Otherwise, if the scope table entry describes
                    // a termination handler, then record the address of the
                    // end of the scope as the new control PC address and call
                    // the termination handler.
                    //

                    if (ScopeTable->ScopeRecord[Index].JumpTarget != 0) {
                        if (TargetPc == ScopeTable->ScopeRecord[Index].JumpTarget) {
                            break;
                        }

                    } else {

                        if (TargetHandler == ScopeTable->ScopeRecord[Index].HandlerAddress) {
                            break;
                        }

                        DispatcherContext->ControlPc = ImageBase +
                                ScopeTable->ScopeRecord[Index].EndAddress;

                        Handler = ImageBase + ScopeTable->ScopeRecord[Index].HandlerAddress;
                        __C_ExecuteTerminationHandler(
                            MemoryStackFp,
                            BackingStoreFp,
                            TRUE,
                            Handler,
                            TargetGp);
                    }
                }
            }
        }
    }

    //
    // Continue search for exception or termination handlers.
    //

    return ExceptionContinueSearch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\misc\ia64\setjmpex.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
// Module Name:
//
//    setjmpex.s
//
// Abstract:
//
//    This module implements the IA64 specific routine to perform a setjmp.
//
//    N.B. This module has two entry points that provide SAFE and UNSAFE 
//         handling of setjmp.
//
// Author:
//
//    William K. Cheung (wcheung) 27-Jan-1996
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Modified to support mixed ISA.
//
//--

#include "ksia64.h"


        .global     _setjmpex
        .type       _setjmpex, @function
        .global     _setjmp_common
        .type       _setjmp_common, @function

        .sdata
        .align      8
_setjmpexused::
        data8       _setjmpex


//++
//
// int
// setjmpex (
//    IN jmp_buf JumpBuffer
//    )
//
// Routine Description:
//
//    This function saved the current nonvolatile register state in the
//    specified jump buffer and returns a function vlaue of zero.
//
// Arguments:
//
//    JumpBuffer (a0) - Supplies the address of a jump buffer to store the
//       jump information.
//
//    MemoryStackFp (a1) - Supplies the memory stack frame pointer (psp)
//       of the caller.  It's an optional argument.
//
// Return Value:
//
//    A value of zero is returned.
//
//--

        NESTED_ENTRY(_setjmpex)

        LEAF_SETUP(3, 0, 0, 0)

        rUnat       = t8
        rFpsr       = t9
        rPsp        = a1
        rBsp        = a2

        movl        t4 = 0x130324356            // ascii code of "VC20"

        mov         rUnat = ar.unat
        mov         rFpsr = ar.fpsr
        add         t2 = JbCookie, a0
        ;;

        st8.nta     [t2] = t4, JbUnwindData-JbCookie // save the magic cookie
        add         t3 = JbUnwindData+8, a0
        ;;

        st8.nta     [t2] = rPsp, 8
        st8.nta     [t3] = rBsp
        br.sptk.many _setjmp_common
        ;;

        NESTED_EXIT(_setjmpex)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\bintree.cpp ===
/***
*bintree.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   Removed alloca dependency for CRT independence
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Everything is now prefixed with _RTC_
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

void 
_RTC_BinaryTree::BinaryNode::kill() throw()
{
    if (l)
    {
        l->kill();
        delete l;
    }
    if (r)
    {
        r->kill();
        delete r;
    }
    delete val;
}

_RTC_Container *
_RTC_BinaryTree::get(_RTC_HeapBlock *data) throw()
{
    BinaryNode *t = tree;
    while (t)
    {
        if (t->val->contains(data))
            return t->val;

        if (*t->val->info() < *data)
            t = t->l;
        else
            t = t->r;
    }
    return 0;
}


_RTC_Container *
_RTC_BinaryTree::add(_RTC_HeapBlock* data) throw()
{
    BinaryNode *t = tree;
    if (!tree)
    {
        tree = new BinaryNode(0,0,new _RTC_Container(data));
        return tree->val;
    }
    for (;;)
    {
        if (*t->val->info() < *data)
        {
            // before this one
            if (t->l)
                t = t->l;
            else 
            {
                t->l = new BinaryNode(0,0,new _RTC_Container(data));
                return t->l->val;
            }
        } else 
        {
            if (t->r)
                t = t->r;
            else
            {
                t->r = new BinaryNode(0, 0, new _RTC_Container(data));
                return t->r->val;
            }
        }
    }
}


_RTC_Container *
_RTC_BinaryTree::del(_RTC_HeapBlock *data) throw()
{
    BinaryNode **prv = &tree;
    while (*prv && (*prv)->val->info() != data)
    {
        prv = (*(*prv)->val->info() < *data) ? &(*prv)->l : &(*prv)->r;
    }

    if (!*prv)
        return 0;

    BinaryNode *dl = *prv;
    
    if (dl->r) 
    {
        *prv = dl->r;
        BinaryNode *left = dl->r;
        
        while (left->l)
            left = left->l;

        left->l = dl->l;
    
    } else 
        *prv = dl->l;

    _RTC_Container* res = dl->val;
    delete dl;
    return res;
}


_RTC_Container *
_RTC_BinaryTree::FindNext(_RTC_BinaryTree::iter *i) throw()
{
    // Return the next element from the iterator
    // If the iterator is done, free up it's memory
    if (++i->curSib >= i->totSibs) 
    {
        VirtualFree(i->allSibs, 0, MEM_RELEASE);
        i->curSib = i->totSibs = 0;
        return 0;
    } else
        return i->allSibs[i->curSib];
}

_RTC_Container *
_RTC_BinaryTree::FindFirst(_RTC_BinaryTree::iter *i) throw()
{
    // Initialize the iterator, and return it's first element
    // Flatten the siblings into a nice array..
    struct stk {
        stk(stk *p, BinaryNode *i) : next(p), cur(i) {}
        void *operator new(unsigned) {return _RTC_heap2->alloc();}
        void operator delete(void *p) {_RTC_heap2->free(p);}
        stk *next;
        BinaryNode *cur;
    };

    stk *stack = new stk(0, this->tree);
    stk *list = 0;
    stk *tmp;

    int count = 0;
    
    // Build a list of all elements (reverse in-order traversal)
    while (stack) 
    {
        BinaryNode *cur = stack->cur;
        tmp = stack;
        stack = stack->next;
        delete tmp;
        while (cur) 
        {
            list = new stk(list, cur);
            count++;
            if (cur->l)
                stack = new stk(stack, cur->l);
            cur = cur->r;
        }
    }
    i->totSibs = 0;
    i->curSib = 0;
    if (!count)
    {
        i->allSibs = 0;
        return 0;
    }

    i->allSibs = (_RTC_Container**)VirtualAlloc(0, sizeof(_RTC_Container*) * count,
                                           MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    while (list)
    {
        i->allSibs[i->totSibs++] = list->cur->val;
        tmp = list;
        list = list->next;
        delete tmp;
    }
    return i->allSibs[0];

}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\fileio.cpp ===
/***
*fileio.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   added throw() to eliminate C++ EH code & removed
*                       alloca to make more CRT independent
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   This stuff has been permanently cut
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#if 0

#error This stuff has all been cut, permanently - it belongs in the heap code,
#error not in compiler-provided extras

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\callsite.cpp ===
/***
*callsite.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   This stuff has been permanently canceled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#if 0

#error This stuff has all been cut - the CRT's heap could provide
#error equivalent functionality

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\chsyheap.cpp ===
/***
*chsyheap.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-25-99  KBF   Renamed - _RTC_SimpleHeap instead of CheesyHeap
*       05-26-99  KBF   Removed RTCl and RTCv, added _RTC_ADVMEM stuff
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

// This is my 'Cheesy Heap' implementation...

/* Here are the sizes that I need:

BinaryNode              3 DWORDS - use heap4
BinaryTree              1 DWORD  - use heap2
Container               2 DWORDS - use heap2
BreakPoint              2 DWORDS - use heap2
HashTable<HeapBlock>    2 DWORDS - use heap2
HeapBlock               6 DWORDS - use heap8

Container[] - short term...
CallSite[]  - permanent
HeapBlock[] - permanent

*/

_RTC_SimpleHeap *_RTC_heap2 = 0;
_RTC_SimpleHeap *_RTC_heap4 = 0;
_RTC_SimpleHeap *_RTC_heap8 = 0;

void *
_RTC_SimpleHeap::operator new(unsigned) throw()
{
    void *res = VirtualAlloc(NULL, ALLOC_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#ifdef _RTC_SHADOW
    if (shadow)
        _RTC_MSCommitRange((memptr)res, ALLOC_SIZE, IDX_STATE_ILLEGAL);
#endif
    return res;
}    

void 
_RTC_SimpleHeap::operator delete(void *addr) throw()
{
    VirtualFree(addr, 0, MEM_RELEASE);
#ifdef _RTC_SHADOW
    if (shadow)
        _RTC_MSDecommitRange((memptr)addr, ALLOC_SIZE);
#endif
}

_RTC_SimpleHeap::_RTC_SimpleHeap(unsigned blockSize)  throw()
{
    // Flag it as the only item in the heap
    head.next = 0;
    head.inf.top.nxtFree = 0;

    // Align the block size
    head.inf.top.wordSize = 8;
    blockSize = (blockSize - 1) >> 3;
    
    while (blockSize) {
        blockSize >>= 1;
        head.inf.top.wordSize <<= 1;
    }

    // Build up the free-list
    head.free = (FreeList*)(((unsigned)&head) + 
                           ((head.inf.top.wordSize < sizeof(HeapNode)) ?
                                sizeof(HeapNode) :
                                head.inf.top.wordSize));
    FreeList *t = head.free;
    while (((unsigned)t) + head.inf.top.wordSize < ((unsigned)&head) + ALLOC_SIZE)
    {
        t->next = (FreeList*)(((unsigned)t) + head.inf.top.wordSize);
        t = t->next;
    }
    t->next = 0;
}

_RTC_SimpleHeap::~_RTC_SimpleHeap() throw()
{
    // Free all sections that we have allocated
    HeapNode *n, *c = head.next;
    while(c) {
        n = c->next;
        _RTC_SimpleHeap::operator delete(c);
        c = n;
    }
    // the 'head' page will be handled by delete
}

void *
_RTC_SimpleHeap::alloc() throw()
{
    void *res;

    // If there's a free item, remove it from the list
    // And decrement the free count for it's parent page
    
    if (head.free) 
    {
        // There's a free block on the first page
        res = head.free;
        head.free = head.free->next;

        // Since it's on the top page, there's no free-count to update,
        // And it ain't on no stinkin' free-list
        
    } else if (head.inf.top.nxtFree)
    {
        // There's a free block on some page
        HeapNode *n = head.inf.top.nxtFree;
        
        res = n->free;
        n->free = n->free->next;
        n->inf.nontop.freeCount--;

        if (!n->free)
        {
            // This page is now full, so it must be removed from the freelist
            for (n = head.next; n && !n->free; n = n->next) {}
            // Now the nxtFree pointer is either null (indicating a full heap)
            // or it's pointing to a page that has free nodes
            head.inf.top.nxtFree = n;
        }
        
    } else 
    {
        // No pages have any free blocks
        // Get a new page, and add it to the list
        HeapNode *n = (HeapNode *)_RTC_SimpleHeap::operator new(0);
        
        // Count the number of free nodes
        n->inf.nontop.freeCount = 
            (ALLOC_SIZE - sizeof(HeapNode)) / head.inf.top.wordSize - 1;
   
        res = (void *)(((unsigned)n) + 
                        ((head.inf.top.wordSize < sizeof(HeapNode)) ?
                            sizeof(HeapNode) :
                            head.inf.top.wordSize));
        
        // Build the free-list for this node
        FreeList *f;
        for (f = n->free = (FreeList*)(((unsigned)res) + head.inf.top.wordSize);
             ((unsigned)f) + head.inf.top.wordSize < ((unsigned)n) + ALLOC_SIZE;
             f = f->next)
            f->next = (FreeList*)(((unsigned)f) + head.inf.top.wordSize);
        
        f->next = 0;
             
        // Stick it in the page list
        n->next = head.next;
        n->inf.nontop.prev = &head;
        head.next = n;
        
        // Flag this as a page with free stuff on it...
        head.inf.top.nxtFree = n;
    }
    return res;
}

void
_RTC_SimpleHeap::free(void *addr) throw()
{
    // Get the heap node for this address
    HeapNode *n = (HeapNode *)(((unsigned)addr) & ~(ALLOC_SIZE - 1));

    // Stick this sucker back in the free list
    FreeList *f = (FreeList *)addr;
    f->next = n->free;
    n->free = f;

    if (n == &head)
        // If this is in the head node, just return...
        return;
    
    if (++n->inf.nontop.freeCount == 
        (ALLOC_SIZE - sizeof(HeapNode)) / head.inf.top.wordSize)
    {
        // This page is free
        if (head.inf.top.freePage)
        {
            // There's already another free page, go ahead and free this one
            
            // (there's always a previous node)
            n->inf.nontop.prev->next = n->next;
            if (n->next)
                n->next->inf.nontop.prev = n->inf.nontop.prev;
            _RTC_SimpleHeap::operator delete(n);
                
            if (head.inf.top.nxtFree == n)
            {   
                // This was the free page
                // find a page with some free nodes on it...
                for (n = head.next; !n->free; n = n->next) {}
                // ASSERT(n)
                // If n is null, we're in some serious trouble...
                head.inf.top.nxtFree = n;
            }
            // If it wasn't the free page, we're just fine...
        } else
        { 
            // flag the freePages to say we have a 100% free page
            head.inf.top.freePage = true;

            if (head.inf.top.nxtFree == n)
            {
                // If this is the free page,
                // try to find another page with some free nodes
                HeapNode *t;
                for (t = head.next; t && (!t->free || t == n) ; t = t->next) {}

                // if there was a different page with some nodes, pick it
                head.inf.top.nxtFree = t ? t : n;
            }
        }
    } else
        // This page isn't empty, so just set it as the next free
        head.inf.top.nxtFree = n;
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\convert.cpp ===
/***
*convert.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   Moved pragma optimize to rtcpriv header
*       05-11-99  KBF   Error if RTC support define not enabled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

char __fastcall 
_RTC_Check_2_to_1(short big)
{
    unsigned bits = big & 0xFF00;
    if (bits && bits != 0xFF00)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (char)big;
}

char __fastcall 
_RTC_Check_4_to_1(int big)
{
    unsigned int bits = big & 0xFFFFFF00;
    if (bits && bits != 0xFFFFFF00)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (char)big;
}

char __fastcall 
_RTC_Check_8_to_1(__int64 big)
{
    unsigned __int64 bits = big & 0xFFFFFFFFFFFFFF00;
    if (bits && bits != 0xFFFFFFFFFFFFFF00)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (char)big;
}

short __fastcall 
_RTC_Check_4_to_2(int big)
{
    unsigned int bits = big & 0xFFFF0000;
    if (bits && bits != 0xFFFF0000)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (short)big;
}

short __fastcall 
_RTC_Check_8_to_2(__int64 big)
{
    unsigned __int64 bits = big & 0xFFFFFFFFFFFF0000;
    if (bits && bits != 0xFFFFFFFFFFFF0000)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (short)big;
}

int __fastcall 
_RTC_Check_8_to_4(__int64 big)
{
    unsigned __int64 bits = big & 0xFFFFFFFF00000000;
    if (bits && bits != 0xFFFFFFFF00000000)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (int)big;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\error.cpp ===
/***
*error.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   added throw() to eliminate C++ EH code
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Added -RTCu stuff, _RTC_ prefix on all non-statics
*       11-30-99  PML   Compile /Wp64 clean.
*       03-19-01  KBF   Fix buffer overruns (vs7#227306), eliminate all /GS
*                       checks (vs7#224261).
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#pragma intrinsic(strcpy)
#pragma intrinsic(strcat)
#pragma intrinsic(strlen)

static int __cdecl _IsDebuggerPresent();
int _RTC_ErrorLevels[_RTC_ILLEGAL] = {1,1,1,1};
static const char *_RTC_ErrorMessages[_RTC_ILLEGAL+1] =
{
    "The value of ESP was not properly saved across a function "
        "call.  This is usually a result of calling a function "
        "declared with one calling convention with a function "
        "pointer declared with a different calling convention.\n\r",
    "A cast to a smaller data type has caused a loss of data.  "
        "If this was intentional, you should mask the source of "
        "the cast with the appropriate bitmask.  For example:  \n\r"
        "\tchar c = (i & 0xFF);\n\r"
        "Changing the code in this way will not affect the quality of the resulting optimized code.\n\r",
    "Stack memory was corrupted\n\r",
    "A local variable was used before it was initialized\n\r",
#ifdef _RTC_ADVMEM
    "Referencing invalid memory\n\r",
    "Referencing memory across different blocks\n\r",
#endif
    "Unknown Runtime Check Error\n\r"
};

static const BOOL _RTC_NoFalsePositives[_RTC_ILLEGAL+1] =
{
    TRUE,   // ESP was trashed
    FALSE,  // Shortening convert
    TRUE,   // Stack corruption
    TRUE,   // Uninitialized use
#ifdef _RTC_ADVMEM
    TRUE,   // Invalid memory reference
    FALSE,  // Different memory blocks
#endif
    TRUE    // Illegal
};

// returns TRUE if debugger understands, FALSE if not
static BOOL
DebuggerProbe( DWORD dwLevelRequired ) throw()
{
    EXCEPTION_VISUALCPP_DEBUG_INFO info;
    BYTE bDebuggerListening = FALSE;

    info.dwType = EXCEPTION_DEBUGGER_PROBE;
    info.DebuggerProbe.dwLevelRequired = dwLevelRequired;
    info.DebuggerProbe.pbDebuggerPresent = &bDebuggerListening;

    __try
    {
        HelloVC( info );
    }
    __except(EXCEPTION_CONTINUE_EXECUTION)
    {
    }

    return (BOOL)bDebuggerListening;
}

// returns TRUE if debugger reported it (or was ignored), FALSE if runtime needs to report it
static int
DebuggerRuntime( DWORD dwErrorNumber, BOOL bRealBug, PVOID pvReturnAddr, LPCWSTR pwMessage ) throw()
{
    EXCEPTION_VISUALCPP_DEBUG_INFO info;
    BYTE bDebuggerListening = FALSE;

    info.dwType = EXCEPTION_DEBUGGER_RUNTIMECHECK;
    info.RuntimeError.dwRuntimeNumber = dwErrorNumber;
    info.RuntimeError.bRealBug = bRealBug;
    info.RuntimeError.pvReturnAddress = pvReturnAddr;
    info.RuntimeError.pbDebuggerPresent = &bDebuggerListening;
    info.RuntimeError.pwRuntimeMessage = pwMessage;

    __try
    {
        HelloVC( info );
    }
    __except(EXCEPTION_CONTINUE_EXECUTION)
    {
    }

    return (BOOL)bDebuggerListening;
}

static void
failwithmessage(void *retaddr, int crttype, int errnum, const char *msg)
{
    _RTC_error_fn fn = _RTC_GetErrorFunc(retaddr);
    bool dobreak;
    if (DebuggerProbe( EXCEPTION_DEBUGGER_RUNTIMECHECK ))
    {
        wchar_t *buf = (wchar_t*)_alloca(sizeof(wchar_t) * (strlen(msg) + 2));
        int i;
        for (i = 0; msg[i]; i++)
            buf[i] = msg[i];
        buf[i] = 0;
        if (DebuggerRuntime(errnum, _RTC_NoFalsePositives[errnum], retaddr, buf))
            return;
        dobreak = false;
    } else
        dobreak = true;
    if (!fn || (dobreak && _IsDebuggerPresent()))
        DebugBreak();
    else
    {
        char *srcName = (char*)_alloca(sizeof(char) * 513);
        int lineNum;
        char *moduleName;
        _RTC_GetSrcLine(((DWORD)(uintptr_t)retaddr)-5, srcName, 512, &lineNum, &moduleName);
        // We're just running - report it like the user setup (or the default way)
        // If we don't recognize this type, it defaults to an error
        if (fn(crttype, srcName, lineNum, moduleName,
               "Run-Time Check Failure #%d - %s", errnum, msg) == 1)
            DebugBreak();
    }
}

void __cdecl
_RTC_Failure(void *retaddr, int errnum)
{
    int crttype;
    const char *msg;

    if (errnum < _RTC_ILLEGAL && errnum >= 0) {
        crttype = _RTC_ErrorLevels[errnum];
        msg = _RTC_ErrorMessages[errnum];
    } else {
        crttype = 1;
        msg = _RTC_ErrorMessages[_RTC_ILLEGAL];
        errnum = _RTC_ILLEGAL;
    }

    // If we're running inside a debugger, raise an exception

    if (crttype != _RTC_ERRTYPE_IGNORE)
    {
        failwithmessage(retaddr, crttype, errnum, msg);
    }
}

static
char *IntToString(int i)
{
    static char buf[15];
    bool neg = i < 0;
    int pos = 14;
    buf[14] = 0;
    do {
        buf[--pos] = i % 10 + '0';
        i /= 10;
    } while (i);
    if (neg)
        buf[--pos] = '-';
    return &buf[pos];
}

void __cdecl
_RTC_MemFailure(void *retaddr, int errnum, const void *assign)
{
    char *srcName = (char*)_alloca(sizeof(char) * 513);
    int lineNum;
    char *moduleName;
    int crttype = _RTC_ErrorLevels[errnum];
    if (crttype == _RTC_ERRTYPE_IGNORE)
        return;
    _RTC_GetSrcLine(((DWORD)(uintptr_t)assign)-5, srcName, 512, &lineNum, &moduleName);
    if (!lineNum)
        _RTC_Failure(retaddr, errnum);
    else
    {
        char *msg = (char*)_alloca(strlen(_RTC_ErrorMessages[errnum]) +
                                    strlen(srcName) + strlen(moduleName) +
                                    150);
        strcpy(msg, _RTC_ErrorMessages[errnum]);
        strcat(msg, "Invalid pointer was assigned at\n\rFile:\t");
        strcat(msg, srcName);
        strcat(msg, "\n\rLine:\t");
        strcat(msg, IntToString(lineNum));
        strcat(msg, "\n\rModule:\t");
        strcat(msg, moduleName);
        failwithmessage(retaddr, crttype, errnum, msg);
    }
}

void __cdecl
_RTC_StackFailure(void *retaddr, const char *varname)
{
    int crttype = _RTC_ErrorLevels[_RTC_CORRUPT_STACK];
    if (crttype != _RTC_ERRTYPE_IGNORE)
    {
        char *msg = (char*)_alloca(strlen(varname) + 80);
        strcpy(msg, "Stack around the variable '");
        strcat(msg, varname);
        strcat(msg, "' was corrupted.");
        failwithmessage(retaddr, crttype, _RTC_CORRUPT_STACK, msg);
    }
}

void __cdecl
_RTC_UninitUse(const char *varname)
{
    int crttype = _RTC_ErrorLevels[_RTC_UNINIT_LOCAL_USE];
    if (crttype != _RTC_ERRTYPE_IGNORE)
    {
        char *msg = (char*)_alloca(strlen(varname) + 80);
        if (varname)
        {
            strcpy(msg, "The variable '");
            strcat(msg, varname);
            strcat(msg, "' is being used without being defined.");
        } else
        {
            strcpy(msg, "A variable is being used without being defined.");
        }
        failwithmessage(_ReturnAddress(), crttype, _RTC_UNINIT_LOCAL_USE, msg);
    }
}

/* The rest of this file just implements "IsDebuggerPresent" functionality */

#pragma pack (push, 1)

typedef struct _TIB {
    PVOID   ExceptionList;
    PVOID   StackLimit;
    PVOID   StackBase;
    PVOID   SubSystemTib;
    PVOID   Something1;
    PVOID   ArbitraryUserPointer;
    struct _TIB*    Self;
    WORD    Flags;
    WORD    Win16MutextCount;
    PVOID   DebugContext;
    DWORD   CurrentPriority;
    DWORD   MessageQueueSelector;
    PVOID*  TlsSlots;       // most likely an array
} TIB;

#pragma pack (pop)

//
// Define function to return the current Thread Environment Block
//  AXPMOD - v-caseyc 9/22/98  We use and intrinsic function _rdteb to get the Thread
//  Information Block

#if defined(_M_ALPHA)
void *_rdteb(void);
#pragma intrinsic(_rdteb)

static _inline TIB* GetCurrentTib() { return (TIB*) _rdteb(); }

#else   // If not _M_ALPHA                  (AXPMOD)

#pragma warning (disable:4035)
#define OffsetTib 0x18
static _inline TIB* GetCurrentTib() { __asm mov eax, fs:[OffsetTib] }
#pragma warning (default:4035)

#endif  // _M_ALPHA                         (End AXPMOD)


#define DLL_NOT_FOUND_EXCEPTION (0xc0000135L)

typedef BOOL (WINAPI* NT_IS_DEBUGGER_PRESENT) ();

static NT_IS_DEBUGGER_PRESENT FnIsDebuggerPresent = NULL;

static PVOID
WinGetDebugContext()
{
    return GetCurrentTib()->DebugContext;
}

// here's the Win95 version of IsDebuggerPresent
static BOOL WINAPI
Win95IsDebuggerPresent()
{
    if (WinGetDebugContext ()) {
        return TRUE;
    } else {
        return FALSE;
    }
}


static BOOL
Initialize()
{
    HINSTANCE       hInst = NULL;

    hInst = LoadLibrary ("Kernel32.dll");

    FnIsDebuggerPresent =
        (NT_IS_DEBUGGER_PRESENT) GetProcAddress (hInst, "IsDebuggerPresent");

    if (!FnIsDebuggerPresent) {
        OSVERSIONINFOA *VersionInfo = (OSVERSIONINFOA*)_alloca(sizeof(OSVERSIONINFOA));

        VersionInfo->dwOSVersionInfoSize = sizeof (OSVERSIONINFOA);

        if (GetVersionExA (VersionInfo) &&
            VersionInfo->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
            VersionInfo->dwMajorVersion == 4)
            FnIsDebuggerPresent = Win95IsDebuggerPresent;
    }

    return !!(FnIsDebuggerPresent);
}


// This is a version of IsDebuggerPresent () that works for all Win32 platforms.
static int __cdecl
_IsDebuggerPresent()
{
    static BOOL     fInited = FALSE;

    if (!fInited) {
        if (!Initialize())
            RaiseException (DLL_NOT_FOUND_EXCEPTION, 0, 0, NULL);
        fInited = TRUE;
    }

    return FnIsDebuggerPresent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\contain.cpp ===
/***
*contain.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   added throw() to eliminate C++ EH code
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Added _RTC_ prefix, _RTC_ADVMEM stuff
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

_RTC_Container *
_RTC_Container::AddChild(_RTC_HeapBlock *hb) throw()
{
    if (kids)
    {
        _RTC_Container *p = kids->get(hb);
        if (p)
            return p->AddChild(hb);
        kids->add(hb);

    } else
    {   
        kids = new _RTC_BinaryTree(new _RTC_Container(hb));
    }
    return this;
}


_RTC_Container *
_RTC_Container::DelChild(_RTC_HeapBlock* hb) throw()
{
    if (kids)
    {
        _RTC_Container *p = kids->get(hb);
        if (p)
        {
            if (p->inf == hb) {
                kids->del(hb)->kill();
                return this;
            } else
                return p->DelChild(hb);
        }
        kids->del(hb);
        return this;
    } else
        return 0;
}


_RTC_Container *
_RTC_Container::FindChild(_RTC_HeapBlock *i) throw()
{
    if (inf == i)
        return this;
    else if (kids)
    {
        _RTC_Container *res = kids->get(i);
        if (res)
            return res->FindChild(i);
    }
    return 0;
}


void 
_RTC_Container::kill() throw()
{
    if (kids) 
    {
        _RTC_BinaryTree::iter i;

        for (_RTC_Container *c = kids->FindFirst(&i); c; c = kids->FindNext(&i))
            c->kill();

        delete kids;
        kids = 0;
    } 
    
    if (inf)
    {
        delete inf;
        inf = 0;
    }
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\memory.cpp ===
/***
*memory.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       12-01-98  KBF   Added some debugging info for _RTC_DEBUG
*       12-02-98  KBF   Fixed MC 11240
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Wrapped in _RTC_ADVMEM, simplified due to loss of -RTClv
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

#ifdef _RTC_DEBUG

#include <windows.h>

#pragma intrinsic(strcpy)
#pragma intrinsic(strcat)

char *IntToString(int i)
{
    static char buf[15];
    bool neg = i < 0;
    int pos = 14;
    buf[14] = 0;
    do {
        int val = i % 16;
        if (val < 10)
            val += '0';
        else
            val = val - 10 + 'A';
        buf[--pos] = val;
        i /= 16;
    } while (i);
    if (neg)
        buf[--pos] = '-';
    return &buf[pos];
}

#endif



void __cdecl
_RTC_Allocate(void *addr, size_t size, short level)
{
    if (!addr)
        return;

#ifdef _RTC_DEBUG
    char buf[88];
    strcpy(buf, IntToString((int)retaddr));
    strcat(buf, " Allocate Memory located @ ");
    strcat(buf, IntToString((int)addr));
    strcat(buf, " of size ");
    strcat(buf, IntToString((int)size));
    strcat(buf, "\n");
    OutputDebugString(buf);
#endif

    _RTC_HeapBlock key(addr, level);
    _RTC_HeapBlock *hb = _RTC_heapblocks->find(&key);
    
    if (!hb) 
    {
        hb = new _RTC_HeapBlock(addr, level, size);
        _RTC_heapblocks->add(hb);
    
    } else
    {
        hb->size(size);
    }
    
    if (level) 
    {
        _RTC_Container *parent = _RTC_memhier->AddChild(hb);
        
        if (parent && parent->info())
        {
            hb->tag(_RTC_MSRenumberShadow((memptr)addr, size, parent->info()->tag()));
            return;
        }
    }
    hb->tag(_RTC_MSAllocShadow((memptr)addr, size, IDX_STATE_FULLY_KNOWN));
}

void __cdecl
_RTC_Free(void *mem, short level)
{
    if (!mem)
        return;


#ifdef _RTC_DEBUG
    char buf[88];
    strcpy(buf, IntToString((int)retaddr));
    strcat(buf, " Freeing Memory located at ");
    strcat(buf, IntToString((int)mem));
    strcat(buf, "\n");
    OutputDebugString(buf);
#endif

    bool fail = false;
    
    _RTC_HeapBlock key(mem, level);
    _RTC_HeapBlock *hb = _RTC_heapblocks->find(&key);
    
    if (hb)
    {
        if (level)
        {
            _RTC_Container *parent = _RTC_memhier->DelChild(hb);
            
            if (parent)
            {
                if (parent->info())
                    _RTC_MSRestoreShadow((memptr)(hb->addr()), hb->size(), parent->info()->tag());
                else
                    _RTC_MSFreeShadow((memptr)(hb->addr()), hb->size());
            }
        } else 
        {
            _RTC_heapblocks->del(hb);
            _RTC_MSFreeShadow((memptr)(hb->addr()), hb->size());
            delete hb;
        }
    }
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\init.cpp ===
/***
*init.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       10-12-98  KBF   Moved _RTC_IsEnabled here from UserAPI, and fixed it
*       10-13-98  KBF   Added _RTC_SetOutOfMemFunc
*       10-28-98  KBF   Added _RTC_Shutdown to prevent locks on FreeLibrary
*       11-03-98  KBF   added throw() to eliminate C++ EH code & improved
*                       termination code
*       11-24-98  KBF   Added additional callback to _RTC_MSPtrMemCheckN
*       11-25-98  KBF   Fixed initialization problem
*       12-03-98  KBF   Added APISet callback, and changed MSPtrMemCheckN
*                       to CheckMem
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   General cleanup - RTClv cut, _RTC_ADVMEM for reenabling
*                       -RTCm later
*       08-03-99  KBF   Fixed some pretty bad handle leaks, code cleanup &
*                       commenting
*       11-30-99  PML   Compile /Wp64 clean.
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"
#pragma intrinsic(memset)

#ifdef _RTC_ADVMEM
// This is the process wide global data struct pointer
// It must maintain backward compatibility at all times!
_RTC_globals                    *_RTC_globptr = 0;
// This is only actually used for shadow memory, but it doesn't really hurt
// And it serves as a placeholder for future work
CRITICAL_SECTION                _RTC_memlock;

    HashTable<_RTC_HeapBlock>   *_RTC_heapblocks    = 0;
    _RTC_Container              *_RTC_memhier       = 0;
    shadowtag                   *_RTC_shadow        = 0;
    index_elem                  *_RTC_pageidx       = 0;
    bool                        *_RTC_pi_array      = 0;
    bool                        _RTC_shadowmemory   = false;
#   define                      FUNCCOUNT           4
#else
#   define                      FUNCCOUNT           1
#endif // _RTC_ADVMEM

#ifdef _RTC_ADVMEM
static _RTC_Funcs   this_image;
static char         name[40]            = "#--------RTCSubsystem";  // scoped name for process wide synchronization
static HANDLE       init_mutex          = INVALID_HANDLE_VALUE;           // mutex for initialization & termination only
static HANDLE       work_mutex          = INVALID_HANDLE_VALUE;           // mutex for all RTC stuff
static HANDLE       sharedmem           = INVALID_HANDLE_VALUE;           // the memory mapped file
static void         *funcs[FUNCCOUNT]   = {                         // List of function pointers that the CRT need hooks too
#                                           ifdef _RTC_ADVMEM
                                                &_RTC_APISet, &_RTC_Allocate, &_RTC_Free, &_RTC_CheckMem_API
#                                           else
                                                0
#                                           endif
                                          };

static _RTC_globals * GetRTCGlobalData() throw();
static void  _RTC_NotifyOfGlobChange() throw();
static void  SetErrors() throw();
static void  InitMemoryTracking(bool advmem) throw();
static void  InitGlobals() throw();
static void  GetGlobals() throw();
static void  SetSMName(char which);
#endif

#if 0
void DBGdumpbin(void *addr, char *buf)
{
    unsigned int x = (unsigned int)addr;
    for (int i = 0; i < 8; i++) 
    {
        buf[7-i] = x & 15;
        if (buf[7-i] < 10)
            buf[7-i] += '0';
        else
            buf[7-i] += 'a' - 10;
        x = x >> 4;
    }
}
#endif


// This initializes the basics of the RTC subsystem
void  __cdecl 
_RTC_InitBase(void)
{
    static bool init = false;
    if (init)
        return;
    init = true;
    _RTC_SetErrorFunc(_CRT_RTC_INIT(0, 0, 0, _RTC_CURRENT_VERSION, 0));
}

void  __cdecl
_RTC_Shutdown(void)
{
    _CRT_RTC_INIT(0, 0, 0, _RTC_CURRENT_VERSION, 1);
}

#ifdef _RTC_ADVMEM
// This initializes the shadow memory subsystem
void  __cdecl
_RTC_InitAdvMem(void)
{
    ACQUIRE(INIT_MUTEX);
    if (_RTC_shadowmemory)
    {
        _RTC_SetErrorFunc(_CRT_RTC_INIT(init_mutex, funcs, FUNCCOUNT, _RTC_CURRENT_VERSION, 0));
        return;
    }
    
    ACQUIRE(WORK_MUTEX);

    GetGlobals();
   
    InitGlobals();

    if (_RTC_shadowmemory) 
    {
        _RTC_SetErrorFunc(_CRT_RTC_INIT(init_mutex, funcs, FUNCCOUNT, _RTC_CURRENT_VERSION, 0));
        return;
    }

    _RTC_shadowmemory = true;

    if (!_RTC_shadow)
        _RTC_MS_Init();

    InitMemoryTracking(true);

    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
        _RTC_NotifyOthersOfChange((void*)mbi.AllocationBase);

    RELEASE(WORK_MUTEX);
    RELEASE(INIT_MUTEX);
}
#endif
#ifdef _RTC_ADVMEM

// Remove this image from the list of running images...
void  __cdecl
_RTC_Shutdown(void)
{
    static bool run = false;
    MEMORY_BASIC_INFORMATION mbi, img_mbi;
    _RTC_Funcs *curfunc, *prev;
    
    if (!_RTC_globptr || run)
        return;
    run = true;    
    __try 
    {
        if (_RTC_Lock(INIT_MUTEX)) { __try
        {
            if (_RTC_Lock(WORK_MUTEX)) { __try
            {
                _CRT_RTC_INIT(init_mutex, funcs, FUNCCOUNT, _RTC_CURRENT_VERSION, 1);

                curfunc = _RTC_globptr->callbacks;
                prev = 0;

                VirtualQuery(&this_image, &img_mbi, sizeof(img_mbi));

                while (curfunc) 
                {
                    VirtualQuery(curfunc, &mbi, sizeof(mbi));
                    if (mbi.BaseAddress == img_mbi.BaseAddress)
                    {
                        if (prev)
                            prev->next = curfunc->next;
                        else
                            _RTC_globptr->callbacks = curfunc->next;
                    } else if (mbi.State != MEM_COMMIT)
                    {
                        if (prev)
                            prev->next = 0;
                        else
                            _RTC_globptr->callbacks = 0;
                        OutputDebugString("RTC Shutdown problem detected...");
                        break;
                    } else
                        prev = curfunc;
                    curfunc = curfunc->next;
                }
            } __finally { _RTC_Unlock(WORK_MUTEX); } }
        } __finally { _RTC_Unlock(INIT_MUTEX); } }
    } __finally
    {
        CloseHandle(init_mutex);
        CloseHandle(work_mutex);
        if (_RTC_globptr)
            UnmapViewOfFile(_RTC_globptr);
        CloseHandle(sharedmem);
        init_mutex = work_mutex = sharedmem = INVALID_HANDLE_VALUE;
    }
}

static void  
GetGlobals() throw()
{
    static bool init = false;
    if (init)
        return;
    init = true;

    // Setup the error types for this instance
    for (int i = 0; i < _RTC_ILLEGAL; i++)
        _RTC_ErrorLevels[i] = 1;

    if (!_RTC_globptr)
        _RTC_globptr = GetRTCGlobalData();
    
    if(_RTC_globptr)
        _RTC_NotifyOfGlobChange();
}


static void  
InitGlobals() throw()
{
    static bool init = false;
    if (init)
        return;
    init = true;

#ifdef _RTC_ADVMEM
    if (!_RTC_heap2)
    {
        _RTC_heap2 = new _RTC_SimpleHeap(8);
        _RTC_heap4 = new _RTC_SimpleHeap(16);
        _RTC_heap8 = new _RTC_SimpleHeap(32);
    }
#endif

    // Add this module to the list of callbacks

    MEMORY_BASIC_INFORMATION mbi;
    if (_RTC_globptr && VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
    {
        this_image.err = 0;
        this_image.next = _RTC_globptr->callbacks;
        this_image.notify = &_RTC_NotifyOfGlobChange;
        this_image.allocationBase = mbi.AllocationBase;
#ifdef _RTC_ADVMEM
        this_image.shadowoff = 0;
#endif
        _RTC_globptr->callbacks = &this_image;
    }
}

static void  
InitMemoryTracking(bool advmem) throw()
{
    static bool init = false;
    if (init)
        return;
    init = true;

    // Build the memory block hash table
    void *hbmem = VirtualAlloc(0, 65521 * sizeof(_RTC_HeapBlock*), 
                               MEM_RESERVE | MEM_COMMIT, 
                               PAGE_READWRITE);

    _RTC_heapblocks = new HashTable<_RTC_HeapBlock>(65521, hbmem);

    _RTC_MSAllocShadow((memptr)hbmem, 65521 * sizeof(_RTC_HeapBlock*), IDX_STATE_ILLEGAL);
    
    _RTC_memhier = new _RTC_Container(0);

    _RTC_MSAllocateGlobals();

    _RTC_SetErrorFunc(_CRT_RTC_INIT(init_mutex, funcs, 2 + (advmem ? 2 : 0), _RTC_CURRENT_VERSION, 0));
}
#endif

// This is code to post process wide values...
#ifdef _RTC_ADVMEM

static void  
SetSMName(char which)
{
    name[0] = which;

    if (name[1] != '-')
        return;

    DWORD pid = GetCurrentProcessId();
    char *num = &(name[1]);
    for (int i = 0; i < 8; i++) 
    {
        *num = (char)('A' + (pid & 0xF));
        num++;
        pid >>= 4;
    }
}

bool
_RTC_Lock(int work) // currently work = 1, init = 0
{
    HANDLE mutex = (work == WORK_MUTEX) ? work_mutex : init_mutex;
    char chr = (work == WORK_MUTEX) ? 'W' : 'I';
    if (mutex == INVALID_HANDLE_VALUE)
    {
        SetSMName(chr);
        mutex = CreateMutex(NULL, FALSE, name);
        if (mutex == INVALID_HANDLE_VALUE)
            return false;
    }
    WaitForSingleObject(mutex, INFINITE);
    return true;
}

void  
_RTC_Unlock(int work)
{
    ReleaseMutex((work == WORK_MUTEX) ? work_mutex : init_mutex);
}

static _RTC_globals*  
GetRTCGlobalData() throw()
{
    // Try to open the memory mapped file
    // If it's not created, create it & init it to zeroes

    SetSMName('F');

    sharedmem = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                                  0, _RTC_GLOBALS_SIZE, name);

    if (!sharedmem)
        return 0;
    
    DWORD lastErr = GetLastError();
    _RTC_globals* data = (_RTC_globals *)MapViewOfFile(sharedmem, 
                                                     FILE_MAP_ALL_ACCESS, 
                                                     0, 0, 0);

    if (!data)
        return 0;

    if (lastErr != ERROR_ALREADY_EXISTS)
    {
        memset(data, 0, sizeof(_RTC_globals));
    }

    return data;
}

// This function should be called when data in the global pointer has changed
// This stuff is highly version sensitive!  Be careful!
static void  
_RTC_NotifyOfGlobChange() throw()
{
    _RTC_memlock = _RTC_globptr->memlock;
#ifdef _RTC_ADVMEM
    _RTC_heap2 = _RTC_globptr->heap2;
    _RTC_heap4 = _RTC_globptr->heap4;
    _RTC_heap8 = _RTC_globptr->heap8;
    _RTC_shadow = _RTC_globptr->shadow;
    _RTC_pageidx = _RTC_globptr->pageidx;
    _RTC_pi_array = _RTC_globptr->pi_array;
    _RTC_memhier = _RTC_globptr->memhier;
    _RTC_heapblocks = _RTC_globptr->heapblocks;
    _RTC_shadowmemory = _RTC_globptr->shadowmemory;
#endif
}

// This function should be called when local data has changed 
// and needs copied to global data
// This stuff is highly version sensitive!  Be careful!
void  
_RTC_NotifyOthersOfChange(void *addr)
{
    _RTC_globptr->memlock = _RTC_memlock;
#ifdef _RTC_ADVMEM
    _RTC_globptr->heap2 = _RTC_heap2;
    _RTC_globptr->heap4 = _RTC_heap4;
    _RTC_globptr->heap8 = _RTC_heap8;
    _RTC_globptr->shadow = _RTC_shadow;
    _RTC_globptr->heapblocks = _RTC_heapblocks;
    _RTC_globptr->memhier = _RTC_memhier;
    _RTC_globptr->pageidx = _RTC_pageidx;
    _RTC_globptr->pi_array = _RTC_pi_array;
    _RTC_globptr->shadowmemory = _RTC_shadowmemory;
#endif
    
    for (_RTC_Funcs *f = _RTC_globptr->callbacks; f; f = f->next)
        if (f->allocationBase != addr)
            f->notify();
}

void  __cdecl
_RTC_SetOutOfMemFunc(int (*func)(void))
{
    if (!_RTC_Lock())
        return;
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
    {
        for (_RTC_Funcs *f = _RTC_globptr->callbacks; f; f = f->next)
        {
            if (f->allocationBase == mbi.AllocationBase)
            {
                f->shadowoff = func;
                _RTC_Unlock();
                return;
            }
        }
    }
    _RTC_Unlock();
}
#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\stack.cpp ===
/***
*stack.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

/* Stack Checking Calls */
void
#ifndef _M_ALPHA		// AXPMOD - No declspec(naked) for us.
__declspec(naked) 
#endif
_RTC_CheckEsp() 
{
#ifndef _M_ALPHA		// AXPMOD - Disable this until we can get the
						// assembly written for it.
    __asm 
    {
        jne esperror    ; 
        ret

    esperror:
        ; function prolog

        push ebp
        mov ebp, esp
        sub esp, __LOCAL_SIZE

        push eax        ; save the old return value
        push edx

        push ebx
        push esi
        push edi
    }

    _RTC_Failure(_ReturnAddress(), _RTC_CHKSTK);

    __asm 
    {
        ; function epilog

        pop edi
        pop esi
        pop ebx

        pop edx         ; restore the old return value
        pop eax

        mov esp, ebp
        pop ebp
        ret
    }
#endif
}

void __fastcall 
_RTC_CheckStackVars(void *frame, _RTC_framedesc *v)
{
    int i;
    for (i = 0; i < v->varCount; i++)
    {
        int *head = (int *)(((char *)frame) + v->variables[i].addr + v->variables[i].size);
        int *tail = (int *)(((char *)frame) + v->variables[i].addr - sizeof(int));
        
        if (*tail != 0xcccccccc || *head != 0xcccccccc) 
            _RTC_StackFailure(_ReturnAddress(), v->variables[i].name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\userapi.cpp ===
/***
*userapi.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       07-30-98  JWM   errnum is now type _RTC_ErrorNumber throughout.
*       10-09-98  KBF   moved _RTC_IsEnabled to init.cpp (it now works for
*                       EXE/DLL combos)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Updated for -RTCu, -RTClv cancelled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

static const char *_RTC_errlist[_RTC_ILLEGAL] =
{
    "Stack pointer corruption",
    "Cast to smaller type causing loss of data",
    "Stack memory corruption",
    "Local variable used before initialization"
#ifdef _RTC_ADVMEM
    ,
    "Accessing invalid memory",
    "Accessing memory from different heap blocks"
#endif
};

static _RTC_error_fn _RTC_ErrorReportFunc = 0;

int __cdecl 
_RTC_NumErrors(void)
{
    return _RTC_ILLEGAL;
}

const char * __cdecl 
_RTC_GetErrDesc(_RTC_ErrorNumber errnum)
{
    if (errnum < 0 || errnum >= _RTC_ILLEGAL)
        return 0;
    return _RTC_errlist[errnum];
}

int __cdecl 
_RTC_SetErrorType(_RTC_ErrorNumber errnum, int type)
{
    if (errnum >= 0 && errnum < _RTC_ILLEGAL)
    {
        int res = _RTC_ErrorLevels[errnum];
        _RTC_ErrorLevels[errnum] = type;
        return res;
    } else
        return -1;
}


_RTC_error_fn __cdecl 
_RTC_SetErrorFunc(_RTC_error_fn func)
{
    // We've got a global data structure: add this to the error func list
    _RTC_error_fn res;
    res = _RTC_ErrorReportFunc;
    _RTC_ErrorReportFunc = func;
    return res;
}

_RTC_error_fn
_RTC_GetErrorFunc(LPCVOID addr)
{
#ifdef _RTC_ADVMEM
    MEMORY_BASIC_INFORMATION mbi;

    if (!_RTC_globptr || !VirtualQuery(addr, &mbi, sizeof(mbi)))
        return _RTC_ErrorReportFunc;

    for (_RTC_Funcs *fn = _RTC_globptr->callbacks; fn; fn = fn->next)
        if (fn->allocationBase == mbi.AllocationBase)
            return fn->err;
#endif
    return _RTC_ErrorReportFunc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\shadow.cpp ===
/***
*shadow.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       08-13-98  KBF   Changed address cache to be 'invalid' address cache
*       08-13-98  KBF   Turned on optimization, modified address calc functions
*       10-13-98  KBF   Added Shadow-Death notification capabilities
*       11-03-98  KBF   added pragma intrinsic to eliminate CRT code dependence
*       11-03-98  KBF   Also fixed bug with allocating blocks of 4K multiples
*       12-01-98  KBF   Fixed a bug in RTC_MSFreeShadow - MC 11029
*       12-02-98  KBF   Fixed _RTC_MSR0AssignPtr
*       12-03-98  KBF   Added CheckMem_API and APISet functions
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-14-99  KBF   Requires _RTC_ADVMEM (it's been cut for 7.0)
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

static const unsigned MEM_SIZE = 0x40000000;
// This tag is valid?
#define MEM_ISVALID(tag) (tag)
// Both tags in this short are valid
#define MEM_SHORTVALID(tag) (((tag) & 0xFF) && ((tag) & 0xFF00))
// All 4 tags in this int are valid
#define MEM_INTVALID(tag) (((tag) & 0xFF) && ((tag) & 0xFF00) && ((tag) & 0xFF0000) && ((tag) & 0xFF000000))
// Given an address, get a shadow memory index
#define MEM_FIXADDR(addr) ((addr) & (MEM_SIZE - 1))
// An int's worth of unused values
static const unsigned int MEM_EMPTYINT = 0;
// An unused value
static const shadowtag MEM_EMPTY = 0;
// An untracked value
static const shadowtag MEM_UNKNOWN = 0xFF;
static const unsigned int MEM_UNKNOWNINT = 0xFFFFFFFF;

#define MEM_NEXT_ID(a) ((shadowtag)((a) % 253 + 1))

static const unsigned int PAGE_SIZE = 4096;

/* Page Index Macros */
static const unsigned int PAGES_PER_ELEM = 1;
static const unsigned int MEM_PER_IDX = PAGE_SIZE; // 4K
static const unsigned int IDX_SIZE = ((MEM_SIZE / MEM_PER_IDX) * sizeof(index_elem)) / PAGES_PER_ELEM;
static const unsigned int IDX_STATE_TRACKED        = 0x2; // bitmask

#define SET_IDX_STATE(idx, st) (_RTC_pageidx[idx]=st)
#define GET_IDX_STATE(idx) (_RTC_pageidx[idx])

// Get the index number for a given address
#define IDX_NUM(addr) (MEM_FIXADDR(addr) / MEM_PER_IDX)

// Index align this address
#define IDX_ALIGN(addr) ((addr) & ~(MEM_PER_IDX - 1))

#ifdef _RTC_DEBUG
// Debugging helper functions
#define show(a, b) unsigned b(unsigned c) { return a(c); }
show(GET_IDX_STATE, get_idx_state)
show(IDX_NUM, idx_num)
show(IDX_ALIGN, idx_align)
#undef show
#endif

// This is the pseudo-address used for REG0 in the cache
#define REG0 ((memref)1)

static shadowtag blockID = 0;

static void KillShadow();

#ifdef __MSVC_RUNTIME_CHECKS
#error Hey dufus, don't compile this file with runtime checks turned on
#endif

#pragma intrinsic(memset)

struct cacheLine
{
    memref pointer;
    memptr value;
    memptr base;
    void *assignment;
};

// Actual Cache Size is 2^CacheSize
// Cache is 8x3 - 24 elements total
#define CACHESIZE     3
#define CACHELINESIZE 3

static cacheLine cache[1<<CACHESIZE][CACHELINESIZE];
static long readlocks[1<<CACHESIZE];
static long writelocks[1<<CACHESIZE];
static long cachePos[1<<CACHESIZE];

#define READ_LOCK(line) \
{\
    while(InterlockedIncrement(&readlocks[line]) <= 0)\
    {\
        InterlockedDecrement(&readlocks[line]);\
        Sleep(0);\
    }\
}
#define READ_UNLOCK(line) InterlockedDecrement(&readlocks[line])

static void WRITE_LOCK(int line) 
{
    while (InterlockedExchange(&writelocks[line], 1))
        Sleep(0);
    long users = InterlockedExchange(&readlocks[line], -2000);
    while (readlocks[line] != -2000-users)
        Sleep(0);
}

#define WRITE_UNLOCK(line) {readlocks[line] = 0; writelocks[line] = 0;}

#define CacheHash(value) (((1 << CACHESIZE) - 1) & (value >> 3))

static void
ClearCacheRange(memptr lo, memptr hi)
{
    // Remove all pointers stored between lo and hi
    // We don't need to use locks, because this stuff is only
    // used for the stack, and if you're running on the same stack
    // you're in serious trouble...
    unsigned size = hi - lo;
    for (int i = 0; i < (1 << CACHESIZE); i++)
    {
        for (int j = 0; j < CACHELINESIZE; j++)
        {
            if (cache[i][j].pointer && 
                (unsigned)cache[i][j].pointer - (unsigned)lo < size)
                cache[i][j].pointer = 0;
        }
    }
}

static void
AddCacheLine(void *retaddr, memref ptr, memptr base, memptr value)
{
    if (!value)
        return;
    
    int loc = CacheHash((int)ptr);

    WRITE_LOCK(loc);
    int prefpos = 0;
    
    for (int i = 0; i < CACHELINESIZE; i++)
    {
        if (cache[loc][i].pointer == ptr)
        {
            prefpos = i+1;
            break;
        } else if (!prefpos && !cache[loc][i].pointer)
            prefpos = i+1;
    }

    if (!prefpos)
        prefpos = cachePos[loc];
    else
        prefpos--;
    
    cache[loc][prefpos].pointer = ptr;
    cache[loc][prefpos].value = value;
    cache[loc][prefpos].base = base;
    cache[loc][prefpos].assignment = retaddr;
    
    if (++prefpos == CACHELINESIZE)
        cachePos[loc] = 0;
    else
        cachePos[loc] = prefpos;
    
    WRITE_UNLOCK(loc);
}

static void
ClearCacheLine(memref ptr)
{
    int loc = CacheHash((int)ptr);

    READ_LOCK(loc);
    for (int i = 0; i < CACHELINESIZE; i++)
    {
        if (cache[loc][i].pointer == ptr)
        {
            READ_UNLOCK(loc);
            WRITE_LOCK(loc);
            cache[loc][i].pointer = 0;
            cachePos[loc] = i;
            WRITE_UNLOCK(loc);
            return;
        }
    }
    READ_UNLOCK(loc);
}

#define GetCacheLine(ptr, dst) {\
    int loc = CacheHash((int)ptr);\
    dst.pointer = 0;\
    READ_LOCK(loc);\
    for (int i = 0; i < CACHELINESIZE; i++)\
    {\
        if (cache[loc][i].pointer == ptr)\
        {\
            dst = cache[loc][i];\
            break;\
        }\
    }\
    READ_UNLOCK(loc);\
}

static void
ClearCache()
{
    for (int loc = 0; loc < 1 << CACHESIZE; loc++)
    {
        for (int i = 0; i < CACHELINESIZE; i++)
            cache[loc][i].pointer = 0;
        readlocks[loc] = writelocks[loc] = 0;
        cachePos[loc] = 0;
    }
}


// This is called before every function to allocate 
// locals in the shadow memory
void __fastcall
_RTC_MSAllocateFrame(memptr frame, _RTC_framedesc *v)
{
    if (!_RTC_shadow)
        return;

    int i;
    int memsize = -v->variables[v->varCount-1].addr + sizeof(int);

    // Next, commit all required pages, initializing all unallocated portions 
    // of newly committed memory to the proper state
    _RTC_MSCommitRange(frame - memsize, memsize, IDX_STATE_PARTIALLY_KNOWN);
    if (!_RTC_shadow)
        return;

    // Now step thru each variable, and allocate it within the shadow memory
    // While allocating, mark the buffer sections as invalid
    for (i = 0; i < v->varCount; i++)
    {
        *(unsigned*)(&_RTC_shadow[MEM_FIXADDR(frame + v->variables[i].addr - sizeof(int))]) = MEM_EMPTYINT;
        *(unsigned*)(&_RTC_shadow[MEM_FIXADDR(frame + v->variables[i].addr + v->variables[i].size)]) = MEM_EMPTYINT;
        blockID = MEM_NEXT_ID(blockID);
        memset(&_RTC_shadow[MEM_FIXADDR(frame + v->variables[i].addr)], blockID, v->variables[i].size);
    }
}

// Free the stack frame from shadow memory
void __fastcall
_RTC_MSFreeFrame(memptr frame, _RTC_framedesc *v)
{
    // I'm not bothering to attempt to free any shadow memory pages
    // This might cause problems for certain really poorly written programs...
    if (_RTC_shadow)
    {
        int size = (sizeof(int) + sizeof(int) - 1 - v->variables[v->varCount - 1].addr);
        memset(&_RTC_shadow[MEM_FIXADDR(frame-size)], MEM_UNKNOWN, size);

        // Temporary hack until we handle parameters
        ClearCacheRange(frame - size, frame);
    }
    // Cheap Bounds Check, to be sure that no external functions trash the stack
    _RTC_CheckStackVars((void*)frame, v);
}


// The list of global variable descriptors is constructed by dummy
// start and end descriptor here, in sections .rtc$MEA and .rtc$MEZ.
// The compiler emits .rtc$MEB entries for each global, under -RTCm.
// The linker sorts these together into the .rtc section. Note that the
// linker, under /DEBUG, inserts zero padding into the section for
// incremental compilation. We force the alignment of these descriptors,
// and thus the sections, to be the size of the structure, so no odd padding
// is inserted.
//
// The following is how the code *should* look:
//
// __declspec(align(8)) struct global_descriptor {
//     memptr addr;
//     unsigned size;
// };
// 
// #pragma section(".rtc$MEA", read)
// #pragma section(".rtc$MEZ", read)
// 
// __declspec(allocate(".rtc$MEA")) global_descriptor glob_desc_start = {0};
// __declspec(allocate(".rtc$MEZ")) global_descriptor glob_desc_end = {0};
//
// However, __declspec(align()), #pragma section, and __declspec(allocate())
// are all VC 6.1 features. It is a CRT requirement to compile the 6.1 CRT
// using only 6.0 language features (because NT 5 only uses the 6.0 compiler,
// I think). So here's how we do it:

struct global_descriptor
{
    union {
        double ___unused; // only here to force 8-byte alignment
        struct {
            memptr addr;
            unsigned size;
        };
    };
};

#pragma const_seg(".rtc$MEA")
const global_descriptor glob_desc_start = {0};
#pragma const_seg(".rtc$MEZ")
const global_descriptor glob_desc_end = {0};
#pragma const_seg()

// We must start our loop at &glob_desc_start, not &glob_desc_start + 1,
// because the pre-VC 6.1 compiler (specifically, the global optimizer)
// treats &glob_desc_start + 1 as distinct (unaliased) from &glob_desc_end,
// in the loop below. Thus, it gets rid of the loop test at the loop top.
// This is a problem for cases where there are no globals. This is done
// because it is expected that the 6.1 CRT will be compiled by pre-6.1
// compilers.

// Allocate the list of globals in shadow memory
void __cdecl
_RTC_MSAllocateGlobals(void)
{
    if (!_RTC_shadow)
        return;

    // Just step thru every item, and call _RTC_MSAllocShadow
    const global_descriptor *glob = &glob_desc_start;
    for (; glob != &glob_desc_end; glob++)
        _RTC_MSAllocShadow(glob->addr, glob->size, IDX_STATE_PARTIALLY_KNOWN);
}


// This should initialize the shadow memory as appropriate,
// committing all necessary pages
// partial implies that the page is only partially known
// so we need to be sure that all unallocated values on the
// page are set as a single valid block
short
_RTC_MSAllocShadow(memptr real_addr, unsigned real_size, unsigned state)
{
    // Ignore bogus zero address or size, possibly from globals linker padding
    if (!_RTC_shadow || !real_addr || !real_size)
        return 0;

    // Now allocate the shadow memory, if necessary
    if (state & IDX_STATE_TRACKED)
    {
        // Commit the shadow memory, 
        // marking newly committed, but unallocated memory as appropriate
        _RTC_MSCommitRange(real_addr, real_size, state);
        if (!_RTC_shadow)
            return blockID;

        // Now initialize the shadow memory
        blockID = MEM_NEXT_ID(blockID);

        memset(&_RTC_shadow[MEM_FIXADDR(real_addr)], blockID, real_size);
    } else if (state == IDX_STATE_ILLEGAL)
    {
        // Initialize the page index stuff to the correct state
        // ASSERT(state == IDX_STATE_ILLEGAL)

        unsigned idx_start = IDX_NUM(real_addr);
        unsigned idx_end = IDX_NUM(real_addr + real_size - 1);

        for (unsigned i = idx_start; i <= idx_end; i++)
            SET_IDX_STATE(i, state);
    }

    return blockID;
}

// This sets the value of the shadow memory to be the value passed in
void 
_RTC_MSRestoreShadow(memptr addr, unsigned size, short id)
{
    if (!_RTC_shadow)
        return;
    memset(&_RTC_shadow[MEM_FIXADDR(addr)], id, size);
}

// This assigns a new blockID to the shadow memory
// It will NOT be equal to the id passed in
short
_RTC_MSRenumberShadow(memptr addr, unsigned size, short notID)
{
    if (!_RTC_shadow)
        return 0;

    blockID = MEM_NEXT_ID(blockID);
    
    if (blockID == notID)
        blockID = MEM_NEXT_ID(blockID);
    
    memset(&_RTC_shadow[MEM_FIXADDR(addr)], blockID, size);
    return blockID;
}
    

// This should de-initialize shadow memory
// and decommit any unneeded pages
void _RTC_MSFreeShadow(memptr addr, unsigned size)
{
    if (!_RTC_shadow)
        return;

    // Low & Hi are the bounds of the freed memory region
    memptr low = MEM_FIXADDR(addr);
    memptr hi  = (low + size) & ~(sizeof(unsigned)-1);

    // start and end are the page-aligned bounds;
    memptr start = IDX_ALIGN(low);
    memptr end = IDX_ALIGN(low + size + MEM_PER_IDX - 1);

    memptr tmp;

    int used;

    // First, clear the shadow memory that contained this stuff
    memset(&_RTC_shadow[low], 
           (GET_IDX_STATE(IDX_NUM(low)) == IDX_STATE_PARTIALLY_KNOWN) 
            ? MEM_UNKNOWN 
            : MEM_EMPTY, 
           size);

    // Now go thru and release the pages that have
    // been completely eliminated from use
    for (tmp = start, used = 0; !used && tmp < low; tmp += sizeof(unsigned))
    {
        unsigned val = *(unsigned *)&_RTC_shadow[tmp];
        used = val != MEM_EMPTYINT && val != MEM_UNKNOWNINT;
    }

    if (used)
        start += MEM_PER_IDX;

    for (tmp = hi, used = 0; !used && tmp < end; tmp += sizeof(unsigned))
    {
        unsigned val = *(unsigned *)&_RTC_shadow[tmp];
        used = val != MEM_EMPTYINT && val != MEM_UNKNOWNINT;
    }

    if (used)
        end -= MEM_PER_IDX;

    if (start < end)
        // Free the page in memory
        _RTC_MSDecommitRange(start, end-start);

}

void _RTC_MSCommitRange(memptr addr, unsigned size, unsigned state)
{
    // Commit the page range
    if (!VirtualAlloc(&_RTC_shadow[MEM_FIXADDR(addr)], size, MEM_COMMIT, PAGE_READWRITE))
        KillShadow();
    else {
        // Now mark the range as committed in the page tables
        size += (addr - IDX_ALIGN(addr));
        int val = (state == IDX_STATE_PARTIALLY_KNOWN) ? MEM_UNKNOWNINT : MEM_EMPTYINT;
        while (size && !(size & 0x80000000)) 
        {
            // If this is a newly committed page, initialize it to the proper value
            if (GET_IDX_STATE(IDX_NUM(addr)) != state)
            {
                SET_IDX_STATE(IDX_NUM(addr), state);
                int *pg = (int*)&_RTC_shadow[MEM_FIXADDR(IDX_ALIGN(addr))];
                for (int i = 0; i < MEM_PER_IDX / sizeof(int); i++)
                    pg[i] = val;
            }
            addr += MEM_PER_IDX;
            size -= MEM_PER_IDX;
        }
    }
}

void _RTC_MSDecommitRange(memptr addr, unsigned size)
{
    // Decommit the page range
    VirtualFree(&_RTC_shadow[MEM_FIXADDR(addr)], size, MEM_DECOMMIT);

    // Now mark the range as decommited in the page tables
    size += (addr - IDX_ALIGN(addr));
    while (size && !(size & 0x80000000))
    {
        SET_IDX_STATE(IDX_NUM(addr), IDX_STATE_UNKNOWN);
        addr += MEM_PER_IDX;
        size -= MEM_PER_IDX;
    }
}

static shadowtag
GetAddrTag(memptr addr)
{
    shadowtag *loc = &_RTC_shadow[MEM_FIXADDR(addr)];
    if ((memptr)loc == addr)
        return MEM_EMPTY;
    
    if (addr & 0x80000000) 
        return MEM_UNKNOWN;
    switch (GET_IDX_STATE(IDX_NUM(addr)))
    {
    case IDX_STATE_UNKNOWN:
        return MEM_UNKNOWN;
    case IDX_STATE_ILLEGAL:
        return MEM_EMPTY;
    case IDX_STATE_PARTIALLY_KNOWN:
    case IDX_STATE_FULLY_KNOWN:
        return *loc;
    default:
        __assume(0);
    }
}

static void 
MemCheckAdd(void *retaddr, memptr base, int offset, unsigned size)
{
    // If base isn't really the base, don't assume offset is, 
    // just be sure the memory is valid
    shadowtag baseTag;
    if (base < offset) 
        baseTag = GetAddrTag(base + offset);
    else
        baseTag = GetAddrTag(base);
    
    // Step thru ever byte of the memory and verify that they're all the same
    for (unsigned i = 0; i < size; i++)
    {
        shadowtag newTag = GetAddrTag(base + offset + i);
        if (newTag != baseTag || newTag == MEM_EMPTY)
        {
            _RTC_Failure(retaddr, (newTag == MEM_EMPTY) 
                                  ? _RTC_INVALID_MEM 
                                  : _RTC_DIFF_MEM_BLOCK);
            return;
        }
    }
}


static void 
PtrMemCheckAdd(void *retaddr, memref base, int offset, unsigned size)
{
    if (*base < offset)
    {
        // if *base isn't really the base, just do a MemCheckAdd
        MemCheckAdd(retaddr, *base, offset, size);
        return;
    }
    
    shadowtag baseTag;
    cacheLine cl;
    GetCacheLine(base, cl);

    if (cl.pointer && cl.value == *base)
    {
        baseTag = GetAddrTag(cl.base);
    } else
        baseTag = GetAddrTag(*base);

    for (unsigned i = 0; i < size; i++)
    {
        shadowtag newTag = GetAddrTag(*base + offset + i);
        if (newTag != baseTag || newTag == MEM_EMPTY)
        {
            if (cl.pointer && cl.value == *base && cl.base)
                _RTC_MemFailure(retaddr, 
                                (newTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK,
                                cl.assignment);
            else
                _RTC_Failure(retaddr, 
                             (newTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK);
            return;
        }
    }
}

static void 
PtrMemCheck(void *retaddr, memref base, unsigned size)
{
    shadowtag baseTag = GetAddrTag(*base);
    cacheLine cl;
    GetCacheLine(base, cl);
    if (cl.pointer && cl.value == *base)
        _RTC_MemFailure(retaddr, 
                        (baseTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK,
                        cl.assignment);
    
    else for (unsigned i = 1; i < size; i++)
    {
        shadowtag newTag = GetAddrTag(*base + i);
        if (newTag != baseTag)
        {
            _RTC_Failure(retaddr, (newTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK);
            return;
        }
    }
}

memptr __fastcall 
_RTC_MSPtrPushAdd(memref dstoffset, memref base, int offset)
{
    if (_RTC_shadow)
    {
        memptr src = *base;
        memref dst = dstoffset - 4;

        shadowtag dstTag = GetAddrTag(src + offset);
        shadowtag srcTag = GetAddrTag(src);

        cacheLine cl;
        GetCacheLine(base, cl);
        memptr origBase = src;
    
        if (cl.pointer)
        {
            if (cl.value == src)
            {
                srcTag = GetAddrTag(cl.base);
                origBase = cl.base;
            } else
                ClearCacheLine(base);
        }
        
        if (srcTag != MEM_EMPTY)
        {
            if (dstTag != srcTag)
                AddCacheLine(_ReturnAddress(), dst, origBase, src + offset);
            else
                ClearCacheLine(dst);
        }
    }
    return *base + offset;
}

void __fastcall 
_RTC_MSPtrAssignAdd(memref dst, memref base, int offset)
{
    memptr src = *base;
    *dst = src + offset;
    if (!_RTC_shadow)
        return;

    // First, verify that the address is not in shadow memory
    shadowtag dstTag = GetAddrTag(*dst);
    shadowtag srcTag = GetAddrTag(src);

    cacheLine cl;
    GetCacheLine(base, cl);
    memptr origBase = src;
    
    if (cl.pointer)
    {
        if (cl.value == src)
        {
            srcTag = GetAddrTag(cl.base);
            origBase = cl.base;
        } else
            ClearCacheLine(base);
    }
        
    if (srcTag == MEM_EMPTY)
        return;

    if (dstTag != srcTag)
        AddCacheLine(_ReturnAddress(), dst, origBase, *dst);
    else
        ClearCacheLine(dst);
}

memptr __fastcall 
_RTC_MSPtrAssignR0(memref src)
{
    if (_RTC_shadow)
    {
        cacheLine cl;
        GetCacheLine(src, cl);
        if (cl.pointer)
        {
            if (cl.value == *src)
                AddCacheLine(_ReturnAddress(), REG0, cl.base, *src);
            else
                ClearCacheLine(src);
        }
    }
    return *src;
}

memptr __fastcall 
_RTC_MSPtrAssignR0Add(memref src, int offset)
{
    memptr dst = *src + offset;
    if (_RTC_shadow)
    {
        // First, verify that the address is tolerable 
        shadowtag dstTag = GetAddrTag(dst);
        shadowtag srcTag = GetAddrTag(*src);

        cacheLine cl;
        GetCacheLine(src, cl);
        memptr origBase = *src;

        if (cl.pointer)
        {
            if (cl.value == *src)
            {
                srcTag = GetAddrTag(cl.base);
                origBase = cl.base;
            } else
                ClearCacheLine(src);
        }
        
        if (srcTag != MEM_EMPTY)
        {
            if (dstTag != srcTag)
                AddCacheLine(_ReturnAddress(), REG0, origBase, dst);
            else
                ClearCacheLine(REG0);
        }
    }
    return *src + offset;
}

void __fastcall 
_RTC_MSR0AssignPtr(memref dst, memptr src)
{
    *dst = src;
    if (_RTC_shadow)
    {
        cacheLine cl;
        GetCacheLine(REG0, cl);
        if (cl.pointer)
        {
            if (cl.value == src)
                AddCacheLine(_ReturnAddress(), dst, cl.base, src);
            else
                ClearCacheLine(REG0);
        }
    }
}

void __fastcall 
_RTC_MSR0AssignPtrAdd(memref dst, memptr src, int offset)
{
    *dst = src + offset;
    if (_RTC_shadow)
    {
        shadowtag dstTag = GetAddrTag(*dst);
        shadowtag srcTag = GetAddrTag(src);

        cacheLine cl;
        GetCacheLine(REG0, cl);
        memptr origBase = src;

        if (cl.pointer)
        {
            if (cl.value == src)
            {
                srcTag = GetAddrTag(cl.base);
                origBase = cl.base;
            } else
                ClearCacheLine(REG0);
        }
        
        if (srcTag == MEM_EMPTY)
            return;
        
        if (dstTag != srcTag)
            AddCacheLine(_ReturnAddress(), dst, origBase, *dst);
        else
            ClearCacheLine(dst);
    }
}
    
memptr __fastcall 
_RTC_MSAddrPushAdd(memref dstoffset, memptr base, int offset)
{
    if (_RTC_shadow)
    {
        memref dst = dstoffset - 4;
        // First, verify that the address is not in shadow memory
        shadowtag dstTag = GetAddrTag(base + offset);
        shadowtag srcTag = GetAddrTag(base);

        if (dstTag == MEM_UNKNOWN && 
            (srcTag == MEM_EMPTY || srcTag == MEM_UNKNOWN))
            ClearCacheLine(dst);

        else if (dstTag == MEM_EMPTY ||
                (dstTag == MEM_UNKNOWN && srcTag != MEM_UNKNOWN) ||
                (srcTag == MEM_UNKNOWN && dstTag != MEM_UNKNOWN))
            AddCacheLine(_ReturnAddress(), dst, base, base + offset);
    
        else if (srcTag != MEM_EMPTY)
        {
            if (srcTag != dstTag)
                AddCacheLine(_ReturnAddress(), dst, base, base + offset);
        
            else
                ClearCacheLine(dst);
        }
    }
    return base + offset;
}

void __fastcall 
_RTC_MSAddrAssignAdd(memref dst, memptr base, int offset)
{
    *dst = base + offset;
    if (!_RTC_shadow)
        return;

    // First, verify that the address is not in shadow memory
    shadowtag dstTag = GetAddrTag(*dst);
    shadowtag srcTag = GetAddrTag(base);

    if (dstTag == MEM_UNKNOWN && 
        (srcTag == MEM_EMPTY || srcTag == MEM_UNKNOWN))
        ClearCacheLine(dst);

    else if (dstTag == MEM_EMPTY ||
            (dstTag == MEM_UNKNOWN && srcTag != MEM_UNKNOWN) ||
            (srcTag == MEM_UNKNOWN && dstTag != MEM_UNKNOWN))
        AddCacheLine(_ReturnAddress(), dst, base, *dst);
    
    else if (srcTag == MEM_EMPTY)
        return;

    else if (srcTag != dstTag)
        AddCacheLine(_ReturnAddress(), dst, base, *dst);

    else
        ClearCacheLine(dst);
}

void __fastcall 
_RTC_MSPtrAssign(memref dst, memref src)
{
    *dst = *src;
    if (!_RTC_shadow)
        return;
    cacheLine cl;
    GetCacheLine(src, cl);
    if (cl.pointer)
    {
        if (cl.value == *src)
            AddCacheLine(_ReturnAddress(), dst, cl.base, *src);
        else
            ClearCacheLine(src);
    }
}

memptr __fastcall 
_RTC_MSPtrPush(memref dstoffset, memref src)
{
    if (_RTC_shadow)
    {
        cacheLine cl;
        GetCacheLine(src, cl);
        if (cl.pointer)
        {
            if (cl.value == *src)
                AddCacheLine(_ReturnAddress(), dstoffset - 4, cl.base, *src);
            else
                ClearCacheLine(src);
        }
    }
    return *src;
}

memval1 __fastcall 
_RTC_MSPtrMemReadAdd1(memref base, int offset)
{
    memval1 res;
    __try
    {
        res = *(memval1*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 1);
    return res;
}

memval2 __fastcall 
_RTC_MSPtrMemReadAdd2(memref base, int offset)
{
    memval2 res;
    __try
    {
        res = *(memval2*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 2);
    return res;
}

memval4 __fastcall 
_RTC_MSPtrMemReadAdd4(memref base, int offset)
{
    memval4 res;
    __try
    {
        res = *(memval4*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 4);
    return res;
}

memval8 __fastcall 
_RTC_MSPtrMemReadAdd8(memref base, int offset)
{
    memval8 res;
    __try
    {
        res = *(memval8*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 8);
    return res;
}

memval1 __fastcall 
_RTC_MSMemReadAdd1(memptr base, int offset)
{
    memval1 res;
    __try
    {
        res = *(memval1*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 1);
    return res;
}

memval2 __fastcall 
_RTC_MSMemReadAdd2(memptr base, int offset)
{
    memval2 res;
    __try
    {
        res = *(memval2*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 2);
    return res;
}

memval4 __fastcall 
_RTC_MSMemReadAdd4(memptr base, int offset)
{
    memval4 res;
    __try
    {
        res = *(memval4*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 4);
    return res;
}

memval8 __fastcall 
_RTC_MSMemReadAdd8(memptr base, int offset)
{
    memval8 res;
    __try
    {
        res = *(memval8*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 8);
    return res;
}

memval1 __fastcall 
_RTC_MSPtrMemRead1(memref base)
{
    memval1 res;
    __try
    {
        res = *(memval1*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 1);
    return res;
}

memval2 __fastcall 
_RTC_MSPtrMemRead2(memref base)
{
    memval2 res;
    __try
    {
        res = *(memval2*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 2);
    return res;
}

memval4 __fastcall 
_RTC_MSPtrMemRead4(memref base)
{
    memval4 res;
    __try
    {
        res = *(memval4*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 4);
    return res;
}

memval8 __fastcall 
_RTC_MSPtrMemRead8(memref base)
{
    memval8 res;
    __try
    {
        res = *(memval8*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 8);
    return res;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd1(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 1);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd2(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 2);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd4(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 4);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd8(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 8);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAddN(memref base, int offset, unsigned size)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, size);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd1(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 1);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd2(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 2);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd4(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 4);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd8(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 8);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAddN(memptr base, int offset, unsigned size)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, size);
    return base + offset;
}

memptr __fastcall
_RTC_MSPtrMemCheck1(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 1);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheck2(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 2);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheck4(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 4);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheck8(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 8);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheckN(memref base, unsigned size)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, size);
    return *base;
}

static long enabled = 1;

void __fastcall 
_RTC_CheckMem_API(memref addr, unsigned size)
{
    if (enabled)
        _RTC_MSPtrMemCheckN(addr, size);
}

void __fastcall 
_RTC_APISet(int on_off)
{
    if (on_off)
        InterlockedIncrement(&enabled);
    else
        InterlockedDecrement(&enabled);
}

void _RTC_MS_Init()
{
    _RTC_shadow = (shadowtag *)VirtualAlloc(NULL, MEM_SIZE, MEM_RESERVE, PAGE_READWRITE);
    _RTC_pageidx = (index_elem*)VirtualAlloc(NULL, IDX_SIZE, MEM_COMMIT, PAGE_READWRITE);
    _RTC_MSAllocShadow((memptr)_RTC_pageidx, IDX_SIZE, IDX_STATE_ILLEGAL);
    ClearCache();
}


static void
KillShadow()
{
    // This is called if a call to VirtualAlloc failed - we need to turn off shadow memory
    bool didit = false;
    _RTC_Lock();

    if (_RTC_shadow) 
    {
        VirtualFree(_RTC_shadow, 0, MEM_RELEASE);
        VirtualFree(_RTC_pageidx, 0, MEM_RELEASE);
        _RTC_shadow = 0;
        _RTC_pageidx = 0;

        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
            _RTC_NotifyOthersOfChange((void*)mbi.AllocationBase);
        didit = true;
    }
    
    if (didit)
    {
        bool notify = true;
        for (_RTC_Funcs *f = _RTC_globptr->callbacks; f; f = f->next)
            if (f->shadowoff)
                notify = notify && (f->shadowoff()!=0);

        if (notify)
        {
            HINSTANCE user32 = LoadLibrary("USER32.DLL");
            if (!user32)
                return;
            typedef int (*pMsgBoxProc)(HWND,LPCTSTR,LPCTSTR,UINT);
            pMsgBoxProc pMsgBox = (pMsgBoxProc)GetProcAddress(user32, "MessageBoxA");
            if (!pMsgBox)
                return;
            pMsgBox(NULL, "The Advanced Memory Checking subsystem has run out of virtual memory,"
                          " and is now disabled. The checks will no longer occur for this process. "
                          "Try freeing up hard drive space for your swap file.",
                    "RTC Subsystem Failure",
                    MB_OK | MB_ICONWARNING | MB_DEFBUTTON1 | MB_SETFOREGROUND | MB_TOPMOST);
        }
    }
    _RTC_Unlock();
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\pdblkup.cpp ===
/***
*pdblkup.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Minor Cleanup, _RTC_ prefix added to GetSrcLine
*       11-30-99  PML   Compile /Wp64 clean.
*       06-20-00  KBF   Major mods to use PDBOpenValidate3 & MSPDB70
*       03-19-01  KBF   Fix buffer overruns (vs7#227306), eliminate all /GS
*                       checks (vs7#224261), use correct VS7 registry key.
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"
#include <tlhelp32.h>

#pragma warning(disable:4311 4312)      // 32-bit specific, ignore /Wp64 warnings

#define REGISTRY_KEY_MASTER HKEY_LOCAL_MACHINE
#define REGISTRY_KEY_NAME "EnvironmentDirectory"
#define REGISTRY_KEY_LOCATION "SOFTWARE\\Microsoft\\VisualStudio\\7.0\\Setup\\VS"

static const char *mspdbName = "MSPDB70.DLL";
static const mspdbNameLen = 11;

// Here's some stuff from the PDB header
typedef char *          SZ;
typedef ULONG           SIG;    // unique (across PDB instances) signature
typedef long            EC;     // error code
typedef USHORT          ISECT;  // section index
typedef LONG            OFF;    // offset
typedef LONG            CB;     // count of bytes
typedef BYTE*           PB;     // pointer to some bytes
struct PDB;                 // program database
struct DBI;                 // debug information within the PDB
struct Mod;                 // a module within the DBI
#define pdbRead                 "r"

// Here's some stuff from the psapi header
typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;

static HINSTANCE mspdb  = 0;
static HINSTANCE psapi  = 0;
static HINSTANCE imghlp = 0;
static HINSTANCE kernel = 0;

#define declare(rettype, call_type, name, parms)\
    extern "C" { typedef rettype ( call_type * name ## Proc) parms; }
#define decldef(rettype, call_type, name, parms)\
    declare(rettype, call_type, name, parms)\
    static name ## Proc name = 0

#define GetProcedure(lib, name) name = (name ## Proc)GetProcAddress(lib, #name)
#define GetW9xProc(lib, name) name ## W9x = (name ## W9xProc)GetProcAddress(lib, #name)

#define GetReqProcedure(lib, name, err) {if (!(GetProcedure(lib, name))) return err;}
#define GetReqW9xProc(lib, name, err) {if (!(GetW9xProc(lib, name))) return err;}

 
/* PDB functions */
decldef(BOOL, __cdecl, PDBOpenValidate3, 
        (SZ szExe, SZ szPath, OUT EC* pec, OUT SZ szError, OUT SZ szDbgPath, OUT DWORD *pfo, OUT DWORD *pcb, OUT PDB** pppdb));
decldef(BOOL, __cdecl, PDBOpenDBI, 
        (PDB* ppdb, SZ szMode, SZ szTarget, OUT DBI** ppdbi));
decldef(BOOL, __cdecl, DBIQueryModFromAddr,
        (DBI* pdbi, ISECT isect, OFF off, OUT Mod** ppmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb));
decldef(BOOL, __cdecl, ModQueryLines,
        (Mod* pmod, PB pbLines, CB* pcb));
decldef(BOOL, __cdecl, ModClose,
        (Mod* pmod));
decldef(BOOL, __cdecl, DBIClose, 
        (DBI* pdbi));
decldef(BOOL, __cdecl, PDBClose, 
        (PDB* ppdb));

/* ImageHlp Functions */
decldef(PIMAGE_NT_HEADERS, __stdcall, ImageNtHeader,
        (IN PVOID Base));

/* PSAPI Functions */
decldef(BOOL, WINAPI, GetModuleInformation,
        (HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb));
decldef(BOOL, WINAPI, EnumProcessModules,
        (HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded));

/* Win9X Functions */
decldef(HANDLE, WINAPI, CreateToolhelp32SnapshotW9x,
        (DWORD dwFlags, DWORD th32ProcessID));
decldef(BOOL, WINAPI, Module32FirstW9x,
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme));
decldef(BOOL, WINAPI, Module32NextW9x,
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme));

/* AdvAPI32 Functions */
declare(WINADVAPI LONG, APIENTRY, RegOpenKeyExA,
        (HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult));
declare(WINADVAPI LONG, APIENTRY, RegQueryValueExA,
        (HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData));
declare(WINADVAPI LONG, APIENTRY, RegCloseKey,
        (HKEY hKey));

struct ImageInfo {
    DWORD sig;
    DWORD BaseAddress;
    DWORD BaseSize;
    HMODULE hndl;
    PIMAGE_NT_HEADERS img;
    PIMAGE_SECTION_HEADER sectHdr;
    char *imgName;
    ImageInfo *next;
};

static ImageInfo *lImages = 0;

// I do lots of assignments in conditionals intentionally
#pragma warning(disable:4706) 

static ImageInfo *
GetImageInfo(DWORD address)
{
    ImageInfo *res, *cur;
    // This will not run the first time, because lImages is null
    for (res = lImages; res; res = res->next)
    {
        if (res->BaseAddress <= address && address - res->BaseAddress <= res->BaseSize)
            return res;
    }

    // We didn't find the address in the images we already know about
    // Let's refresh the image list, to see if it was delay-loaded
    
    // Clear out the old list
    while (lImages)
    {
        ImageInfo *next = lImages->next;
        HeapFree(GetProcessHeap(), 0, lImages);
        lImages = next;
    }

    if (!imghlp)
    {
        // We haven't already loaded all the DLL entrypoints we need

        kernel = LoadLibrary("KERNEL32.DLL");
        imghlp = LoadLibrary("IMAGEHLP.DLL");

        if (!kernel || !imghlp)
            return 0;
        
        GetReqProcedure(imghlp, ImageNtHeader, 0);

        GetW9xProc(kernel, CreateToolhelp32Snapshot);

        if (!CreateToolhelp32SnapshotW9x)
        {
            // We're running under WinNT, use PSAPI DLL

            psapi = LoadLibrary("PSAPI.DLL");
            if (!psapi) 
                return 0;

            GetReqProcedure(psapi, EnumProcessModules, 0);
            GetReqProcedure(psapi, GetModuleInformation, 0);
        } else
        {
            // We're running under Win9X, use the toolhelp functions
            GetReqW9xProc(kernel, Module32First, 0);
            GetReqW9xProc(kernel, Module32Next, 0);
        }
    }

    // Now we have all the callbacks we need, so get the process information needed
    if (!CreateToolhelp32SnapshotW9x)
    {
        // We're running under NT4
        // Note that I "prefer" using toolhelp32 - it's supposed to show up in NT5...
        HMODULE hModules[512];
        HANDLE hProcess = GetCurrentProcess();
        DWORD imageCount;

        if (!EnumProcessModules(hProcess, hModules, 512 * sizeof(HMODULE), &imageCount))
            return 0;

        imageCount /= sizeof(HMODULE);

        MODULEINFO info;
        for (DWORD i = 0; i < imageCount; i++)
        {
            if (!GetModuleInformation(hProcess, hModules[i], &info, sizeof(MODULEINFO)))
                return 0;
            
            if (!(cur = (ImageInfo *)HeapAlloc(GetProcessHeap(), 0, sizeof(ImageInfo))))
                goto CHOKE;

            cur->hndl = hModules[i];
            cur->BaseAddress = (DWORD)info.lpBaseOfDll;
            cur->BaseSize = info.SizeOfImage;
            cur->imgName = 0;

            cur->next = lImages;
            lImages = cur;       
        }
    } else
    {
        HANDLE snap;
        if ((snap = CreateToolhelp32SnapshotW9x(TH32CS_SNAPMODULE, 0)) == (HANDLE)-1)
            return 0;

        MODULEENTRY32 *info = (MODULEENTRY32*)_alloca(sizeof(MODULEENTRY32));
        info->dwSize = sizeof(MODULEENTRY32);
        if (Module32FirstW9x(snap, info))
        {
            do {
                ImageInfo *newImg;
                
                if (!(newImg = (ImageInfo *)HeapAlloc(GetProcessHeap(), 0, sizeof(ImageInfo))))
                {
                    CloseHandle(snap);
                    goto CHOKE;
                }
                
                newImg->hndl = info->hModule;
                newImg->BaseAddress = (DWORD)info->modBaseAddr;
                newImg->BaseSize = info->modBaseSize;
                newImg->imgName = 0;
            
                newImg->next = lImages;
                lImages = newImg;       

            } while (Module32NextW9x(snap, info));
        }
        CloseHandle(snap);
    }

    for (cur = lImages; cur; cur = cur->next)
    {
        cur->img = ImageNtHeader((void *)cur->BaseAddress);
        cur->sectHdr = IMAGE_FIRST_SECTION(cur->img);
        char *buf = (char*)_alloca(513);
        buf[512] = '\0';
        if (!GetModuleFileName(cur->hndl, buf, 512))
            goto CHOKE;
        int nmLen;
        for (nmLen = 0; buf[nmLen]; nmLen++) {}
        if (!(cur->imgName = (char*)HeapAlloc(GetProcessHeap(), 0, nmLen+1)))
            goto CHOKE;
        nmLen = 0;
        do {
            cur->imgName[nmLen] = buf[nmLen];
        } while (buf[nmLen++]);

    }

    for (res = lImages; res; res = res->next)
    {
        if (res->BaseAddress <= address && address - res->BaseAddress <= res->BaseSize)
            return res;
    }

CHOKE:
    while (lImages) {
        ImageInfo *next = lImages->next;
        
        if (lImages->imgName)
            HeapFree(GetProcessHeap(), 0, lImages->imgName);
        HeapFree(GetProcessHeap(), 0, lImages);
        lImages = next;
    }
    return 0;
}

static HINSTANCE
GetPdbDll()
{
    static BOOL alreadyTried = FALSE;
    // If we already tried to load it, return
    if (alreadyTried)
        return (HINSTANCE)0;
    alreadyTried = TRUE;

    HINSTANCE res;
    if (res = LoadLibrary(mspdbName))
        return res;

    // Load the AdvAPI32.DLL entrypoints
    HINSTANCE advapi32;
    if (!(advapi32 = LoadLibrary("ADVAPI32.DLL")))
        return 0;
    RegOpenKeyExAProc RegOpenKeyExA;
    GetReqProcedure(advapi32, RegOpenKeyExA, 0);
    RegQueryValueExAProc RegQueryValueExA;
    GetReqProcedure(advapi32, RegQueryValueExA, 0);
    RegCloseKeyProc RegCloseKey;
    GetReqProcedure(advapi32, RegCloseKey, 0);

    char *keyname = REGISTRY_KEY_LOCATION;
    BYTE *buf;
    HKEY key1;
    long pos, err;
    DWORD type, len;

    err = RegOpenKeyExA(REGISTRY_KEY_MASTER, keyname, 0, KEY_QUERY_VALUE, &key1);
    if (err != ERROR_SUCCESS)
    {
        FreeLibrary(advapi32);
        return 0;
    }
    
    err = RegQueryValueExA(key1, REGISTRY_KEY_NAME, NULL, &type, 0, &len);
    if (err != ERROR_SUCCESS)
        return 0;
    len += 2 + mspdbNameLen;
    buf = (BYTE*)_alloca(len * sizeof(BYTE));
    err = RegQueryValueExA(key1, REGISTRY_KEY_NAME, NULL, &type, buf, &len);
    RegCloseKey(key1);
    FreeLibrary(advapi32);

    if (err != ERROR_SUCCESS)
        return 0;
    if (buf[len - 2] != '\\')
        buf[len - 1] = '\\';
    else
        len--;

    for (pos = 0; pos <= mspdbNameLen; pos++)
        buf[len + pos] = mspdbName[pos];

    return LoadLibrary((const char *)buf);
}

BOOL
_RTC_GetSrcLine(
    DWORD address,
    char* source,
    int sourcelen,
    int* pline,
    char** moduleName
    )
{
    struct SSrcModuleHdr { 
        WORD cFile; 
        WORD cSeg; 
    };
    struct SStartEnd {
        DWORD start;
        DWORD end;
    };
    SSrcModuleHdr *liHdr;
    ULONG *baseSrcFile; // SSrcModuleHdr.cFile items
    SStartEnd *startEnd; // SSrcModuleHdr.cSeg items
    USHORT *contribSegs; // SSrcModuleHdr.cSeg items (+1 for alignement)
    int i;
    ImageInfo *iInf;

    PDB *ppdb;
    DBI *pdbi;
    Mod *pmod;

    EC err;
    // CB_ERR_MAX from linker is 1024 - not particularly secure, but oh well.
    // This whole thing should be rewritten using DIA instead of MSPDB for next rev...
    char *errname = (char*)_alloca(1024);
    
    OFF imageAddr;
    OFF secAddr;
    OFF offsetRes;
    USHORT sectionIndex;
    USHORT sectionIndexRes;
    long size;
    PB lineBuffer;
    static BOOL PDBOK = FALSE;

    BOOL res = FALSE;
    
    *pline = 0;
    *source = 0;
    *moduleName = 0;

    // First, find the image (DLL/EXE) in which this address occurs
    iInf = GetImageInfo(address);
    
    if (!iInf)
        // We didn't find this address is the list of modules, so quit
        goto DONE0;


    // Now get the Relative virtual address of the address given
    imageAddr = address - iInf->BaseAddress;
    
    *moduleName = iInf->imgName;

    res = TRUE;

    // Try to load the PDB DLL
    if (!PDBOK) 
    {
        // If we already loaded it before, there must be some missing API function
        if (mspdb || !(mspdb = GetPdbDll()))
            goto DONE0;

        GetReqProcedure(mspdb, PDBOpenValidate3, 0);
        GetReqProcedure(mspdb, PDBOpenDBI, 0);
        GetReqProcedure(mspdb, DBIQueryModFromAddr, 0);
        GetReqProcedure(mspdb, ModQueryLines, 0);
        GetReqProcedure(mspdb, ModClose, 0);
        GetReqProcedure(mspdb, DBIClose, 0);
        GetReqProcedure(mspdb, PDBClose, 0);
        PDBOK = TRUE;
    }

    // Now find the section index & section-relative address
    secAddr = -1;
    for (sectionIndex = 0; sectionIndex < iInf->img->FileHeader.NumberOfSections; sectionIndex++)
    {
        if (iInf->sectHdr[sectionIndex].VirtualAddress < (unsigned)imageAddr &&
            imageAddr - iInf->sectHdr[sectionIndex].VirtualAddress < iInf->sectHdr[sectionIndex].SizeOfRawData)
        {
            secAddr = imageAddr - iInf->sectHdr[sectionIndex].VirtualAddress;
            break;
        }
    }

    if (secAddr == -1)
        goto DONE0;

    // Open the PDB for this image
    DWORD fo, cb;
    char *path = (char*)_alloca(MAX_PATH);
    // Rumor has it that I'll need to switch to OV5 instead of OV3 for this call soon...
    if (!PDBOpenValidate3(iInf->imgName, "", &err, errname, path, &fo, &cb, &ppdb))
        goto DONE0;

    // Get the DBI interface for the PDB
    if (!PDBOpenDBI(ppdb, pdbRead, 0, &pdbi))
        goto DONE1;

    // Now get the Mod from the section index & the section-relative address
    if (!DBIQueryModFromAddr(pdbi, ++sectionIndex, secAddr, &pmod, &sectionIndexRes, &offsetRes, &size))
        goto DONE2;

    // Get the size of the buffer we need
    if (!ModQueryLines(pmod, 0, &size) || !size)
        goto DONE3;

    lineBuffer = (PB)HeapAlloc(GetProcessHeap(), 0, size);
    if (!ModQueryLines(pmod, lineBuffer, &size))
        goto DONE3;

    // fill in the number of source files, and their corresponding regions
    liHdr = (SSrcModuleHdr*)lineBuffer;
    baseSrcFile = (ULONG *)(lineBuffer + sizeof(SSrcModuleHdr));
    // I think I can actually ignore the rest of the module header info
    startEnd = (SStartEnd *)&(baseSrcFile[liHdr->cFile]);
    contribSegs = (USHORT *)&(startEnd[liHdr->cSeg]);

    for (i = 0; i < liHdr->cFile; i++)
    {
        BYTE *srcBuff = lineBuffer + baseSrcFile[i];
        USHORT segCount = *(USHORT *)srcBuff;
        ULONG *baseSrcLn = &(((ULONG *)srcBuff)[1]);
        SStartEnd *segStartEnd = (SStartEnd*)&(baseSrcLn[segCount]);
        char *srcName = (char *)&segStartEnd[segCount];

        // Step through the various bunch of segments this src file contributes
        for (int j = 0; j < segCount; j++)
        {
            if (segStartEnd[j].start <= (unsigned)secAddr &&
                (unsigned)secAddr <= segStartEnd[j].end) 
            {
                // If this segment contains the section address, 
                // we've found the right one, so find the closest line number
                BYTE *segLnBuf = &lineBuffer[baseSrcLn[j]];
                USHORT pairCount = *(USHORT*)&(segLnBuf[sizeof(USHORT)]);
                ULONG *offsets = (ULONG *)&(segLnBuf[sizeof(USHORT)*2]);
                USHORT *linNums = (USHORT *)&(offsets[pairCount]);
                int best = -1;
                ULONG dist = 0xFFFFFFFF;
                for (int k = 0; k < pairCount; k++)
                {
                    if (secAddr - offsets[k] < dist)
                    {
                        best = k;
                        dist = secAddr - offsets[k];
                    }
                }
                if (best < 0)
                    // It shoulda been here, but it wasn't...
                    goto DONE4;
                
                *pline = linNums[best];
                for (j = 0; srcName[j] && j < sourcelen; j++)
                    source[j] = srcName[j];
                source[(j < sourcelen) ? j : sourcelen-1] = 0;

                goto DONE4;
            }
        }
    }

DONE4:
    HeapFree(GetProcessHeap(), 0, lineBuffer);
DONE3:
    ModClose(pmod);
DONE2:
    DBIClose(pdbi);
DONE1:
    PDBClose(ppdb);
DONE0:
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\rtc\initsect.cpp ===
/***
*initsect.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       11-03-98  KBF   Module incorporated into CRTs
*       05-11-99  KBF   Error if RTC support define not enabled
*       08-10-99  RMS   Use external symbols for BBT support
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "internal.h"
#include "rtcpriv.h"
#include "sect_attribs.h"

#pragma const_seg(".rtc$IAA")
extern "C" const _CRTALLOC(".rtc$IAA") _PVFV __rtc_iaa[] = { 0 };


#pragma const_seg(".rtc$IZZ")
extern "C" const _CRTALLOC(".rtc$IZZ") _PVFV __rtc_izz[] = { 0 };


#pragma const_seg(".rtc$TAA")
extern "C" const _CRTALLOC(".rtc$TAA") _PVFV __rtc_taa[] = { 0 };


#pragma const_seg(".rtc$TZZ")
extern "C" const _CRTALLOC(".rtc$TZZ") _PVFV __rtc_tzz[] = { 0 };

#pragma const_seg()


#pragma comment(linker, "/MERGE:.rtc=.rdata")

#ifndef _RTC_DEBUG
#pragma optimize("g", on)
#endif

// Run the RTC initializers
extern "C" void __declspec(nothrow) __cdecl _RTC_Initialize()
{
    // Just step thru every item
    const _PVFV *f;
    for (f = __rtc_iaa + 1; f < __rtc_izz; f++)
    {
	__try {
            if (*f)
                (**f)();
        } __except(1){}
    }
}

// Run the RTC terminators
extern "C" void __declspec(nothrow) __cdecl _RTC_Terminate()
{
    // Just step thru every item
    const _PVFV *f;
    for (f = __rtc_taa + 1; f < __rtc_tzz; f++)
    {
	__try {
            if (*f)
                (**f)();
        } __except(1){}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\crt0init.c ===
/***
*crt0init.c - Initialization segment declarations.
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Do initialization segment declarations.
*
*Notes:
*       In the 16-bit C world, the X*B and X*E segments were empty except for
*       a label.  This will not work with COFF since COFF throws out empty
*       sections.  Therefore we must put a zero value in them.  (Zero because
*       the routine to traverse the initializers will skip over zero entries.)
*
*Revision History:
*       03-19-92  SKS   Module created.
*       03-24-92  SKS   Added MIPS support (NO_UNDERSCORE)
*       08-06-92  SKS   Revised to use new section names and macros
*       10-19-93  SKS   Add .DiRECTiVE section for MIPS, too!
*       10-28-93  GJF   Rewritten in C
*       10-28-94  SKS   Add user32.lib as a default library
*       02-27-95  CFW   Remove user32.lib as a default library
*       06-22-95  CFW   Add /disallowlib directives.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       03-27-01  PML   .CRT$XI funcs now return an error status (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <stdio.h>
#include <internal.h>

#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PIFV __xi_a[] = { NULL };


#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PIFV __xi_z[] = { NULL };


#pragma data_seg(".CRT$XCA")
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };


#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };


#pragma data_seg(".CRT$XPA")
_CRTALLOC(".CRT$XPA") _PVFV __xp_a[] = { NULL };


#pragma data_seg(".CRT$XPZ")
_CRTALLOC(".CRT$XPZ") _PVFV __xp_z[] = { NULL };


#pragma data_seg(".CRT$XTA")
_CRTALLOC(".CRT$XTA") _PVFV __xt_a[] = { NULL };


#pragma data_seg(".CRT$XTZ")
_CRTALLOC(".CRT$XTZ") _PVFV __xt_z[] = { NULL };

#pragma data_seg()  /* reset */

#ifdef  _M_IA64
// BUGBUG: the following should be enabled for ALPHA64 when .CRT is read-only
#pragma comment(linker, "/merge:.CRT=.rdata")
#else
#ifdef  NT_BUILD
#pragma comment(linker, "/merge:.CRT=.rdata")
#else
#pragma comment(linker, "/merge:.CRT=.data")
#endif
#endif

#pragma comment(linker, "/defaultlib:kernel32.lib")

#if     !(!defined(_MT) && !defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libc.lib")
#endif
#if     !(!defined(_MT) &&  defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libcd.lib")
#endif
#if     !( defined(_MT) && !defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libcmt.lib")
#endif
#if     !( defined(_MT) &&  defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libcmtd.lib")
#endif
#pragma comment(linker, "/disallowlib:msvcrt.lib")
#pragma comment(linker, "/disallowlib:msvcrtd.lib")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\crt0.c ===
/***
*crt0.c - C runtime initialization routine
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps.  It calls the user's main
*       routine [w]main() or [w]WinMain after performing C Run-Time Library
*       initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrt0.c     the startup routine for console apps with wide chars
*       wincrt0.c   the startup routine for Windows apps
*       wwincrt0.c  the startup routine for Windows apps with wide chars
*
*Revision History:
*       06-27-89  PHG   Module created, based on asm version
*       11-02-89  JCR   Added DOS32QUERYSYSINFO to get osversion
*       04-09-90  GJF   Added #include <cruntime.h>. Put in explicit calling
*                       types (_CALLTYPE1 or _CALLTYPE4) for __crt0(),
*                       inherit(), __amsg_exit() and _cintDIV(). Also, fixed
*                       the copyright and cleaned up the formatting a bit.
*       04-10-90  GJF   Fixed compiler warnings (-W3).
*       08-08-90  GJF   Added exception handling stuff (needed to support
*                       runtime errors and signal()).
*       08-31-90  GJF   Removed 32 from API names.
*       10-08-90  GJF   New-style function declarators.
*       12-05-90  GJF   Fixed off-by-one error in inherit().
*       12-06-90  GJF   Win32 version of inherit().
*       12-06-90  SRW   Added _osfile back for win32.  Changed _osfinfo from
*                       an array of structures to an array of 32-bit handles
*                       (_osfhnd)
*       01-21-91  GJF   ANSI naming.
*       01-25-91  SRW   Changed Win32 Process Startup [_WIN32_]
*       02-01-91  SRW   Removed usage of PPEB type [_WIN32_]
*       02-05-91  SRW   Changed to pass _osfile and _osfhnd arrays as binary
*                       data to child process.  [_WIN32_]
*       04-02-91  GJF   Need to get version number sooner so it can be used in
*                       _heap_init. Prefixed an '_' onto BaseProcessStartup.
*                       Version info now stored in _os[version|major|minor] and
*                       _base[version|major|minor] (_WIN32_).
*       04-10-91  PNT   Added _MAC_ conditional
*       04-26-91  SRW   Removed level 3 warnings
*       05-14-91  GJF   Turn on exception handling for Dosx32.
*       05-22-91  GJF   Fixed careless errors.
*       07-12-91  GJF   Fixed one more careless error.
*       08-13-91  GJF   Removed definitions of _confh and _coninpfh.
*       09-13-91  GJF   Incorporated Stevewo's startup variations.
*       11-07-91  GJF   Revised try-except, fixed outdated comments on file
*                       handle inheritance [_WIN32_].
*       12-02-91  SRW   Fixed WinMain startup code to skip over first token
*                       plus delimiters for the lpszCommandLine parameter.
*       01-17-92  GJF   Merge of NT and CRT version. Restored Stevewo's scheme
*                       for unhandled exceptions.
*       02-13-92  GJF   For Win32, moved file inheritance stuff to ioinit.c.
*                       Call to inherit() is replace by call to _ioinit().
*       03-23-92  OLM   Created MAC version
*       04-01-92  XY    Add cinit call (MAC)
*       04-16-92  DJM   POSIX support
*       06-10-92  PLM   Added putenv support (MAC)
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       08-26-92  GJF   Deleted version number(s) fetch from POSIX startup (it
*                       involved a Win32 API call).
*       09-30-92  SRW   Call _heap_init before _mtinit
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-01-93  CFW   Change try-except to __try-__except
*       04-05-93  JWM   GUI apps now call MessageBox() from _amsg_exit().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-19-93  SKS   Remove obsolete variable _atopsp
*       04-26-93  SKS   Change _mtinit to return failure
*                       remove a number of OS/2 (CRUISER) ifdefs
*       04-26-93  GJF   Made lpszCommandLine (unsigned char *) to deal with
*                       chars > 127 in the command line.
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       05-14-93  GJF   Added support for quoted program names.
*       09-08-93  CFW   Added call to _initmbctable.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-21-93  CFW   Move _initmbctable call to _cinit().
*       11-05-93  CFW   Undefine GetEnviromentStrings.
*       11-08-93  GJF   Guard as much init. code as possible with the __try -
*                       __except statement, especially _cinit(). Also,
*                       restored the call to __initmbctable to this module.
*       11-19-93  CFW   Add _wcmdln variable, enable wide char command line
*                       only.
*       11-23-93  CFW   GetEnviromentStrings undef moved to internal.h.
*       11-29-93  CFW   Wide environment.
*       12-21-93  CFW   Fix API failure error handling.
*       01-04-94  CFW   Pass copy of environment to main.
*       01-28-94  CFW   Move environment copying to setenv.c.
*       02-07-94  CFW   POSIXify.
*       03-30-93  CFW   Use __crtXXX calls for Unicode model.
*       04-08-93  CFW   cinit() should be later.
*       04-12-94  GJF   Moved declaration of _[w]initenv to internal.h.
*       04-14-94  GJF   Enclosed whole source in #ifndef CRTDLL - #endif.
*       09-02-94  SKS   Fix inaccurate description in file header comment
*       09-06-94  CFW   Remove _MBCS_OS switch.
*       09-06-94  GJF   Added definitions of __error_mode and __app_type.
*       10-14-94  BWT   try->__try / except->__except for POSIX
*       01-16-95  CFW   Set default debug output for console.
*       02-11-95  CFW   PPC -> _M_MPPC.
*       02-16-95  JWM   Spliced _WIN32 & Mac versions.
*       03-28-95  BWT   Fail if unable to retrieve cmdline or envptr (fixes
*                       stress bug).
*       04-06-95  CFW   Set default debug output for Mac.
*       04-06-95  CFW   Use __crtGetEnvironmentStringsA.
*       04-26-95  CFW   Change default debug output for Mac to debugger.
*       07-04-95  GJF   Interface to __crtGetEnvironmentStrings and _setenvp
*                       changes slightly.
*       07-07-95  CFW   Simplify default report mode scheme.
*       04-22-96  GJF   Check for error on _heap_init.
*       01-17-97  GJF   For _heap_init() or _mtinit() failure, exit the
*                       process without going through _exit().
*       07-24-97  GJF   Moved building of lpszCommandLine to wincmdln.c. Also,
*                       heap_init changed slightly to support option to use
*                       heap running directly on Win32 API.
*       08-06-97  GJF   Moved __mbctype_initialized to crt0dat.c
*       12-23-97  RKP   Corrected posix use of _heap_init()
*       02-27-98  RKP   Added 64 bit support.
*       10-02-98  GJF   Use GetVersionEx instead of GetVersion and store OS ID
*                       in _osplatform.
*       11-13-98  KBF   Moved RTC_Initialize from _cinit to just after
*                       _heap_init
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  RDL   Win64 POSIX warning fix.
*       11-12-99  KBF   Create 4 new COM+ specific entrypoints which return
*                       instead of calling exit().
*       11-16-99  PML   ... and remove them - linker problems mean new
*                       entrypoints don't work.  Instead, look directly at the
*                       COM Descriptor Image Directory entry in the optional
*                       header to see if we are a COM+ app.
*       02-15-00  GB    Changed GetModuleHandle to GetModuleHandleA in
*                       check_complus_app.
*       03-06-00  PML   Call __crtExitProcess instead of ExitProcess.
*       08-04-00  PML   check_complus_app -> check_managed_app (VS7#117746).
*       12-09-00  PML   Tighten up check_managed_app tests (VS7#167293).
*       03-17-01  PML   _alloca the OSVERSIONINFO so /GS can work (vs7#224261)
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*       03-27-01  PML   Call to _amsg_exit on startup failure now pushed up to
*                       this level (vs7#231220)
*       04-29-01  BWT   Fix posix build
*
*******************************************************************************/

#ifndef CRTDLL

#include <cruntime.h>
#include <dos.h>
#include <internal.h>
#include <process.h>
#include <stdlib.h>
#include <string.h>
#ifndef _POSIX_
#include <rterr.h>
#include <rtcapi.h>
#else
#include <posix/sys/types.h>
#include <posix/unistd.h>
#include <posix/signal.h>
#endif
#include <windows.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>

/*
 * wWinMain is not yet defined in winbase.h. When it is, this should be
 * removed.
 */

int
WINAPI
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR lpCmdLine,
    int nShowCmd
    );

#ifdef  WPRFLAG
_TUCHAR * __cdecl _wwincmdln(void);
#else
_TUCHAR * __cdecl _wincmdln(void);
#endif

/*
 * command line, environment, and a few other globals
 */

#ifdef  WPRFLAG
wchar_t *_wcmdln;           /* points to wide command line */
#else
char *_acmdln;              /* points to command line */
#endif

char *_aenvptr = NULL;      /* points to environment block */
#ifndef _POSIX_
wchar_t *_wenvptr = NULL;   /* points to wide environment block */
#endif

#ifdef  _POSIX_
char *_cmdlin;
#endif

void (__cdecl * _aexit_rtn)(int) = _exit;   /* RT message return procedure */

static void __cdecl fast_error_exit(int);   /* Error exit via ExitProcess */

static int __cdecl check_managed_app(void); /* Determine if a managed app */

/*
 * _error_mode and _apptype, together, determine how error messages are
 * written out.
 */
int __error_mode = _OUT_TO_DEFAULT;
#ifdef  _WINMAIN_
int __app_type = _GUI_APP;
#else
int __app_type = _CONSOLE_APP;
#endif

#ifdef  _POSIX_

/***
*mainCRTStartup(void)
*
*Purpose:
*       This routine does the C runtime initialization, calls main(), and
*       then exits.  It never returns.
*
*Entry:
*
*Exit:
*       This function never returns.
*
*******************************************************************************/

void
mainCRTStartup(
        void
        )
{
        int mainret;
        int initret;
        char **ppch;

        extern char **environ;
        extern char * __PdxGetCmdLine(void);  /* an API in the Posix SS */
        extern main(int,char**);

        _cmdlin = __PdxGetCmdLine();
        ppch = (char **)_cmdlin;
        __argv = ppch;

        // normalize argv pointers

        __argc = 0;
        while (NULL != *ppch) {
            *ppch += (int)(intptr_t)_cmdlin;
            ++__argc;
            ++ppch;
        }
        // normalize environ pointers

        ++ppch;
        environ = ppch;

        while (NULL != *ppch) {
            *ppch = *ppch + (int)(intptr_t)_cmdlin;
            ++ppch;
        }

        /*
         * If POSIX runtime needs to fetch and store POSIX verion info,
         * it should be done here.
         *
         *      Get_and_save_version_info;
         */

#ifdef  _MT
        _heap_init(1);                          /* initialize heap */
#else
        _heap_init(0);                          /* initialize heap */
#endif

        initret = _cinit();                     /* do C data initialize */
        if (initret != 0)
            _amsg_exit(initret);

        __try {
            mainret = main(__argc, __argv);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            switch (GetExceptionCode()) {
            case STATUS_ACCESS_VIOLATION:
                kill(getpid(), SIGSEGV);
                break;
            case STATUS_ILLEGAL_INSTRUCTION:
            case STATUS_PRIVILEGED_INSTRUCTION:
                kill(getpid(), SIGILL);
                break;
            case STATUS_FLOAT_DENORMAL_OPERAND:
            case STATUS_FLOAT_DIVIDE_BY_ZERO:
            case STATUS_FLOAT_INEXACT_RESULT:
            case STATUS_FLOAT_OVERFLOW:
            case STATUS_FLOAT_STACK_CHECK:
            case STATUS_FLOAT_UNDERFLOW:
                kill(getpid(), SIGFPE);
                break;
            default:
                kill(getpid(), SIGKILL);
            }

            mainret = -1;
        }
        exit(mainret);
}
#else   /* ndef _POSIX_ */

/***
*mainCRTStartup(void)
*wmainCRTStartup(void)
*WinMainCRTStartup(void)
*wWinMainCRTStartup(void)
*
*Purpose:
*       These routines do the C runtime initialization, call the appropriate
*       user entry function, and handle termination cleanup.  For a managed
*       app, they then return the exit code back to the calling routine, which
*       is the managed startup code.  For an unmanaged app, they call exit and
*       never return.
*
*       Function:               User entry called:
*       mainCRTStartup          main
*       wmainCRTStartup         wmain
*       WinMainCRTStartup       WinMain
*       wWinMainCRTStartup      wWinMain
*
*Entry:
*
*Exit:
*       Managed app: return value from main() et al, or the exception code if
*                 execution was terminated by the __except guarding the call
*                 to main().
*       Unmanaged app: never return.
*
*******************************************************************************/

#ifdef  _WINMAIN_

#ifdef  WPRFLAG
int wWinMainCRTStartup(
#else
int WinMainCRTStartup(
#endif

#else   /* ndef _WINMAIN_ */

#ifdef  WPRFLAG
int wmainCRTStartup(
#else
int mainCRTStartup(
#endif

#endif  /* _WINMAIN_ */

        void
        )

{
        int initret;
        int mainret;
        OSVERSIONINFOA *posvi;
        int managedapp;
#ifdef  _WINMAIN_
        _TUCHAR *lpszCommandLine;
        STARTUPINFO StartupInfo;
#endif
        /*
         * Dynamically allocate the OSVERSIONINFOA buffer, so we avoid
         * triggering the /GS buffer overrun detection.  That can't be
         * used here, since the guard cookie isn't available until we
         * initialize it from here!
         */
        posvi = (OSVERSIONINFOA *)_alloca(sizeof(OSVERSIONINFOA));

        /*
         * Get the full Win32 version
         */
        posvi->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        (void)GetVersionExA(posvi);

        _osplatform = posvi->dwPlatformId;
        _winmajor = posvi->dwMajorVersion;
        _winminor = posvi->dwMinorVersion;

        /*
         * The somewhat bizarre calculations of _osver and _winver are
         * required for backward compatibility (used to use GetVersion)
         */
        _osver = (posvi->dwBuildNumber) & 0x07fff;
        if ( _osplatform != VER_PLATFORM_WIN32_NT )
            _osver |= 0x08000;
        _winver = (_winmajor << 8) + _winminor;

        /*
         * Determine if this is a managed application
         */
        managedapp = check_managed_app();

#ifdef  _MT
        if ( !_heap_init(1) )               /* initialize heap */
#else
        if ( !_heap_init(0) )               /* initialize heap */
#endif
            fast_error_exit(_RT_HEAPINIT);  /* write message and die */

#ifdef  _MT
        if( !_mtinit() )                    /* initialize multi-thread */
            fast_error_exit(_RT_THREAD);    /* write message and die */
#endif

        /*
         * Initialize the Runtime Checks stuff
         */
#ifdef  _RTC
        _RTC_Initialize();
#endif
        /*
         * Guard the remainder of the initialization code and the call
         * to user's main, or WinMain, function in a __try/__except
         * statement.
         */

        __try {

            if ( _ioinit() < 0 )            /* initialize lowio */
                _amsg_exit(_RT_LOWIOINIT);

#ifdef  WPRFLAG
            /* get wide cmd line info */
            _wcmdln = (wchar_t *)__crtGetCommandLineW();

            /* get wide environ info */
            _wenvptr = (wchar_t *)__crtGetEnvironmentStringsW();

            if ( _wsetargv() < 0 )
                _amsg_exit(_RT_SPACEARG);
            if ( _wsetenvp() < 0 )
                _amsg_exit(_RT_SPACEENV);
#else
            /* get cmd line info */
            _acmdln = (char *)GetCommandLineA();

            /* get environ info */
            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            if ( _setargv() < 0 )
                _amsg_exit(_RT_SPACEARG);
            if ( _setenvp() < 0 )
                _amsg_exit(_RT_SPACEENV);
#endif

            initret = _cinit();                     /* do C data initialize */
            if (initret != 0)
                _amsg_exit(initret);

#ifdef  _WINMAIN_

            StartupInfo.dwFlags = 0;
            GetStartupInfo( &StartupInfo );

#ifdef  WPRFLAG
            lpszCommandLine = _wwincmdln();
            mainret = wWinMain(
#else
            lpszCommandLine = _wincmdln();
            mainret = WinMain(
#endif
                               GetModuleHandleA(NULL),
                               NULL,
                               lpszCommandLine,
                               StartupInfo.dwFlags & STARTF_USESHOWWINDOW
                                    ? StartupInfo.wShowWindow
                                    : SW_SHOWDEFAULT
                             );
#else   /* _WINMAIN_ */

#ifdef  WPRFLAG
            __winitenv = _wenviron;
            mainret = wmain(__argc, __wargv, _wenviron);
#else
            __initenv = _environ;
            mainret = main(__argc, __argv, _environ);
#endif

#endif  /* _WINMAIN_ */

            if ( !managedapp )
                exit(mainret);

            _cexit();

        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
            /*
             * Should never reach here
             */

            mainret = GetExceptionCode();

            if ( !managedapp )
                _exit(mainret);

            _c_exit();

        } /* end of try - except */

        return mainret;
}


#endif  /* _POSIX_ */

/***
*_amsg_exit(rterrnum) - Fast exit fatal errors
*
*Purpose:
*       Exit the program with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls exit() (for integer divide-by-0) or _exit() indirectly
*       through _aexit_rtn [amsg_exit].
*       For multi-thread: calls _exit() function
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _amsg_exit (
        int rterrnum
        )
{
#ifdef  _WINMAIN_
        if ( __error_mode == _OUT_TO_STDERR )
#else
        if ( __error_mode != _OUT_TO_MSGBOX )
#endif
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);  /* write message */
        _aexit_rtn(255);        /* normally _exit(255) */
}

/***
*fast_error_exit(rterrnum) - Faster exit fatal errors
*
*Purpose:
*       Exit the process with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls ExitProcess (through __crtExitProcess).
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl fast_error_exit (
        int rterrnum
        )
{
#ifdef  _WINMAIN_
        if ( __error_mode == _OUT_TO_STDERR )
#else
        if ( __error_mode != _OUT_TO_MSGBOX )
#endif
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);  /* write message */
        __crtExitProcess(255);  /* normally _exit(255) */
}

/***
*check_managed_app() - Check for a managed executable
*
*Purpose:
*       Determine if the EXE the startup code is linked into is a managed app
*       by looking for the COM Runtime Descriptor in the Image Data Directory
*       of the PE or PE+ header.
*
*Entry:
*       None
*
*Exit:
*       1 if managed app, 0 if not.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl check_managed_app (
        void
        )
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;
        PIMAGE_OPTIONAL_HEADER32 pNTHeader32;
        PIMAGE_OPTIONAL_HEADER64 pNTHeader64;

        pDOSHeader = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
        if ( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return 0;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);
        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return 0;

        pNTHeader32 = (PIMAGE_OPTIONAL_HEADER32)&pPEHeader->OptionalHeader;
        switch ( pNTHeader32->Magic ) {
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            /* PE header */
            if ( pNTHeader32->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader32 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            /* PE+ header */
            pNTHeader64 = (PIMAGE_OPTIONAL_HEADER64)pNTHeader32;
            if ( pNTHeader64->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader64 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        }

        /* Not PE or PE+, so not managed */
        return 0;
}

#ifndef WPRFLAG

#ifdef  _POSIX_

/***
*RaiseException() - stub for posix FP routines
*
*Purpose:
*       Stub of a Win32 API that posix can't call
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    const ULONG_PTR * lpArguments
    )
{
}

#endif  /* _POSIX_ */

#endif  /* WPRFLAG */

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\crt0msg.c ===
/***
*crt0msg.c - startup error messages
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prints out banner for runtime error messages.
*
*Revision History:
*       06-27-89  PHG   Module created, based on asm version
*       04-09-90  GJF   Added #include <cruntime.h>. Made calling type
*                       _CALLTYPE1. Also, fixed the copyright.
*       04-10-90  GJF   Fixed compiler warnings (-W3).
*       06-04-90  GJF   Revised to be more compatible with old scheme.
*                       nmsghdr.c merged in.
*       10-08-90  GJF   New-style function declarators.
*       10-11-90  GJF   Added _RT_ABORT, _RT_FLOAT, _RT_HEAP.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       02-04-91  SRW   Changed to call WriteFile (_WIN32_)
*       02-25-91  MHL   Adapt to ReadFile/WriteFile changes (_WIN32_)
*       04-10-91  PNT   Added _MAC_ conditional
*       09-09-91  GJF   Added _RT_ONEXIT error.
*       09-18-91  GJF   Added 3 math errors, also corrected comments for
*                       errors that were changed in rterr.h, cmsgs.h.
*       03-31-92  DJM   POSIX support.
*       10-23-92  GJF   Added _RT_PUREVIRT.
*       04-05-93  JWM   Added _GET_RTERRMSG().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-29-93  GJF   Removed rterrs[] entries for _RT_STACK, _RT_INTDIV,
*                       _RT_NONCONT and _RT_INVALDISP.
*       09-06-94  CFW   Remove Cruiser support.
*       09-06-94  GJF   Revised to use MessageBox for GUI apps.
*       01-10-95  JCF   Remove __app_type and __error_mode check for _MAC_.
*       02-14-95  CFW   write -> _write, error messages to debug reporting.
*       02-15-95  CFW   Make all CRT message boxes look alike.
*       02-24-95  CFW   Use __crtMessageBoxA.
*       02-27-95  CFW   Change __crtMessageBoxA params.
*       03-07-95  GJF   Added _RT_STDIOINIT.
*       03-21-95  CFW   Add _CRT_ASSERT report type.
*       06-06-95  CFW   Remove _MB_SERVICE_NOTIFICATION.
*       06-19-95  CFW   Avoid STDIO calls.
*       06-20-95  GJF   Added _RT_LOWIOINIT.
*       04-23-96  GJF   Added _RT_HEAPINIT. Also, revised _NMSG_WRITE to
*                       allow for ioinit() having not been invoked.
*       05-05-97  GJF   Changed call to WriteFile, in _NMSG_WRITE, so that 
*                       it does not reference _pioinfo. Also, a few cosmetic
*                       changes.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       01-24-99  PML   Fix buffer overrun in _NMSG_WRITE.
*       05-10-00  GB    Fix call of _CrtDbgReport for _RT_BANNER in _NMSG_WRITE
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <rterr.h>
#include <cmsgs.h>
#include <awint.h>
#include <windows.h>
#include <dbgint.h>

#ifdef  _POSIX_
#include <posix\sys\types.h>
#include <posix\unistd.h>
#endif

/* struct used to lookup and access runtime error messages */

struct rterrmsgs {
        int rterrno;        /* error number */
        char *rterrtxt;     /* text of error message */
};

/* runtime error messages */

static struct rterrmsgs rterrs[] = {

        /* 2 */
        { _RT_FLOAT, _RT_FLOAT_TXT },

        /* 8 */
        { _RT_SPACEARG, _RT_SPACEARG_TXT },

        /* 9 */
        { _RT_SPACEENV, _RT_SPACEENV_TXT },

        /* 10 */
        { _RT_ABORT, _RT_ABORT_TXT },

        /* 16 */
        { _RT_THREAD, _RT_THREAD_TXT },

        /* 17 */
        { _RT_LOCK, _RT_LOCK_TXT },

        /* 18 */
        { _RT_HEAP, _RT_HEAP_TXT },

        /* 19 */
        { _RT_OPENCON, _RT_OPENCON_TXT },

        /* 22 */
        /* { _RT_NONCONT, _RT_NONCONT_TXT }, */

        /* 23 */
        /* { _RT_INVALDISP, _RT_INVALDISP_TXT }, */

        /* 24 */
        { _RT_ONEXIT, _RT_ONEXIT_TXT },

        /* 25 */
        { _RT_PUREVIRT, _RT_PUREVIRT_TXT },

        /* 26 */
        { _RT_STDIOINIT, _RT_STDIOINIT_TXT },

        /* 27 */
        { _RT_LOWIOINIT, _RT_LOWIOINIT_TXT },

        /* 28 */
        { _RT_HEAPINIT, _RT_HEAPINIT_TXT },

        /* 120 */
        { _RT_DOMAIN, _RT_DOMAIN_TXT },

        /* 121 */
        { _RT_SING, _RT_SING_TXT },

        /* 122 */
        { _RT_TLOSS, _RT_TLOSS_TXT },

        /* 252 */
        { _RT_CRNL, _RT_CRNL_TXT },

        /* 255 */
        { _RT_BANNER, _RT_BANNER_TXT }

};

/* number of elements in rterrs[] */

#define _RTERRCNT   ( sizeof(rterrs) / sizeof(struct rterrmsgs) )

/* For C, _FF_DBGMSG is inactive, so _adbgmsg is
   set to null
   For FORTRAN, _adbgmsg is set to point to
   _FF_DBGMSG in dbginit initializer in dbgmsg.asm  */

void (*_adbgmsg)(void) = NULL;

/***
*_FF_MSGBANNER - writes out first part of run-time error messages
*
*Purpose:
*       This routine writes "\r\nrun-time error " to standard error.
*
*       For FORTRAN $DEBUG error messages, it also uses the _FF_DBGMSG
*       routine whose address is stored in the _adbgmsg variable to print out
*       file and line number information associated with the run-time error.
*       If the value of _adbgmsg is found to be null, then the _FF_DBGMSG
*       routine won't be called from here (the case for C-only programs).
*
*Entry:
*       No arguments.
*
*Exit:
*       Nothing returned.
*
*Exceptions:
*       None handled.
*
*******************************************************************************/

void __cdecl _FF_MSGBANNER (
        void
        )
{

        if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
               _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
        {
            _NMSG_WRITE(_RT_CRNL);  /* new line to begin error message */
            if (_adbgmsg != 0)
                _adbgmsg(); /* call __FF_DBGMSG for FORTRAN */
            _NMSG_WRITE(_RT_BANNER); /* run-time error message banner */
        }
}


/***
*__NMSGWRITE(message) - write a given message to handle 2 (stderr)
*
*Purpose:
*       This routine writes the message associated with rterrnum
*       to stderr.
*
*Entry:
*       int rterrnum - runtime error number
*
*Exit:
*       no return value
*
*Exceptions:
*       none
*
*******************************************************************************/

void __cdecl _NMSG_WRITE (
        int rterrnum
        )
{
        int tblindx;
#if     !defined(_POSIX_)
        DWORD bytes_written;            /* bytes written */
#endif

        for ( tblindx = 0 ; tblindx < _RTERRCNT ; tblindx++ )
            if ( rterrnum == rterrs[tblindx].rterrno )
                break;

        if ( rterrnum == rterrs[tblindx].rterrno )
        {
#ifdef  _DEBUG
            /*
             * Report error.
             *
             * If _CRT_ERROR has _CRTDBG_REPORT_WNDW on, and user chooses
             * "Retry", call the debugger.
             *
             * Otherwise, continue execution.
             *
             */

            if (rterrnum != _RT_CRNL && rterrnum != _RT_BANNER)
            {
                if (1 == _CrtDbgReport(_CRT_ERROR, NULL, 0, NULL, rterrs[tblindx].rterrtxt))
                    _CrtDbgBreak();
            }
#endif

#if     !defined(_POSIX_)
            if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
                   _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
            {
                WriteFile( GetStdHandle(STD_ERROR_HANDLE),
                           rterrs[tblindx].rterrtxt,
                           (unsigned long)strlen(rterrs[tblindx].rterrtxt),
                           &bytes_written,
                           NULL );
            }
            else if (rterrnum != _RT_CRNL)
            {
                #define MAXLINELEN 60
                char * pch;
                char progname[MAX_PATH + 1];
                char * outmsg;

                progname[MAX_PATH] = '\0';
                if (!GetModuleFileName(NULL, progname, MAX_PATH))
                    strcpy(progname, "<program name unknown>");

                pch = (char *)progname;

                if (strlen(pch) + 1 > MAXLINELEN)
                {
                    pch += strlen(progname) + 1 - MAXLINELEN;
                    strncpy(pch, "...", 3);
                }

                #define MSGTEXTPREFIX "Runtime Error!\n\nProgram: "
                outmsg = (char *)_alloca(sizeof(MSGTEXTPREFIX)
                                         + strlen(pch)
                                         + 2
                                         + strlen(rterrs[tblindx].rterrtxt));

                strcpy(outmsg, MSGTEXTPREFIX);
                strcat(outmsg, pch);
                strcat(outmsg, "\n\n");
                strcat(outmsg, rterrs[tblindx].rterrtxt);

                __crtMessageBoxA(outmsg,
                        "Microsoft Visual C++ Runtime Library",
                        MB_OK|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
            }

#else   /* !_POSIX_ */

            write(STDERR_FILENO,rterrs[tblindx].rterrtxt,
            strlen(rterrs[tblindx].rterrtxt));

#endif  /* !_POSIX_ */

        }
}


/***
*_GET_RTERRMSG(message) - returns ptr to error text for given runtime error
*
*Purpose:
*       This routine returns the message associated with rterrnum
*
*Entry:
*       int rterrnum - runtime error number
*
*Exit:
*       no return value
*
*Exceptions:
*       none
*
*******************************************************************************/

char * __cdecl _GET_RTERRMSG (
        int rterrnum
        )
{
        int tblindx;

        for ( tblindx = 0 ; tblindx < _RTERRCNT ; tblindx++ )
            if ( rterrnum == rterrs[tblindx].rterrno )
                break;

        if ( rterrnum == rterrs[tblindx].rterrno )
            return rterrs[tblindx].rterrtxt;
        else
            return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\dllmain.c ===
/***
*dllmain.c - Dummy DllMain for user DLLs that have no notification handler
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object goes into LIBC.LIB and LIBCMT.LIB and MSVCRT.LIB for use
*       when linking a DLL with one of the three models of C run-time library.
*       If the user does not provide a DllMain notification routine, this
*       dummy handler will be linked in.  It always returns TRUE (success).
*
*Revision History:
*       04-14-93  SKS   Initial version
*       02-22-95  JCF   Spliced _WIN32 & Mac versions.
*       04-06-95  SKS   In LIBC.LIB and MSVCRT.LIB models, turn off thread
*                       attach and detach notifications to the current DLL.
*       05-17-99  PML   Remove all Macintosh support.
*
******************************************************************************/

#include <oscalls.h>
#define _DECL_DLLMAIN   /* include prototype of _pRawDllMain */
#include <process.h>

/***
*DllMain - dummy version DLLs linked with all 3 C Run-Time Library models
*
*Purpose:
*       The routine DllMain is always called by _DllMainCrtStartup.  If
*       the user does not provide a routine named DllMain, this one will
*       get linked in so that _DllMainCRTStartup has something to call.
*
*       For the LIBC.LIB and MSVCRT.LIB models, the CRTL does not need
*       per-thread notifications so if the user is ignoring them (default
*       DllMain and _pRawDllMain == NULL), just turn them off.  (WIN32-only)
*
*Entry:
*
*Exit:
*
*Exceptions:
*
******************************************************************************/

BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
#if !defined(_MT) || defined(CRTDLL)
        if ( dwReason == DLL_PROCESS_ATTACH && ! _pRawDllMain )
                DisableThreadLibraryCalls(hDllHandle);
#endif
        return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\crt0fp.c ===
/***
*crt0fp.asm - floating point not loaded trap
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	To trap certain cases where certain necessary floating-point
*	software is not loaded.  Two specific cases are when no emulator
*	is linked in but no coprocessor is present, and when floating
*	point i/o conversions are done, but no floating-point variables
*	or expressions are used in the program.
*
*Revision History:
*	06-29-89  PHG	module created, based on asm version
*	04-09-90  GJF	Added #include <cruntime.h>. Made calling type
*			_CALLTYPE1. Also, fixed the copyright.
*	04-10-90  GJF	Fixed compiler warnings (-W3).
*	10-08-90  GJF	New-style function declarator.
*	10-11-90  GJF	Changed _amsg_exit() interface.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>

/***
*_fptrap - trap for missing floating-point software
*
*Purpose:
*	Catches these cases of incomplete f.p. software linked into a program.
*
*	(1) no coprocessor present, and no emulator linked in
*
*	(2) "%e", "%f", and "%g" i/o conversion formats specified, but
*	    not all conversion software has been linked in, because the
*	    program did not use any floating-point variables or expressions.
*
*Entry:
*	None.
*
*Exit:
*	Never returns.
*
*Exceptions:
*	Transfers control to _amsg_exit which ...
*	- Writes error message to standard error:  "floating point not loaded"
*	- Terminates the program by calling _exit().
*******************************************************************************/

void __cdecl _fptrap(
	void
	)
{
	_amsg_exit(_RT_FLOAT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\makefile.inc ===
!if "$(SRCDIR)" == ""
SRCDIR = .^\
!endif

$(SRCDIR)_setargv.c: $(SRCDIR)stdargv.c

$(SRCDIR)wincrt0.c: $(SRCDIR)crt0.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\dllcrt0.c ===
/***
*dllcrt0.c - C runtime initialization routine for a DLL with linked-in C R-T
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This the startup routine for a DLL which is linked with its own
*       C run-time code.  It is similar to the routine _mainCRTStartup()
*       in the file CRT0.C, except that there is no main() in a DLL.
*
*Revision History:
*       05-04-92  SKS   Based on CRT0.C (start-up code for EXE's)
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       09-16-92  SKS   This module used to be enabled only in LIBCMT.LIB,
*                       but it is now enabled for LIBC.LIB as well!
*       09-29-92  SKS   _CRT_INIT needs to be WINAPI, not cdecl
*       10-16-92  SKS   Call _heap_init before _mtinit (fix copied from CRT0.C)
*       10-24-92  SKS   Call to _mtdeletelocks() must be under #ifdef MTHREAD!
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  SKS   _DllMainCRTStartup replaces _CRT_INIT.  Also, call
*                       _mtterm instead of _mtdeletelocks on PROCESS_DETACH
*                       to do all multi-thread cleanup (e.g. free up TLS index)
*       04-19-93  SKS   Remove obsolete variable _atopsp
*       04-20-93  SKS   Call _cexit on DLL detach
*       04-20-93  SKS   Restore _CRT_INIT, must co-exist with DllMainCRTStartup
*       04-26-93  SKS   _mtinit now returns 0 or 1, no longer calls _amsg_exit
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       05-06-93  SKS   Add call to _heap_term to free up all allocated memory
*                       *and* address space.  This must be the last thing done.
*       06-08-93  GJF   Added __proc_attached flag.
*       06-08-93  SKS   Clean up failure handling in _CRT_INIT
*       11-05-93  CFW   Undefine GetEnviromentStrings.
*       11-09-93  GJF   Added call to __initmbctable (must happen before args
*                       and env strings are processed).
*       11-09-93  GJF   Added (restored) support for NT SDK builds. Also,
*                       replaced MTHREAD with _MT.
*       11-20-93  CFW   Wide char enable.
*       11-23-93  CFW   GetEnviromentStrings undef moved to internal.h.
*       11-29-93  CFW   Wide environment.
*       12-06-93  CFW   Wide char enable.
*       12-13-93  SKS   Free up per-thread CRT data on DLL_THREAD_DETACH
*                       using a call to _freeptd() in _CRT_INIT()
*       03-30-93  CFW   Use __crtXXX calls for Unicode model.
*       04-08-93  CFW   Move __crtXXX calls past initialization.
*       06-08-94  SKS   Add functn pointer _pRawDllMain, called around DllMain.
*       09-06-94  CFW   Remove _MBCS_OS switch.
*       09-06-94  GJF   Added __error_mode and __app_type.
*       09-15-94  SKS   Move #ifndef directives to after file header comment
*       12-27-94  CFW   Remove unused _wDll support.
*       01-16-95  CFW   Set default debug output for console.
*       02-22-95  JCF   Spliced _WIN32 & Mac versions.
*       03-10-95  JCF   Return the user error from DllInit instead of noErr.
*       03-28-95  BWT   Fail if unable to retrieve cmdline or envptr (fixes
*                       stress bug).
*       04-06-95  CFW   Set default debug output for Mac, dump leaks for user
*                       DLL.
*       04-06-95  CFW   Use __crtGetEnvironmentStringsA.
*       04-12-95  CFW   __crtGetEnvironmentStringsA must be after mtinit().
*       04-14-95  CFW   env, arg test must also be.
*       04-26-95  CFW   Change default debug output for Mac to debugger.
*       05-23-95  CFW   Dump memory leaks before mtterm().
*       06-27-95  CFW   Always set __app_type.
*       06-28-95  GJF    Added call to _ioterm() to clean up lowio at DLL
*                       unload time.
*       07-04-95  GJF   Interface to __crtGetEnvironmentStrings and _setenvp
*                       changes slightly.
*       07-07-95  CFW   Simplify default report mode scheme.
*       04-23-96  GJF   Check for failure of heap initialization.
*       05-14-96  GJF   Changed how failure during process attach is handled.
*       02-18-97  GJF   Removed obsolete Win32s and PharLap TNT support. Also,
*                       some cosmetic changes.
*       07-24-97  GJF   Minor changes to support stubbing out arg and env 
*                       processing, and our heap manager.
*       10-02-98  GJF   Use GetVersionEx instead of GetVersion and store OS ID
*                       in _osplatform.
*       11-13-98  KBF   Moved RTC_Initialize from _cinit to after _heap_init.
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       02-02-00  GB    Added ATTACH_THREAD support for _CRT_INIT where we
*                       initialise per thread data so that in case where we
*                       are short of memory, we don't have to kill the whole
*                       process for inavailablity of space.
*       08-22-00  GB    Fixed potentia leak of ptd in CRT_INIT
*       03-16-01  PML   _alloca the OSVERSIONINFO so /GS can work (vs7#224261)
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*       03-27-01  PML   Fail DLL load instead of calling _amsg_exit (vs7#231220)
*
*******************************************************************************/

#ifndef _POSIX_         /* not built for POSIX */
#ifndef CRTDLL          /* not built for CRTDLL */

#include <cruntime.h>
#include <dos.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <rterr.h>
#include <oscalls.h>
#define _DECL_DLLMAIN   /* enable prototypes for DllMain and _CRT_INIT */
#include <process.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>
#include <rtcapi.h>

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int __proc_attached = 0;

/*
 * command line, environment, and a few other globals
 */
char *_acmdln;              /* points to command line */

char *_aenvptr = NULL;      /* points to environment block */
wchar_t *_wenvptr = NULL;   /* points to wide environment block */

void (__cdecl * _aexit_rtn)(int) = _exit;   /* RT message return procedure */

/*
 * _error_mode and _apptype, together, determine how error messages are
 * written out.
 */
int __error_mode = _OUT_TO_DEFAULT;
int __app_type = _UNKNOWN_APP;

/*
 * User routine DllMain is called on all notifications
 */
extern BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        ) ;

/* _pRawDllMain MUST be a common variable, not extern nor initialized! */

BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);

/***
*BOOL WINAPI _CRT_INIT(hDllHandle, dwReason, lpreserved) -
*       C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*       This routine does the C run-time initialization or termination.
*       For the multi-threaded run-time library, it also cleans up the
*       multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*       This routine must be the entry point for the DLL.
*
*******************************************************************************/

BOOL WINAPI _CRT_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        /*
         * Start-up code only gets executed when the process is initialized
         */

        if ( dwReason == DLL_PROCESS_ATTACH )
        {
            /*
             * Dynamically allocate the OSVERSIONINFOA buffer, so we avoid
             * triggering the /GS buffer overrun detection.  That can't be
             * used here, since the guard cookie isn't available until we
             * initialize it from here!
             */
            OSVERSIONINFOA *posvi =
                (OSVERSIONINFOA *)_alloca(sizeof(OSVERSIONINFOA));

            /*
             * Get the full Win32 version
             */
            posvi->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            if ( !GetVersionExA(posvi) )
                return FALSE;

            _osplatform = posvi->dwPlatformId;
            _winmajor = posvi->dwMajorVersion;
            _winminor = posvi->dwMinorVersion;

            /*
             * The somewhat bizarre calculations of _osver and _winver are 
             * required for backward compatibility (used to use GetVersion)
             */
            _osver = (posvi->dwBuildNumber) & 0x07fff;
            if ( _osplatform != VER_PLATFORM_WIN32_NT )
                _osver |= 0x08000;
            _winver = (_winmajor << 8) + _winminor;

#ifdef  _MT
            if ( !_heap_init(1) )   /* initialize heap */
#else
            if ( !_heap_init(0) )   /* initialize heap */
#endif
                return FALSE;       /* fail to load DLL */

#ifdef  _MT
            if(!_mtinit())          /* initialize multi-thread */
            {
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }
#endif  /* _MT */

            /*
             * Initialize the Runtime Checks stuff
             */
#ifdef  _RTC
            _RTC_Initialize();
#endif
            _acmdln = (char *)GetCommandLineA();
            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            if (_ioinit() < 0) {    /* initialize lowio */
#ifdef  _MT
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
#endif  /* _MT */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            if (_setargv() < 0 ||   /* get cmd line info */
                _setenvp() < 0 ||   /* get environ info */
                _cinit() != 0)      /* do C data initialize */
            {
                _ioterm();          /* shut down lowio */
#ifdef  _MT
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
#endif  /* _MT */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            /*
             * increment flag to indicate process attach notification
             * has been received
             */
            __proc_attached++;
        }

        else if ( dwReason == DLL_PROCESS_DETACH )
        {
            if ( __proc_attached > 0 ) 
            {
                __proc_attached--;

                /*
                 * Any basic clean-up code that goes here must be duplicated
                 * below in _DllMainCRTStartup for the case where the user's
                 * DllMain() routine fails on a Process Attach notification.
                 * This does not include calling user C++ destructors, etc.
                 */

                if ( _C_Termination_Done == FALSE )
                    _cexit();

#ifdef  _DEBUG
                /* Dump all memory leaks */
                if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
                    _CrtDumpMemoryLeaks();
#endif

                /* Shut down lowio */
                _ioterm();

#ifdef  _MT
                _mtterm();
#endif

                /* This should be the last thing the C run-time does */
                _heap_term();   /* heap is now invalid! */
            }
            else
                /* no prior process attach, just return */
                return FALSE;
        }
#ifdef  _MT
        else if ( dwReason == DLL_THREAD_ATTACH )
        {
            _ptiddata ptd;
            if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL))
            {
                if (TlsSetValue(__tlsindex, (LPVOID)ptd) ) {
                    /*
                     * Initialize of per-thread data
                     */
                    _initptd(ptd);
                    
                    ptd->_tid = GetCurrentThreadId();
                    ptd->_thandle = (uintptr_t)(-1);
                } else
                {
                    _free_crt(ptd);
                    return FALSE;
                }
            } else
            {
                return FALSE;
            }
        }
        else if ( dwReason == DLL_THREAD_DETACH )
        {
            _freeptd(NULL);         /* free up per-thread CRT data */
        }
#endif

        return TRUE ;
}

/***
*BOOL WINAPI _DllMainCRTStartup(hDllHandle, dwReason, lpreserved) -
*       C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*       This routine does the C run-time initialization or termination
*       and then calls the user code notification handler "DllMain".
*       For the multi-threaded run-time library, it also cleans up the
*       multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*       This routine is the preferred entry point. _CRT_INIT may also be
*       used, or the user may supply his/her own entry and call _CRT_INIT
*       from within it, but this is not the preferred method.
*
*******************************************************************************/

BOOL WINAPI _DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        BOOL retcode = TRUE;

        /*
         * If this is a process detach notification, check that there has
         * has been a prior process attach notification.
         */
        if ( (dwReason == DLL_PROCESS_DETACH) && (__proc_attached == 0) ) 
            /*
             * no prior process attach notification. just return
             * without doing anything.
             */
            return FALSE;

        if ( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH )
        {
            if ( _pRawDllMain )
                retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);

            if ( retcode )
                retcode = _CRT_INIT(hDllHandle, dwReason, lpreserved);

            if ( !retcode )
                return FALSE;
        }

        retcode = DllMain(hDllHandle, dwReason, lpreserved);

        if ( (dwReason == DLL_PROCESS_ATTACH) && !retcode )
            /*
             * The user's DllMain routine returned failure, the C runtime
             * needs to be cleaned up. Do this by calling _CRT_INIT again, 
             * this time imitating DLL_PROCESS_DETACH. Note this will also
             * clear the __proc_attached flag so the cleanup will not be 
             * repeated upon receiving the real process detach notification.
             */
            _CRT_INIT(hDllHandle, DLL_PROCESS_DETACH, lpreserved);

        if ( (dwReason == DLL_PROCESS_DETACH) || 
             (dwReason == DLL_THREAD_DETACH) )
        {
            if ( _CRT_INIT(hDllHandle, dwReason, lpreserved) == FALSE )
                retcode = FALSE ;

            if ( retcode && _pRawDllMain )
                retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);
        }

        return retcode ;
}


/***
*_amsg_exit(rterrnum) - Fast exit fatal errors
*
*Purpose:
*       Exit the program with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls exit() (for integer divide-by-0) or _exit() indirectly
*       through _aexit_rtn [amsg_exit].
*       For multi-thread: calls _exit() function
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _amsg_exit (
        int rterrnum
        )
{
        if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
               _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);      /* write message */
        _aexit_rtn(255);        /* normally _exit(255) */
}


#endif  /* CRTDLL */
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\crt0dat.c ===
/***
*crt0dat.c - 32-bit C run-time initialization/termination routines
*
*       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the routines _cinit, exit, and _exit
*       for C run-time startup and termination.  _cinit and exit
*       are called from the _astart code in crt0.asm.
*       This module also defines several data variables used by the
*       runtime.
*
*       [NOTE: Lock segment definitions are at end of module.]
*
*Revision History:
*       06-28-89  PHG   Module created, based on asm version
*       04-09-90  GJF   Added #include <cruntime.h>. Made calling type
*                       explicit (_CALLTYPE1 or _CALLTYPE4). Also, fixed
*                       the copyright.
*       04-10-90  GJF   Fixed compiler warnings (-W3).
*       05-21-90  GJF   Added #undef _NFILE_ (temporary hack) and fixed the
*                       indents.
*       08-31-90  GJF   Removed 32 from API names.
*       09-25-90  GJF   Merged tree version with local (8-31 and 5-21 changes).
*       10-08-90  GJF   New-style function declarators.
*       10-12-90  GJF   Removed divide by 0 stuff.
*       10-18-90  GJF   Added _pipech[] array.
*       11-05-90  GJF   Added _umaskval.
*       12-04-90  GJF   Added _osfinfo[] definition for Win32 target. Note that
*                       the Win32 support is still incomplete!
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-04-90  SRW   Added _osfile back for win32.  Changed _osfinfo from
*                       an array of structures to an array of 32-bit handles
*                       (_osfhnd)
*       12-28-90  SRW   Added _CRUISER_ conditional around pack pragmas
*       01-29-91  GJF   ANSI naming.
*       01-29-91  SRW   Added call to GetFileType [_WIN32_]
*       02-18-91  SRW   Removed duplicate defintion of _NFILE_ (see mtdll.h)
*       04-04-91  GJF   Added definitions for _base[version|major|minor]
*                       (_WIN32_).
*       04-08-91  GJF   Temporary hack for Win32/DOS folks - added HeapDestroy
*                       call to doexit to tear down the OS heap used by C
*                       heap.
*       04-09-91  PNT   Added _MAC_ conditional
*       04-26-91  SRW   Removed level 3 warnings
*       07-16-91  GJF   Added fp initialization test-and-call [_WIN32_].
*       07-26-91  GJF   Revised initialization and termination stuff. In
*                       particular, removed need for win32ini.c [_WIN32_].
*       08-07-91  GJF   Added init. for FORTRAN runtime, if present [_WIN32_].
*       08-21-91  GJF   Test _prmtmp against NULL, not _prmtmp().
*       08-21-91  JCR   Added _exitflag, _endstdio, _cpumode, etc.
*       09-09-91  GJF   Revised _doinitterm for C++ init. support and to make
*                       _onexit/atexit compatible with C++ needs.
*       09-16-91  GJF   Must test __onexitend before calling _doinitterm.
*       10-29-91  GJF   Force in floating point initialization for MIPS
*                       compiler [_WIN32_].
*       11-13-91  GJF   FORTRAN needs _onexit/atexit init. before call thru
*                       _pFFinit.
*       12-29-91  RID   MAC module created, based on OS2 version
*       01-10-92  GJF   Merged. Also, added _C_Termination_Done [_WIN32_].
*       02-13-92  GJF   Moved all lowio initialization to ioinit.c for Win32.
*       03-12-92  SKS   Major changes to initialization/termination scheme
*       04-01-92  XY    implemented new intialization/termination schema (MAC)
*       04-16-92  DJM   POSIX support.
*       04-17-92  SKS   Export _initterm() for CRTDLL model
*       05-07-92  DJM   Removed _exit() from POSIX build.
*       06-03-92  GJF   Temporarily restored call to FORTRAN init.
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       08-28-92  GJF   Use unistd.h for POSIX build.
*       09-02-92  SKS   Fix _onexit table traversal to be LIFO.
*                       Since table is built forward (my changes 03-12-92)
*                       the table must be traversed in reverse order.
*       11-12-92  SKS   Remove hard-coded call to FORTRAN initializer
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Change to __declspec(dllexport) for CRT DLL model
*       04-19-93  SKS   Remove obsolete variable _child.
*       04-20-93  SKS   _C_Termination_Done is now used by DLLs in LIBC/LIBCMT
*                       models, not just in MSVCRT10.DLL.
*       07-16-93  SRW   ALPHA Merge
*       09-21-93  CFW   Move _initmbctable call to _cinit().
*       10-19-93  GJF   Merged NT and Cuda versions. Cleaned out a lot of old
*                       Cruiser and Dosx32 support. Replaced MTHREAD with
*                       _MT, _MIPS_ with _M_MRX000, _ALPHA_ with _M_ALPHA.
*       11-09-93  GJF   Moved _initmbctable call back into crt0.c.
*       11-09-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       11-19-93  CFW   Add _wargv, _wpgmptr.
*       11-29-93  CFW   Add _wenviron.
*       12-15-93  CFW   Set _pgmptr, _wpgmptr to NULL (MIPS compiler bug).
*       02-04-94  CFW   Add _[w]initenv.
*       03-25-94  GJF   Made definitions of:
*                           __argc,
*                           __argv,     __wargv,
*                           _C_Termination_Done,
*                           _environ,   _wenviron,
*                           _exitflag,
*                           __initenv,  __winitenv,
*                           __onexitbegin, __onexitend,
*                           _osver,
*                           _pgmptr,    _wpgmptr,
*                           _winmajor,
*                           _winminor
*                           _winver
*                       conditional on ndef DLL_FOR_WIN32S.
*       10-02-94  BWT   Add PPC changes
*       12-03-94  SKS   Clean up OS/2 references
*       02-11-95  CFW   PPC -> _M_MPPC.
*       02-16-95  JWM   Spliced _WIN32 & Mac versions.
*       02-24-95  CFW   Call _CrtDumpMemoryLeaks.
*       02-27-95  CFW   Make _CrtDumpMemoryLeaks call conditional
*       04-06-95  CFW   Only check for static libs, avoid infinite loop.
*       07-24-95  CFW   Call _CrtDumpMemoryLeaks for PMac.
*       12-18-95  JWM   doexit() can no longer be called recursively.
*       08-01-96  RDK   For PMac, define _osflagfiles, cleaned up Gestalt test,
*                       and make termination parallel x86 functionality.
*       07-24-97  GJF   Added __env_initialized flag.
*       08-06-97  GJF   Moved __mbctype_initialized flag here from crt0.c.
*       09-26-97  BWT   Fix POSIX
*       10-07-97  RDL   Added IA64.
*       01-16-98  RDL   Removed IA64 from fpinit #if for _fltused support.
*       10-02-98  GJF   Added _osplatform.
*       11-13-98  KBF   Only do an atexit(RTC_Terminate) - moved Init to after
*                       _heap_init
*       02-01-99  GJF   Slight change to terminator execution loop to allow
*                       terminators to register more terminators.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       03-06-00  PML   Add __crtExitProcess for COM+ exit processing.
*       04-28-00  BWT   Fix Posix
*       08-04-00  PML   COM+ -> managed (VS7#117746).
*       03-27-01  PML   .CRT$XI funcs now return an error status (VS7#231220).
*       05-01-01  BWT   Remove TerminateProcess call.  It's not necessary when
*                       simply exiting would serve the same purpose.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#include <rtcapi.h>
#endif
#include <dos.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <dbgint.h>
#include <sect_attribs.h>

/* define errno */
#ifndef _MT
int errno = 0;            /* libc error value */
unsigned long _doserrno = 0;  /* OS system error value */
#endif  /* _MT */


/* define umask */
int _umaskval = 0;


/* define version info variables */

_CRTIMP unsigned int _osplatform = 0;
_CRTIMP unsigned int _osver = 0;
_CRTIMP unsigned int _winver = 0;
_CRTIMP unsigned int _winmajor = 0;
_CRTIMP unsigned int _winminor = 0;


/* argument vector and environment */

_CRTIMP int __argc = 0;
_CRTIMP char **__argv = NULL;
_CRTIMP wchar_t **__wargv = NULL;
#ifdef  _POSIX_
char **environ = NULL;
#else
_CRTIMP char **_environ = NULL;
_CRTIMP char **__initenv = NULL;
_CRTIMP wchar_t **_wenviron = NULL;
_CRTIMP wchar_t **__winitenv = NULL;
#endif
_CRTIMP char *_pgmptr = NULL;           /* ptr to program name */
_CRTIMP wchar_t *_wpgmptr = NULL;       /* ptr to wide program name */


/* callable exit flag */
char _exitflag = 0;

/*
 * flag indicating if C runtime termination has been done. set if exit,
 * _exit, _cexit or _c_exit has been called. checked when _CRTDLL_INIT
 * is called with DLL_PROCESS_DETACH.
 */
int _C_Termination_Done = FALSE;
int _C_Exit_Done = FALSE;

#ifndef CRTDLL
/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
int __env_initialized;

#endif

#ifdef  _MBCS
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
int __mbctype_initialized;
#endif  /* _MBCS */


/*
 * NOTE: THE USE OF THE POINTERS DECLARED BELOW DEPENDS ON THE PROPERTIES
 * OF C COMMUNAL VARIABLES. SPECIFICALLY, THEY ARE NON-NULL IFF THERE EXISTS
 * A DEFINITION ELSEWHERE INITIALIZING THEM TO NON-NULL VALUES.
 */

/*
 * pointers to initialization functions
 */

_PVFV _FPinit;          /* floating point init. */

/*
 * pointers to initialization sections
 */

extern _CRTALLOC(".CRT$XIA") _PIFV __xi_a[];
extern _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[];    /* C initializers */
extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */
extern _CRTALLOC(".CRT$XPA") _PVFV __xp_a[];
extern _CRTALLOC(".CRT$XPZ") _PVFV __xp_z[];    /* C pre-terminators */
extern _CRTALLOC(".CRT$XTA") _PVFV __xt_a[];
extern _CRTALLOC(".CRT$XTZ") _PVFV __xt_z[];    /* C terminators */

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
/*
 * For MIPS compiler, must explicitly force in and call the floating point
 * initialization.
 */
extern void __cdecl _fpmath(void);
#endif

/*
 * pointers to the start and finish of the _onexit/atexit table
 */
_PVFV *__onexitbegin;
_PVFV *__onexitend;


/*
 * static (internal) functions that walk a table of function pointers,
 * calling each entry between the two pointers, skipping NULL entries
 *
 * _initterm needs to be exported for CRT DLL so that C++ initializers in the
 * client EXE / DLLs can be initialized.
 *
 * _initterm_e calls function pointers that return a nonzero error code to
 * indicate an initialization failed fatally.
 */
#ifdef  CRTDLL
void __cdecl _initterm(_PVFV *, _PVFV *);
#else
static void __cdecl _initterm(_PVFV *, _PVFV *);
#endif
static int  __cdecl _initterm_e(_PIFV *, _PIFV *);


/***
*_cinit - C initialization
*
*Purpose:
*       This routine performs the shared DOS and Windows initialization.
*       The following order of initialization must be preserved -
*
*       1.  Check for devices for file handles 0 - 2
*       2.  Integer divide interrupt vector setup
*       3.  General C initializer routines
*
*Entry:
*       No parameters: Called from __crtstart and assumes data
*       set up correctly there.
*
*Exit:
*       Initializes C runtime data.
*       Returns 0 if all .CRT$XI internal initializations succeeded, else
*       the _RT_* fatal error code encountered.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _cinit (
        void
        )
{
        int initret;

        /*
         * initialize floating point package, if present
         */
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
        /*
         * MIPS compiler doesn't emit external reference to _fltused. Therefore,
         * must always force in the floating point initialization.
         */
        _fpmath();
#else
        if ( _FPinit != NULL )
            (*_FPinit)();
#endif

        /*
         * do initializations
         */
        initret = _initterm_e( __xi_a, __xi_z );
        if ( initret != 0 )
            return initret;

#ifdef  _RTC
        atexit(_RTC_Terminate);
#endif
        /*
         * do C++ initializations
         */
        _initterm( __xc_a, __xc_z );

        return 0;
}


/***
*exit(status), _exit(status), _cexit(void), _c_exit(void) - C termination
*
*Purpose:
*
*       Entry points:
*
*           exit(code):  Performs all the C termination functions
*               and terminates the process with the return code
*               supplied by the user.
*
*           _exit(code):  Performs a quick exit routine that does not
*               do certain 'high-level' exit processing.  The _exit
*               routine terminates the process with the return code
*               supplied by the user.
*
*           _cexit():  Performs the same C lib termination processing
*               as exit(code) but returns control to the caller
*               when done (i.e., does NOT terminate the process).
*
*           _c_exit():  Performs the same C lib termination processing
*               as _exit(code) but returns control to the caller
*               when done (i.e., does NOT terminate the process).
*
*       Termination actions:
*
*           exit(), _cexit():
*
*           1.  call user's terminator routines
*           2.  call C runtime preterminators
*
*           _exit(), _c_exit():
*
*           3.  call C runtime terminators
*           4.  return to DOS or caller
*
*       Notes:
*
*       The termination sequence is complicated due to the multiple entry
*       points sharing the common code body while having different entry/exit
*       sequences.
*
*       Multi-thread notes:
*
*       1. exit() should NEVER be called when mthread locks are held.
*          The exit() routine can make calls that try to get mthread locks.
*
*       2. _exit()/_c_exit() can be called from anywhere, with or without locks held.
*          Thus, _exit() can NEVER try to get locks (otherwise, deadlock
*          may occur).  _exit() should always 'work' (i.e., the process
*          should always terminate successfully).
*
*       3. Only one thread is allowed into the exit code (see _lockexit()
*          and _unlockexit() routines).
*
*Entry:
*       exit(), _exit()
*           int status - exit status (0-255)
*
*       _cexit(), _c_exit()
*           <no input>
*
*Exit:
*       exit(), _exit()
*           <EXIT to DOS>
*
*       _cexit(), _c_exit()
*           Return to caller
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

/* worker routine prototype */
static void __cdecl doexit (int code, int quick, int retcaller);

void __cdecl exit (
        int code
        )
{
        doexit(code, 0, 0); /* full term, kill process */
}

#ifndef _POSIX_

void __cdecl _exit (
        int code
        )
{
        doexit(code, 1, 0); /* quick term, kill process */
}

void __cdecl _cexit (
        void
        )
{
        doexit(0, 0, 1);    /* full term, return to caller */
}

void __cdecl _c_exit (
        void
        )
{
        doexit(0, 1, 1);    /* quick term, return to caller */
}

#endif  /* _POSIX_ */


static void __cdecl doexit (
        int code,
        int quick,
        int retcaller
        )
{
#ifdef  _DEBUG
        static int fExit = 0;
#endif /* _DEBUG */

#ifdef  _MT
        _lockexit();        /* assure only 1 thread in exit path */
#endif

#ifndef _POSIX_
        if (_C_Exit_Done == TRUE)                               /* if doexit() is being called recursively */
                goto ExitBranch;
#endif
        _C_Termination_Done = TRUE;

        /* save callable exit flag (for use by terminators) */
        _exitflag = (char) retcaller;  /* 0 = term, !0 = callable exit */

        if (!quick) {

            /*
             * do _onexit/atexit() terminators
             * (if there are any)
             *
             * These terminators MUST be executed in reverse order (LIFO)!
             *
             * NOTE:
             *  This code assumes that __onexitbegin points
             *  to the first valid onexit() entry and that
             *  __onexitend points past the last valid entry.
             *  If __onexitbegin == __onexitend, the table
             *  is empty and there are no routines to call.
             */

            if (__onexitbegin) {
                while ( --__onexitend >= __onexitbegin )
                /*
                 * if current table entry is non-NULL,
                 * call thru it.
                 */
                if ( *__onexitend != NULL )
                    (**__onexitend)();
            }

            /*
             * do pre-terminators
             */
            _initterm(__xp_a, __xp_z);
        }

        /*
         * do terminators
         */
        _initterm(__xt_a, __xt_z);

#ifndef CRTDLL
#ifdef  _DEBUG
        /* Dump all memory leaks */
        if (!fExit && _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
        {
            fExit = 1;
            _CrtDumpMemoryLeaks();
        }
#endif
#endif

#ifndef _POSIX_
ExitBranch:
#endif
        /* return to OS or to caller */

        if (retcaller) {
#ifdef  _MT
            _unlockexit();      /* unlock the exit code path */
#endif
            return;
        }

#ifdef  _POSIX_

        _exit(code);
}

#else   /* ndef _POSIX_ */

        _C_Exit_Done = TRUE;

        __crtExitProcess(code);
}

/***
* __crtExitProcess - CRT wrapper for ExitProcess
*
*Purpose:
*       If we're part of a managed app, then call the CorExitProcess,
*       otherwise call ExitProcess.  For managed apps, calling ExitProcess can
*       be problematic, because it doesn't give the managed FinalizerThread a
*       chance to clean up.
*
*       To determine if we're a managed app, we check if mscoree.dll is loaded.
*       Then, if CorExitProcess is available, we call it.
*
*Entry:
*       int status - exit code
*
*Exit:
*       Does not return
*
*Exceptions:
*
*******************************************************************************/

typedef void (WINAPI * PFN_EXIT_PROCESS)(UINT uExitCode);

void __cdecl __crtExitProcess (
        int status
        )
{
        HMODULE hmod;
        PFN_EXIT_PROCESS pfn;

        hmod = GetModuleHandle("mscoree.dll");
        if (hmod != NULL) {
            pfn = (PFN_EXIT_PROCESS)GetProcAddress(hmod, "CorExitProcess");
            if (pfn != NULL) {
                pfn(status);
            }
        }

        /*
         * Either mscoree.dll isn't loaded,
         * or CorExitProcess isn't exported from mscoree.dll,
         * or CorExitProcess returned (should never happen).
         * Just call ExitProcess.
         */

        ExitProcess(status);
}

#endif  /* _POSIX_ */

#ifdef  _MT
/***
* _lockexit - Aquire the exit code lock
*
*Purpose:
*       Makes sure only one thread is in the exit code at a time.
*       If a thread is already in the exit code, it must be allowed
*       to continue.  All other threads must pend.
*
*       Notes:
*
*       (1) It is legal for a thread that already has the lock to
*       try and get it again(!).  That is, consider the following
*       sequence:
*
*           (a) program calls exit()
*           (b) thread locks exit code
*           (c) user onexit() routine calls _exit()
*           (d) same thread tries to lock exit code
*
*       Since _exit() must ALWAYS be able to work (i.e., can be called
*       from anywhere with no regard for locking), we must make sure the
*       program does not deadlock at step (d) above.
*
*       (2) If a thread executing exit() or _exit() aquires the exit lock,
*       other threads trying to get the lock will pend forever.  That is,
*       since exit() and _exit() terminate the process, there is not need
*       for them to unlock the exit code path.
*
*       (3) Note that onexit()/atexit() routines call _lockexit/_unlockexit
*       to protect mthread access to the onexit table.
*
*       (4) The 32-bit OS semaphore calls DO allow a single thread to acquire
*       the same lock multiple times* thus, this version is straight forward.
*
*Entry: <none>
*
*Exit:
*       Calling thread has exit code path locked on return.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lockexit (
        void
        )
{
        _mlock(_EXIT_LOCK1);
}

/***
* _unlockexit - Release exit code lock
*
*Purpose:
*       [See _lockexit() description above.]
*
*       This routine is called by _cexit(), _c_exit(), and onexit()/atexit().
*       The exit() and _exit() routines never unlock the exit code path since
*       they are terminating the process.
*
*Entry:
*       Exit code path is unlocked.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlockexit (
        void
        )
{
        _munlock(_EXIT_LOCK1);
}

#endif /* _MT */


/***
* static void _initterm(_PVFV * pfbegin, _PVFV * pfend) - call entries in
*       function pointer table
*
*Purpose:
*       Walk a table of function pointers, calling each entry, as follows:
*
*           1. walk from beginning to end, pfunctbl is assumed to point
*              to the beginning of the table, which is currently a null entry,
*              as is the end entry.
*           2. skip NULL entries
*           3. stop walking when the end of the table is encountered
*
*Entry:
*       _PVFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PVFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it to initialize their C++ constructors.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

#ifdef  CRTDLL
void __cdecl _initterm (
#else
static void __cdecl _initterm (
#endif
        _PVFV * pfbegin,
        _PVFV * pfend
        )
{
        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend )
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                (**pfbegin)();
            ++pfbegin;
        }
}

/***
* static int  _initterm_e(_PIFV * pfbegin, _PIFV * pfend) - call entries in
*       function pointer table, return error code on any failure
*
*Purpose:
*       Walk a table of function pointers in the same way as _initterm, but
*       here the functions return an error code.  If an error is returned, it
*       will be a nonzero value equal to one of the _RT_* codes.
*
*Entry:
*       _PIFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PIFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

static int __cdecl _initterm_e (
        _PIFV * pfbegin,
        _PIFV * pfend
        )
{
        int ret = 0;

        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend  && ret == 0)
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                ret = (**pfbegin)();
            ++pfbegin;
        }

        return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\thread.c ===
/***
*thread.c - Begin and end a thread
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This source contains the _beginthread() and _endthread()
*       routines which are used to start and terminate a thread.
*
*Revision History:
*       05-09-90  JCR   Translated from ASM to C
*       07-25-90  SBM   Removed '32' from API names
*       10-08-90  GJF   New-style function declarators.
*       10-09-90  GJF   Thread ids are of type unsigned long.
*       10-19-90  GJF   Added code to set _stkhqq properly in stub().
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       06-03-91  GJF   Win32 version [_WIN32_].
*       07-18-91  GJF   Fixed many silly errors [_WIN32_].
*       08-19-91  GJF   Allow for newly created thread terminating before
*                       _beginthread returns
*       09-30-91  GJF   Add per-thread initialization and termination calls
*                       for floating point.
*       01-18-92  GJF   Revised try - except statement.
*       02-25-92  GJF   Initialize _holdrand field to 1.
*       09-30-92  SRW   Add WINAPI keyword to _threadstart routine
*       10-30-92  GJF   Error ret for CreateThread is 0 (NULL), not -1.
*       02-13-93  GJF   Revised to use TLS API. Also, purged Cruiser support.
*       03-26-93  GJF   Fixed horribly embarrassing bug: ptd->pxcptacttab
*                       must be initialized to _XcptActTab!
*       04-01-93  CFW   Change try-except to __try-__except
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       10-26-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       12-13-93  SKS   Free up per-thread data using a call to _freeptd()
*       01-06-94  GJF   Free up _tiddata struct upon failure in _beginthread.
*                       Also, set errno on failure.
*       01-10-95  CFW   Debug CRT allocs.
*       04-18-95  SKS   Add 5 MIPS per-thread variables.
*       05-02-95  SKS   Call _initptd for initialization of per-thread data.
*       02-03-98  GJF   Changes for Win64: use uintptr_t type for anything with
*                       a HANDLE value.
*       02-02-00  GB    Modified threadstart() to prevent leaking of ptd
*                       allocated during call to getptd while ATTACHing THREAD 
*                       in dlls.
*       08-04-00  PML   Set EINVAL error if thread start address null in
*                       _beginthread (VS7#118688).
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <malloc.h>
#include <process.h>
#include <stddef.h>
#include <rterr.h>
#include <dbgint.h>
#include <errno.h>

/*
 * Startup code for new thread.
 */
static unsigned long WINAPI _threadstart(void *);

/*
 * declare pointers to per-thread FP initialization and termination routines
 */
_PVFV _FPmtinit;
_PVFV _FPmtterm;


/***
*_beginthread() - Create a child thread
*
*Purpose:
*       Create a child thread.
*
*Entry:
*       initialcode = pointer to thread's startup code address
*       stacksize = size of stack
*       argument = argument to be passed to new thread
*
*Exit:
*       success = handle for new thread if successful
*
*       failure = (unsigned long) -1L in case of error, errno and _doserrno
*                 are set
*
*Exceptions:
*
*******************************************************************************/

uintptr_t __cdecl _beginthread (
        void (__cdecl * initialcode) (void *),
        unsigned stacksize,
        void * argument
        )
{
        _ptiddata ptd;                  /* pointer to per-thread data */
        uintptr_t thdl;                 /* thread handle */
        unsigned long errcode = 0L;     /* Return from GetLastError() */

        if ( initialcode == NULL ) {
            errno = EINVAL;
            return( (uintptr_t)(-1) );
        }

        /*
         * Allocate and initialize a per-thread data structure for the to-
         * be-created thread.
         */
        if ( (ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL )
                goto error_return;

        /*
         * Initialize the per-thread data
         */

        _initptd(ptd);

        ptd->_initaddr = (void *) initialcode;
        ptd->_initarg = argument;

        /*
         * Create the new thread. Bring it up in a suspended state so that
         * the _thandle and _tid fields are filled in before execution
         * starts.
         */
        if ( (ptd->_thandle = thdl = (uintptr_t)
              CreateThread( NULL,
                            stacksize,
                            _threadstart,
                            (LPVOID)ptd,
                            CREATE_SUSPENDED,
                            (LPDWORD)&(ptd->_tid) ))
             == (uintptr_t)0 )
        {
                errcode = GetLastError();
                goto error_return;
        }

        /*
         * Start the new thread executing
         */
        if ( ResumeThread( (HANDLE)thdl ) == (DWORD)(-1) ) {
                errcode = GetLastError();
                goto error_return;
        }

        /*
         * Good return
         */
        return(thdl);

        /*
         * Error return
         */
error_return:
        /*
         * Either ptd is NULL, or it points to the no-longer-necessary block
         * calloc-ed for the _tiddata struct which should now be freed up.
         */
        _free_crt(ptd);

        /*
         * Map the error, if necessary.
         */
        if ( errcode != 0L )
                _dosmaperr(errcode);

        return( (uintptr_t)(-1) );
}


/***
*_threadstart() - New thread begins here
*
*Purpose:
*       The new thread begins execution here.  This routine, in turn,
*       passes control to the user's code.
*
*Entry:
*       void *ptd       = pointer to _tiddata structure for this thread
*
*Exit:
*       Never returns - terminates thread!
*
*Exceptions:
*
*******************************************************************************/

static unsigned long WINAPI _threadstart (
        void * ptd
        )
{
        _ptiddata _ptd;                  /* pointer to per-thread data */
        
        /* 
         * Check if ptd is initialised during THREAD_ATTACH call to dll mains
         */
        if ( (_ptd = TlsGetValue(__tlsindex)) == NULL)
        {
            /*
             * Stash the pointer to the per-thread data stucture in TLS
             */
            if ( !TlsSetValue(__tlsindex, ptd) )
                _amsg_exit(_RT_THREAD);
        }
        else
        {
            _ptd->_initaddr = ((_ptiddata) ptd)->_initaddr;
            _ptd->_initarg =  ((_ptiddata) ptd)->_initarg;
            _ptd->_thandle =  ((_ptiddata) ptd)->_thandle;
            _free_crt(ptd);
            ptd = _ptd;
        }

        /*
         * Call fp initialization, if necessary
         */
        if ( _FPmtinit != NULL )
                (*_FPmtinit)();

        /*
         * Guard call to user code with a _try - _except statement to
         * implement runtime errors and signal support
         */
        __try {
                ( (void(__cdecl *)(void *))(((_ptiddata)ptd)->_initaddr) )
                    ( ((_ptiddata)ptd)->_initarg );

                _endthread();
        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
                /*
                 * Should never reach here
                 */
                _exit( GetExceptionCode() );

        } /* end of _try - _except */

        /*
         * Never executed!
         */
        return(0L);
}


/***
*_endthread() - Terminate the calling thread
*
*Purpose:
*
*Entry:
*       void
*
*Exit:
*       Never returns!
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _endthread (
        void
        )
{
        _ptiddata ptd;           /* pointer to thread's _tiddata struct */

        /*
         * Call fp termination, if necessary
         */
        if ( _FPmtterm != NULL )
                (*_FPmtterm)();

        if ( (ptd = _getptd()) == NULL )
                _amsg_exit(_RT_THREAD);

        /*
         * Close the thread handle (if there was one)
         */
        if ( ptd->_thandle != (uintptr_t)(-1) )
                (void) CloseHandle( (HANDLE)(ptd->_thandle) );

        /*
         * Free up the _tiddata structure & its subordinate buffers
         *      _freeptd() will also clear the value for this thread
         *      of the TLS variable __tlsindex.
         */
        _freeptd(ptd);

        /*
         * Terminate the thread
         */
        ExitThread(0);

}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\tidprint.c ===
/***
*tidprint.c - Dislpay thread data
*
*	Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Display the per thread data table.
*
*	[NOTE: This module is NOT included in the C runtime libraries but
*	is maintained for debugging analysis.]
*
*Revision History:
*	11-17-88  JCR	Module created.
*	04-03-89  JCR	Added _stackalloc to tid table
*	06-06-89  JCR	386 version
*	06-09-89  JCR	386: Added values to _tiddata struc (for _beginthread)
*	04-09-90  GJF	Added #include <cruntime.h>. Made the calling type
*			_CALLTYPE1. Also, fixed the copyright.
*	04-10-90  GJF	Removed #include <dos.h>.
*	08-16-90  SBM	Made _terrno and _tdoserrno int, not unsigned
*	10-08-90  GJF	New-style function declarators.
*	10-09-90  GJF	Thread ids are of type unsigned long!
*	12-18-90  GJF	Use real thread id, not thread id - 1.
*	08-01-91  GJF	Adapted for Win32 [_WIN32_].
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	12-07-93  CFW   Rip out Cruiser, add _wasctimebuf.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <mtdll.h>

void __cdecl _print_tiddata(unsigned long);
void __cdecl _print_tiddata1(_ptiddata);

/***
*void _print_tiddata(unsigned long) - Display data for a thread
*
*Purpose:
*	This routine displays the per thread data for a specific, or all,
*	active threads in the _ptd[] table.
*
*Entry:
*	unsigned long = <n> = ID of the thread to display
*		      = -1  = Display thread data for all threads
*
*Exit:
*	<void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _print_tiddata (
	unsigned long tid
	)
{
	int i;			/* loop index */
	int threadcnt;		/* number of active threads */

	/*
	 * lock the _ptd[] table.
	 */
	_mlock(_THREADDATA_LOCK);

	/*
	 * see if caller want's all threads or just a specific one.
	 */
	if (tid == (unsigned long) -1L) {
		/*
		 * caller want's all threads!
		 */
		for ( i = threadcnt = 0 ; i < 1024 ; i++ )
			/*
			 * print out the fields of *_ptd[i] for each entry
			 * bound to an active thread (i.e., for each i st
			 * _ptd[i] non-NULL). also, count up the total number
			 * of active threads.
			 */
			if ( _ptd[i] != NULL ) {
				threadcnt++;
				_print_tiddata1(_ptd[i]);
			}

		printf("\nTHERE ARE %d CURRENTLY ACTIVE THREADS!\n", threadcnt);
	}
	else {
		/*
		 * caller just interested in a particular thread. search
		 * the _ptd[] table inline because a call to _getptd[] would
		 * have unpleasant side effects if tid is not (or no longer)
		 * valid.
		 */
		for ( i = 0 ; (i < 1024) && ((_ptd[i] == NULL) ||
		    (_ptd[i] == (_ptiddata)1L) || (_ptd[i]->_tid != tid)) ;
		    i++ ) ;

		if ( i < 1024 )
			_print_tiddata1(_ptd[i]);
		else
			printf("\nTID INVALID OR THREAD HAS TERMINATED!\n");
	}

	/*
	 * unlock the _ptd[] table.
	 */
	_munlock(_THREADDATA_LOCK);

}


/***
* void _print_tiddata1(_ptiddata ptd) - print out _tiddata structure
*
*Purpose:
*	Given a pointer to a thread data structure, print out its contents
*
*Entry:
*	ptd = pointer to thread's data area
*
*Exit:
*	<void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _print_tiddata1 (
	_ptiddata ptd
	)
{
	printf("\t_tid            = %lu\n",  ptd->_tid );
	printf("\t_thandle        = %lu\n",  ptd->_thandle );
	printf("\t_terrno         = %d\n",   ptd->_terrno);
	printf("\t_tdoserrno      = %d\n",   ptd->_tdoserrno);
	printf("\t_fpds           = %#x\n",  ptd->_fpds);
	printf("\t_holdrand       = %u\n",   ptd->_holdrand);
	printf("\t_token          = %p\n",   ptd->_token);
	printf("\t_errmsg         = %p\n",   ptd->_errmsg);
	printf("\t_namebuf        = %p\n",   ptd->_namebuf);
	printf("\t_asctimebuf     = %p\n",   ptd->_asctimebuf);
	printf("\t_wasctimebuf    = %p\n",   ptd->_wasctimebuf);
	printf("\t_gmtimebuf      = %p\n",   ptd->_gmtimebuf);
	printf("\t_initaddr       = %p\n",   ptd->_initaddr);
	printf("\t_initarg        = %p\n",   ptd->_initarg);
	printf("\t_pxcptacttab    = %p\n",   ptd->_pxcptacttab);
	printf("\t_tpxcptinfoptrs = %p\n",   ptd->_tpxcptinfoptrs);
	printf("\t_tfpecode       = %p\n\n", ptd->_tfpecode);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\tidtable.c ===
/***
*tidtable.c - Access thread data table
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the following routines for multi-thread
*       data support:
*
*       _mtinit     = Initialize the mthread data
*       _getptd     = get the pointer to the per-thread data structure for
*                       the current thread
*       _freeptd    = free up a per-thread data structure and its
*                       subordinate structures
*       __threadid  = return thread ID for the current thread
*       __threadhandle = return pseudo-handle for the current thread
*
*Revision History:
*       05-04-90  JCR   Translated from ASM to C for portable 32-bit OS/2
*       06-04-90  GJF   Changed error message interface.
*       07-02-90  GJF   Changed __threadid() for DCR 1024/2012.
*       08-08-90  GJF   Removed 32 from API names.
*       10-08-90  GJF   New-style function declarators.
*       10-09-90  GJF   Thread ids are of type unsigned long! Also, fixed a
*                       bug in __threadid().
*       10-22-90  GJF   Another bug in __threadid().
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-31-91  GJF   Win32 version [_WIN32_].
*       07-18-91  GJF   Fixed many silly errors [_WIN32_].
*       09-29-91  GJF   Conditionally added _getptd_lk/_getptd1_lk so that
*                       DEBUG version of mlock doesn't infinitely recurse
*                       the first time _THREADDATA_LOCK is asserted [_WIN32_].
*       01-30-92  GJF   Must init. _pxcptacttab field to _XcptActTab.
*       02-25-92  GJF   Initialize _holdrand field to 1.
*       02-13-93  GJF   Revised to use TLS API. Also, purged Cruiser support.
*       03-26-93  GJF   Initialize ptd->_holdrand to 1L (see thread.c).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-13-93  SKS   Add _mtterm to do multi-thread termination
*                       Set freed __tlsindex to -1 again to prevent mis-use
*       04-26-93  SKS   _mtinit now returns 0 or 1, no longer calls _amsg_exit
*       12-13-93  SKS   Add _freeptd(), which frees up the per-thread data
*                       maintained by the C run-time library.
*       04-12-94  GJF   Made definition of __tlsindex conditional on ndef
*                       DLL_FOR_WIN32S. Also, replaced MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       04-12-95  DAK   Added NT kernel support for C++ exceptions
*       04-18-95  SKS   Add 5 MIPS per-thread variables.
*       04-25-95  DAK   More Kernel EH support
*       05-02-95  SKS   add _initptd() to do initialization of per-thread data
*       05-24-95  CFW   Add _defnewh.
*       06-12-95  JWM   _getptd() now preserves LastError.
*       01-17-97  GJF   _freeptd() must free the thread's copy of the
*                       exception-action table.
*       09-26-97  BWT   Fix NTSUBSET
*       02-03-98  GJF   Changes for Win64: use uintptr_t type for anything with
*                       a HANDLE value.
*       04-27-98  GJF   Added support for per-thread mbc information.
*       07-28-98  JWM   Initialize __pceh (new per-thread data for comerr support).
*       09-03-98  GJF   Added support for per-thread locale information.
*       12-04-98  JWM   Pulled all comerr support.
*       12-08-98  GJF   In _freeptd, fixed several errors in cleaning up the 
*                       threadlocinfo.
*       12-18-98  GJF   Fixed one more error in _freeptd.
*       01-18-99  GJF   Take care not to free up __ptlocinfo when a thread 
*                       exits.
*       03-16-99  GJF   threadlocinfo incorporates more reference counters
*       04-24-99  PML   Added __lconv_intl_refcount
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       11-03-99  RDL   Win64 _NTSUBSET_ warning fix.
*       06-08-00  PML   No need to keep per-thread mbcinfo in circular linked
*                       list.  Also, don't free mbcinfo if it's also the global
*                       info (vs7#118174).
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       06-12-01  BWT   ntbug: 414059 - cleanup from mtinit failure
*
*******************************************************************************/

#if defined(_MT) || defined(_NTSUBSET_)

# if defined(_NTSUBSET_)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <ntos.h>
#include <fsrtl.h>

# endif /* _NTSUBSET_ */

#include <sect_attribs.h>
#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <memory.h>
#include <msdos.h>
#include <rterr.h>
#include <stdlib.h>
#include <stddef.h>
#include <dbgint.h>

#ifdef  _MT
extern pthreadmbcinfo __ptmbcinfo;

extern threadlocinfo __initiallocinfo;
extern pthreadlocinfo __ptlocinfo;

void __cdecl __freetlocinfo(pthreadlocinfo);
#endif

unsigned long __tlsindex = 0xffffffff;

#if defined(_NTSUBSET_)

#define BEGIN_NONPAGED_CODE code_seg(".text")
#define END_NONPAGED_CODE   code_seg("PAGE")

static _ptiddata   pTheKernelExceptionContextPool;
static KSPIN_LOCK  TheKernelExceptionContextPoolLock;

/****
*_initKernelExceptionContextPool() - creates kernel-mode exception context pool
*
*Purpose:
*   (1) Initializes spin-lock used to serialize access to pool
*
*Entry:
*   <NONE>
*Exit:
*   <NONE>
*
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
void __cdecl _initKernelExceptionContextPool(void)
{
    KeInitializeSpinLock( &TheKernelExceptionContextPoolLock );
}
#pragma END_NONPAGED_CODE


/****
*  Tell the linker to insert a call to this function into the CRT runtime
*  startup.
*
*  The segment .CRT$XCA is the first data segment bounding the array
*  of CRT startup functions.  We therefore insert our function between
*  the first (.CRT$XCA) and the last (.CRT$XCZ).
*
*******************************************************************************/
#pragma data_seg(".CRT$XCAA")
typedef void (__cdecl *PFStartup)(void);
_CRTALLOC(".CRT$XCAA") PFStartup _KernelECPool = _initKernelExceptionContextPool;
#pragma data_seg(".CRT$XCZ")

#pragma data_seg()


/****
*_emptyKernelExceptionContextPool() - empties kernel-mode exception context pool
*
*Purpose:
*   (1) Deletes all entries in the pool
*
*Entry:
*   <NONE>
*Exit:
*   <NONE>
*
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
void _emptyKernelExceptionContextPool()
{
        while ( pTheKernelExceptionContextPool != 0 ) {
            _ptiddata ptd = pTheKernelExceptionContextPool;
            pTheKernelExceptionContextPool = pTheKernelExceptionContextPool->_next;

            ExFreePool( ptd );
        }
}
#pragma END_NONPAGED_CODE


/****
*_newKernelTid() - Creates, initializes and sets the current thread's
* OfsChain to _tiddata;
*
*Purpose:
*   (1) Creates a new kernel-mode _tiddata
*   (2) Initializes fields in new _tiddata
*   (3) Sets current thread's OfsChain to new _tiddata
*
*   NOTES:
*   (1) Can not fail; the memory allocation will cause a fatal system
*       trap if memory can not be allocated
*
*Entry:
*   <NONE>
*Exit:
*   _ptiddata
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
static _ptiddata _newKernelTid(void)
{
        /*
         * Pop an entry from the pool of _ptiddata's
         */

        _ptiddata ptd;
        PSINGLE_LIST_ENTRY entry;

        entry = ExInterlockedPopEntryList((PSINGLE_LIST_ENTRY) & pTheKernelExceptionContextPool,
                                                               & TheKernelExceptionContextPoolLock );

        /*
         *  If none are available, create a new one.
         */

        if ( 0 == entry ) {
            ptd = FsRtlAllocatePoolWithTag( NonPagedPoolMustSucceed,
                                          sizeof(struct _tiddata),
                                          ' dtp' );

        } else {
            ptd = CONTAINING_RECORD( entry, struct _tiddata, _next );
        }

        ptd->_tid          = (unsigned long) (uintptr_t) PsGetCurrentThread()->Cid.UniqueThread;
        ptd->_terminate    = 0;
        ptd->_unexpected   = 0;
        ptd->_translator   = SystemExceptionTranslator;
        ptd->_curexception = 0;
        ptd->_curcontext   = 0;

        PsGetCurrentThread()->OfsChain = ptd;

        return ptd;
}
#pragma END_NONPAGED_CODE


/****
*_freeKernelTid() - appends the _tiddata to the pool
*
*Entry:
*   _ptiddata
*Exit:
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
static void _freeKernelTid(_ptiddata ptd)
{
        /*
         *  Return the entry to the kernel pool
         */
        ExInterlockedPushEntryList( (PSINGLE_LIST_ENTRY) &pTheKernelExceptionContextPool,
                                (PSINGLE_LIST_ENTRY) &ptd->_next,
                                &TheKernelExceptionContextPoolLock );
}
#pragma END_NONPAGED_CODE
#endif /* _NTSUBSET_ */

/****
*_mtinit() - Init multi-thread data bases
*
*Purpose:
*       (1) Call _mtinitlocks to create/open all lock semaphores.
*       (2) Allocate a TLS index to hold pointers to per-thread data
*           structure.
*
*       NOTES:
*       (1) Only to be called ONCE at startup
*       (2) Must be called BEFORE any mthread requests are made
*
*Entry:
*       <NONE>
*Exit:
*       returns FALSE on failure
*
*Uses:
*       <any registers may be modified at init time>
*
*Exceptions:
*
*******************************************************************************/
#if defined(_NTSUBSET_)
#pragma BEGIN_NONPAGED_CODE
#endif

int __cdecl _mtinit (
        void
        )
{
        _ptiddata ptd;

#if defined(_NTSUBSET_)
        ptd = _newKernelTid();
#else

        /*
         * Initialize the mthread lock data base
         */

        if ( !_mtinitlocks() ) {
            _mtterm();
            return FALSE;       /* fail to load DLL */
        }

        /*
         * Allocate a TLS index to maintain pointers to per-thread data
         */
        if ( (__tlsindex = TlsAlloc()) == 0xffffffff ) {
            _mtterm();
            return FALSE;       /* fail to load DLL */
        }


        /*
         * Create a per-thread data structure for this (i.e., the startup)
         * thread.
         */
        if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL) ||
             !TlsSetValue(__tlsindex, (LPVOID)ptd) ) 
        {
            _mtterm();
            return FALSE;       /* fail to load DLL */
        }

        /*
         * Initialize the per-thread data
         */

        _initptd(ptd);

        ptd->_tid = GetCurrentThreadId();
        ptd->_thandle = (uintptr_t)(-1);

#endif /* _NTSUBSET_ */

        return TRUE;
}


/****
*_mtterm() - Clean-up multi-thread data bases
*
*Purpose:
*       (1) Call _mtdeletelocks to free up all lock semaphores.
*       (2) Free up the TLS index used to hold pointers to
*           per-thread data structure.
*
*       NOTES:
*       (1) Only to be called ONCE at termination
*       (2) Must be called AFTER all mthread requests are made
*
*Entry:
*       <NONE>
*Exit:
*       returns
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _mtterm (
        void
        )
{

#if defined(_NTSUBSET_)

        _freeKernelTid( PsGetCurrentThread()->OfsChain );
        PsGetCurrentThread()->OfsChain = 0;

#else   /* _NTSUBSET_ */

        /*
         * Clean up the mthread lock data base
         */

        _mtdeletelocks();

        /*
         * Free up the TLS index
         *
         * (Set the variable __tlsindex back to the unused state (-1L).)
         */

        if ( __tlsindex != 0xffffffff ) {
            TlsFree(__tlsindex);
            __tlsindex = 0xffffffff;
        }
#endif  /* _NTSUBSET_ */
}



#if !defined(_NTSUBSET_)

/***
*void _initptd(_ptiddata ptd) - initialize a per-thread data structure
*
*Purpose:
*       This routine handles all of the per-thread initialization
*       which is common to _beginthread, _beginthreadex, _mtinit
*       and _getptd.
*
*Entry:
*       pointer to a per-thread data block
*
*Exit:
*       the common fields in that block are initialized
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _initptd (
        _ptiddata ptd
        )
{
        ptd->_pxcptacttab = (void *)_XcptActTab;
        ptd->_holdrand = 1L;
#ifdef ANSI_NEW_HANDLER
        ptd->_newh = _defnewh;
#endif /* ANSI_NEW_HANDLER */

#ifdef _M_MRX000
        /*
         * MIPS per-thread data
         */
        ptd->_MipsPtdDelta =
        ptd->_MipsPtdEpsilon = -1L ;
#endif
}

#endif      /* _NTSUBSET_ */


/***
*_ptiddata _getptd(void) - get per-thread data structure for the current thread
*
*Purpose:
*
*Entry:
*       unsigned long tid
*
*Exit:
*       success = pointer to _tiddata structure for the thread
*       failure = fatal runtime exit
*
*Exceptions:
*
*******************************************************************************/

_ptiddata __cdecl _getptd (
        void
        )
{
        _ptiddata ptd;
        DWORD   TL_LastError;

#if defined(_NTSUBSET_)
        ptd = PsGetCurrentThread()->OfsChain;

        if ( ptd == 0 ) {
            ptd = _newKernelTid();
        }
#else   /* _NTSUBSET_ */

        TL_LastError = GetLastError();
        if ( (ptd = TlsGetValue(__tlsindex)) == NULL ) {
            /*
             * no per-thread data structure for this thread. try to create
             * one.
             */
            if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL) &&
                TlsSetValue(__tlsindex, (LPVOID)ptd) ) {

                /*
                 * Initialize of per-thread data
                 */

                _initptd(ptd);

                ptd->_tid = GetCurrentThreadId();
                ptd->_thandle = (uintptr_t)(-1);
            }
            else
                _amsg_exit(_RT_THREAD); /* write message and die */
            }

        SetLastError(TL_LastError);

#endif  /* _NTSUBSET_ */

        return(ptd);
}


/***
*void _freeptd(_ptiddata) - free up a per-thread data structure
*
*Purpose:
*       Called from _endthread and from a DLL thread detach handler,
*       this routine frees up the per-thread buffer associated with a
*       thread that is going away.  The tiddata structure itself is
*       freed, but not until its subordinate buffers are freed.
*
*Entry:
*       pointer to a per-thread data block (malloc-ed memory)
*       If NULL, the pointer for the current thread is fetched.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _freeptd (
        _ptiddata ptd
        )
{

#if defined(_NTSUBSET_)

        if ( 0 == ptd ) {
            ptd = PsGetCurrentThread()->OfsChain;
        } else {
            ASSERT( ptd == PsGetCurrentThread()->OfsChain );
        }

        _freeKernelTid( ptd );
        PsGetCurrentThread()->OfsChain = 0;

#else   /* _NTSUBSET_ */

        pthreadmbcinfo ptmbci;
        pthreadlocinfo ptloci;

        /*
         * Do nothing unless per-thread data has been allocated for this module!
         */

        if ( __tlsindex != 0xFFFFFFFF ) {
            /*
             * if parameter "ptd" is NULL, get the per-thread data pointer
             * Must NOT call _getptd because it will allocate one if none exists!
             */

            if ( ! ptd )
                ptd = TlsGetValue(__tlsindex );

            /*
             * Free up the _tiddata structure & its malloc-ed buffers.
             */

            if ( ptd ) {
                if(ptd->_errmsg)
                    _free_crt((void *)ptd->_errmsg);

                if(ptd->_namebuf0)
                    _free_crt((void *)ptd->_namebuf0);

                if(ptd->_namebuf1)
                    _free_crt((void *)ptd->_namebuf1);

                if(ptd->_asctimebuf)
                    _free_crt((void *)ptd->_asctimebuf);

                if(ptd->_gmtimebuf)
                    _free_crt((void *)ptd->_gmtimebuf);

                if(ptd->_cvtbuf)
                    _free_crt((void *)ptd->_cvtbuf);

                if (ptd->_pxcptacttab != _XcptActTab)
                    _free_crt((void *)ptd->_pxcptacttab);

                _mlock(_MB_CP_LOCK);
                __try {
                    if ( ((ptmbci = ptd->ptmbcinfo) != NULL) && 
                         (--(ptmbci->refcount) == 0) &&
                         (ptmbci != __ptmbcinfo) )
                        _free_crt(ptmbci);
                }
                __finally {
                    _munlock(_MB_CP_LOCK);
                }

                _mlock(_SETLOCALE_LOCK);

                __try {
                    if ( (ptloci = ptd->ptlocinfo) != NULL )
                    {
                        (ptloci->refcount)--;

                        if ( ptloci->lconv_intl_refcount != NULL )
                            (*(ptloci->lconv_intl_refcount))--;

                        if ( ptloci->lconv_mon_refcount != NULL )
                            (*(ptloci->lconv_mon_refcount))--;

                        if ( ptloci->lconv_num_refcount != NULL )
                            (*(ptloci->lconv_num_refcount))--;

                        if ( ptloci->ctype1_refcount != NULL )
                            (*(ptloci->ctype1_refcount))--;

                        (ptloci->lc_time_curr->refcount)--;

                        if ( (ptloci != __ptlocinfo) &&
                             (ptloci != &__initiallocinfo) &&
                             (ptloci->refcount == 0) )
                            __freetlocinfo(ptloci);
                    }
                }
                __finally {
                    _munlock(_SETLOCALE_LOCK);
                }

                _free_crt((void *)ptd);
            }

            /*
             * Zero out the one pointer to the per-thread data block
             */

            TlsSetValue(__tlsindex, (LPVOID)0);
        }

#endif  /* _NTSUBSET_ */

}

#if defined(_NTSUBSET_)
#pragma END_NONPAGED_CODE
#endif


/***
*__threadid()     - Returns current thread ID
*__threadhandle() - Returns "pseudo-handle" for current thread
*
*Purpose:
*       The two function are simply do-nothing wrappers for the corresponding
*       Win32 APIs (GetCurrentThreadId and GetCurrentThread, respectively).
*
*Entry:
*       void
*
*Exit:
*       thread ID value
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP unsigned long __cdecl __threadid (
        void
        )
{
#if defined(_NTSUBSET_)
        return( (unsigned long) (uintptr_t) PsGetCurrentThread()->Cid.UniqueThread );
#else
        return( GetCurrentThreadId() );
#endif
}

_CRTIMP uintptr_t __cdecl __threadhandle(
        void
        )
{
#if defined(_NTSUBSET_)
        return( (uintptr_t) PsGetCurrentThread()->Cid.UniqueThread );
#else
        return( (uintptr_t)GetCurrentThread() );
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\mlock.c ===
/***
*mlock.c - Multi-thread locking routines
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-07-90  JCR   Module created.
*       06-04-90  GJF   Changed error message interface.
*       08-08-90  GJF   Removed 32 from API names.
*       08-08-90  SBM   _lockmap no longer 8 times required size
*       10-08-90  GJF   New-style function declarators. Removed questionable
*                       return statements from void functions (weren't needed
*                       and the compiler was bitching).
*       10-09-90  GJF   Thread ids are unsigned longs.
*       06-06-91  GJF   Adapted for Win32 [_WIN32_].
*       09-29-91  GJF   Fixed infinite recursion problem with DEBUG version
*                       of _lock [_WIN32_].
*       03-06-92  GJF   Removed _[un]lock_fh() and _[un]lock_stream for Win32
*                       targets.
*       05-28-92  GJF   Added _mtdeletelocks() for Win32 for DLLs with contain
*                       the C runtime (e.g., crtdll.dll).
*       10-06-92  SRW   Make _locktable an array of PCRITICAL_SECTION pointers
*                       instead of structures.  Allocate each critical section
*                       as it is needed.
*       02-25-93  GJF   Substantially revised. Restored static critical section
*                       structures for some locks. Replaced bit-array scheme
*                       of keeping track of locks. Removed Cruiser support and
*                       replaced obsolete DEBUG code.
*       03-03-93  GJF   Made CRITICAL_SECTION structure for _HEAP_LOCK static.
*       03-08-93  SKS   Fix ptr use error in DEBUG version of _mtdeletelocks
*       03-08-93  SKS   Fix deletion of the special critical sections,
*                       especially the heap lock.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-05-93  GJF   Turned DEBUG code off.
*       06-03-93  SRW   Disable FPO optimizations for this file so it can call
*                       CriticalSection routines on a checked build even though
*                       the C Runtimes are compiled free.
*       10-19-93  GJF   Merged in NT SDK version. Enclosed #pragma-s in
*                       #ifdef _M_IX86 / #endif. Replaced MTHREAD with _MT.
*       04-12-94  GJF   Made into empty functions for the Win32s version of
*                       msvcrt*.dll.
*       01-10-95  CFW   Debug CRT allocs.
*       01-30-95  GJF   Made CRITICAL_SECTION structure for _SIGNAL_LOCK
*                       static.
*       03-06-95  GJF   Added _[un]lock_file[2] to lock stdio files (__piob[]
*                       entries).
*       03-23-95  BWT   Store the critsec in the locktable *after* it's
*                       initialized.
*       10-03-95  GJF   Added comments to the effect that the _LC_*_LOCK
*                       locks are obsolete.
*       11-15-95  JWM   Correct syntax error in 2nd '#pragma optimize()'.
*       06-19-97  GJF   Moved _[un]lock_file[2]() to stdio\_file.c to improve 
*                       granularity.
*       05-13-99  PML   Remove Win32s
*       10-14-99  PML   Replace InitializeCriticalSection with wrapper function
*                       __crtInitCritSecAndSpinCount
*       12-10-99  GB    Added a new Lock _UNDNAME_LOCK for critical section in
*                       unDName().
*       03-06-00  PML   Call __crtExitProcess instead of ExitProcess.
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       03-07-01  PML   vs7#221122 Release preallocated locks after heap ones,
*                       so _HEAP_LOCK is around while we're still freeing mem.
*       03-22-01  PML   Add _DEBUG_LOCK for _CrtSetReportHook2 (vs7#124998)
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <rterr.h>
#include <stddef.h>
#include <malloc.h>
#include <limits.h>
#include <stdio.h>
#include <dbgint.h>
#include <errno.h>


/*
 * Local routines
 */
void __cdecl _lockerr_exit(char *);


/*
 * Global Data
 */

/*
 * Statically allocated critical section structures for all preallocated locks.
 * These are most of the named locks before _STREAM_LOCKS, along with the locks
 * for stdin/stdout/stderr.  These must be preallocated so we do not hit fatal
 * memory conditions on failing to initialize a critical section, except at
 * runtime startup, since these locks may be taken where we have no good way
 * to return a non-fatal error.
 */
#define NUM_STD_FILE_LOCKS     3
#define NUM_NON_PREALLOC_LOCKS 5
#define NUM_PREALLOC_LOCKS \
        ( _STREAM_LOCKS + NUM_STD_FILE_LOCKS - NUM_NON_PREALLOC_LOCKS )
static CRITICAL_SECTION lclcritsects[NUM_PREALLOC_LOCKS];

/*
 * Lock Table
 * This table contains a pointer to the critical section management structure
 * for each lock.
 *
 * Locks marked lkPrealloc have their critical sections statically allocated
 * and initialized at startup in _mtinitlocks.  Locks marked lkNormal must
 * be allocated when first used, via a call to _mtinitlocknum.
 */
static struct {
        PCRITICAL_SECTION lock;
        enum { lkNormal = 0, lkPrealloc, lkDeleted } kind;
} _locktable[_TOTAL_LOCKS] = {
        { NULL, lkPrealloc }, /* 0  == _SIGNAL_LOCK      */
        { NULL, lkPrealloc }, /* 1  == _IOB_SCAN_LOCK    */
        { NULL, lkNormal   }, /* 2  == _TMPNAM_LOCK      - not preallocated */
        { NULL, lkPrealloc }, /* 3  == _CONIO_LOCK       */
        { NULL, lkPrealloc }, /* 4  == _HEAP_LOCK        */
        { NULL, lkNormal   }, /* 5  == _UNDNAME_LOCK     - not preallocated */
        { NULL, lkPrealloc }, /* 6  == _TIME_LOCK        */
        { NULL, lkPrealloc }, /* 7  == _ENV_LOCK         */
        { NULL, lkPrealloc }, /* 8  == _EXIT_LOCK1       */
        { NULL, lkNormal   }, /* 9  == _POPEN_LOCK       - not preallocated */
        { NULL, lkPrealloc }, /* 10 == _LOCKTAB_LOCK     */
        { NULL, lkNormal   }, /* 11 == _OSFHND_LOCK      - not preallocated */
        { NULL, lkPrealloc }, /* 12 == _SETLOCALE_LOCK   */
        { NULL, lkPrealloc }, /* 13 == _MB_CP_LOCK       */
        { NULL, lkPrealloc }, /* 14 == _TYPEINFO_LOCK    */
        { NULL, lkNormal   }, /* 15 == _DEBUG_LOCK       - not preallocated */
        { NULL, lkPrealloc }, /* 16 == _STREAM_LOCKS+0 - stdin  */
        { NULL, lkPrealloc }, /* 17 == _STREAM_LOCKS+1 - stdout */
        { NULL, lkPrealloc }, /* 18 == _STREAM_LOCKS+2 - stderr */
/*      { NULL, lkNormal   }, /* ... */
};

#ifndef NT_BUILD
#ifdef  _M_IX86
#pragma optimize("y",off)
#endif
#endif

/***
*_mtinitlocks() - Initialize multi-thread lock scheme
*
*Purpose:
*       Perform whatever initialization is required for the multi-thread
*       locking (synchronization) scheme. This routine should be called
*       exactly once, during startup, and this must be before any requests
*       are made to assert locks.
*
*       NOTES: In Win32, the multi-thread locks are created individually,
*       each upon its first use. That is when any particular lock is asserted
*       for the first time, the underlying critical section is then allocated,
*       initialized and (finally) entered. This allocation and initialization
*       is protected under _LOCKTAB_LOCK. It is _mtinitlocks' job to set up
*       _LOCKTAB_LOCK.
*
*       All other named (non-FILE) locks are also preallocated in _mtinitlocks.
*       That is because a failure to allocate a lock on its first use in _lock
*       triggers a fatal error, which cannot be permitted since that can bring
*       down a long-lived app without warning.
*
*Entry:
*       <none>
*
*Exit:
*       returns FALSE on failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocks (
        void
        )
{
        int locknum;
        int idxPrealloc = 0;

        /*
         * Scan _locktable[] and allocate all entries marked lkPrealloc.
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
#ifdef  DEBUG
            if ( _locktable[locknum].lock != NULL )
                _lockerr_exit("fatal error in _mtinitlocks #1\n");
#endif  /* DEBUG */
            if ( _locktable[locknum].kind == lkPrealloc ) {
                _locktable[locknum].lock = &lclcritsects[idxPrealloc++];
                if ( !__crtInitCritSecAndSpinCount( _locktable[locknum].lock,
                                                    _CRT_SPINCOUNT )) 
                {
                    _locktable[locknum].lock = NULL;
                    return FALSE;
                }
            }
        }

#ifdef  DEBUG
        if ( idxPrealloc != NUM_PREALLOC_LOCKS )
            _lockerr_exit("fatal error in _mtinitlocks #2\n");
#endif  /* DEBUG */

        return TRUE;
}


/***
*_mtdeletelocks() - Delete all initialized locks
*
*Purpose:
*       Walks _locktable[] and _lockmap, and deletes every 'lock' (i.e.,
*       critical section) which has been initialized.
*
*       This function is intended for use in DLLs containing the C runtime
*       (i.e., crtdll.dll and user DLLs built using libcmt.lib and the
*       special startup objects). It is to be called from within the DLL's
*       entrypoint function when that function is called with
*       DLL_PROCESS_DETACH.
*
*Entry:
*       <none>
*
*Exit:
*
*Exceptions:
*       behavior undefined/unknown if a lock is being held when this routine
*       is called.
*
*******************************************************************************/

void __cdecl _mtdeletelocks(
        void
        )
{
        int locknum;

        /*
         * Delete and free all normal locks that have been created.
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].lock != NULL &&
                 _locktable[locknum].kind != lkPrealloc )
            {
                PCRITICAL_SECTION pcs = _locktable[locknum].lock;

                DeleteCriticalSection(pcs);

                /*
                 * Free the memory for the CritSect after deleting it.
                 */
#ifdef  DEBUG
                /* check that it's an undeleted normal lock */
                if ( _locktable[locknum].kind != lkNormal )
                    _lockerr_exit("fatal error in _mtdeletelocks #1\n");

                /* mark as deleted */
                _locktable[locknum].kind = lkDeleted;
#endif  /* DEBUG */

                _free_crt(pcs);
                _locktable[locknum].lock = NULL;
            }
        }

        /*
         * Delete all preallocated locks after all normal ones are
         * freed (so preallocated _HEAP_LOCK outlives all heap usages).
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].lock != NULL &&
                 _locktable[locknum].kind == lkPrealloc )
            {
                PCRITICAL_SECTION pcs = _locktable[locknum].lock;

                DeleteCriticalSection(pcs);
            }
        }
}

/***
* _mtinitlocknum - Allocate a non-preallocated multi-thread lock
*
*Purpose:
*       Allocate a new, non-preallocated multi-thread lock.  This should be
*       used whenever a new lock is known to be needed, so that failure to
*       allocate can return an error, instead of allowing _lock() to issue
*       a fatal _RT_LOCK instead.
*
*       It is not an error to call this on a normal lock which has already
*       been allocated.  It is used to ensure that certain named locks which
*       are not preallocated are available.
*
*       It is also called by _lock, in case any other paths exist which call
*       _lock without calling _mtinitlocknum first.  This is not expected,
*       and can allow fatal _RT_LOCK errors to be issued.
*
*       Since a failure sets errno to ENOMEM, this should only be called
*       after the per-thread data has been set up (after _mtinit).
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*       Returns FALSE on failure, and sets errno to ENOMEM.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocknum (
        int locknum
        )
{
        PCRITICAL_SECTION pcs;

#ifdef  DEBUG
        if ( _locktable[locknum].kind != lkNormal )
            _lockerr_exit("fatal error in _mtinitlocknum #1\n");
#endif  /* DEBUG */

        if ( _locktable[locknum].lock != NULL )
            return TRUE;

        if ( (pcs = _malloc_crt(sizeof(CRITICAL_SECTION))) == NULL ) {
            errno = ENOMEM;
            return FALSE;
        }

        _mlock(_LOCKTAB_LOCK);

        if ( _locktable[locknum].lock == NULL ) {
            if ( !__crtInitCritSecAndSpinCount(pcs, _CRT_SPINCOUNT) ) {
                _free_crt(pcs);
                _munlock(_LOCKTAB_LOCK);
                errno = ENOMEM;
                return FALSE;
            }
            _locktable[locknum].lock = pcs;
        }
        else {
            _free_crt(pcs);
        }

        _munlock(_LOCKTAB_LOCK);

        return TRUE;
}


/***
* _lock - Acquire a multi-thread lock
*
*Purpose:
*       Acquire a multi-thread lock.  If the lock has not already been
*       allocated, do so, but that is an internal CRT error, since all locks
*       should be allocated before first being acquired, either in
*       _mtinitlocks or individually in _mtinitlocknum.
*
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*
*Exceptions:
*       A failure to allocate a new lock results in a fatal _RT_LOCK error.
*
*******************************************************************************/

void __cdecl _lock (
        int locknum
        )
{
#ifdef  DEBUG
        if ( _locktable[locknum].kind != lkNormal &&
             _locktable[locknum].kind != lkPrealloc )
            _lockerr_exit("fatal error in _lock #1\n");
#endif  /* DEBUG */

        /*
         * Create/open the lock, if necessary
         */
        if ( _locktable[locknum].lock == NULL ) {
#ifdef  DEBUG
            if ( _locktable[locknum].kind != lkNormal )
                _lockerr_exit("fatal error in _lock #2\n");

            /*
             * All locks should be allocated before first being acquired.
             * Failure to do so is an internal CRT error, which we silently
             * allow in a production CRT, but that can lead to fatal _RT_LOCK
             * errors which result in an ExitProcess call.
             */
            _lockerr_exit("fatal error in _lock #3\n");
#endif  /* DEBUG */

            if ( !_mtinitlocknum(locknum) )
                _amsg_exit( _RT_LOCK );
        }

        /*
         * Enter the critical section.
         */

        EnterCriticalSection( _locktable[locknum].lock );
}


/***
* _unlock - Release multi-thread lock
*
*Purpose:
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to release
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock (
        int locknum
        )
{
        /*
         * leave the critical section.
         */
        LeaveCriticalSection( _locktable[locknum].lock );
}


#ifndef NT_BUILD
#ifdef  _M_IX86
#pragma optimize("y",on)
#endif
#endif

/***
*_lockerr_exit() - Write error message and die
*
*Purpose:
*       Attempt to write out the unexpected lock error message, then terminate
*       the program by a direct API call.  This function is used in place of
*       amsg_exit(_RT_LOCK) when it is judged unsafe to allow further lock
*       or unlock calls.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lockerr_exit (
        char *msg
        )
{
        FatalAppExit(0, msg);       /* Die with message box */
        __crtExitProcess(255);      /* Just die */
}


#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\threadex.c ===
/***
*threadex.c - Extended versions of Begin (Create) and End (Exit) a Thread
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This source contains the _beginthreadex() and _endthreadex()
*       routines which are used to start and terminate a thread.  These
*       routines are more like the Win32 APIs CreateThread() and ExitThread() 
*       than the original functions _beginthread() & _endthread() were.
*
*Revision History:
*       02-16-94  SKS   Original version, based on thread.c which contains
*                       _beginthread() and _endthread().
*       02-17-94  SKS   Changed error return from -1 to 0, fix some comments.
*       06-10-94  SKS   Pass the thrdaddr value directly to CreateThread().
*                       Do *NOT* store the thread handle into the per-thread
*                       data block of the child thread.  (It is not needed.)
*                       The thread data structure may have been freed by the
*                       child thread before the parent thread returns from the
*                       call to CreateThread().  Watch that synchronization!
*       01-10-95  CFW   Debug CRT allocs.
*       04-18-95  SKS   Add 5 MIPS per-thread variables.
*       05-02-95  SKS   Call _initptd for initialization of per-thread data.
*       02-03-98  GJF   Changes for Win64: use uintptr_t type for anything with
*                       a HANDLE value.
*       02-02-00  GB    Modified threadstartex() to prevent leaking of ptd
*                       allocated during call to getptd while ATTACHing THREAD 
*                       in dlls.
*       05-31-00  PML   Don't pass NULL thrdaddr into CreateThread, since a
*                       non-NULL lpThreadId is required on Win9x.
*       08-04-00  PML   Set EINVAL error if thread start address null in
*                       _beginthreadex (VS7#118688).
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <malloc.h>
#include <process.h>
#include <stddef.h>
#include <rterr.h>
#include <dbgint.h>
#include <errno.h>

/*
 * Startup code for new thread.
 */
static unsigned long WINAPI _threadstartex(void *);

/*
 * declare pointers to per-thread FP initialization and termination routines
 */
_PVFV _FPmtinit;
_PVFV _FPmtterm;


/***
*_beginthreadex() - Create a child thread
*
*Purpose:
*       Create a child thread.
*
*Entry:
*       *** Same parameters as the Win32 API CreateThread() ***
*       security = security descriptor for the new thread
*       stacksize = size of stack
*       initialcode = pointer to thread's startup code address
*               must be a __stdcall function returning an unsigned.
*       argument = argument to be passed to new thread
*       createflag = flag to create thread in a suspended state
*       thrdaddr = points to an int to receive the ID of the new thread
*
*Exit:
*       *** Same as the Win32 API CreateThread() ***
*
*       success = handle for new thread if successful
*
*       failure = 0 in case of error, errno and _doserrno are set
*
*Exceptions:
*
*Notes:
*       This routine is more like the Win32 API CreateThread() than it
*       is like the C run-time routine _beginthread().  Ditto for
*       _endthreadex() and the Win32 API ExitThread() versus _endthread().
*
*       Differences between _beginthread/_endthread and the "ex" versions:
*
*         1)  _beginthreadex takes the 3 extra parameters to CreateThread
*             which are lacking in _beginthread():
*               A) security descriptor for the new thread
*               B) initial thread state (running/asleep)
*               C) pointer to return ID of newly created thread
*
*         2)  The routine passed to _beginthread() must be __cdecl and has
*             no return code, but the routine passed to _beginthreadex()
*             must be __stdcall and returns a thread exit code.  _endthread
*             likewise takes no parameter and calls ExitThread() with a
*             parameter of zero, but _endthreadex() takes a parameter as
*             thread exit code.
*
*         3)  _endthread implicitly closes the handle to the thread, but
*             _endthreadex does not!
*
*         4)  _beginthread returns -1 for failure, _beginthreadex returns
*             0 for failure (just like CreateThread).
*
*******************************************************************************/

uintptr_t __cdecl _beginthreadex (
        void *security,
        unsigned stacksize,
        unsigned (__stdcall * initialcode) (void *),
        void * argument,
        unsigned createflag,
        unsigned *thrdaddr
        )
{
        _ptiddata ptd;                  /* pointer to per-thread data */
        uintptr_t thdl;                 /* thread handle */
        unsigned long errcode = 0L;     /* Return from GetLastError() */
        unsigned dummyid;               /* dummy returned thread ID */

        if ( initialcode == NULL ) {
            errno = EINVAL;
            return( (uintptr_t)0 );
        }

        /*
         * Allocate and initialize a per-thread data structure for the to-
         * be-created thread.
         */
        if ( (ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL )
                goto error_return;

        /*
         * Initialize the per-thread data
         */

        _initptd(ptd);

        ptd->_initaddr = (void *) initialcode;
        ptd->_initarg = argument;
        ptd->_thandle = (uintptr_t)(-1);

        /*
         * Make sure non-NULL thrdaddr is passed to CreateThread
         */
        if ( thrdaddr == NULL )
                thrdaddr = &dummyid;

        /*
         * Create the new thread using the parameters supplied by the caller.
         */
        if ( (thdl = (uintptr_t)
              CreateThread( security,
                            stacksize,
                            _threadstartex,
                            (LPVOID)ptd,
                            createflag,
                            thrdaddr))
             == (uintptr_t)0 )
        {
                errcode = GetLastError();
                goto error_return;
        }

        /*
         * Good return
         */
        return(thdl);

        /*
         * Error return
         */
error_return:
        /*
         * Either ptd is NULL, or it points to the no-longer-necessary block
         * calloc-ed for the _tiddata struct which should now be freed up.
         */
        _free_crt(ptd);

        /*
         * Map the error, if necessary.
         *
         * Note: this routine returns 0 for failure, just like the Win32
         * API CreateThread, but _beginthread() returns -1 for failure.
         */
        if ( errcode != 0L )
                _dosmaperr(errcode);

        return( (uintptr_t)0 );
}


/***
*_threadstartex() - New thread begins here
*
*Purpose:
*       The new thread begins execution here.  This routine, in turn,
*       passes control to the user's code.
*
*Entry:
*       void *ptd       = pointer to _tiddata structure for this thread
*
*Exit:
*       Never returns - terminates thread!
*
*Exceptions:
*
*******************************************************************************/

static unsigned long WINAPI _threadstartex (
        void * ptd
        )
{
        _ptiddata _ptd;                  /* pointer to per-thread data */
        
        /* 
         * Check if ptd is initialised during THREAD_ATTACH call to dll mains
         */
        if ( ( _ptd = TlsGetValue(__tlsindex)) == NULL)
        {
            /*
             * Stash the pointer to the per-thread data stucture in TLS
             */
            if ( !TlsSetValue(__tlsindex, ptd) )
                _amsg_exit(_RT_THREAD);
            /*
             * Set the thread ID field -- parent thread cannot set it after
             * CreateThread() returns since the child thread might have run
             * to completion and already freed its per-thread data block!
             */
            ((_ptiddata) ptd)->_tid = GetCurrentThreadId();
        }
        else
        {
            _ptd->_initaddr = ((_ptiddata) ptd)->_initaddr;
            _ptd->_initarg =  ((_ptiddata) ptd)->_initarg;
            _free_crt(ptd);
            ptd = _ptd;
        }


        /*
         * Call fp initialization, if necessary
         */
        if ( _FPmtinit != NULL )
                (*_FPmtinit)();

        /*
         * Guard call to user code with a _try - _except statement to
         * implement runtime errors and signal support
         */
        __try {
                _endthreadex ( 
                    ( (unsigned (WINAPI *)(void *))(((_ptiddata)ptd)->_initaddr) )
                    ( ((_ptiddata)ptd)->_initarg ) ) ;
        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
                /*
                 * Should never reach here
                 */
                _exit( GetExceptionCode() );

        } /* end of _try - _except */

        /*
         * Never executed!
         */
        return(0L);
}


/***
*_endthreadex() - Terminate the calling thread
*
*Purpose:
*
*Entry:
*       Thread exit code
*
*Exit:
*       Never returns!
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _endthreadex (
        unsigned retcode
        )
{
        _ptiddata ptd;           /* pointer to thread's _tiddata struct */

        /*
         * Call fp termination, if necessary
         */
        if ( _FPmtterm != NULL )
                (*_FPmtterm)();

        if ( (ptd = _getptd()) == NULL )
                _amsg_exit(_RT_THREAD);

        /*
         * Free up the _tiddata structure & its subordinate buffers
         *      _freeptd() will also clear the value for this thread
         *      of the TLS variable __tlsindex.
         */
        _freeptd(ptd);

        /*
         * Terminate the thread
         */
        ExitThread(retcode);

}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\stdargv.c ===
/***
*stdargv.c - standard & wildcard _setargv routine
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line, with or without wildcard expansion
*
*Revision History:
*       06-27-89  PHG   module created, based on asm version
*       04-09-90  GJF   Added #include <cruntime.h>. Made calling types
*                       explicit (_CALLTYPE1 or _CALLTYPE4). Also, fixed the
*                       copyright.
*       06-04-90  GJF   Changed error message interface.
*       08-31-90  GJF   Removed 32 from API names.
*       09-25-90  GJF   Merged tree version with local version (8-31 change
*                       with 6-4 change).
*       10-08-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-25-91  SRW   Include oscalls.h if _WIN32_ OR WILDCARD defined
*       01-25-91  SRW   Changed Win32 Process Startup [_WIN32_]
*       01-25-91  MHL   Fixed bug in Win32 Process Startup [_WIN32_]
*       01-28-91  GJF   Fixed call to DOSFINDFIRST (removed last arg).
*       01-31-91  MHL   Changed to call GetModuleFileName instead of
*                       NtCurrentPeb() [_WIN32_]
*       02-18-91  SRW   Fixed command line parsing bug [_WIN32_]
*       03-11-91  GJF   Fixed check of FindFirstFile return [_WIN32_].
*       03-12-91  SRW   Add FindClose call to _find [_WIN32_]
*       04-16-91  SRW   Fixed quote parsing logic for arguments.
*       03-31-92  DJM   POSIX support.
*       05-12-92  DJM   ifndefed for POSIX.
*       06-02-92  SKS   Add #include <dos.h> for CRTDLL definition of _pgmptr
*       04-19-93  GJF   Change test in the do-while loop in parse_cmdline to
*                       NOT terminate on chars with high bit set.
*       05-14-93  GJF   Added support for quoted program names.
*       05-28-93  KRS   Added MBCS support under _MBCS switches.
*       06-04-93  KRS   Added more MBCS logic.
*       11-17-93  CFW   Rip out Cruiser.
*       11-19-93  CFW   Gratuitous whitespace cleanup.
*       11-20-93  CFW   Enable wide char, move _find to wild.c.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       04-15-94  GJF   Made definition of _pgmname conditional on
*                       DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       06-30-97  GJF   Added explicit, conditional init. of multibyte ctype
*                       table. Also, detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*       09-05-00  GB    Fixed parse_cmdline to return "c:\test\"foo.c as one
*                       argument.
*       09-07-00  GB    Fixed parse_cmdline to del double quotes in
*                       c:"\test\"foo.c.
*       03-24-01  PML   Protect against null _[aw]cmdln (vs7#229081)
*       03-27-01  PML   Return error instead of calling amsg_exit (vs7#231220)
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>
#include <dos.h>
#include <oscalls.h>
#ifdef  _MBCS
#include <mbctype.h>
#endif
#include <tchar.h>
#include <dbgint.h>

#define NULCHAR    _T('\0')
#define SPACECHAR  _T(' ')
#define TABCHAR    _T('\t')
#define DQUOTECHAR _T('\"')
#define SLASHCHAR  _T('\\')

/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

#ifdef  WPRFLAG
static void __cdecl wparse_cmdline(wchar_t *cmdstart, wchar_t **argv, wchar_t *args,
        int *numargs, int *numchars);
#else
static void __cdecl parse_cmdline(char *cmdstart, char **argv, char *args,
        int *numargs, int *numchars);
#endif

/***
*_setargv, __setargv - set up "argc" and "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line,
*       pointed to by _acmdln.
*
*Exit:
*       Returns 0 if successful, -1 if memory allocation failed.
*       "argv" points to a null-terminated list of pointers to ASCIZ
*       strings, each of which is an argument from the command line.
*       "argc" is the number of arguments.  The strings are copied from
*       the environment segment into space allocated on the heap/stack.
*       The list of pointers is also located on the heap or stack.
*       _pgmptr points to the program name.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

#ifdef  WILDCARD

#ifdef  WPRFLAG
int __cdecl __wsetargv (
#else
int __cdecl __setargv (
#endif  /* WPRFLAG */

#else   /* WILDCARD */

#ifdef  WPRFLAG
int __cdecl _wsetargv (
#else
int __cdecl _setargv (
#endif  /* WPRFLAG */

#endif  /* WILDCARD */
    void
    )
{
        _TSCHAR *p;
        _TSCHAR *cmdstart;                  /* start of command line to parse */
        int numargs, numchars;

        static _TSCHAR _pgmname[ MAX_PATH + 1 ];

#if     !defined(CRTDLL) && defined(_MBCS)
        /* If necessary, initialize the multibyte ctype table. */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif

        /* Get the program name pointer from Win32 Base */

        _pgmname[ MAX_PATH ] = '\0';
        GetModuleFileName( NULL, _pgmname, MAX_PATH );
#ifdef  WPRFLAG
        _wpgmptr = _pgmname;
#else
        _pgmptr = _pgmname;
#endif

        /* if there's no command line at all (won't happen from cmd.exe, but
           possibly another program), then we use _pgmptr as the command line
           to parse, so that argv[0] is initialized to the program name */

#ifdef  WPRFLAG
        cmdstart = (_wcmdln == NULL || *_wcmdln == NULCHAR)
                   ? _wpgmptr : _wcmdln;
#else
        cmdstart = (_acmdln == NULL || *_acmdln == NULCHAR)
                   ? _pgmptr : _acmdln;
#endif

        /* first find out how much space is needed to store args */
#ifdef  WPRFLAG
        wparse_cmdline(cmdstart, NULL, NULL, &numargs, &numchars);
#else
        parse_cmdline(cmdstart, NULL, NULL, &numargs, &numchars);
#endif

        /* allocate space for argv[] vector and strings */
        p = _malloc_crt(numargs * sizeof(_TSCHAR *) + numchars * sizeof(_TSCHAR));
        if (p == NULL)
            return -1;

        /* store args and argv ptrs in just allocated block */

#ifdef  WPRFLAG
        wparse_cmdline(cmdstart, (wchar_t **)p, (wchar_t *)(((char *)p) + numargs * sizeof(wchar_t *)), &numargs, &numchars);
#else
        parse_cmdline(cmdstart, (char **)p, p + numargs * sizeof(char *), &numargs, &numchars);
#endif

        /* set argv and argc */
        __argc = numargs - 1;
#ifdef  WPRFLAG
        __wargv = (wchar_t **)p;
#else
        __argv = (char **)p;
#endif /* WPRFLAG */

#ifdef  WILDCARD

        /* call _[w]cwild to expand wildcards in arg vector */
#ifdef  WPRFLAG
        if (_wcwild())
#else   /* WPRFLAG */
        if (_cwild())
#endif  /* WPRFLAG */
            return -1;                  /* out of space */

#endif  /* WILDCARD */

        return 0;
}


/***
*static void parse_cmdline(cmdstart, argv, args, numargs, numchars)
*
*Purpose:
*       Parses the command line and sets up the argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, args
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only coujting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numchars has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       _TSCHAR *cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       _TSCHAR **argv - where to build argv array; NULL means don't
*                       build array
*       _TSCHAR *args - where to place argument text; NULL means don't
*                       store text
*
*Exit:
*       no return value
*       int *numargs - returns number of argv entries created
*       int *numchars - number of characters used in args buffer
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
static void __cdecl wparse_cmdline (
#else
static void __cdecl parse_cmdline (
#endif
    _TSCHAR *cmdstart,
    _TSCHAR **argv,
    _TSCHAR *args,
    int *numargs,
    int *numchars
    )
{
        _TSCHAR *p;
        _TUCHAR c;
        int inquote;                    /* 1 = inside quotes */
        int copychar;                   /* 1 = copy char to *args */
        unsigned numslash;              /* num of backslashes seen */

        *numchars = 0;
        *numargs = 1;                   /* the program name at least */

        /* first scan the program name, copy it, and count the bytes */
        p = cmdstart;
        if (argv)
            *argv++ = args;

#ifdef  WILDCARD
        /* To handle later wild card expansion, we prefix each entry by
        it's first character before quote handling.  This is done
        so _[w]cwild() knows whether to expand an entry or not. */
        if (args)
            *args++ = *p;
        ++*numchars;

#endif  /* WILDCARD */

        /* A quoted program name is handled here. The handling is much
           simpler than for other arguments. Basically, whatever lies
           between the leading double-quote and next one, or a terminal null
           character is simply accepted. Fancier handling is not required
           because the program name must be a legal NTFS/HPFS file name.
           Note that the double-quote characters are not copied, nor do they
           contribute to numchars. */
        inquote = FALSE;
        do {
            if (*p == DQUOTECHAR )
            {
                inquote = !inquote;
                c = (_TUCHAR) *p++;
                continue;
            }
            ++*numchars;
            if (args)
                *args++ = *p;

            c = (_TUCHAR) *p++;
#ifdef  _MBCS
            if (_ismbblead(c)) {
                ++*numchars;
                if (args)
                    *args++ = *p;   /* copy 2nd byte too */
                p++;  /* skip over trail byte */
            }
#endif

        } while ( (c != NULCHAR && (inquote || (c !=SPACECHAR && c != TABCHAR))) );

        if ( c == NULCHAR ) {
            p--;
        } else {
            if (args)
                *(args-1) = NULCHAR;
        }

        inquote = 0;

        /* loop on each argument */
        for(;;) {

            if ( *p ) {
                while (*p == SPACECHAR || *p == TABCHAR)
                    ++p;
            }

            if (*p == NULCHAR)
                break;              /* end of args */

            /* scan an argument */
            if (argv)
                *argv++ = args;     /* store ptr to arg */
            ++*numargs;

#ifdef  WILDCARD
        /* To handle later wild card expansion, we prefix each entry by
        it's first character before quote handling.  This is done
        so _[w]cwild() knows whether to expand an entry or not. */
        if (args)
            *args++ = *p;
        ++*numchars;

#endif  /* WILDCARD */

        /* loop through scanning one argument */
        for (;;) {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
               2N+1 backslashes + " ==> N backslashes + literal "
               N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == SLASHCHAR) {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == DQUOTECHAR) {
                /* if 2N backslashes before, start/end quote, otherwise
                    copy literally */
                if (numslash % 2 == 0) {
                    if (inquote) {
                        if (p[1] == DQUOTECHAR)
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    } else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--) {
                if (args)
                    *args++ = SLASHCHAR;
                ++*numchars;
            }

            /* if at end of arg, break loop */
            if (*p == NULCHAR || (!inquote && (*p == SPACECHAR || *p == TABCHAR)))
                break;

            /* copy character into argument */
#ifdef  _MBCS
            if (copychar) {
                if (args) {
                    if (_ismbblead(*p)) {
                        *args++ = *p++;
                        ++*numchars;
                    }
                    *args++ = *p;
                } else {
                    if (_ismbblead(*p)) {
                        ++p;
                        ++*numchars;
                    }
                }   
                ++*numchars;
            }
            ++p;
#else 
            if (copychar) {
                if (args)
                    *args++ = *p;
                ++*numchars;
            }
            ++p;
#endif 
            }

            /* null-terminate the argument */

            if (args)
                *args++ = NULCHAR;          /* terminate string */
            ++*numchars;
        }

        /* We put one last argument in -- a null ptr */
        if (argv)
            *argv++ = NULL;
        ++*numargs;
}


#endif  /* ndef _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\stdenvp.c ===
/***
*stdenvp.c - standard _setenvp routine
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module is called by the C start-up routine to set up "_environ".
*       Its sets up an array of pointers to strings in the environment.
*       The global symbol "_environ" is set to point to this array.
*
*Revision History:
*       11-07-84  GFW   initial version
*       01-08-86  SKS   Modified for OS/2
*       05-21-86  SKS   Call _stdalloc to get memory for strings
*       09-04-86  SKS   Added check to skip the "*C_FILE_INFO" string
*       10-21-86  SKS   Improved check for "*C_FILE_INFO"/"_C_FILE_INFO"
*       02-19-88  SKS   Handle case where environment starts with a single null
*       05-10-88  JCR   Modified code to accept far pointer from _stdalloc
*       06-01-88  PHG   Merged DLL and normal versions
*       07-12-88  JCR   Largely re-written: (1) split mem allocation into two
*                       seperate malloc() calls to help simplify putenv(),
*                       (2) stdalloc() no longer robs from stack, (3) cProc/cEnd
*                       sequence, (4) misc cleanup
*       09-20-88  WAJ   Initial 386 version
*       12-13-88  JCR   Use rterr.inc parameters for runtime errors
*       04-09-90  GJF   Added #include <cruntime.h>. Made the calling type
*                       _CALLTYPE1. Also, fixed the copyright and cleaned up
*                       up the formatting a bit.
*       06-05-90  GJF   Changed error message interface.
*       10-08-90  GJF   New-style function declarator.
*       10-31-90  GJF   Fixed statement appending the final NULL (Stevewo
*                       found the bug).
*       12-11-90  SRW   Changed to include <oscalls.h> and setup _environ
*                       correctly for Win32
*       01-21-91  GJF   ANSI naming.
*       02-07-91  SRW   Change _WIN32_ specific code to allocate static copy
*       02-18-91  SRW   Change _WIN32_ specific code to allocate copy of
*                       variable strings as well [_WIN32_]
*       07-25-91  GJF   Changed strupr to _strupr.
*       03-31-92  DJM   POSIX support.
*       04-20-92  GJF   Removed conversion to upper-case code for Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-24-93  CFW   Rip out Cruiser and filter out "=c:\foo" type.
*       11-29-93  CFW   Remove unused POSIX stuff, wide char enable.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       01-10-95  CFW   Debug CRT allocs.
*       04-07-95  CFW   Free environment block on demand.
*       07-03-95  GJF   Always free environment block.
*       02-20-96  SKS   Set _aenvptr/_wenvptr to NULL after freeing what it
*                       points to (a copy of environment strings).
*       06-30-97  GJF   Added explicit, conditional init. of the mbctype table.
*                       Set __env_initialized flag. Also detab-ed.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       03-05-01  PML   Don't AV if _aenvptr is NULL (vs7#174755).
*       03-27-01  PML   Return error instead of calling amsg_exit (vs7#231220)
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <rterr.h>
#include <oscalls.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef CRTDLL

#ifdef  _MBCS
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

#endif

/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
extern int __env_initialized;

#endif

/***
*_setenvp - set up "envp" for C programs
*
*Purpose:
*       Reads the environment and build the envp array for C programs.
*
*Entry:
*       The environment strings occur at _aenvptr.
*       The list of environment strings is terminated by an extra null
*       byte.  Thus two null bytes in a row indicate the end of the
*       last environment string and the end of the environment, resp.
*
*Exit:
*       "environ" points to a null-terminated list of pointers to ASCIZ
*       strings, each of which is of the form "VAR=VALUE".  The strings
*       are copied from the environment area. This array of pointers will
*       be malloc'ed.  The block pointed to by _aenvptr is deallocated.
*
*Uses:
*       Allocates space on the heap for the environment pointers.
*
*Exceptions:
*       If space cannot be allocated, program is terminated.
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wsetenvp (
#else
int __cdecl _setenvp (
#endif
        void
        )
{
        _TSCHAR *p;
        _TSCHAR **env;              /* _environ ptr traversal pointer */
        int numstrings;             /* number of environment strings */
        int cchars;

#if     !defined(CRTDLL) && defined(_MBCS)
        /* If necessary, initialize the multibyte ctype table. */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif

        numstrings = 0;

#ifdef WPRFLAG
        p = _wenvptr;
#else
        p = _aenvptr;
#endif

        /*
         * We called __crtGetEnvironmentStrings[AW] just before this,
         * so if _[aw]envptr is NULL, we failed to get the environment.
         * Return an error.
         */
        if (p == NULL)
            return -1;

        /*
         * NOTE: starting with single null indicates no environ.
         * Count the number of strings. Skip drive letter settings
         * ("=C:=C:\foo" type) by skipping all environment variables
         * that begin with '=' character.
         */

        while (*p != _T('\0')) {
            /* don't count "=..." type */
            if (*p != _T('='))
                ++numstrings;
            p += _tcslen(p) + 1;
        }

        /* need pointer for each string, plus one null ptr at end */
        if ( (_tenviron = env = (_TSCHAR **)
            _malloc_crt((numstrings+1) * sizeof(_TSCHAR *))) == NULL )
            return -1;

        /* copy strings to malloc'd memory and save pointers in _environ */
#ifdef WPRFLAG
        for ( p = _wenvptr ; *p != L'\0' ; p += cchars )
#else
        for ( p = _aenvptr ; *p != '\0' ; p += cchars )
#endif
        {
            cchars = (int)_tcslen(p) + 1;
            /* don't copy "=..." type */
            if (*p != _T('=')) {
                if ( (*env = (_TSCHAR *)_malloc_crt(cchars * sizeof(_TSCHAR))) 
                     == NULL )
                {
                    _free_crt(_tenviron);
                    _tenviron = NULL;
                    return -1;
                }
                _tcscpy(*env, p);
                env++;
            }
        }

#ifdef WPRFLAG
        _free_crt(_wenvptr);
        _wenvptr = NULL;
#else
        _free_crt(_aenvptr);
        _aenvptr = NULL;
#endif

        /* and a final NULL pointer */
        *env = NULL;

#ifndef CRTDLL
        /*
         * Set flag for getenv() and _putenv() to know the environment
         * has been set up.
         */
        __env_initialized = 1;
#endif

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\tlssup.c ===
/***
*tlssup.c - Thread Local Storage run-time support module
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-19-93  SKS   Original Version from Chuck Mitchell
*       11-16-93  GJF   Enclosed in #ifdef _MSC_VER
*       02-17-94  SKS   Add "const" to declaration of _tls_used
*                       to work around problems with MIPS compiler.
*                       Also added a canonical file header comment.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       03-04-98  JWM   Modified for WIN64 - uses _IMAGE_TLS_DIRECTORY64
*       04-03-98  JWM   _tls_start & _tls_end are no longer initialized.
*       01-21-99  GJF   Added a couple ULONGLONG casts.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       09-06-00  PML   _tls_start/_tls_end can be 1 byte long (vs7#154062)
*       03-24-01  PML   callback array starts at __xl_a+1, not __xl_a.
*
****/

#ifdef  _MSC_VER

#include <sect_attribs.h>
#include <windows.h>

/* Thread Local Storage index for this .EXE or .DLL */

ULONG _tls_index = 0;

/* Special symbols to mark start and end of Thread Local Storage area. */

#pragma data_seg(".tls")

_CRTALLOC(".tls") char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

_CRTALLOC(".tls$ZZZ") char _tls_end = 0;

/* Start and end sections for Threadl Local Storage CallBack Array.
 * Actual array is constructed using .CRT$XLA, .CRT$XLC, .CRT$XLL,
 * .CRT$XLU, .CRT$XLZ similar to the way global
 *         static initializers are done for C++.
 */

#pragma data_seg(".CRT$XLA")

_CRTALLOC(".CRT$XLA") PIMAGE_TLS_CALLBACK __xl_a = 0;

#pragma data_seg(".CRT$XLZ")

_CRTALLOC(".CRT$XLZ") PIMAGE_TLS_CALLBACK __xl_z = 0;


#pragma data_seg(".rdata$T")

#ifndef IMAGE_SCN_SCALE_INDEX
#define IMAGE_SCN_SCALE_INDEX                0x00000001  // Tls index is scaled
#endif

#ifdef _WIN64

__declspec(allocate(".rdata$T")) const IMAGE_TLS_DIRECTORY64 _tls_used =
{
        (ULONGLONG) &_tls_start,        // start of tls data
        (ULONGLONG) &_tls_end,          // end of tls data
        (ULONGLONG) &_tls_index,        // address of tls_index
        (ULONGLONG) (&__xl_a+1),        // pointer to call back array
        (ULONG) 0,                      // size of tls zero fill
        (ULONG) 0                       // characteristics
};


#else

const IMAGE_TLS_DIRECTORY _tls_used =
{
        (ULONG)(ULONG_PTR) &_tls_start, // start of tls data
        (ULONG)(ULONG_PTR) &_tls_end,   // end of tls data
        (ULONG)(ULONG_PTR) &_tls_index, // address of tls_index
        (ULONG)(ULONG_PTR) (&__xl_a+1), // pointer to call back array
        (ULONG) 0,                      // size of tls zero fill
#if defined(_M_MRX000)
        (ULONG)IMAGE_SCN_SCALE_INDEX    // characteristics
#else
        (ULONG) 0                       // characteristics
#endif
};

#endif


#endif  /* _MSC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wcrt0.c ===
/***
*wcrt0.c - C runtime console EXE start-up routine, wchar_t version
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for console apps using wide
*       characters.  It calls the user's main routine wmain() after
*       performing C Run-Time Library initialization.
*
*Revision History:
*       11-19-93  CFW   Module created.
*       02-04-94  CFW   POSIX? NOT!
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "crt0.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wincrt0.c ===
/***
*wincrt0.c - C runtime Windows EXE start-up routine
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps.  It calls the
*       user's main routine WinMain() after performing C Run-Time Library
*       initialization.
*
*Revision History:
*       ??-??-??  ???   Module created.
*       09-01-94  SKS   Module commented.
*       10-28-94  SKS   Remove user32.lib as a default library -- it is now
*                       specified in crt0init.obj along with kernel32.lib.
*
*******************************************************************************/

#ifndef _POSIX_

#define _WINMAIN_
#include "crt0.c"

#endif  /* ndef _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wstdargv.c ===
/***
*wstdargv.c - standard & wildcard _setargv routine (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	processes program command line, with or without wildcard expansion
*
*Revision History:
*	11-19-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "stdargv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wincmdln.c ===
/***
*wincmdln.c - process command line for WinMain
*
*       Copyright (c) 1997-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prepare command line to be passed to [w]WinMain.
*
*Revision History:
*       06-23-97  GJF   Module created by extracting the code from crt0.c
*       03-24-01  PML   Protect against null _[aw]cmdln (vs7#229081)
*
*******************************************************************************/

#include <internal.h>
#include <tchar.h>

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

/***
*_[w]wincmdln
*
*Purpose:
*       Extract the command line tail to be passed to WinMain.
*
*       Be warned! This code was originally implemented by the NT group and 
*       has remained pretty much unchanged since 12-91. It should be changed
*       only with extreme care since there are undoubtedly many apps which
*       depend on its historical behavior.
*
*Entry:
*       The global variable _[a|w]cmdln is set to point at the complete
*       command line.
*
*Exit:
*       Returns a pointer to the command line tail.
*
*Exceptions:
*
*******************************************************************************/

_TUCHAR * __cdecl
#ifdef  WPRFLAG
_wwincmdln(
#else
_wincmdln(
#endif
        void
        )
{
        _TUCHAR *lpszCommandLine;

#ifdef  _MBCS
        /*
         * If necessary, initialize the multibyte ctype table
         */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif

        /*
         * Skip past program name (first token in command line).
         * Check for and handle quoted program name.
         */
#ifdef  WPRFLAG
        lpszCommandLine = _wcmdln == NULL ? L"" : (wchar_t *)_wcmdln;
#else
        lpszCommandLine = _acmdln == NULL ? "" : (unsigned char *)_acmdln;
#endif

        if ( *lpszCommandLine == DQUOTECHAR ) {
            /*
             * Scan, and skip over, subsequent characters until
             * another double-quote or a null is encountered.
             */

            while ( (*(++lpszCommandLine) != DQUOTECHAR)
                    && (*lpszCommandLine != _T('\0')) ) 
            {
#ifdef  _MBCS
                if (_ismbblead(*lpszCommandLine))
                    lpszCommandLine++;
#endif
            }

            /*
             * If we stopped on a double-quote (usual case), skip
             * over it.
             */
            if ( *lpszCommandLine == DQUOTECHAR )
                lpszCommandLine++;
        }
        else {
            while (*lpszCommandLine > SPACECHAR)
                lpszCommandLine++;
        }

        /*
         * Skip past any white space preceeding the second token.
         */
        while (*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
            lpszCommandLine++;

        return lpszCommandLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wstdenvp.c ===
/***
*wstdenvp.c - standard _setenvp routine (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module is called by the C start-up routine to set up "_wenviron".
*	Its sets up an array of pointers to strings in the environment.
*	The global symbol "_wenviron" is set to point to this array.
*
*Revision History:
*	11-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "stdenvp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wild.c ===
/***
*wild.c - wildcard expander
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*        expands wildcards in argv
*
*        handles '*' (none or more of any char) and '?' (exactly one char)
*
*Revision History:
*       05-21-84  RN    initial version
*       06-07-85  TDC   since dos accepts forward slash, added
*                       code to accept forward slash in a manner consistent
*                       with reverse slash.
*       09-20-86  SKS   Modified for OS/2
*                       All argument strings to this function have a
*                       leading flag character. If the flag is a quote,
*                       that argument string was quoted on the command
*                       line and should have not wildcard expansion.  In all
*                       cases the leading flag character is removed from
*                       the string.
*       11-11-86  JMB   Added Kanji support under KANJI switch.
*       09-21-88  WAJ   initial 386 version
*       04-09-90  GJF   Added #include <cruntime.h> and removed #include
*                       <register.h>. Made calling types explicit (_CALLTYPE1
*                       or _CALLTYPE4). Also, fixed the copyright.
*       04-10-90  GJF   Added #include <internal.h> and fixed compiler warnings
*                       (-W3).
*       07-03-90  SBM   Compiles cleanly with -W3 under KANJI, removed
*                       redundant includes, removed #include <internal.h>
*                       to keep wild.c free of private stuff, should we
*                       decide to release it
*       09-07-90  SBM   put #include <internal.h> back in, reason for
*                       removing it discovered to be horribly bogus
*       10-08-90  GJF   New-style function declarators.
*       01-18-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                       Remove explicit declarations of __argc & __argv.
*                       They are declared in <stdlib.h>
*       05-05-93  SKS   Filename sorting should be case-insensitive
*       06-09-93  KRS   Update _MBCS support.
*       10-20-93  GJF   Merged in NT version.
*       11-23-93  CFW   Wide char enable, grab _find from stdargv.c.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       04-22-94  GJF   Made defintions of arghead, argend, _WildFindHandle
*                       and findbuf conditional on DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       01-18-95  GJF   Must replace _tcsdup with _malloc_crt/_tcscpy for
*                       _DEBUG build.
*       02-04-98  GJF   Changes for Win64: use intptr_t and ptrdiff_t casts
*                       where appropriate.
*       02-19-01  GB    added check for return value of malloc in find.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>

#ifdef _MBCS
#include <mbdata.h>
#include <mbstring.h>
#endif
#include <dbgint.h>

/*
** these are the data structures
**
**     __argv
**     -------     ------
**     |     |---->|    |---->"arg0"
**     -------     ------
**                 |    |---->"arg1"
**                 ------
**                  ....
**                 ------
**                 |    |---->"argn"
**                 ------
**                 |NULL|
**                 ------
**                                       argend
**                                       -------
**     -------                           |     |
**     |     | __argc                    -------
**     -------                              |
**                                          |
**  arghead                                 V
**  ------     ---------                ----------
**  |    |---->|   |   |----> .... ---->|   |NULL|
**  ------     ---------                ----------
**               |                        |
**               V                        V
**            "narg0"                  "nargn"
*/

#define ERRORHANDLE ((HANDLE)(intptr_t)(-1))

/* local function tchars */
#ifdef WPRFLAG
#define tmatch  wmatch
#define tadd    wadd
#define tsort   wsort
#define tfind   wfind
#else
#define tmatch  match
#define tadd    add
#define tsort   sort
#define tfind   find
#endif

#define SLASHCHAR       _T('\\')
#define FWDSLASHCHAR    _T('/')
#define COLONCHAR       _T(':')
#define QUOTECHAR       _T('"')

#define SLASH           _T("\\")
#define FWDSLASH        _T("/")
#define STAR            _T("*.*")
#define DOT             _T(".")
#define DOTDOT          _T("..")

#define WILDSTRING      _T("*?")

struct argnode {
    _TSCHAR *argptr;
    struct argnode *nextnode;
};

static struct argnode *arghead;
static struct argnode *argend;

#ifdef WPRFLAG
static int __cdecl wmatch(wchar_t *, wchar_t *);
static int __cdecl wadd(wchar_t *);
static void __cdecl wsort(struct argnode *);
static wchar_t * __cdecl wfind (wchar_t *pattern);
#else
static int __cdecl match(char *, char *);
static int __cdecl add(char *);
static void __cdecl sort(struct argnode *);
static char * __cdecl find (char *pattern);
#endif

/***
*int _cwild() - wildcard expander
*
*Purpose:
*       expands wildcard in file specs in argv
*
*       handles '*' (none or more of any char), '?' (exactly one char), and
*       '[string]' (chars which match string chars or between n1 and n2
*       if 'n1-n2' in string inclusive)
*
*Entry:
*
*Exit:
*       returns 0 if successful, -1 if any malloc() calls fail
*       if problems with malloc, the old argc and argv are not touched
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wcwild (
#else
int __cdecl _cwild (
#endif
        void
        )
{
#ifdef WPRFLAG
        REG1 wchar_t **argv = __wargv;
#else
        REG1 char **argv = __argv;
#endif
        REG2 struct argnode *nodeptr;
        REG3 int argc;
        REG4 _TSCHAR **tmp;
        _TSCHAR *wchar;

        arghead = argend = NULL;

#ifdef WPRFLAG
        for (argv = __wargv; *argv; argv++) /* for each arg... */
#else
        for (argv = __argv; *argv; argv++)  /* for each arg... */
#endif
            if ( *(*argv)++ == QUOTECHAR )
                /* strip leading quote from quoted arg */
            {
                if (tadd(*argv))
                    return(-1);
            }
            else if (wchar = _tcspbrk( *argv, WILDSTRING )) {
                /* attempt to expand arg with wildcard */
                if (tmatch( *argv, wchar ))
                    return(-1);
            }
            else if (tadd( *argv )) /* normal arg, just add */
                return(-1);

        /* count the args */
        for (argc = 0, nodeptr = arghead; nodeptr;
                nodeptr = nodeptr->nextnode, argc++)
            ;

        /* try to get new arg vector */
        if (!(tmp = (_TSCHAR **)_malloc_crt(sizeof(_TSCHAR *)*(argc+1))))
            return(-1);

        /* the new arg vector... */
#ifdef WPRFLAG
        __wargv = tmp;
#else
        __argv = tmp;
#endif

        /* the new arg count... */
        __argc = argc;

        /* install the new args */
        for (nodeptr = arghead; nodeptr; nodeptr = nodeptr->nextnode)
            *tmp++ = nodeptr->argptr;

        /* the terminal NULL */
        *tmp = NULL;

        /* free up local data */
        for (nodeptr = arghead; nodeptr; nodeptr = arghead) {
            arghead = arghead->nextnode;
            _free_crt(nodeptr);
        }

        /* return success */
        return(0);
}


/***
*match(arg, ptr) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wmatch (
#else
static int __cdecl match (
#endif
        REG4 _TSCHAR *arg,
        REG1 _TSCHAR *ptr
        )
{
        REG2 _TSCHAR *new;
        REG3 int length = 0;
        _TSCHAR *all;
        REG5 struct argnode *first;
        REG6 int gotone = 0;

        while (ptr != arg && *ptr != SLASHCHAR && *ptr != FWDSLASHCHAR
            && *ptr != COLONCHAR) {
            /* find first slash or ':' before wildcard */
#ifdef _MBCS
            if (--ptr > arg)
                ptr = _mbsdec(arg,ptr+1);
#else
            ptr--;
#endif
        }

        if (*ptr == COLONCHAR && ptr != arg+1) /* weird name, just add it as is */
            return(tadd(arg));

        if (*ptr == SLASHCHAR || *ptr == FWDSLASHCHAR
            || *ptr == COLONCHAR) /* pathname */
            length = (int)(ptrdiff_t)(ptr - arg + 1); /* length of dir prefix */

        if (new = tfind(arg)) { /* get the first file name */
            first = argend;

            do  { /* got a file name */
                if (_tcscmp(new, DOT) && _tcscmp(new, DOTDOT)) {
                    if (*ptr != SLASHCHAR && *ptr != COLONCHAR
                        && *ptr != FWDSLASHCHAR ) {
                        /* current directory; don't need path */
#ifdef  _DEBUG
                        if (!(arg=_malloc_crt((_tcslen(new)+1)*sizeof(_TSCHAR)))
                            || tadd(_tcscpy(arg,new)))
#else   /* ndef _DEBUG */
                        if (!(arg = _tcsdup(new)) || tadd(arg))
#endif  /* _DEBUG */
                            return(-1);
                    }
                    else    /* add full pathname */
                        if (!(all=_malloc_crt((length+_tcslen(new)+1)*sizeof(_TSCHAR)))
                            || tadd(_tcscpy(_tcsncpy(all,arg,length)+length,new)
                            - length))
                            return(-1);

                    gotone++;
                }

            }
            while (new = tfind(NULL));  /* get following files */

            if (gotone) {
                tsort(first ? first->nextnode : arghead);
                return(0);
            }
        }

        return(tadd(arg)); /* no match */
}

/***
*add(arg) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wadd (
#else
static int __cdecl add (
#endif
    _TSCHAR *arg
    )
{
        REG1 struct argnode *nodeptr;

        if (!(nodeptr = (struct argnode *)_malloc_crt(sizeof(struct argnode))))
            return(-1);

        nodeptr->argptr = arg;
        nodeptr->nextnode = NULL;

        if (arghead)
            argend->nextnode = nodeptr;
        else
            arghead = nodeptr;

        argend = nodeptr;
        return(0);
}


/***
*sort(first) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static void __cdecl wsort (
#else
static void __cdecl sort (
#endif
        REG2 struct argnode *first
        )
{
        REG1 struct argnode *nodeptr;
        REG3 _TSCHAR *temp;

        if (first) /* something to sort */
            while (nodeptr = first->nextnode) {
                do  {
#ifdef _POSIX_
                    if (_tcscmp(nodeptr->argptr, first->argptr) < 0) {
#else
                    if (_tcsicmp(nodeptr->argptr, first->argptr) < 0) {
#endif /* _POSIX_ */
                        temp = first->argptr;
                        first->argptr = nodeptr->argptr;
                        nodeptr->argptr = temp;
                    }
                }
                while (nodeptr = nodeptr->nextnode);

                first = first->nextnode;
            }
}


/***
*find(pattern) - find matching filename
*
*Purpose:
*       if argument is non-null, do a DOSFINDFIRST on that pattern
*       otherwise do a DOSFINDNEXT call.  Return matching filename
*       or NULL if no more matches.
*
*Entry:
*       pattern = pointer to pattern or NULL
*           (NULL means find next matching filename)
*
*Exit:
*       returns pointer to matching file name
*           or NULL if no more matches.
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static wchar_t * __cdecl wfind (
#else
static char * __cdecl find (
#endif /* WPRFLAG */
    _TSCHAR *pattern
    )
{
        _TSCHAR *retval;

        static HANDLE _WildFindHandle;
        static LPWIN32_FIND_DATA findbuf;

        if (pattern) {
            if (findbuf == NULL)
                if ((findbuf = (LPWIN32_FIND_DATA)_malloc_crt(MAX_PATH + sizeof(*findbuf))) == NULL)
                    return NULL;

            if (_WildFindHandle != NULL) {
                (void)FindClose( _WildFindHandle );
                _WildFindHandle = NULL;
            }

            _WildFindHandle = FindFirstFile( (LPTSTR)pattern, findbuf );
            if (_WildFindHandle == ERRORHANDLE)
                return NULL;
        }
        else if (!FindNextFile( _WildFindHandle, findbuf )) {
            (void)FindClose( _WildFindHandle );
            _WildFindHandle = NULL;
            return NULL;
        }

        retval = findbuf->cFileName;

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wwincrt0.c ===
/***
*wwincrt0.c - C runtime Windows EXE start-up routine, wchar_t version
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps using wide
*       characters.  It calls the user's main routine wWinMain() after
*       performing C Run-Time Library initialization.
*
*Revision History:
*       ??-??-??  ???   Module created.
*       09-01-94  SKS   Module commented.
*       10-28-94  SKS   Remove user32.lib as a default library -- it is now
*                       specified in crt0init.obj along with kernel32.lib.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define _WINMAIN_
#include "crt0.c"

#endif  /* ndef _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wwild.c ===
/***
*wwild.c - wildcard expander (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	 expands wildcards in argv
*
*	 handles L'*' (none or more of any char) and L'?' (exactly one char)
*
*Revision History:
*	11-19-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "wild.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\wwncmdln.c ===
/***
*wwncmdln.c - process command line for wWinMain
*
*       Copyright (c) 1997-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prepare command line to be passed to wWinMain.
*
*Revision History:
*       06-26-97  GJF   Module created.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG     1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE     /* NT flag */
#define UNICODE     1
#endif

#undef  _MBCS       /* UNICODE not _MBCS */

#include "wincmdln.c"

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\_setargv.c ===
/***
*_setargv.c - Wildcard argv[] expansion
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	_setargv performs wildcard argv[] expansion
*
*	NOTE:  This stub module scheme is compatible with NT build
*	procedure.
*
*Revision History:
*	09-25-91  JCR	Stub module created.
*
*******************************************************************************/

#define WILDCARD 1
#include "stdargv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\dll\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\dlllib\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\amd64\chkstk.asm ===
TITLE   "Runtime Stack Checking"
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;   chkstk.s
;
; Abstract:
;
;   This module implements runtime stack checking.
;
; Author:
;
;   David N. Cutler (davec) 20-Oct-2000
;
; Environment:
;
;   Any mode.
;
;--

include ksamd64.inc

        subttl  "Check Stack"
;++
;
; ULONG64
; __chkstk (
;     VOID
;     )
;
; Routine Description:
;
;   This function provides runtime stack checking for local allocations
;   that are more than a page and for storage dynamically allocated with
;   the alloca function. Stack checking consists of probing downward in
;   the stack a page at a time. If the current stack commitment is exceeded,
;   then the system will automatically attempts to expand the stack. If the
;   attempt succeeds, then another page is committed. Otherwise, a stack
;   overflow exception is raised. It is the responsibility of the caller to
;   handle this exception.
;
;   N.B. This routine is called using a non-standard calling sequence since
;        it is typically called from within the prologue. The allocation size
;        argument is in register rax and it must be preserved. Registers r10
;        and r11 used by this function and are not preserved.
;
;        The typical calling sequence from the prologue is:
;
;        mov    rax, allocation-size    ; set requested stack frame size
;        call   __chkstk                ; check stack page allocation
;        sub    rsp, rax                ; allocate stack frame
;
; Arguments:
;
;   None.
;
; Implicit Arguments:
;
;   Allocation (rax) - Supplies the size of the allocation on the stack.
;
; Return Value:
;
;   The allocation size is returned as the function value.
;
;--

        LEAF_ENTRY __chkstk, _TEXT$00

ifdef NTOS_KERNEL_RUNTIME

;
; Kernel components should never allocate more than 512 bytes on the kernel
; stack.
;

if DBG

        cmp     rax, 512                ; check if less than 512 bytes
        jbe     short cs05              ; if be, less than 512 bytes
        int     3                       ; break into debugger

endif

cs05:   ret                             ; return

else

        lea     r10, 8[rsp]             ; compute requested stack address
        sub     r10, rax                ;

;
; If the new stack address is greater than the current stack limit, then the
; pages have already been allocated and nothing further needs to be done.
;

        mov     r11, gs:[TeStackLimit]  ; get current stack limit
        cmp     r10, r11                ; check if stack within limits
        jae     short cs20              ; if ae, stack within limits

;
; The new stack address is not within the currently allocated stack. Probe
; pages downward in the stack until all pages have been allocated or a stack
; overflow occurs in which case an exception will be raised.
;

        and     r10w, not (PAGE_SIZE - 1) ; round down new stack address
cs10:   lea     r11, (-PAGE_SIZE)[r11]  ; get next lower page address
        mov     byte ptr [r11], 0       ; probe stack address
        cmp     r10, r11                ; check if end of probe range
        jne     short cs10              ; if ne, not end of probe range
cs20:   ret                             ; return

endif

        LEAF_END __chkstk, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\_wstargv.c ===
/***
*_wstargv.c - Wildcard argv[] expansion (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	_wsetargv performs wildcard argv[] expansion
*
*	NOTE:  This stub module scheme is compatible with NT build
*	procedure.
*
*Revision History:
*	11-23-93  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define WILDCARD 1

#include "stdargv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\psx\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\mt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\st\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\nt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\i386\atlssup.asm ===
page	,132
	title	atlssup - TLS support object
;***
;atlssup.asm - Thread Local Storage support object (defines [_]_tls_array)
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Defines the symbol [_]_tls_array which is the offset into the
;	TEB (thread environment block) of the thread local storage pointer.
;
;Revision History:
;	03-19-93  SKS	Initial version (from ChuckM)
;	03-22-93  SKS	One less leading underscore with new include file 
;	10-06-94  SKS	Added header file comment
;
;*******************************************************************************

.xlist
include cruntime.inc
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

		public	_tls_array 
_tls_array 	equ	2Ch	  ; TEB.ThreadLocalStoragePointer

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\i386\chkstk.asm ===
page    ,132
        title   chkstk - C stack checking routine
;***
;chkstk.asm - C stack checking routine
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Provides support for automatic stack checking in C procedures
;       when stack checking is enabled.
;
;Revision History:
;       04-21-87  SKS   Added conditional assembly switch for STKHQQ = 0
;       07-23-87  MAG   [1] Added run-time CS:IP error processing for QC
;       08-17-87  JLS   [2] Remove all references to DGROUP
;       08-25-87  JLS   [3] Shift include files
;       11-13-87  SKS   OS/2 Reentrant version, add thread ID check
;       11-18-87  SKS   Make STKHQQ an array (oops!)
;       12-14-87  SKS   add .286p to allow PUSH immediate value
;       02-19-88  SKS   Change minimum bottom limit to STACKSLOP, not 0
;       06-01-88  PHG   Merge DLL and normal versions
;       09-21-88  WAJ   initial 386 version
;       10-18-88  JCR   Chkstk was trashing bx... not good on 386
;       06-06-89  JCR   386 mthread support
;       06-20-89  JCR   386: Removed _LOAD_DGROUP code
;       04-06-90  GJF   Fixed the copyright.
;       06-21-90  GJF   Rewritten to probe pages
;       10-15-90  GJF   Restored _end and STKHQQ.
;       03-19-91  GJF   Revised to preserve all registers except eax. Note
;                       this is _rchkstk functionality so there is no longer
;                       a separate _rchkstk routine.
;       08-01-91  GJF   Got rid of _end and STKHQQ, except for Cruiser
;                       (probably not needed for Cruiser either) [_WIN32_].
;       09-27-91  JCR   Merged Stevewo' changes from NT tree
;       09-06-94  CFW   Nuke Cruiser.
;       12-03-94  SKS   Remove include of obsolete file msdos.inc
;       12-13-94  GJF   Better version from Intel (old jmp eax method of
;                       returning is too expensive on P6).
;       09-11-98  GJF   Fixed handling of very small frames.
;       12-10-99  GB    Changed both _chkstk and _alloca_probe to procedure
;
;*******************************************************************************

.xlist
        include cruntime.inc
.list

; size of a page of memory

_PAGESIZE_      equ     1000h


        CODESEG

page
;***
;_chkstk - check stack upon procedure entry
;
;Purpose:
;       Provide stack checking on procedure entry. Method is to simply probe
;       each page of memory required for the stack in descending order. This
;       causes the necessary pages of memory to be allocated via the guard
;       page scheme, if possible. In the event of failure, the OS raises the
;       _XCPT_UNABLE_TO_GROW_STACK exception.
;
;       NOTE:  Currently, the (EAX < _PAGESIZE_) code path falls through
;       to the "lastpage" label of the (EAX >= _PAGESIZE_) code path.  This
;       is small; a minor speed optimization would be to special case
;       this up top.  This would avoid the painful save/restore of
;       ecx and would shorten the code path by 4-6 instructions.
;
;Entry:
;       EAX = size of local frame
;
;Exit:
;       ESP = new stackframe, if successful
;
;Uses:
;       EAX
;
;Exceptions:
;       _XCPT_GUARD_PAGE_VIOLATION - May be raised on a page probe. NEVER TRAP
;                                    THIS!!!! It is used by the OS to grow the
;                                    stack on demand.
;       _XCPT_UNABLE_TO_GROW_STACK - The stack cannot be grown. More precisely,
;                                    the attempt by the OS memory manager to
;                                    allocate another guard page in response
;                                    to a _XCPT_GUARD_PAGE_VIOLATION has
;                                    failed.
;
;*******************************************************************************

public _alloca_probe 

_chkstk proc

_alloca_probe    =  _chkstk

        cmp     eax, _PAGESIZE_         ; more than one page?
        jae     short probesetup        ;   yes, go setup probe loop
                                        ;   no
        neg     eax                     ; compute new stack pointer in eax
        add     eax,esp
        add     eax,4
        test    dword ptr [eax],eax     ; probe it
        xchg    eax,esp
        mov     eax,dword ptr [eax]
        push    eax
        ret

probesetup:
        push    ecx                     ; save ecx
        lea     ecx,[esp] + 8           ; compute new stack pointer in ecx
                                        ; correct for return address and
                                        ; saved ecx

probepages:
        sub     ecx,_PAGESIZE_          ; yes, move down a page
        sub     eax,_PAGESIZE_          ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,_PAGESIZE_          ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...
 
        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        mov     esp,ecx                 ; set the new stack pointer
 
        mov     ecx,dword ptr [eax]     ; recover ecx
        mov     eax,dword ptr [eax + 4] ; recover return address
 
        push    eax                     ; prepare return address
                                        ; ...probe in case a page was crossed
        ret
_chkstk endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\i386\fp8.c ===
/***
* fp8.c - Set default FP precision to 53 bits (8-byte double)
*
*	Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*   03-23-93  JWM	created file
*
*******************************************************************************/
#include <float.h>

void  _setdefaultprecision(void);

/*
 * Routine to set default FP precision to 53 bits.
 */
 
void _setdefaultprecision()
{
	_controlfp(_PC_53, _MCW_PC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\ia64\fp8.c ===
/***
* fp8.c - Set default FP precision
*
*       Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-23-93  JWM   created file
*       06-04-99  PML   For IA64, set _PC_64 bit mode as default
*
*******************************************************************************/
#include <float.h>

void  _setdefaultprecision(void);

/*
 * Routine to set default FP precision to 64 bits.
 */
 
void _setdefaultprecision()
{
        _controlfp(_PC_64, _MCW_PC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\startup\ia64\chkstk.s ===
.file "chkstk.s"

/* _chkstk - check stack upon procedure entry

;Purpose:
;       Provide stack checking on procedure entry. Method is to simply probe
;       each page of memory required for the stack in descending order. This
;       causes the necessary pages of memory to be allocated via the guard
;       page scheme, if possible. In the event of failure, the OS raises the
;       _XCPT_UNABLE_TO_GROW_STACK exception.
;
;       The link register is b7 to avoid conflicts with linker thunks.
;
;
;Entry:
;       r26:        Size of the storage to allocate
;               (This is rounded up to the next multiple of 16)
;
;Exit:
;
;
;*******************************************************************************

*/
#include "ksia64.h"

        .section        .text
        .align 32

        LEAF_ENTRY(__chkstk)
        ALTERNATE_ENTRY(__alloca_probe)

        .prologue

        cond_reg1              = p6
        cond_discard           = p0

        return_branch_register = b7

        argument_reg           = r26
        discard_reg            = r27
        new_stack_pointer      = r28
        page_size_reg          = r29
        alloc_size_reg         = r30

        .altrp return_branch_register

        mov discard_reg = 15
        
        mov page_size_reg = PAGE_SIZE
        // load page size into a register, we'll need to use it again.

        add alloc_size_reg=15,argument_reg
        // Make sure the requested size is = 0 mod 16:      round up
        ;;

	.body

        mov new_stack_pointer = sp             
        // Save the stack pointer to a different register for manipulation
        // new_stack_pointer is scratch


        andcm alloc_size_reg=alloc_size_reg,discard_reg
        // setting the lower four bits to zero

        ;;          

        cmp.le     cond_reg1,p0 = alloc_size_reg, page_size_reg      
        // assume greater than 1 page most of the time.

   (cond_reg1) br.cond.dpnt    ._last_page
        // if size is <= 1 page, branch to

._probepages:
        sub  alloc_size_reg = alloc_size_reg,page_size_reg            

        // The size is more than 1 page, subtract a page from sp
        sub  new_stack_pointer = new_stack_pointer,page_size_reg
        ;;
        
        // Do we still have more than 1 page?
        cmp.gt  cond_reg1,cond_discard = alloc_size_reg, page_size_reg     
        
        ;; 

        // Use non-temporal locality hint so the cache is not polluted
        ld8.nta discard_reg = [new_stack_pointer]             // probe it
   (cond_reg1) br.cond.dpnt    ._probepages
        ;; 
 
// .mmi
._last_page:
        sub new_stack_pointer = new_stack_pointer, alloc_size_reg
        ;;

        // subtract the last piecemill, which is in alloc_size_reg.
        // the new stack pointer.

        ld8.nta discard_reg = [new_stack_pointer]           // probe it. 

        // If we are here, everything is ok.
        
        br.ret.dpnt       return_branch_register

        LEAF_EXIT(__chkstk)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\cerr.cpp ===
// cerr -- initialize standard error stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf ferr(_cpp_stderr);
_CRTIMP2 ostream cerr(&ferr);

		// INITIALIZATION CODE
struct _Init_cerr
	{	// ensures that cerr is initialized
	_Init_cerr()
		{	// initialize cerr
		_Ptr_cerr = &cerr;
		cerr.tie(_Ptr_cout);
		cerr.setf(ios_base::unitbuf);
		}
	};
static _Init_cerr init_cerr;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\cin.cpp ===
// cin -- initialize standard input stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf fin(_cpp_stdin);
_CRTIMP2 istream cin(&fin);

		// INITIALIZATION CODE
struct _Init_cin
	{	// ensures that cin is initialized
	_Init_cin()
		{	// initialize cin
		_Ptr_cin = &cin;
		cin.tie(_Ptr_cout);
		}
	};
static _Init_cin init_cin;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\delaop2.cpp ===
// delaop2 -- operator delete[](void *, nothrow_t) REPLACEABLE
#include <new>

void __cdecl operator delete[](void *ptr,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	operator delete[](ptr);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\clog.cpp ===
// clog -- initialize standard log stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf flog(_cpp_stderr);
_CRTIMP2 ostream clog(&flog);

		// INITIALIZATION CODE
struct _Init_clog
	{	// ensures that clog is initialized
	_Init_clog()
		{	// initialize clog
		_Ptr_clog = &clog;
		clog.tie(_Ptr_cout);
		}
	};
static _Init_clog init_clog;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\cout.cpp ===
// cout -- initialize standard output stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf fout(_cpp_stdout);
_CRTIMP2 ostream cout(&fout);

		// INITIALIZATION CODE
struct _Init_cout
	{	// ensures that cout is initialized
	_Init_cout()
		{	// initialize cout
		_Ptr_cout = &cout;
		if (_Ptr_cin != 0)
			_Ptr_cin->tie(_Ptr_cout);
		if (_Ptr_cerr != 0)
			_Ptr_cerr->tie(_Ptr_cout);
		if (_Ptr_clog != 0)
			_Ptr_clog->tie(_Ptr_cout);
		}
	};
static _Init_cout init_cout;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\delop2.cpp ===
// delop2 -- operator delete(void *, nothrow_t) REPLACEABLE
#include <new>

void __cdecl operator delete(void *ptr,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	operator delete(ptr);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\delaop2_s.cpp ===
//  delaop2_s.cpp - version of delaop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "delaop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\delop2_s.cpp ===
//  delop2_s.cpp - version of delop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "delop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\fiopen.cpp ===
// fiopen -- _Fiopen(const char *, ios_base::openmode)
#include <fstream>
_STD_BEGIN

_CRTIMP2 FILE *__cdecl _Fiopen(const char *filename, ios_base::openmode mode)
	{	// open a file
	static const char *mods[] =
		{	// fopen mode strings corresponding to valid[i]
		"r", "w", "w", "a", "rb", "wb", "wb", "ab",
		"r+", "w+", "a+", "r+b", "w+b", "a+b", 0};

	static const int valid[] =
		{	// valid combinations of open flags
		ios_base::in,
		ios_base::out,
		ios_base::out | ios_base::trunc,
		ios_base::out | ios_base::app,
		ios_base::in | ios_base::binary,
		ios_base::out | ios_base::binary,
		ios_base::out | ios_base::trunc | ios_base::binary,
		ios_base::out | ios_base::app | ios_base::binary,
		ios_base::in | ios_base::out,
		ios_base::in | ios_base::out | ios_base::trunc,
		ios_base::in | ios_base::out | ios_base::app,
		ios_base::in | ios_base::out | ios_base::binary,
		ios_base::in | ios_base::out | ios_base::trunc
			| ios_base::binary,
		ios_base::in | ios_base::out | ios_base::app
			| ios_base::binary,
		0};

	FILE *fp;
	int n;
	ios_base::openmode atendflag = mode & ios_base::ate;

	mode &= ~ios_base::ate;
	for (n = 0; valid[n] != 0 && valid[n] != mode; ++n)
		;	// look for a valid mode

	if (valid[n] == 0 || (fp = fopen(filename, mods[n])) == 0)
		return (0);	// no valid mode or open failed

	if (!atendflag || fseek(fp, 0, SEEK_END) == 0)
		return (fp);	// no need to seek to end, or seek succeeded

	fclose(fp);	// can't position at end
	return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\instances.cpp ===
// instances -- force DLL instances for Microsoft
#define __FORCE_INSTANCE

#include <complex>
#include <fstream>
#include <ios>
#include <istream>
#include <limits>
#include <locale>
#include <ostream>
#include <sstream>
#include <streambuf>
#include <xlocale>
#include <xlocmes>
#include <xlocmon>
#include <xlocnum>
#include <xloctime>
#include <xstring>

_STD_BEGIN

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, char&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, signed char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, signed char&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, unsigned short *);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, unsigned short&);
#endif

template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const signed char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, signed char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const unsigned char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, unsigned char);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, wchar_t);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const unsigned short *);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, unsigned short);
#endif

template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const char, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator==(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);

template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const wchar_t, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator==(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const unsigned short, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator==(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl getline(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl getline(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
#endif

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, complex<float>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<float>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<float>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<float>&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<float>&);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<float>&);
#endif

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, complex<double>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<double>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<double>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<double>&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<double>&);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<double>&);
#endif

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<long double>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<long double>&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<long double>&);
#endif

template _CRTIMP2 float __cdecl imag(const complex<float>&);
template _CRTIMP2 float __cdecl real(const complex<float>&);
template _CRTIMP2 float __cdecl _Fabs(const complex<float>&, int *);
template _CRTIMP2 complex<float> __cdecl operator+(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator+(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator+(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator-(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator-(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator-(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator*(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator*(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator*(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator/(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator/(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator/(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator+(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator-(const complex<float>&);
template _CRTIMP2 bool __cdecl operator==(const complex<float>&, const complex<float>&);
template _CRTIMP2 bool __cdecl operator==(const complex<float>&, const float&);
template _CRTIMP2 bool __cdecl operator==(const float&, const complex<float>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<float>&, const complex<float>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<float>&, const float&);
template _CRTIMP2 bool __cdecl operator!=(const float&, const complex<float>&);
template _CRTIMP2 float __cdecl abs(const complex<float>&);
template _CRTIMP2 float __cdecl arg(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl conj(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl cos(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl cosh(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl exp(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl log(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl log10(const complex<float>&);
template _CRTIMP2 float __cdecl norm(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl polar(const float&, const float&);
template _CRTIMP2 complex<float> __cdecl polar(const float&);
template _CRTIMP2 complex<float> __cdecl pow(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl pow(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl pow(const complex<float>&, int);
template _CRTIMP2 complex<float> __cdecl pow(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl sin(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl sinh(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl sqrt(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl tanh(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl tan(const complex<float>&);

template _CRTIMP2 double __cdecl imag(const complex<double>&);
template _CRTIMP2 double __cdecl real(const complex<double>&);
template _CRTIMP2 double __cdecl _Fabs(const complex<double>&, int *);
template _CRTIMP2 complex<double> __cdecl operator+(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator+(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator+(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator-(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator-(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator-(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator*(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator*(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator*(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator/(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator/(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator/(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator+(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator-(const complex<double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<double>&, const complex<double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<double>&, const double&);
template _CRTIMP2 bool __cdecl operator==(const double&, const complex<double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<double>&, const complex<double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<double>&, const double&);
template _CRTIMP2 bool __cdecl operator!=(const double&, const complex<double>&);
template _CRTIMP2 double __cdecl abs(const complex<double>&);
template _CRTIMP2 double __cdecl arg(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl conj(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl cos(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl cosh(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl exp(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl log(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl log10(const complex<double>&);
template _CRTIMP2 double __cdecl norm(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl polar(const double&, const double&);
template _CRTIMP2 complex<double> __cdecl polar(const double&);
template _CRTIMP2 complex<double> __cdecl pow(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl pow(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl pow(const complex<double>&, int);
template _CRTIMP2 complex<double> __cdecl pow(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl sin(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl sinh(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl sqrt(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl tanh(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl tan(const complex<double>&);

template _CRTIMP2 long double __cdecl imag(const complex<long double>&);
template _CRTIMP2 long double __cdecl real(const complex<long double>&);
template _CRTIMP2 long double __cdecl _Fabs(const complex<long double>&, int *);
template _CRTIMP2 complex<long double> __cdecl operator+(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator+(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator+(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator-(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator-(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator-(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator*(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator*(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator*(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator/(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator/(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator/(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator+(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator-(const complex<long double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<long double>&, const long double&);
template _CRTIMP2 bool __cdecl operator==(const long double&, const complex<long double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<long double>&, const long double&);
template _CRTIMP2 bool __cdecl operator!=(const long double&, const complex<long double>&);
template _CRTIMP2 long double __cdecl abs(const complex<long double>&);
template _CRTIMP2 long double __cdecl arg(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl conj(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl cos(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl cosh(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl exp(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl log(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl log10(const complex<long double>&);
template _CRTIMP2 long double __cdecl norm(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl polar(const long double&, const long double&);
template _CRTIMP2 complex<long double> __cdecl polar(const long double&);
template _CRTIMP2 complex<long double> __cdecl pow(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl pow(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl pow(const complex<long double>&, int);
template _CRTIMP2 complex<long double> __cdecl pow(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl sin(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl sinh(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl sqrt(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl tanh(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl tan(const complex<long double>&);

template<> const basic_string<char, char_traits<char>, allocator<char> >::size_type
        basic_string<char, char_traits<char>, allocator<char> >::npos =
		(size_type)(-1);
template<> const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::size_type
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::npos =
		(size_type)(-1);
#ifdef _NATIVE_WCHAR_T_DEFINED
template<> const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >::size_type
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >::npos =
		(size_type)(-1);
#endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\iostream.cpp ===
// iostream -- ios::Init members, dummy for MS
#include <iostream>
_STD_BEGIN

		// OBJECT DECLARATIONS
int ios_base::Init::_Init_cnt = -1;

_CRTIMP2 ios_base::Init::Init()
	{	// initialize standard streams first time
	if (0 <= _Init_cnt)
		++_Init_cnt;
	else
		_Init_cnt = 1;
	}

_CRTIMP2 ios_base::Init::~Init()
	{	// flush standard streams last time
	if (--_Init_cnt == 0)
		{	// flush standard streams
		if (_Ptr_cerr != 0)
			_Ptr_cerr->flush();
		if (_Ptr_clog != 0)
			_Ptr_clog->flush();
		if (_Ptr_cout != 0)
			_Ptr_cout->flush();
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\iomanip.cpp ===
// iomanip -- instantiations of iomanip
#include <iomanip>
_STD_BEGIN

		// FUNCTION resetiosflags
static void __cdecl rsfun(ios_base& iostr, ios_base::fmtflags mask)
	{	// reset specified format flags
	iostr.setf(ios_base::_Fmtzero, mask);
	}

		// FUNCTION setiosflags
static void __cdecl sifun(ios_base& iostr, ios_base::fmtflags mask)
	{	// set specified format flags
	iostr.setf(ios_base::_Fmtmask, mask);
	}

		// FUNCTION setbase
static void __cdecl sbfun(ios_base& iostr, int base)
	{	// set base
	iostr.setf(base == 8 ? ios_base::oct
		: base == 10 ? ios_base::dec
		: base == 16 ? ios_base::hex
		: ios_base::_Fmtzero,
			ios_base::basefield);
	}

		// FUNCTION setprecision
static void __cdecl spfun(ios_base& iostr, streamsize prec)
	{	// set precision
	iostr.precision(prec);
	}

		// FUNCTION setw
static void __cdecl swfun(ios_base& iostr, streamsize wide)
	{	// set width
	iostr.width(wide);
	}

_CRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl resetiosflags(ios_base::fmtflags mask)
	{	// manipulator to reset format flags
	return (_Smanip<ios_base::fmtflags>(&rsfun, mask));
	}

_CRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl setiosflags(ios_base::fmtflags mask)
	{	// manipulator to set format flags
	return (_Smanip<ios_base::fmtflags>(&sifun, mask));
	}

_CRTIMP2 _Smanip<int> __cdecl setbase(int base)
	{	// manipulator to set base
	return (_Smanip<int>(&sbfun, base));
	}

_CRTIMP2 _Smanip<streamsize> __cdecl setprecision(streamsize prec)
	{	// manipulator to set precision
	return (_Smanip<streamsize>(&spfun, prec));
	}

_CRTIMP2 _Smanip<streamsize> __cdecl setw(streamsize wide)
	{	// manipulator to set width
	return (_Smanip<streamsize>(&swfun, wide));
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\iosptrs.cpp ===
// iosptrs -- iostream object pointers for Microsoft
#include <iostream>
_STD_BEGIN

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

		// OBJECT DECLARATIONS
_CRTIMP2 istream *_Ptr_cin = 0;
_CRTIMP2 ostream *_Ptr_cout = 0;
_CRTIMP2 ostream *_Ptr_cerr = 0;
_CRTIMP2 ostream *_Ptr_clog = 0;

		// WIDE OBJECTS
_CRTIMP2 wistream *_Ptr_wcin = 0;
_CRTIMP2 wostream *_Ptr_wcout = 0;
_CRTIMP2 wostream *_Ptr_wcerr = 0;
_CRTIMP2 wostream *_Ptr_wclog = 0;
_STD_END

_C_STD_BEGIN
		// FINALIZATION CODE
_EXTERN_C
#define NATS	10	/* fclose, xgetloc, locks, facet free, etc. */

		/* static data */
static void (*atfuns[NATS])(void) = {0};
static size_t atcount = {NATS};

_CRTIMP2 void __cdecl _Atexit(void (__cdecl *pf)())
	{	// add to wrapup list
	if (atcount == 0)
		abort();	/* stack full, give up */
	else
		atfuns[--atcount] = pf;
	}
_END_EXTERN_C

struct _Init_atexit
	{	// controller for atexit processing
	~_Init_atexit()
		{	// process wrapup functions
		while (atcount < NATS)
			(*atfuns[atcount++])();
		}
	};

static std::_Init_locks initlocks;
static _Init_atexit init_atexit;

char _PJP_CPP_Copyright[] =
	"Copyright (c) 1992-2001 by P.J. Plauger,"
	" licensed by Dinkumware, Ltd."
	" ALL RIGHTS RESERVED.";
_C_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\locale0.cpp ===
// locale0 -- class locale basic member functions
#include <climits>
#include <locale>
#include <xdebug>

struct _Fac_node
	{	// node for lazy facet recording
	_Fac_node(_Fac_node *_Nextarg, std::locale::facet *_Facptrarg)
		: _Next(_Nextarg), _Facptr(_Facptrarg)
		{	// construct a node with value
		}

	~_Fac_node()
		{	// destroy a facet
		_DELETE_CRT(_Facptr->_Decref());
		}

	_Fac_node *_Next;
	std::locale::facet *_Facptr;
	};

static _Fac_node *_Fac_head = 0;

_C_STD_BEGIN
_EXTERN_C
void __cdecl _Fac_tidy()
	{	// destroy lazy facets
	std::_Lockit lock(_LOCK_LOCALE);	// prevent double delete
	for (; _Fac_head != 0; )
		{	// destroy a lazy facet node
		_Fac_node *nodeptr = _Fac_head;
		_Fac_head = nodeptr->_Next;
		_DELETE_CRT(nodeptr);
		}
	}

void __cdecl _Deletegloballocale(void *ptr)
	{	// delete a global locale reference
	std::locale::_Locimp *locptr = *(std::locale::_Locimp **)ptr;
	if (locptr != 0)
		_DELETE_CRT(locptr->_Decref());
	}

static std::locale::_Locimp *global_locale = 0;	// pointer to current locale

static void __cdecl tidy_global()
	{	// delete static global locale reference
	std::_Lockit lock(_LOCK_LOCALE);	// prevent double delete
	_Deletegloballocale(&global_locale);
	}

std::locale::_Locimp *__cdecl _Getgloballocale()
	{	// return pointer to current locale
	return (global_locale);
	}

void __cdecl _Setgloballocale(void *ptr)
	{	// alter pointer to current locale
	static bool registered = false;

	if (!registered)
		{	// register cleanup first time
		registered = true;
		::_Atexit(&tidy_global);
		}
	global_locale = (std::locale::_Locimp *)ptr;
	}
_END_EXTERN_C
_C_STD_END

_STD_BEGIN

 #pragma warning(disable: 4786)

static locale classic_locale(_Noinit);	// "C" locale object, uninitialized
locale::_Locimp *locale::_Locimp::_Clocptr = 0;	// pointer to classic_locale
int locale::id::_Id_cnt = 0;	// unique id counter for facets

_TEMPLATE_STAT const size_t ctype<char>::table_size =
	1 << CHAR_BIT;	// size of ctype mapping table, typically 256

locale::locale() _THROW0()
	: _Ptr(_Init())
	{	// construct from current locale
	::_Getgloballocale()->_Incref();
	}

const locale& __cdecl locale::classic()
	{	// get reference to "C" locale
	_Init();
	return (classic_locale);
	}

locale __cdecl locale::empty()
	{	// make empty transparent locale
	_Init();
	return (locale(_NEW_CRT _Locimp(true)));
	}

const locale::facet *locale::_Getfacet(size_t id) const
	{	// look up a facet in locale object
	const facet *facptr = id < _Ptr->_Facetcount
		? _Ptr->_Facetvec[id] : 0;	// null if id off end
	if (facptr != 0 || !_Ptr->_Xparent)
		return (facptr);	// found facet or not transparent, return pointer
	else
		{	// look in current locale
		locale::_Locimp *_Ptr = ::_Getgloballocale();
		return (id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[id]	// get from current locale
			: 0);	// no entry in current locale
		}
	}

bool locale::operator==(const locale& loc) const
	{	// compare locales for equality
	return (_Ptr == loc._Ptr
		|| name().compare("*") != 0 && name().compare(loc.name()) == 0);
	}

locale::_Locimp *__cdecl locale::_Init()
	{	// setup global and "C" locales
	locale::_Locimp *_Ptr = ::_Getgloballocale();
	if (_Ptr == 0)
		{	// lock and test again
		_Lockit lock(_LOCK_LOCALE);	// prevent double initialization

		_Ptr = ::_Getgloballocale();
		if (_Ptr == 0)
			{	// create new locales
			::_Setgloballocale(_Ptr = _NEW_CRT _Locimp);
			_Ptr->_Catmask = all;	// set current locale to "C"
			_Ptr->_Name = "C";

			_Locimp::_Clocptr = _Ptr;	// set classic to match
			_Locimp::_Clocptr->_Incref();
			new (&classic_locale) locale(_Locimp::_Clocptr);
			}
		}
	return (_Ptr);
	}

void locale::facet::_Register()
	{	// queue up lazy facet for destruction
	if (_Fac_head == 0)
		::_Atexit(&_Fac_tidy);
	
	_Fac_head = _NEW_CRT _Fac_node(_Fac_head, this);
	}

locale::_Locimp::_Locimp(bool transparent)
	: locale::facet(1), _Facetvec(0), _Facetcount(0),
		_Catmask(none), _Xparent(transparent), _Name("*")
	{	// construct an empty _Locimp
	}

locale::_Locimp::~_Locimp()
	{	// destruct a _Locimp
	_Lockit lock(_LOCK_LOCALE);	// prevent double delete
	for (size_t count = _Facetcount; 0 < count; )
		if (_Facetvec[--count] != 0)
			_DELETE_CRT(_Facetvec[count]->_Decref());
	free(_Facetvec);
	}

_Locinfo::_Locinfo(const char *locname)
	: _Lock(_LOCK_LOCALE)
	{	// switch to a named locale
	_Oldlocname = setlocale(LC_ALL, 0);
	_Newlocname = locname == 0
		|| (locname = setlocale(LC_ALL, locname)) == 0
			? "*" : locname;
	}

_Locinfo::~_Locinfo()
	{	// destroy a _Locinfo object, revert locale
	if (0 < _Oldlocname.size())
		setlocale(LC_ALL, _Oldlocname.c_str());
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\ios.cpp ===
// ios_base -- ios_base basic members
#include <new>
#include <xiosbase>
#include <xdebug>
_STD_BEGIN

#define NSTDSTR	8	/* cin, wcin, cout, wcout, cerr, wcerr, clog, wclog */

extern _CRTIMP2 const streamoff
	_BADOFF = -1;	// initialize constant for bad file offset
_CRTIMP2 fpos_t _Fpz = {0};	// initialize constant for beginning of file

int ios_base::_Index = 0;	// initialize source of unique indexes
bool ios_base::_Sync = true;	// initialize synchronization flag

static ios_base *stdstr[NSTDSTR + 2] =
	{0};	// [1, NSTDSTR] hold pointers to standard streams
static char stdopens[NSTDSTR + 2] =
	{0};	// [1, NSTDSTR] hold open counts for standard streams

void ios_base::clear(iostate state, bool reraise)
	{	// set state, possibly reraise exception
	_Mystate = (iostate)(state & _Statmask);
	if ((_Mystate & _Except) == 0)
		;
	else if (reraise)
		_RERAISE;
	else if (_Mystate & _Except & badbit)
		_THROW(failure, "ios_base::badbit set");
	else if (_Mystate & _Except & failbit)
		_THROW(failure, "ios_base::failbit set");
	else
		_THROW(failure, "ios_base::eofbit set");
	}

ios_base& ios_base::copyfmt(const ios_base& right)
	{	// copy format stuff
	if (this != &right)
		{	// copy all but _Mystate
		_Tidy();
		*_Ploc = *right._Ploc;
		_Fmtfl = right._Fmtfl;
		_Prec = right._Prec;
		_Wide = right._Wide;
		_Iosarray *p = right._Arr;

		for (_Arr = 0; p != 0; p = p->_Next)
			if (p->_Lo != 0 || p->_Vp != 0)
				{	// copy over nonzero array values
				iword(p->_Index) = p->_Lo;
				pword(p->_Index) = p->_Vp;
				}

		for (_Fnarray *q = right._Calls; q != 0; q = q->_Next)
			register_callback(q->_Pfn, q->_Index);	// copy callbacks

		_Callfns(copyfmt_event);	// call callbacks
		exceptions(right._Except);	// cause any throw at end
		}
	return (*this);
	}

locale ios_base::imbue(const locale& loc)
	{	// set locale to argument
	locale oldlocale = *_Ploc;
	*_Ploc = loc;
	_Callfns(imbue_event);
	return (oldlocale);
	}

void ios_base::register_callback(event_callback pfn, int idx)
	{	// register event handler
	_Calls = _NEW_CRT _Fnarray(idx, pfn, _Calls);
	}

ios_base::~ios_base()
	{	// destroy the object
	if (0 < _Stdstr && 0 < --stdopens[_Stdstr])
		return;
	_Tidy();
	_DELETE_CRT(_Ploc);
	}

void ios_base::_Callfns(event ev)
	{	// call all event handlers, reporting event
	for (_Fnarray *p = _Calls; p != 0; p = p->_Next)
		(*p->_Pfn)(ev, *this, p->_Index);
	}

ios_base::_Iosarray& ios_base::_Findarr(int idx)
	{	// locate or make a variable array element
	static _Iosarray stub(0, 0);
	_Iosarray *p, *q;

	if (idx < 0)
		{	// handle bad index
		setstate(badbit);
		return (stub);
		}

	for (p = _Arr, q = 0; p != 0; p = p->_Next)
		if (p->_Index == idx)
			return (*p);	// found element, return it
		else if (q == 0 && p->_Lo == 0 && p->_Vp == 0)
			q = p;	// found recycling candidate

	if (q != 0)
		{	// recycle existing element
		q->_Index = idx;
		return (*q);
		}

	_Arr = _NEW_CRT _Iosarray(idx, _Arr);	// make a new element
	return (*_Arr);
	}

void ios_base::_Addstd()
	{	// add standard stream to destructor list
	_Lockit lock(_LOCK_STREAM);

	for (; ++_Stdstr < NSTDSTR; )
		if (stdstr[_Stdstr] == 0 || stdstr[_Stdstr] == this)
			break;	// found a candidate

	stdstr[_Stdstr] = this;
	++stdopens[_Stdstr];
	}

void ios_base::_Init()
	{	// initialize a new ios_base
	_Ploc = _NEW_CRT locale;
	_Except = goodbit;
	_Fmtfl = skipws | dec;
	_Prec = 6;
	_Wide = 0;
	_Arr = 0;
	_Calls = 0;
	clear(goodbit);
	}

void ios_base::_Tidy()
	{	// discard storage for an ios_base
	_Callfns(erase_event);
	_Iosarray *q1, *q2;

	for (q1 = _Arr; q1 != 0; q1 = q2)
		q2 = q1->_Next, _DELETE_CRT(q1);	// delete array elements
	_Arr = 0;

	_Fnarray *q3, *q4;
	for (q3 = _Calls; q3 != 0; q3 = q4)
		q4 = q3->_Next, _DELETE_CRT(q3);	// delete callback elements
	_Calls = 0;
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newaop.cpp ===
// newaop -- operator new[](size_t) REPLACEABLE
#include <new>

 #if !_VC6SP2 || _DLL
void *__cdecl operator new[](size_t count) _THROW1(std::bad_alloc)
	{	// try to allocate count bytes for an array
	return (operator new(count));
	}
 #endif /* !_VC6SP2 || _DLL */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newaop2_s.cpp ===
//  newaop2_s.cpp - version of newaop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newaop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newaop2.cpp ===
// newaop2 -- operator new[](size_t, const nothrow_t&) REPLACEABLE
#include <new>

void *__cdecl operator new[](::size_t count, const std::nothrow_t& x)
	_THROW0()
	{	// try to allocate count bytes for an array
	return (operator new(count, x));
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\locale.cpp ===
// locale -- class locale member functions
#include <cstdlib>
#include <istream>
#include <locale>
#include <xdebug>
#include <dbgint.h>

_C_STD_BEGIN
_EXTERN_C
std::locale::_Locimp *__cdecl _Getgloballocale();

void __cdecl _Setgloballocale(void *);
_END_EXTERN_C
_C_STD_END

_STD_BEGIN

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

locale::locale(const locale& loc, const locale& other, category cat)
	: _Ptr(_NEW_CRT _Locimp(*loc._Ptr))
	{	// construct a locale by copying named facets
	_TRY_BEGIN
	_Locinfo _Lobj(loc._Ptr->_Catmask, loc._Ptr->_Name.c_str());
	_Locimp::_Makeloc(_Lobj._Addcats(cat & other._Ptr->_Catmask,
		other._Ptr->_Name.c_str()), cat, _Ptr, &other);
	_CATCH_ALL
	_DELETE_CRT(_Ptr->_Decref());
	_RERAISE;
	_CATCH_END
	}

locale::locale(const char *locname, category cat)
	: _Ptr(_NEW_CRT _Locimp)
	{	// construct a locale with named facets
	_TRY_BEGIN
	_Init();
	_Locinfo _Lobj(cat, locname);

	if (_Lobj._Getname().compare("*") == 0)
		_THROW(runtime_error, "bad locale name");
	_Locimp::_Makeloc(_Lobj, cat, _Ptr, 0);
	_CATCH_ALL
	_DELETE_CRT(_Ptr->_Decref());
	_RERAISE;
	_CATCH_END
	}

locale::locale(const locale& loc, const char *locname, category cat)
	: _Ptr(_NEW_CRT _Locimp(*loc._Ptr))
	{	// construct a locale by copying, replacing named facets
	_TRY_BEGIN
	_Locinfo _Lobj(loc._Ptr->_Catmask, loc._Ptr->_Name.c_str());
	bool _Hadname = _Lobj._Getname().compare("*") != 0;
	_Lobj._Addcats(cat, locname);

	if (_Hadname && _Lobj._Getname().compare("*") == 0)
		_THROW(runtime_error, "bad locale name");
	_Locimp::_Makeloc(_Lobj, cat, _Ptr, 0);
	_CATCH_ALL
	_DELETE_CRT(_Ptr->_Decref());
	_RERAISE;
	_CATCH_END
	}

_DEPRECATED locale& locale::_Addfac(facet *fac, size_t id, size_t catmask)
	{	// add a facet, copying on write
	if (1 < _Ptr->_Refs)
		{	// shared, make private copy before altering
		_Ptr->_Decref();
		_Ptr = _NEW_CRT _Locimp(*_Ptr);
		}
	_Ptr->_Addfac(fac, id);

	if (catmask != 0)
		_Ptr->_Name = "*";
	return (*this);
	}

locale __cdecl locale::global(const locale& loc)
	{	// change global locale
	locale _Oldglobal;
	_Lockit lock(_LOCK_LOCALE);
	locale::_Locimp *_Ptr = ::_Getgloballocale();

	if (_Ptr != loc._Ptr)
		{	// set new global locale
		_DELETE_CRT(_Ptr->_Decref());
		::_Setgloballocale(_Ptr = loc._Ptr);
		_Ptr->_Incref();
		category _Cmask = _Ptr->_Catmask & all;
		if (_Cmask == all)
			setlocale(LC_ALL, _Ptr->_Name.c_str());
		else
			for (int catindex = 0; catindex <= _X_MAX; ++catindex)
				if ((_CATMASK(catindex) & _Cmask) != 0)
					setlocale(catindex, _Ptr->_Name.c_str());
		}
	return (_Oldglobal);
	}

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

typedef ctype<char> _T1;
typedef num_get<char, _Initer> _T2;
typedef num_put<char, _Outiter> _T3;
typedef numpunct<char> _T4;
// others moved to wlocale and xlocale to ease subsetting
typedef codecvt<char, char, mbstate_t> _Tc1;

_TEMPLATE_STAT locale::id ctype<char>::id;


locale::_Locimp *__cdecl locale::_Locimp::_Makeloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup a new locale
	ADDFAC(_T1, cat, ptrimp, ptrloc);
	ADDFAC(_T2, cat, ptrimp, ptrloc);
	ADDFAC(_T3, cat, ptrimp, ptrloc);
	ADDFAC(_T4, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Tc1, cat, ptrimp, ptrloc);

	_Locimp::_Makexloc(lobj, cat, ptrimp, ptrloc);
	_Locimp::_Makewloc(lobj, cat, ptrimp, ptrloc);
#ifdef _NATIVE_WCHAR_T_DEFINED
	_Locimp::_Makeushloc(lobj, cat, ptrimp, ptrloc);
#endif
	ptrimp->_Catmask |= cat;
	ptrimp->_Name = lobj._Getname();
	return (ptrimp);
	}

locale::_Locimp::_Locimp(const locale::_Locimp& imp)
	: locale::facet(1), _Facetvec(0), _Facetcount(imp._Facetcount),
		_Catmask(imp._Catmask), _Xparent(imp._Xparent), _Name(imp._Name)
	{	// construct a _Locimp from a copy
	if (&imp == _Clocptr)
		_Makeloc(_Locinfo(), locale::all, this, 0);
	else
		{	// lock to keep facets from disappearing
		_Lockit lock(_LOCK_LOCALE);
		if (0 < _Facetcount)
			{	// copy over nonempty facet vector
			if ((_Facetvec = (locale::facet **)_malloc_crt(
				_Facetcount * sizeof (locale::facet *))) == 0)
				_Nomemory();
			for (size_t count = _Facetcount; 0 < count; )
				{	// copy over facet pointers
				locale::facet *ptrfac = imp._Facetvec[--count];
				if ((_Facetvec[count] = ptrfac) != 0)
					ptrfac->_Incref();
				}
			}
		}
	}

void locale::_Locimp::_Addfac(locale::facet *ptrfac, size_t id)
	{	// add a facet to a locale
	_Lockit lock(_LOCK_LOCALE);
	const size_t MINCAT = 40;	// minimum number of facets in a locale

	if (_Facetcount <= id)
		{	// make facet vector larger
		size_t count = id + 1;
		if (count < MINCAT)
			count = MINCAT;
		locale::facet **ptrnewvec = (locale::facet **)_realloc_crt(_Facetvec,
			count * sizeof (locale::facet **));
		if (ptrnewvec == 0)
			_Nomemory();

		_Facetvec = ptrnewvec;
		for (; _Facetcount < count; ++_Facetcount)
			_Facetvec[_Facetcount] = 0;
		}

	ptrfac->_Incref();
	if (_Facetvec[id] != 0)
		_DELETE_CRT(_Facetvec[id]->_Decref());
	_Facetvec[id] = ptrfac;
	}

_CRTIMP2 _Locinfo::_Locinfo(int cat, const char *locname)
	: _Lock(_LOCK_LOCALE)
	{	// capture a named locale
	_Oldlocname = setlocale(LC_ALL, 0);
	_Addcats(cat, locname);
	}

_CRTIMP2 _Locinfo& _Locinfo::_Addcats(int cat, const char *locname)
	{	// merge in another named locale
	const char *oldlocname = 0;
	if (locname[0] == '*' && locname[1] == '\0')
		;
	else if (cat == 0)
		oldlocname = setlocale(LC_ALL, 0);
	else if (cat == _M_ALL)
		oldlocname = setlocale(LC_ALL, locname);
	else
		{	// alter selected categories
		for (int catindex = 0; catindex <= _X_MAX; ++catindex)
			if ((_CATMASK(catindex) & cat) != 0)
				setlocale(catindex, locname);
		oldlocname = setlocale(LC_ALL, locname);
		}
	if (oldlocname == 0)
		_Newlocname = "*";
	else if (_Newlocname.compare("*") != 0)
		_Newlocname = oldlocname;
	return (*this);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newaop_s.cpp ===
//  newaop_s.cpp - version of newaop.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newaop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newop.cpp ===
// newop operator new(size_t) for Microsoft C++
#include <cstdlib>
#include <new>

_C_LIB_DECL
int __cdecl _callnewh(size_t size) _THROW1(_STD bad_alloc);
_END_C_LIB_DECL

void *__cdecl operator new(size_t size) _THROW1(_STD bad_alloc)
	{	// try to allocate size bytes
	void *p;
	while ((p = malloc(size)) == 0)
		if (_callnewh(size) == 0)
			_STD _Nomemory();
	return (p);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V2.3:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newop2.cpp ===
// newop2 operator new(size_t, const nothrow_t&) for Microsoft C++
#include <cstdlib>
#include <new>

_C_LIB_DECL
int __cdecl _callnewh(size_t count) _THROW1(_STD bad_alloc);
_END_C_LIB_DECL

void *__cdecl operator new(size_t count,
	const std::nothrow_t&) _THROW0()
	{	// try to allocate count bytes
	void *p;
	_TRY_BEGIN
	while ((p = malloc(count)) == 0)
		{	// buy more memory or return null pointer
		if (_callnewh(count) == 0)
			break;
		}
	_CATCH_ALL
	p = 0;
	_CATCH_END
	return (p);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newop_s.cpp ===
//  newop_s.cpp - version of newop.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\nothrow.cpp ===
// nothrow -- define nothrow object
#include <new>
_STD_BEGIN

const nothrow_t nothrow = nothrow_t();	// define nothrow
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\nomemory.cpp ===
// nomemory -- report out of memory
#include <new>
_STD_BEGIN

_CRTIMP2 void __cdecl _Nomemory()
	{	// report out of memory
	static const bad_alloc nomem;
	_RAISE(nomem);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\newop2_s.cpp ===
//  newop2_s.cpp - version of newop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\raisehan.cpp ===
// raisehan -- pointer to raise handler
#include <exception>
_STD_BEGIN

_CRTIMP2 _Prhand _Raise_handler = 0;	// define raise handler pointer as null

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\stdthrow.cpp ===
// throw -- terminate on thrown exception REPLACEABLE
#include <cstdio>
#include <cstdlib>
#include <exception>
_STD_BEGIN

_CRTIMP2 void __cdecl _Throw(const exception& ex)
	{	// report error and die
	const char *s2 = ex.what();
	fputs("exception: ", _cpp_stderr);
	fputs(s2 != 0 ? s2 : "unknown", _cpp_stderr);
	fputs("\n", _cpp_stderr);
	abort();
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\stdhndlr.cpp ===
// handler.cpp -- set_new_handler for Microsoft
#include <new>

typedef int (__cdecl *new_hand)(size_t);
new_hand _set_new_handler(new_hand);

_STD_BEGIN
static new_handler _New_handler;

int __cdecl _New_handler_interface(size_t) _THROW1(bad_alloc)
	{	// interface to existing Microsoft _callnewh mechanism
	_New_handler();
	return (1);
	}

_CRTIMP2 new_handler __cdecl set_new_handler(new_handler pnew) _THROW0()
	{	// remove current handler
	_Lockit _Lock(_LOCK_MALLOC);	// lock thread to ensure atomicity
	new_handler pold = _New_handler;
	_New_handler = pnew;
	_set_new_handler(pnew ? _New_handler_interface : 0);
	return (pold);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\ushcerr.cpp ===
// wcerr -- initialize standard wide error stream
// This wcerr is unsigned short version of wcerr
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wcerr.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\string.cpp ===
// string -- template string support functions
#include <istream>
_STD_BEGIN


_CRTIMP2 void _String_base::_Xlen() const
	{	// report a length_error
	_THROW(length_error, "string too long");
	}

_CRTIMP2 void _String_base::_Xran() const
	{	// report an out_of_range error
	_THROW(out_of_range, "invalid string position");
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\ushcin.cpp ===
// wcin -- initialize standard wide error stream
// This wcin is unsigned short version of wcin
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wcin.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\uncaught.cpp ===
// uncaught -- uncaught_exception for Microsoft
 #if 1300 <= _MSC_VER
  #include <eh.h>
  #include <exception>
_STD_BEGIN

_CRTIMP2 bool __cdecl uncaught_exception()
	{	// report if handling a throw
	return (__uncaught_exception());
	}

_STD_END
 #else /* 1300 <= _MSC_VER */
  #include <exception>
_STD_BEGIN

_CRTIMP2 bool __cdecl uncaught_exception()
	{	// report if handling a throw -- dummy
	return (false);
	}

_STD_END
 #endif /* 1300 <= _MSC_VER */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\ushcout.cpp ===
// wcout -- initialize standard wide error stream
// This wcout is unsigned short version of wcout
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wcout.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\strstrea.cpp ===
// strstreambuf -- strstreambuf basic members
#include <climits>
#include <cstdlib>
#include <cstring>
#include <strstream>
#include <xdebug>

 #pragma warning(disable:4244 4097)
_STD_BEGIN

_CRTIMP2 istrstream::~istrstream()
	{	// destroy an istrstream
	}

_CRTIMP2 ostrstream::ostrstream(char *ptr, streamsize count,
	ios_base::openmode mode)
	: ostream(&_Mysb),
	_Mysb(ptr, count, ptr == 0 || (mode & app) == 0 ? ptr : ptr + strlen(ptr))
	{	// construct with [ptr, ptr + count)
	}

_CRTIMP2 ostrstream::~ostrstream()
	{	// destroy an ostrstream
	}

_CRTIMP2 strstream::strstream(char *ptr, streamsize count,
	ios_base::openmode mode)
	: iostream(&_Mysb),
	_Mysb(ptr, count, ptr == 0 || (mode & app) == 0 ? ptr : ptr + strlen(ptr))
	{	// construct with [ptr, ptr + count)
	}

_CRTIMP2 strstream::~strstream()
	{	// destroy a strstream
	}

_CRTIMP2 strstreambuf::~strstreambuf()
	{	// destroy a strstreambuf
	_Tidy();
	}

_CRTIMP2 void strstreambuf::freeze(bool freezeit)
	{	// freeze or unfreeze writing
	if (freezeit && !(_Strmode & _Frozen))
		{	// disable writing
		_Strmode |= _Frozen;
		_Pendsave = epptr();
		setp(pbase(), pptr(), eback());
		}
	else if (!freezeit && _Strmode & _Frozen)
		{	// re-enable writing
		_Strmode &= ~_Frozen;
		setp(pbase(), pptr(), _Pendsave);
		}
	}

_CRTIMP2 int strstreambuf::overflow(int meta)
	{	// try to extend write area
	if (meta == EOF)
		return (0);	// nothing to write
	else if (pptr() != 0 && pptr() < epptr())
		return ((unsigned char)(*_Pninc() = meta));	// room in buffer
	else if (!(_Strmode & _Dynamic)
		|| _Strmode & (_Constant | _Frozen))
		return (EOF);	// can't extend
	else
		{	// okay to extend
		int oldsize = gptr() == 0 ? 0 : epptr() - eback();
		int newsize = oldsize;
		int inc = newsize / 2 < _Minsize
			? _Minsize : newsize / 2;	// grow by 50 per cent if possible
		_Minsize = _MINSIZE;	// back to default for future growth
		char *ptr = 0;

		while (0 < inc && INT_MAX - inc < newsize)
			inc /= 2;	// reduce growth increment if too big
		if (0 < inc)
			{	// room to grow, increase size
			newsize += inc;
			ptr = _Palloc != 0 ? (char *)(*_Palloc)(newsize)
				: _NEW_CRT char[newsize];
			}
		if (ptr == 0)
			return (EOF);	// couldn't grow, return failure

		if (0 < oldsize)
			memcpy(ptr, eback(), oldsize);	// copy existing buffer
		if (!(_Strmode & _Allocated))
			;	// no buffer to free
		else if (_Pfree != 0)
			(*_Pfree)(eback());	// free with function call
		else
			_DELETE_CRT_VEC(eback());	// free by deleting array

		_Strmode |= _Allocated;
		if (oldsize == 0)
			{	// set up new buffer
			_Seekhigh = ptr;
			setp(ptr, ptr + newsize);
			setg(ptr, ptr, ptr);
			}
		else
			{	// revise old pointers
			_Seekhigh = _Seekhigh - eback() + ptr;
			setp(pbase() - eback() + ptr, pptr() - eback() + ptr,
				ptr + newsize);
			setg(ptr, gptr() - eback() + ptr, pptr() + 1);
			}

		return ((unsigned char)(*_Pninc() = meta));
		}
	}

_CRTIMP2 int strstreambuf::pbackfail(int meta)
	{	// try to putback a character
	if (gptr() == 0 || gptr() <= eback() || meta != EOF
			&& (unsigned char)meta != (unsigned char)gptr()[-1]
			&& _Strmode & _Constant)
		return (EOF);	// can't put it back
	else
		{	// safe to back up
		gbump(-1);
		return (meta == EOF ? 0 : (unsigned char)(*gptr() = meta));
		}
	}

_CRTIMP2 int strstreambuf::underflow()
	{	// read if read position available
	if (gptr() == 0)
		return (EOF);	// no read buffer
	else if (gptr() < egptr())
		return ((unsigned char)*gptr());	// char in buffer, read it
	else if (pptr() == 0 || pptr() <= gptr() && _Seekhigh <= gptr())
		return (EOF);	// no write buffer to read
	else
		{	// update _Seekhigh and expand read region
		if (_Seekhigh < pptr())
			_Seekhigh = pptr();
		setg(eback(), gptr(), _Seekhigh);
		return ((unsigned char)*gptr());
		}
	}

_CRTIMP2 streampos strstreambuf::seekoff(streamoff off,
	ios_base::seekdir way, ios_base::openmode which)
	{	// seek by specified offset
	if (pptr() != 0 && _Seekhigh < pptr())
		_Seekhigh = pptr();	// update high water mark

	if (which & ios_base::in && gptr() != 0)
		{	// set input (and maybe output) pointer
		if (way == ios_base::end)
			off += _Seekhigh - eback();	// seek from end
		else if (way == ios_base::cur
			&& !(which & ios_base::out))
			off += gptr() - eback();	// seek from current position
		else if (way != ios_base::beg || off == _BADOFF)
			off = _BADOFF;	// invalid seek
		if (0 <= off && off <= _Seekhigh - eback())
			{	// seek from beginning, set one or two pointers
			gbump(eback() - gptr() + off);
			if (which & ios_base::out && pptr() != 0)
				setp(pbase(), gptr(), epptr());
			}
		else
			off = _BADOFF;	// invalid seek from beginning
		}
	else if (which & ios_base::out && pptr() != 0)
		{	// set only output pointer
		if (way == ios_base::end)
			off += _Seekhigh - eback();	// seek from end
		else if (way == ios_base::cur)
			off += pptr() - eback();	// seek from current position
		else if (way != ios_base::beg || off == _BADOFF)
			off = _BADOFF;	// invalid seek
		if (0 <= off && off <= _Seekhigh - eback())
			pbump(eback() - pptr() + off);	// seek from beginning
		else
			off = _BADOFF;	// invalid seek from beginning
		}
	else	// nothing to set
		off = _BADOFF;
	return (streampos(off));
	}

_CRTIMP2 streampos strstreambuf::seekpos(streampos sp,
		ios_base::openmode which)
	{	// seek to memorized position
	streamoff off = (streamoff)sp;
	if (pptr() != 0 && _Seekhigh < pptr())
		_Seekhigh = pptr();	// update high water mark

	if (off == _BADOFF)
		;	// invalid seek
	else if (which & ios_base::in && gptr() != 0)
		{	// set input (and maybe output) pointer
		if (0 <= off && off <= _Seekhigh - eback())
			{	// set valid offset
			gbump(eback() - gptr() + off);
			if (which & ios_base::out && pptr() != 0)
				setp(pbase(), gptr(), epptr());
			}
		else
			off = _BADOFF;	// offset invalid, don't seek
		}
	else if (which & ios_base::out && pptr() != 0)
		{	// set output pointer
		if (0 <= off && off <= _Seekhigh - eback())
			pbump(eback() - pptr() + off);
		else
			off = _BADOFF;	// offset invalid, don't seek
		}
	else	// nothing to set
		off = _BADOFF;
	return (streampos(off));
	}

_CRTIMP2 void strstreambuf::_Init(streamsize count, char *gp, char *pp,
	_Strstate mode)
	{	// initialize with possibly static buffer
	streambuf::_Init();
	_Minsize = _MINSIZE;
	_Pendsave = 0;
	_Seekhigh = 0;
	_Palloc = 0;
	_Pfree = 0;
	_Strmode = mode;

	if (gp == 0)
		{	// make dynamic
		_Strmode |= _Dynamic;
		if (_Minsize < count)
			_Minsize = count;
		}
	else
		{	// make static
		int size = count < 0 ? INT_MAX : count == 0 ? (int)strlen(gp) : count;
		_Seekhigh = gp + size;

		if (pp == 0)
			setg(gp, gp, gp + size);	// set read pointers only
		else
			{	// make writable too
			if (pp < gp)
				pp = gp;
			else if (gp + size < pp)
				pp = gp + size;
			setp(pp, gp + size);
			setg(gp, gp, pp);
			}
		}
	}

_CRTIMP2 void strstreambuf::_Tidy()
	{	// free any allocated storage
	if ((_Strmode & (_Allocated | _Frozen)) != _Allocated)
		;	// no buffer to free
	else if (_Pfree != 0)
		(*_Pfree)(eback());	// free with function call
	else
		_DELETE_CRT_VEC(eback());	// free by deleting array

	_Seekhigh = 0;
	_Strmode &= ~(_Allocated | _Frozen);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\ushclog.cpp ===
// wclog -- initialize standard wide error stream
// This wclog is unsigned short version of wclog
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wclog.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\ushiostr.cpp ===
// ushiostream -- _UShinit members, dummy for Microsoft
// unsigned short version for wiostram
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>

_STD_BEGIN
_CRTIMP2 wistream *_Ptr_wcin = 0;
_CRTIMP2 wostream *_Ptr_wcout = 0;
_CRTIMP2 wostream *_Ptr_wcerr = 0;
_CRTIMP2 wostream *_Ptr_wclog = 0;
_STD_END
#include "wiostrea.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wcerr.cpp ===
// wcerr -- initialize standard wide error stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks initlocks;
static wfilebuf wferr(_cpp_stderr);
_CRTIMP2 wostream wcerr(&wferr);

		// INITIALIZATION CODE
struct _Init_wcerr
	{	// ensures that wcerr is initialized
	_Init_wcerr()
		{	// initialize wcerr
		_Ptr_wcerr = &wcerr;
		wcerr.tie(_Ptr_wcout);
		wcerr.setf(ios_base::unitbuf);
		}
	};
static _Init_wcerr init_wcerr;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wcin.cpp ===
// wcin -- initialize standard wide input stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks initlocks;
static wfilebuf wfin(_cpp_stdin);
_CRTIMP2 wistream wcin(&wfin);

		// INITIALIZATION CODE
struct _Init_wcin
	{	// ensures that wcin is initialized
	_Init_wcin()
		{	// initialize wcin
		_Ptr_wcin = &wcin;
		wcin.tie(_Ptr_wcout);
		}
	};
static _Init_wcin init_wcin;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wcout.cpp ===
// wcout -- initialize standard wide output stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks initlocks;
static wfilebuf wfout(_cpp_stdout);
_CRTIMP2 wostream wcout(&wfout);

		// INITIALIZATION CODE
struct _Init_wcout
	{	// ensures that wcout is initialized
	_Init_wcout()
		{	// initialize wcout
		_Ptr_wcout = &wcout;
		if (_Ptr_wcin != 0)
			_Ptr_wcin->tie(_Ptr_wcout);
		if (_Ptr_wcerr != 0)
			_Ptr_wcerr->tie(_Ptr_wcout);
		if (_Ptr_wclog != 0)
			_Ptr_wclog->tie(_Ptr_wcout);
		}
	};
static _Init_wcout init_wcout;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wclog.cpp ===
// wclog -- initialize standard wide log stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static wfilebuf wflog(_cpp_stderr);
_CRTIMP2 wostream wclog(&wflog);

		// INITIALIZATION CODE
struct _Init_wclog
	{	// ensures that wclog is initialized
	_Init_wclog()
		{	// initialize wclog
		_Ptr_wclog = &wclog;
		wclog.tie(_Ptr_wcout);
		}
	};
static _Init_wclog init_wclog;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wctrans.c ===
/* towctrans/wctrans functions for Microsoft */
#include <string.h>
#ifndef _YVALS
#include <yvals.h>
#endif
 #pragma warning(disable:4244)

 #ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
 #endif

typedef wchar_t wctrans_t;
_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"tolower", 0},
	{"toupper", 1},
	{(const char *)0, 0}};

_CRTIMP2 wint_t (__cdecl towctrans)(wint_t c, wctrans_t val)
	{	/* translate wide character */
	return (val == 1 ? towupper(c) : towlower(c));
	}

_CRTIMP2 wctrans_t (__cdecl wctrans)(const char *name)
	{	/* find translation for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wiostrea.cpp ===
// wiostream -- _Winit members, dummy for Microsoft
#include <iostream>
_STD_BEGIN

		// OBJECT DECLARATIONS
int _Winit::_Init_cnt = -1;

_CRTIMP2 _Winit::_Winit()
	{	// initialize standard wide streams first time
	if (0 <= _Init_cnt)
		++_Init_cnt;
	else
		_Init_cnt = 1;
	}

_CRTIMP2 _Winit::~_Winit()
	{	// flush standard wide streams last time
	if (--_Init_cnt == 0)
		{	// flush standard wide streams
		if (_Ptr_wcout != 0)
			_Ptr_wcout->flush();
		if (_Ptr_wcerr != 0)
			_Ptr_wcerr->flush();
		if (_Ptr_wclog != 0)
			_Ptr_wclog->flush();
		}
_STD_END
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wctype.c ===
/* wctype function for Microsoft */
#include <string.h>
#include <wctype.h>
#ifndef _YVALS
#include <yvals.h>
#endif
_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"alnum", _ALPHA|_DIGIT},
	{"alpha", _ALPHA},
	{"cntrl", _CONTROL},
	{"digit", _DIGIT},
	{"graph", _PUNCT|_ALPHA|_DIGIT},
	{"lower", _LOWER},
	{"print", _BLANK|_PUNCT|_ALPHA|_DIGIT},
	{"punct", _PUNCT},
	{"space", _SPACE},
	{"upper", _UPPER},
	{"xdigit", _HEX},
	{(const char *)0, 0}};

#pragma warning(disable:4273)	/* inconsistent with Microsoft header */
_CRTIMP2 wctype_t (__cdecl wctype)(const char *name)
	{	/* find classification for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
#pragma warning(default:4273)
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xdateord.cpp ===
// xdateord -- look up date ordering for Microsoft
#include <cruntime.h>
#include <locale>
#include <setlocal.h>
#include <tchar.h>

_STD_BEGIN
extern "C" int __cdecl _Getdateorder()
	{	// return date order for current locale
	_TCHAR buf[2] = {0};
	GetLocaleInfo(___lc_handle_func()[LC_TIME], LOCALE_ILDATE,
		buf, sizeof (buf) / sizeof (buf[0]));
	return (buf[0] == _T('0') ? std::time_base::mdy
		: buf[0] == _T('1') ? std::time_base::dmy
		: buf[0] == _T('2') ? std::time_base::ymd
		: std::time_base::no_order);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xcosh.c ===
/* _Cosh function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 double __cdecl _Cosh(double x, double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_Dtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1.0, -1);
			return (y * (x + 0.25 / x));
			}
		switch (_Exp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\wlocale.cpp ===
// wlocale -- class locale wide member functions
#include <istream>
#include <locale>
#include <xdebug>
_STD_BEGIN

 #pragma warning(disable: 4786)

typedef char_traits<wchar_t> _Wtraits;
typedef istreambuf_iterator<wchar_t, _Wtraits> _Winiter;
typedef ostreambuf_iterator<wchar_t, _Wtraits> _Woutiter;

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

// moved from locale to ease subsetting
typedef ctype<wchar_t> _Tw1;
typedef num_get<wchar_t, _Winiter> _Tw2;
typedef num_put<wchar_t, _Woutiter> _Tw3;
typedef numpunct<wchar_t> _Tw4;
typedef collate<wchar_t> _Tw5;
typedef messages<wchar_t> _Tw6;
typedef money_get<wchar_t, _Winiter> _Tw7;
typedef money_put<wchar_t, _Woutiter> _Tw9;
typedef moneypunct<wchar_t, false> _Tw11;
typedef moneypunct<wchar_t, true> _Tw12;
typedef time_get<wchar_t, _Winiter> _Tw13;
typedef time_put<wchar_t, _Woutiter> _Tw14;
//....
typedef codecvt<wchar_t, char, mbstate_t> _Twc1;

_TEMPLATE_STAT locale::id ctype<wchar_t>::id;
_TEMPLATE_STAT locale::id codecvt<wchar_t, char, mbstate_t>::id;
_TEMPLATE_STAT locale::id time_put<wchar_t>::id;

void __cdecl locale::_Locimp::_Makewloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup wide part of a new locale
	ADDFAC(_Tw1, cat, ptrimp, ptrloc);
	ADDFAC(_Tw2, cat, ptrimp, ptrloc);
	ADDFAC(_Tw3, cat, ptrimp, ptrloc);
	ADDFAC(_Tw4, cat, ptrimp, ptrloc);
	ADDFAC(_Tw5, cat, ptrimp, ptrloc);
	ADDFAC(_Tw6, cat, ptrimp, ptrloc);
	ADDFAC(_Tw7, cat, ptrimp, ptrloc);
	ADDFAC(_Tw9, cat, ptrimp, ptrloc);
	ADDFAC(_Tw11, cat, ptrimp, ptrloc);
	ADDFAC(_Tw12, cat, ptrimp, ptrloc);
	ADDFAC(_Tw13, cat, ptrimp, ptrloc);
	ADDFAC(_Tw14, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Twc1, cat, ptrimp, ptrloc);
	}

#ifdef _NATIVE_WCHAR_T_DEFINED
typedef char_traits<unsigned short> _UShtraits;
typedef istreambuf_iterator<unsigned short, _UShtraits> _UShiniter;
typedef ostreambuf_iterator<unsigned short, _UShtraits> _UShoutiter;


// moved from locale to ease subsetting
typedef ctype<unsigned short> _Tush1;
typedef num_get<unsigned short, _UShiniter> _Tush2;
typedef num_put<unsigned short, _UShoutiter> _Tush3;
typedef numpunct<unsigned short> _Tush4;
typedef collate<unsigned short> _Tush5;
typedef messages<unsigned short> _Tush6;
typedef money_get<unsigned short, _UShiniter> _Tush7;
typedef money_put<unsigned short, _UShoutiter> _Tush9;
typedef moneypunct<unsigned short, false> _Tush11;
typedef moneypunct<unsigned short, true> _Tush12;
typedef time_get<unsigned short, _UShiniter> _Tush13;
typedef time_put<unsigned short, _UShoutiter> _Tush14;
//....
typedef codecvt<unsigned short, char, mbstate_t> _Tushc1;

_TEMPLATE_STAT locale::id ctype<unsigned short>::id;
_TEMPLATE_STAT locale::id codecvt<unsigned short, char, mbstate_t>::id;
_TEMPLATE_STAT locale::id time_put<unsigned short>::id;

void __cdecl locale::_Locimp::_Makeushloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup wide part of a new locale
	ADDFAC(_Tush1, cat, ptrimp, ptrloc);
	ADDFAC(_Tush2, cat, ptrimp, ptrloc);
	ADDFAC(_Tush3, cat, ptrimp, ptrloc);
	ADDFAC(_Tush4, cat, ptrimp, ptrloc);
	ADDFAC(_Tush5, cat, ptrimp, ptrloc);
	ADDFAC(_Tush6, cat, ptrimp, ptrloc);
	ADDFAC(_Tush7, cat, ptrimp, ptrloc);
	ADDFAC(_Tush9, cat, ptrimp, ptrloc);
	ADDFAC(_Tush11, cat, ptrimp, ptrloc);
	ADDFAC(_Tush12, cat, ptrimp, ptrloc);
	ADDFAC(_Tush13, cat, ptrimp, ptrloc);
	ADDFAC(_Tush14, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Tushc1, cat, ptrimp, ptrloc);
	}
#endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xdebug.cpp ===
// new and delete operators for debug CRT heap use by C++ Library
#if defined(_DEBUG)

#include <xdebug>
#include <crtdbg.h>

void *operator new(size_t sz, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW1(std::bad_alloc)
	{
	void *p = _malloc_dbg(sz, tag._Type, file, line);
	if (p == 0)
		std::_Nomemory();
	return p;
	}

void *operator new[](size_t sz, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW1(std::bad_alloc)
	{
	return operator new(sz, tag, file, line);
	}

void operator delete(void *p, const std::_DebugHeapTag_t &tag, char *, int)
	_THROW0()
	{
		_free_dbg(p, tag._Type);
	}

void operator delete[](void *p, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW0()
	{
		operator delete(p, tag, file, line);
	}

_STD_BEGIN
const _DebugHeapTag_t _DebugHeapTag = { _CRT_BLOCK };
_STD_END

#endif	/* _DEBUG */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xdscale.c ===
/* _Dscale function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _Dscale(double *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = (short)((ps[_D0] & _DMASK) >> _DOFF);

	if (xchar == _DMAX)
		return ((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _Dnorm(ps)))
		return (0);
	lexp += xchar;
	if (_DMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_D0] & _DSIGN ? -_Inf._Double : _Inf._Double;
		return (_INFCODE);
		}
	else if (0 < lexp)
		{	/* finite result, repack */
		ps[_D0] = ps[_D0] & ~_DMASK | (short)lexp << _DOFF;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_D0] & _DSIGN;

		ps[_D0] = (unsigned short)(1 << _DOFF
			| ps[_D0] & _DFRAC);
		if (--lexp < -(48+_DOFF))
			{	/* underflow, return +/-0 */
			ps[_D0] = sign, ps[_D1] = 0;
			ps[_D2] = 0, ps[_D3] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = (short)lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_D3] = ps[_D2], ps[_D2] = ps[_D1];
				ps[_D1] = ps[_D0], ps[_D0] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_D3] = ps[_D3] >> xexp
					| ps[_D2] << (16 - xexp);
				ps[_D2] = ps[_D2] >> xexp
					| ps[_D1] << (16 - xexp);
				ps[_D1] = ps[_D1] >> xexp
					| ps[_D0] << (16 - xexp);
				ps[_D0] >>= xexp;
				}
			ps[_D0] |= sign;
			return (_FINITE);
			}
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xdtest.c ===
/* _Dtest function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _Dtest(double *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;

	if ((ps[_D0] & _DMASK) == _DMAX << _DOFF)
		return ((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? _NANCODE : _INFCODE);
	else if ((ps[_D0] & ~_DSIGN) != 0 || ps[_D1] != 0
		|| ps[_D2] != 0 || ps[_D3] != 0)
		return (_FINITE);
	else
		return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xdnorm.c ===
/* _Dnorm function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _Dnorm(unsigned short *ps)
	{	/* normalize double fraction */
	short xchar;
	unsigned short sign = ps[_D0] & _DSIGN;

	xchar = 1;
	if ((ps[_D0] &= _DFRAC) != 0 || ps[_D1]
		|| ps[_D2] || ps[_D3])
		{	/* nonzero, scale */
		for (; ps[_D0] == 0; xchar -= 16)
			{	/* shift left by 16 */
			ps[_D0] = ps[_D1], ps[_D1] = ps[_D2];
			ps[_D2] = ps[_D3], ps[_D3] = 0;
			}
		for (; ps[_D0] < 1 << _DOFF; --xchar)
			{	/* shift left by 1 */
			ps[_D0] = ps[_D0] << 1 | ps[_D1] >> 15;
			ps[_D1] = ps[_D1] << 1 | ps[_D2] >> 15;
			ps[_D2] = ps[_D2] << 1 | ps[_D3] >> 15;
			ps[_D3] <<= 1;
			}
		for (; 1 << (_DOFF + 1) <= ps[_D0]; ++xchar)
			{	/* shift right by 1 */
			ps[_D3] = ps[_D3] >> 1 | ps[_D2] << 15;
			ps[_D2] = ps[_D2] >> 1 | ps[_D1] << 15;
			ps[_D1] = ps[_D1] >> 1 | ps[_D0] << 15;
			ps[_D0] >>= 1;
			}
		ps[_D0] &= _DFRAC;
		}
	ps[_D0] |= sign;
	return (xchar);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfcosh.c ===
/* _FCosh function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 float __cdecl _FCosh(float x, float y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_FDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1.0F, -1);
			return (y * (x + 0.25F / x));
			}
		switch (_FExp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfdnorm.c ===
/* _FDnorm function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _FDnorm(unsigned short *ps)
	{	/* normalize float fraction */
	short xchar;
	unsigned short sign = ps[_F0] & _FSIGN;

	xchar = 1;
	if ((ps[_F0] &= _FFRAC) != 0 || ps[_F1])
		{	/* nonzero, scale */
		if (ps[_F0] == 0)
			ps[_F0] = ps[_F1], ps[_F1] = 0, xchar -= 16;
		for (; ps[_F0] < 1 << _FOFF; --xchar)
			{	/* shift left by 1 */
			ps[_F0] = ps[_F0] << 1 | ps[_F1] >> 15;
			ps[_F1] <<= 1;
			}
		for (; 1 << (_FOFF + 1) <= ps[_F0]; ++xchar)
			{	/* shift right by 1 */
			ps[_F1] = ps[_F1] >> 1 | ps[_F0] << 15;
			ps[_F0] >>= 1;
			}
		ps[_F0] &= _FFRAC;
		}
	ps[_F0] |= sign;
	return (xchar);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xexp.c ===
/* _Exp function */
#include "xmath.h"
_STD_BEGIN

/* coefficients */
static const double p[] = {	/* courtesy Dr. Tim Prince */
	1.0,
	420.30235984910635,
	15132.70094680474802};
static const double q[] = {	/* courtesy Dr. Tim Prince */
	30.01511290683317,
	3362.72154416553028,
	30265.40189360949691};
static const double c1 = 22713.0 / 32768.0;
static const double c2 = 1.4286068203094172321214581765680755e-6;
static const double hugexp = HUGE_EXP;
static const double invln2 = 1.4426950408889634073599246810018921;

_CRTIMP2 short __cdecl _Exp(double *px, double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0)
		{	/* certain underflow */
		*px = 0.0;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _Inf._Double;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		double g = *px * invln2;
		short xexp = (short)(g + (g < 0.0 ? - 0.5 : + 0.5));

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_Eps._Double < g && g < _Eps._Double)
			*px = y;
		else
			{	/* g*g worth computing */
			const double z = g * g;
			const double w = (q[0] * z + q[1]) * z + q[2];

			g *= (z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2.0 * y;
			--xexp;
			}
		return (_Dscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfdtest.c ===
/* _FDtest function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _FDtest(float *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;

	if ((ps[_F0] & _FMASK) == _FMAX << _FOFF)
		return ((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? _NANCODE : _INFCODE);
	else if ((ps[_F0] & ~_FSIGN) != 0 || ps[_F1] != 0)
		return (_FINITE);
	else
		return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfsinh.c ===
/* _FSinh function */
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const float p[] = {	/* courtesy Dr. Tim Prince */
	0.00020400F,
	0.00832983F,
	0.16666737F,
	0.99999998F};

_CRTIMP2 float __cdecl _FSinh(float x, float y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_FDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0F ? x : FSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0F)
			return (x < 0.0F ? -y : y);
		if (x < 0.0F)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _FRteps._Float)
			x *= y;	/* x tiny */
		else if (x < 1.0F)
			{
			float w = x * x;

			x += ((p[0] * w + p[1]) * w + p[2]) * w * x;
			x *= y;
			}
		else if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1.0F, -1);
			x = y * (x - 0.25F / x);
			}
		else
			switch (_FExp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xgetwctype.c ===
/* _Getwctype -- return character classification flags for wide character */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>

_STD_BEGIN
_CRTIMP2 short __cdecl _Getwctype(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* return character classification flags for _Ch */
	short _Mask;
	return ((short)(__crtGetStringTypeW(CT_CTYPE1, &_Ch, 1,
		(LPWORD)&_Mask, _Ctype->_Page, _Ctype->_Hand) == 0
		? 0 : _Mask));
	}

_CRTIMP2 const wchar_t * __cdecl _Getwctypes(
	const wchar_t *_First, const wchar_t *_Last,
		short *_Dest, const _Ctypevec *_Ctype)
	{	/* get mask sequence for elements in [_First, _Last) */
	__crtGetStringTypeW(CT_CTYPE1, _First, (int)(_Last - _First),
		(LPWORD)_Dest, _Ctype->_Page, _Ctype->_Hand);
	return (_Last);		
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfexp.c ===
/* _FExp function */
#include "xmath.h"
_STD_BEGIN

static const float p[] = {	/* courtesy Dr. Tim Prince */
	1.0F,
	60.09114349F};
static const float q[] = {	/* courtesy Dr. Tim Prince */
	12.01517514F,
	120.18228722F};
static const float c1 = (22713.0F / 32768.0F);
static const float c2 = 1.4286068203094172321214581765680755e-6F;
static const float hugexp = FHUGE_EXP;
static const float invln2 = 1.4426950408889634073599246810018921F;

_CRTIMP2 short __cdecl _FExp(float *px, float y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0F)
		{	/* certain underflow */
		*px = 0.0F;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _FInf._Float;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		float g = *px * invln2;
		short xexp = (short)(g + (g < 0.0F ? - 0.5F : + 0.5F));

		g = xexp;
		g = (float)((*px - g * c1) - g * c2);
		if (-_FEps._Float < g && g < _FEps._Float)
			*px = y;
		else
			{	/* g*g worth computing */
			const float z = g * g;
			const float w = q[0] * z + q[1];

			g *= z + p[1];
			*px = (w + g) / (w - g) * 2.0F * y;
			--xexp;
			}
		return (_FDscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfdscale.c ===
/* _FDscale function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _FDscale(float *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = (short)((ps[_F0] & _FMASK) >> _FOFF);

	if (xchar == _FMAX)
		return ((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _FDnorm(ps)))
		return (0);
	lexp += xchar;
	if (_FMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_F0] & _FSIGN ? -_FInf._Float : _FInf._Float;
		return (_INFCODE);
		}
	else if (0 < lexp)
		{	/* finite result, repack */
		ps[_F0] = ps[_F0] & ~_FMASK | (short)lexp << _FOFF;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_F0] & _FSIGN;

		ps[_F0] = (unsigned short)(1 << _FOFF
			| ps[_F0] & _FFRAC);
		if (--lexp < -(16+_FOFF))
			{	/* underflow, return +/-0 */
			ps[_F0] = sign, ps[_F1] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			if (xexp <= -16)
				ps[_F1] = ps[_F0], ps[_F0] = 0, xexp += 16;
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_F1] = ps[_F1] >> xexp
					| ps[_F0] << (16 - xexp);
				ps[_F0] >>= xexp;
				}
			ps[_F0] |= sign;
			return (_FINITE);
			}
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xferaise.c ===
/* _Feraise function */
#include <errno.h>
	#if _IS_C9X
#include <fenv.h>
#include <math.h>
	#else /* _IS_C9X */
#include <ymath.h>
	#endif /* _IS_C9X */
_STD_BEGIN

void (_Feraise)(int except)
	{	/* report floating-point exception */
	#if _IS_C9X
	if (math_errhandling == MATH_ERREXCEPT)
		feraiseexcept(except);

	if (math_errhandling != MATH_ERRNO)
		;
	else if ((except & (_FE_DIVBYZERO | _FE_INVALID)) != 0)
		errno = EDOM;
	else if ((except & (_FE_UNDERFLOW | _FE_OVERFLOW)) != 0)
		errno = ERANGE;
	#else /* _IS_C9X */
	if ((except & (_FE_DIVBYZERO | _FE_INVALID)) != 0)
		errno = EDOM;
	else if ((except & (_FE_UNDERFLOW | _FE_OVERFLOW)) != 0)
		errno = ERANGE;
	#endif /* _IS_C9X */
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlcosh.c ===
/* _LCosh function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 long double __cdecl _LCosh(long double x, long double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_LDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0L)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1.0L, -1);
			return (y * (x + 0.25L / x));
			}
		switch (_LExp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xfvalues.c ===
/* values used by math functions -- IEEE 754 float version */
#include "xmath.h"
_STD_BEGIN

		/* macros */
#define NBITS	(16 + _FOFF)
 #if _D0 == 0
  #define INIT(w0)		{w0, 0}
  #define INIT2(w0, w1)	{w0, w1}
 #else
  #define INIT(w0)		{0, w0}
  #define INIT2(w0, w1)	{w1, w0}
 #endif

		/* static data */
_CRTIMP2 const _Dconst _FDenorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _FEps = {INIT((_FBIAS - NBITS - 1) << _FOFF)};
_CRTIMP2 const _Dconst _FInf = {INIT(_FMAX << _FOFF)};
_CRTIMP2 const _Dconst _FNan = {INIT(_FSIGN | (_FMAX << _FOFF)
	| (1 << (_FOFF - 1)))};
_CRTIMP2 const _Dconst _FSnan = {INIT(_FSIGN | (_FMAX << _FOFF)
	| (1 << (_FOFF - 1)))};
_CRTIMP2 const _Dconst _FRteps = {INIT((_FBIAS - NBITS / 2) << _FOFF)};

_CRTIMP2 const float _FXbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2 const float _FZero = 0.0F;
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xldscale.c ===
/* _LDscale function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
_CRTIMP2 short __cdecl _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 64-bit */
	return (_Dscale((double *)px, lexp));
	}

 #elif _DLONG == 1
_CRTIMP2 short __cdecl _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 80-bit */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && ps[_L1] == 0 && ps[_L2] == 0
		&& ps[_L3] == 0 && ps[_L4] == 0)
		return (0);
	lexp += xchar + _LDnorm(ps);
	if (_LMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._Long_double
			: _LInf._Long_double;
		return (_INFCODE);
		}
	else if (0 <= lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (short)lexp;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		ps[_L0] &= _LSIGN;
		if (lexp <= -64)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0, ps[_L2] = 0;
			ps[_L3] = 0, ps[_L4] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_L4] = ps[_L3], ps[_L3] = ps[_L2];
				ps[_L2] = ps[_L1], ps[_L1] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] >>= xexp;
				}
			return (_FINITE);
			}
		}
	}
 #else	/*	1 < _DLONG */
_CRTIMP2 short __cdecl _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 128-bit SPARC */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _LDnorm(ps)))
		return (0);
	lexp += xchar;
	if (_LMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._Long_double
			: _LInf._Long_double;
		return (_INFCODE);
		}
	else if (0 <= lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (short)lexp;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_L0] & _LSIGN;

		ps[_L0] = 1;
		if (--lexp <= -112)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0, ps[_L2] = 0, ps[_L3] = 0, ps[_L4] = 0;
			ps[_L5] = 0, ps[_L6] = 0, ps[_L7] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_L7] = ps[_L6], ps[_L6] = ps[_L5];
				ps[_L5] = ps[_L4], ps[_L4] = ps[_L3];
				ps[_L3] = ps[_L2], ps[_L2] = ps[_L1];
				ps[_L1] = ps[_L0], ps[_L0] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_L7] = ps[_L7] >> xexp
					| ps[_L6] << 16 - xexp;
				ps[_L6] = ps[_L6] >> xexp
					| ps[_L5] << 16 - xexp;
				ps[_L5] = ps[_L5] >> xexp
					| ps[_L4] << 16 - xexp;
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] = ps[_L1] >> xexp
					| ps[_L0] << 16 - xexp;
				}
			ps[_L0] = sign;
			return (_FINITE);
			}
		}
	}
 #endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlock.cpp ===
// xlock.cpp -- global lock for locales, etc.
#include <stdlib.h>
#include <yvals.h>

 #if _MULTI_THREAD
  #include "xmtx.h"
_STD_BEGIN

  #define MAX_LOCK	4	/* must be power of two */

static _Rmtx mtx[MAX_LOCK];
static long init = -1;

_Init_locks::_Init_locks()
	{	// initialize locks
	if (InterlockedIncrement(&init) == 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxinit(&mtx[count]);
	}

_Init_locks::~_Init_locks()
	{	// clean up locks
	if (InterlockedDecrement(&init) < 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxdst(&mtx[count]);
	}

static _Init_locks initlocks;

_Lockit::_Lockit()
	: _Locktype(0)
	{	// lock default mutex
	_Mtxlock(&mtx[0]);
	}

_Lockit::_Lockit(int kind)
	: _Locktype(kind & (MAX_LOCK - 1))
	{	// lock the mutex
	_Mtxlock(&mtx[_Locktype]);
	}

_Lockit::~_Lockit()
	{	// unlock the mutex
	_Mtxunlock(&mtx[_Locktype]);
	}
_STD_END
 #endif	// _MULTI_THREAD

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlocale.cpp ===
// xlocale -- class locale exotic char member functions
#include <istream>
#include <locale>
#include <xdebug>
_STD_BEGIN

 #pragma warning(disable: 4786)

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

// moved from locale to ease subsetting
typedef collate<char> _T5;
typedef messages<char> _T6;
typedef money_get<char, _Initer> _T7;
typedef money_put<char, _Outiter> _T9;
typedef moneypunct<char, false> _T11;
typedef moneypunct<char, true> _T12;
typedef time_get<char, _Initer> _T13;
typedef time_put<char, _Outiter> _T14;


void __cdecl locale::_Locimp::_Makexloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup exotic char part of a new locale
	ADDFAC(_T5, cat, ptrimp, ptrloc);
	ADDFAC(_T6, cat, ptrimp, ptrloc);
	ADDFAC(_T7, cat, ptrimp, ptrloc);
	ADDFAC(_T9, cat, ptrimp, ptrloc);
	ADDFAC(_T11, cat, ptrimp, ptrloc);
	ADDFAC(_T12, cat, ptrimp, ptrloc);
	ADDFAC(_T13, cat, ptrimp, ptrloc);
	ADDFAC(_T14, cat, ptrimp, ptrloc);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xldnorm.c ===
/* _LDnorm function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
	/* not needed -- 64-bit */

 #elif _DLONG == 1
_CRTIMP2 short __cdecl _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- 80-bit */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 0;
	for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
		xchar -= 16)
		{	/* shift left by 16 */
		ps[_L0] = ps[_L1];
		ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
		ps[_L3] = ps[_L4], ps[_L4] = 0;
		}
	if (ps[_L0] == 0)
		for (; ps[_L1] < (1U << _LOFF); --xchar)
			{	/* shift left by 1 */
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] <<= 1;
			}
	for (; ps[_L0] != 0; ++xchar)
		{	/* shift right by 1 */
		ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
		ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
		ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
		ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
		ps[_L0] >>= 1;
		}
	ps[_L0] = sign;
	return (xchar);
	}

 #else	/* 1 < _DLONG */
_CRTIMP2 short __cdecl _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- 128-bit SPARC */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 1;
	if (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
		|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
		|| ps[_L7] != 0)
		{	/* nonzero, scale */
		for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
			xchar -= 16)
			{	/* shift left by 16 */
			ps[_L0] = ps[_L1];
			ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
			ps[_L3] = ps[_L4], ps[_L4] = ps[_L5];
			ps[_L5] = ps[_L6], ps[_L6] = ps[_L7];
			ps[_L7] = 0;
			}
		for (; ps[_L0] == 0; --xchar)
			{	/* shift left by 1 */
			ps[_L0] = ps[_L0] << 1 | ps[_L1] >> 15;
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] = ps[_L4] << 1 | ps[_L5] >> 15;
			ps[_L5] = ps[_L5] << 1 | ps[_L6] >> 15;
			ps[_L6] = ps[_L6] << 1 | ps[_L7] >> 15;
			ps[_L7] <<= 1;
			}
		for (; 1 < ps[_L0]; ++xchar)
			{	/* shift right by 1 */
			ps[_L7] = ps[_L7] >> 1 | ps[_L6] << 15;
			ps[_L6] = ps[_L6] >> 1 | ps[_L5] << 15;
			ps[_L5] = ps[_L5] >> 1 | ps[_L4] << 15;
			ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
			ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
			ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
			ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
			ps[_L0] >>= 1;
			}
		}
	ps[_L0] = sign;
	return (xchar);
	}
 #endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlpoly.c ===
/* _LPoly function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 long double __cdecl _LPoly(long double x,
	const long double *tab, int n)
	{	/* compute polynomial */
	long double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xldtest.c ===
/* _LDtest function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
_CRTIMP2 short __cdecl _LDtest(long double *px)
	{	/* categorize *px -- 64-bit */
	return (_Dtest((double *)px));
	}

 #elif _DLONG == 1
_CRTIMP2 short __cdecl _LDtest(long double *px)
	{	/* categorize *px -- 80-bit */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? _NANCODE : _INFCODE);
	else if (0 < xchar || ps[_L1] != 0 || ps[_L2] || ps[_L3]
		|| ps[_L4])
		return (_FINITE);
	else
		return (0);
	}

 #else	/*	1 < _DLONG */
_CRTIMP2 short __cdecl _LDtest(long double *px)
	{	/* categorize *px -- 128-bit SPARC */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? _NANCODE : _INFCODE);
	else if (0 < xchar || ps[_L1] || ps[_L2] || ps[_L3]
		|| ps[_L4] || ps[_L5] || ps[_L6] || ps[_L7])
		return (_FINITE);
	else
		return (0);
	}
 #endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlexp.c ===
/* _LExp function */
#include "xmath.h"
_STD_BEGIN

	/* coefficients */
 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	42.038913947607355L,
	10096.353102778762831L,
	333228.767219512631062L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	1.0L,
	841.167880526530790L,
	75730.834075476293976L,
	666457.534439025262146L};
 #else	/* assume IEEE 754 16 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	2.9807566520819951922553427799e-12L,
	1.77137207816625148450390487465e-8L,
	1.5047926518149448268177793026372e-5L,
	3.611828913847589925056132680618007e-3L,
	2.3684088648142335389097476188945590e-1L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	3.279723985560247033712687707263e-10L,
	6.1415060072086450089090888123384e-7L,
	2.708775201978218837374512615596512e-4L,
	3.5087109907378343612154047611394786e-2L};
 #endif

static const long double c1 = (22713.0L / 32768.0L);
static const long double c2 = 1.4286068203094172321214581765680755e-6L;
static const long double hugexp = LHUGE_EXP;
static const long double invln2 = 1.4426950408889634073599246810018921L;

_CRTIMP2 short __cdecl _LExp(long double *px, long double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0L)
		{	/* certain underflow */
		*px = 0.0L;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _LInf._Long_double;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		long double g = *px * invln2;
		short xexp = (short)(g + (g < 0 ? - 0.5L : + 0.5L));

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_LEps._Long_double < g && g < _LEps._Long_double)
			*px = y;
		else
			{	/* g*g worth computing */
 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
			const long double z = g * g;
			const long double w = ((z + q[1]) * z + q[2]) * z + q[3];

			g *= (p[0] * z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2.0L * y;
			--xexp;
 #else	/* assume IEEE 754 16 byte */
			const long double z = g * g;
			const long double w = ((q[0] * z + q[1]) * z + q[2]) * z + q[3];
			const long double v = (((p[0] * z + p[1]) * z + p[2])
				* z + p[3]) * z + p[4];
			const long double u = g * w - v;

			*px = g * (g + z * (w + w + u)) / (2.0L - (g + z * u)) + g + 1.0;
			*px *= y;
 #endif
			}
		return (_LDscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlsinh.c ===
/* _LSinh function */
#include "xmath.h"
_STD_BEGIN

	/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)

 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000000000028486835L,
	0.0000000000007646464279L,
	0.0000000001605905091647L,
	0.0000000250521083436962L,
	0.0000027557319224130455L,
	0.0001984126984126956009L,
	0.0083333333333333336073L,
	0.1666666666666666666564L,
	1.0000000000000000000001L};
 #else	/* assume IEEE 754 16 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.00000000000000000000000006506911776L,
	0.00000000000000000000003867997525529L,
	0.00000000000000000001957294395545097L,
	0.00000000000000000822063524350084984L,
	0.00000000000000281145725434779709982L,
	0.00000000000076471637318198050919003L,
	0.00000000016059043836821614638343470L,
	0.00000002505210838544171877496283537L,
	0.00000275573192239858906525574505191L,
	0.00019841269841269841269841269726379L,
	0.00833333333333333333333333333338555L,
	0.16666666666666666666666666666666573L,
	1.0L};
 #endif

_CRTIMP2 long double __cdecl _LSinh(long double x, long double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_LDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0L ? x : LSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0L)
			return (x < 0.0L ? -y : y);
		if (x < 0.0L)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _LRteps._Long_double)
			x *= y;	/* x tiny */
		else if (x < 1.0L)
			{
			long double w = x * x;

			x += x * w * _LPoly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1.0L, -1);
			x = y * (x - 0.25L / x);
			}
		else
			switch (_LExp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xmtx.h ===
/* xmtx.h internal header */
#pragma once
#ifndef _XMTX
#define _XMTX
#include <stdlib.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

_C_LIB_DECL
  #include <windows.h>
typedef CRITICAL_SECTION _Rmtx;

void _Mtxinit(_Rmtx *);
void _Mtxdst(_Rmtx *);
void _Mtxlock(_Rmtx *);
void _Mtxunlock(_Rmtx *);

 #if !_MULTI_THREAD
  #define _Mtxinit(mtx)
  #define _Mtxdst(mtx)
  #define _Mtxlock(mtx)
  #define _Mtxunlock(mtx)

typedef char _Once_t;

  #define _Once(cntrl, func)	if (*(cntrl) == 0) (func)(), *(cntrl) = 2
  #define _ONCE_T_INIT	0

 #else
typedef long _Once_t;

void __cdecl _Once(_Once_t *, void (*)(void));
  #define _ONCE_T_INIT	0

 #endif /* _MULTI_THREAD */
_END_C_LIB_DECL
#endif /* _XMTX */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

		/* return values for _Stopfx/_Stoflt */
#define FL_ERR	0
#define FL_DEC	1
#define FL_HEX	2
#define FL_INF	3
#define FL_NAN	4
#define FL_NEG	8

_C_LIB_DECL
		/* double declarations */
_CRTIMP2 double __cdecl _Atan(double, int);
_CRTIMP2 short __cdecl _Dint(double *, short);
_CRTIMP2 short __cdecl _Dnorm(unsigned short *);
_CRTIMP2 short __cdecl _Dscale(double *, long);
_CRTIMP2 double __cdecl _Dtento(double, long);
_CRTIMP2 short __cdecl _Dunscale(short *, double *);
_CRTIMP2 double __cdecl _Poly(double, const double *, int);

_CRTIMP2 int __cdecl _Stoflt(const char *, char **, long[], int);

extern _CRTIMP2 const _Dconst _Eps, _Rteps;
extern _CRTIMP2 const double _Xbig;

		/* float declarations */
_CRTIMP2 float __cdecl _FAtan(float, int);
_CRTIMP2 short __cdecl _FDint(float *, short);
_CRTIMP2 short __cdecl _FDnorm(unsigned short *);
_CRTIMP2 short __cdecl _FDscale(float *, long);
_CRTIMP2 float __cdecl _FDtento(float, long);
_CRTIMP2 short __cdecl _FDunscale(short *, float *);
_CRTIMP2 float __cdecl _FPoly(float, const float *, int);

extern _CRTIMP2 const _Dconst _FEps, _FRteps;
extern _CRTIMP2 const float _FXbig;

		/* long double functions */
_CRTIMP2 long double __cdecl _LAtan(long double, int);
_CRTIMP2 short __cdecl _LDint(long double *, short);
_CRTIMP2 short __cdecl _LDnorm(unsigned short *);
_CRTIMP2 short __cdecl _LDscale(long double *, long);
_CRTIMP2 long double __cdecl _LDtento(long double, long);
_CRTIMP2 short __cdecl _LDunscale(short *, long double *);
_CRTIMP2 long double __cdecl _LPoly(long double, const long double *, int);

extern _CRTIMP2 const _Dconst _LEps, _LRteps;
extern _CRTIMP2 const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xpoly.c ===
/* _Poly function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 double __cdecl _Poly(double x, const double *tab, int n)
	{	/* compute polynomial */
	double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xmbtowc.c ===
/***
*xmbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*Revision History:
*       12-XX-95  PJP   Created from mbtowc.c December 1995 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-25-96  GJF   Made mbrlen, mbrtowc and mbsrtowcs multithread safe.
*       09-17-97  JWM   Added "return MB_CUR_MAX" to "if (*pst != 0)" branch.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <limits.h>              /* for INT_MAX */
#include <stdio.h>               /* for EOF */
#include <xlocinfo.h>            /* for _Cvtvec, _Mbrtowc */
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

#ifndef _MT
#define _Mbrtowc_lk _Mbrtowc
#endif

/***
*int _Mbrtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*               mbstate_t *pst          = pointer to state
*       const _Cvtvec *     = pointer to locale info
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
static int __cdecl _Mbrtowc_lk
        (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        );

int _CRTIMP2 __cdecl _Mbrtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        int retval;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )
        retval = _Mbrtowc_lk(pwc, s, n, pst, ploc);
        _unlock_locale( local_lock_flag )
        return retval;
}
#endif  /* _MT */
#ifdef _MT
static int __cdecl _Mbrtowc_lk
#else  /* _MT */
int _CRTIMP2 __cdecl _Mbrtowc
#endif  /* _MT */
        (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        _ASSERTE (___mb_cur_max_func() == 1 || ___mb_cur_max_func() == 2);

        if ( !s || n == 0 )
            /* indicate do not have state-dependent encodings,
               handle zero length string */
            return 0;

        if ( !*s )
        {
            /* handle NULL char */
            if (pwc)
                *pwc = 0;
            return 0;
        }

        {   /* perform locale-dependent parse */
            LCID handle;
            UINT codepage;

            if (ploc == 0)
            {
                handle = ___lc_handle_func()[LC_CTYPE];
                codepage = ___lc_codepage_func(); 
            }
            else
            {
                handle = ploc->_Hand;
                codepage = ploc->_Page; 
            }

            if ( handle == _CLOCALEHANDLE )
            {
                if (pwc)
                    *pwc = (wchar_t)(unsigned char)*s;
                return sizeof(char);
            }

            if (*pst != 0)
            {   /* complete two-byte multibyte character */
                ((char *)pst)[1] = *s;
                if (___mb_cur_max_func() <= 1 || (MultiByteToWideChar(codepage,
                    MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                    (char *)pst, 2, pwc, (pwc) ? 1 : 0) == 0))
                {   /* translation failed */
                    *pst = 0;
                    errno = EILSEQ;
                    return -1;
                }
                *pst = 0;
                return ___mb_cur_max_func();
            }
            else if ( _cpp_isleadbyte((unsigned char)*s) )
            {
                /* multi-byte char */
                if (n < (size_t)___mb_cur_max_func())
                {   /* save partial multibyte character */
                    ((char *)pst)[0] = *s;
                    return (-2);
                }
                else if ( ___mb_cur_max_func() <= 1 ||
                          (MultiByteToWideChar( codepage, 
                                                MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS,
                                                s, 
                                                ___mb_cur_max_func(), 
                                                pwc, 
                                                (pwc) ? 1 : 0) == 0) )
                {
                    /* validate high byte of mbcs char */
                    if (!*(s+1))
                    {
                        *pst = 0;
                        errno = EILSEQ;
                        return -1;
                    }
/*                  else translation failed with no complaint? [pjp] */
                }
                return ___mb_cur_max_func();
            }
            else {
                /* single byte char */

                if ( MultiByteToWideChar( codepage, 
                                          MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                                          s, 
                                          1, 
                                          pwc, 
                                          (pwc) ? 1 : 0) == 0 )
                {
                    errno = EILSEQ;
                    return -1;
                }

                return sizeof(char);
            }
        }
}


/***
*wint_t btowc(c) - translate single byte to wide char 
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wint_t _CRTIMP2 __cdecl btowc (
        int c
        )
{
        if (c == EOF)
            return (WEOF);
        else
        {   /* convert as one-byte string */
            char ch = (char)c;
            mbstate_t mbst = 0;
            wchar_t wc;
            return (_Mbrtowc(&wc, &ch, 1, &mbst, 0) < 0 ? WEOF : wc);
        }
}


/***
*size_t mbrlen(s, n, pst) - determine next multibyte code, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbrlen (
        const char *s, 
        size_t n, 
        mbstate_t *pst
        )
{
#ifdef  _MT
        int local_lock_flag;
#endif
        size_t retval;

        static mbstate_t mbst = {0};

        _lock_locale( local_lock_flag )
        retval = _Mbrtowc_lk(0, s != 0 ? s : 0, n, pst ? pst : &mbst, 0);
        _unlock_locale( local_lock_flag )

        return retval;
}


/***
*size_t mbrtowc(pwc, s, n, pst) - translate multibyte to wchar_t, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbrtowc (
        wchar_t *pwc, 
        const char *s, 
        size_t n, 
        mbstate_t *pst
        )
{
#ifdef  _MT
        int local_lock_flag;
#endif
        size_t retval;

        static mbstate_t mbst = {0};

        _lock_locale( local_lock_flag )
        retval = (s != 0) ? _Mbrtowc_lk(pwc, s, n, pst ? pst : &mbst, 0)
                 : _Mbrtowc_lk(0, "", n, pst ? pst : &mbst, 0);
        _unlock_locale( local_lock_flag )

        return retval;    
}


/***
*size_t mbsrtowcs(wcs, ps, n, pst) - translate multibyte string to wide, 
*       restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbsrtowcs (
        wchar_t *wcs, 
        const char **ps, 
        size_t n, 
        mbstate_t *pst
        )
{
        const char *s = *ps;
        int i;
        size_t nwc = 0;
#ifdef  _MT
        int local_lock_flag;
#endif
        static mbstate_t mbst = {0};

        if (pst == 0)
            pst = &mbst;

        _lock_locale( local_lock_flag )

        if (wcs == 0)
            for (; ; ++nwc, s += i)
            {   /* translate but don't store */
                wchar_t wc;
                if ((i = _Mbrtowc_lk(&wc, s, INT_MAX, pst, 0)) < 0) {
                    _unlock_locale( local_lock_flag )
                    return ((size_t)-1);
                }
                else if (i == 0) {
                    _unlock_locale( local_lock_flag )
                    return (nwc);
                }
            }

        for (; 0 < n; ++nwc, s += i, ++wcs, --n)
        {   /* translate and store */
            if ((i = _Mbrtowc_lk(wcs, s, INT_MAX, pst, 0)) < 0)
            {   /* encountered invalid sequence */
                nwc = (size_t)-1;
                break;
            }
            else if (i == 0)
            {   /* encountered terminating null */
                s = 0;
                break;
            }
        }

        *ps = s;

        _unlock_locale( local_lock_flag )

        return (nwc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xmutex.cpp ===
//	xmutex.cpp -- implement mutex lock for iostreams
#include <yvals.h>
#include <xdebug>

 #if _MULTI_THREAD
  #include "xmtx.h"
_STD_BEGIN

_Mutex::_Mutex()
	: _Mtx(_NEW_CRT _Rmtx)
	{	// initialize recursive mutex object
	_Mtxinit((_Rmtx*)_Mtx);
	}

_Mutex::~_Mutex()
	{	// release resources allocated to mutex object
	_Mtxdst((_Rmtx*)_Mtx);
	_DELETE_CRT((_Rmtx*)_Mtx);
	}

void _Mutex::_Lock()
	{	// lock mutex
	_Mtxlock((_Rmtx*)_Mtx);
	}

void _Mutex::_Unlock()
	{	// unlock mutex
	_Mtxunlock((_Rmtx*)_Mtx);
	}
_STD_END
 #endif	/* _MULTI_THREAD */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xmtx.c ===
/*	xmtx.c -- mutex support for VC++ */
#include "xmtx.h"

 #if !_MULTI_THREAD

 #else /* !_MULTI_THREAD */
/* Win32 critical sections are recursive, but
   Win32 does not have once-function */

void _Once(_Once_t *_Cntrl, void (*_Func)(void))
	{	/* execute _Func exactly one time */
	_Once_t old;
	if (*_Cntrl == 2)
		;
	else if ((old = InterlockedExchange(_Cntrl, 1)) == 0)
		{	/* execute _Func, mark as executed */
		_Func();
		*_Cntrl = 2;
		}	
	else if (old == 2)
		*_Cntrl = 2;
	else
		while (*_Cntrl != 2)
			Sleep(1);
		}

void _Mtxinit(_Rmtx *_Mtx)
	{	/* initialize mutex */
	InitializeCriticalSection(_Mtx);
	}

void _Mtxdst(_Rmtx *_Mtx)
	{	/* delete mutex */
	DeleteCriticalSection(_Mtx);
	}

void _Mtxlock(_Rmtx *_Mtx)
	{	/* lock mutex */
	EnterCriticalSection(_Mtx);
	}

void _Mtxunlock(_Rmtx *_Mtx)
	{	/* unlock mutex */
	LeaveCriticalSection(_Mtx);
	}
 #endif /* !_MULTI_THREAD */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xsinh.c ===
/* _Sinh function */
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000001632881,
	0.0000000250483893,
	0.0000027557344615,
	0.0001984126975233,
	0.0083333333334816,
	0.1666666666666574,
	1.0000000000000001};

_CRTIMP2 double __cdecl _Sinh(double x, double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_Dtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0 ? x : DSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0)
			return (x < 0.0 ? -y : y);
		if (x < 0.0)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _Rteps._Double)
			x *= y;	/* x tiny */
		else if (x < 1.0)
			{
			double w = x * x;

			x += x * w * _Poly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1.0, -1);
			x = y * (x - 0.25 / x);
			}
		else
			switch (_Exp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xlvalues.c ===
/* values used by math functions -- IEEE 754 long version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
		/* macros -- 64-bit */
  #define NBITS	(48 + _DOFF)
  #if _D0 == 0
   #define INIT(w0)		{w0, 0, 0, 0}
   #define INIT2(w0, w1)	{w0, 0, 0, w1}
  #else
   #define INIT(w0)		{0, 0, 0, w0}
   #define INIT2(w0, w1)	{w1, 0, 0, w0}
  #endif

		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT((_DBIAS - NBITS - 1) << _DOFF)};
_CRTIMP2 const _Dconst _LInf = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _LNan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
_CRTIMP2 const _Dconst _LRteps = {INIT((_DBIAS - NBITS / 2) << _DOFF)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};

 #elif _DLONG == 1
		/* macros -- 80-bit */
  #define NBITS	64
  #if _D0 == 0
   #define INIT(w0, w1)		{w0, w1, 0, 0, 0}
   #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, wn}
  #else
   #define INIT(w0, w1)		{0, 0, 0, w1, w0}
   #define INIT3(w0, w1, wn)	{wn, 0, 0, w1, w0}
  #endif

		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT3(0, 0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT(_LBIAS - NBITS - 1, 0x8000)};
_CRTIMP2 const _Dconst _LInf = {INIT(_LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LNan = {INIT(_LSIGN | _LMAX, 0xc000)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LRteps = {INIT(_LBIAS - NBITS / 2, 0x8000)};

 #else /* 1 < _DLONG */
		/* macros -- 128-bit SPARC */
  #define NBITS	128
  #if _D0 == 0
   #define INIT(w0, w1)		{w0, w1, 0, 0, 0, 0, 0, 0}
   #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, 0, 0, 0, wn}
  #else
   #define INIT(w0, w1)		{0, 0, 0, 0, 0, 0, w1, w0}
   #define INIT3(w0, w1, wn)	{wn, 0, 0, 0, 0, 0, w1, w0}
  #endif

		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT3(0, 0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT(_LBIAS - NBITS - 1, 0x8000)};
_CRTIMP2 const _Dconst _LInf = {INIT(_LMAX, 0)};
_CRTIMP2 const _Dconst _LNan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LRteps = {INIT(_LBIAS - NBITS / 2, 0x8000)};
 #endif

_CRTIMP2 const long double _LXbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2 const long double _LZero = 0.0L;
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xtowlower.c ===
/* _Towlower -- convert wchar_t to lower case for Microsoft */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <setlocal.h>

_STD_BEGIN
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* convert element to lower case */
	wchar_t _Res = _Ch;

	if (_Ch == WEOF)
		;
	else if (_Ctype->_Hand == _CLOCALEHANDLE && _Ch < 256)
		{	/* handle ASCII character in C locale */
		if (L'A' <= _Ch && _Ch <= L'Z')
			_Res = (wchar_t)(_Ch - L'A' + L'a');
		}
	else if (__crtLCMapStringW(_Ctype->_Hand, LCMAP_LOWERCASE,
			&_Ch, 1, &_Res, 1, _Ctype->_Page) == 0)
		_Res = _Ch;
	return (_Res);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xstod.c ===
/* xstod.c -- dummies for _Sto* */
#include <stdlib.h>
 #ifndef _CRTIMP2
  #ifdef  CRTDLL2
   #define _CRTIMP2 __declspec(dllexport)
  #else   /* ndef CRTDLL2 */
   #ifdef  _DLL
    #define _CRTIMP2 __declspec(dllimport)
   #else   /* ndef _DLL */
    #define _CRTIMP2
   #endif  /* _DLL */
  #endif  /* CRTDLL2 */
 #endif  /* _CRTIMP2 */

_CRTIMP2 double __cdecl _Stod(const char *s, char **endptr, long pten)
	{	/* convert string to double */
	double x = strtod(s, endptr);
	for (; 0 < pten; --pten)
		x *= 10.0;
	for (; pten < 0; ++pten)
		x /= 10.0;
	return (x);
	}

_CRTIMP2 float __cdecl _Stof(const char *s, char **endptr, long pten)
	{	/* convert string to float */
	return ((float)_Stod(s, endptr, pten));
	}

_CRTIMP2 long double __cdecl _Stold(const char *s, char **endptr, long pten)
	{	/* convert string to long double */
	return ((long double)_Stod(s, endptr, pten));
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xtowupper.c ===
/* _Towupper -- convert wchar_t to upper case for Microsoft */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <setlocal.h>

_STD_BEGIN
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* convert element to upper case */
	wchar_t _Res = _Ch;

	if (_Ch == WEOF)
		;
	else if (_Ctype->_Hand == _CLOCALEHANDLE && _Ch < 256)
		{	/* handle ASCII character in C locale */
		if (L'a' <= _Ch && _Ch <= L'z')
			_Res = (wchar_t)(_Ch - L'a' + L'A');
		}
	else if (__crtLCMapStringW(_Ctype->_Hand, LCMAP_UPPERCASE,
			&_Ch, 1, &_Res, 1, _Ctype->_Page) == 0)
		_Res = _Ch;
	return (_Res);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xstrxfrm.c ===
/***
*xstrxfrm.c - Transform a string using locale information
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       01-XX-96  PJP   Created from strxfrm.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strxfrm */
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/***
*size_t _Strxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the string pointer to by _string2 and place the
*       resulting string into the array pointer to by _string1.
*       No more than _end1 - _string1 characters are place into the
*       resulting string (including the null).
*
*       The transformation is such that if strcmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of strcoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*       [ANSI]
*
*       The value of the following expression is the size of the array
*       needed to hold the transformation of the source string:
*
*               1 + strxfrm(NULL,string,0)
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*       Thus, _Strxfrm() simply resolves to strncpy()/strlen().
*
*Entry:
*       char *_string1       = pointer to beginning of result string
*       char *_end1          = pointer past end of result string
*       const char *_string2 = pointer to beginning of source string
*       const char *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl _Strxfrm (
        char *_string1,
        char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        int dstlen;
        int retval = INT_MAX;   /* NON-ANSI: default if OM or API error */
        LCID handle;
        UINT codepage;
#ifdef  _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_COLLATE];
            codepage = ___lc_collate_cp_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ((handle == _CLOCALEHANDLE) &&
            (codepage == _CLOCALECP)) 
        {
            _unlock_locale( local_lock_flag )
            if (_n2 <= _n1)
                memcpy(_string1, _string2, _n2);
            return _n2;
        }

        /* Inquire size of dst string in BYTES */
        if (0 == (dstlen = __crtLCMapStringA(handle,
                                             LCMAP_SORTKEY, 
                                             _string2, 
                                             (int)_n2, 
                                             NULL, 
                                             0, 
                                             codepage,
                                             TRUE)))
                goto error_cleanup;

        retval = dstlen;

        /* if not enough room, return amount needed */
        if (dstlen > (int)(_n1))
            goto error_cleanup;

        /* Map src string to dst string */
        if (0 == __crtLCMapStringA(handle,
                                   LCMAP_SORTKEY, 
                                   _string2, 
                                   (int)_n2, 
                                   _string1, 
                                   (int)_n1, 
                                   codepage,
                                   TRUE))
            goto error_cleanup;

error_cleanup:
        _unlock_locale( local_lock_flag )
        return (size_t)retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xstrcoll.c ===
/***
*xstrcoll.c - Collate locale strings
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       01-XX-96  PJP   Created from strcoll.c January 1996 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       05-14-96  JWM   Bug fix to _Strcoll(): error path failed to unlock.
*       09-26-96  GJF   Made _GetColl() multithread safe.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-11-99  PML   Win64 fix: cast ptr diff to int
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strcoll */
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/***
*int _Strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1b = pointer to beginning of the first string
*       const char *s1e = pointer past end of the first string
*       const char *s2b = pointer to beginning of the second string
*       const char *s1e = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

_CRTIMP2 int __cdecl _Strcoll (
        const char *_string1,
        const char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        int ret;
        LCID handle;
#ifdef  _MT
        int local_lock_flag;
#endif
        int n1 = (int)(_end1 - _string1);
        int n2 = (int)(_end2 - _string2);

        _lock_locale( local_lock_flag )

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            _unlock_locale( local_lock_flag )
            ans = memcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;
        }

        if ( 0 == (ret = __crtCompareStringA( handle,
                                              0,
                                              _string1,
                                              n1,
                                              _string2,
                                              n2,
                                              ___lc_collate_cp_func() )) )
            goto error_cleanup;

        _unlock_locale( local_lock_flag )
        return (ret - 2);

error_cleanup:

        _unlock_locale( local_lock_flag )
        errno = EINVAL;
        return _NLSCMPERROR;
}


/***
*_Collvec _Getcoll() - get collation info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Collvec __cdecl _Getcoll()
{
        _Collvec coll;
#ifdef  _MT
        int local_lock_flag;
#endif
        _lock_locale( local_lock_flag )
        coll._Hand = ___lc_handle_func()[LC_COLLATE];
        coll._Page = ___lc_collate_cp_func();
        _unlock_locale( local_lock_flag )

        return (coll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xwcscoll.c ===
/***
*xwcscoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*
*Revision History:
*       01-XX-96  GJF   Created from wcscoll.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-11-99  PML   Win64 fix: cast ptr diff to int
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcscoll */

/***
*static int _Wmemcmp(s1, s2, n) - compare wchar_t s1[n], s2[n]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static int _Wmemcmp(
        const wchar_t *s1, 
        const wchar_t *s2, 
        int n
        )
{
        for (; 0 < n; ++s1, ++s2, --n)
             if (*s1 != *s2)
               return (*s1 < *s2 ? -1 : +1);
        return (0);
}

/***
*int _Wcscoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       In the C locale, wcscmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *_string1 = pointer to beginning of the first string
*       const wchar_t *_end1    = pointer past end of the first string
*       const wchar_t *_string2 = pointer to beginning of the second string
*       const wchar_t *_end2    = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _Wcscoll (
        const wchar_t *_string1,
        const wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{

        int n1 = (int)(_end1 - _string1);
        int n2 = (int)(_end2 - _string2);
        int ret;
        LCID handle;
#ifdef  _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif
        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            _unlock_locale( local_lock_flag )
            ans = _Wmemcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;
        }

        if (0 == (ret = __crtCompareStringW(handle, 
                                            0, 
                                            _string1, 
                                            n1,
                                            _string2, 
                                            n2, 
                                            ___lc_collate_cp_func())))
        {
            _unlock_locale( local_lock_flag )
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        _unlock_locale( local_lock_flag )
        return (ret - 2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xvalues.c ===
/* values used by math functions -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

		/* macros */
#define NBITS	(48 + _DOFF)
 #if _D0 == 0
  #define INIT(w0)		{w0, 0, 0, 0}
  #define INIT2(w0, w1)	{w0, 0, 0, w1}
 #else
  #define INIT(w0)		{0, 0, 0, w0}
  #define INIT2(w0, w1)	{w1, 0, 0, w0}
 #endif

		/* static data */
_CRTIMP2 const _Dconst _Denorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _Eps = {INIT((_DBIAS - NBITS - 1) << _DOFF)};
_CRTIMP2 const _Dconst _Hugeval = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _Inf = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _Nan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
_CRTIMP2 const _Dconst _Rteps = {INIT((_DBIAS - NBITS / 2) << _DOFF)};
_CRTIMP2 const _Dconst _Snan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};

_CRTIMP2 const double _Xbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2 const double _Zero = 0.0;
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\delop2_s.cpp ===
//  delop2_s.cpp - version of delop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "delop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xwcsxfrm.c ===
/***
*xwcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*               
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       01-XX-96  PJP   Created from wcsxfrm.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <stdlib.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcsxfrm */

/***
*size_t _Wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _end1 - _string1 wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = pointer to beginning of result string
*       wchar_t *_end1          = pointer past end of result string
*       const wchar_t *_string2 = pointer to beginning of source string
*       const wchar_t *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl _Wcsxfrm (
        wchar_t *_string1,
        wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        int size = INT_MAX;
        unsigned char *bbuffer;
        LCID handle;
#ifdef _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            _unlock_locale( local_lock_flag )
            if (_n2 <= _n1)
                memcpy(_string1, _string2, _n2 * sizeof (wchar_t));
                return _n2;
        }

        /*
         * When using LCMAP_SORTKEY, LCMapStringW handles BYTES not wide
         * chars. We use a byte buffer to hold bytes and then convert the
         * byte string to a wide char string and return this so it can be
         * compared using wcscmp(). User's buffer is _n1 wide chars, so
         * use an internal buffer of _n1 bytes.
         */

        if (NULL == (bbuffer = (unsigned char *)_malloc_crt(_n1)))
            goto error_cleanup;

        if (0 == (size = __crtLCMapStringW(handle, 
                                           LCMAP_SORTKEY,
                                           _string2,
                                           (int)_n2,
                                           (wchar_t *)bbuffer,
                                           (int)_n1,
                                           ___lc_collate_cp_func())))
        {
            /* buffer not big enough, get size required. */

            if (0 == (size = __crtLCMapStringW(handle,
                                               LCMAP_SORTKEY,
                                               _string2,
                                               (int)_n2,
                                               NULL,
                                               0,
                                               ___lc_collate_cp_func())))
                size = INT_MAX; /* default error */

        } else {
            int i;
            /* string successfully mapped, convert to wide char */

            for (i = 0; i < size; i++)
                _string1[i] = (wchar_t)bbuffer[i];
        }

error_cleanup:
        _unlock_locale( local_lock_flag )
        _free_crt(bbuffer);

        return (size_t)size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\xwctomb.c ===
/***
*xwctomb.c - Convert wide character to multibyte character, with locale.
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*Revision History:
*       12-XX-95  PJP   Created from wctomb.c December 1995 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-26-96  GJF   Made _Getcvt() and wcsrtombs() multithread safe.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <limits.h>             /* for MB_LEN_MAX */
#include <string.h>             /* for memcpy */
#include <stdio.h>              /* for EOF */
#include <xlocinfo.h>           /* for _Cvtvec, _Wcrtomb */
#include <locale.h>
#include <setlocal.h>

#ifndef _MT
#define __Wcrtomb_lk    _Wcrtomb
#endif

/***
*int _Wcrtomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s             = pointer to multibyte character
*       wchar_t wchar       = source wide character
*       mbstate_t *pst      = pointer to state (not used)
*       const _Cvtvec *ploc = pointer to locale info
*
*Exit:
*       Returns:
*      -1 (if error) or number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
_CRTIMP2 int __cdecl __Wcrtomb_lk
        (
        char *s,
        wchar_t wchar,
        mbstate_t *,
        const _Cvtvec *ploc
        );

_CRTIMP2 int __cdecl _Wcrtomb
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        int retval;
        int local_lock_flag;

        _lock_locale( local_lock_flag )
        retval = __Wcrtomb_lk(s, wchar, 0, ploc);
        _unlock_locale( local_lock_flag )
        return retval;
}
#endif  /* _MT */

#ifdef _MT
_CRTIMP2 int __cdecl __Wcrtomb_lk
#else  /* _MT */
_CRTIMP2 int __cdecl _Wcrtomb
#endif  /* _MT */
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ( handle == _CLOCALEHANDLE )
        {
            if ( wchar > 255 )  /* validate high byte */
            {
                errno = EILSEQ;
                return -1;
            }

            *s = (char) wchar;
            return sizeof(char);
        } else {
            int size;
            BOOL defused = 0;

            if ( ((size = WideCharToMultiByte(codepage,
                                              0,
                                              &wchar, 
                                              1,
                                              s, 
                                              ___mb_cur_max_func(), 
                                              NULL, 
                                              &defused)) == 0) || 
                 (defused) )
            {
                errno = EILSEQ;
                return -1;
            }

            return size;
        }
}


/***
*_Cvtvec _Getcvt() - get conversion info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Cvtvec __cdecl _Getcvt()
{
        _Cvtvec cvt;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )
        cvt._Hand = ___lc_handle_func()[LC_CTYPE];
        cvt._Page = ___lc_codepage_func();
        _unlock_locale( local_lock_flag )

        return (cvt);
}


/***
*size_t wcrtomb(s, wchar, pst) - translate wchar_t to multibyte, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl wcrtomb(
        char *s, 
        wchar_t wchar, 
        mbstate_t *pst
        )
{
        return (s == 0 ? 1 : _Wcrtomb(s, wchar, 0, 0));
}


/***
*size_t wcsrtombs(s, pwcs, n, pst) - translate wide char string to multibyte 
*       string
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl wcsrtombs(
        char *s, 
        const wchar_t **pwcs, 
        size_t n, 
        mbstate_t *pst
        )
{
        char buf[MB_LEN_MAX];
        int i;
        size_t nc = 0;
        const wchar_t *wcs = *pwcs;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )

        if (s == 0)
            for (; ; nc += i, ++wcs)
            {   /* translate but don't store */
                if ((i = __Wcrtomb_lk(buf, *wcs, 0, 0)) <= 0) {
                    _unlock_locale( local_lock_flag )
                    return ((size_t)-1);
                }
                else if (buf[i - 1] == '\0') {
                    _unlock_locale( local_lock_flag )
                    return (nc + i - 1);
                }
            }

        for (; 0 < n; nc += i, ++wcs, s += i, n -= i)
        {   /* translate and store */
            char *t;

            if (n < (size_t)___mb_cur_max_func())
                t = buf;
            else
                t = s;

            if ((i = __Wcrtomb_lk(t, *wcs, 0, 0)) <= 0)
            {   /* encountered invalid sequence */
                nc = (size_t)-1;
                break;
            }

            if (s == t)
                ;
            else if (n < (size_t)i)
                break;  /* won't all fit */
            else
                memcpy(s, buf, i);

            if (s[i - 1] == '\0')
            {   /* encountered terminating null */
                *pwcs = 0;
                _unlock_locale( local_lock_flag )
                return (nc + i - 1);
            }
        }

        _unlock_locale( local_lock_flag )

        *pwcs = wcs;
        return (nc);
}


/***
*int wctob(wchar) - translate wint_t to one-byte multibyte
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 int __cdecl wctob(
        wint_t wchar
        )
{  
        if (wchar == WEOF)
            return (EOF);
        else
        {   /* check for one-byte translation */
            char buf[MB_LEN_MAX];
            return (_Wcrtomb(buf, wchar, 0, 0) == 1 ? buf[0] : EOF);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\delop.cpp ===
// delop -- operator delete(void *) REPLACEABLE
#include <cstdlib>
#include <xstddef>

void __cdecl operator delete(void *p) _THROW0()
	{	// free an allocated object
	free(p);
	}

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\_tolower.c ===
/***
*_tolower.c - convert character to lower case
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Tolower().
*
*Revision History:
*       01-xx-96  PJP   Created from tolower.c, January 1996 by P.J. Plauger
*       04-16-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-25-96  GJF   Added locale locking to _Getctype.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in
*                       msvcprt.lib to work with STATIC_CPPLIB
*       03-12-01  PML   Use supplied locale to check case VS7#190902
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <stdlib.h>
#include <dbgint.h>

/* remove macro definitions of _tolower() and tolower()
 */
#undef  _tolower
#undef  tolower

/***
*int _tolower(c) - convert character to lower case
*
*Purpose:
*       _tolower() is a version of tolower with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of lower case representation of c
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
int __cdecl _Tolower_lk (
        int c,
        const _Ctypevec *ploc
        );
#endif

_CRTIMP2 int __cdecl _Tolower (
        int c,
        const _Ctypevec *ploc
        )
{
#ifdef _MT

        LCID handle;
        int local_lock_flag;

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_CTYPE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'A') && (c <= 'Z') )
                c = c + ('a' - 'A');
            return c;
        }

        _lock_locale( local_lock_flag )

        c = _Tolower_lk(c, ploc);

        _unlock_locale( local_lock_flag )

        return c;
}

/***
*int _tolower_lk(c) - convert character to lower case
*
*Purpose:
*       Multi-thread function only! Non-locking version of tolower.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _Tolower_lk (
        int c,
        const _Ctypevec *ploc
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'A') && (c <= 'Z') )
                c = c + ('a' - 'A');
            return c;
        }

        /* if checking case of c does not require API call, do it */
        if ((unsigned)c < 256)
        {
            if (ploc == 0)
            {
                if (!isupper(c))
                {
                    return c;
                }
            }
            else
            {
                if (!ploc->_Table[c] & _UPPER)
                {
                    return c;
                }
            }
        }

        /* convert int c to multibyte string */
        if (_cpp_isleadbyte(c >> 8 & 0xff))
        {
            inbuffer[0] = (c >> 8 & 0xff); 
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to lowercase */
        if (0 == (size = __crtLCMapStringA(handle, LCMAP_LOWERCASE,
            inbuffer, size, outbuffer, 3, codepage, TRUE)))
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

}


/***
*_Ctypevec _Getctype() - get ctype info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Ctypevec __cdecl _Getctype()
{       
        /* get ctype info for current locale */
        _Ctypevec ctype;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )

        ctype._Hand = ___lc_handle_func()[LC_COLLATE];
        ctype._Page = ___lc_codepage_func();
        ctype._Table = _malloc_crt(256 * sizeof (*__pctype_func()));
        if (ctype._Table != 0)
        {
            memcpy((void *)ctype._Table, __pctype_func(), 256 * sizeof (*__pctype_func()));
            ctype._Delfl = 1; 
        }
        else
        {
            ctype._Table = (const short *)__pctype_func();
            ctype._Delfl = 0; 
        }

        _unlock_locale( local_lock_flag )

        return (ctype);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\delop_s.cpp ===
//  delop_s.cpp - version of delop.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "delop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp\_toupper.c ===
/***
*_toupper.c - convert character to uppercase
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Toupper()
*
*Revision History:.
*       01-XX-96  PJP   Created from toupper.c January 1996 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in
*                       msvcprt.lib to work with STATIC_CPPLIB
*       03-12-01  PML   Use supplied locale to check case VS7#190902
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/* remove macro definitions of _toupper() and toupper()
 */
#undef  _toupper
#undef  toupper

/***
*int _toupper(c) - convert character to uppercase
*
*Purpose:
*       _toupper() is a version of toupper with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of uppercase representation of c
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
int __cdecl _Toupper_lk (
        int c,
        const _Ctypevec *ploc
        );
#endif

_CRTIMP2 int __cdecl _Toupper (
        int c,
        const _Ctypevec *ploc
        )
{
#ifdef _MT

        LCID handle;
        int local_lock_flag;

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_CTYPE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'a') && (c <= 'z') )
                c = c - ('a' - 'A');
            return c;
        }

        _lock_locale( local_lock_flag )

        c = _Toupper_lk(c, ploc);

        _unlock_locale( local_lock_flag )

        return c;
}

/***
*int _toupper_lk(c) - convert character to uppercase
*
*Purpose:
*       Multi-thread function only! Non-locking version of toupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _Toupper_lk (
        int c,
        const _Ctypevec *ploc
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'a') && (c <= 'z') )
                c = c - ('a' - 'A');
            return c;
        }

        /* if checking case of c does not require API call, do it */
        if ((unsigned)c < 256)
        {
            if (ploc == 0)
            {
                if (!islower(c))
                {
                    return c;
                }
            }
            else
            {
                if (!ploc->_Table[c] & _LOWER)
                {
                    return c;
                }
            }
        }

        /* convert int c to multibyte string */
        if (_cpp_isleadbyte(c >> 8 & 0xff))
        {
            inbuffer[0] = (c >> 8 & 0xff); 
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to uppercase */
        if (0 == (size = __crtLCMapStringA(handle, LCMAP_UPPERCASE,
            inbuffer, size, outbuffer, 3, codepage, TRUE)))
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\delop2.cpp ===
// delop2 -- operator delete(void *, nothrow_t) REPLACEABLE
#include <new>

 #if (1200 <= _MSC_VER)
void __cdecl operator delete(void *p,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	delete(p);
	}
 #else
 #endif

/*
 * Copyright (c) 1999 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 V2.33:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\ios.cpp ===
// ios_base -- ios_base basic members
#include <new>
#include <xiosbase>
#include <xstddef>
_STD_BEGIN

#define NSTDSTR	8	/* cin, wcin, etc. */

extern _CRTIMP2 const fpos_t _Fpz;

int ios_base::_Index = 0;
bool ios_base::_Sync = true;
const fpos_t _Fpz = {0};

static ios_base *stdstr[NSTDSTR + 1] = {0};
static char stdopens[NSTDSTR + 1] = {0};

void ios_base::clear(iostate ns, bool ex)
	{	// clear all but selected state bits
	_State = (iostate)(ns & _Statmask);
	if ((_State & _Except) == 0)
		;
	else if (ex)
		_RERAISE;
	else
		_THROW(failure,
			_State & _Except & badbit ? "ios::badbit set"
			: _State & _Except & failbit ? "ios::failbit set"
			: "ios::eofbit set");
	}

ios_base& ios_base::copyfmt(const ios_base& rhs)
	{	// copy format info from another ios_base
	if (this != &rhs)
		{	// copy all but _State
		_Tidy();
		_Loc = rhs._Loc;
		_Fmtfl = rhs._Fmtfl;
		_Prec = rhs._Prec;
		_Wide = rhs._Wide;
		_Iosarray *p = rhs._Arr;
		for (_Arr = 0; p != 0; p = p->_Next)
			if (p->_Lo != 0 || p->_Vp != 0)
				{	// copy over nonzero array values
				iword(p->_Index) = p->_Lo;
				pword(p->_Index) = p->_Vp;
				}
		_Callfns(copyfmt_event);
		exceptions(rhs._Except);	// cause any throw at end
		}
	return (*this);
	}

locale ios_base::imbue(const locale& _Ln)
	{	// imbue a new locale into stream
	locale _Lo = _Loc;
	_Loc = _Ln;
	_Callfns(imbue_event);
	return (_Lo);
	}

void ios_base::register_callback(event_callback _P, int _Idx)
	{	// register a callback function
	if ((_Calls = new _Fnarray(_Idx, _P, _Calls)) == 0)
		_Nomemory();
	}

ios_base::~ios_base()
	{	// destruct an ios_base
	if (0 < _Stdstr && 0 < --stdopens[_Stdstr])
		return;
	_Tidy();
	}

void ios_base::_Callfns(event ev)
	{	// call registered functions
	_Fnarray *p;
	for (p = _Calls; p != 0; p = p->_Next)
		(*p->_Pfn)(ev, *this, p->_Index);
	}

ios_base::_Iosarray& ios_base::_Findarr(int idx)
	{	// locate or make a variable array element
	_Iosarray *p, *q;
	if (idx < 0)
		_THROW(failure, "invalid ios::iword/pword index");
	for (p = _Arr, q = 0; p != 0; p = p->_Next)
		if (p->_Index == idx)
			return (*p);
		else if (q == 0 && p->_Lo == 0 && p->_Vp == 0)
			q = p;
	if (q != 0)
		{	// recycle existing element
		q->_Index = idx;
		return (*q);
		}
	if ((_Arr = new _Iosarray(idx, _Arr)) == 0)
		_Nomemory();
	return (*_Arr);
	}

void ios_base::_Addstd()
	{	// add standard stream to destructor list
	_Lockit _Lk;
	for (; _Stdstr < NSTDSTR; ++_Stdstr)
		if (stdstr[_Stdstr] == 0 || stdstr[_Stdstr] == this)
			break;
	stdstr[_Stdstr] = this;
	++stdopens[_Stdstr];
	}

void ios_base::_Init()
	{	// initialize a new ios_base
	new (&_Loc) locale;
	_Except = goodbit;
	_Fmtfl = skipws | dec;
	_Prec = 6;
	_Wide = 0;
	_Arr = 0;
	_Calls = 0;
	clear(goodbit);
	}

void ios_base::_Tidy()
	{	// discard storage for an ios_base
	_Callfns(erase_event);
	_Iosarray *q1, *q2;
	for (q1 = _Arr; q1 != 0; q1 = q2)
		q2 = q1->_Next, delete q1;
	_Arr = 0;
	_Fnarray *q3, *q4;
	for (q3 = _Calls; q3 != 0; q3 = q4)
		q4 = q3->_Next, delete q3;
	_Calls = 0;
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\iostream.cpp ===
// iostream -- ios::Init members, initialize standard streams
#include <locale>
#include <fstream>
#include <istream>	/* NOT <iostream> */
#include <new>
_STD_BEGIN

		// OBJECT DECLARATIONS
int ios_base::Init::_Init_cnt = -1;
static filebuf fin(_Noinit);
static filebuf fout(_Noinit);
_CRTIMP2 istream cin(_Noinit);
_CRTIMP2 ostream cout(_Noinit);
static filebuf ferr(_Noinit);
_CRTIMP2 ostream cerr(_Noinit);
_CRTIMP2 ostream clog(_Noinit);

_CRTIMP2 ios_base::Init::Init()
	{	// initialize standard streams first time
	bool doinit;
		{_Lockit _Lk;
		if (0 <= _Init_cnt)
			++_Init_cnt, doinit = false;
		else
			_Init_cnt = 1, doinit = true; }
	if (doinit)
		{	// initialize standard streams
		new (&fin) filebuf(stdin);
		new (&fout) filebuf(stdout);
		new (&cin) istream(&fin, true);
		new (&cout) ostream(&fout, true);
		cin.tie(&cout);
		new (&ferr) filebuf(stderr);
		new (&cerr) ostream(&ferr, true);
		cerr.tie(&cout);
		cerr.setf(ios_base::unitbuf);
		new (&clog) ostream(&ferr, true);
		clog.tie(&cout);
		}
	}

_CRTIMP2 ios_base::Init::~Init()
	{	// flush standard streams last time
	bool doflush;
		{_Lockit _Lk;
		if (--_Init_cnt == 0)
			doflush = true;
		else
			doflush = false; }
	if (doflush)
		{	// flush standard streams
		cout.flush();
		cerr.flush();
		clog.flush();
		}
_STD_END
	}

const char _PJP_CPP_Copyright[] =
	"Portions of this work are derived"
	" from 'The Draft Standard C++ Library',\n"
	"copyright (c) 1994-1995 by P.J. Plauger,"
	" published by Prentice-Hall,\n"
	"and are used with permission.";

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\fiopen.cpp ===
// fiopen -- [w]filebuf::_Fiopen(const char *, ios::openmode)
#include <locale>
#include <fstream>
_STD_BEGIN

_CRTIMP2 FILE *__cdecl __Fiopen(const char *name,
	ios_base::openmode mode)
	{	// open a file
	static const char *mods[] = {
		"r", "w", "w", "a", "rb", "wb", "wb", "ab",
			"r+", "w+", "a+", "r+b", "w+b", "a+b", 0};
	static const int valid[] = {
		ios_base::in,
		ios_base::out,
		ios_base::out | ios_base::trunc,
		ios_base::out | ios_base::app,
		ios_base::in | ios_base::binary,
		ios_base::out | ios_base::binary,
		ios_base::out | ios_base::trunc | ios_base::binary,
		ios_base::out | ios_base::app | ios_base::binary,
		ios_base::in | ios_base::out,
		ios_base::in | ios_base::out | ios_base::trunc,
		ios_base::in | ios_base::out | ios_base::app,
		ios_base::in | ios_base::out | ios_base::binary,
		ios_base::in | ios_base::out | ios_base::trunc
			| ios_base::binary,
		ios_base::in | ios_base::out | ios_base::app
			| ios_base::binary,
		0};
	FILE *fp;
	int n;
	ios_base::openmode atefl = mode & ios_base::ate;
	mode &= ~ios_base::ate;
	for (n = 0; valid[n] != 0 && valid[n] != mode; ++n)
		;
	if (valid[n] == 0 || (fp = fopen(name, mods[n])) == 0)
		return (0);
	if (!atefl || fseek(fp, 0, SEEK_END) == 0)
		return (fp);
	fclose(fp);	// can't position at end
	return (0);
	}

_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\iomanip.cpp ===
// iomanip -- instantiations of iomanip
#include <locale>
#include <iomanip>
_STD_BEGIN
		// function resetiosflags
static void rsfun(ios_base& iostr, ios_base::fmtflags mask)
	{iostr.setf(ios_base::_Fmtzero, mask); }

		// function setiosflags
static void sifun(ios_base& iostr, ios_base::fmtflags mask)
	{iostr.setf(ios_base::_Fmtmask, mask); }

		// function setbase
static void sbfun(ios_base& iostr, int n)
	{iostr.setf(n == 8 ? ios_base::oct : n == 10 ? ios_base::dec
		: n == 16 ? ios_base::hex : ios_base::_Fmtzero,
			ios_base::basefield); }

		// function setprecision
static void spfun(ios_base& iostr, streamsize n)
	{iostr.precision(n); }

		// function setw
static void swfun(ios_base& iostr, streamsize n)
	{iostr.width(n); }

_CRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl resetiosflags(ios_base::fmtflags mask)
	{return (_Smanip<ios_base::fmtflags>(&rsfun, mask)); }

_CRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl setiosflags(ios_base::fmtflags mask)
	{return (_Smanip<ios_base::fmtflags>(&sifun, mask)); }

_CRTIMP2 _Smanip<int> __cdecl setbase(int n)
	{return (_Smanip<int>(&sbfun, n)); }

_CRTIMP2 _Smanip<streamsize> __cdecl setprecision(streamsize n)
	{return (_Smanip<streamsize>(&spfun, n)); }

_CRTIMP2 _Smanip<streamsize> __cdecl setw(streamsize n)
	{return (_Smanip<streamsize>(&swfun, n)); }
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\newop2_s.cpp ===
//  newop2_s.cpp - version of newop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\newop_s.cpp ===
//  newop_s.cpp - version of newop.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\dlldef.cpp ===
// dlldef.cpp - definitions for C++ DLL

#define __FORCE_INSTANCE

#pragma warning(disable:4667)

#ifdef _DEBUG
#pragma warning(disable:4786)
#endif

#include <limits>
#include <istream>
#include <sstream>
#include <xstring>
#include <iomanip>
#include <fstream>
#include <locale>
#include <complex>

_STD_BEGIN

template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, char&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, signed char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, signed char&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, signed short *);

template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const signed char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const signed char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const unsigned char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const unsigned char);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, wchar_t);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const signed short *);

template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > operator+(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > operator+(
        const char, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2 bool operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator==(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator!=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator<(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator>(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator<=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator>=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);

template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > operator+(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > operator+(
        const wchar_t, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,        const wchar_t);
template _CRTIMP2 bool operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator==(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator!=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator<(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator>(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator<=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator>=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);

template _CRTIMP2 complex<float>& operator+=(
        complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float>& operator-=(
        complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float>& operator*=(
        complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float>& operator/=(
        complex<float>&, const complex<float>&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, complex<float>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<float>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<float>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<float>&);

template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, int);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, unsigned int);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, short);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, unsigned short);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, long);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, unsigned long);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, int);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, unsigned int);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, short);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, unsigned short);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, long);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, unsigned long);

template _CRTIMP2 complex<double>& operator+=(
        complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double>& operator-=(
        complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double>& operator*=(
        complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double>& operator/=(
        complex<double>&, const complex<double>&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, complex<double>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<double>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<double>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<double>&);

template _CRTIMP2 complex<long double>& operator+=(
        complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double>& operator-=(
        complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double>& operator*=(
        complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double>& operator/=(
        complex<long double>&, const complex<long double>&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& operator>>(
        basic_istream<char, char_traits<char> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<long double>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<long double>&);

template _CRTIMP2 float imag(const complex<float>&);
template _CRTIMP2 float real(const complex<float>&);
template _CRTIMP2 float _Fabs(const complex<float>&, int *);
template _CRTIMP2 complex<float> operator+(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> operator+(const complex<float>&, const float&);
template _CRTIMP2 complex<float> operator+(const float&, const complex<float>&);
template _CRTIMP2 complex<float> operator-(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> operator-(const complex<float>&, const float&);
template _CRTIMP2 complex<float> operator-(const float&, const complex<float>&);
template _CRTIMP2 complex<float> operator*(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> operator*(const complex<float>&, const float&);
template _CRTIMP2 complex<float> operator*(const float&, const complex<float>&);
template _CRTIMP2 complex<float> operator/(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> operator/(const complex<float>&, const float&);
template _CRTIMP2 complex<float> operator/(const float&, const complex<float>&);
template _CRTIMP2 complex<float> operator+(const complex<float>&);
template _CRTIMP2 complex<float> operator-(const complex<float>&);
template _CRTIMP2 bool operator==(const complex<float>&, const complex<float>&);
template _CRTIMP2 bool operator==(const complex<float>&, const float&);
template _CRTIMP2 bool operator==(const float&, const complex<float>&);
template _CRTIMP2 bool operator!=(const complex<float>&, const complex<float>&);
template _CRTIMP2 bool operator!=(const complex<float>&, const float&);
template _CRTIMP2 bool operator!=(const float&, const complex<float>&);
template _CRTIMP2 float abs(const complex<float>&);
template _CRTIMP2 float arg(const complex<float>&);
template _CRTIMP2 complex<float> conj(const complex<float>&);
template _CRTIMP2 complex<float> cos(const complex<float>&);
template _CRTIMP2 complex<float> cosh(const complex<float>&);
template _CRTIMP2 complex<float> exp(const complex<float>&);
template _CRTIMP2 complex<float> log(const complex<float>&);
template _CRTIMP2 complex<float> log10(const complex<float>&);
template _CRTIMP2 float norm(const complex<float>&);
template _CRTIMP2 complex<float> polar(const float&, const float&);
template _CRTIMP2 complex<float> polar(const float&);
template _CRTIMP2 complex<float> pow(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> pow(const complex<float>&, const float&);
template _CRTIMP2 complex<float> pow(const complex<float>&, int);
template _CRTIMP2 complex<float> pow(const float&, const complex<float>&);
template _CRTIMP2 complex<float> sin(const complex<float>&);
template _CRTIMP2 complex<float> sinh(const complex<float>&);
template _CRTIMP2 complex<float> sqrt(const complex<float>&);

template _CRTIMP2 double imag(const complex<double>&);
template _CRTIMP2 double real(const complex<double>&);
template _CRTIMP2 double _Fabs(const complex<double>&, int *);
template _CRTIMP2 complex<double> operator+(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> operator+(const complex<double>&, const double&);
template _CRTIMP2 complex<double> operator+(const double&, const complex<double>&);
template _CRTIMP2 complex<double> operator-(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> operator-(const complex<double>&, const double&);
template _CRTIMP2 complex<double> operator-(const double&, const complex<double>&);
template _CRTIMP2 complex<double> operator*(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> operator*(const complex<double>&, const double&);
template _CRTIMP2 complex<double> operator*(const double&, const complex<double>&);
template _CRTIMP2 complex<double> operator/(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> operator/(const complex<double>&, const double&);
template _CRTIMP2 complex<double> operator/(const double&, const complex<double>&);
template _CRTIMP2 complex<double> operator+(const complex<double>&);
template _CRTIMP2 complex<double> operator-(const complex<double>&);
template _CRTIMP2 bool operator==(const complex<double>&, const complex<double>&);
template _CRTIMP2 bool operator==(const complex<double>&, const double&);
template _CRTIMP2 bool operator==(const double&, const complex<double>&);
template _CRTIMP2 bool operator!=(const complex<double>&, const complex<double>&);
template _CRTIMP2 bool operator!=(const complex<double>&, const double&);
template _CRTIMP2 bool operator!=(const double&, const complex<double>&);
template _CRTIMP2 double abs(const complex<double>&);
template _CRTIMP2 double arg(const complex<double>&);
template _CRTIMP2 complex<double> conj(const complex<double>&);
template _CRTIMP2 complex<double> cos(const complex<double>&);
template _CRTIMP2 complex<double> cosh(const complex<double>&);
template _CRTIMP2 complex<double> exp(const complex<double>&);
template _CRTIMP2 complex<double> log(const complex<double>&);
template _CRTIMP2 complex<double> log10(const complex<double>&);
template _CRTIMP2 double norm(const complex<double>&);
template _CRTIMP2 complex<double> polar(const double&, const double&);
template _CRTIMP2 complex<double> polar(const double&);
template _CRTIMP2 complex<double> pow(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> pow(const complex<double>&, const double&);
template _CRTIMP2 complex<double> pow(const complex<double>&, int);
template _CRTIMP2 complex<double> pow(const double&, const complex<double>&);
template _CRTIMP2 complex<double> sin(const complex<double>&);
template _CRTIMP2 complex<double> sinh(const complex<double>&);
template _CRTIMP2 complex<double> sqrt(const complex<double>&);

template _CRTIMP2 long double imag(const complex<long double>&);
template _CRTIMP2 long double real(const complex<long double>&);
template _CRTIMP2 long double _Fabs(const complex<long double>&, int *);
template _CRTIMP2 complex<long double> operator+(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator+(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> operator+(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator-(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator-(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> operator-(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator*(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator*(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> operator*(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator/(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator/(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> operator/(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> operator+(const complex<long double>&);
template _CRTIMP2 complex<long double> operator-(const complex<long double>&);
template _CRTIMP2 bool operator==(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 bool operator==(const complex<long double>&, const long double&);
template _CRTIMP2 bool operator==(const long double&, const complex<long double>&);
template _CRTIMP2 bool operator!=(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 bool operator!=(const complex<long double>&, const long double&);
template _CRTIMP2 bool operator!=(const long double&, const complex<long double>&);
template _CRTIMP2 long double abs(const complex<long double>&);
template _CRTIMP2 long double arg(const complex<long double>&);
template _CRTIMP2 complex<long double> conj(const complex<long double>&);
template _CRTIMP2 complex<long double> cos(const complex<long double>&);
template _CRTIMP2 complex<long double> cosh(const complex<long double>&);
template _CRTIMP2 complex<long double> exp(const complex<long double>&);
template _CRTIMP2 complex<long double> log(const complex<long double>&);
template _CRTIMP2 complex<long double> log10(const complex<long double>&);
template _CRTIMP2 long double norm(const complex<long double>&);
template _CRTIMP2 complex<long double> polar(const long double&, const long double&);
template _CRTIMP2 complex<long double> polar(const long double&);
template _CRTIMP2 complex<long double> pow(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> pow(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> pow(const complex<long double>&, int);
template _CRTIMP2 complex<long double> pow(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> sin(const complex<long double>&);
template _CRTIMP2 complex<long double> sinh(const complex<long double>&);
template _CRTIMP2 complex<long double> sqrt(const complex<long double>&);

template<> const basic_string<char, char_traits<char>, allocator<char> >::size_type
        basic_string<char, char_traits<char>, allocator<char> >::npos = -1;
template<> const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::size_type
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::npos = -1;

_STD_END

#ifdef _DEBUG
#pragma warning(default:4786)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\locale0.cpp ===
// locale0 -- class locale basic member functions
#include <climits>
#include <locale>
_STD_BEGIN

static locale classic_locale(_Noinit);
locale::_Locimp *locale::_Locimp::_Clocptr = 0;
locale::_Locimp *locale::_Locimp::_Global = 0;
int locale::id::_Id_cnt = 0;

const ctype_base::mask *ctype<char>::_Cltab = 0;
const size_t ctype<char>::table_size = 1 << CHAR_BIT;

const locale& __cdecl locale::classic()
        {       // get reference to "C" locale
        _Init();
        _Lockit _Lk;
        return (classic_locale);
        }

locale __cdecl locale::empty()
        {       // make empty transparent locale
        _Init();
        return (locale(new _Locimp(true)));
        }

const locale::facet *locale::_Getfacet(size_t _Id,
        bool _Xp) const
        {       // look up a facet in locale object
        _Lockit _Lk;
        const facet *_F = _Id < _Ptr->_Nfv ? _Ptr->_Fv[_Id] : 0;
        return (_F != 0 || !_Xp || !_Ptr->_Xpar ? _F
                : _Id < _Locimp::_Global->_Nfv
                        ? _Locimp::_Global->_Fv[_Id] : 0);
        }

bool locale::_Iscloc() const
        {       // test for underlying dummy C locale object
        _Lockit _Lk;
        return (_Ptr == _Locimp::_Clocptr || _Ptr->_Xpar
                && _Locimp::_Global == _Locimp::_Clocptr);
        }

bool locale::operator==(const locale& _X) const
        {       // compare locales for equality
        return (_Ptr == _X._Ptr || name().compare("*") != 0
                && name().compare(_X.name()) == 0);
        }

locale::_Locimp *__cdecl locale::_Init()
        {       // setup _Global and "C" locales
        _Lockit _Lk;
        if (_Locimp::_Global == 0)
                {       // create new locales
                _Locimp::_Global = new _Locimp;
                atexit(&_Tidy);
                _Locimp::_Global->_Cat = all;
                _Locimp::_Global->_Name = "C";
                _Locimp::_Clocptr = _Locimp::_Global;
                _Locimp::_Clocptr->_Incref();
                new (&classic_locale) locale(_Locimp::_Clocptr);
                }
        return (_Locimp::_Global);
        }

void __cdecl locale::_Tidy()
        {       // discard _Global locale
        _Lockit _Lk;
        if (_Locimp::_Global != 0)
                delete _Locimp::_Global->_Decref();
        }

locale::_Locimp::_Locimp(bool _Xp)
        : locale::facet(1), _Fv(0), _Nfv(0),
                _Cat(none), _Xpar(_Xp), _Name("*")
        {       // construct an empty _Locimp
        }

locale::_Locimp::~_Locimp()
        {       // destruct a _Locimp
        _Lockit _Lk;
        for (size_t _N = _Nfv; 0 < _N; )
                if (_Fv[--_N] != 0)
                        delete _Fv[_N]->_Decref();
        free(_Fv);
        }
_STD_END

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\newop.cpp ===
// newop operator new(size_t) for Microsoft C++
#include <cstdlib>
#include <xstddef>
#include <new>
#include <dbgint.h>

#if !defined(_MSC_EXTENSIONS)
#define RESERVE_SIZE    256     /* for out-of-heap handling */

static void *pres = 0;

_C_LIB_DECL
int _callnewh(size_t size);

#ifdef  _DLL
static void __cdecl cleanup_pres(void)
	{	// free reserved block
	if (pres != 0)
		_free_crt(pres);
	}
#endif
_END_C_LIB_DECL

void *__cdecl operator new(size_t size) _THROW1(_STD bad_alloc)
	{	// try to allocate size bytes
	static void *pres = 0;
		{_STD _Lockit _Lk;
#ifdef  _DLL
		static int firsttime = 0;
		if (firsttime == 0)
			{	// register routine to clean up reserve space
			atexit(&cleanup_pres);
			++firsttime;
			}
#endif
		if (pres == 0)
			pres = _malloc_crt(RESERVE_SIZE);
		}
	void *p;
	while ((p = malloc(size)) == 0)
		{	// handle failure to allocate
			{_STD _Lockit _Lk;
			if (pres != 0)
				{	// free reserve space
				_free_crt(pres);
				pres = 0;
				}
			}
		if (_callnewh(size) == 0)
			break;
		}
	if (p == 0)
		_STD _Nomemory();
	return (p);
	}

#endif

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
950330 pjp: added throw clause
950608 pjp: added reserve space
960214 pjp: added locks
960313 pjp: tidied headers
960317 pjp: put new/delete in global namespace
961026 pjp: added logic to free reserved block
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\nomemory.cpp ===
// nomemory -- report out of memory
#include <new>
_STD_BEGIN

void _CRTIMP2 __cdecl _Nomemory()
	{	// report out of memory
	static const bad_alloc nomem;
	_RAISE(nomem);
	}

const nothrow_t nothrow;

_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\locale.cpp ===
// locale -- class locale member functions
#include <cstdlib>
#include <istream>
#include <locale>
_STD_BEGIN

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

locale::locale(const locale& _X, const locale& _Y, category _C)
        : _Ptr(new _Locimp(*_X._Ptr))
        {       // construct a locale by copying named facets
        _Locinfo _Lobj(_X._Ptr->_Cat, _X._Ptr->_Name.c_str());
        _Locimp::_Makeloc(_Lobj._Addcats(_C & _Y._Ptr->_Cat,
                _Y._Ptr->_Name.c_str()), _C, _Ptr, &_Y);
        }

locale::locale(const char *_S, category _C)
        : _Ptr(new _Locimp)
        {       // construct a locale with named facets
        _Init();
        _Locinfo _Lobj(_C, _S);
        if (_Lobj._Getname().compare("*") == 0)
                _THROW(runtime_error, "bad locale name");
        _Locimp::_Makeloc(_Lobj, _C, _Ptr, 0);
        }

locale::locale(const locale& _X, const char *_S, category _C)
        : _Ptr(new _Locimp(*_X._Ptr))
        {       // construct a locale by copying, replacing named facets
        _Locinfo _Lobj(_C, _S);
        if (_Lobj._Getname().compare("*") == 0)
                _THROW(runtime_error, "bad locale name");
        _Locimp::_Makeloc(_Lobj._Addcats(_Ptr->_Cat,
                _Ptr->_Name.c_str()), _C, _Ptr, 0);
        }

locale& locale::_Addfac(facet *_Fac, size_t _Id, size_t _Cat)
        {       // add a facet, copying on write
        if (1 < _Ptr->_Refs)
                {_Ptr->_Decref();
                _Ptr = new _Locimp(*_Ptr); }
        _Ptr->_Addfac(_Fac, _Id);
        if (_Cat != 0)
                _Ptr->_Name = "*";
        return (*this); }

locale __cdecl locale::global(const locale& _X)
        {       // change global locale
        locale _L;
        _Lockit _Lk;
        if (_Locimp::_Global != _X._Ptr)
                {       // set new global locale
                delete _Locimp::_Global->_Decref();
                _Locimp::_Global = _X._Ptr;
                _Locimp::_Global->_Incref();
                category _Cmask = _Locimp::_Global->_Cat & all;
                if (_Cmask == all)
                        setlocale(LC_ALL, _Locimp::_Global->_Name.c_str());
                else
                        for (int _Cat = 0; _Cat <= _LC_MAX; ++_Cat)
                                if ((_CATMASK(_Cat) & _Cmask) != 0)
                                        setlocale(_Cat,
                                                _Locimp::_Global->_Name.c_str());
                }
        return (_L);
        }

        // facets associated with C categories
#define ADDFAC(T, cat, pi, pl) \
        if ((_CATMASK(T::_Getcat()) & cat) == 0) \
                ; \
        else if (pl == 0) \
                pi->_Addfac(new T(_Lobj), T::id); \
        else \
                pi->_Addfac((locale::facet *)&_USE(*pl, T), T::id);

typedef ctype<char> _T1;
typedef num_get<char, _Initer> _T2;
typedef num_put<char, _Outiter> _T3;
typedef numpunct<char> _T4;

typedef codecvt<char, char, mbstate_t> _Tc1;

template<> locale::id ctype<char>::id;
template<> locale::id codecvt<char,char,int>::id;
template<> locale::id num_get<char, _Initer>::id;
template<> locale::id num_put<char, _Outiter>::id;
template<> locale::id numpunct<char>::id;

locale::_Locimp *__cdecl locale::_Locimp::_Makeloc(
        const _Locinfo& _Lobj, locale::category _C,
                _Locimp *_Pi, const locale *_Pl)
        {       // setup a new locale
        _Lockit _Lk;
        ADDFAC(_T1, _C, _Pi, _Pl);
        ADDFAC(_T2, _C, _Pi, _Pl);
        ADDFAC(_T3, _C, _Pi, _Pl);
        ADDFAC(_T4, _C, _Pi, _Pl);
        //...
        ADDFAC(_Tc1, _C, _Pi, _Pl);
        _Locimp::_Makexloc(_Lobj, _C, _Pi, _Pl);
        _Locimp::_Makewloc(_Lobj, _C, _Pi, _Pl);
        _Pi->_Cat |= _C;
        _Pi->_Name = _Lobj._Getname();
        return (_Pi);
        }

locale::_Locimp::_Locimp(const locale::_Locimp& _X)
        : locale::facet(1), _Fv(0), _Nfv(_X._Nfv),
                _Cat(_X._Cat), _Xpar(_X._Xpar), _Name(_X._Name)
        {       // construct a _Locimp from a copy
        _Lockit Lk;
        if (&_X == _Clocptr)
                _Makeloc(_Locinfo(), locale::all, this, 0);
        else
                {_Lockit _Lk;
                if (0 < _Nfv)
                        {       // copy over nonempty facet vector
                        if ((_Fv = (locale::facet **)malloc(
                                _Nfv * sizeof (locale::facet *))) == 0)
                                _Nomemory();
                        for (size_t _N = _Nfv; 0 < _N; )
                                {       // copy over facet pointers
                                locale::facet *_Pf = _X._Fv[--_N];
                                if ((_Fv[_N] = _Pf) != 0)
                                        _Pf->_Incref();
                                }
                        }
                }
        }

void locale::_Locimp::_Addfac(locale::facet *_Pf, size_t _Id)
        {       // add a facet to a locale
        _Lockit _Lk;
        const size_t _MINCAT = 32;
        if (_Nfv <= _Id)
                {       // make facet vector larger
                size_t _N = _Id + 1;
                if (_N < _MINCAT)
                        _N = _MINCAT;
                locale::facet **_Pvn = (locale::facet **)realloc(_Fv,
                        _N * sizeof (locale::facet **));
                if (_Pvn == 0)
                        _Nomemory();
                _Fv = _Pvn;
                for (; _Nfv < _N; ++_Nfv)
                        _Fv[_Nfv] = 0;
                }
        _Pf->_Incref();
        if (_Fv[_Id] != 0)
                delete _Fv[_Id]->_Decref();
        _Fv[_Id] = _Pf;
        }

_CRTIMP2 _Locinfo::_Locinfo(const char *_Name)
        {       // switch to a named locale
        _Lockit _Lk;
        _Oname = setlocale(LC_ALL, 0);
        _Nname = _Name == 0
                || (_Name = setlocale(LC_ALL, _Name)) == 0
                        ? "*" : _Name; }

_CRTIMP2 _Locinfo::_Locinfo(int _C, const char *_Name)
        {
        _Lockit _Lk;
        _Addcats(_C, _Name);
        }


_CRTIMP2 _Locinfo::~_Locinfo()
        {       // destroy a _Locinfo object, revert locale
        if (0 < _Oname.size())
                setlocale(LC_ALL, _Oname.c_str()); }

_CRTIMP2 _Locinfo& _Locinfo::_Addcats(int _C, const char *_Name)
        {       // merge in another named locale
        const char *_Lname = 0;
        if (_C == 0)
                _Lname = setlocale(LC_ALL, 0);
        else if (_C == _M_ALL)
                _Lname = setlocale(LC_ALL, _Name);
        else
                for (int _Cat = 0; _Cat <= _LC_MAX; ++_Cat)
                        if ((_CATMASK(_Cat) & _C) != 0)
                                _Lname = setlocale(_Cat, _Name);
        _Nname = _Lname != 0 ? _Lname : "*";
        return (*this); }

_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\string.cpp ===
// string -- template string support functions
#include <locale>
#include <istream>
_STD_BEGIN

		// report a length_error
_CRTIMP2 void __cdecl _Xlen()
	{_THROW(length_error, "string too long"); }

		// report an out_of_range error
_CRTIMP2 void __cdecl _Xran()
	{_THROW(out_of_range, "invalid string position"); }
_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\strstrea.cpp ===
// strstreambuf -- strstreambuf basic members
#include <climits>
#include <cstdlib>
#include <cstring>
#include <locale>
#include <strstream>
_STD_BEGIN

_CRTIMP2 istrstream::~istrstream()
	{	// destruct an istrstream
	}

_CRTIMP2 ostrstream::ostrstream(char *s, streamsize n, openmode mode)
	: ostream(&_Sb),
	_Sb(s, n, s == 0 || (mode & app) == 0 ? s : s + strlen(s))
	{	// write at terminating null (if there)
	}

_CRTIMP2 ostrstream::~ostrstream()
	{	// destruct an ostrstream
	}

_CRTIMP2 strstream::strstream(char *s, streamsize n, openmode mode)
	: iostream(&_Sb),
	_Sb(s, n, s == 0 || (mode & app) == 0 ? s : s + strlen(s))
	{	// write at terminating null (if there)
	}

_CRTIMP2 strstream::~strstream()
	{	// destruct a strstream
	}

_CRTIMP2 strstreambuf::~strstreambuf()
	{	// destruct a strstreambuf
	_Tidy();
	}

_CRTIMP2 void strstreambuf::freeze(bool freezeit)
	{	// freeze a dynamic string
	if (freezeit && !(_Strmode & _Frozen))
		{	// disable writing
		_Strmode |= _Frozen;
		_Pendsave = epptr();
		setp(pbase(), pptr(), eback());
		}
	else if (!freezeit && _Strmode & _Frozen)
		{	// re-enable writing
		_Strmode &= ~_Frozen;
		setp(pbase(), pptr(), _Pendsave);
		}
	}

_CRTIMP2 int strstreambuf::overflow(int ch)
	{	// try to extend write area
	if (ch == EOF)
		return (0);
	else if (pptr() != 0 && pptr() < epptr())
		return ((unsigned char)(*_Pninc() = (char)ch));
	else if (!(_Strmode & _Dynamic)
		|| _Strmode & (_Constant | _Frozen))
		return (EOF);
	else
		{	// okay to extend
		int osize = gptr() == 0 ? 0 : epptr() - eback();
		int nsize = osize + _Alsize;
		char *p = _Palloc != 0 ? (char *)(*_Palloc)(nsize)
			: new char[nsize];
		if (p == 0)
			return (EOF);
		if (0 < osize)
			memcpy(p, eback(), osize);
		else if (_ALSIZE < _Alsize)
			_Alsize = _ALSIZE;
		if (!(_Strmode & _Allocated))
			;
		else if (_Pfree != 0)
			(*_Pfree)(eback());
		else
			delete[] eback();
		_Strmode |= _Allocated;
		if (osize == 0)
			{	// setup new buffer
			_Seekhigh = p;
			setp(p, p + nsize);
			setg(p, p, p);
			}
		else
			{	// revise old pointers
			_Seekhigh = _Seekhigh - eback() + p;
			setp(pbase() - eback() + p, pptr() - eback() + p,
				p + nsize);
			setg(p, gptr() - eback() + p, pptr() + 1);
			}
		return ((unsigned char)(*_Pninc() = (char)ch));
		}
	}

_CRTIMP2 int strstreambuf::pbackfail(int ch)
	{	// try to putback a character
	if (gptr() == 0 || gptr() <= eback()
		|| ch != EOF
			&& (unsigned char)ch != (unsigned char)gptr()[-1]
			&& _Strmode & _Constant)
		return (EOF);
	else
		{	// safe to back up
		gbump(-1);
		return (ch == EOF ? 0 : (unsigned char)(*gptr() = (char)ch));
		}
	}

_CRTIMP2 int strstreambuf::underflow()
	{	// read only if read position available
	if (gptr() == 0)
		return (EOF);
	else if (gptr() < egptr())
		return ((unsigned char)*gptr());
	else if (pptr() == 0
		|| pptr() <= gptr() && _Seekhigh <= gptr())
		return (EOF);
	else
		{	// update _Seekhigh and expand read region
		if (_Seekhigh < pptr())
			_Seekhigh = pptr();
		setg(eback(), gptr(), _Seekhigh);
		return ((unsigned char)*gptr());
		}
	}

_CRTIMP2 streampos strstreambuf::seekoff(streamoff off,
	ios::seekdir way, ios::openmode which)
	{	// seek by specified offset
	if (pptr() != 0 && _Seekhigh < pptr())
		_Seekhigh = pptr();
	if (which & ios::in && gptr() != 0)
		{	// set input (and maybe output) pointer
		if (way == ios::end)
			off += _Seekhigh - eback();
		else if (way == ios::cur && !(which & ios::out))
			off += gptr() - eback();
		else if (way != ios::beg || off == _BADOFF)
			off = _BADOFF;
		if (0 <= off && off <= _Seekhigh - eback())
			{	// set one or two pointers
			gbump(eback() - gptr() + off);
			if (which & ios::out && pptr() != 0)
				setp(pbase(), gptr(), epptr());
			}
		else
			off = _BADOFF;
		}
	else if (which & ios::out && pptr() != 0)
		{	// set only output pointer
		if (way == ios::end)
			off += _Seekhigh - eback();
		else if (way == ios::cur)
			off += pptr() - eback();
		else if (way != ios::beg || off == _BADOFF)
			off = _BADOFF;
		if (0 <= off && off <= _Seekhigh - eback())
			pbump(eback() - pptr() + off);
		else
			off = _BADOFF;
		}
	else	// nothing to set
		off = _BADOFF;
	return (streampos(off));
	}

_CRTIMP2 streampos strstreambuf::seekpos(streampos sp,
		ios::openmode which)
	{	// seek to memorized position
	streamoff off = (streamoff)sp;
	if (pptr() != 0 && _Seekhigh < pptr())
		_Seekhigh = pptr();
	if (off == _BADOFF)
		;
	else if (which & ios::in && gptr() != 0)
		{	// set input (and maybe output) pointer
		if (0 <= off && off <= _Seekhigh - eback())
			{	// set valid offset
			gbump(eback() - gptr() + off);
			if (which & ios::out && pptr() != 0)
				setp(pbase(), gptr(), epptr());
			}
		else
			off = _BADOFF;
		}
	else if (which & ios::out && pptr() != 0)
		{	// set output pointer
		if (0 <= off && off <= _Seekhigh - eback())
			pbump(eback() - pptr() + off);
		else
			off = _BADOFF;
		}
	else	// nothing to set
		off = _BADOFF;
	return (streampos(off));
	}

_CRTIMP2 void strstreambuf::_Init(int n, char *gp, char *pp,
	_Strstate mode)
	{	// initialize with possibly static buffer
	streambuf::_Init();
	_Pendsave = 0;
	_Seekhigh = 0;
	_Palloc = 0;
	_Pfree = 0;
	_Strmode = mode;
	if (gp == 0)
		{	// make dynamic
		_Alsize = _MINSIZE <= n ? n : _ALSIZE;
		_Strmode |= _Dynamic;
		}
	else
		{	// make static
		int size = n < 0 ? INT_MAX : n == 0 ? (int)strlen(gp) : n;
		_Alsize = 0;
		_Seekhigh = gp + size;
		if (pp == 0)
			setg(gp, gp, gp + size);
		else
			{	// make writable too
			if (pp < gp)
				pp = gp;
			else if (gp + size < pp)
				pp = gp + size;
			setp(pp, gp + size);
			setg(gp, gp, pp);
			}
		}
	}

_CRTIMP2 void strstreambuf::_Tidy()
	{	// discard any allocated storage
	if ((_Strmode & (_Allocated | _Frozen)) != _Allocated)
		;
	else if (_Pfree != 0)
		(*_Pfree)(eback());
	else
		delete[] eback();
	_Seekhigh = 0;
	_Strmode &= ~(_Allocated | _Frozen);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\newop2.cpp ===
// newop2 operator new(size_t, const nothrow_t&) for Microsoft C++
#include <cstdlib>
#include <new>

_C_LIB_DECL
int _callnewh(size_t size);
_END_C_LIB_DECL

void *operator new(size_t size, const std::nothrow_t&) _THROW0()
	{	// try to allocate size bytes
	void *p;
	while ((p = malloc(size)) == 0)
		{	// buy more memory or return null pointer
		_TRY_BEGIN
			if (_callnewh(size) == 0)
				break;
		_CATCH(std::bad_alloc)
			return (0);
		_CATCH_END
		}
	return (p);
	}

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\uncaught.cpp ===
// uncaught -- dummy uncaught_exception
#include <exception>
_STD_BEGIN

_CRTIMP2 bool __cdecl uncaught_exception()
	{	// report if handling a throw
	return (false);
	}

_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\wctrans.c ===
/* towctrans/wctrans functions for Microsoft */
#include <string.h>
#include <wctype.h>
#ifndef _LIMITS
#include <yvals.h>
#endif
_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"tolower", 0},
	{"toupper", 1},
	{(const char *)0, 0}};

_CRTIMP2 wint_t (towctrans)(wint_t c, wctrans_t val)
	{	/* translate wide character */
	return (val == 1 ? towupper(c) : towlower(c));
	}

_CRTIMP2 wctrans_t (wctrans)(const char *name)
	{	/* find translation for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
951207 pjp: added new file
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\wctype.c ===
/* wctype function for Microsoft */
#include <string.h>
#include <wctype.h>
#ifndef _LIMITS
#include <yvals.h>
#endif
_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"alnum", _ALPHA|_DIGIT},
	{"alpha", _ALPHA},
	{"cntrl", _CONTROL},
	{"digit", _DIGIT},
	{"graph", _PUNCT|_ALPHA|_DIGIT},
	{"lower", _LOWER},
	{"print", _BLANK|_PUNCT|_ALPHA|_DIGIT},
	{"punct", _PUNCT},
	{"space", _SPACE},
	{"upper", _UPPER},
	{"xdigit", _HEX},
	{(const char *)0, 0}};

_CRTIMP2 wctype_t (wctype)(const char *name)
	{	/* find classification for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
951207 pjp: added new file
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\wlocale.cpp ===
// wlocale -- class locale wide member functions
#include <istream>
#include <locale>
_STD_BEGIN

typedef char_traits<wchar_t> _Wtraits;
typedef istreambuf_iterator<wchar_t, _Wtraits> _Winiter;
typedef ostreambuf_iterator<wchar_t, _Wtraits> _Woutiter;

        // facets associated with C categories
#define ADDFAC(T, cat, pi, pl) \
        if ((_CATMASK(T::_Getcat()) & cat) == 0) \
                ; \
        else if (pl == 0) \
                pi->_Addfac(new T(_Lobj), T::id); \
        else \
                pi->_Addfac((locale::facet *)&_USE(*pl, T), T::id);

typedef ctype<wchar_t> _Tw1;
typedef num_get<wchar_t, _Winiter> _Tw2;
typedef num_put<wchar_t, _Woutiter> _Tw3;
typedef numpunct<wchar_t> _Tw4;
typedef collate<wchar_t> _Tw5;
typedef messages<wchar_t> _Tw6;
typedef money_get<wchar_t, _Winiter> _Tw7;
typedef money_put<wchar_t, _Woutiter> _Tw9;
typedef moneypunct<wchar_t, false> _Tw11;
typedef moneypunct<wchar_t, true> _Tw12;
typedef time_get<wchar_t, _Winiter> _Tw13;
typedef time_put<wchar_t, _Woutiter> _Tw14;
typedef codecvt<wchar_t, char, mbstate_t> _Twc1;

template<> locale::id ctype<wchar_t>::id;
template<> locale::id codecvt<wchar_t, char, mbstate_t>::id;
template<> locale::id time_put<wchar_t, _Woutiter>::id;
template<> locale::id num_get<wchar_t, _Winiter>::id;
template<> locale::id num_put<wchar_t, _Woutiter>::id;
template<> locale::id numpunct<wchar_t>::id;
template<> locale::id collate<wchar_t>::id;
template<> locale::id messages<wchar_t>::id;
template<> locale::id money_get<wchar_t, _Winiter>::id;
template<> locale::id money_put<wchar_t, _Woutiter>::id;
template<> locale::id moneypunct<wchar_t, false>::id;
template<> locale::id moneypunct<wchar_t, true>::id;
template<> locale::id time_get<wchar_t, _Winiter>::id;

void __cdecl locale::_Locimp::_Makewloc(const _Locinfo& _Lobj,
        locale::category _C, _Locimp *_Pi, const locale *_Pl)
        {       // setup wide part of a new locale
        _Lockit lk;
        ADDFAC(_Tw1, _C, _Pi, _Pl);
        ADDFAC(_Tw2, _C, _Pi, _Pl);
        ADDFAC(_Tw3, _C, _Pi, _Pl);
        ADDFAC(_Tw4, _C, _Pi, _Pl);
        ADDFAC(_Tw5, _C, _Pi, _Pl);
        ADDFAC(_Tw6, _C, _Pi, _Pl);
        ADDFAC(_Tw7, _C, _Pi, _Pl);
        ADDFAC(_Tw9, _C, _Pi, _Pl);
        ADDFAC(_Tw11, _C, _Pi, _Pl);
        ADDFAC(_Tw12, _C, _Pi, _Pl);
        ADDFAC(_Tw13, _C, _Pi, _Pl);
        ADDFAC(_Tw14, _C, _Pi, _Pl);
        //...
        ADDFAC(_Twc1, _C, _Pi, _Pl);
        }

_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xdscale.c ===
/* _Dscale function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short _Dscale(double *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = (ps[_D0] & _DMASK) >> _DOFF;

	if (xchar == _DMAX)
		return ((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? NAN : INF);
	else if (xchar == 0 && 0 < (xchar = _Dnorm(ps)))
		return (0);
	lexp += xchar;
	if (_DMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_D0] & _DSIGN ? -_Inf._D : _Inf._D;
		return (INF);
		}
	else if (0 < lexp)
		{	/* finite result, repack */
		ps[_D0] = ps[_D0] & ~_DMASK | (short)lexp << _DOFF;
		return (FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_D0] & _DSIGN;

		ps[_D0] = 1 << _DOFF | ps[_D0] & _DFRAC;
		if (--lexp < -(48+_DOFF))
			{	/* underflow, return +/-0 */
			ps[_D0] = sign, ps[_D1] = 0;
			ps[_D2] = 0, ps[_D3] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = (short)lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_D3] = ps[_D2], ps[_D2] = ps[_D1];
				ps[_D1] = ps[_D0], ps[_D0] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_D3] = ps[_D3] >> xexp
					| ps[_D2] << (16 - xexp);
				ps[_D2] = ps[_D2] >> xexp
					| ps[_D1] << (16 - xexp);
				ps[_D1] = ps[_D1] >> xexp
					| ps[_D0] << (16 - xexp);
				ps[_D0] >>= xexp;
				}
			ps[_D0] |= sign;
			return (FINITE);
			}
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xdnorm.c ===
/* _Dnorm function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short _Dnorm(unsigned short *ps)
	{	/* normalize double fraction */
	short xchar;
	unsigned short sign = ps[_D0] & _DSIGN;

	xchar = 1;
	if ((ps[_D0] &= _DFRAC) != 0 || ps[_D1]
		|| ps[_D2] || ps[_D3])
		{	/* nonzero, scale */
		for (; ps[_D0] == 0; xchar -= 16)
			{	/* shift left by 16 */
			ps[_D0] = ps[_D1], ps[_D1] = ps[_D2];
			ps[_D2] = ps[_D3], ps[_D3] = 0;
			}
		for (; ps[_D0] < 1<<_DOFF; --xchar)
			{	/* shift left by 1 */
			ps[_D0] = ps[_D0] << 1 | ps[_D1] >> 15;
			ps[_D1] = ps[_D1] << 1 | ps[_D2] >> 15;
			ps[_D2] = ps[_D2] << 1 | ps[_D3] >> 15;
			ps[_D3] <<= 1;
			}
		for (; 1<<(_DOFF+1) <= ps[_D0]; ++xchar)
			{	/* shift right by 1 */
			ps[_D3] = ps[_D3] >> 1 | ps[_D2] << 15;
			ps[_D2] = ps[_D2] >> 1 | ps[_D1] << 15;
			ps[_D1] = ps[_D1] >> 1 | ps[_D0] << 15;
			ps[_D0] >>= 1;
			}
		ps[_D0] &= _DFRAC;
		}
	ps[_D0] |= sign;
	return (xchar);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\wiostrea.cpp ===
// wiostream -- initialize standard wide streams
#include <locale>
#include <fstream>
#include <iostream>
#include <new>
_STD_BEGIN

		// OBJECT DECLARATIONS
int _Winit::_Init_cnt = -1;
static wfilebuf wfin(_Noinit);
static wfilebuf wfout(_Noinit);
static wfilebuf wferr(_Noinit);
_CRTIMP2 wistream wcin(_Noinit);
_CRTIMP2 wostream wcout(_Noinit);
_CRTIMP2 wostream wcerr(_Noinit);
_CRTIMP2 wostream wclog(_Noinit);

_CRTIMP2 _Winit::_Winit()
	{	// initialize standard wide streams first time
	bool doinit;
		{_Lockit _Lk;
		if (0 <= _Init_cnt)
			++_Init_cnt, doinit = false;
		else
			_Init_cnt = 1, doinit = true; }
	if (doinit)
		{	// initialize standard wide streams
		new (&wfin) wfilebuf(stdin);
		new (&wfout) wfilebuf(stdout);
		new (&wferr) wfilebuf(stderr);
		new (&wcin) wistream(&wfin, true);
		new (&wcout) wostream(&wfout, true);
		wcin.tie(&wcout);
		new (&wcerr) wostream(&wferr, true);
		wcerr.tie(&wcout);
		wcerr.setf(ios_base::unitbuf);
		new (&wclog) wostream(&wferr, true);
		wclog.tie(&wcout);
		}
	}

_CRTIMP2 _Winit::~_Winit()
	{	// flush standard wide streams last time
	bool doflush;
		{_Lockit _Lk;
		if (--_Init_cnt == 0)
			doflush = true;
		else
			doflush = false; }
	if (doflush)
		{	// flush standard wide streams
		wcout.flush();
		wcerr.flush();
		wclog.flush();
		}
_STD_END
	}

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xdtest.c ===
/* _Dtest function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short _Dtest(double *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;

	if ((ps[_D0] & _DMASK) == _DMAX << _DOFF)
		return ((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? NAN : INF);
	else if ((ps[_D0] & ~_DSIGN) != 0 || ps[_D1] != 0
		|| ps[_D2] != 0 || ps[_D3] != 0)
		return (FINITE);
	else
		return (0);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xcosh.c ===
/* _Cosh function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 double __cdecl _Cosh(double x, double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_Dtest(&x))
		{	/* test for special codes */
	case NAN:
		errno = EDOM;
		return (x);
	case INF:
		if (y == 0)
			return (0);
		errno = ERANGE;
		return (_Inf._D);
	case 0:
		return (y);
	default:	/* finite */
		if (x < 0)
			x = -x;
		if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1, -1);
			return (y * (x + 0.25 / x));
			}
		if (0 <= _Exp(&x, y, -1))
			errno = ERANGE;	/* x large */
		return (x);
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xexp.c ===
/* _Exp function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

/* coefficients */
static const double p[] = {	/* courtesy Dr. Tim Prince */
	1.0,
	420.30235984910635,
	15132.70094680474802};
static const double q[] = {	/* courtesy Dr. Tim Prince */
	30.01511290683317,
	3362.72154416553028,
	30265.40189360949691};
static const double c1 = 22713.0 / 32768.0;
static const double c2 = 1.428606820309417232e-6L;
static const double hugexp = HUGE_EXP;
static const double invln2 = 1.4426950408889634074L;

_CRTIMP2 short __cdecl _Exp(double *px, double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0)
		{	/* certain underflow */
		*px = 0;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _Inf._D;
		return (INF);
		}
	else
		{	/* xexp won't overflow */
		double g = *px * invln2;
		short xexp = g + (g < 0 ? - 0.5 : + 0.5);

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_Eps._D < g && g < _Eps._D)
			*px = y;
		else
			{	/* g*g worth computing */
			const double z = g * g;
			const double w = (q[0] * z + q[1]) * z + q[2];

			g *= (z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2 * y;
			--xexp;
			}
		return (_Dscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfcosh.c ===
/* _FCosh function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 float __cdecl _FCosh(float x, float y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_FDtest(&x))
		{	/* test for special codes */
	case NAN:
		errno = EDOM;
		return (x);
	case INF:
		if (y == 0)
			return (0);
		errno = ERANGE;
		return (_FInf._F);
	case 0:
		return (y);
	default:	/* finite */
		if (x < 0)
			x = -x;
		if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1, -1);
			return (y * (x + 0.25 / x));
			}
		if (0 <= _FExp(&x, y, -1))
			errno = ERANGE;	/* x large */
		return (x);
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfdtest.c ===
/* _FDtest function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short _FDtest(float *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;

	if ((ps[_F0] & _FMASK) == _FMAX << _FOFF)
		return ((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? NAN : INF);
	else if ((ps[_F0] & ~_FSIGN) != 0 || ps[_F1] != 0)
		return (FINITE);
	else
		return (0);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfdnorm.c ===
/* _FDnorm function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short _FDnorm(unsigned short *ps)
	{	/* normalize float fraction */
	short xchar;
	unsigned short sign = ps[_F0] & _FSIGN;

	xchar = 1;
	if ((ps[_F0] &= _FFRAC) != 0 || ps[_F1])
		{	/* nonzero, scale */
		if (ps[_F0] == 0)
			ps[_F0] = ps[_F1], ps[_F1] = 0, xchar -= 16;
		for (; ps[_F0] < 1<<_FOFF; --xchar)
			{	/* shift left by 1 */
			ps[_F0] = ps[_F0] << 1 | ps[_F1] >> 15;
			ps[_F1] <<= 1;
			}
		for (; 1<<(_FOFF+1) <= ps[_F0]; ++xchar)
			{	/* shift right by 1 */
			ps[_F1] = ps[_F1] >> 1 | ps[_F0] << 15;
			ps[_F0] >>= 1;
			}
		ps[_F0] &= _FFRAC;
		}
	ps[_F0] |= sign;
	return (xchar);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfdscale.c ===
/* _FDscale function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short _FDscale(float *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = (ps[_F0] & _FMASK) >> _FOFF;

	if (xchar == _FMAX)
		return ((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? NAN : INF);
	else if (xchar == 0 && 0 < (xchar = _FDnorm(ps)))
		return (0);
	lexp += xchar;
	if (_FMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_F0] & _FSIGN ? -_FInf._F : _FInf._F;
		return (INF);
		}
	else if (0 < lexp)
		{	/* finite result, repack */
		ps[_F0] = ps[_F0] & ~_FMASK | (short)lexp << _FOFF;
		return (FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_F0] & _FSIGN;

		ps[_F0] = 1 << _FOFF | ps[_F0] & _FFRAC;
		if (--lexp < -(16+_FOFF))
			{	/* underflow, return +/-0 */
			ps[_F0] = sign, ps[_F1] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			if (xexp <= -16)
				ps[_F1] = ps[_F0], ps[_F0] = 0, xexp += 16;
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_F1] = ps[_F1] >> xexp
					| ps[_F0] << (16 - xexp);
				ps[_F0] >>= xexp;
				}
			ps[_F0] |= sign;
			return (FINITE);
			}
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfsinh.c ===
/* _FSinh function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const float p[] = {	/* courtesy Dr. Tim Prince */
	0.00020400F,
	0.00832983F,
	0.16666737F,
	0.99999998F};

_CRTIMP2 float __cdecl _FSinh(float x, float y)
	{	/* compute y*sinh(x), |y| <= 1 */
	switch (_FDtest(&x))
		{	/* test for special codes */
	case NAN:
		errno = EDOM;
		return (x);
	case INF:
		if (y == 0)
			return (0);
		errno = ERANGE;
		return (FSIGN(x) ? -_FInf._F : _FInf._F);
	case 0:
		return (0);
	default:	/* finite */
		 {	/* compute sinh(finite) */
		short neg;

		if (x < 0)
			x = -x, neg = 1;
		else
			neg = 0;
		if (x < _FRteps._F)
			x *= y;	/* x tiny */
		else if (x < 1)
			{
			float w = x * x;

			x += ((p[0] * w + p[1]) * w + p[2]) * w * x;
			x *= y;
			}
		else if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1, -1);
			x = y * (x - 0.25 / x);
			}
		else if (0 <= _FExp(&x, y, -1))
			errno = ERANGE;	/* x large */
		return (neg ? -x : x);
		 }
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfexp.c ===
/* _FExp function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

static const float p[] = {	/* courtesy Dr. Tim Prince */
	1.0F,
	60.09114349F};
static const float q[] = {	/* courtesy Dr. Tim Prince */
	12.01517514F,
	120.18228722F};
static const double c1 = 22713.0 / 32768.0;
static const double c2 = 1.428606820309417232e-6L;
static const float hugexp = FHUGE_EXP;
static const float invln2 = 1.4426950408889634074F;

_CRTIMP2 short __cdecl _FExp(float *px, float y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0)
		{	/* certain underflow */
		*px = 0;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _FInf._F;
		return (INF);
		}
	else
		{	/* xexp won't overflow */
		float g = *px * invln2;
		short xexp = g + (g < 0 ? - 0.5 : + 0.5);

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_FEps._F < g && g < _FEps._F)
			*px = y;
		else
			{	/* g*g worth computing */
			const float z = g * g;
			const float w = q[0] * z + q[1];

			g *= z + p[1];
			*px = (w + g) / (w - g) * 2 * y;
			--xexp;
			}
		return (_FDscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xfvalues.c ===
/* values used by math functions -- IEEE 754 float version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

		/* macros */
#define NBITS	(16 + _FOFF)
#if _D0
 #define INIT(w0)		{0, w0}
 #define INIT2(w0, w1)	{w1, w0}
#else
 #define INIT(w0)		{w0, 0}
 #define INIT2(w0, w1)	{w0, w1}
#endif
		/* static data */
_CRTIMP2 const _Dconst _FDenorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _FEps = {INIT((_FBIAS - NBITS - 1) << _FOFF)};
_CRTIMP2 const _Dconst _FInf = {INIT(_FMAX << _FOFF)};
_CRTIMP2 const _Dconst _FNan = {INIT(_FSIGN | (_FMAX << _FOFF)
	| (1 << (_FOFF - 1)))};
_CRTIMP2 const _Dconst _FSnan = {INIT(_FSIGN | (_FMAX << _FOFF))};
_CRTIMP2 const _Dconst _FRteps = {INIT((_FBIAS - NBITS / 2) << _FOFF)};
_CRTIMP2 const float _FXbig = (NBITS + 1) * 347L / 1000;

#if defined(__CENTERLINE__)
 #define _DYNAMIC_INIT_CONST(x) \
	(x._F = *(float *)(void *)(x._W))
_DYNAMIC_INIT_CONST(_FEps);
_DYNAMIC_INIT_CONST(_FInf);
_DYNAMIC_INIT_CONST(_FNan);
_DYNAMIC_INIT_CONST(_FRteps);
#endif
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
950222 pjp: added signaling NaN, denorm minimum for C++
950405 pjp: corrected _FSnan punctuation
950505 pjp: corrected _FDenorm spelling
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xldnorm.c ===
/* _LDnorm function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

#if !_DLONG
	/* not needed */
#elif _LONG_DOUBLE_HAS_HIDDEN_BIT
_CRTIMP2 short _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- SPARC */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 1;
	if (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
		|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
		|| ps[_L7] != 0)
		{	/* nonzero, scale */
		for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
			xchar -= 16)
			{	/* shift left by 16 */
			ps[_L0] = ps[_L1];
			ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
			ps[_L3] = ps[_L4], ps[_L4] = ps[_L5];
			ps[_L5] = ps[_L6], ps[_L6] = ps[_L7];
			ps[_L7] = 0;
			}
		for (; ps[_L0] == 0; --xchar)
			{	/* shift left by 1 */
			ps[_L0] = ps[_L0] << 1 | ps[_L1] >> 15;
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] = ps[_L4] << 1 | ps[_L5] >> 15;
			ps[_L5] = ps[_L5] << 1 | ps[_L6] >> 15;
			ps[_L6] = ps[_L6] << 1 | ps[_L7] >> 15;
			ps[_L7] <<= 1;
			}
		for (; 1 < ps[_L0]; ++xchar)
			{	/* shift right by 1 */
			ps[_L7] = ps[_L7] >> 1 | ps[_L6] << 15;
			ps[_L6] = ps[_L6] >> 1 | ps[_L5] << 15;
			ps[_L5] = ps[_L5] >> 1 | ps[_L4] << 15;
			ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
			ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
			ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
			ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
			ps[_L0] >>= 1;
			}
		}
	ps[_L0] = sign;
	return (xchar);
	}
#else	/* !_LONG_DOUBLE_HAS_HIDDEN_BIT */
_CRTIMP2 short _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 0;
	for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
		xchar -= 16)
		{	/* shift left by 16 */
		ps[_L0] = ps[_L1];
		ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
		ps[_L3] = ps[_L4], ps[_L4] = 0;
		}
	if (ps[_L0] == 0)
		for (; ps[_L1] < (1U << _LOFF); --xchar)
			{	/* shift left by 1 */
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] <<= 1;
			}
	for (; ps[_L0] != 0; ++xchar)
		{	/* shift right by 1 */
		ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
		ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
		ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
		ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
		ps[_L0] >>= 1;
		}
	ps[_L0] = sign;
	return (xchar);
	}
#endif
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xldtest.c ===
/* _LDtest function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

#if !_DLONG
_CRTIMP2 short _LDtest(long double *px)
	{	/* categorize *px */
	return (_Dtest((double *)px));
	}
#elif _LONG_DOUBLE_HAS_HIDDEN_BIT
_CRTIMP2 short _LDtest(long double *px)
	{	/* categorize *px -- SPARC */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? NAN : INF);
	else if (0 < xchar || ps[_L1] || ps[_L2] || ps[_L3]
		|| ps[_L4] || ps[_L5] || ps[_L6] || ps[_L7])
		return (FINITE);
	else
		return (0);
	}
#else	/*	_DLONG && !_LONG_DOUBLE_HAS_HIDDEN_BIT */
_CRTIMP2 short _LDtest(long double *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? NAN : INF);
	else if (0 < xchar || ps[_L1] != 0 || ps[_L2] || ps[_L3]
		|| ps[_L4])
		return (FINITE);
	else
		return (0);
	}
#endif
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xldscale.c ===
/* _LDscale function -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

#if !_DLONG
_CRTIMP2 short _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking */
	return (_Dscale((double *)px, lexp));
	}
#elif _LONG_DOUBLE_HAS_HIDDEN_BIT
_CRTIMP2 short _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- SPARC */
	unsigned short *ps = (unsigned short *)px;
	unsigned short frac;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? NAN : INF);
	else if (xchar == 0 && 0 < (xchar = _LDnorm(ps)))
		return (0);
	lexp += xchar;
	if (_LMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._L : _LInf._L;
		return (INF);
		}
	else if (0 <= lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (short)lexp;
		return (FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_L0] & _LSIGN;

		ps[_L0] = 1;
		if (--lexp <= -112)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0, ps[_L2] = 0, ps[_L3] = 0, ps[_L4] = 0;
			ps[_L5] = 0, ps[_L6] = 0, ps[_L7] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_L7] = ps[_L6], ps[_L6] = ps[_L5];
				ps[_L5] = ps[_L4], ps[_L4] = ps[_L3];
				ps[_L3] = ps[_L2], ps[_L2] = ps[_L1];
				ps[_L1] = ps[_L0], ps[_L0] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_L7] = ps[_L7] >> xexp
					| ps[_L6] << 16 - xexp;
				ps[_L6] = ps[_L6] >> xexp
					| ps[_L5] << 16 - xexp;
				ps[_L5] = ps[_L5] >> xexp
					| ps[_L4] << 16 - xexp;
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] = ps[_L1] >> xexp
					| ps[_L0] << 16 - xexp;
				}
			ps[_L0] = sign;
			return (FINITE);
			}
		}
	}
#else	/*	_DLONG && !_LONG_DOUBLE_HAS_HIDDEN_BIT */
_CRTIMP2 short _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? NAN : INF);
	else if (xchar == 0 && ps[_L1] == 0 && ps[_L2] == 0
		&& ps[_L3] == 0 && ps[_L4] == 0)
		return (0);
	lexp += xchar + _LDnorm(ps);
	if (_LMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._L : _LInf._L;
		return (INF);
		}
	else if (0 <= lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (short)lexp;
		return (FINITE);
		}
	else
		{	/* denormalized, scale */
		ps[_L0] &= _LSIGN;
		if (lexp <= -64)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0, ps[_L2] = 0;
			ps[_L3] = 0, ps[_L4] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_L4] = ps[_L3], ps[_L3] = ps[_L2];
				ps[_L2] = ps[_L1], ps[_L1] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] >>= xexp;
				}
			return (FINITE);
			}
		}
	}
#endif
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlexp.c ===
/* _LExp function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

/* coefficients */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	42.038913947607355L,
	10096.353102778762831L,
	333228.767219512631062L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	1.0L,
	841.167880526530790L,
	75730.834075476293976L,
	666457.534439025262146L};
static const long double c1 = 22713.0 / 32768.0;
static const long double c2 = 1.428606820309417232e-6L;
static const long double hugexp = LHUGE_EXP;
static const long double invln2 = 1.4426950408889634074L;

_CRTIMP2 short __cdecl _LExp(long double *px, long double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0)
		{	/* certain underflow */
		*px = 0;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _LInf._L;
		return (INF);
		}
	else
		{	/* xexp won't overflow */
		long double g = *px * invln2;
		short xexp = g + (g < 0 ? - 0.5 : + 0.5);

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_LEps._L < g && g < _LEps._L)
			*px = y;
		else
			{	/* g*g worth computing */
			const long double z = g * g;
			const long double w = ((z + q[1]) * z + q[2]) * z
				+ q[3];

			g *= (p[0] * z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2 * y;
			--xexp;
			}
		return (_LDscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlcosh.c ===
/* _LCosh function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 long double __cdecl _LCosh(long double x, long double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_LDtest(&x))
		{	/* test for special codes */
	case NAN:
		errno = EDOM;
		return (x);
	case INF:
		if (y == 0)
			return (0);
		errno = ERANGE;
		return (_LInf._L);
	case 0:
		return (y);
	default:	/* finite */
		if (x < 0)
			x = -x;
		if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1, -1);
			return (y * (x + 0.25 / x));
			}
		if (0 <= _LExp(&x, y, -1))
			errno = ERANGE;	/* x large */
		return (x);
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlpoly.c ===
/* _LPoly function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 long double _LPoly(long double x, const long double *tab, int n)
	{	/* compute polynomial */
	long double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlocale.cpp ===
// xlocale -- class locale exotic char member functions
#include <istream>
#include <locale>
_STD_BEGIN

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

        // facets associated with C categories
#define ADDFAC(T, cat, pi, pl) \
        if ((_CATMASK(T::_Getcat()) & cat) == 0) \
                ; \
        else if (pl == 0) \
                pi->_Addfac(new T(_Lobj), T::id); \
        else \
                pi->_Addfac((locale::facet *)&_USE(*pl, T), T::id);

typedef collate<char> _T5;
typedef messages<char> _T6;
typedef money_get<char, _Initer> _T7;
typedef money_put<char, _Outiter> _T9;
typedef moneypunct<char, false> _T11;
typedef moneypunct<char, true> _T12;
typedef time_get<char, _Initer> _T13;
typedef time_put<char, _Outiter> _T14;

template<> locale::id collate<char>::id;
template<> locale::id messages<char>::id;
template<> locale::id money_get<char, _Initer>::id;
template<> locale::id money_put<char, _Outiter>::id;
template<> locale::id moneypunct<char, false>::id;
template<> locale::id moneypunct<char, true>::id;
template<> locale::id time_get<char, _Initer>::id;
template<> locale::id time_put<char, _Outiter>::id;

void __cdecl locale::_Locimp::_Makexloc(const _Locinfo& _Lobj,
        locale::category _C, _Locimp *_Pi, const locale *_Pl)
        {       // setup exotic char part of a new locale
        _Lockit _Lk;
        ADDFAC(_T5, _C, _Pi, _Pl);
        ADDFAC(_T6, _C, _Pi, _Pl);
        ADDFAC(_T7, _C, _Pi, _Pl);
        ADDFAC(_T9, _C, _Pi, _Pl);
        ADDFAC(_T11, _C, _Pi, _Pl);
        ADDFAC(_T12, _C, _Pi, _Pl);
        ADDFAC(_T13, _C, _Pi, _Pl);
        ADDFAC(_T14, _C, _Pi, _Pl);
        }

_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlock.cpp ===
/***
*xlock.cpp - thread lock class
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Define lock class used to make STD C++ Library thread-safe.
*
*Revision History:
*       08-28-96  GJF   Module created, MGHMOM.
*
*******************************************************************************/

#ifdef  _MT

#include <xstddef>
#include <windows.h>
_STD_BEGIN

static CRITICAL_SECTION _CritSec;

static long _InitFlag = 0L;

static void _CleanUp()
{
        long InitFlagValue;

        if ( InitFlagValue = InterlockedExchange( &_InitFlag, 3L ) == 2L )
            // Should be okay to delete critical section
            DeleteCriticalSection( &_CritSec );
}

_Lockit::_Lockit()
{

        // Most common case - just enter the critical section

        if ( _InitFlag == 2L ) {
            EnterCriticalSection( &_CritSec );
            return;
        }

        // Critical section either needs to be initialized.

        if ( _InitFlag == 0L ) {

            long InitFlagVal;

            if ( (InitFlagVal = InterlockedExchange( &_InitFlag, 1L )) == 0L ) {
                InitializeCriticalSection( &_CritSec );
                atexit( _CleanUp );
                _InitFlag = 2L;
            }
            else if ( InitFlagVal == 2L )
                _InitFlag = 2L;
        }

        // If necessary, wait while another thread finishes initializing the
        // critical section

        while ( _InitFlag == 1L )
            Sleep( 1 );

        if ( _InitFlag == 2L )
            EnterCriticalSection( &_CritSec );
}

_Lockit::~_Lockit()
{
        if ( _InitFlag == 2L ) 
            LeaveCriticalSection( &_CritSec );
}

_STD_END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlsinh.c ===
/* _LSinh function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000000000028486835L,
	0.0000000000007646464279L,
	0.0000000001605905091647L,
	0.0000000250521083436962L,
	0.0000027557319224130455L,
	0.0001984126984126956009L,
	0.0083333333333333336073L,
	0.1666666666666666666564L,
	1.0000000000000000000001L};

_CRTIMP2 long double __cdecl _LSinh(long double x, long double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	switch (_LDtest(&x))
		{	/* test for special codes */
	case NAN:
		errno = EDOM;
		return (x);
	case INF:
		if (y == 0)
			return (0);
		errno = ERANGE;
		return (LSIGN(x) ? -_LInf._L : _LInf._L);
	case 0:
		return (0);
	default:	/* finite */
		 {	/* compute sinh(finite) */
		short neg;

		if (x < 0)
			x = -x, neg = 1;
		else
			neg = 0;
		if (x < _LRteps._L)
			x *= y;	/* x tiny */
		else if (x < 1)
			{
			long double w = x * x;

			x += x * w * _LPoly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1, -1);
			x = y * (x - 0.25 / x);
			}
		else if (0 <= _LExp(&x, y, -1))
			errno = ERANGE;	/* x large */
		return (neg ? -x : x);
		 }
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xpoly.c ===
/* _Poly function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 double _Poly(double x, const double *tab, int n)
	{	/* compute polynomial */
	double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xlvalues.c ===
/* values used by math functions -- IEEE 754 long version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

#if _DLONG	/* long double has unique representation */
		/* macros */
#define NBITS	64
 #if _D0
  #define INIT(w0, w1)		{0, 0, 0, w1, w0}
  #define INIT3(w0, w1, wn)	{wn, 0, 0, w1, w0}
 #else
  #define INIT(w0, w1)		{w0, w1, 0, 0, 0}
  #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, wn}
 #endif
		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT3(0, 0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT(_LBIAS - NBITS - 1, 0x8000)};
 #if _LONG_DOUBLE_HAS_HIDDEN_BIT
_CRTIMP2 const _Dconst _LInf = {INIT(_LMAX, 0)};
_CRTIMP2 const _Dconst _LNan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_LSIGN | _LMAX, 0)};
 #else
_CRTIMP2 const _Dconst _LInf = {INIT(_LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LNan = {INIT(_LSIGN | _LMAX, 0xc000)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_LSIGN | _LMAX, 0x8000)};
 #endif
_CRTIMP2 const _Dconst _LRteps = {INIT(_LBIAS - NBITS / 2, 0x8000)};
_CRTIMP2 const long double _LXbig = (NBITS + 1) * 347L / 1000;

 #if defined(__CENTERLINE__)
  #define _DYNAMIC_INIT_CONST(x) \
	(x._L = *(long double *)(void *)(x._W))
long double _centerline_long_double_dynamic_init =
_DYNAMIC_INIT_CONST(_LEps),
_DYNAMIC_INIT_CONST(_LInf),
_DYNAMIC_INIT_CONST(_LNan),
_DYNAMIC_INIT_CONST(_LRteps);
 #endif
#else	/* long double same representation as double */
		/* macros */
 #define NBITS	(48 + _DOFF)
 #if _D0
  #define INIT(w0)		{0, 0, 0, w0}
  #define INIT2(w0, w1)	{w1, 0, 0, w0}
 #else
  #define INIT(w0)		{w0, 0, 0, 0}
  #define INIT2(w0, w1)	{w0, 0, 0, w1}
 #endif
		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT((_DBIAS - NBITS - 1) << _DOFF)};
_CRTIMP2 const _Dconst _LInf = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _LNan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
_CRTIMP2 const _Dconst _LRteps = {INIT((_DBIAS - NBITS / 2) << _DOFF)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_DSIGN | (_DMAX << _DOFF))};
_CRTIMP2 const long double _LXbig = (NBITS + 1) * 347L / 1000;

 #if defined(__CENTERLINE__)
  #define _DYNAMIC_INIT_CONST(x) \
	(x._D = *(long double *)(void *)(x._W))
long double _centerline_long_double_dynamic_inits =
_DYNAMIC_INIT_CONST(_LEps),
_DYNAMIC_INIT_CONST(_LInf),
_DYNAMIC_INIT_CONST(_LNan),
_DYNAMIC_INIT_CONST(_LRteps);
 #endif
#endif
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
950222 pjp: added signaling NaN, denorm minimum for C++
950506 pjp: corrected _LDenorm spelling
951005 pjp: added _DLONG logic
951115 pjp: corrected _LXbig type
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <wctype.h>
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN
		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1
 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4
		/* IEEE 754 double properties */
#define _DFRAC	((1 << _DOFF) - 1)
#define _DMASK	(0x7fff & ~_DFRAC)
#define _DMAX	((1 << (15 - _DOFF)) - 1)
#define _DSIGN	0x8000
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define SAFE_EXP	(_DMAX >> 1)
		/* IEEE 754 float properties */
#define _FFRAC	((1 << _FOFF) - 1)
#define _FMASK	(0x7fff & ~_FFRAC)
#define _FMAX	((1 << (15 - _FOFF)) - 1)
#define _FSIGN	0x8000
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define FSAFE_EXP	(_FMAX >> 1)
 #define _F0	1	/* little-endian order */
 #define _F1	0
		/* IEEE 754 long double properties */
#define _LFRAC	(-1)
#define _LMASK	0x7fff
#define _LMAX	0x7fff
#define _LSIGN	0x8000
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define LSAFE_EXP	(_LMAX >> 1)
 #define _L0	4	/* little-endian order */
 #define _L1	3
 #define _L2	2
 #define _L3	1
 #define _L4	0
		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE
_C_LIB_DECL
		/* double declarations */
_CRTIMP2 double _Atan(double, unsigned short);
_CRTIMP2 short _Dint(double *, short);
_CRTIMP2 short _Dnorm(unsigned short *);
_CRTIMP2 short _Dscale(double *, long);
_CRTIMP2 double _Dtento(double, long);
_CRTIMP2 short _Dunscale(short *, double *);
_CRTIMP2 double _Poly(double, const double *, int);
extern _CRTIMP2 const _Dconst _Eps, _Rteps;
extern _CRTIMP2 const double _Xbig;
		/* float declarations */
_CRTIMP2 float _FAtan(float, unsigned short);
_CRTIMP2 short _FDint(float *, short);
_CRTIMP2 short _FDnorm(unsigned short *);
_CRTIMP2 short _FDscale(float *, long);
_CRTIMP2 float _FDtento(float, long);
_CRTIMP2 short _FDunscale(short *, float *);
_CRTIMP2 float _FPoly(float, const float *, int);
extern _CRTIMP2 const _Dconst _FEps, _FRteps;
extern _CRTIMP2 const float _FXbig;
		/* long double functions */
_CRTIMP2 long double _LAtan(long double, unsigned short);
_CRTIMP2 short _LDint(long double *, short);
_CRTIMP2 short _LDnorm(unsigned short *);
_CRTIMP2 short _LDscale(long double *, long);
_CRTIMP2 long double _LDtento(long double, long);
_CRTIMP2 short _LDunscale(short *, long double *);
_CRTIMP2 long double _LPoly(long double, const long double *, int);
extern _CRTIMP2 const _Dconst _LEps, _LRteps;
extern _CRTIMP2 const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xsinh.c ===
/* _Sinh function */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000001632881,
	0.0000000250483893,
	0.0000027557344615,
	0.0001984126975233,
	0.0083333333334816,
	0.1666666666666574,
	1.0000000000000001};

_CRTIMP2 double __cdecl _Sinh(double x, double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	switch (_Dtest(&x))
		{	/* test for special codes */
	case NAN:
		errno = EDOM;
		return (x);
	case INF:
		if (y == 0)
			return (0);
		errno = ERANGE;
		return (DSIGN(x) ? -_Inf._D : _Inf._D);
	case 0:
		return (0);
	default:	/* finite */
		 {	/* compute sinh(finite) */
		short neg;

		if (x < 0)
			x = -x, neg = 1;
		else
			neg = 0;
		if (x < _Rteps._D)
			x *= y;	/* x tiny */
		else if (x < 1)
			{
			double w = x * x;

			x += x * w * _Poly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1, -1);
			x = y * (x - 0.25 / x);
			}
		else if (0 <= _Exp(&x, y, -1))
			errno = ERANGE;	/* x large */
		return (neg ? -x : x);
		 }
		}
	}
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xstod.c ===
/* _Stod/_Stof/_Stold functions for Microsoft */
#include <stdlib.h>
#include "wctype.h"
#ifndef _LIMITS
#include <yvals.h>
#endif
_STD_BEGIN

_CRTIMP2 double _Stod(const char *s, char **endptr, long pten)
	{	/* convert string to double */
	double x = strtod(s, endptr);
	for (; 0 < pten; --pten)
		x *= 10.0;
	for (; pten < 0; ++pten)
		x /= 10.0;
	return (x);
	}

_CRTIMP2 float _Stof(const char *s, char **endptr, long pten)
	{	/* convert string to float */
	return ((float)_Stod(s, endptr, pten));
	}

_CRTIMP2 long double _Stold(const char *s, char **endptr, long pten)
	{	/* convert string to long double */
	return ((long double)_Stod(s, endptr, pten));
	}
_STD_END

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
951207 pjp: added new file
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xmbtowc.c ===
/***
*xmbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*Revision History:
*       12-XX-95  PJP   Created from mbtowc.c December 1995 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-25-96  GJF   Made mbrlen, mbrtowc and mbsrtowcs multithread safe.
*       09-17-97  JWM   Added "return MB_CUR_MAX" to "if (*pst != 0)" branch.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <limits.h>              /* for INT_MAX */
#include <stdio.h>               /* for EOF */
#include <xlocinfo.h>            /* for _Cvtvec, _Mbrtowc */
#ifdef _WIN32
#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#endif  /* _WIN32 */

#ifndef _MT
#define _Mbrtowc_lk _Mbrtowc
#endif

/***
*int _Mbrtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*               mbstate_t *pst          = pointer to state
*       const _Cvtvec *     = pointer to locale info
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
static int __cdecl _Mbrtowc_lk
        (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        );

int _CRTIMP2 __cdecl _Mbrtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        int retval;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )
        retval = _Mbrtowc_lk(pwc, s, n, pst, ploc);
        _unlock_locale( local_lock_flag )
        return retval;
}
#endif  /* _MT */
#ifdef _MT
static int __cdecl _Mbrtowc_lk
#else  /* _MT */
int _CRTIMP2 __cdecl _Mbrtowc
#endif  /* _MT */
        (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);

        if ( !s || n == 0 )
            /* indicate do not have state-dependent encodings,
               handle zero length string */
            return 0;

        if ( !*s )
        {
            /* handle NULL char */
            if (pwc)
                *pwc = 0;
            return 0;
        }

#ifdef _WIN32

        {   /* perform locale-dependent parse */
            LCID handle;
            UINT codepage;

            if (ploc == 0)
            {
                handle = __lc_handle[LC_CTYPE];
                codepage = __lc_codepage; 
            }
            else
            {
                handle = ploc->_Hand;
                codepage = ploc->_Page; 
            }

            if ( handle == _CLOCALEHANDLE )
            {
                if (pwc)
                    *pwc = (wchar_t)(unsigned char)*s;
                return sizeof(char);
            }

            if (*pst != 0)
            {   /* complete two-byte multibyte character */
                ((char *)pst)[1] = *s;
                if (MB_CUR_MAX <= 1 || (MultiByteToWideChar(codepage,
                    MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                    (char *)pst, 2, pwc, (pwc) ? 1 : 0) == 0))
                {   /* translation failed */
                    *pst = 0;
                    errno = EILSEQ;
                    return -1;
                }
                *pst = 0;
                return MB_CUR_MAX;
            }
            else if ( isleadbyte((unsigned char)*s) )
            {
                /* multi-byte char */
                if (n < MB_CUR_MAX)
                {   /* save partial multibyte character */
                    ((char *)pst)[0] = *s;
                    return (-2);
                }
                else if ( MB_CUR_MAX <= 1 ||
                          (MultiByteToWideChar( codepage, 
                                                MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS,
                                                s, 
                                                MB_CUR_MAX, 
                                                pwc, 
                                                (pwc) ? 1 : 0) == 0) )
                {
                    /* validate high byte of mbcs char */
                    if (!*(s+1))
                    {
                        *pst = 0;
                        errno = EILSEQ;
                        return -1;
                    }
/*                  else translation failed with no complaint? [pjp] */
                }
                return MB_CUR_MAX;
            }
            else {
                /* single byte char */

                if ( MultiByteToWideChar( codepage, 
                                          MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                                          s, 
                                          1, 
                                          pwc, 
                                          (pwc) ? 1 : 0) == 0 )
                {
                    errno = EILSEQ;
                    return -1;
                }

                return sizeof(char);
            }
        }

#else  /* _WIN32 */

        /* stuck the "C" locale again */
        if (pwc)
            *pwc = (wchar_t)(unsigned char)*s;
        return sizeof(char);

#endif  /* _WIN32 */
}


/***
*wint_t btowc(c) - translate single byte to wide char 
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wint_t _CRTIMP2 __cdecl btowc (
        int c
        )
{
        if (c == EOF)
            return (WEOF);
        else
        {   /* convert as one-byte string */
            char ch = (char)c;
            mbstate_t mbst = 0;
            wchar_t wc;
            return (_Mbrtowc(&wc, &ch, 1, &mbst, 0) < 0 ? WEOF : wc);
        }
}


/***
*size_t mbrlen(s, n, pst) - determine next multibyte code, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbrlen (
        const char *s, 
        size_t n, 
        mbstate_t *pst
        )
{
#ifdef  _MT
        int local_lock_flag;
#endif
        size_t retval;

        static mbstate_t mbst = {0};

        _lock_locale( local_lock_flag )
        retval = _Mbrtowc_lk(0, s != 0 ? s : 0, n, pst ? pst : &mbst, 0);
        _unlock_locale( local_lock_flag )

        return retval;
}


/***
*size_t mbrtowc(pwc, s, n, pst) - translate multibyte to wchar_t, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbrtowc (
        wchar_t *pwc, 
        const char *s, 
        size_t n, 
        mbstate_t *pst
        )
{
#ifdef  _MT
        int local_lock_flag;
#endif
        size_t retval;

        static mbstate_t mbst = {0};

        _lock_locale( local_lock_flag )
        retval = (s != 0) ? _Mbrtowc_lk(pwc, s, n, pst ? pst : &mbst, 0)
                 : _Mbrtowc_lk(0, "", n, pst ? pst : &mbst, 0);
        _unlock_locale( local_lock_flag )

        return retval;    
}


/***
*size_t mbsrtowcs(wcs, ps, n, pst) - translate multibyte string to wide, 
*       restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbsrtowcs (
        wchar_t *wcs, 
        const char **ps, 
        size_t n, 
        mbstate_t *pst
        )
{
        const char *s = *ps;
        int i;
        size_t nwc = 0;
#ifdef  _MT
        int local_lock_flag;
#endif
        static mbstate_t mbst = {0};

        if (pst == 0)
            pst = &mbst;

        _lock_locale( local_lock_flag )

        if (wcs == 0)
            for (; ; ++nwc, s += i)
            {   /* translate but don't store */
                wchar_t wc;
                if ((i = _Mbrtowc_lk(&wc, s, INT_MAX, pst, 0)) < 0) {
                    _unlock_locale( local_lock_flag )
                    return ((size_t)-1);
                }
                else if (i == 0) {
                    _unlock_locale( local_lock_flag )
                    return (nwc);
                }
            }

        for (; 0 < n; ++nwc, s += i, ++wcs, --n)
        {   /* translate and store */
            if ((i = _Mbrtowc_lk(wcs, s, INT_MAX, pst, 0)) < 0)
            {   /* encountered invalid sequence */
                nwc = (size_t)-1;
                break;
            }
            else if (i == 0)
            {   /* encountered terminating null */
                s = 0;
                break;
            }
        }

        *ps = s;

        _unlock_locale( local_lock_flag )

        return (nwc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xstrcoll.c ===
/***
*xstrcoll.c - Collate locale strings
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       01-XX-96  PJP   Created from strcoll.c January 1996 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       05-14-96  JWM   Bug fix to _Strcoll(): error path failed to unlock.
*       09-26-96  GJF   Made _GetColl() multithread safe.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strcoll */

#ifdef  _WIN32
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>
#endif  /* _WIN32 */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/***
*int _Strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1b = pointer to beginning of the first string
*       const char *s1e = pointer past end of the first string
*       const char *s2b = pointer to beginning of the second string
*       const char *s1e = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

_CRTIMP2 int __cdecl _Strcoll (
        const char *_string1,
        const char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
#ifdef  _WIN32
        int ret;
        LCID handle;
#ifdef  _MT
        int local_lock_flag;
#endif
#endif

        int n1 = _end1 - _string1;
        int n2 = _end2 - _string2;

        _lock_locale( local_lock_flag )

#ifdef  _WIN32
        if (ploc == 0)
            handle = __lc_handle[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            _unlock_locale( local_lock_flag )
            ans = memcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;
        }

        if ( 0 == (ret = __crtCompareStringA( handle,
                                              0,
                                              _string1,
                                              n1,
                                              _string2,
                                              n2,
                                              __lc_collate_cp )) )
            goto error_cleanup;

        _unlock_locale( local_lock_flag )
        return (ret - 2);

error_cleanup:

        _unlock_locale( local_lock_flag )
        errno = EINVAL;
        return _NLSCMPERROR;

#else   /* defined (_WIN32) */

        int ans = memcmp(_string1, _string2, n1 < n2 ? n1 : n2);
        return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;

#endif  /* defined (_WIN32) */
}


/***
*_Collvec _Getcoll() - get collation info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Collvec _Getcoll()
{
        _Collvec coll;
#ifdef  _MT
        int local_lock_flag;
#endif
        _lock_locale( local_lock_flag )
        coll._Hand = __lc_handle[LC_COLLATE];
        coll._Page = __lc_collate_cp;
        _unlock_locale( local_lock_flag )

        return (coll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xvalues.c ===
/* values used by math functions -- IEEE 754 version */
#include "wctype.h"
#include "xmath.h"
_STD_BEGIN

		/* macros */
#define NBITS	(48 + _DOFF)
#if _D0
 #define INIT(w0)		{0, 0, 0, w0}
 #define INIT2(w0, w1)	{w1, 0, 0, w0}
#else
 #define INIT(w0)		{w0, 0, 0, 0}
 #define INIT2(w0, w1)	{w0, 0, 0, w1}
#endif
		/* static data */
_CRTIMP2 const _Dconst _Denorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _Eps = {INIT((_DBIAS - NBITS - 1) << _DOFF)};
_CRTIMP2 const _Dconst _Hugeval = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _Inf = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _Nan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
_CRTIMP2 const _Dconst _Rteps = {INIT((_DBIAS - NBITS / 2) << _DOFF)};
_CRTIMP2 const _Dconst _Snan = {INIT(_DSIGN | (_DMAX << _DOFF))};
_CRTIMP2 const double _Xbig = (NBITS + 1) * 347L / 1000;

#if defined(__CENTERLINE__)
 #define _DYNAMIC_INIT_CONST(x) \
	(x._D = *(double *)(void *)(x._W))
double _centerline_double_dynamic_inits =
_DYNAMIC_INIT_CONST(_Hugeval),
_DYNAMIC_INIT_CONST(_Eps),
_DYNAMIC_INIT_CONST(_Inf),
_DYNAMIC_INIT_CONST(_Nan),
_DYNAMIC_INIT_CONST(_Rteps);
#endif
_STD_END

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
941029 pjp: added _STD machinery
950222 pjp: added signaling NaN, denorm minimum for C++
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xstrxfrm.c ===
/***
*xstrxfrm.c - Transform a string using locale information
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       01-XX-96  PJP   Created from strxfrm.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strxfrm */

#ifdef  _WIN32
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>
#endif  /* _WIN32 */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/***
*size_t _Strxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the string pointer to by _string2 and place the
*       resulting string into the array pointer to by _string1.
*       No more than _end1 - _string1 characters are place into the
*       resulting string (including the null).
*
*       The transformation is such that if strcmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of strcoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*       [ANSI]
*
*       The value of the following expression is the size of the array
*       needed to hold the transformation of the source string:
*
*               1 + strxfrm(NULL,string,0)
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*       Thus, _Strxfrm() simply resolves to strncpy()/strlen().
*
*Entry:
*       char *_string1       = pointer to beginning of result string
*       char *_end1          = pointer past end of result string
*       const char *_string2 = pointer to beginning of source string
*       const char *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl _Strxfrm (
        char *_string1,
        char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
#ifdef  _WIN32
        int dstlen;
        int retval = INT_MAX;   /* NON-ANSI: default if OM or API error */
        LCID handle;
        UINT codepage;
#ifdef  _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif

        if (ploc == 0)
        {
            handle = __lc_handle[LC_COLLATE];
            codepage = __lc_collate_cp;
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ((handle == _CLOCALEHANDLE) &&
            (codepage == _CLOCALECP)) 
        {
            _unlock_locale( local_lock_flag )
#endif  /* _WIN32 */
            if (_n2 <= _n1)
                memcpy(_string1, _string2, _n2);
            return _n2;
#ifdef  _WIN32
        }

        /* Inquire size of dst string in BYTES */
        if (0 == (dstlen = __crtLCMapStringA(handle,
                                             LCMAP_SORTKEY, 
                                             _string2, 
                                             (int)_n2, 
                                             NULL, 
                                             0, 
                                             codepage,
                                             TRUE)))
                goto error_cleanup;

        retval = dstlen;

        /* if not enough room, return amount needed */
        if (dstlen > (int)(_n1))
            goto error_cleanup;

        /* Map src string to dst string */
        if (0 == __crtLCMapStringA(handle,
                                   LCMAP_SORTKEY, 
                                   _string2, 
                                   (int)_n2, 
                                   _string1, 
                                   (int)_n1, 
                                   codepage,
                                   TRUE))
            goto error_cleanup;

error_cleanup:
        _unlock_locale( local_lock_flag )
        return (size_t)retval;
#endif  /* _WIN32 */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xwctomb.c ===
/***
*xwctomb.c - Convert wide character to multibyte character, with locale.
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*Revision History:
*       12-XX-95  PJP   Created from wctomb.c December 1995 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-26-96  GJF   Made _Getcvt() and wcsrtombs() multithread safe.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <limits.h>             /* for MB_LEN_MAX */
#include <string.h>             /* for memcpy */
#include <stdio.h>              /* for EOF */
#include <xlocinfo.h>           /* for _Cvtvec, _Wcrtomb */
#ifdef _WIN32
#include <locale.h>
#include <setlocal.h>
#endif  /* _WIN32 */

#ifndef _MT
#define __Wcrtomb_lk    _Wcrtomb
#endif

/***
*int _Wcrtomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s             = pointer to multibyte character
*       wchar_t wchar       = source wide character
*       mbstate_t *pst      = pointer to state (not used)
*       const _Cvtvec *ploc = pointer to locale info
*
*Exit:
*       Returns:
*      -1 (if error) or number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
_CRTIMP2 int __cdecl __Wcrtomb_lk
        (
        char *s,
        wchar_t wchar,
        mbstate_t *,
        const _Cvtvec *ploc
        );

_CRTIMP2 int __cdecl _Wcrtomb
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        int retval;
        int local_lock_flag;

        _lock_locale( local_lock_flag )
        retval = __Wcrtomb_lk(s, wchar, 0, ploc);
        _unlock_locale( local_lock_flag )
        return retval;
}
#endif  /* _MT */

#ifdef _MT
_CRTIMP2 int __cdecl __Wcrtomb_lk
#else  /* _MT */
_CRTIMP2 int __cdecl _Wcrtomb
#endif  /* _MT */
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
#ifdef _WIN32
        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = __lc_handle[LC_CTYPE];
            codepage = __lc_codepage;
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ( handle == _CLOCALEHANDLE )
        {
            if ( wchar > 255 )  /* validate high byte */
            {
                errno = EILSEQ;
                return -1;
            }

            *s = (char) wchar;
            return sizeof(char);
        } else {
            int size;
            BOOL defused = 0;

            if ( ((size = WideCharToMultiByte(codepage,
                                              WC_COMPOSITECHECK | WC_SEPCHARS,
                                              &wchar, 
                                              1,
                                              s, 
                                              MB_CUR_MAX, 
                                              NULL, 
                                              &defused)) == 0) || 
                 (defused) )
            {
                errno = EILSEQ;
                return -1;
            }

            return size;
        }

#else  /* _WIN32 */

        if ( wchar > 255 )  /* validate high byte */
        {
            errno = EILSEQ;
            return -1;
        }

        *s = (char) wchar;
        return sizeof(char);

#endif  /* _WIN32 */
}


/***
*_Cvtvec _Getcvt() - get conversion info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Cvtvec __cdecl _Getcvt()
{
        _Cvtvec cvt;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )
        cvt._Hand = __lc_handle[LC_CTYPE];
        cvt._Page = __lc_codepage;
        _unlock_locale( local_lock_flag )

        return (cvt);
}


/***
*size_t wcrtomb(s, wchar, pst) - translate wchar_t to multibyte, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl wcrtomb(
        char *s, 
        wchar_t wchar, 
        mbstate_t *pst
        )
{
        return (s == 0 ? 1 : _Wcrtomb(s, wchar, 0, 0));
}


/***
*size_t wcsrtombs(s, pwcs, n, pst) - translate wide char string to multibyte 
*       string
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl wcsrtombs(
        char *s, 
        const wchar_t **pwcs, 
        size_t n, 
        mbstate_t *pst
        )
{
        char buf[MB_LEN_MAX];
        int i;
        size_t nc = 0;
        const wchar_t *wcs = *pwcs;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )

        if (s == 0)
            for (; ; nc += i, ++wcs)
            {   /* translate but don't store */
                if ((i = __Wcrtomb_lk(buf, *wcs, 0, 0)) <= 0) {
                    _unlock_locale( local_lock_flag )
                    return ((size_t)-1);
                }
                else if (buf[i - 1] == '\0') {
                    _unlock_locale( local_lock_flag )
                    return (nc + i - 1);
                }
            }

        for (; 0 < n; nc += i, ++wcs, s += i, n -= i)
        {   /* translate and store */
            char *t;

            if (n < MB_CUR_MAX)
                t = buf;
            else
                t = s;

            if ((i = __Wcrtomb_lk(t, *wcs, 0, 0)) <= 0)
            {   /* encountered invalid sequence */
                nc = (size_t)-1;
                break;
            }

            if (s == t)
                ;
            else if (n < i)
                break;  /* won't all fit */
            else
                memcpy(s, buf, i);

            if (s[i - 1] == '\0')
            {   /* encountered terminating null */
                *pwcs = 0;
                _unlock_locale( local_lock_flag )
                return (nc + i - 1);
            }
        }

        _unlock_locale( local_lock_flag )

        *pwcs = wcs;
        return (nc);
}


/***
*int wctob(wchar) - translate wint_t to one-byte multibyte
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 int __cdecl wctob(
        wint_t wchar
        )
{  
        if (wchar == WEOF)
            return (EOF);
        else
        {   /* check for one-byte translation */
            char buf[MB_LEN_MAX];
            return (_Wcrtomb(buf, wchar, 0, 0) == 1 ? buf[0] : EOF);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xwcscoll.c ===
/***
*xwcscoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*
*Revision History:
*       01-XX-96  GJF   Created from wcscoll.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcscoll */

/***
*static int _Wmemcmp(s1, s2, n) - compare wchar_t s1[n], s2[n]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static int _Wmemcmp(
        const wchar_t *s1, 
        const wchar_t *s2, 
        int n
        )
{
        for (; 0 < n; ++s1, ++s2, --n)
             if (*s1 != *s2)
               return (*s1 < *s2 ? -1 : +1);
        return (0);
}

/***
*int _Wcscoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       In the C locale, wcscmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *_string1 = pointer to beginning of the first string
*       const wchar_t *_end1    = pointer past end of the first string
*       const wchar_t *_string2 = pointer to beginning of the second string
*       const wchar_t *_end2    = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _Wcscoll (
        const wchar_t *_string1,
        const wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{

        int n1 = _end1 - _string1;
        int n2 = _end2 - _string2;
        int ret;
        LCID handle;
#ifdef  _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif
        if (ploc == 0)
            handle = __lc_handle[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            _unlock_locale( local_lock_flag )
            ans = _Wmemcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;
        }

        if (0 == (ret = __crtCompareStringW(handle, 
                                            0, 
                                            _string1, 
                                            n1,
                                            _string2, 
                                            n2, 
                                            __lc_collate_cp)))
        {
            _unlock_locale( local_lock_flag )
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        _unlock_locale( local_lock_flag )
        return (ret - 2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\_tolower.c ===
/***
*_tolower.c - convert character to lower case
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Tolower().
*
*Revision History:
*       01-xx-96  PJP   Created from tolower.c, January 1996 by P.J. Plauger
*       04-16-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-25-96  GJF   Added locale locking to _Getctype.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <xlocinfo.h>
#ifdef _WIN32
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#endif  /* _WIN32 */

/* remove macro defintions of _tolower() and tolower()
 */
#undef  _tolower
#undef  tolower

/* define function-like macro equivalent to _tolower()
 */
#define mklower(c)      ( (c)-'A'+'a' )

/***
*int _tolower(c) - convert character to lower case
*
*Purpose:
*       _tolower() is a version of tolower with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of lower case representation of c
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
int __cdecl _Tolower_lk (
        int c,
        const _Ctypevec *ploc
        );
#endif

_CRTIMP2 int __cdecl _Tolower (
        int c,
        const _Ctypevec *ploc
        )
{

#if defined (_WIN32)

#ifdef _MT

        LCID handle;
        int local_lock_flag;

        if (ploc == 0)
                handle = __lc_handle[LC_CTYPE];
        else
                handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE)
        {
                if ( (c >= 'A') && (c <= 'Z') )
                        c = c + ('a' - 'A');
                return c;
        }

        _lock_locale( local_lock_flag )

        c = _Tolower_lk(c, ploc);

        _unlock_locale( local_lock_flag )

        return c;

}

/***
*int _tolower_lk(c) - convert character to lower case
*
*Purpose:
*       Multi-thread function only! Non-locking version of tolower.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _Tolower_lk (
        int c,
        const _Ctypevec *ploc
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
                handle = __lc_handle[LC_CTYPE];
                codepage = __lc_codepage; 
        }
        else
        {
                handle = ploc->_Hand;
                codepage = ploc->_Page; 
        }

        if (handle == _CLOCALEHANDLE)
        {
                if ( (c >= 'A') && (c <= 'Z') )
                        c = c + ('a' - 'A');
                return c;
        }

        /* if checking case of c does not require API call, do it */
        if (c < 256)
        {
                if (!isupper(c))
                {
                        return c;
                }
        }

        /* convert int c to multibyte string */
        if (isleadbyte(c >> 8 & 0xff))
        {
                inbuffer[0] = (c >> 8 & 0xff); 
                inbuffer[1] = (unsigned char)c;
                inbuffer[2] = 0;
                size = 2;
        } else {
                inbuffer[0] = (unsigned char)c;
                inbuffer[1] = 0;
                size = 1;
        }

        /* convert to lowercase */
        if (0 == (size = __crtLCMapStringA(handle, LCMAP_LOWERCASE,
                inbuffer, size, outbuffer, 3, codepage, TRUE)))
        {
                return c;
        }

        /* construct integer return value */
        if (size == 1)
                return ((int)outbuffer[0]);
        else
                return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else  /* defined (_WIN32) */

        return(isupper(c) ? mklower(c) : c);

#endif  /* defined (_WIN32) */
}


/***
*_Ctypevec _Getctype() - get ctype info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Ctypevec __cdecl _Getctype()
{       
        /* get ctype info for current locale */
        _Ctypevec ctype;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )

        ctype._Hand = __lc_handle[LC_COLLATE];
        ctype._Page = __lc_codepage;
        ctype._Table = malloc(256 * sizeof (*_pctype));
        if (ctype._Table != 0)
        {
                memcpy((void *)ctype._Table, _pctype, 256 * sizeof (*_pctype));
                ctype._Delfl = 1; 
        }
        else
        {
                ctype._Table = (const short *)_pctype;
                ctype._Delfl = 0; 
        }

        _unlock_locale( local_lock_flag )

        return (ctype);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\_toupper.c ===
/***
*_toupper.c - convert character to uppercase
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Toupper()
*
*Revision History:.
*       01-XX-96  PJP   Created from toupper.c January 1996 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#ifdef _WIN32
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#endif  /* _WIN32 */

/* remove macro definitions of _toupper() and toupper()
 */
#undef  _toupper
#undef  toupper

/* define function-like macro equivalent to _toupper()
 */
#define mkupper(c)  ( (c)-'a'+'A' )

/***
*int _toupper(c) - convert character to uppercase
*
*Purpose:
*       _toupper() is a version of toupper with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of uppercase representation of c
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
int __cdecl _Toupper_lk (
        int c,
        const _Ctypevec *ploc
        );
#endif

_CRTIMP2 int __cdecl _Toupper (
        int c,
        const _Ctypevec *ploc
        )
{
#if defined (_WIN32)

#ifdef _MT

        LCID handle;
        int local_lock_flag;


        if (ploc == 0)
                handle = __lc_handle[LC_CTYPE];
        else
                handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE)
        {
                if ( (c >= 'a') && (c <= 'z') )
                        c = c - ('a' - 'A');
                return c;
        }

        _lock_locale( local_lock_flag )

        c = _Toupper_lk(c, ploc);

        _unlock_locale( local_lock_flag )

        return c;
}


/***
*int _toupper_lk(c) - convert character to uppercase
*
*Purpose:
*       Multi-thread function! Non-locking version of toupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


int __cdecl _Toupper_lk (
        int c,
        const _Ctypevec *ploc
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
                handle = __lc_handle[LC_CTYPE];
                codepage = __lc_codepage;
        }
        else
        {
                handle = ploc->_Hand;
                codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
                if ( (c >= 'a') && (c <= 'z') )
                        c = c - ('a' - 'A');
                return c;
        }

        /* if checking case of c does not require API call, do it */
        if (c < 256) {
                if (!islower(c))
                {
                        return c;
                }
        }

        /* convert int c to multibyte string */
        if (isleadbyte(c >> 8 & 0xff)) {
                inbuffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
                inbuffer[1] = (unsigned char)c;
                inbuffer[2] = 0;
                size = 2;
        } else {
                inbuffer[0] = (unsigned char)c;
                inbuffer[1] = 0;
                size = 1;
        }

        /* convert wide char to lowercase */
        if (0 == (size = __crtLCMapStringA(handle, LCMAP_UPPERCASE,
                inbuffer, size, outbuffer, 3, codepage, TRUE))) {
                return c;
        }

        /* construct integer return value */
        if (size == 1)
                return ((int)outbuffer[0]);
        else
                return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else  /* defined (_WIN32) */

        return(islower(c) ? mkupper(c) : c);

#endif  /* defined (_WIN32) */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdcpp64\xwcsxfrm.c ===
/***
*xwcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*               
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       01-XX-96  PJP   Created from wcsxfrm.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <stdlib.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcsxfrm */

/***
*size_t _Wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _end1 - _string1 wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = pointer to beginning of result string
*       wchar_t *_end1          = pointer past end of result string
*       const wchar_t *_string2 = pointer to beginning of source string
*       const wchar_t *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl _Wcsxfrm (
        wchar_t *_string1,
        wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        int size = INT_MAX;
        unsigned char *bbuffer;
        LCID handle;
#ifdef _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif

        if (ploc == 0)
            handle = __lc_handle[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            _unlock_locale( local_lock_flag )
            if (_n2 <= _n1)
                memcpy(_string1, _string2, _n2 * sizeof (wchar_t));
                return _n2;
        }

        /*
         * When using LCMAP_SORTKEY, LCMapStringW handles BYTES not wide
         * chars. We use a byte buffer to hold bytes and then convert the
         * byte string to a wide char string and return this so it can be
         * compared using wcscmp(). User's buffer is _n1 wide chars, so
         * use an internal buffer of _n1 bytes.
         */

        if (NULL == (bbuffer = (unsigned char *)_malloc_crt(_n1)))
            goto error_cleanup;

        if (0 == (size = __crtLCMapStringW(handle, 
                                           LCMAP_SORTKEY,
                                           _string2,
                                           (int)_n2,
                                           (wchar_t *)bbuffer,
                                           (int)_n1,
                                           __lc_collate_cp)))
        {
            /* buffer not big enough, get size required. */

            if (0 == (size = __crtLCMapStringW(handle,
                                               LCMAP_SORTKEY,
                                               _string2,
                                               (int)_n2,
                                               NULL,
                                               0,
                                               __lc_collate_cp)))
                size = INT_MAX; /* default error */

        } else {
            int i;
            /* string successfully mapped, convert to wide char */

            for (i = 0; i < size; i++)
                _string1[i] = (wchar_t)bbuffer[i];
        }

error_cleanup:
        _unlock_locale( local_lock_flag )
        _free_crt(bbuffer);

        return (size_t)size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL && !STATIC_CPPLIB
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL && !STATIC_CPPLIB

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\stl.h ===
// stl.h supplemental header
#pragma once
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque
		: public deque<_Ty, allocator<_Ty> >
	{	// wrap new deque as old
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Deque()
		: deque<_Ty, _Alloc>()
		{	// construct empty deque
		}

	explicit Deque(size_type _Count)
		: deque<_Ty, _Alloc>(_Count, _Ty())
		{	// construct deque from _Count * _Ty()
		}

	Deque(size_type _Count, const _Ty& _Val)
		: deque<_Ty, _Alloc>(_Count, _Val)
		{	// construct deque from _Count * _Val
		}

	typedef const_iterator _Iter;

	Deque(_Iter _First, _Iter _Last)
		: deque<_Ty, _Alloc>(_First, _Last)
		{	// construct deque from [_First, _Last)
		}
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List
		: public list<_Ty, allocator<_Ty> >
	{	// wrap new list as old
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	List()
		: list<_Ty, _Alloc>()
		{	// construct empty list
		}

	explicit List(size_type _Count)
		: list<_Ty, _Alloc>(_Count, _Ty())
		{	// construct list from _Count * _Ty()
		}

	List(size_type _Count, const _Ty& _Val)
		: list<_Ty, _Alloc>(_Count, _Val)
		{	// construct list from _Count * _Val
		}

	typedef const_iterator _Iter;

	List(_Iter _First, _Iter _Last)
		: list<_Ty, _Alloc>(_First, _Last)
		{	// construct list from [_First, _Last)
		}
	};

		// TEMPLATE CLASS Map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Map
		: public map<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new map as old
public:
	typedef Map<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Map()
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Map(const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Map(_Iter _First, _Iter _Last)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Map(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Multimap
		: public multimap<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new multimap as old
public:
	typedef Multimap<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Multimap()
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Multimap(const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Multimap(_Iter _First, _Iter _Last)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Multimap(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Set
template<class _Kty,
	class _Pr = less<_Kty> >
	class Set
		: public set<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new set as old
public:
	typedef Set<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Set()
		: set<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Set(const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Set(_Iter _First, _Iter _Last)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Set(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multiset
template<class _Kty,
	class _Pr = less<_Kty> >
	class Multiset
		: public multiset<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new multiset as old
public:
	typedef Multiset<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Multiset()
		: multiset<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Multiset(const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Multiset(_Iter _First, _Iter _Last)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Multiset(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector
		: public vector<_Ty, allocator<_Ty> >
	{	// wrap new vector as old
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Vector()
		: vector<_Ty, _Alloc>()
		{	// construct empty vector
		}

	explicit Vector(size_type _Count)
		: vector<_Ty, _Alloc>(_Count, _Ty())
		{	// construct vector from _Count * _Ty()
		}

	Vector(size_type _Count, const _Ty& _Val)
		: vector<_Ty, _Alloc>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	Vector(_Iter _First, _Iter _Last)
		: vector<_Ty, _Alloc>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// CLASS bit_vector
class bit_vector
	: public vector<_Bool, _Bool_allocator>
	{	// wrap new vector<bool> as old
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _Alloc;
	typedef bit_vector _Myt;

	bit_vector()
		: vector<_Bool, _Bool_allocator>()
		{	// construct empty vector
		}

	explicit bit_vector(size_type _Count, const _Ty& _Val = _Ty())
		: vector<_Bool, _Bool_allocator>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	bit_vector(_Iter _First, _Iter _Last)
		: vector<_Bool, _Bool_allocator>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// TEMPLATE CLASS priority_queue
template<class _Container,
	class _Pr = less<_Container::value_type> >
	class Priority_queue
		: public priority_queue<_Container::value_type, _Container, _Pr>
	{	// wrap new priority_queue as old
public:
	typedef typename _Container::value_type _Ty;

	Priority_queue()
		: priority_queue<_Ty, _Container, _Pr>(_Pr())
		{	// construct empty queue from defaults
		}

	explicit Priority_queue(const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_Pred)
		{	// construct empty queue from comparator
		}

	typedef const _Ty *_Iter;

	Priority_queue(_Iter _First, _Iter _Last)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pr())
		{	// construct queue from [_First, _Last)
		}

	Priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS queue
template<class _Container>
	class Queue
		: public queue<_Container::value_type, _Container>
	{	// wrap new queue as old
	};

		// TEMPLATE CLASS stack
template<class _Container>
	class Stack
		: public stack<_Container::value_type, _Container>
	{	// wrap new stack as old
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif /* _STL_H_ */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(CRTDLL2)
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP2 wctrans_t __cdecl wctrans(const char *);
_CRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
_C_LIB_DECL

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT		0x20
#define _FE_INVALID		0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __cdecl _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2 double __cdecl _Cosh(double, double);
_CRTIMP2 short __cdecl _Dtest(double *);
_CRTIMP2 short __cdecl _Exp(double *, double, short);
_CRTIMP2 double __cdecl _Log(double, int);
_CRTIMP2 double __cdecl _Sin(double, unsigned int);
_CRTIMP2 double __cdecl _Sinh(double, double);
extern _CRTIMP2 const _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2 float __cdecl _FCosh(float, float);
_CRTIMP2 short __cdecl _FDtest(float *);
_CRTIMP2 short __cdecl _FExp(float *, float, short);
_CRTIMP2 float __cdecl _FLog(float, int);
_CRTIMP2 float __cdecl _FSin(float, unsigned int);
_CRTIMP2 float __cdecl _FSinh(float, float);
extern _CRTIMP2 const _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2 long double __cdecl _LCosh(long double, long double);
_CRTIMP2 short __cdecl _LDtest(long double *);
_CRTIMP2 short __cdecl _LExp(long double *, long double, short);
_CRTIMP2 long double __cdecl _LLog(long double, int);
_CRTIMP2 long double __cdecl _LSin(long double, unsigned int);
_CRTIMP2 long double __cdecl _LSinh(long double, long double);
_CRTIMP2 extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
_C_STD_END
#endif /* _YMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\iso646.h ===
/* iso646.h standard header */
#ifndef _ISO646
#define _ISO646
#define and		&&
#define and_eq	&=
#define bitand	&
#define bitor	|
#define compl	~
#define not		!
#define not_eq	!=
#define or		||
#define or_eq	|=
#define xor		^
#define xor_eq	^=
#endif /* _ISO646 */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#ifdef _DLL
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\stl.h ===
// stl.h supplemental header
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>
using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque : public deque<_Ty, allocator<_Ty> > {
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit Deque()
		: deque<_Ty, _A>() {}
	explicit Deque(size_type _N, const _Ty& _V = _Ty())
		: deque<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	Deque(_It _F, _It _L)
		: deque<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{deque<_Ty, _A>::swap((deque<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List : public list<_Ty, allocator<_Ty> > {
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit List()
		: list<_Ty, _A>() {}
	explicit List(size_type _N, const _Ty& _V = _Ty())
		: list<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	List(_It _F, _It _L)
		: list<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{list<_Ty, _A>::swap((list<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Map
template<class _K, class _Ty, class _Pr = less<_K> >
	class Map : public map<_K, _Ty, _Pr, allocator<_Ty> > {
public:
	typedef Map<_K, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _A;
	explicit Map(const _Pr& _Pred = _Pr())
		: map<_K, _Ty, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Map(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: map<_K, _Ty, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{map<_K, _Ty, _Pr, _A>::
			swap((map<_K, _Ty, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Multimap
template<class _K, class _Ty, class _Pr = less<_K> >
	class Multimap
		: public multimap<_K, _Ty, _Pr, allocator<_Ty> > {
public:
	typedef Multimap<_K, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _A;
	explicit Multimap(const _Pr& _Pred = _Pr())
		: multimap<_K, _Ty, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Multimap(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: multimap<_K, _Ty, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{multimap<_K, _Ty, _Pr, _A>::
			swap((multimap<_K, _Ty, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Set
template<class _K, class _Pr = less<_K> >
	class Set : public set<_K, _Pr, allocator<_K> > {
public:
	typedef Set<_K, _Pr> _Myt;
	typedef allocator<_K> _A;
	explicit Set(const _Pr& _Pred = _Pr())
		: set<_K, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Set(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: set<_K, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{set<_K, _Pr, _A>::swap((set<_K, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Multiset
template<class _K, class _Pr = less<_K> >
	class Multiset : public multiset<_K, _Pr, allocator<_K> > {
public:
	typedef Multiset<_K, _Pr> _Myt;
	typedef allocator<_K> _A;
	explicit Multiset(const _Pr& _Pred = _Pr())
		: multiset<_K, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Multiset(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: multiset<_K, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{multiset<_K, _Pr, _A>::
			swap((multiset<_K, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector : public vector<_Ty, allocator<_Ty> > {
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit Vector()
		: vector<_Ty, _A>(_Al) {}
	explicit Vector(size_type _N, const _Ty& _V = _Ty())
		: vector<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	Vector(_It _F, _It _L)
		: vector<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{vector<_Ty, _A>::swap((vector<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// CLASS bit_vector
class bit_vector : public vector<_Bool, _Bool_allocator> {
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _A;
	typedef bit_vector _Myt;
	explicit bit_vector()
		: vector<_Bool, _Bool_allocator>() {}
	explicit bit_vector(size_type _N, const _Ty& _V = _Ty())
		: vector<_Bool, _Bool_allocator>(_N, _V) {}
	typedef const_iterator _It;
	bit_vector(_It _F, _It _L)
		: vector<_Bool, _Bool_allocator>(_F, _L) {}
	void swap(_Myt& _X)
		{vector<_Bool, _Bool_allocator>::
			swap((vector<_Bool, _Bool_allocator>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS priority_queue
template<class _C = vector<_Ty>,
	class _Pr = less<_C::value_type> >
	class Priority_queue
		: public priority_queue<_C::value_type, _C, _Pr,
			allocator<_C::value_type> > {
public:
	typedef _C::value_type _Ty;
	typedef allocator<_C::value_type> _A;
	explicit Priority_queue(const _Pr& _X = _Pr())
		: priority_queue<_Ty, _C, _Pr, _A>(_X) {}
	typedef const value_type *_It;
	Priority_queue(_It _F, _It _L, const _Pr& _X = _Pr())
		: priority_queue<_Ty, _C, _Pr, _A>(_F, _L, _X) {}
	};

		// TEMPLATE CLASS queue
template<class _C = deque<_Ty> >
	class Queue
		: public queue<_C::value_type, _C,
			allocator<_C::value_type> > {
	};

		// TEMPLATE CLASS stack
template<class _C = deque<_Ty> >
	class Stack
		: public stack<_C::value_type, _C,
			allocator<_C::value_type> > {
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif	/* _STL_H_ */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#define _CPPLIB_VER	310

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	_MT	/* nontrivial locks if multithreaded */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */
 #else
  #define _TLS_QUAL
 #endif

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif

 #define _HAS_TEMPLATE_PARTIAL_ORDERING	0

#include <use_ansi.h>

#ifndef _VC6SP2
 #define _VC6SP2	0 /* define as 1 to fix linker errors with V6.0 SP2 */
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2
  #ifdef  CRTDLL2
   #define _CRTIMP2	__declspec(dllexport)
  #else   /* ndef CRTDLL2 */
   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)
   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */
  #endif  /* CRTDLL2 */
 #endif  /* _CRTIMP2 */

 #ifndef _INTERNAL_IFSTRIP_
 /* These functions are for enabling STATIC_CPPLIB functionality */
    #define _cpp_stdin  (&(__iob_func())[0])
    #define _cpp_stdout (&(__iob_func())[1])
    #define _cpp_stderr (&(__iob_func())[2])
    #define _cpp_isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
 #endif
 #if defined(_DLL) && !defined(_STATIC_CPPLIB)
  #define _DLL_CPPLIB
 #endif

 #ifndef _INTERNAL_IFSTRIP_
/* Define _CRTBLD_NATIVE_WCHAR_T */
 #if defined(_CRTBLD) && defined(__cplusplus)
  #ifndef _NATIVE_WCHAR_T_DEFINED
   #error Native wchar_t must be defined
  #else
   #define _CRTBLD_NATIVE_WCHAR_T
  #endif /* _NATIVE_WCHAR_T_DEFINED */
 #endif /* defined(_CRTBLD) && defined(__cplusplus) */
 #endif

 #if (1300 <= _MSC_VER)
  #define _DEPRECATED	__declspec(deprecated)
 #else
  #define _DEPRECATED
 #endif

		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}

  #define _CSTD			::
   #define _C_STD_BEGIN	/* match _STD_BEGIN/END if *.c compiled as C++ */
   #define _C_STD_END

  #define _C_LIB_DECL	extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL }
  #define _EXTERN_C		extern "C" {
  #define _END_EXTERN_C }

 #else /* __cplusplus */
  #define _STD
  #define _STD_BEGIN
  #define _STD_END

  #define _CSTD
  #define _C_STD_BEGIN
  #define _C_STD_END

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _MAX_LOCK		3	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
		// CLASS _Lockit
class _CRTIMP2 _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  #if _MULTI_THREAD
	explicit _Lockit();	// set default lock
	explicit _Lockit(int);	// set the lock
	~_Lockit();	// clear the lock

private:
	_Lockit(const _Lockit&);				// not defined
	_Lockit& operator=(const _Lockit&);	// not defined

	int _Locktype;
  #else /* _MULTI_THREAD */
   #define _LOCKIT(x)
	explicit _Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _CRTIMP2 _Mutex
	{	// lock under program control
public:
  #if _MULTI_THREAD
	_Mutex();
	~_Mutex();
	void _Lock();
	void _Unlock();

private:
	_Mutex(const _Mutex&);				// not defined
	_Mutex& operator=(const _Mutex&);	// not defined
	void *_Mtx;
  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _Init_locks
	{	// initialize mutexes
public:
 #if _MULTI_THREAD
	_Init_locks();
	~_Init_locks();
 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */ 
	};
_STD_END
 #endif /* __cplusplus */


		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_EXTERN_C
_CRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));
_END_EXTERN_C

typedef int _Mbstatet;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

#endif /* _YVALS */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX 
#define _X_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGE	_CATMASK(_X_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP2 _Collvec __cdecl _Getcoll();
_CRTIMP2 _Ctypevec __cdecl _Getctype();
_CRTIMP2 _Cvtvec __cdecl _Getcvt();

_CRTIMP2 int __cdecl _Getdateorder();
_CRTIMP2 char *__cdecl _Getdays();
_CRTIMP2 char *__cdecl _Getmonths();
_CRTIMP2 void *__cdecl _Gettnames();

_CRTIMP2 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
_CRTIMP2 float __cdecl _Stof(const char *, char **, long);
_CRTIMP2 double __cdecl _Stod(const char *, char **, long);
_CRTIMP2 long double __cdecl _Stold(const char *, char **, long);
_CRTIMP2 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP2 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2 int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2 const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\ymath.h ===
/* ymath.h internal header */
#ifndef _YMATH
#define _YMATH
#include <wctype.h>
#include <math.h>
#ifndef _YVALS
#include <yvals.h>
#endif
		/* MACROS */
#define _FINITE		-1
#define _INFCODE	1
#define _NANCODE	2
		/* TYPE DEFINITIONS */
typedef union {
	unsigned short _W[5];
	float _F;
	double _D;
	long double _L;
	} _Dconst;
_C_LIB_DECL
		/* double DECLARATIONS */
_CRTIMP2 double __cdecl _Cosh(double, double);
_CRTIMP2 short __cdecl _Dtest(double *);
_CRTIMP2 short __cdecl _Exp(double *, double, short);
_CRTIMP2 double __cdecl _Sinh(double, double);
extern _CRTIMP2 const _Dconst _Denorm, _Hugeval, _Inf, _Nan, _Snan;
		/* float DECLARATIONS */
_CRTIMP2 float __cdecl _FCosh(float, float);
_CRTIMP2 short __cdecl _FDtest(float *);
_CRTIMP2 short __cdecl _FExp(float *, float, short);
_CRTIMP2 float __cdecl _FSinh(float, float);
extern _CRTIMP2 const _Dconst _FDenorm, _FInf, _FNan, _FSnan;
		/* long double DECLARATIONS */
_CRTIMP2 long double __cdecl _LCosh(long double, long double);
_CRTIMP2 short __cdecl _LDtest(long double *);
_CRTIMP2 short __cdecl _LExp(long double *, long double, short);
_CRTIMP2 long double __cdecl _LSinh(long double, long double);
extern _CRTIMP2 const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
#endif /* _YMATH */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#ifndef _YVALS
#define _YVALS
#include <use_ansi.h>

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef	CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else	/* ndef CRTDLL2 */
#ifdef	_DLL
#define _CRTIMP2 __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP2
#endif	/* _DLL */
#endif	/* CRTDLL2 */
#endif	/* _CRTIMP2 */

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

 #pragma warning(4: 4018 4114 4146 4244 4245)
 #pragma warning(4: 4663 4664 4665)
 #pragma warning(disable: 4237 4284 4290 4514)
		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		};
  #define _STD_USING
 #else
  #define _STD			::
  #define _STD_BEGIN
  #define _STD_END
 #endif /* __cplusplus */
_STD_BEGIN
		/* TYPE bool */
 #if defined(__cplusplus)
typedef bool _Bool;
 #endif /* __cplusplus */
		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36
		/* STDIO PROPERTIES */
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)	((long)(fp))
#endif /* _FPOS_T_DEFINED */

		/* NAMING PROPERTIES */
 #if defined(__cplusplus)
  #define _C_LIB_DECL extern "C" {
  #define _END_C_LIB_DECL }
 #else
  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
 #endif /* __cplusplus */
#define _CDECL
		// CLASS _Lockit
 #if defined(__cplusplus)
class _CRTIMP2 _Lockit
	{	// lock while object in existence
public:
  #ifdef _MT
   #define _LOCKIT(x)	lockit x
	_Lockit();
	~_Lockit();
  #else
   #define _LOCKIT(x)
	_Lockit()
		{}
	~_Lockit()
		{}
  #endif /* _MT */
	};
 #endif /* __cplusplus */
		/* MISCELLANEOUS MACROS */
#define _L(c)	L##c
#define _Mbstinit(x)	mbstate_t x = {0}
#define _MAX	_cpp_max
#define _MIN	_cpp_min
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
#include <yvals.h>
#endif


		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _LC_ALL			LC_ALL
#define _LC_COLLATE		LC_COLLATE
#define _LC_CTYPE		LC_CTYPE
#define _LC_MONETARY	LC_MONETARY
#define _LC_NUMERIC		LC_NUMERIC
#define _LC_TIME 		LC_TIME
#define _LC_MAX			LC_MAX 
#define _LC_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_LC_COLLATE)
#define _M_CTYPE	_CATMASK(_LC_CTYPE)
#define _M_MONETARY	_CATMASK(_LC_MONETARY)
#define _M_NUMERIC	_CATMASK(_LC_NUMERIC)
#define _M_TIME		_CATMASK(_LC_TIME)
#define _M_MESSAGE	_CATMASK(_LC_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP2 _Collvec __cdecl _Getcoll();
_CRTIMP2 _Ctypevec __cdecl _Getctype();
_CRTIMP2 _Cvtvec __cdecl _Getcvt();
char *__cdecl _Getdays();
char *__cdecl _Getmonths();
void *__cdecl _Gettnames();
_CRTIMP2 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
extern float __cdecl _Stof(const char *, char **, long);
extern double __cdecl _Stod(const char *, char **, long);
extern long double __cdecl _Stold(const char *, char **, long);
_CRTIMP2 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP2 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2 int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\clearerr.c ===
/***
*clearerr.c - clear error and eof flags
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines clearerr() - clear error and eof flags from a stream
*
*Revision History:
*       11-30-83  RN    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-01-88  JCR   Clear lowio flags as well as stdio flags
*       02-15-90  GJF   Fixed copyright and indents
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       02-25-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <mtdll.h>
#include <internal.h>
#ifndef _POSIX_
#include <msdos.h>
#endif

/***
*void clearerr(stream) - clear error and eof flags on a stream
*
*Purpose:
*       Resets the error and eof indicators for a stream to 0
*
*Entry:
*       FILE *stream - stream to set indicators on
*
*Exit:
*       No return value.
*       changes the _flag field of the FILE struct.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl clearerr (
        FILE *stream
        )
{
        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        /* Clear stdio level flags */
        stream->_flag &= ~(_IOERR|_IOEOF);

        /* Clear lowio level flags */

#ifndef _POSIX_
        _osfile_safe(_fileno(stream)) &= ~(FEOFLAG);
#endif

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdhpp64\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/

#ifndef _MAC

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300 /*IFSTRIP=IGN*/
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP2 wctrans_t __cdecl wctrans(const char *);
_CRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */

#endif  /* ndef _MAC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\cscanf.c ===
/***
*cscanf.c - Conio version of scanf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Perform formatted i/o directly to the keyboard.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define CPRFLAG 1
#include "input.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\cprintf.c ===
/***
*cprintf.c - Conio version of printf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Perform formatted i/o directly to the console.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\closeall.c ===
/***
*closeall.c - close all open files
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fcloseall() - closes all open files except stdin, stdout
*       stdprn, stderr, and stdaux.
*
*Revision History:
*       09-19-83  RN    initial version
*       06-26-87  JCR   Stream search starts with _iob[3] for OS/2
*       11-02-87  JCR   Multi-thread support
*       11-08-87  SKS   Changed PROTMODE to OS2
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Added check that OS2 is defined whenever M_I386 is.
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       10-03-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       03-25-92  DJM   POSIX support
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       03-06-95  GJF   Converted to walk the __piob[] table (rather than
*                       the _iob[] table).
*       02-25-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int _fcloseall() - close all open streams
*
*Purpose:
*       Closes all streams currently open except for stdin/out/err/aux/prn.
*       tmpfile() files are among those closed.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed if OK
*       returns EOF if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fcloseall (
        void
        )
{
        REG2 int count = 0;
        REG1 i;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        for ( i = 3 ; i < _nstream ; i++ ) {

            if ( __piob[i] != NULL ) {
                /*
                 * if the stream is in use, close it
                 */
                if ( inuse( (FILE *)__piob[i] ) && (fclose( __piob[i] ) !=
                     EOF) )
                        count++;

                /*
                 * if stream is part of a _FILEX we allocated, free it.
                 */
                if ( i >= _IOB_ENTRIES ) {

#ifdef  _MT
                    DeleteCriticalSection( &(((_FILEX *)__piob[i])->lock) );
#endif
                    _free_crt( __piob[i] );
                    __piob[i] = NULL;
                }
            }
        }

#ifdef  _MT
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\cwscanf.c ===
/***
*cscanf.c - Conio version of scanf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Perform formatted i/o directly to the keyboard.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define CPRFLAG 1
#include "winput.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\cwprintf.c ===
/***
*cwprintf.c - Conio version of wprintf
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Perform formatted i/o directly to the console.
*
*Revision History:
*       02-11-00  GB    Stub module created.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#define CPRFLAG 1
#include "output.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fclose.c ===
/***
*fclose.c - close a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fclose() - close an open file
*
*Revision History:
*       09-02-83  RN    initial version
*       05-14-87  SKS   error return from fflush must not be clobbered
*       08-10-87  JCR   Added code to support P_tmpdir with or without trailing '\'
*       11-01-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-31-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       03-11-92  GJF   For Win32, revised temporary file cleanup.
*       03-25-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       01-13-93  GJF   Don't need/want to remove() tmp files on Windows NT
*                       (file is removed by the OS when handle is closed).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version. Removed some useless #ifdef-s.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       05-12-95  CFW   Paranoia: set _tmpfname field to NULL.
*       02-25-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <file2.h>
#include <string.h>
#include <io.h>
#include <stdlib.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int fclose(stream) - close a stream
*
*Purpose:
*       Flushes and closes a stream and frees any buffer associated
*       with that stream, unless it was set with setbuf.
*
*Entry:
*       FILE *stream - stream to close
*
*Exit:
*       returns 0 if OK, EOF if fails (can't _flush, not a FILE, not open, etc.)
*       closes the file -- affecting FILE structure
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT      /* multi-thread; define both fclose and _fclose_lk */

int __cdecl fclose (
        FILE *stream
        )
{
        int result = EOF;

        _ASSERTE(stream != NULL);

        /* If stream is a string, simply clear flag and return EOF */
        if (stream->_flag & _IOSTRG)
                stream->_flag = 0;  /* IS THIS REALLY NEEDED ??? */

        /* Stream is a real file. */
        else {
                _lock_str(stream);
                __try {
                        result = _fclose_lk(stream);
                }
                __finally {
                        _unlock_str(stream);
                }
        }

        return(result);
}

/***
*int _fclose_lk() - close a stream (lock already held)
*
*Purpose:
*       Core fclose() routine; assumes caller has stream lock held.
*
*       [See fclose() above for more information.]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fclose_lk (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int result = EOF;

        /* Init near stream pointer */
        stream = str;

#else       /* non multi-thread; just define fclose() */

int __cdecl fclose (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int result = EOF;

        /* Init near stream pointer */
        stream = str;

        if (stream->_flag & _IOSTRG) {
                stream->_flag = 0;
                return(EOF);
        }

#endif

        _ASSERTE(str != NULL);

        if (inuse(stream)) {

                /* Stream is in use:
                       (1) flush stream
                       (2) free the buffer
                       (3) close the file
                       (4) delete the file if temporary
                */

                result = _flush(stream);
                _freebuf(stream);

#ifdef _POSIX_
                if (close(fileno(stream)) <0)
#else
                if (_close(_fileno(stream)) < 0)
#endif
                        result = EOF;

                else if ( stream->_tmpfname != NULL ) {
                        /*
                         * temporary file (i.e., one created by tmpfile()
                         * call). delete, if necessary (don't have to on
                         * Windows NT because it was done by the system when
                         * the handle was closed). also, free up the heap
                         * block holding the pathname.
                         */
#ifdef _POSIX_
                        if ( unlink(stream->_tmpfname) )
                                result = EOF;
#endif

                        _free_crt(stream->_tmpfname);
                stream->_tmpfname = NULL;
                }

        }

        stream->_flag = 0;
        return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fdopen.c ===
/***
*fdopen.c - open a file descriptor as stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fdopen() - opens a file descriptor as a stream, thus allowing
*       buffering, etc.
*
*Revision History:
*       09-02-83  RN    initial version
*       03-02-87  JCR   added support for 'b' and 't' embedded in mode strings
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-03-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2 references
*       11-20-89  GJF   Fixed copyright, indents. Added const to type of mode.
*       02-15-90  GJF   _iob[], _iob2[] merge.
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-24-90  SBM   Added support for 'c' and 'n' flags
*       10-02-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       02-14-92  GJF   Replaced _nfile with _nhandle for Win32.
*       05-01-92  DJM   Replaced _nfile with OPEN_MAX for POSIX.
*       08-03-92  GJF   Function name must be "fdopen" for POSIX.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-04-95  GJF   _WIN32_ -> _WIN32.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       10-20-95  GJF   Added checks to passed supplied handle is open (for
*                       Win32 and Mac builds) (Olympus0 10153).
*       09-26-97  BWT   Fix POSIX
*       02-26-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Set errno EMFILE when out of streams.
*
*******************************************************************************/

#include <cruntime.h>
#include <msdos.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#ifdef  _POSIX_
#include <limits.h>
#endif
#include <tchar.h>
#include <errno.h>

/***
*FILE *_fdopen(filedes, mode) - open a file descriptor as a stream
*
*Purpose:
*       associates a stream with a file handle, thus allowing buffering, etc.
*       The mode must be specified and must be compatible with the mode
*       the file was opened with in the low level open.
*
*Entry:
*       int filedes - handle referring to open file
*       _TSCHAR *mode - file mode to use ("r", "w", "a", etc.)
*
*Exit:
*       returns stream pointer and sets FILE struct fields if successful
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfdopen (
        int filedes,
        REG2 const _TSCHAR *mode
        )
{
        REG1 FILE *stream;
        int whileflag, tbflag, cnflag;

        _ASSERTE(mode != NULL);

#if     !defined(_POSIX_)

        _ASSERTE((unsigned)filedes < (unsigned)_nhandle);
        _ASSERTE(_osfile(filedes) & FOPEN);

        if ( ((unsigned)filedes >= (unsigned)_nhandle) ||
             !(_osfile(filedes) & FOPEN) )
            return(NULL);

#else

        _ASSERTE((unsigned)filedes < OPEN_MAX);

        if ((unsigned)filedes >= OPEN_MAX)
            return(NULL);

#endif  /* !_POSIX_ */


        /* Find a free stream; stream is returned 'locked'. */

        if ((stream = _getstream()) == NULL) {
            errno = EMFILE;
            return(NULL);
        }

#ifdef  _MT
        __try {
#endif

        /* First character must be 'r', 'w', or 'a'. */

        switch (*mode) {
            case _T('r'):
                stream->_flag = _IOREAD;
                break;
            case _T('w'):
            case _T('a'):
                stream->_flag = _IOWRT;
                break;
            default:
                stream = NULL;  /* error */
                goto done;
                break;
        }

        /* There can be up to three more optional characters:
           (1) A single '+' character,
           (2) One of 'b' and 't' and
           (3) One of 'c' and 'n'.

           Note that currently, the 't' and 'b' flags are syntax checked
           but ignored.  'c' and 'n', however, are correctly supported.
        */

        whileflag=1;
        tbflag=cnflag=0;
        stream->_flag |= _commode;

        while(*++mode && whileflag)
            switch(*mode) {

                case _T('+'):
                    if (stream->_flag & _IORW)
                        whileflag=0;
                    else {
                        stream->_flag |= _IORW;
                        stream->_flag &= ~(_IOREAD | _IOWRT);
                    }
                    break;

                case _T('b'):
                case _T('t'):
                    if (tbflag)
                        whileflag=0;
                    else
                        tbflag=1;
                    break;

                case _T('c'):
                    if (cnflag)
                        whileflag = 0;
                    else {
                        cnflag = 1;
                        stream->_flag |= _IOCOMMIT;
                    }
                    break;

                case _T('n'):
                    if (cnflag)
                        whileflag = 0;
                    else {
                        cnflag = 1;
                        stream->_flag &= ~_IOCOMMIT;
                    }
                    break;

                default:
                    whileflag=0;
                    break;
            }

#ifndef CRTDLL
        _cflush++;  /* force library pre-termination procedure */
#endif  /* CRTDLL */

        stream->_file = filedes;

/* Common return */

done:
#ifdef  _MT
        ; }
        __finally {
            _unlock_str(stream);
        }
#endif
        return(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fflush.c ===
/***
*fflush.c - flush a stream buffer
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fflush() - flush the buffer on a stream
*               _flushall() - flush all stream buffers
*
*Revision History:
*       09-01-83  RN    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merge DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       11-29-89  GJF   Added support for fflush(NULL) (per ANSI). Merged in
*                       flushall().
*       01-24-90  GJF   Fixed fflush(NULL) functionality to comply with ANSI
*                       (must only call fflush() for output streams)
*       03-16-90  GJF   Made calling type  _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Made flsall() _CALLTYPE4.
*       05-09-90  SBM   _fflush_lk became _flush, added new [_]fflush[_lk]
*       07-11-90  SBM   Commit mode on a per stream basis
*       10-02-90  GJF   New-style function declarators.
*       12-12-90  GJF   Fixed mis-placed paran in ternary expr commiting the
*                       buffers.
*       01-16-91  SRW   Reversed test of _commit return value
*       01-21-91  GJF   ANSI naming.
*       06-05-91  GJF   On a successful _flush of a read/write stream in write
*                       mode, clear _IOWRT so that the next operation can be a
*                       read. ANSI requirement (C700 bug #2531).
*       07-30-91  GJF   Added support for termination scheme used on
*                       non-Cruiser targets [_WIN32_].
*       08-19-91  JCR   Added _exitflag, _endstdio
*       03-16-92  SKS   Moved _cflush to the initializer module (in assembler)
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       03-18-93  CFW   fflush_lk returns 0 before exit.
*       03-19-93  GJF   Revised flsall() so that, in multi-thread models,
*                       unused streams are not locked unnecessarily.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-10-93  GJF   Purged ftell call accidently checked in 3/10/93.
*       10-29-93  GJF   Define entry for termination section (used to be in
*                       in i386\cinitstd.asm). Also, replaced MTHREAD with
*                       _MT.
*       04-05-94  GJF   #ifdef-ed out _cflush definition for msvcrt*.dll, it
*                       is unnecessary.
*       08-18-94  GJF   Moved terminator stuff (including _cflush def) to
*                       _file.c
*       02-17-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       03-07-95  GJF   Changed flsall() to iterate over the __piob[] table.
*                       Also, changed to locks based on __piob.
*       12-28-95  GJF   Repaced reference to _NSTREAM_ with _nstream (users
*                       may change the max. number of supported streams).
*       08-01-96  RDK   Change termination pointer data type to static.
*       02-13-98  GJF   Changes for Win64: added int cast to pointer diff.
*       02-27-98  GJF   Exception-safe locking.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#include <fcntl.h>
#endif
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <mtdll.h>
#include <internal.h>


/* Values passed to flsall() to distinguish between _flushall() and
 * fflush(NULL) behavior
 */
#define FLUSHALL        1
#define FFLUSHNULL      0

/* Core routine for fflush(NULL) and flushall()
 */
static int __cdecl flsall(int);


/***
*int fflush(stream) - flush the buffer on a stream
*
*Purpose:
*       if file open for writing and buffered, flush the buffer. if problems
*       flushing the buffer, set the stream flag to error
*       Always flushes the stdio stream and forces a commit to disk if file
*       was opened in commit mode.
*
*Entry:
*       FILE *stream - stream to flush
*
*Exit:
*       returns 0 if flushed successfully, or no buffer to flush
*       returns EOF and sets file error flag if fails.
*       FILE struct entries affected: _ptr, _cnt, _flag.
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT

int __cdecl fflush (
        REG1 FILE *stream
        )
{
        int rc;

        /* if stream is NULL, flush all streams
         */
        if ( stream == NULL )
                return(flsall(FFLUSHNULL));

        _lock_str(stream);

        __try {
                rc = _fflush_lk(stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(rc);
}


/***
*_fflush_lk() - Flush the buffer on a stream (stream is already locked)
*
*Purpose:
*       Core flush routine; assumes stream lock is held by caller.
*
*       [See fflush() above for more information.]
*
*Entry:
*       [See fflush()]
*Exit:
*       [See fflush()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fflush_lk (
        REG1 FILE *str
        )
{

#else   /* non multi-thread */

int __cdecl fflush (
        REG1 FILE *str
        )
{

        /* if stream is NULL, flush all streams */
        if ( str == NULL ) {
                return(flsall(FFLUSHNULL));
        }

#endif  /* rejoin common code */

        if (_flush(str) != 0) {
                /* _flush failed, don't attempt to commit */
                return(EOF);
        }

        /* lowio commit to ensure data is written to disk */
#ifndef _POSIX_
        if (str->_flag & _IOCOMMIT) {
                return (_commit(_fileno(str)) ? EOF : 0);
        }
#endif
        return 0;
}


/***
*int _flush(stream) - flush the buffer on a single stream
*
*Purpose:
*       If file open for writing and buffered, flush the buffer.  If
*       problems flushing the buffer, set the stream flag to error.
*       Multi-thread version assumes stream lock is held by caller.
*
*Entry:
*       FILE* stream - stream to flush
*
*Exit:
*       Returns 0 if flushed successfully, or if no buffer to flush.,
*       Returns EOF and sets file error flag if fails.
*       File struct entries affected: _ptr, _cnt, _flag.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flush (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int rc = 0; /* assume good return */
        REG3 int nchar;

        /* Init pointer to stream */
        stream = str;

#ifdef _POSIX_

        /*
         * Insure that EBADF is returned whenever the underlying
         * file descriptor is closed.
         */

        if (-1 == fcntl(fileno(stream), F_GETFL))
                return(EOF);

        /*
         * Posix ignores read streams to insure that the result of
         * ftell() is the same before and after fflush(), and to
         * avoid seeking on pipes, ttys, etc.
         */

        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOREAD) {
                return 0;
        }

#endif /* _POSIX_ */

        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOWRT && bigbuf(stream)
                && (nchar = (int)(stream->_ptr - stream->_base)) > 0)
        {
#ifdef _POSIX_
                if ( write(fileno(stream), stream->_base, nchar) == nchar ) {
#else
                if ( _write(_fileno(stream), stream->_base, nchar) == nchar ) {
#endif
                        /* if this is a read/write file, clear _IOWRT so that
                         * next operation can be a read
                         */
                        if ( _IORW & stream->_flag )
                                stream->_flag &= ~_IOWRT;
                }
                else {
                        stream->_flag |= _IOERR;
                        rc = EOF;
                }
        }

        stream->_ptr = stream->_base;
        stream->_cnt = 0;

        return(rc);
}


/***
*int _flushall() - flush all output buffers
*
*Purpose:
*       flushes all the output buffers to the file, clears all input buffers.
*
*Entry:
*       None.
*
*Exit:
*       returns number of open streams
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flushall (
        void
        )
{
        return(flsall(FLUSHALL));
}


/***
*static int flsall(flushflag) - flush all output buffers
*
*Purpose:
*       Flushes all the output buffers to the file and, if FLUSHALL is passed,
*       clears all input buffers. Core routine for both fflush(NULL) and
*       flushall().
*
*       MTHREAD Note: All the locking/unlocking required for both fflush(NULL)
*       and flushall() is performed in this routine.
*
*Entry:
*       int flushflag - flag indicating the exact semantics, there are two
*                       legal values: FLUSHALL and FFLUSHNULL
*
*Exit:
*       if flushflag == FFLUSHNULL then flsbuf returns:
                0, if successful
*               EOF, if an error occurs while flushing one of the streams
*
*       if flushflag == FLUSHALL then flsbuf returns the number of streams
*       successfully flushed
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl flsall (
        int flushflag
        )
{
        REG1 int i;
        int count = 0;
        int errcode = 0;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        for ( i = 0 ; i < _nstream ; i++ ) {

                if ( (__piob[i] != NULL) && (inuse((FILE *)__piob[i])) ) {

#ifdef  _MT
                        /*
                         * lock the stream. this is not done until testing
                         * the stream is in use to avoid unnecessarily creating
                         * a lock for every stream. the price is having to
                         * retest the stream after the lock has been asserted.
                         */
                        _lock_str2(i, __piob[i]);

                        __try {
                                /*
                                 * if the stream is STILL in use (it may have been
                                 * closed before the lock was asserted), see about
                                 * flushing it.
                                 */
                                if ( inuse((FILE *)__piob[i]) ) {
#endif

                        if ( flushflag == FLUSHALL ) {
                                /*
                                 * FLUSHALL functionality: fflush the read or
                                 * write stream and, if successful, update the
                                 * count of flushed streams
                                 */
                                if ( _fflush_lk(__piob[i]) != EOF )
                                        /* update count of successfully flushed
                                         * streams
                                         */
                                        count++;
                        }
                        else if ( (flushflag == FFLUSHNULL) &&
                                  (((FILE *)__piob[i])->_flag & _IOWRT) ) {
                                /*
                                 * FFLUSHNULL functionality: fflush the write
                                 * stream and kept track of the error, if one
                                 * occurs
                                 */
                                if ( _fflush_lk(__piob[i]) == EOF )
                                        errcode = EOF;
                        }

#ifdef  _MT
                                }
                        }
                        __finally {
                                _unlock_str2(i, __piob[i]);
                        }
#endif
                }
        }

#ifdef  _MT
        }
        __finally {
                _munlock(_IOB_SCAN_LOCK);
        }
#endif

        if ( flushflag == FLUSHALL )
                return(count);
        else
                return(errcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgetc.c ===
/***
*fgetc.c - get a character from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetc() and getc() - read  a character from a stream
*
*Revision History:
*       09-01-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-21-89  PHG   Added getc() function
*       02-15-90  GJF   Fixed copyright and indents
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       04-30-93  CFW   Remove wide char support to fgetwc.c.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       07-20-97  GJF   Made getc() identical to fgetc(). Also, detab-ed.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fgetc(stream), getc(stream) - read a character from a stream
*
*Purpose:
*       reads a character from the given stream
*
*Entry:
*       FILE *stream - stream to read character from
*
*Exit:
*       returns the character read
*       returns EOF if at end of file or error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fgetc (
        REG1 FILE *stream
        )
{
        int retval;

        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _getc_lk(stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#undef getc

int __cdecl getc (
        FILE *stream
        )
{
        int retval;

        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _getc_lk(stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\feoferr.c ===
/***
*feoferr.c - defines feof() and ferror()
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines feof() (test for end-of-file on a stream) and ferror() (test
*	for error on a stream).
*
*Revision History:
*	03-13-89  GJF	Module created
*	03-27-89  GJF	Moved to 386 tree
*	02-15-90  GJF	Fixed copyright
*	03-16-90  GJF	Made calling type  _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-02-90  GJF	New-style function declarators.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/* remove macro definitions for feof() and ferror()
 */
#undef	feof
#undef	ferror

/***
*int feof(stream) - test for end-of-file on stream
*
*Purpose:
*	Tests whether or not the given stream is at end-of-file. Normally
*	feof() is a macro, but it must also be available as a true function
*	for ANSI.
*
*Entry:
*	FILE *stream - stream to test
*
*Exit:
*	returns nonzero (_IOEOF to be more precise) if and only if the stream
*	is at end-of-file
*
*Exceptions:
*
*******************************************************************************/

int __cdecl feof (
	FILE *stream
	)
{
	return( ((stream)->_flag & _IOEOF) );
}


/***
*int ferror(stream) - test error indicator on stream
*
*Purpose:
*	Tests the error indicator for the given stream. Normally, feof() is
*	a macro, but it must also be available as a true function for ANSI.
*
*Entry:
*	FILE *stream - stream to test
*
*Exit:
*	returns nonzero (_IOERR to be more precise) if and only if the error
*	indicator for the stream is set.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl ferror (
	FILE *stream
	)
{
	return( ((stream)->_flag & _IOERR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgetchar.c ===
/***
*fgetchar.c - get a character from stdin
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fgetchar() and getchar() - read a character from stdin
*	defines _fgetwchar() and getwchar() - read a wide character from stdin
*
*Revision History:
*	11-20-83  RN	initial version
*	11-09-87  JCR	Multi-thread support
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-31-88  PHG	Merged DLL and normal versions
*	06-21-89  PHG	Added getchar() function
*	02-15-90  GJF	Fixed copyright and indents
*	03-16-90  GJF	Replaced _LOAD_DS with _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-03-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	04-26-93  CFW	Wide char enable.
*	04-30-93  CFW	Move wide char support to fgetwchr.c.
*	03-15-95  GJF	Deleted #include <tchar.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/***
*int _fgetchar(), getchar() - read a character from stdin
*
*Purpose:
*	Reads the next character from stdin.  Function version of
*	getchar() macro.
*
*Entry:
*	None.
*
*Exit:
*	Returns character read or EOF if at end-of-file or an error occured,
*	in which case the appropriate flag is set in the FILE structure.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fgetchar (
	void
	)
{
	return(getc(stdin));
}

#undef getchar

int __cdecl getchar (
	void
	)
{
	return _fgetchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgets.c ===
/***
*fgets.c - get string from a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgets() - read a string from a file
*
*Revision History:
*       09-02-83  RN    initial version
*       04-16-87  JCR   changed count from an unsigned int to an int (ANSI)
*                       and modified comparisons accordingly
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and added #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       10-01-93  CFW   Enable for fgetws().
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*char *fgets(string, count, stream) - input string from a stream
*
*Purpose:
*       get a string, up to count-1 chars or '\n', whichever comes first,
*       append '\0' and put the whole thing into string. the '\n' IS included
*       in the string. if count<=1 no input is requested. if EOF is found
*       immediately, return NULL. if EOF found after chars read, let EOF
*       finish the string as '\n' would.
*
*Entry:
*       char *string - pointer to place to store string
*       int count - max characters to place at string (include \0)
*       FILE *stream - stream to read from
*
*Exit:
*       returns string with text read from file in it.
*       if count <= 0 return NULL
*       if count == 1 put null string in string
*       returns NULL if error or end-of-file found immediately
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * __cdecl fgetws (
#else
char * __cdecl fgets (
#endif
        _TSCHAR *string,
        int count,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 _TSCHAR *pointer = string;
        _TSCHAR *retval = string;
        int ch;

        _ASSERTE(string != NULL);
        _ASSERTE(str != NULL);

        if (count <= 0)
                return(NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (--count)
        {
#ifdef _UNICODE
                if ((ch = _getwc_lk(stream)) == WEOF)
#else
                if ((ch = _getc_lk(stream)) == EOF)
#endif               
                {
                        if (pointer == string) {
                                retval=NULL;
                                goto done;
                        }

                        break;
                }

                if ((*pointer++ = (_TSCHAR)ch) == _T('\n'))
                        break;
        }

        *pointer = _T('\0');

/* Common return */
done:

#ifdef  _MT
        ; }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgetwc.c ===
/***
*fgetwc.c - get a wide character from a stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetwc() - read a wide character from a stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       04-30-93  CFW   Bring wide char support from fgetc.c.
*       05-03-93  CFW   Add getwc function.
*       05-10-93  CFW   Optimize, fix error handling.
*       06-02-93  CFW   Wide get/put use wint_t.
*       09-14-93  CFW   Fix EOF cast bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-01-93  CFW   Test only for TEXT.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       10-28-93  CFW   Test for both IOSTRG and TEXT.
*       02-07-94  CFW   POSIXify.
*       08-31-94  CFW   Fix for "C" locale, call mbtowc().
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       04-18-97  JWM   Explicit cast added to avoid new C4242 warnings.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <tchar.h>
#include <setlocal.h>

#ifdef _MT      /* multi-thread; define both fgetwc and _getwc_lk */

/***
*wint_t fgetwc(stream) - read a wide character from a stream
*
*Purpose:
*       reads a wide character from the given stream
*
*Entry:
*       FILE *stream - stream to read wide character from
*
*Exit:
*       returns the wide character read
*       returns WEOF if at end of file or error occurred
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl fgetwc (
        REG1 FILE *stream
        )
{
        wint_t retval;

        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _getwc_lk(stream);

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}

/***
*_getwc_lk() -  getwc() core routine (locked version)
*
*Purpose:
*       Core getwc() routine; assumes stream is already locked.
*
*       [See getwc() above for more info.]
*
*Entry: [See getwc()]
*
*Exit:  [See getwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _getwc_lk (
        REG1 FILE *stream
        )
{

#else   /* non multi-thread; just define fgetwc */

wint_t __cdecl fgetwc (
        REG1 FILE *stream
        )
{

#endif  /* rejoin common code */

#ifndef _NTSUBSET_
        if (!(stream->_flag & _IOSTRG) && (_osfile_safe(_fileno(stream)) & 
              FTEXT))
        {
                int size = 1;
                int ch;
                char mbc[4];
                wchar_t wch;
                
                /* text (multi-byte) mode */
                if ((ch = _getc_lk(stream)) == EOF)
                        return WEOF;

                mbc[0] = (char)ch;

                if (isleadbyte((unsigned char)mbc[0]))
                {
                        if ((ch = _getc_lk(stream)) == EOF)
                        {
                                ungetc(mbc[0], stream);
                                return WEOF;
                        }
                        mbc[1] = (char)ch;
                        size = 2;
                }
                if (mbtowc(&wch, mbc, size) == -1)
                {
                        /*
                         * Conversion failed! Set errno and return
                         * failure.
                         */
                        errno = EILSEQ;
                        return WEOF;
                }
                return wch;
        }
#endif
        /* binary (Unicode) mode */
        if ((stream->_cnt -= sizeof(wchar_t)) >= 0)
                return *((wchar_t *)(stream->_ptr))++;
        else
                return (wint_t) _filwbuf(stream);
}

#undef getwc

wint_t __cdecl getwc (
        FILE *stream
        )
{
        return fgetwc(stream);
}


#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgetpos.c ===
/***
*fgetpos.c - Contains the fgetpos runtime
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Get file position (in an internal format).
*
*Revision History:
*       01-16-87  JCR   Module created.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-15-90  GJF   Fixed copyright and indents
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-23-94  GJF   Use 64-bit file position (_ftelli64) for non-_MAC_.
*       01-05-94  GJF   Temporarily commented out above change due to MFC/IDE
*                       bugs.
*       01-24-95  GJF   Restored 64-bit fpos_t support.
*       06-28-96  SKS   Enable 64-bit fpos_t support for the MAC
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/***
*int fgetpos(stream,pos) - Get file position (internal format)
*
*Purpose:
*       Fgetpos gets the current file position for the file identified by
*       [stream].  The file position is returned in the object pointed to
*       by [pos] and is in internal format; that is, the user is not supposed
*       to interpret the value but simply use it in the fsetpos call.  Our
*       implementation simply uses fseek/ftell.
*
*Entry:
*       FILE *stream = pointer to a file stream value
*       fpos_t *pos = pointer to a file position value
*
*Exit:
*       Successful fgetpos call returns 0.
*       Unsuccessful fgetpos call returns non-zero (!0) value and sets
*       ERRNO (this is done by ftell and passed back by fgetpos).
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl fgetpos (
        FILE *stream,
        fpos_t *pos
        )
{
#ifdef _POSIX_
        if ( (*pos = ftell(stream)) != -1L )
#else
        if ( (*pos = _ftelli64(stream)) != -1i64 )
#endif
                return(0);
        else
                return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgetwchr.c ===
/***
*fgetwchr.c - get a wide character from stdin
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fgetwchar() and getwchar() - read a wide character from stdin
*
*Revision History:
*	04-26-93  CFW	Module created.
*	05-03-93  CFW	Bring wide char support from fgetwchr.c.
*	06-02-93  CFW	Wide get/put use wint_t.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <tchar.h>

/***
*wint_t _fgetwchar(), getwchar() - read a wide character from stdin
*
*Purpose:
*	Reads the next wide character from stdin.  Function version of
*	getwchar() macro.
*
*Entry:
*	None.
*
*Exit:
*	Returns wide character read or WEOF if at end-of-file or an error occured,
*	in which case the appropriate flag is set in the FILE structure.
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fgetwchar (
	void
	)
{
	return(getwc(stdin));
}

#undef getwchar

wint_t __cdecl getwchar (
	void
	)
{
	return(_fgetwchar());
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\files.c ===
/* Initial Version of FILES.C -- Users can recompile this file to increase
 * (or decrease) the number of low-level I/O file handles or standard I/O
 * (stdio) FILE * streams available when linking with LIBC.LIB or LIBCMT.LIB.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fgetws.c ===
/***
*fgetws.c - get wide string from a file
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines fgetws() - read a wide string from a file
*
*Revision History:
*	04-26-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

/***
*wchar_t *fgetws(string, count, stream) - input string from a stream
*
*Purpose:
*	get a string, up to count-1 wide chars or L'\n', whichever comes first,
*	append L'\0' and put the whole thing into string. the L'\n' IS included
*	in the string. if count<=1 no input is requested. if WEOF is found
*	immediately, return NULL. if WEOF found after chars read, let WEOF
*	finish the string as L'\n' would.
*
*Entry:
*	wchar_t *string - pointer to place to store string
*	int count - max characters to place at string (include \0)
*	FILE *stream - stream to read from
*
*Exit:
*	returns wide string with text read from file in it.
*	if count <= 0 return NULL
*	if count == 1 put null string in string
*	returns NULL if error or end-of-file found immediately
*
*Exceptions:
*
*******************************************************************************/

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "fgets.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fileno.c ===
/***
*fileno.c - defines _fileno()
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines fileno() - return the file handle for the specified stream
*
*Revision History:
*	03-13-89  GJF	Module created
*	03-27-89  GJF	Moved to 386 tree
*	02-15-90  GJF	_file is now an int. Also, fixed copyright.
*	03-19-90  GJF	Made calling type _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-02-90  GJF	New-style function declarator.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/* remove macro definition for fileno()
 */
#undef	_fileno

/***
*int _fileno(stream) - return the file handle for stream
*
*Purpose:
*	Returns the file handle for the given stream is. Normally fileno()
*	is a macro, but it is also available as a true function (for
*	consistency with ANSI, though it is not required).
*
*Entry:
*	FILE *stream - stream to fetch handle for
*
*Exit:
*	returns the file handle for the given stream
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fileno (
	FILE *stream
	)
{
	return( stream->_file );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fopen.c ===
/***
*fopen.c - open a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fopen() and _fsopen() - open a file as a stream and open a file
*       with a specified sharing mode as a stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declarations
*       11-01-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       11-14-88  GJF   Added _fsopen().
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       03-26-92  DJM   POSIX support
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*       10-06-99  PML   Set errno EMFILE when out of streams.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <share.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <file2.h>
#include <tchar.h>
#include <errno.h>

/***
*FILE *_fsopen(file, mode, shflag) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode. shflag determines the
*       sharing mode. Values are the same as for sopen().
*
*Entry:
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns pointer to stream
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfsopen (
        const _TSCHAR *file,
        const _TSCHAR *mode
#ifndef _POSIX_
        ,int shflag
#endif
        )
{
        REG1 FILE *stream;
        REG2 FILE *retval;

        _ASSERTE(file != NULL);
        _ASSERTE(*file != _T('\0'));
        _ASSERTE(mode != NULL);
        _ASSERTE(*mode != _T('\0'));

        /* Get a free stream */
        /* [NOTE: _getstream() returns a locked stream.] */

        if ((stream = _getstream()) == NULL) {
                errno = EMFILE;
                return(NULL);
        }

#ifdef  _MT
        __try {
#endif

        /* open the stream */
#ifdef _POSIX_
#ifdef _UNICODE
        retval = _wopenfile(file,mode, stream);
#else
        retval = _openfile(file,mode, stream);
#endif
#else
#ifdef _UNICODE
        retval = _wopenfile(file,mode,shflag,stream);
#else
        retval = _openfile(file,mode,shflag,stream);
#endif
#endif

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}

  
/***
*FILE *fopen(file, mode) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode
*
*Entry:
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns pointer to stream
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfopen (
        const _TSCHAR *file,
        const _TSCHAR *mode
        )
{
#ifdef _POSIX_
        return( _tfsopen(file, mode) );
#else
        return( _tfsopen(file, mode, _SH_DENYNO) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fputs.c ===
/***
*fputs.c - write a string to a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputs() - writes a string to a stream
*
*Revision History:
*       09-02-83  RN    initial version
*       08-31-84  RN    modified to use the new, fast fwrite.
*       04-13-87  JCR   added const to declaration
*       06-30-87  JCR   made fputs return values conform to ANSI [MSC only]
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-18-88  JCR   Error return = EOF
*       05-27-88  PHG   Merged DLL and normal versions
*       09-22-88  GJF   Include internal.h to get prototypes for _[s|f]tbuf()
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <string.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fputs(string, stream) - write a string to a file
*
*Purpose:
*       Output the given string to the stream, don't write the '\0' or
*       supply a '\n'.  Uses _stbuf and _ftbuf for efficiency reasons.
*
*Entry:
*       char *string - string to write
*       FILE *stream - stream to write to.
*
*Exit:
*       Good return   = 0
*       Error return  = EOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputs (
        const char *string,
        FILE *stream
        )
{
        REG2 int buffing;
        REG1 size_t length;
        REG3 size_t ndone;

        _ASSERTE(string != NULL);
        _ASSERTE(stream != NULL);

        length = strlen(string);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        ndone = _fwrite_lk(string,1,length,stream);
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(ndone == length ? 0 : EOF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fprintf.c ===
/***
*fprintf.c - print formatted data to stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fprintf() - print formatted data to stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-05-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fprintf(stream, format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on the given using the format string to
*       format data and getting as many arguments as called for
*       _output does the real work here
*
*Entry:
*       FILE *stream - stream to print on
*       char *format - format string to control data format/number of arguments
*       followed by arguments to print, number and type controlled by
*       format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fprintf (
        FILE *str,
        const char *format,
        ...
        )
/*
 * 'F'ile (stream) 'PRINT', 'F'ormatted
 */
{
        va_list(arglist);
        REG1 FILE *stream;
        REG2 int buffing;
        int retval;

        va_start(arglist, format);

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _output(stream,format,arglist);
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fputc.c ===
/***
*fputc.c - write a character to an output stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputc() - writes a character to a stream
*       defines fputwc() - writes a wide character to a stream
*
*Revision History:
*       09-01-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       06-21-89  PHG   Added putc() function
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   Fixed copyright and indents.
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       04-30-93  CFW   Remove wide char support to fputwc.c.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-20-97  GJF   Removed unnecessary local from fputc(). Made putc() 
*                       identical to fputc(). Also, detab-ed.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fputc(ch, stream) - write a character to a stream
*
*Purpose:
*       Writes a character to a stream.  Function version of putc().
*
*Entry:
*       int ch - character to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the character if successful
*       returns EOF if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputc (
        int ch,
        FILE *str
        )
{
        int retval;

        _ASSERTE(str != NULL);

#ifdef  _MT
        _lock_str(str);
        __try {
#endif

        retval = _putc_lk(ch,str);

#ifdef  _MT
        }
        __finally {
            _unlock_str(str);
        }
#endif

        return(retval);
}

#undef putc

int __cdecl putc (
        int ch,
        FILE *str
        )
{
        int retval;

        _ASSERTE(str != NULL);

#ifdef  _MT
        _lock_str(str);
        __try {
#endif

        retval = _putc_lk(ch,str);

#ifdef  _MT
        }
        __finally {
            _unlock_str(str);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fputwchr.c ===
/***
*fputwchr.c - write a wide character to stdout
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fputwchar(), putwchar() - write a wide character to stdout,
*	function version
*
*Revision History:
*	04-26-93  CFW	Module created.
*	04-30-93  CFW	Bring wide char support from fputchar.c.
*	06-02-93  CFW	Wide get/put use wint_t.
*       02-07-94  CFW   POSIXify.
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <tchar.h>

/***
*wint_t _fputwchar(ch), putwchar() - put a wide character to stdout
*
*Purpose:
*	Puts the given wide character to stdout.  Function version of macro
*	putwchar().
*
*Entry:
*	wchar_t ch - character to output
*
*Exit:
*	returns character written if successful
*	returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fputwchar (
	REG1 wchar_t ch
	)
{
	return(putwc(ch, stdout));
}

#undef putwchar

wint_t __cdecl putwchar (
	REG1 wchar_t ch
	)
{
	return(_fputwchar(ch));
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fputchar.c ===
/***
*fputchar.c - write a character to stdout
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fputchar(), putchar() - write a character to stdout, function version
*	defines _fputwchar(), putwchar() - write a wide character to stdout, function version
*
*Revision History:
*	11-30-83  RN	initial version
*	11-09-87  JCR	Multi-thread support
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-31-88  PHG	Merged DLL and normal versions
*	06-21-89  PHG	Added putchar() function
*	02-15-90  GJF	Fixed copyright and indents
*	03-19-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h> and removed #include <register.h>.
*	10-02-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	04-26-93  CFW	Wide char enable.
*	04-30-93  CFW	Move wide char support to fputwchr.c.
*	03-15-95  GJF	Deleted #include <tchar.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/***
*int _fputchar(ch), putchar() - put a character to stdout
*
*Purpose:
*	Puts the given characters to stdout.  Function version of macro
*	putchar().
*
*Entry:
*	int ch - character to output
*
*Exit:
*	returns character written if successful
*	returns EOF if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fputchar (
	REG1 int ch
	)
{
	return(putc(ch, stdout));
}

#undef putchar

int __cdecl putchar (
	int ch
	)
{
	return _fputchar(ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fputws.c ===
/***
*fputws.c - write a string to a stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputws() - writes a string to a stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <file2.h>
#include <internal.h>
#include <stdio.h>
#include <mtdll.h>
#include <tchar.h>
#include <wchar.h>
#include <dbgint.h>

/***
*int fputws(string, stream) - write a string to a file
*
*Purpose:
*       Output the given string to the stream, don't write the L'\0' or
*       supply a L'\n'. Uses _stbuf and _ftbuf for efficiency reasons.
*
*Entry:
*       wchar_t *string - string to write
*       FILE *stream - stream to write to.
*
*Exit:
*       Good return   = 0
*       Error return  = WEOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputws (
        const wchar_t *string,
        FILE *stream
        )
{
        size_t length;
        int retval = 0;

        _ASSERTE(string != NULL);
        _ASSERTE(stream != NULL);

        length = wcslen(string);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (length--)
        {
            if (_putwc_lk(*string++, stream) == WEOF)
            {
                retval = -1;
                break;
            }
        }

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fputwc.c ===
/***
*fputwc.c - write a wide character to an output stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputwc() - writes a wide character to a stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       04-30-93  CFW   Bring wide char support from fputc.c.
*       05-03-93  CFW   Add putwc function.
*       05-10-93  CFW   Optimize, fix error handling.
*       06-02-93  CFW   Wide get/put use wint_t.
*       07-16-93  SRW   ALPHA Merge
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-01-93  CFW   Test only for TEXT.
*       10-28-93  CFW   Test for both IOSTRG and TEXT.
*       11-05-93  GJF   Merged with NT SDK version (fix to a cast expr).
*       02-07-94  CFW   POSIXify.
*       08-31-94  CFW   Fix for "C" locale, call wctomb().
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       04-18-97  JWM   Explicit cast added to avoid new C4242 warnings.
*       02-27-98  GJF   Exception-safe locking.
*       12-16-99  GB    Modified for the case when return value from wctomb is
*                       greater then 2.
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <tchar.h>
#include <setlocal.h>

#ifdef  _MT     /* multi-thread; define both fputwc and _putwc_lk */

/***
*wint_t fputwc(ch, stream) - write a wide character to a stream
*
*Purpose:
*       Writes a wide character to a stream.  Function version of putwc().
*
*Entry:
*       wchar_t ch - wide character to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the wide character if successful
*       returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl fputwc (
        wchar_t ch,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 wint_t retval;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _putwc_lk(ch,stream);

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}

/***
*_putwc_lk() -  putwc() core routine (locked version)
*
*Purpose:
*       Core putwc() routine; assumes stream is already locked.
*
*       [See putwc() above for more info.]
*
*Entry: [See putwc()]
*
*Exit:  [See putwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _putwc_lk (
        wchar_t ch,
        FILE *str
        )
{

#else   /* non multi-thread; just define fputwc */

wint_t __cdecl fputwc (
        wchar_t ch,
        FILE *str
        )
{

#endif  /* rejoin common code */

#ifndef _NTSUBSET_
        if (!(str->_flag & _IOSTRG) && (_osfile_safe(_fileno(str)) & FTEXT))
        {
                int size, i;
                char mbc[MB_LEN_MAX];
        
                /* text (multi-byte) mode */
                if ((size = wctomb(mbc, ch)) == -1)
                {
                        /*
                         * Conversion failed! Set errno and return
                         * failure.
                         */
                        errno = EILSEQ;
                        return WEOF;
                }
                for ( i = 0; i < size; i++)
                {
                        if (_putc_lk(mbc[i], str) == EOF)
                                return WEOF;
                }
                return (wint_t)(0xffff & ch);
        }
#endif
        /* binary (Unicode) mode */
        if ( (str->_cnt -= sizeof(wchar_t)) >= 0 )
                return (wint_t) (0xffff & (*((wchar_t *)(str->_ptr))++ = (wchar_t)ch));
        else
                return (wint_t) _flswbuf(ch, str);
}

#undef putwc

wint_t __cdecl putwc (
        wchar_t ch,
        FILE *str
        )
{
        return fputwc(ch, str);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fseeki64.c ===
/***
*fseeki64.c - reposition file pointer on a stream
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fseeki64() - move the file pointer to new place in file
*
*Revision History:
*       12-15-94  GJF   Module created. Derived from fseek.c.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <io.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _fseeki64(stream, offset, whence) - reposition file pointer
*
*Purpose:
*
*       Reposition file pointer to the desired location.  The new location
*       is calculated as follows:
*                                { whence=0, beginning of file }
*               <offset> bytes + { whence=1, current position  }
*                                { whence=2, end of file       }
*
*       Be careful to coordinate with buffering.
*
*Entry:
*       FILE *stream  - file to reposition file pointer on
*       _int64 offset - offset to seek to
*       int whence    - origin offset is measured from (0=beg, 1=current pos,
*                       2=end)
*
*Exit:
*       returns 0 if succeeds
*       returns -1 and sets errno if fails
*       fields of FILE struct will be changed
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _MT     /* multi-thread; define both fseek() and _lk_fseek() */

int __cdecl _fseeki64 (
        FILE *stream,
        __int64 offset,
        int whence
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _fseeki64_lk (stream, offset, whence);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_fseeki64_lk() - Core _fseeki64() routine (stream is locked)
*
*Purpose:
*       Core _fseeki64() routine; assumes that caller has the stream locked.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fseeki64_lk (

#else   /* non multi-thread; just define fseek() */

int __cdecl _fseeki64 (

#endif  /* rejoin common code */

        FILE *str,
        __int64 offset,
        int whence
        )
{


        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

        if ( !inuse(stream) || ((whence != SEEK_SET) && (whence != SEEK_CUR) &&
            (whence != SEEK_END)) ) {
                errno=EINVAL;
                return(-1);
        }

        /* Clear EOF flag */

        stream->_flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if (whence == SEEK_CUR) {
                offset += _ftelli64_lk(stream);
                whence = SEEK_SET;
        }

        /* Flush buffer as necessary */

        _flush(stream);

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next _filbuf
           won't cost quite so much */

        if (stream->_flag & _IORW)
                stream->_flag &= ~(_IOWRT|_IOREAD);
        else if ( (stream->_flag & _IOREAD) && (stream->_flag & _IOMYBUF) &&
                  !(stream->_flag & _IOSETVBUF) )
                stream->_bufsiz = _SMALL_BUFSIZ;

        /* Seek to the desired locale and return. */

        return(_lseeki64(_fileno(stream), offset, whence) == -1i64 ? -1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\freopen.c ===
/***
*freopen.c - close a stream and assign it to a new file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines freopen() - close and reopen file, typically used to redirect
*       stdin/out/err/prn/aux.
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declarations
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       11-14-88  GJF   _openfile() now takes a file sharing flag, also some
*                       cleanup (now specific to the 386)
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant.
*       01-17-94  GJF   Ignore possible failure of _fclose_lk (ANSI 4.9.5.4)
*       04-11-94  CFW   Remove unused 'done' label to avoid warnings.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <share.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*FILE *freopen(filename, mode, stream) - reopen stream as new file
*
*Purpose:
*       Closes the file associated with stream and assigns stream to a new
*       file with current mode.  Usually used to redirect a standard file
*       handle.
*
*Entry:
*       char *filename - new file to open
*       char *mode - new file mode, as in fopen()
*       FILE *stream - stream to close and reassign
*
*Exit:
*       returns stream if successful
*       return NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfreopen (
        const _TSCHAR *filename,
        const _TSCHAR *mode,
        FILE *str
        )
{
        REG1 FILE *stream;
        FILE *retval;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(mode != NULL);
        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        /* If the stream is in use, try to close it. Ignore possible
         * error (ANSI 4.9.5.4). */
        if ( inuse(stream) )
                _fclose_lk(stream);

        stream->_ptr = stream->_base = NULL;
        stream->_cnt = stream->_flag = 0;
#ifdef _POSIX_
#ifdef _UNICODE
        retval = _wopenfile(filename,mode,stream);
#else
        retval = _openfile(filename,mode,stream);
#endif
#else
#ifdef _UNICODE
        retval = _wopenfile(filename,mode,_SH_DENYNO,stream);
#else
        retval = _openfile(filename,mode,_SH_DENYNO,stream);
#endif
#endif

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fread.c ===
/***
*fread.c - read from a stream
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Read from the specified stream into the user's buffer.
*
*Revision History:
*       06-23-89  PHG   Module created, based on asm version
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-19-90  GJF   Made calling type _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       06-22-92  GJF   Must return 0 if EITHER size-of-item or number-of-
*                       item arguments is 0 (TNT Bug #523)
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       10-22-93  GJF   Fix divide-by-0 error in unbuffered case. Also,
*                       replaced MTHREAD with _MT.
*       12-30-94  GJF   _MAC_ merge.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <mtdll.h>
#include <io.h>
#include <string.h>
#include <file2.h>

/***
*size_t fread(void *buffer, size_t size, size_t count, FILE *stream) -
*       read from specified stream into the specified buffer.
*
*Purpose:
*       Read 'count' items of size 'size' from the specified stream into
*       the specified buffer. Return when 'count' items have been read in
*       or no more items can be read from the stream.
*
*Entry:
*       buffer  - pointer to user's buffer
*       size    - size of the item to read in
*       count   - number of items to read
*       stream  - stream to read from
*
*Exit:
*       Returns the number of (whole) items that were read into the buffer.
*       This may be less than 'count' if an error or eof occurred. In this
*       case, ferror() or feof() should be used to distinguish between the
*       two conditions.
*
*Notes:
*       fread will attempt to buffer the stream (side effect of the _filbuf
*       call) if necessary.
*
*       No more than 0xFFFE bytes may be read in at a time by a call to
*       read(). Further, read() does not handle huge buffers. Therefore,
*       in large data models, the read request is broken down into chunks
*       that do not violate these considerations. Each of these chunks is
*       processed much like an fread() call in a small data model (by a
*       call to _nfread()).
*
*       MTHREAD/DLL - Handled in three layers. fread() handles the locking
*       and DS saving/loading/restoring (if required) and calls _fread_lk()
*       to do the work. _fread_lk() is the same as the single-thread,
*       large data model version of fread(). It breaks up the read request
*       into digestible chunks and calls _nfread() to do the actual work.
*
*       386/MTHREAD/DLL - Handled in just the two layers since it is small
*       data model. The outer layer, fread(), takes care of the stream locking
*       and calls _fread_lk() to do the actual work. _fread_lk() is the same
*       as the single-thread version of fread().
*
*******************************************************************************/


#ifdef  _MT
/* define locking/unlocking version */
size_t __cdecl fread (
        void *buffer,
        size_t size,
        size_t count,
        FILE *stream
        )
{
        size_t retval;

        _lock_str(stream);              /* lock stream */
        __try {
                /* do the read */
                retval = _fread_lk(buffer, size, count, stream);
        }
        __finally {
                _unlock_str(stream);    /* unlock stream */
        }

        return retval;
}
#endif

/* define the normal version */
#ifdef  _MT
size_t __cdecl _fread_lk (
#else
size_t __cdecl fread (
#endif
        void *buffer,
        size_t size,
        size_t num,
        FILE *stream
        )
{
        char *data;                     /* point to where should be read next */
        size_t total;                   /* total bytes to read */
        size_t count;                   /* num bytes left to read */
        unsigned bufsize;               /* size of stream buffer */
        unsigned nbytes;                /* how much to read now */
        unsigned nread;                 /* how much we did read */
        int c;                          /* a temp char */

        /* initialize local vars */
        data = buffer;

        if ( (count = total = size * num) == 0 )
                return 0;

        if (anybuf(stream))
                /* already has buffer, use its size */
                bufsize = stream->_bufsiz;
        else
                /* assume will get _INTERNAL_BUFSIZ buffer */
                bufsize = _INTERNAL_BUFSIZ;

        /* here is the main loop -- we go through here until we're done */
        while (count != 0) {
                /* if the buffer exists and has characters, copy them to user
                   buffer */
                if (anybuf(stream) && stream->_cnt != 0) {
                        /* how much do we want? */
                        nbytes = (count < (size_t)stream->_cnt) ? (unsigned)count : stream->_cnt;
                        memcpy(data, stream->_ptr, nbytes);

                        /* update stream and amt of data read */
                        count -= nbytes;
                        stream->_cnt -= nbytes;
                        stream->_ptr += nbytes;
                        data += nbytes;
                }
                else if (count >= bufsize) {
                        /* If we have more than bufsize chars to read, get data
                           by calling read with an integral number of bufsiz
                           blocks.  Note that if the stream is text mode, read
                           will return less chars than we ordered. */

                        /* calc chars to read -- (count/bufsize) * bufsize */
                        nbytes = ( bufsize ? (unsigned)(count - count % bufsize) :
                                   (unsigned)count );

#ifdef  _POSIX_
                        nread = read(fileno(stream), data, nbytes);
#else
                        nread = _read(_fileno(stream), data, nbytes);
#endif
                        if (nread == 0) {
                                /* end of file -- out of here */
                                stream->_flag |= _IOEOF;
                                return (total - count) / size;
                        }
                        else if (nread == (unsigned)-1) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }

                        /* update count and data to reflect read */
                        count -= nread;
                        data += nread;
                }
                else {
                        /* less than bufsize chars to read, so call _filbuf to
                           fill buffer */
                        if ((c = _filbuf(stream)) == EOF) {
                                /* error or eof, stream flags set by _filbuf */
                                return (total - count) / size;
                        }

                        /* _filbuf returned a char -- store it */
                        *data++ = (char) c;
                        --count;

                        /* update buffer size */
                        bufsize = stream->_bufsiz;
                }
        }

        /* we finished successfully, so just return num */
        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fsetpos.c ===
/***
*fsetpos.c - Contains fsetpos runtime
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Fsetpos sets the file position using an internal value returned by an
*       earlier fgetpos call.
*
*Revision History:
*       01-16-87  JCR   Module created
*       04-13-87  JCR   Added const to declaration
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-23-94  GJF   Use 64-bit file position (_fseeki64) for non-_MAC_.
*       01-05-94  GJF   Temporarily commented out above change due to MFC/IDE
*                       bugs.
*       01-24-95  GJF   Restored 64-bit fpos_t support.
*       06-28-96  SKS   Enable 64-bit fpos_t support for the MAC
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/***
*int fsetpos(stream,pos) - Set file positioning
*
*Purpose:
*       Fsetpos sets the file position for the file indicated by [stream] to
*       the position indicated by [pos].  The [pos] value is defined to be in
*       an internal format (not to be interpreted by the user) and has been
*       generated by an earlier fgetpos call.
*
*Entry:
*       FILE *stream = pointer to a file stream value
*       fpos_t *pos = pointer to a file positioning value
*
*Exit:
*       Successful call returns 0.
*       Unsuccessful call returns non-zero (!0).
*
*Exceptions:
*       None.
*******************************************************************************/

int __cdecl fsetpos (
        FILE *stream,
        const fpos_t *pos
        )
{
#ifdef _POSIX_
        return( fseek(stream, *pos, SEEK_SET) );
#else
        return( _fseeki64(stream, *pos, SEEK_SET) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fscanf.c ===
/***
*fscanf.c - read formatted data from stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fscanf() - reads formatted data from stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE2 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Added #include <internal.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       Reads formatted data from stream into arguments.  _input does the real
*       work here.
*
*Entry:
*       FILE *stream - stream to read data from
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fscanf (
        FILE *stream,
        const char *format,
        ...
        )
/*
 * 'F'ile (stream) 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

        va_start(arglist, format);

        _ASSERTE(stream != NULL);
        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = (_input(stream,format,arglist));

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\ftelli64.c ===
/***
*ftelli64.c - get current file position
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _ftelli64() - find current current position of file pointer
*
*Revision History:
*       12-22-94  GJF   Module created. Derived from ftell.c
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-23-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       03-02-98  GJF   Exception-safe locking.
*       03-04-98  RKP   Added 64 bit support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <errno.h>
#include <msdos.h>
#include <stddef.h>
#include <io.h>
#include <internal.h>
#include <mtdll.h>

/***
*__int64 _ftelli64(stream) - query stream file pointer
*
*Purpose:
*       Find out what stream's position is. coordinate with buffering; adjust
*       backward for read-ahead and forward for write-behind. This is NOT
*       equivalent to fseek(stream,0L,1), because fseek will remove an ungetc,
*       may flush buffers, etc.
*
*Entry:
*       FILE *stream - stream to query for position
*
*Exit:
*       return present file position if succeeds
*       returns -1i64 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT

__int64 __cdecl _ftelli64 (
        FILE *stream
        )
{
        __int64 retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
               retval = _ftelli64_lk (stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_ftelli64_lk() - _ftelli64() core routine (assumes stream is locked).
*
*Purpose:
*       Core _ftelli64() routine (assumes caller has aquired stream lock).
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

__int64 __cdecl _ftelli64_lk (

#else   /* mdef _MT */

__int64 __cdecl _ftelli64 (

#endif  /* _MT */

        FILE *str
        )
{
        REG1 FILE *stream;
        size_t offset;
        __int64 filepos;
        REG2 char *p;
        char *max;
        int fd;
        size_t rdcnt;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;
        fd = _fileno(stream);

        if (stream->_cnt < 0)
                stream->_cnt = 0;

        if ((filepos = _lseeki64(fd, 0i64, SEEK_CUR)) < 0L)
                return(-1i64);

        if (!bigbuf(stream))            /* _IONBF or no buffering designated */
                return(filepos - stream->_cnt);

        offset = (size_t)(stream->_ptr - stream->_base);

        if (stream->_flag & (_IOWRT|_IOREAD)) {
                if (_osfile(fd) & FTEXT)
                        for (p = stream->_base; p < stream->_ptr; p++)
                                if (*p == '\n')  /* adjust for '\r' */
                                        offset++;
        }
        else if (!(stream->_flag & _IORW)) {
                errno=EINVAL;
                return(-1i64);
        }

        if (filepos == 0i64)
                return((__int64)offset);

        if (stream->_flag & _IOREAD)    /* go to preceding sector */

                if (stream->_cnt == 0)  /* filepos holds correct location */
                        offset = 0;

                else {

                        /* Subtract out the number of unread bytes left in the
                           buffer. [We can't simply use _iob[]._bufsiz because
                           the last read may have hit EOF and, thus, the buffer
                           was not completely filled.] */

                        rdcnt = stream->_cnt + (size_t)(stream->_ptr - stream->_base);

                        /* If text mode, adjust for the cr/lf substitution. If
                           binary mode, we're outta here. */
                        if (_osfile(fd) & FTEXT) {
                                /* (1) If we're not at eof, simply copy _bufsiz
                                   onto rdcnt to get the # of untranslated
                                   chars read. (2) If we're at eof, we must
                                   look through the buffer expanding the '\n'
                                   chars one at a time. */

                                /* [NOTE: Performance issue -- it is faster to
                                   do the two _lseek() calls than to blindly go
                                   through and expand the '\n' chars regardless
                                   of whether we're at eof or not.] */

                                if (_lseeki64(fd, 0i64, SEEK_END) == filepos) {

                                        max = stream->_base + rdcnt;
                                        for (p = stream->_base; p < max; p++)
                                                if (*p == '\n')
                                                        /* adjust for '\r' */
                                                        rdcnt++;

                                        /* If last byte was ^Z, the lowio read
                                           didn't tell us about it.  Check flag
                                           and bump count, if necessary. */

                                        if (stream->_flag & _IOCTRLZ)
                                                ++rdcnt;
                                }

                                else {

                                        _lseeki64(fd, filepos, SEEK_SET);

                                        /* We want to set rdcnt to the number
                                           of bytes originally read into the
                                           stream buffer (before crlf->lf
                                           translation). In most cases, this
                                           will just be _bufsiz. However, the
                                           buffer size may have been changed,
                                           due to fseek optimization, at the
                                           END of the last _filbuf call. */

                                        if ( (rdcnt <= _SMALL_BUFSIZ) &&
                                             (stream->_flag & _IOMYBUF) &&
                                             !(stream->_flag & _IOSETVBUF) )
                                        {
                                                /* The translated contents of
                                                   the buffer is small and we
                                                   are not at eof. The buffer
                                                   size must have been set to
                                                   _SMALL_BUFSIZ during the
                                                   last _filbuf call. */

                                                rdcnt = _SMALL_BUFSIZ;
                                        }
                                        else
                                                rdcnt = stream->_bufsiz;


                                        /* If first byte in untranslated buffer
                                           was a '\n', assume it was preceeded
                                           by a '\r' which was discarded by the
                                           previous read operation and count
                                           the '\n'. */
                                        if  (_osfile(fd) & FCRLF)
                                                ++rdcnt;
                                }

                        } /* end if FTEXT */

                        filepos -= (__int64)rdcnt;

                } /* end else stream->_cnt != 0 */

        return(filepos + (__int64)offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fseek.c ===
/***
*fseek.c - reposition file pointer on a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fseek() - move the file pointer to new place in file
*
*Revision History:
*       10-13-83  RN    initial version
*       06-26-85  TC    added code to allow variable buffer lengths
*       02-10-87  BCM   fixed '%' mistakenly used for '/'
*       03-04-87  JCR   added errno settings
*       04-16-87  JCR   added _IOUNGETC support for bug fix and changes whence
*                       from unsigned int to int (ANSI conformance)
*       04-17-87  JCR   fseek() now clears end-of-file indicator flag _IOEOF
*                       (for ANSI conformance)
*       04-21-87  JCR   be smart about lseek'ing to the end of the file and
*                       back
*       09-17-87  SKS   handle case of '\n' at beginning of buffer (FCRLF flag)
*       09-24-87  JCR   fixed an incorrect access to flag _IOEOF
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       09-30-87  JCR   Fixed buffer allocation bug, now use _getbuf()
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       03-04-88  JCR   Return value from read() must be treated as unsigned
*                       value
*       05-27-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2[] references
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       12-02-88  JCR   Added _IOCTRLZ support (fixes bug pertaining to ^Z at
*                       eof)
*       04-12-89  JCR   Ripped out all of the special read-only code.  See the
*                       comments in the routine header for more information.
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-08-92  GJF   Use seek method constants!
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-24-93  GJF   If the stream was opened for read-access-only, reduce
*                       _bufsiz after flushing the stream. This should reduce
*                       the expense of the next _filbuf call, and the overall
*                       burden of seek-and-do-small-reads patterns of file
*                       input.
*       06-22-93  GJF   Check _flag for _IOSETVBUF (new) before changing
*                       buffer size.
*       11-05-93  GJF   Merged with NT SDK version. Also, replaced MTHREAD
*                       with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#endif
#include <errno.h>
#include <malloc.h>
#include <io.h>
#include <stddef.h>
#include <internal.h>
#ifndef _POSIX_
#include <mtdll.h>
#endif

/***
*int fseek(stream, offset, whence) - reposition file pointer
*
*Purpose:
*
*       Reposition file pointer to the desired location.  The new location
*       is calculated as follows:
*                                { whence=0, beginning of file }
*               <offset> bytes + { whence=1, current position  }
*                                { whence=2, end of file       }
*
*       Be careful to coordinate with buffering.
*
*                       - - - - - - - - - - - - -
*
*       [NOTE: We used to bend over backwards to try and preserve the current
*       buffer and maintain disk block alignment.  This ended up making our
*       code big and slow and complicated, and slowed us down quite a bit.
*       Some of the things pertinent to the old implimentation:
*
*       (1) Read-only: We only did the special code path if the file was
*       opened read-only (_IOREAD).  If the file was writable, we didn't
*       try to optimize.
*
*       (2) Buffering:  We'd assign a buffer, if necessary, since the
*       later code might need it (i.e., call _getbuf).
*
*       (3) Ungetc: Fseek had to be careful NOT to save the buffer if
*       an ungetc had ever been done on the buffer (flag _IOUNGETC).
*
*       (4) Control ^Z: Fseek had to deal with ^Z after reading a
*       new buffer's worth of data (flag _IOCTRLZ).
*
*       (5) Seek-to-end-and-back: To determine if the new seek was within
*       the current buffer, we had to 'normalize' the desired location.
*       This means that we sometimes had to seek to the end of the file
*       and back to determine what the 0-relative offset was.  Two extra
*       lseek() calls hurt performance.
*
*       (6) CR/LF accounting - When trying to seek within a buffer that
*       is in text mode, we had to go account for CR/LF expansion.  This
*       required us to look at every character up to the new offset and
*       see if it was '\n' or not.  In addition, we had to check the
*       FCRLF flag to see if the new buffer started with '\n'.
*
*       Again, all of these notes are for the OLD implimentation just to
*       remind folks of some of the issues involving seeking within a buffer
*       and maintaining buffer alignment.  As an aside, I think this may have
*       been a big win in the 'old days' on floppy-based systems but on newer
*       fast hard disks, the extra code/complexity overwhelmed any gain.
*
*                       - - - - - - - - - - - - -
*
*Entry:
*       FILE *stream - file to reposition file pointer on
*       long offset - offset to seek to
*       int whence - origin offset is measured from (0=beg, 1=current pos,
*                    2=end)
*
*Exit:
*       returns 0 if succeeds
*       returns -1 and sets errno if fails
*       fields of FILE struct will be changed
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _MT     /* multi-thread; define both fseek() and _lk_fseek() */

int __cdecl fseek (
        FILE *stream,
        long offset,
        int whence
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _fseek_lk (stream, offset, whence);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_fseek_lk() - Core fseek() routine (stream is locked)
*
*Purpose:
*       Core fseek() routine; assumes that caller has the stream locked.
*
*       [See fseek() for more info.]
*
*Entry: [See fseek()]
*
*Exit:  [See fseek()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fseek_lk (

#else   /* non multi-thread; just define fseek() */

int __cdecl fseek (

#endif  /* rejoin common code */

        FILE *str,
        long offset,
        int whence
        )
{


        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

        if ( !inuse(stream) || ((whence != SEEK_SET) && (whence != SEEK_CUR) &&
            (whence != SEEK_END)) ) {
                errno=EINVAL;
                return(-1);
        }

        /* Clear EOF flag */

        stream->_flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if (whence == SEEK_CUR) {
                offset += _ftell_lk(stream);
                whence = SEEK_SET;
        }

        /* Flush buffer as necessary */

#ifdef  _POSIX_
        /*
         * If the stream was last read, we throw away the buffer so
         * that a possible subsequent write will encounter a clean
         * buffer.  (The Win32 version of fflush() throws away the
         * buffer if it's read.)  Write buffers must be flushed.
         */
        
        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOREAD) {
                stream->_ptr = stream->_base;
                stream->_cnt = 0;
        } else {
                _flush(stream);
        }
#else
        _flush(stream);
#endif

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next _filbuf
           won't cost quite so much */

        if (stream->_flag & _IORW)
                stream->_flag &= ~(_IOWRT|_IOREAD);
        else if ( (stream->_flag & _IOREAD) && (stream->_flag & _IOMYBUF) &&
                  !(stream->_flag & _IOSETVBUF) )
                stream->_bufsiz = _SMALL_BUFSIZ;

        /* Seek to the desired locale and return. */

#ifdef  _POSIX_
        return(lseek(fileno(stream), offset, whence) == -1L ? -1 : 0);
#else
        return(_lseek(_fileno(stream), offset, whence) == -1L ? -1 : 0);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\ftell.c ===
/***
*ftell.c - get current file position
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ftell() - find current current position of file pointer
*
*Revision History:
*       09-02-83  RN    initial version
*       ??-??-??  TC    added code to allow variable buffer sizes
*       05-22-86  TC    added code to seek to send if last operation was a
*                       write and append mode specified
*       11-20-86  SKS   do not seek to end of file in append mode
*       12-01-86  SKS   fix off-by-1 problem in text mode when last byte in
*                       buffer was a '\r', and it was followed by a '\n'. Since
*                       the \n was pushed back and the \r was discarded, we
*                       must adjust the computed position for the \r.
*       02-09-87  JCR   Added errno set code (if flag (_IORW not set)
*       09-09-87  JCR   Optimized to eliminate two lseek() calls in binary mode.
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-04-87  JCR   Multi-thread version
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Use _iob2_ macro instead of _iob_index
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       07-27-88  JCR   Changed some variables from int to unsigned (bug fix)
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       12-05-88  JCR   Added _IOCTRLZ support (fixes bug pertaining to ^Z at
*                       eof)
*       08-17-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat
*                       model), also fixed copyright
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       09-01-92  GJF   Fixed POSIX support (was returning -1 for all except
*                       read-write streams).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-29-93  GJF   Fixed bug related to variable buffer sizing (Cuda
*                       #5456).
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       02-27-98  RKP   Add 64 bit support.
*       03-02-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <errno.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#endif
#include <stddef.h>
#include <io.h>
#include <internal.h>
#ifndef _POSIX_
#include <mtdll.h>
#endif

/***
*long ftell(stream) - query stream file pointer
*
*Purpose:
*       Find out what stream's position is. coordinate with buffering; adjust
*       backward for read-ahead and forward for write-behind. This is NOT
*       equivalent to fseek(stream,0L,1), because fseek will remove an ungetc,
*       may flush buffers, etc.
*
*Entry:
*       FILE *stream - stream to query for position
*
*Exit:
*       return present file position if succeeds
*       returns -1L and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT      /* multi-thread; define both ftell() and _lk_ftell() */

long __cdecl ftell (
        FILE *stream
        )
{
        long retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _ftell_lk (stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_ftell_lk() - Ftell() core routine (assumes stream is locked).
*
*Purpose:
*       Core ftell() routine; assumes caller has aquired stream lock).
*
*       [See ftell() above for more info.]
*
*Entry: [See ftell()]
*
*Exit:  [See ftell()]
*
*Exceptions:
*
*******************************************************************************/

long __cdecl _ftell_lk (

#else   /* non multi-thread; define only ftell() */

long __cdecl ftell (

#endif  /* rejoin common code */

        FILE *str
        )
{
        REG1 FILE *stream;
        unsigned int offset;
        long filepos;
#if     !defined(_POSIX_)
        REG2 char *p;
        char *max;
#endif
        int fd;
        unsigned int rdcnt;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;
#ifdef _POSIX_
        fd = fileno(stream);
#else
        fd = _fileno(stream);
#endif

        if (stream->_cnt < 0)
            stream->_cnt = 0;

#ifdef _POSIX_
        if ((filepos = lseek(fd, 0L, SEEK_CUR)) < 0L)
#else
        if ((filepos = _lseek(fd, 0L, SEEK_CUR)) < 0L)
#endif
            return(-1L);

        if (!bigbuf(stream))            /* _IONBF or no buffering designated */
            return(filepos - stream->_cnt);

        offset = (unsigned)(stream->_ptr - stream->_base);

#ifndef _POSIX_
        if (stream->_flag & (_IOWRT|_IOREAD)) {
            if (_osfile(fd) & FTEXT)
                for (p = stream->_base; p < stream->_ptr; p++)
                    if (*p == '\n')  /* adjust for '\r' */
                        offset++;
        }
        else if (!(stream->_flag & _IORW)) {
            errno=EINVAL;
            return(-1L);
        }
#endif

        if (filepos == 0L)
            return((long)offset);

        if (stream->_flag & _IOREAD)    /* go to preceding sector */

            if (stream->_cnt == 0)  /* filepos holds correct location */
                offset = 0;

            else {

                /* Subtract out the number of unread bytes left in the buffer.
                   [We can't simply use _iob[]._bufsiz because the last read
                   may have hit EOF and, thus, the buffer was not completely
                   filled.] */

                rdcnt = stream->_cnt + (unsigned)(stream->_ptr - stream->_base);

#if  !defined(_POSIX_)
                /* If text mode, adjust for the cr/lf substitution. If binary
                   mode, we're outta here. */
                if (_osfile(fd) & FTEXT) {
                    /* (1) If we're not at eof, simply copy _bufsiz onto rdcnt
                       to get the # of untranslated chars read. (2) If we're at
                       eof, we must look through the buffer expanding the '\n'
                       chars one at a time. */

                    /* [NOTE: Performance issue -- it is faster to do the two
                       _lseek() calls than to blindly go through and expand the
                       '\n' chars regardless of whether we're at eof or not.] */

                    if (_lseek(fd, 0L, 2) == filepos) {

                        max = stream->_base + rdcnt;
                        for (p = stream->_base; p < max; p++)
                            if (*p == '\n')
                                /* adjust for '\r' */
                                rdcnt++;

                        /* If last byte was ^Z, the lowio read didn't tell us
                           about it. Check flag and bump count, if necessary. */

                        if (stream->_flag & _IOCTRLZ)
                            ++rdcnt;
                    }

                    else {

                        _lseek(fd, filepos, 0);

                        /* We want to set rdcnt to the number of bytes
                           originally read into the stream buffer (before
                           crlf->lf translation). In most cases, this will
                           just be _bufsiz. However, the buffer size may have
                           been changed, due to fseek optimization, at the
                           END of the last _filbuf call. */

                        if ( (rdcnt <= _SMALL_BUFSIZ) &&
                             (stream->_flag & _IOMYBUF) &&
                             !(stream->_flag & _IOSETVBUF) )
                        {
                            /* The translated contents of the buffer is small
                               and we are not at eof. The buffer size must have
                               been set to _SMALL_BUFSIZ during the last
                               _filbuf call. */

                            rdcnt = _SMALL_BUFSIZ;
                        }
                        else
                            rdcnt = stream->_bufsiz;

                        /* If first byte in untranslated buffer was a '\n',
                           assume it was preceeded by a '\r' which was
                           discarded by the previous read operation and count
                           the '\n'. */
                        if  (_osfile(fd) & FCRLF)
                            ++rdcnt;
                    }

                } /* end if FTEXT */
#endif

                filepos -= (long)rdcnt;

            } /* end else stream->_cnt != 0 */

        return(filepos + (long)offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\getw.c ===
/***
*getw.c - read a binary word from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getw() - gets a binary integer from a stream
*
*Revision History:
*       09-02-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merged DLL and normal versions
*                       Fixed bug if EOF occurs in middle of word being read
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-13-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _getw(stream) - read an int from a stream
*
*Purpose:
*       get n bytes (n=sizeof(int)); OR them together in proper order; high
*       byte first. check for EOF between getc's.
*       this routine should be machine independent.
*
*Entry:
*       FILE *stream - stream to read integer from
*
*Exit:
*       returns the int read from the stream
*       returns EOF if fails (but this is a legit int value, so
*       should test feof() or ferror().
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getw (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int bytecount = sizeof(int);
        int word;
        char *byteptr = (char *)&word;
        int retval;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (bytecount--)
            *byteptr++ = (char)_getc_lk(stream);
        retval = ((feof(stream) || ferror(stream)) ? EOF : word);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\getws.c ===
/***
*getws.c - read a line from stdin (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines getws() - read a line from stdin into buffer
*
*Revision History:
*	01-31-94  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "gets.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\gets.c ===
/***
*gets.c - read a line from stdin
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines gets() and getws() - read a line from stdin into buffer
*
*Revision History:
*       09-02-83  RN    initial version
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       02-15-90  GJF   Fixed copyright, indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       01-31-94  CFW   Unicode enable.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <mtdll.h>
#include <tchar.h>

/***
*char *gets(string) - read a line from stdin
*
*Purpose:
*       Gets a string from stdin terminated by '\n' or EOF; don't include '\n';
*       append '\0'.
*
*Entry:
*       char *string - place to store read string, assumes enough room.
*
*Exit:
*       returns string, filled in with the line of input
*       null string if \n found immediately
*       NULL if EOF found immediately
*
*Exceptions:
*
*******************************************************************************/

_TCHAR * __cdecl _getts (
        _TCHAR *string
        )
{
        int ch;
        _TCHAR *pointer = string;
        _TCHAR *retval = string;

        _ASSERTE(string != NULL);

#ifdef  _MT
        _lock_str2(0, stdin);
        __try {
#endif

#ifdef _UNICODE
        while ((ch = _getwchar_lk()) != L'\n')
#else
        while ((ch = _getchar_lk()) != '\n')
#endif
        {
                if (ch == _TEOF)
                {
                        if (pointer == string)
                        {
                                retval = NULL;
                                goto done;
                        }

                        break;
                }

                *pointer++ = (_TCHAR)ch;
        }

        *pointer = _T('\0');

/* Common return */
done:

#ifdef  _MT
        ; }
        __finally {
                _unlock_str2(0, stdin);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fwprintf.c ===
/***
*fwprintf.c - print formatted data to stream
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fwprintf() - print formatted data to stream
*
*Revision History:
*       05-16-92  KRS   Created from fprintf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fwprintf(stream, format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on the given using the format string to
*       format data and getting as many arguments as called for
*       _output does the real work here
*
*Entry:
*       FILE *stream - stream to print on
*       wchar_t *format - format string to control data format/number of arguments
*       followed by arguments to print, number and type controlled by
*       format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fwprintf (
        FILE *str,
        const wchar_t *format,
        ...
        )
/*
 * 'F'ile (stream) 'W'char_t 'PRINT', 'F'ormatted
 */
{
        va_list(arglist);
        REG1 FILE *stream;
        REG2 int buffing;
        int retval;

// UNDONE: make va_start work with wchar_t format string
        va_start(arglist, format);

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _woutput(stream,format,arglist);
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\makefile.inc ===
!if "$(SRCDIR)" == ""
SRCDIR = .^\
!endif

$(SRCDIR)cprintf.c: $(SRCDIR)output.c

$(SRCDIR)cscanf.c: $(SRCDIR)input.c

$(SRCDIR)snprintf.c: $(SRCDIR)sprintf.c

$(SRCDIR)vsnprint.c: $(SRCDIR)vsprintf.c

$(SRCDIR)woutput.c: $(SRCDIR)output.c

$(SRCDIR)snwprint.c: $(SRCDIR)swprintf.c

$(SRCDIR)vsnwprnt.c: $(SRCDIR)vswprint.c

$(SRCDIR)_flswbuf.c: $(SRCDIR)_flsbuf.c

$(SRCDIR)_filwbuf.c: $(SRCDIR)_filbuf.c

$(SRCDIR)cwprintf.c: $(SRCDIR)woutput.c

$(SRCDIR)cwscanf.c: $(SRCDIR)input.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fwscanf.c ===
/***
*fwscanf.c - read formatted data from stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fwscanf() - reads formatted data from stream
*
*Revision History:
*       05-16-92  KRS   Created from fscanf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fwscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       Reads formatted data from stream into arguments.  _input does the real
*       work here.
*
*Entry:
*       FILE *stream - stream to read data from
*       wchar_t *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fwscanf (
        FILE *stream,
        const wchar_t *format,
        ...
        )
/*
 * 'F'ile (stream) 'W'char_t 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

        va_start(arglist, format);

        _ASSERTE(stream != NULL);
        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = (_winput(stream,format,arglist));

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\fwrite.c ===
/***
*fwrite.c - read from a stream
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Write to the specified stream from the user's buffer.
*
*Revision History:
*       06-23-89  PHG   Module created, based on asm version
*       01-18-90  GJF   Must call _fflush_lk() rather than fflush().
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-19-90  GJF   Made calling type _CALLTYPE1 and added #include
*                       <cruntime.h>. Also, fixed compiler warning.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-26-90  SBM   Added #include <internal.h>
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       10-22-93  GJF   Fix divide-by-0 error in unbuffered case. Also,
*                       replaced MTHREAD with _MT.
*       12-30-94  GJF   _MAC_ merge.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       05-24-95  CFW   Return 0 if none to write.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <mtdll.h>
#include <io.h>
#include <string.h>
#include <file2.h>
#include <internal.h>

/***
*size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream) -
*       write to the specified stream from the specified buffer.
*
*Purpose:
*       Write 'count' items of size 'size' to the specified stream from
*       the specified buffer. Return when 'count' items have been written
*       or no more items can be written to the stream.
*
*Entry:
*       buffer  - pointer to user's buffer
*       size    - size of the item to write
*       count   - number of items to write
*       stream  - stream to write to
*
*Exit:
*       Returns the number of (whole) items that were written to the stream.
*       This may be less than 'count' if an error or eof occurred. In this
*       case, ferror() or feof() should be used to distinguish between the
*       two conditions.
*
*Notes:
*       fwrite will attempt to buffer the stream (side effect of the _flsbuf
*       call) if necessary.
*
*       No more than 0xFFFE bytes may be written out at a time by a call to
*       write(). Further, write() does not handle huge buffers. Therefore,
*       in large data models, the write request is broken down into chunks
*       that do not violate these considerations. Each of these chunks is
*       processed much like an fwrite() call in a small data model (by a
*       call to _nfwrite()).
*
*       This code depends on _iob[] being a near array.
*
*       MTHREAD/DLL - Handled in just two layers since it is small data
*       model. The outer layer, fwrite(), handles stream locking/unlocking
*       and calls _fwrite_lk() to do the work. _fwrite_lk() is the same as
*       the single-thread, small data model version of fwrite().
*
*******************************************************************************/


#ifdef  _MT
/* define locking/unlocking version */
size_t __cdecl fwrite (
        const void *buffer,
        size_t size,
        size_t count,
        FILE *stream
        )
{
        size_t retval;

        _lock_str(stream);                      /* lock stream */

        __try {
                /* do the read */
                retval = _fwrite_lk(buffer, size, count, stream);
        }
        __finally {
                _unlock_str(stream);            /* unlock stream */
        }

        return retval;
}
#endif

/* define the normal version */
#ifdef  _MT
size_t __cdecl _fwrite_lk (
#else
size_t __cdecl fwrite (
#endif
        const void *buffer,
        size_t size,
        size_t num,
        FILE *stream
        )
{
        const char *data;               /* point to where data comes from next */
        size_t total;                   /* total bytes to write */
        size_t count;                   /* num bytes left to write */
        unsigned bufsize;               /* size of stream buffer */
        unsigned nbytes;                /* number of bytes to write now */
        unsigned nwritten;              /* number of bytes written */
        int c;                          /* a temp char */

        /* initialize local vars */
        data = buffer;
        count = total = size * num;
        if (0 == count)
            return 0;

        if (anybuf(stream))
                /* already has buffer, use its size */
                bufsize = stream->_bufsiz;
        else
                /* assume will get _INTERNAL_BUFSIZ buffer */
                bufsize = _INTERNAL_BUFSIZ;

        /* here is the main loop -- we go through here until we're done */
        while (count != 0) {
                /* if the buffer is big and has room, copy data to buffer */
                if (bigbuf(stream) && stream->_cnt != 0) {
                        /* how much do we want? */
                        nbytes = (count < (unsigned)stream->_cnt) ? (unsigned)count : stream->_cnt;
                        memcpy(stream->_ptr, data, nbytes);

                        /* update stream and amt of data written */
                        count -= nbytes;
                        stream->_cnt -= nbytes;
                        stream->_ptr += nbytes;
                        data += nbytes;
                }
                else if (count >= bufsize) {
                        /* If we have more than bufsize chars to write, write
                           data by calling write with an integral number of
                           bufsiz blocks.  If we reach here and we have a big
                           buffer, it must be full so _flush it. */

                        if (bigbuf(stream)) {
                                if (_flush(stream)) {
                                        /* error, stream flags set -- we're out
                                           of here */
                                        return (total - count) / size;
                                }
                        }

                        /* calc chars to read -- (count/bufsize) * bufsize */
                        nbytes = ( bufsize ? (unsigned)(count - count % bufsize) :
                                   (unsigned)count );

#ifdef  _POSIX_
                        nwritten = write(fileno(stream), data, nbytes);
#else
                        nwritten = _write(_fileno(stream), data, nbytes);
#endif
                        if (nwritten == (unsigned)EOF) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }

                        /* update count and data to reflect write */

                        count -= nwritten;
                        data += nwritten;

                        if (nwritten < nbytes) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }
                }
                else {
                        /* buffer full and not enough chars to do direct write,
                           so do a _flsbuf. */
                        c = *data;  /* _flsbuf write one char, this is it */
                        if (_flsbuf(c, stream) == EOF) {
                                /* error or eof, stream flags set by _flsbuf */
                                return (total - count) / size;
                        }

                        /* _flsbuf wrote a char -- update count */
                        ++data;
                        --count;

                        /* update buffer size */
                        bufsize = stream->_bufsiz > 0 ? stream->_bufsiz : 1;
                }
        }

        /* we finished successfully, so just return num */
        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\input.c ===
/***
*input.c - C formatted input, used by scanf, etc.
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _input() to do formatted input; called from scanf(),
*       etc. functions.  This module defines _cscanf() instead when
*       CPRFLAG is defined.  The file cscanf.c defines that symbol
*       and then includes this file in order to implement _cscanf().
*
*Revision History:
*       09-26-83  RN    author
*       11-01-85  TC    added %F? %N? %?p %n %i
*       11-20-86  SKS   enlarged "table" to 256 bytes, to support chars > 0x7F
*       12-12-86  SKS   changed "s_in()" to pushback whitespace or other delimiter
*       03-24-87  BCM   Evaluation Issues:
*                       SDS - needs #ifdef SS_NE_DS for the "number" buffer
*                           (for S/M models only)
*                       GD/TS : (not evaluated)
*                       other INIT : (not evaluated)
*                           needs _cfltcvt_init to have been called if
*                           floating-point i/o conversions are being done
*                       TERM - nothing
*       06-25-87  PHG   added check_stack pragma
*       08-31-87  JCR   Made %n conform to ANSI standard: (1) %n is supposed to
*                       return the # of chars read so far by the current scanf(),
*                       NOT the total read on the stream since open; (2) %n is NOT
*                       supposed to affect the # of items read that is returned by
*                       scanf().
*       09-24-87  JCR   Made cscanf() use the va_ macros (fixes cl warnings).
*       11-04-87  JCR   Multi-thread support
*       11-16-87  JCR   Cscanf() now gets _CONIO_LOCK
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-25-88  JCR   If burn() char hits EOF, only return EOF if count==0.
*       05-31-88  WAJ   Now suports %Fs and %Ns
*       06-01-88  PHG   Merged DLL and normal versions
*       06-08-88  SJM   %D no longer means %ld.  %[]ABC], %[^]ABC] work.
*       06-14-88  SJM   Fixed %p, and %F? and %N? code.
*                 SJM   Complete re-write of input/_input for 6.00
*       09-15-88  JCR   If we match a field but it's not assigned, then are
*                       terminated by EOF, we must return 0 not EOF (ANSI).
*       09-25-88  GJF   Initial adaption for the 386
*       10-04-88  JCR   386: Removed 'far' keyword
*       11-30-88  GJF   Cleanup, now specific to 386
*       06-09-89  GJF   Propagated fixes of 03-06-89 and 04-05-89
*       11-20-89  GJF   Added const attribute to type of format. Also, fixed
*                       copyright.
*       12-21-89  GJF   Allow null character in scanset
*       02-14-90  KRS   Fix suppressed-assignment pattern matching.
*       03-20-90  GJF   Made _cscanf() _CALLTYPE2 and _input() _CALLTYPE1. Added
*                       #include <cruntime.h> and #include <register.h>.
*       03-26-90  GJF   Made static functions _CALLTYPE4. Placed prototype for
*                       _input() in internal.h and #include-d it. Changed type of
*                       arglist from void ** to va_list (to get rid of annoying
*                       warnings). Added #include <string.h>. Elaborated prototypes
*                       of static functions to get rid of compiler warnings.
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       07-23-90  SBM   Compiles cleanly with -W3, replaced <assertm.h> by
*                       <assert.h>, moved _cfltcvt_tab to new header
*                       <fltintrn.h>, formerly named <struct.h>
*       08-13-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       08-27-90  SBM   Minor cleanup to agree with CRT7 version
*       10-02-90  GJF   New-style function declarators. Also, rewrote expr. to
*                       avoid using casts as lvalues.
*       10-22-90  GJF   Added arglistsave, used to save and restore arglist pointer
*                       without using pointer arithmetic.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragma
*       01-16-91  GJF   ANSI naming.
*       03-14-91  GJF   Fix to allow processing of %n, even at eof. Fix devised by
*                       DanK of PSS.
*       06-19-91  GJF   Fixed execution of string, character and scan-set format
*                       directives to avoid problem with line-buffered devices
*                       (C700 bug 1441).
*       10-22-91  ETC   Int'l dec point; Under _INTL: wchar_t/mb support; fix bug
*                       under !ALLOW_RANGE (never compiled).
*       11-15-91  ETC   Fixed bug with %f %lf %Lf (bad handling of longone).
*       11-19-91  ETC   Added support for _wsscanf with WPRFLAG; added %tc %ts.
*       06-09-92  KRS   Rip out %tc/%ts; conform to new ISO spec.
*       08-17-92  KRS   Further ISO changes:  Add %lc/%ls/%hc/%hs/%C/%S.
*       12-23-92  SKS   Needed to handle %*n (suppressed storage of byte count)
*       02-16-93  CFW   Added wide character output for [] scanset.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       08-17-93  CFW   Avoid mapping tchar macros incorrectly if _MBCS defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       11-08-93  GJF   Merged in NT SDK version (use __unaligned pointer
*                       casts on MIPS and Alpha. Also, fixed #elif WPRFLAG to
*                       be #elif defined(WPRFLAG), and removed old CRUISER
*                       support.
*       12-16-93  CFW   Get rid of spurious compiler warnings.
*       03-15-94  GJF   Added support for I64 size modifier.
*       04-21-94  GJF   Must reinitialize integer64 flag.
*       09-05-94  SKS   Remove include of obsolete 16-bit file <sizeptr.h>
*       12-14-94  GJF   Changed test for (hex) digits so that when WPRFLAG is
*                       defined, only zero-extended (hex) digits are
*                       recognized. This way, the familar arithmetic to convert
*                       from character rep. to binary integer value will work.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also, replaced
*                       WPRFLAG with _UNICODE.
*       08-01-96  RDK   For PMac, added __int64 support for _input.
*       02-27-98  RKP   Added 64 bit support.
*       07-07-98  RKP   Corrected %P formatting for 64 bit.
*       09-21-98  GJF   Added support for %I and %I32 modifiers.
*       05-17-99  PML   Remove all Macintosh support.
*       10-28-99  PML   vs7#10705 Win64 %p was totally busted
*       04-25-00  GB    Adding support for _cwprintf.
*       05-31-00  GB    Changed scanf to match with standards. problem was
*                       reading octal or hexa while %d was specified.
*       10-20-00  GB    Changed input not to use %[] case for %c and %s.
*       02-19-01  GB    Added check for return value of malloc.
*       03-13-01  PML   Fix heap leak on multiple %[] specs (vs7#224990)
*       07-07-01  BWT   Fix prefix bug - init pointer to a known value
*                       when handling * formatting.
*
*******************************************************************************/


#define ALLOW_RANGE /* allow "%[a-z]"-style scansets */


/* temporary work-around for compiler without 64-bit support */

#ifndef _INTEGRAL_MAX_BITS
#define _INTEGRAL_MAX_BITS  64
#endif


#include <cruntime.h>
#include <stdio.h>
#include <ctype.h>
#include <cvt.h>
#include <conio.h>
#include <stdarg.h>
#include <string.h>
#include <internal.h>
#include <fltintrn.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <nlsint.h>
#include <dbgint.h>

#ifdef _MBCS    /* always want either Unicode or SBCS for tchar.h */
#undef _MBCS
#endif
#include <tchar.h>

#if defined(_NTSUBSET_) || defined(_POSIX_)
#if  defined (UNICODE)
#define malloc_crt(x) RtlAllocateHeap(RtlProcessHeap(), 0, x)
#define free_crt(x)   RtlFreeHeap(RtlProcessHeap(), 0, x)
#define ALLOC_TABLE 1
#else 
#define ALLOC_TABLE 0
#endif
#else
#define ALLOC_TABLE 1
#endif

#define HEXTODEC(chr)   _hextodec(chr)
#define LEFT_BRACKET    ('[' | ('a' - 'A')) /* 'lowercase' version */

#ifdef _UNICODE
static wchar_t __cdecl _hextodec(wchar_t);
#else
static int __cdecl _hextodec(int);
#endif /* _UNICODE */

#ifdef CPRFLAG

#define INC()           (++charcount, _inc())
#define UN_INC(chr)     (--charcount, _un_inc(chr))
#define EAT_WHITE()     _whiteout(&charcount)

#ifndef _UNICODE
static int __cdecl _inc(void);
static void __cdecl _un_inc(int);
static int __cdecl _whiteout(int *);
#else /* _UNICODE */
static wchar_t __cdecl _inc(void);
static void __cdecl _un_inc(wchar_t);
static wchar_t __cdecl _whiteout(int *);
#endif /* _UNICODE */

#else /* CPRFLAG */

#define INC()           (++charcount, _inc(stream))
#define UN_INC(chr)     (--charcount, _un_inc(chr, stream))
#define EAT_WHITE()     _whiteout(&charcount, stream)

#ifndef _UNICODE
static int __cdecl _inc(FILE *);
static void __cdecl _un_inc(int, FILE *);
static int __cdecl _whiteout(int *, FILE *);
#else /* _UNICODE */
static wchar_t __cdecl _inc(FILE *);
static void __cdecl _un_inc(wchar_t, FILE *);
static wchar_t __cdecl _whiteout(int *, FILE *);
#endif /* _UNICODE */

#endif /* CPRFLAG */


#ifndef _UNICODE
#define _ISDIGIT(chr)   isdigit(chr)
#define _ISXDIGIT(chr)  isxdigit(chr)
#else
#define _ISDIGIT(chr)   ( !(chr & 0xff00) && isdigit( chr & 0x00ff ) )
#define _ISXDIGIT(chr)  ( !(chr & 0xff00) && isxdigit( chr & 0x00ff ) )
#endif



#ifdef CPRFLAG
#ifndef _UNICODE
static int __cdecl input(const unsigned char *, va_list);
#else
static int __cdecl input(const wchar_t *, va_list);
#endif


/***
*int _cscanf(format, arglist) - read formatted input direct from console
*
*Purpose:
*   Reads formatted data like scanf, but uses console I/O functions.
*
*Entry:
*   char *format - format string to determine data formats
*   arglist - list of POINTERS to where to put data
*
*Exit:
*   returns number of successfully matched data items (from input)
*
*Exceptions:
*
*******************************************************************************/

#ifndef _UNICODE
int __cdecl _cscanf (
    const char *format,
#else /* _UNICODE */
int __cdecl _cwscanf (
    const wchar_t *format,
#endif /* _UNICODE */
    ...
    )
{
    va_list arglist;

    va_start(arglist, format);

    _ASSERTE(format != NULL);

    return input(format,arglist);   /* get the input */
}

#endif  /* CPRFLAG */


#define ASCII       32           /* # of bytes needed to hold 256 bits */

#define SCAN_SHORT     0         /* also for FLOAT */
#define SCAN_LONG      1         /* also for DOUBLE */
#define SCAN_L_DOUBLE  2         /* only for LONG DOUBLE */

#define SCAN_NEAR    0
#define SCAN_FAR     1

#ifndef _UNICODE
#define TABLESIZE    ASCII
#else
#define TABLESIZE    (ASCII * 256)
#endif


/***
*int _input(stream, format, arglist), static int input(format, arglist)
*
*Purpose:
*   get input items (data items or literal matches) from the input stream
*   and assign them if appropriate to the items thru the arglist. this
*   function is intended for internal library use only, not for the user
*
*   The _input entry point is for the normal scanf() functions
*   The input entry point is used when compiling for _cscanf() [CPRFLAF
*   defined] and is a static function called only by _cscanf() -- reads from
*   console.
*
*Entry:
*   FILE *stream - file to read from
*   char *format - format string to determine the data to read
*   arglist - list of pointer to data items
*
*Exit:
*   returns number of items assigned and fills in data items
*   returns EOF if error or EOF found on stream before 1st data item matched
*
*Exceptions:
*
*******************************************************************************/

#ifdef CPRFLAG

#ifndef _UNICODE
static int __cdecl input (
    const unsigned char *format,
    va_list arglist
    )
#else
static int __cdecl input (
    const wchar_t *format,
    va_list arglist
    )
#endif /* _UNICODE */ 
#else
#if defined(_UNICODE)

int __cdecl _winput (
    FILE *stream,
    const wchar_t *format,
    va_list arglist
    )
#else

int __cdecl _input (
    FILE *stream,
    const unsigned char *format,
    va_list arglist
    )
#endif /* _UNICODE */ 
#endif /* CPRFLAG */

{
#ifndef _UNICODE
    char floatstring[CVTBUFSIZE + 1];   /* ASCII buffer for floats           */
#else
    wchar_t floatstring[CVTBUFSIZE + 1];
#endif

    unsigned long number;               /* temp hold-value                   */
#if ALLOC_TABLE
    char *table = NULL;                 /* which chars allowed for %[]       */
    int malloc_flag = 0;                /* is "table" allocated on the heap? */
#else
    char AsciiTable[TABLESIZE];
    char *table = AsciiTable;
#endif

#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
    unsigned __int64 num64;             /* temp for 64-bit integers          */
#endif
    void *pointer;                      /* points to user data receptacle    */
    void *start;                        /* indicate non-empty string         */


#ifdef _UNICODE
    wchar_t *scanptr;                   /* for building "table" data         */
REG2 wchar_t ch = 0;
#else
    wchar_t wctemp;
    unsigned char *scanptr;             /* for building "table" data         */
REG2 int ch = 0;
#endif
    int charcount;                      /* total number of chars read        */
REG1 int comchr;                        /* holds designator type             */
    int count;                          /* return value.  # of assignments   */

    int started;                        /* indicate good number              */
    int width;                          /* width of field                    */
    int widthset;                       /* user has specified width          */

/* Neither coerceshort nor farone are need for the 386 */


    char done_flag;                     /* general purpose loop monitor      */
    char longone;                       /* 0 = SHORT, 1 = LONG, 2 = L_DOUBLE */
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
    int integer64;                      /* 1 for 64-bit integer, 0 otherwise */
#endif
    signed char widechar;               /* -1 = char, 0 = ????, 1 = wchar_t  */
    char reject;                        /* %[^ABC] instead of %[ABC]         */
    char negative;                      /* flag for '-' detected             */
    char suppress;                      /* don't assign anything             */
    char match;                         /* flag: !0 if any fields matched    */
    va_list arglistsave;                /* save arglist value                */

    char fl_wchar_arg;                  /* flags wide char/string argument   */
#ifdef _UNICODE
#ifdef ALLOW_RANGE
    wchar_t rngch;              /* used while scanning range         */
#endif
    wchar_t last;               /* also for %[a-z]                   */
    wchar_t prevchar;           /* for %[a-z]                        */
    wchar_t wdecimal;                   /* wide version of decimal point     */
    wchar_t *wptr;                      /* pointer traverses wide floatstring*/
#else
#ifdef ALLOW_RANGE
    unsigned char rngch;                /* used while scanning range         */
#endif
    unsigned char last;                 /* also for %[a-z]                   */
    unsigned char prevchar;             /* for %[a-z]                        */
#endif

    _ASSERTE(format != NULL);

#ifndef CPRFLAG
    _ASSERTE(stream != NULL);
#endif

    /*
    count = # fields assigned
    charcount = # chars read
    match = flag indicating if any fields were matched

    [Note that we need both count and match.  For example, a field
    may match a format but have assignments suppressed.  In this case,
    match will get set, but 'count' will still equal 0.  We need to
    distinguish 'match vs no-match' when terminating due to EOF.]
    */

    count = charcount = match = 0;

    while (*format) {

        if (_istspace((_TUCHAR)*format)) {

            UN_INC(EAT_WHITE()); /* put first non-space char back */

            while ((_istspace)(*++format)); /* NULL */
            /* careful: isspace macro may evaluate argument more than once! */
            continue;

        }

        if (_T('%') == *format) {

            number = 0;
            prevchar = 0;
            width = widthset = started = 0;
            fl_wchar_arg = done_flag = suppress = negative = reject = 0;
            widechar = 0;

            longone = 1;

            integer64 = 0;

            while (!done_flag) {

                comchr = *++format;
                if (_ISDIGIT((_TUCHAR)comchr)) {
                    ++widthset;
                    width = MUL10(width) + (comchr - _T('0'));
                } else
                    switch (comchr) {
                        case _T('F') :
                        case _T('N') :   /* no way to push NEAR in large model */
                            break;  /* NEAR is default in small model */
                        case _T('h') :
                            /* set longone to 0 */
                            --longone;
                            --widechar;         /* set widechar = -1 */
                            break;

#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                        case _T('I'):
                            if ( (*(format + 1) == _T('6')) &&
                                 (*(format + 2) == _T('4')) )
                            {
                                format += 2;
                                ++integer64;
                                num64 = 0;
                                break;
                            }
                            else if ( (*(format + 1) == _T('3')) &&
                                      (*(format + 2) == _T('2')) )
                            {
                                format += 2;
                                break;
                            }
                            else if ( (*(format + 1) == _T('d')) ||
                                      (*(format + 1) == _T('i')) ||
                                      (*(format + 1) == _T('o')) ||
                                      (*(format + 1) == _T('x')) ||
                                      (*(format + 1) == _T('X')) )
                            {
                                if (sizeof(void*) == sizeof(__int64))
                                {
                                    ++integer64;
                                    num64 = 0;
                                }
                                break;
                            }
                            if (sizeof(void*) == sizeof(__int64))
                            {
                                    ++integer64;
                                    num64 = 0;
                            }
                            goto DEFAULT_LABEL;
#endif

                        case _T('L') :
                        /*  ++longone;  */
                            ++longone;
                            break;

                        case _T('l') :
                            ++longone;
                                    /* NOBREAK */
                        case _T('w') :
                            ++widechar;         /* set widechar = 1 */
                            break;

                        case _T('*') :
                            ++suppress;
                            break;

                        default:
DEFAULT_LABEL:
                            ++done_flag;
                            break;
                    }
            }

            if (!suppress) {
                arglistsave = arglist;
                pointer = va_arg(arglist,void *);
            } else {
                pointer = NULL;         // doesn't matter what value we use here - we're only using it as a flag
            }

            done_flag = 0;

            if (!widechar) {    /* use case if not explicitly specified */
                if ((*format == _T('S')) || (*format == _T('C')))
#ifdef _UNICODE
                    --widechar;
                else
                    ++widechar;
#else
                    ++widechar;
                else
                    --widechar;
#endif
            }

            /* switch to lowercase to allow %E,%G, and to
               keep the switch table small */

            comchr = *format | (_T('a') - _T('A'));

            if (_T('n') != comchr)
                if (_T('c') != comchr && LEFT_BRACKET != comchr)
                    ch = EAT_WHITE();
                else
                    ch = INC();

#ifdef _POSIX_
            if (_T('n') != comchr)
            {
                if (EOF == ch)
                    goto error_return;
            }
#endif

            if (!widthset || width) {

                switch(comchr) {

                    case _T('c'):
                /*  case _T('C'):  */
                        if (!widthset) {
                            ++widthset;
                            ++width;
                        }
                        if (widechar > 0)
                            fl_wchar_arg++;
                        goto scanit;


                    case _T('s'):
                /*  case _T('S'):  */
                        if(widechar > 0)
                            fl_wchar_arg++;
                        goto scanit;


                    case LEFT_BRACKET :   /* scanset */
                        if (widechar>0)
                            fl_wchar_arg++;
                        scanptr = (_TCHAR *)(++format);

                        if (_T('^') == *scanptr) {
                            ++scanptr;
                            --reject; /* set reject to 255 */
                        }

                        /* Allocate "table" on first %[] spec */
#if ALLOC_TABLE
                        if (table == NULL) {
                            __try {
                                table = _alloca(TABLESIZE);
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER) {
                                _resetstkoflw();
                                table = _malloc_crt(TABLESIZE);
                                if ( table == NULL)
                                    goto error_return;
                                malloc_flag = 1;
                            }
                        }
#endif
                        memset(table, 0, TABLESIZE);

#ifdef ALLOW_RANGE

                        if (LEFT_BRACKET == comchr)
                            if (_T(']') == *scanptr) {
                                prevchar = _T(']');
                                ++scanptr;

                                table[ _T(']') >> 3] = 1 << (_T(']') & 7);

                            }

                        while (_T(']') != *scanptr) {

                            rngch = *scanptr++;

                            if (_T('-') != rngch ||
                                 !prevchar ||           /* first char */
                                 _T(']') == *scanptr) /* last char */

                                table[(prevchar = rngch) >> 3] |= 1 << (rngch & 7);

                            else {  /* handle a-z type set */

                                rngch = *scanptr++; /* get end of range */

                                if (prevchar < rngch)  /* %[a-z] */
                                    last = rngch;
                                else {              /* %[z-a] */
                                    last = prevchar;
                                    prevchar = rngch;
                                }
                                for (rngch = prevchar; rngch <= last; ++rngch)
                                    table[rngch >> 3] |= 1 << (rngch & 7);

                                prevchar = 0;

                            }
                        }


#else
                        if (LEFT_BRACKET == comchr)
                            if (_T(']') == *scanptr) {
                                ++scanptr;
                                table[(prevchar = _T(']')) >> 3] |= 1 << (_T(']') & 7);
                            }

                        while (_T(']') != *scanptr) {
                            table[scanptr >> 3] |= 1 << (scanptr & 7);
                            ++scanptr;
                        }
                        /* code under !ALLOW_RANGE is probably never compiled */
                        /* and has probably never been tested */
#endif
                        if (!*scanptr)
                            goto error_return;      /* trunc'd format string */

                        /* scanset completed.  Now read string */

                        if (LEFT_BRACKET == comchr)
                            format = scanptr;

scanit:
                        start = pointer;

                        /*
                         * execute the format directive. that is, scan input
                         * characters until the directive is fulfilled, eof
                         * is reached, or a non-matching character is
                         * encountered.
                         *
                         * it is important not to get the next character
                         * unless that character needs to be tested! other-
                         * wise, reads from line-buffered devices (e.g.,
                         * scanf()) would require an extra, spurious, newline
                         * if the first newline completes the current format
                         * directive.
                         */
                        UN_INC(ch);

                        while ( !widthset || width-- ) {

                            ch = INC();
                            if (
#ifndef CPRFLAG
#ifndef _UNICODE
                                 (EOF != ch) &&
#else
                                 (WEOF != ch) &&
#endif /* _UNICODE */
#endif
                                   // char conditions
                                 ( ( comchr == _T('c')) ||
                                   // string conditions !isspace()
                                   ( ( comchr == _T('s') &&
                                       (!(ch >= _T('\t') && ch <= _T('\r')) && 
                                       ch != _T(' ')))) ||
                                   // BRACKET conditions
                                   ( (comchr == LEFT_BRACKET) &&
                                     ((table[ch >> 3] ^ reject) & (1 << (ch & 7)))
                                     )
                                   )
                                )
                            {
                                if (!suppress) {
#ifndef _UNICODE
                                    if (fl_wchar_arg) {
                                        char temp[2];
                                        temp[0] = (char) ch;
                                        if (isleadbyte(ch))
                                            temp[1] = (char) INC();
                                        mbtowc(&wctemp, temp, MB_CUR_MAX);
                                        *(wchar_t UNALIGNED *)pointer =
                                          wctemp;
                                        /* do nothing if mbtowc fails */
                                        pointer = (wchar_t *)pointer + 1;
                                    } else
#else
                                    if (fl_wchar_arg) {
                                        *(wchar_t UNALIGNED *)pointer = ch;
                                        pointer = (wchar_t *)pointer + 1;
                                    } else
#endif
                                    {
#ifndef _UNICODE
                                    *(char *)pointer = (char)ch;
                                    pointer = (char *)pointer + 1;
#else
                                    int temp;
                                    /* convert wide to multibyte */
                                    temp = wctomb((char *)pointer, ch);
                                    /* do nothing if wctomb fails */
                                    pointer = (char *)pointer + temp;
#endif
                                    }
                                } /* suppress */
                                else {
                                    /* just indicate a match */
                                    start = (_TCHAR *)start + 1;
                                }
                            }
                            else  {
                                UN_INC(ch);
                                break;
                            }
                        }

                        /* make sure something has been matched and, if
                           assignment is not suppressed, null-terminate
                           output string if comchr != c */

                        if (start != pointer) {
                            if (!suppress) {
                                ++count;
                                if ('c' != comchr) /* null-terminate strings */
                                    if (fl_wchar_arg)
                                        *(wchar_t UNALIGNED *)pointer = L'\0';
                                    else
                                    *(char *)pointer = '\0';
                            } else /*NULL*/;
                        }
                        else
                            goto error_return;

                        break;

                    case _T('i') :      /* could be d, o, or x */

                        comchr = _T('d'); /* use as default */

                    case _T('x'):

                        if (_T('-') == ch) {
                            ++negative;

                            goto x_incwidth;

                        } else if (_T('+') == ch) {
x_incwidth:
                            if (!--width && widthset)
                                ++done_flag;
                            else
                                ch = INC();
                        }

                        if (_T('0') == ch) {

                            if (_T('x') == (_TCHAR)(ch = INC()) || _T('X') == (_TCHAR)ch) {
                                ch = INC();
                                if (widthset) {
                                    width -= 2;
                                    if (width < 1)
                                        ++done_flag;
                                }
                                comchr = _T('x');
                            } else {
                                ++started;
                                if (_T('x') != comchr) {
                                    if (widthset && !--width)
                                        ++done_flag;
                                    comchr = _T('o');
                                }
                                else {
                                    /* scanning a hex number that starts */
                                    /* with a 0. push back the character */
                                    /* currently in ch and restore the 0 */
                                    UN_INC(ch);
                                    ch = _T('0');
                                }
                            }
                        }
                        goto getnum;

                        /* NOTREACHED */

                    case _T('p') :
                        /* force %hp to be treated as %p */
                        longone = 1;
#ifdef  _WIN64
                        /* force %p to be 64 bit in WIN64 */
                        ++integer64;
                        num64 = 0;
#endif
                    case _T('o') :
                    case _T('u') :
                    case _T('d') :

                        if (_T('-') == ch) {
                            ++negative;

                            goto d_incwidth;

                        } else if (_T('+') == ch) {
d_incwidth:
                            if (!--width && widthset)
                                ++done_flag;
                            else
                                ch = INC();
                        }

getnum:
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                        if ( integer64 ) {

                            while (!done_flag) {

                                if (_T('x') == comchr || _T('p') == comchr)

                                    if (_ISXDIGIT(ch)) {
                                        num64 <<= 4;
                                        ch = HEXTODEC(ch);
                                    }
                                    else
                                        ++done_flag;

                                else if (_ISDIGIT(ch))

                                    if (_T('o') == comchr)
                                        if (_T('8') > ch)
                                                num64 <<= 3;
                                        else {
                                                ++done_flag;
                                        }
                                    else /* _T('d') == comchr */
                                        num64 = MUL10(num64);

                                else
                                    ++done_flag;

                                if (!done_flag) {
                                    ++started;
                                    num64 += ch - _T('0');

                                    if (widthset && !--width)
                                        ++done_flag;
                                    else
                                        ch = INC();
                                } else
                                    UN_INC(ch);

                            } /* end of WHILE loop */

                            if (negative)
                                num64 = (unsigned __int64 )(-(__int64)num64);
                        }
                        else {
#endif
                            while (!done_flag) {

                                if (_T('x') == comchr || _T('p') == comchr)

                                    if (_ISXDIGIT(ch)) {
                                        number = (number << 4);
                                        ch = HEXTODEC(ch);
                                    }
                                    else
                                        ++done_flag;

                                else if (_ISDIGIT(ch))

                                    if (_T('o') == comchr)
                                        if (_T('8') > ch)
                                            number = (number << 3);
                                        else {
                                            ++done_flag;
                                        }
                                    else /* _T('d') == comchr */
                                        number = MUL10(number);

                                else
                                    ++done_flag;

                                if (!done_flag) {
                                    ++started;
                                    number += ch - _T('0');

                                    if (widthset && !--width)
                                        ++done_flag;
                                    else
                                        ch = INC();
                                } else
                                    UN_INC(ch);

                            } /* end of WHILE loop */

                            if (negative)
                                number = (unsigned long)(-(long)number);
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                        }
#endif
                        if (_T('F')==comchr) /* expected ':' in long pointer */
                            started = 0;

                        if (started)
                            if (!suppress) {

                                ++count;
assign_num:
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                                if ( integer64 )
                                    *(__int64 UNALIGNED *)pointer = (unsigned __int64)num64;
                                else
#endif
                                if (longone)
                                    *(long UNALIGNED *)pointer = (unsigned long)number;
                                else
                                    *(short UNALIGNED *)pointer = (unsigned short)number;

                            } else /*NULL*/;
                        else
                            goto error_return;

                        break;

                    case _T('n') :      /* char count, don't inc return value */
                        number = charcount;
                        if(!suppress)
                            goto assign_num; /* found in number code above */
                        break;


                    case _T('e') :
                 /* case _T('E') : */
                    case _T('f') :
                    case _T('g') : /* scan a float */
                 /* case _T('G') : */

#ifndef _UNICODE
                        scanptr = floatstring;

                        if (_T('-') == ch) {
                            *scanptr++ = _T('-');
                            goto f_incwidth;

                        } else if (_T('+') == ch) {
f_incwidth:
                            --width;
                            ch = INC();
                        }

                        if (!widthset || width > CVTBUFSIZE)              /* must watch width */
                            width = CVTBUFSIZE;


                        /* now get integral part */

                        while (_ISDIGIT(ch) && width--) {
                            ++started;
                            *scanptr++ = (char)ch;
                            ch = INC();
                        }

                        /* now check for decimal */

                        if (*___decimal_point == (char)ch && width--) {
                            ch = INC();
                            *scanptr++ = *___decimal_point;

                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *scanptr++ = (char)ch;
                                ch = INC();
                            }
                        }

                        /* now check for exponent */

                        if (started && (_T('e') == ch || _T('E') == ch) && width--) {
                            *scanptr++ = 'e';

                            if (_T('-') == (ch = INC())) {

                                *scanptr++ = '-';
                                goto f_incwidth2;

                            } else if (_T('+') == ch) {
f_incwidth2:
                                if (!width--)
                                    ++width;
                                else
                                    ch = INC();
                            }


                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *scanptr++ = (char)ch;
                                ch = INC();
                            }

                        }

                        UN_INC(ch);

                        if (started)
                            if (!suppress) {
                                ++count;
                                *scanptr = '\0';
                                _fassign( longone-1, pointer , floatstring);
                            } else /*NULL */;
                        else
                            goto error_return;

#else /* _UNICODE */
                        wptr = floatstring;

                        if (L'-' == ch) {
                            *wptr++ = L'-';
                            goto f_incwidthw;

                        } else if (L'+' == ch) {
f_incwidthw:
                            --width;
                            ch = INC();
                        }

                        if (!widthset || width > CVTBUFSIZE)
                            width = CVTBUFSIZE;


                        /* now get integral part */

                        while (_ISDIGIT(ch) && width--) {
                            ++started;
                            *wptr++ = ch;
                            ch = INC();
                        }

                        /* now check for decimal */

                        /* convert decimal point to wide-char */
                        /* assume result is single wide-char */
                        mbtowc (&wdecimal, ___decimal_point, MB_CUR_MAX);

                        if (wdecimal == ch && width--) {
                            ch = INC();
                            *wptr++ = wdecimal;

                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *wptr++ = ch;
                                ch = INC();
                            }
                        }

                        /* now check for exponent */

                        if (started && (L'e' == ch || L'E' == ch) && width--) {
                            *wptr++ = L'e';

                            if (L'-' == (ch = INC())) {

                                *wptr++ = L'-';
                                goto f_incwidth2w;

                            } else if (L'+' == ch) {
f_incwidth2w:
                                if (!width--)
                                    ++width;
                                else
                                    ch = INC();
                            }


                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *wptr++ = ch;
                                ch = INC();
                            }

                        }

                        UN_INC(ch);

                        if (started)
                            if (!suppress) {
                                ++count;
                                *wptr = '\0';
                                {
                                /* convert floatstring to char string */
                                /* and do the conversion */
                                size_t cfslength;
                                char *cfloatstring;
                                cfslength =(size_t)(wptr-floatstring+1)*sizeof(wchar_t);
                                if ((cfloatstring = (char *)_malloc_crt (cfslength)) == NULL)
                                    goto error_return;
                                wcstombs (cfloatstring, floatstring, cfslength);
                                _fassign( longone-1, pointer , cfloatstring);
                                _free_crt (cfloatstring);
                                }
                            } else /*NULL */;
                        else
                            goto error_return;

#endif /* _UNICODE */
                        break;


                    default:    /* either found '%' or something else */

                        if ((int)*format != (int)ch) {
                            UN_INC(ch);
                            goto error_return;
                            }
                        else
                            match--; /* % found, compensate for inc below */

                        if (!suppress)
                            arglist = arglistsave;

                } /* SWITCH */

                match++;        /* matched a format field - set flag */

            } /* WHILE (width) */

            else {  /* zero-width field in format string */
                UN_INC(ch);  /* check for input error */
                goto error_return;
            }

            ++format;  /* skip to next char */

        } else  /*  ('%' != *format) */
            {

            if ((int)*format++ != (int)(ch = INC()))
                {
                UN_INC(ch);
                goto error_return;
                }
#ifndef _UNICODE
            if (isleadbyte(ch))
                {
                int ch2;
                if ((int)*format++ != (ch2=INC()))
                    {
                    UN_INC(ch2);
                    UN_INC(ch);
                    goto error_return;
                    }

                    --charcount; /* only count as one character read */
                }
#endif
            }

#ifndef CPRFLAG
        if ( (EOF == ch) && ((*format != '%') || (*(format + 1) != 'n')) )
            break;
#endif

    }  /* WHILE (*format) */

error_return:
#if ALLOC_TABLE
    if (malloc_flag == 1)
        _free_crt(table);
#endif

#ifndef CPRFLAG
    if (EOF == ch)
        /* If any fields were matched or assigned, return count */
        return ( (count || match) ? count : EOF);
    else
#endif
        return count;

}

/* _hextodec() returns a value of 0-15 and expects a char 0-9, a-f, A-F */
/* _inc() is the one place where we put the actual getc code. */
/* _whiteout() returns the first non-blank character, as defined by isspace() */

#ifndef _UNICODE
static int __cdecl _hextodec (
    int chr
    )
{
    return _ISDIGIT(chr) ? chr : (chr & ~(_T('a') - _T('A'))) - _T('A') + 10 + _T('0');
}
#else
static _TCHAR __cdecl _hextodec (
    _TCHAR chr
    )
{
    if (_ISDIGIT(chr))
        return chr;
    if (_istlower(chr))
        return (_TCHAR)(chr - _T('a') + 10 + _T('0'));
    else
        return (_TCHAR)(chr - _T('A') + 10 + _T('0'));
}
#endif


#ifdef CPRFLAG

#ifndef _UNICODE
static int __cdecl _inc (
    void
    )
{
    return(_getche_lk());
}

static void __cdecl _un_inc (
    int chr
    )
{
    if (EOF != chr)
        _ungetch_lk(chr);
}

static int __cdecl _whiteout (
    REG1 int *counter
    )
{
    REG2 int ch;

    while((_istspace)(ch = (++*counter, _inc())));
    return ch;
}
#else /* _UNICODE */
static wchar_t __cdecl _inc (
    void
    )
{
    return(_getwche_lk());
}

static void __cdecl _un_inc (
    wchar_t chr
    )
{
    if (WEOF != chr)
        _ungetwch_lk(chr);
}

static wchar_t __cdecl _whiteout (
    REG1 int *counter
    )
{
    REG2 wchar_t ch;

    while((iswspace)(ch = (++*counter, _inc())));
    return ch;
}
#endif

#else /* CPRFLAG */

#ifdef _UNICODE
/*
 * Manipulate wide-chars in a file.
 * A wide-char is hard-coded to be two chars for efficiency.
 */

static wchar_t __cdecl _inc (
    REG1 FILE *fileptr
    )
{
    return(_getwc_lk(fileptr));
}

static void __cdecl _un_inc (
    wchar_t chr,
    FILE *fileptr
    )
{
    if (WEOF != chr)
        _ungetwc_lk(chr, fileptr);
}

static wchar_t __cdecl _whiteout (
    REG1 int *counter,
    REG3 FILE *fileptr
    )
{
    REG2 wchar_t ch;

    while((iswspace)(ch = (++*counter, _inc(fileptr))));
    return ch;
}

#else /* _UNICODE */

static int __cdecl _inc (
    REG1 FILE *fileptr
    )
{
    return(_getc_lk(fileptr));
}

static void __cdecl _un_inc (
    int chr,
    FILE *fileptr
    )
{
    if (EOF != chr)
        _ungetc_lk(chr, fileptr);
}

static int __cdecl _whiteout (
    REG1 int *counter,
    REG3 FILE *fileptr
    )
{
    REG2 int ch;

    while((_istspace)(ch = (++*counter, _inc(fileptr))));
    return ch;
}

#endif /* _UNICODE */
#endif /* CPRFLAG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\maketab.c ===
/* make the lookup table for output.asm */

#define TABLESIZE  ('x' - ' ' + 1)


/* possible states to be in */
#define NORMAL	  0 /* normal character to be output */
#define PERCENT   1 /* just read percent sign */
#define FLAG	  2 /* just read a flag character */
#define WIDTH	  3 /* just read a width specification character */
#define DOT	  4 /* just read a dot between width and precision */
#define PRECIS	  5 /* just read a precision specification character */
#define SIZE	  6 /* just read a size specification character */
#define TYPE	  7 /* just read a conversion specification character */
#define BOGUS	  0 /* bogus state - print the character literally */

#define NUMSTATES 8

/* possible types of characters to read */
#define CH_OTHER   0   /* character with no special meaning */
#define CH_PERCENT 1   /* '%' */
#define CH_DOT	   2   /* '.' */
#define CH_STAR    3   /* '*' */
#define CH_ZERO    4   /* '0' */
#define CH_DIGIT   5   /* '1'..'9' */
#define CH_FLAG    6   /* ' ', '+', '-', '#' */
#define CH_SIZE    7   /* 'h', 'l', 'L', 'N', 'F', 'w' */
#define CH_TYPE    8   /* conversion specified character */

#define NUMCHARS 9

unsigned char table[TABLESIZE];   /* the table we build */



/* this is the state table */

int statetable[NUMSTATES][NUMCHARS] = {
/* state,	other	    %	    .	    *	    0	    digit   flag    size    type  */

/* NORMAL */  { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL },
/* PERCENT */ { BOGUS,	  NORMAL,   DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* FLAG */    { BOGUS,	  BOGUS,    DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* WIDTH */   { BOGUS,	  BOGUS,    DOT,    BOGUS,  WIDTH,  WIDTH,  BOGUS,  SIZE,   TYPE },
/* DOT */     { BOGUS,	  BOGUS,    BOGUS,  PRECIS, PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* PRECIS */  { BOGUS,	  BOGUS,    BOGUS,  BOGUS,  PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* SIZE */    { BOGUS,	  BOGUS,    BOGUS,  BOGUS,  BOGUS,  BOGUS,  BOGUS,  SIZE,   TYPE },
/* TYPE */    { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL }
};

/* this determines what type of character ch is */

static int chartype (
	int ch
	)
{
    if (ch < ' ' || ch > 'z')
	return CH_OTHER;
    if (ch == '%')
	return CH_PERCENT;
    if (ch == '.')
	return CH_DOT;
    if (ch == '*')
	return CH_STAR;
    if (ch == '0')
	return CH_ZERO;
    if (strchr("123456789", ch))
	return CH_DIGIT;
    if (strchr(" +-#", ch))
	return CH_FLAG;
    if (strchr("hlLNFw", ch))
	return CH_SIZE;
    if (strchr("diouxXfeEgGcspnCSZ", ch))
	return CH_TYPE;
    return CH_OTHER;
}


main()
{
	int ch;
	int state, class;
	int i;

	for (ch = ' '; ch <= 'x'; ++ch) {
		table[ch-' '] = chartype(ch);
	}

	for (state = NORMAL; state <= TYPE; ++state)
		for (class = CH_OTHER; class <= CH_TYPE; ++class)
			table[class*8+state] |= statetable[state][class]<<4;

	for (i = 0; i < TABLESIZE; ++i) {
		if (i % 8 == 0)
			printf("\ndb\t %.2xh", table[i]);
		else
			printf(", %.2xh", table[i]);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\ncommode.c ===
/***
*ncommode.c - set global file commit mode flag to nocommit
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to nocommit.  This is the default.
*
*Revision History:
*       07-11-90  SBM   Module created, based on asm version.
*       04-05-94  GJF   Added conditional so this definition doesn't make it
*                       into the msvcrt*.dll for Win32s.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>

/* set default file commit mode to nocommit */
int _commode = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\maketabc.c ===
/***
*maketabc.c - program to generate printf format specifier lookup table for
*             output.c
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This program writes to stdout the lookuptable values needed by
*       output.c
*
*Revision History:
*       06-01-89  PHG   Module created
*        1-16-91  SRW   Added extra format codes (_WIN32_)
*        1-16-91  SRW   Fixed output loop to put trailing comma on a line
*       03-11-94  GJF   Recognize 'I' as size modifier.
*       01-04-95  GJF   _WIN32_ -> _WIN32.
*       02-24-95  GJF   Don't recognize 'I' for non-Win32 (Mac merge).
*       07-14-96  RDK   Allow 'I' for Mac size specifier.
*
*******************************************************************************/

#define TABLESIZE  ('x' - ' ' + 1)


/* possible states to be in */
#define NORMAL    0 /* normal character to be output */
#define PERCENT   1 /* just read percent sign */
#define FLAG      2 /* just read a flag character */
#define WIDTH     3 /* just read a width specification character */
#define DOT       4 /* just read a dot between width and precision */
#define PRECIS    5 /* just read a precision specification character */
#define SIZE      6 /* just read a size specification character */
#define TYPE      7 /* just read a conversion specification character */
#define BOGUS     0 /* bogus state - print the character literally */

#define NUMSTATES 8

/* possible types of characters to read */
#define CH_OTHER   0   /* character with no special meaning */
#define CH_PERCENT 1   /* '%' */
#define CH_DOT     2   /* '.' */
#define CH_STAR    3   /* '*' */
#define CH_ZERO    4   /* '0' */
#define CH_DIGIT   5   /* '1'..'9' */
#define CH_FLAG    6   /* ' ', '+', '-', '#' */
#define CH_SIZE    7   /* 'h', 'l', 'L', 'N', 'F' */
#define CH_TYPE    8   /* conversion specified character */

#define NUMCHARS 9

unsigned char table[TABLESIZE];   /* the table we build */



/* this is the state table */

int statetable[NUMSTATES][NUMCHARS] = {
/* state,       other       %       .       *       0       digit   flag    size    type  */

/* NORMAL */  { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL },
/* PERCENT */ { BOGUS,    NORMAL,   DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* FLAG */    { BOGUS,    BOGUS,    DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* WIDTH */   { BOGUS,    BOGUS,    DOT,    BOGUS,  WIDTH,  WIDTH,  BOGUS,  SIZE,   TYPE },
/* DOT */     { BOGUS,    BOGUS,    BOGUS,  PRECIS, PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* PRECIS */  { BOGUS,    BOGUS,    BOGUS,  BOGUS,  PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* SIZE */    { BOGUS,    BOGUS,    BOGUS,  BOGUS,  BOGUS,  BOGUS,  BOGUS,  SIZE,   TYPE },
/* TYPE */    { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL }
};

/* this determines what type of character ch is */

static int chartype (
        int ch
        )
{
    if (ch < ' ' || ch > 'z')
        return CH_OTHER;
    if (ch == '%')
        return CH_PERCENT;
    if (ch == '.')
        return CH_DOT;
    if (ch == '*')
        return CH_STAR;
    if (ch == '0')
        return CH_ZERO;
    if (strchr("123456789", ch))
        return CH_DIGIT;
    if (strchr(" +-#", ch))
        return CH_FLAG;
    if (strchr("hIlLNF", ch))
        return CH_SIZE;
    if (strchr("diouxXfeEgGcspn", ch))
        return CH_TYPE;
#ifdef  _WIN32
    /* Win32 supports three additional format codes for debugging purposes */

    if (strchr("BCS", ch))
        return CH_TYPE;
#endif  /* _WIN32 */

    return CH_OTHER;
}


main()
{
        int ch;
        int state, class;
        int i;

        for (ch = ' '; ch <= 'x'; ++ch) {
                table[ch-' '] = chartype(ch);
        }

        for (state = NORMAL; state <= TYPE; ++state)
                for (class = CH_OTHER; class <= CH_TYPE; ++class)
                        table[class*8+state] |= statetable[state][class]<<4;

        for (i = 0; i < TABLESIZE; ++i) {
                if (i % 8 == 0) {
                        if (i != 0)
                                printf(",");

                        printf("\n\t 0x%.2X", table[i]);
                }
                else
                        printf(", 0x%.2X", table[i]);
        }
        printf("\n");

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\putw.c ===
/***
*putw.c - put a binary int to output stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putw() - puts a binary int to an output stream
*
*Revision History:
*       09-02-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _putw(word, stream) - write a binary int to an output stream
*
*Purpose:
*       Writes sizeof(int) bytes to the output stream, high byte first.
*       This routine should be machine independent.
*
*Entry:
*       int word - integer to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the word put to the stream
*       returns EOF if error, but this is a legit int value, so should
*       test with feof() or ferror().
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _putw (
        int word,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG3 int bytecount = sizeof(int);
        REG2 char *byteptr = (char *)&word;
        int retval;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (bytecount--)
        {
            _putc_lk(*byteptr,stream);
            ++byteptr;
        }
        retval = (ferror(stream) ? EOF : word);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\puts.c ===
/***
*puts.c - put a string to stdout
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines puts() and _putws() - put a string to stdout
*
*Revision History:
*       09-02-83  RN    initial version
*       08-31-84  RN    modified to use new, blazing fast fwrite
*       07-01-87  JCR   made return values conform to ANSI [MSC only]
*       09-24-87  JCR   Added 'const' to declaration [ANSI]
*       11-05-87  JCR   Multi-thread version
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-18-88  JCR   Error return = EOF
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <string.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       01-31-94  CFW   Unicode enable.
*       02-04-94  CFW   Use _putwchar_lk.
*       04-18-94  CFW   Get rid of those pesky warnings.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*int puts(string) - put a string to stdout with newline
*
*Purpose:
*       Write a string to stdout; don't include '\0' but append '\n'.  Uses
*       temporary buffering for efficiency on stdout if unbuffered.
*
*Entry:
*       char *string - string to output
*
*Exit:
*       Good return = 0
*       Error return = EOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _putts (
        const _TCHAR *string
        )
{
        int buffing;
#ifndef _UNICODE
        size_t length;
        size_t ndone;
#endif
        int retval = _TEOF; /* error */

        _ASSERTE(string != NULL);

#ifdef  _MT
        _lock_str2(1, stdout);
        __try {
#endif

        buffing = _stbuf(stdout);

#ifdef  _UNICODE
        while (*string) {
            if (_putwchar_lk(*string++) == WEOF)
                goto done;
        }
        if (_putwchar_lk(L'\n') != WEOF)
            retval = 0;     /* success */
#else       
        length = strlen(string);
        ndone = _fwrite_lk(string,1,length,stdout);

        if (ndone == length) {
            _putc_lk('\n',stdout);
            retval = 0;     /* success */
        }
#endif

#ifdef  _UNICODE
done:
#endif
        _ftbuf(buffing, stdout);

#ifdef  _MT
        }
        __finally {
            _unlock_str2(1, stdout);
        }
#endif

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\output.c ===
/***
*output.c - printf style output to a FILE
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the code that does all the work for the
*       printf family of functions.  It should not be called directly, only
*       by the *printf functions.  We don't make any assumtions about the
*       sizes of ints, longs, shorts, or long doubles, but if types do overlap,
*       we also try to be efficient.  We do assume that pointers are the same
*       size as either ints or longs.
*       If CPRFLAG is defined, defines _cprintf instead.
*       **** DOESN'T CURRENTLY DO MTHREAD LOCKING ****
*
*Revision History:
*       06-01-89  PHG   Module created
*       08-28-89  JCR   Added cast to get rid of warning (no object changes)
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Changed LOCAL macro to incorporate _CALLTYPE4. Placed
*                       prototype for _output() in internal.h and #include-d
*                       it.
*       08-01-90  SBM   Compiles cleanly with -W3, moved _cfltcvt_tab and
*                       typedefs DOUBLE and LONGDOUBLE to new header
*                       <fltintrn.h>, formerly named <struct.h>
*       09-05-90  SBM   First attempt at adding CPRFLAG and code to generate
*                       cprintf.  Anything in #ifdef CPRFLAG untested.
*                       Still needs to have locking added for MTHREAD case.
*       10-03-90  GJF   New-style function declarators.
*       01-02-91  SRW   Added _WIN32_ conditional for 'C' and 'S' format chars.
*       01-16-91  GJF   ANSI naming.
*       01-16-91  SRW   Added #include of maketabc.out (_WIN32_)
*       04-09-91  PNT   Use the _CRUISER_ mapping for _MAC_
*       04-16-91  SRW   Fixed #include of maketabc.out (_WIN32_)
*       04-25-91  SRW   Made nullstring static
*       05-20-91  GJF   Moved state table for Win32 inline (_WIN32_).
*       09-12-91  JCR   Bumped conversion buffer size to be ANSI-compliant
*       09-17-91  IHJ   Add partial UNICODE (%ws, %wc) support
*       09-28-91  GJF   Merged with crt32 and crtdll versions. For now, 9-17-91
*                       change is built only for Win32, not Dosx32 (_WIN32_).
*       10-22-91  ETC   Complete wchar_t/mb support under _INTL.  For now,
*                       9-28-91 change is additionally under !_INTL.  Bug fix:
*                       ints and pointers are longs.
*       11-19-91  ETC   Added support for _wsprintf, _vwsprintf with WPRFLAG;
*                       added %tc %ts (generic string handling).
*       12-05-91  GDP   Bug fix: va_arg was used inconsistently for double
*       12-19-91  ETC   Added some comments on wsprintf optimization, undones;
*                       check return on malloc.
*       03-25-92  DJM   POSIX support
*       04-16-92  KRS   Support new ISO {s|f}wprintf with Unicode format string.
*       06-08-92  SRW   Modified to not use free and malloc for mbtowc conversion.
*       06-10-92  KRS   Fix glitch in previous change.
*       07-17-92  KRS   Fix typo which broke WPRFLAG support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-16-93  SKS   Fix bug in 'S' option logic.
*       04-26-93  CFW   Wide char enable.
*       07-14-93  TVB   Added Alpha support (quad stuff).
*       07-16-93  SRW   ALPHA Merge
*       07-26-93  GJF   Fixed write_multichar and write_string so that they
*                       stop looping when an error occurs. This generalizes
*                       and supplants the fix MattBr made for POSIX only.
*       08-17-93  CFW   Avoid mapping tchar macros incorrectly if _MBCS
*                       defined.
*       11-10-93  GJF   Merged in NT SDK version. Deleted Cruiser support
*                       and references to _WIN32_ (the former is obsolete and
*                       the later is assumed).
*       03-10-94  GJF   Added support for I64 size modifier.
*       03-25-94  GJF   Rebuilt __lookuptable[].
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       10-02-94  BWT   Add _M_PPC definition.
*       10-19-94  BWT   Reenable %Z and %ws/%wc for NT_BUILD only.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-23-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also, replaced
*                       WPRFLAG with _UNICODE.
*       05-03-96  GJF   Removed NT_BUILD. The extensions for NT (i.e., the 'Z'
*                       descriptor and 'w' modifier) are now in the retail
*                       build. Fixed textlen calculation for %ws. Also, 
*                       detab-ed.
*       07-25-96  SKS   Added initialization of textlen for cases where no valid
*                       format character is found after the % character.
*       08-01-96  RDK   Add support for %I64 for PMac.
*       09-09-96  JWM   Local struct "string" renamed to "_count_string" (Orion
*                       8710).
*       02-27-98  RKP   Added 64 bit support.
*       03-05-98  RKP   Expanded pointers to 64 bits on AXP64 and IA64.
*       09-17-98  GJF   Added support for %I32 and %I modifiers.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  GB    VS7#5431. Fixed output() for the case when L format
*                       specifier is used with wprintf
*       11-30-99  PML   Compile /Wp64 clean.
*       02-11-00  GB    Added support for unicode console output function
*                       (_cwprintf).
*       03-10-00  GB    Modified write_char for NULL pointer string in
*                       sprintf.
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*       07-05-01  BWT   Turn off %n formatting for NTSUBSET - it's a security hole
*                       waiting to happen.
*       07-15-01  PML   Remove all ALPHA, MIPS, and PPC code
*       08-11-01  PML   Cap precision to fix overrun of 'buffer' (vs7#298618)
*
*******************************************************************************/

/* temporary work-around for compiler without 64-bit support */

#ifndef _INTEGRAL_MAX_BITS
#define _INTEGRAL_MAX_BITS  64
#endif


#include <cruntime.h>
#include <limits.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdarg.h>
#include <cvt.h>
#include <conio.h>
#include <internal.h>
#include <fltintrn.h>
#include <stdlib.h>
#include <ctype.h>
#include <dbgint.h>

/* inline keyword is non-ANSI C7 extension */
#if     !defined(_MSC_VER) || defined(__STDC__)
#define __inline static
#else
/* UNDONE: compiler is broken */
#define __inline static
#endif

#ifdef  _MBCS   /* always want either Unicode or SBCS for tchar.h */
#undef  _MBCS
#endif
#include <tchar.h>

/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type> near. */
#define LOCAL(x) static x __cdecl

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
#define LONG_IS_INT      1      /* 1 means long is same size as int */
#define SHORT_IS_INT     0      /* 1 means short is same size as int */
#define LONGDOUBLE_IS_DOUBLE 1  /* 1 means long double is same as double */
#if     defined (_WIN64)
#define PTR_IS_INT       0      /* 1 means ptr is same size as int */
#define PTR_IS_LONG      0      /* 1 means ptr is same size as long */
#define PTR_IS_INT64     1      /* 1 means ptr is same size as int64 */
#else
#define PTR_IS_INT       1      /* 1 means ptr is same size as int */
#define PTR_IS_LONG      1      /* 1 means ptr is same size as long */
#define PTR_IS_INT64     0      /* 1 means ptr is same size as int64 */
#endif

#if     LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#ifndef _UNICODE
#if SHORT_IS_INT
    #define get_short_arg(x) (short)get_int_arg(x)
#endif
#endif

#if     PTR_IS_INT
    #define get_ptr_arg(x) (void *)(intptr_t)get_int_arg(x)
#elif   PTR_IS_LONG
    #define get_ptr_arg(x) (void *)(intptr_t)get_long_arg(x)
#elif   PTR_IS_INT64
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif



/* CONSTANTS */

/* size of conversion buffer (ANSI-specified minimum is 509) */

#define BUFFERSIZE    512
#define MAXPRECISION  BUFFERSIZE

#if     BUFFERSIZE < CVTBUFSIZE + 6 /*IFSTRIP=IGN*/
/*
 * Buffer needs to be big enough for default minimum precision
 * when converting floating point needs bigger buffer, and malloc
 * fails
 */
#error Conversion buffer too small for max double.
#endif

/* flag definitions */
#define FL_SIGN       0x00001   /* put plus or minus in front */
#define FL_SIGNSP     0x00002   /* put space or minus in front */
#define FL_LEFT       0x00004   /* left justify */
#define FL_LEADZERO   0x00008   /* pad with leading zeros */
#define FL_LONG       0x00010   /* long value given */
#define FL_SHORT      0x00020   /* short value given */
#define FL_SIGNED     0x00040   /* signed data given */
#define FL_ALTERNATE  0x00080   /* alternate form requested */
#define FL_NEGATIVE   0x00100   /* value is negative */
#define FL_FORCEOCTAL 0x00200   /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x00400   /* long double value given */
#define FL_WIDECHAR   0x00800   /* wide characters */
#define FL_I64        0x08000   /* __int64 value given */

/* state definitions */
enum STATE {
    ST_NORMAL,          /* normal state; outputting literal chars */
    ST_PERCENT,         /* just read '%' */
    ST_FLAG,            /* just read flag character */
    ST_WIDTH,           /* just read width specifier */
    ST_DOT,             /* just read '.' */
    ST_PRECIS,          /* just read precision specifier */
    ST_SIZE,            /* just read size specifier */
    ST_TYPE             /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,           /* character with no special meaning */
    CH_PERCENT,         /* '%' */
    CH_DOT,             /* '.' */
    CH_STAR,            /* '*' */
    CH_ZERO,            /* '0' */
    CH_DIGIT,           /* '1'..'9' */
    CH_FLAG,            /* ' ', '+', '-', '#' */
    CH_SIZE,            /* 'h', 'l', 'L', 'N', 'F', 'w' */
    CH_TYPE             /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
#if     defined(_UNICODE) || defined(CPRFLAG)
extern char *__nullstring;  /* string to print on null ptr */
extern wchar_t *__wnullstring;  /* string to print on null ptr */
#else   /* _UNICODE || CPRFLAG */
char *__nullstring = "(null)";  /* string to print on null ptr */
wchar_t *__wnullstring = L"(null)";/* string to print on null ptr */
#endif  /* _UNICODE || CPRFLAG */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketabc.c -- use this program to make       */
/* changes.                                                               */

#if     defined(_UNICODE) || defined(CPRFLAG)

extern const char __lookuptable[];

#else   /* _UNICODE/CPRFLAG */

const char __lookuptable[] = {
 /* ' ' */  0x06,
 /* '!' */  0x00,
 /* '"' */  0x00,
 /* '#' */  0x06,
 /* '$' */  0x00,
 /* '%' */  0x01,
 /* '&' */  0x00,
 /* ''' */  0x00,
 /* ('' */  0x10,
 /* ')' */  0x00,
 /* '*' */  0x03,
 /* '+' */  0x06,
 /* ',' */  0x00,
 /* '-' */  0x06,
 /* '.' */  0x02,
 /* '/' */  0x10,
 /* '0' */  0x04,
 /* '1' */  0x45,
 /* '2' */  0x45,
 /* '3' */  0x45,
 /* '4' */  0x05,
 /* '5' */  0x05,
 /* '6' */  0x05,
 /* '7' */  0x05,
 /* '8' */  0x05,
 /* '9' */  0x35,
 /* ':' */  0x30,
 /* ';' */  0x00,
 /* '<' */  0x50,
 /* '=' */  0x00,
 /* '>' */  0x00,
 /* '?' */  0x00,
 /* '@' */  0x00,
 /* 'A' */  0x20,
 /* 'B' */  0x28,
 /* 'C' */  0x38,
 /* 'D' */  0x50,
 /* 'E' */  0x58,
 /* 'F' */  0x07,
 /* 'G' */  0x08,
 /* 'H' */  0x00,
 /* 'I' */  0x37,
 /* 'J' */  0x30,
 /* 'K' */  0x30,
 /* 'L' */  0x57,
 /* 'M' */  0x50,
 /* 'N' */  0x07,
 /* 'O' */  0x00,
 /* 'P' */  0x00,
 /* 'Q' */  0x20,
 /* 'R' */  0x20,
 /* 'S' */  0x08,
 /* 'T' */  0x00,
 /* 'U' */  0x00,
 /* 'V' */  0x00,
 /* 'W' */  0x00,
 /* 'X' */  0x08,
 /* 'Y' */  0x60,
 /* 'Z' */  0x68,
 /* '[' */  0x60,
 /* '\' */  0x60,
 /* ']' */  0x60,
 /* '^' */  0x60,
 /* '_' */  0x00,
 /* '`' */  0x00,
 /* 'a' */  0x70,
 /* 'b' */  0x70,
 /* 'c' */  0x78,
 /* 'd' */  0x78,
 /* 'e' */  0x78,
 /* 'f' */  0x78,
 /* 'g' */  0x08,
 /* 'h' */  0x07,
 /* 'i' */  0x08,
 /* 'j' */  0x00,
 /* 'k' */  0x00,
 /* 'l' */  0x07,
 /* 'm' */  0x00,
#ifdef _NTSUBSET_
 /* 'n' */  0x00,       // Disable %n format for kernel (ST_NORMAL|CH_OTHER)
#else
 /* 'n' */  0x08,
#endif
 /* 'o' */  0x08,
 /* 'p' */  0x08,
 /* 'q' */  0x00,
 /* 'r' */  0x00,
 /* 's' */  0x08,
 /* 't' */  0x00,
 /* 'u' */  0x08,
 /* 'v' */  0x00,
 /* 'w' */  0x07,
 /* '*' */  0x08
};

#endif  /* _UNICODE || CPRFLAG */

#define find_char_class(c)      \
        ((c) < _T(' ') || (c) > _T('x') ? \
            CH_OTHER            \
            :               \
        __lookuptable[(c)-_T(' ')] & 0xF)

#define find_next_state(class, state)   \
        (__lookuptable[(class) * NUMSTATES + (state)] >> 4)


/*
 * Note: CPRFLAG and _UNICODE cases are currently mutually exclusive.
 */

/* prototypes */

#ifdef  CPRFLAG

#define WRITE_CHAR(ch, pnw)         write_char(ch, pnw)
#define WRITE_MULTI_CHAR(ch, num, pnw)  write_multi_char(ch, num, pnw)
#define WRITE_STRING(s, len, pnw)   write_string(s, len, pnw)
#define WRITE_WSTRING(s, len, pnw)  write_wstring(s, len, pnw)

LOCAL(void) write_char(_TCHAR ch, int *pnumwritten);
LOCAL(void) write_multi_char(_TCHAR ch, int num, int *pnumwritten);
LOCAL(void) write_string(_TCHAR *string, int len, int *numwritten);
LOCAL(void) write_wstring(wchar_t *string, int len, int *numwritten);

#else

#define WRITE_CHAR(ch, pnw)         write_char(ch, stream, pnw)
#define WRITE_MULTI_CHAR(ch, num, pnw)  write_multi_char(ch, num, stream, pnw)
#define WRITE_STRING(s, len, pnw)   write_string(s, len, stream, pnw)
#define WRITE_WSTRING(s, len, pnw)  write_wstring(s, len, stream, pnw)

LOCAL(void) write_char(_TCHAR ch, FILE *f, int *pnumwritten);
LOCAL(void) write_multi_char(_TCHAR ch, int num, FILE *f, int *pnumwritten);
LOCAL(void) write_string(_TCHAR *string, int len, FILE *f, int *numwritten);
LOCAL(void) write_wstring(wchar_t *string, int len, FILE *f, int *numwritten);

#endif

__inline int __cdecl get_int_arg(va_list *pargptr);

#ifndef _UNICODE
#if     !SHORT_IS_INT
__inline short __cdecl get_short_arg(va_list *pargptr);
#endif
#endif

#if     !LONG_IS_INT
__inline long __cdecl get_long_arg(va_list *pargptr);
#endif

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
__inline __int64 __cdecl get_int64_arg(va_list *pargptr);
#endif

#ifdef  CPRFLAG
LOCAL(int) output(const _TCHAR *, va_list);

/***
*int _cprintf(format, arglist) - write formatted output directly to console
*
*Purpose:
*   Writes formatted data like printf, but uses console I/O functions.
*
*Entry:
*   char *format - format string to determine data formats
*   arglist - list of POINTERS to where to put data
*
*Exit:
*   returns number of characters written
*
*Exceptions:
*
*******************************************************************************/
#ifdef _UNICODE
int __cdecl _cwprintf (
#else
int __cdecl _cprintf (
#endif
        const _TCHAR * format,
        ...
        )
{
        va_list arglist;

        va_start(arglist, format);

        return output(format, arglist);
}

#endif  /* CPRFLAG */


/***
*int _output(stream, format, argptr), static int output(format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, _output assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   FILE *stream   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*ifdef _UNICODE
*   The wide-character flavour returns the number of wide-characters written.
*endif
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG
LOCAL(int) output (
#else

#ifdef  _UNICODE
int __cdecl _woutput (
    FILE *stream,
#else
int __cdecl _output (
    FILE *stream,
#endif

#endif
    const _TCHAR *format,
    va_list argptr
    )
{
    int hexadd;     /* offset to add to number to get 'a'..'f' */
    TCHAR ch;       /* character just read */
    int flags;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;      /* current conversion radix */
    int charsout;   /* characters currently written so far, -1 = IO error */
    int fldwidth;   /* selected field width -- 0 means default */
    int precision;  /* selected precision  -- -1 means default */
    TCHAR prefix[2];    /* numeric prefix -- up to two characters */
    int prefixlen;  /* length of prefix -- 0 means no prefix */
    int capexp;     /* non-zero = 'E' exponent signifient, zero = 'e' */
    int no_output;  /* non-zero = prodcue no output for this specifier */
    union {
        char *sz;   /* pointer text to be printed, not zero terminated */
        wchar_t *wz;
        } text;

    int textlen;    /* length of the text in bytes/wchars to be printed.
                       textlen is in multibyte or wide chars if _UNICODE */
    union {
        char sz[BUFFERSIZE];
#ifdef  _UNICODE
        wchar_t wz[BUFFERSIZE];
#endif
        } buffer;
    wchar_t wchar;      /* temp wchar_t */
    int bufferiswide;   /* non-zero = buffer contains wide chars already */
#if !defined(_NTSUBSET_) && !defined(_POSIX_)
    char *heapbuf = NULL; /* non-zero = test.sz using heap buffer to be freed */
#endif

    textlen = 0;        /* no text yet */
    charsout = 0;       /* no characters written yet */
    state = ST_NORMAL;  /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != _T('\0') && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:

        NORMAL_STATE:

            /* normal state -- just write character */
#ifdef  _UNICODE
            bufferiswide = 1;
#else
            bufferiswide = 0;
            if (isleadbyte((int)(unsigned char)ch)) {
                WRITE_CHAR(ch, &charsout);
                ch = *format++;
                _ASSERTE (ch != _T('\0')); /* UNDONE: don't fall off format string */
            }
#endif  /* !_UNICODE */
            WRITE_CHAR(ch, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            bufferiswide = 0;   /* default */
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case _T('-'):
                flags |= FL_LEFT;   /* '-' => left justify */
                break;
            case _T('+'):
                flags |= FL_SIGN;   /* '+' => force sign indicator */
                break;
            case _T(' '):
                flags |= FL_SIGNSP; /* ' ' => force sign or space */
                break;
            case _T('#'):
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case _T('0'):
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == _T('*')) {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - _T('0'));
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == _T('*')) {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1; /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - _T('0'));
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
            case _T('l'):
                flags |= FL_LONG;   /* 'l' => long int or wchar_t */
                break;

            case _T('I'):
                /*
                 * In order to handle the I, I32, and I64 size modifiers, we
                 * depart from the simple deterministic state machine. The
                 * code below scans for characters following the 'I',
                 * and defaults to 64 bit on WIN64 and 32 bit on WIN32
                 */
#if     PTR_IS_INT64
                flags |= FL_I64;    /* 'I' => __int64 on WIN64 systems */
#endif
                if ( (*format == _T('6')) && (*(format + 1) == _T('4')) )
                {
                    format += 2;
                    flags |= FL_I64;    /* I64 => __int64 */
                }
                else if ( (*format == _T('3')) && (*(format + 1) == _T('2')) )
                {
                    format += 2;
                    flags &= ~FL_I64;   /* I32 => __int32 */
                }
                else if ( (*format == _T('d')) ||
                          (*format == _T('i')) ||
                          (*format == _T('o')) ||
                          (*format == _T('u')) ||
                          (*format == _T('x')) ||
                          (*format == _T('X')) )
                {
                   /*
                    * Nothing further needed.  %Id (et al) is
                    * handled just like %d, except that it defaults to 64 bits
                    * on WIN64.  Fall through to the next iteration.
                    */
                }
                else {
                    state = ST_NORMAL;
                    goto NORMAL_STATE;
                }
                break;

            case _T('h'):
                flags |= FL_SHORT;  /* 'h' => short int or char */
                break;

/* UNDONE: support %wc and %ws for now only for compatibility */
            case _T('w'):
                flags |= FL_WIDECHAR;  /* 'w' => wide character */
                break;

            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is done in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case _T('C'):   /* ISO wide character */
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
#ifdef  _UNICODE
                    flags |= FL_SHORT;
#else
                    flags |= FL_WIDECHAR;   /* ISO std. */
#endif
                /* fall into 'c' case */

            case _T('c'): {
                /* print a single character specified by int argument */
#ifdef  _UNICODE
                bufferiswide = 1;
                wchar = (wchar_t) get_int_arg(&argptr);
                if (flags & FL_SHORT) {
                    /* format multibyte character */
                    /* this is an extension of ANSI */
                    char tempchar[2];
#ifdef  _OUT
                    if (isleadbyte(wchar >> 8)) {
                        tempchar[0] = (wchar >> 8);
                        tempchar[1] = (wchar & 0x00ff);
                    }
                    else
#endif  /* _OUT */
                    {
                        tempchar[0] = (char)(wchar & 0x00ff);
                        tempchar[1] = '\0';
                    }

                    if (mbtowc(buffer.wz,tempchar,MB_CUR_MAX) < 0) {
                        /* ignore if conversion was unsuccessful */
                        no_output = 1;
                    }
                } else {
                    buffer.wz[0] = wchar;
                }
                text.wz = buffer.wz;
                textlen = 1;    /* print just a single character */
#else   /* _UNICODE */
                if (flags & (FL_LONG|FL_WIDECHAR)) {
                    wchar = (wchar_t) get_short_arg(&argptr);
                    /* convert to multibyte character */
                    textlen = wctomb(buffer.sz, wchar);

                    /* check that conversion was successful */
                    if (textlen < 0)
                        no_output = 1;
                } else {
                    /* format multibyte character */
                    /* this is an extension of ANSI */
                    unsigned short temp;
                    temp = (unsigned short) get_int_arg(&argptr);
#ifdef  _OUT
                    if (isleadbyte(temp >> 8)) {
                        buffer.sz[0] = temp >> 8;
                        buffer.sz[1] = temp & 0x00ff;
                        textlen = 2;
                    } else
#endif  /* _OUT */
                    {
                        buffer.sz[0] = (char) temp;
                        textlen = 1;
                    }
                }
                text.sz = buffer.sz;
#endif  /* _UNICODE */
            }
            break;

            case _T('Z'): {
                /* print a Counted String

                int i;
                char *p;       /* temps */
                struct _count_string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text.sz = __nullstring;
                    textlen = (int)strlen(text.sz);
                } else {
                    if (flags & FL_WIDECHAR) {
                        text.wz = (wchar_t *)pstr->Buffer;
                        textlen = pstr->Length / (int)sizeof(wchar_t);
                        bufferiswide = 1;
                    } else {
                        bufferiswide = 0;
                        text.sz = pstr->Buffer;
                        textlen = pstr->Length;
                    }
                }
            }
            break;

            case _T('S'):   /* ISO wide character string */
#ifndef _UNICODE
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
                    flags |= FL_WIDECHAR;
#else
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
                    flags |= FL_SHORT;
#endif

            case _T('s'): {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */
                wchar_t *pwch;

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;
                text.sz = get_ptr_arg(&argptr);

/* UNDONE: handle '#' case properly */
                /* scan for null upto i characters */
#ifdef  _UNICODE
                if (flags & FL_SHORT) {
                    if (text.sz == NULL) /* NULL passed, use special string */
                        text.sz = __nullstring;
                    p = text.sz;
                    for (textlen=0; textlen<i && *p; textlen++) {
                        if (isleadbyte((int)*p))
                            ++p;
                        ++p;
                    }
                    /* textlen now contains length in multibyte chars */
                } else {
                    if (text.wz == NULL) /* NULL passed, use special string */
                        text.wz = __wnullstring;
                    bufferiswide = 1;
                    pwch = text.wz;
                    while (i-- && *pwch)
                        ++pwch;
                    textlen = (int)(pwch - text.wz);       /* in wchar_ts */
                    /* textlen now contains length in wide chars */
                }
#else   /* _UNICODE */
                if (flags & (FL_LONG|FL_WIDECHAR)) {
                    if (text.wz == NULL) /* NULL passed, use special string */
                        text.wz = __wnullstring;
                    bufferiswide = 1;
                    pwch = text.wz; 
                    while ( i-- && *pwch )
                        ++pwch;
                    textlen = (int)(pwch - text.wz);
                    /* textlen now contains length in wide chars */
                } else {
                    if (text.sz == NULL) /* NULL passed, use special string */
                        text.sz = __nullstring;
                    p = text.sz;
                    while (i-- && *p)
                        ++p;
                    textlen = (int)(p - text.sz);    /* length of the string */
                }

#endif  /* _UNICODE */
            }
            break;


            case _T('n'): {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if     !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if     !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


            case _T('E'):
            case _T('G'):
                capexp = 1;                 /* capitalize exponent */
                ch += _T('a') - _T('A');    /* convert format char to lower */
                /* DROP THROUGH */
            case _T('e'):
            case _T('f'):
            case _T('g'): {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text.sz = buffer.sz;        /* put result in buffer */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;          /* default precision: 6 */
                else if (precision == 0 && ch == _T('g'))
                    precision = 1;          /* ANSI specified */
                else if (precision > MAXPRECISION)
                    precision = MAXPRECISION;

                if (precision > BUFFERSIZE - CVTBUFSIZE) {
#if !defined(_NTSUBSET_) && !defined(_POSIX_)
                    /* conversion will potentially overflow local buffer */
                    /* so we need to use a heap-allocated buffer.        */
                    heapbuf = (char *)_malloc_crt(CVTBUFSIZE + precision);
                    if (heapbuf != NULL)
                        text.sz = heapbuf;
                    else
                        /* malloc failed, cap precision further */
#endif
                        precision = BUFFERSIZE - CVTBUFSIZE;
                }

#if     !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    LONGDOUBLE tmp;
                    tmp=va_arg(argptr, LONGDOUBLE);
                    /* Note: assumes ch is in ASCII range */
                    _cldcvt(&tmp, text.sz, (char)ch, precision, capexp);
                } else
#endif
                {
                    DOUBLE tmp;
                    tmp=va_arg(argptr, DOUBLE);
                    /* Note: assumes ch is in ASCII range */
                    _cfltcvt(&tmp,text.sz, (char)ch, precision, capexp);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text.sz);

                /* 'g' format means crop zero unless '#' given */
                if (ch == _T('g') && !(flags & FL_ALTERNATE))
                    _cropzeros(text.sz);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text.sz == '-') {
                    flags |= FL_NEGATIVE;
                    ++text.sz;
                }

                textlen = (int)strlen(text.sz);     /* compute length of text */
            }
            break;

            case _T('d'):
            case _T('i'):
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case _T('u'):
                radix = 10;
                goto COMMON_INT;

            case _T('p'):
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if     PTR_IS_INT64
                flags |= FL_I64;                    /* assume we're converting an int64 */
#elif   !PTR_IS_INT
                flags |= FL_LONG;                   /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case _T('X'):
                /* unsigned upper hex output */
                hexadd = _T('A') - _T('9') - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case _T('x'):
                /* unsigned lower hex output */
                hexadd = _T('a') - _T('9') - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = _T('0');
                    prefix[1] = (TCHAR)(_T('x') - _T('a') + _T('9') + 1 + hexadd);  /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case _T('o'):
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

#if     _INTEGRAL_MAX_BITS >= 64        /*IFSTRIP=IGN*/
                unsigned __int64 number;    /* number to convert */
                int digit;              /* ascii value of digit */
                __int64 l;              /* temp long value */
#else
                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */
#endif

                /* 1. read argument into l, sign extend as needed */
#if     _INTEGRAL_MAX_BITS >= 64        /*IFSTRIP=IGN*/
                if (flags & FL_I64)
                    l = get_int64_arg(&argptr);
                else
#endif

#if     !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if     !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                } else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                } else {
                    number = l;
                }

#if     _INTEGRAL_MAX_BITS >= 64        /*IFSTRIP=IGN*/
                if ( (flags & FL_I64) == 0 ) {
                    /*
                     * Unless printing a full 64-bit value, insure values
                     * here are not in cananical longword format to prevent
                     * the sign extended upper 32-bits from being printed.
                     */
                    number &= 0xffffffff;
                }
#endif

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;  /* default precision */
                else {
                    flags &= ~FL_LEADZERO;
                    if (precision > MAXPRECISION)
                        precision = MAXPRECISION;
                }

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text.sz = &buffer.sz[BUFFERSIZE-1];    /* last digit at end of buffer */

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;                /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text.sz-- = (char)digit;       /* store the digit */
                }

                textlen = (int)((char *)&buffer.sz[BUFFERSIZE-1] - text.sz); /* compute length of number */
                ++text.sz;          /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text.sz[0] != '0' || textlen == 0)) {
                    *--text.sz = '0';
                    ++textlen;      /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = _T('-');
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = _T('+');
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = _T(' ');
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    WRITE_MULTI_CHAR(_T(' '), padding, &charsout);
                }

                /* write prefix */
                WRITE_STRING(prefix, prefixlen, &charsout);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    WRITE_MULTI_CHAR(_T('0'), padding, &charsout);
                }

                /* write text */
#ifndef _UNICODE
                if (bufferiswide && (textlen > 0)) {
                    wchar_t *p;
                    int retval, count;
                    char buffer[MB_LEN_MAX+1];

                    p = text.wz;
                    count = textlen;
                    while (count--) {
                        retval = wctomb(buffer, *p++);
                        if (retval <= 0)
                            break;
                        WRITE_STRING(buffer, retval, &charsout);
                    }
                } else {
                    WRITE_STRING(text.sz, textlen, &charsout);
                }
#else
                if (!bufferiswide && textlen > 0) {
                    char *p;
                    int retval, count;

                    p = text.sz;
                    count = textlen;
                    while (count-- > 0) {
                        retval = mbtowc(&wchar, p, MB_CUR_MAX);
                        if (retval <= 0)
                            break;
                        WRITE_CHAR(wchar, &charsout);
                        p += retval;
                    }
                } else {
                    WRITE_STRING(text.wz, textlen, &charsout);
                }
#endif  /* _UNICODE */

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    WRITE_MULTI_CHAR(_T(' '), padding, &charsout);
                }

                /* we're done! */
            }
#if !defined(_NTSUBSET_) && !defined(_POSIX_)
            if (heapbuf) {
                _free_crt(heapbuf);
                heapbuf = NULL;
            }
#endif
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}

/*
 *  Future Optimizations for swprintf:
 *  - Don't free the memory used for converting the buffer to wide chars.
 *    Use realloc if the memory is not sufficient.  Free it at the end.
 */

/***
*void write_char(char ch, int *pnumwritten)
*ifdef _UNICODE
*void write_char(wchar_t ch, FILE *f, int *pnumwritten)
*endif
*void write_char(char ch, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes a single character to the given file/console.  If no error occurs,
*   then *pnumwritten is incremented; otherwise, *pnumwritten is set
*   to -1.
*
*Entry:
*   _TCHAR ch        - character to write
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG

LOCAL(void) write_char (
    _TCHAR ch,
    int *pnumwritten
    )
{
#ifdef  _UNICODE
    if (_putwch_lk(ch) == WEOF)
#else
    if (_putch_lk(ch) == EOF)
#endif  //_UNICODE
        *pnumwritten = -1;
    else
        ++(*pnumwritten);
}

#else

LOCAL(void) write_char (
    _TCHAR ch,
    FILE *f,
    int *pnumwritten
    )
{
    if ( (f->_flag & _IOSTRG) && f->_base == NULL)
    {
        ++(*pnumwritten);
        return;
    }
#ifdef  _UNICODE
    if (_putwc_lk(ch, f) == WEOF)
#else
    if (_putc_lk(ch, f) == EOF)
#endif  //_UNICODE
        *pnumwritten = -1;
    else
        ++(*pnumwritten);
}

#endif

/***
*void write_multi_char(char ch, int num, int *pnumwritten)
*ifdef _UNICODE
*void write_multi_char(wchar_t ch, int num, FILE *f, int *pnumwritten)
*endif
*void write_multi_char(char ch, int num, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes num copies of a character to the given file/console.  If no error occurs,
*   then *pnumwritten is incremented by num; otherwise, *pnumwritten is set
*   to -1.  If num is negative, it is treated as zero.
*
*Entry:
*   _TCHAR ch        - character to write
*   int num          - number of times to write the characters
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG
LOCAL(void) write_multi_char (
    _TCHAR ch,
    int num,
    int *pnumwritten
    )
{
    while (num-- > 0) {
        write_char(ch, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#else   /* CPRFLAG */

LOCAL(void) write_multi_char (
    _TCHAR ch,
    int num,
    FILE *f,
    int *pnumwritten
    )
{
    while (num-- > 0) {
        write_char(ch, f, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#endif  /* CPRFLAG */

/***
*void write_string(char *string, int len, int *pnumwritten)
*void write_string(char *string, int len, FILE *f, int *pnumwritten)
*ifdef _UNICODE
*void write_string(wchar_t *string, int len, FILE *f, int *pnumwritten)
*endif
*void write_wstring(wchar_t *string, int len, int *pnumwritten)
*void write_wstring(wchar_t *string, int len, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pnumwritten is incremented by len; otherwise, *pnumwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   _TCHAR *string   - string to write (NOT null-terminated)
*   int len          - length of string
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG

LOCAL(void) write_string (
    _TCHAR *string,
    int len,
    int *pnumwritten
    )
{
    while (len-- > 0) {
        write_char(*string++, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#else   /* CPRFLAG */

LOCAL(void) write_string (
    _TCHAR *string,
    int len,
    FILE *f,
    int *pnumwritten
    )
{
    if ( (f->_flag & _IOSTRG) && f->_base == NULL)
    {
        (*pnumwritten) += len;
        return;
    }
    while (len-- > 0) {
        write_char(*string++, f, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}
#endif  /* CPRFLAG */


/***
*int get_int_arg(va_list *pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

__inline int __cdecl get_int_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list *pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

#if     !LONG_IS_INT
__inline long __cdecl get_long_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, long);
}
#endif

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
__inline __int64 __cdecl get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif

#ifndef _UNICODE
/***
*short get_short_arg(va_list *pargptr)
*
*Purpose:
*   Gets a short argument off the given argument list and updates *pargptr.
*   *** CURRENTLY ONLY USED TO GET A WCHAR_T, IFDEF _INTL ***
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the short argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

#if     !SHORT_IS_INT
__inline short __cdecl get_short_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, short);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\popen.c ===
/***
*popen.c - initiate a pipe and a child command
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _popen() and _pclose().
*
*Revision History:
*       01-06-89  GJF   Initial version (I plead temporary insanity).
*       01-09-89  GJF   Fixed several bugs.
*       01-10-89  GJF   Implemented several improvements from Trapper.
*       01-12-89  GJF   Added underscores to function names. Also, in _pclose,
*                       pstream must be close before the cwait call if it is
*                       attached to the write handle of the pipe (otherwise,
*                       may get a deadlock).
*       01-13-89  GJF   Added multi-thread/dll support.
*       02-09-89  GJF   Prevent child process from inheriting unwanted handles.
*                       Also, always close pstream before doing the cwait.
*       05-10-89  GJF   Ported to 386 (OS/2 2.0)
*       08-14-89  GJF   Use DOSCALLS.H for API prototypes, fixed _rotl call
*                       in _pclose (rotate 24 bits for 386!), re-tested.
*       11-16-89  GJF   Changed DOS32SETFILEHSTATE to DOS32SETFHSTATE
*       11-20-89  GJF   Added const attribute to types of _popen()'s args.
*                       Also, fixed copyright.
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Made ibtab() and setinherit() _CALLTYPE4.
*       07-25-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variables), removed '32' from API names
*       08-13-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       10-03-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-18-91  GJF   ANSI naming.
*       02-25-91  SRW   Renamed _get_free_osfhnd to be _alloc_osfhnd [_WIN32_]
*       09-29-91  GJF   Picked up NT implementation (_WIN32_).
*       04-06-92  SRW   Fixed to not rely on setinherit function (_WIN32_).
*       04-28-92  DJM   ifndef for POSIX
*       05-06-92  GJF   Set _osfile[stddup] so that _get_osfhandle knows it's
*                       open (bug found by Markl).
*       05-15-92  GJF   Fixed regression Markl found - _close(stddup) to ensure
*                       that _osfile[] entry is cleared.
*       01-07-93  GJF   Substantially revised: purged Cruiser support, removed
*                       needlessly repeated API calls, closed down a pipe
*                       handle accidently left open at end of _popen, removed
*                       reduntant CloseHandle call from _pclose, tried to clean
*                       up the format and reduce the number of silly casts,
*                       and added or revised many comments.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-10-93  GJF   Removed redundant close of child process handle in
*                       _pclose().
*       12-07-93  CFW   Wide char enable.
*       07-26-94  CFW   Bug fix #14666, make data global so _wpopen sees it.
*       01-10-95  CFW   Debug CRT allocs.
*       01-16-95  SKS   Assume command.com for Win95, but cmd.exe for Win. NT.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       06-12-95  GJF   Replaced _osfile[] and _osfhnd[] with _osfile() and
*                       _osfhnd() (macros referencing fields in the ioinfo
*                       struct).
*       02-17-98  GJF   Changes for Win64:removed so long casts
*       02-25-98  GJF   Exception-safe locking.
*       01-19-00  GB    Made popen 100% multithreaded.
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       02-19-01  GB    Added check for return value of malloc.
*       05-30-01  BWT   Fix handle leak in popen - close thread handle we don't need.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <process.h>
#include <io.h>
#include <fcntl.h>
#include <internal.h>
#include <errno.h>
#include <msdos.h>
#include <mtdll.h>
#include <oscalls.h>
#include <tchar.h>
#include <dbgint.h>

/* size for pipe buffer
 */
#define PSIZE     1024

#define STDIN     0
#define STDOUT    1

#define SLASH _T("\\")
#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')
#define DELIMITER _T(";")



/* definitions for table of stream pointer - process handle pairs. the table
 * is created, maintained and accessed by the idtab function. _popen and
 * _pclose gain access to table entries only by calling idtab. Note that the
 * table is expanded as necessary (by idtab) and free table entries are reused
 * (an entry is free if its stream field is NULL), but the table is never
 * contracted.
 */

typedef struct {
        FILE *stream;
        intptr_t prochnd;
} IDpair;

/* number of entries in idpairs table
 */
#ifndef _UNICODE
unsigned __idtabsiz = 0;
#else
extern unsigned __idtabsiz;
#endif

/* pointer to first table entry
 */
#ifndef _UNICODE
IDpair *__idpairs = NULL;
#else
extern IDpair *__idpairs;
#endif

/* function to find specified table entries. also, creates and maintains
 * the table.
 */
static IDpair * __cdecl idtab(FILE *);


/***
*FILE *_popen(cmdstring,type) - initiate a pipe and a child command
*
*Purpose:
*       Creates a pipe and asynchronously executes a child copy of the command
*       processor with cmdstring (see system()). If the type string contains
*       an 'r', the calling process can read child command's standard output
*       via the returned stream. If the type string contains a 'w', the calling
*       process can write to the child command's standard input via the
*       returned stream.
*
*Entry:
*       _TSCHAR *cmdstring - command to be executed
*       _TSCHAR *type   - string of the form "r|w[b|t]", determines the mode
*                         of the returned stream (i.e., read-only vs write-only,
*                         binary vs text mode)
*
*Exit:
*       If successful, returns a stream associated with one end of the created
*       pipe (the other end of the pipe is associated with either the child
*       command's standard input or standard output).
*
*       If an error occurs, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tpopen (
        const _TSCHAR *cmdstring,
        const _TSCHAR *type
        )
{

        int phdls[2];             /* I/O handles for pipe */
        int ph_open[2];           /* flags, set if correspond phdls is open */
        int i1;                   /* index into phdls[] */
        int i2;                   /* index into phdls[] */

        int tm = 0;               /* flag indicating text or binary mode */

        int stdhdl;               /* either STDIN or STDOUT */

        HANDLE newhnd;            /* ...in calls to DuplicateHandle API */

        FILE *pstream = NULL;     /* stream to be associated with pipe */

        HANDLE prochnd;           /* handle for current process */

        _TSCHAR *cmdexe;          /* pathname for the command processor */
        intptr_t childhnd;        /* handle for child process (cmd.exe) */

        IDpair *locidpair;        /* pointer to IDpair table entry */
        _TSCHAR *buf = NULL, *pfin, *env;
        _TSCHAR *CommandLine;

        /* Info for spawning the child. */
        STARTUPINFO StartupInfo;  /* Info for spawning a child */
        BOOL childstatus = 0;
        PROCESS_INFORMATION ProcessInfo; /* child process information */

#ifdef  _MT
        int fh_lock_held = 0;
        int popen_lock_held = 0;
#endif

        /* first check for errors in the arguments
         */
        if ( (cmdstring == NULL) || (type == NULL) || ((*type != 'w') &&
             (*type != _T('r'))) )
                goto error1;

        /* do the _pipe(). note that neither of the resulting handles will
         * be inheritable.
         */

        if ( *(type + 1) == _T('t') )
                tm = _O_TEXT;
        else if ( *(type + 1) == _T('b') )
                tm = _O_BINARY;

        tm |= _O_NOINHERIT;

        if ( _pipe( phdls, PSIZE, tm ) == -1 )
                goto error1;

        /* test *type and set stdhdl, i1 and i2 accordingly.
         */
        if ( *type == _T('w') ) {
                stdhdl = STDIN;
                i1 = 0;
                i2 = 1;
        }
        else {
                stdhdl = STDOUT;
                i1 = 1;
                i2 = 0;
        }

#ifdef  _MT
        /* ASSERT LOCK FOR IDPAIRS HERE!!!!
         */
        if ( !_mtinitlocknum( _POPEN_LOCK )) {
            _close( phdls[0] );
            _close( phdls[1] );
            return NULL;
        }
        _mlock( _POPEN_LOCK );
        __try
        {
#endif

        /* set flags to indicate pipe handles are open. note, these are only
         * used for error recovery.
         */
        ph_open[ 0 ] = ph_open[ 1 ] = 1;


        /* get the process handle, it will be needed in some API calls
         */
        prochnd = GetCurrentProcess();



        if ( !DuplicateHandle( prochnd,
                               (HANDLE)_osfhnd( phdls[i1] ),
                               prochnd,
                               &newhnd,
                               0L,
                               TRUE,                    /* inheritable */
                               DUPLICATE_SAME_ACCESS )
        ) {
                goto error2;
        }
        (void)_close( phdls[i1] );
        ph_open[ i1 ] = 0;

        /* associate a stream with phdls[i2]. note that if there are no
         * errors, pstream is the return value to the caller.
         */
        if ( (pstream = _tfdopen( phdls[i2], type )) == NULL )
                goto error2;

        /* next, set locidpair to a free entry in the idpairs table.
         */
        if ( (locidpair = idtab( NULL )) == NULL )
                goto error3;


        /* Find what to use. command.com or cmd.exe */
        if ( ((cmdexe = _tgetenv(_T("COMSPEC"))) == NULL &&
              ((errno == ENOENT) || (errno == EACCES))) )
            cmdexe = ( _osver & 0x8000 ) ? _T("command.com") : _T("cmd.exe");

        /*
         * Initialise the variable for passing to CreateProcess
         */

        memset(&StartupInfo, 0, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        /* Used by os for duplicating the Handles. */
        
        StartupInfo.dwFlags = STARTF_USESTDHANDLES;
        StartupInfo.hStdInput = stdhdl == STDIN ? (HANDLE) newhnd
                                                : (HANDLE) _osfhnd(0);
        StartupInfo.hStdOutput = stdhdl == STDOUT ? (HANDLE) newhnd
                                                  : (HANDLE) _osfhnd(1);
        StartupInfo.hStdError = (HANDLE) _osfhnd(2);


        if ((CommandLine = _malloc_crt( (_tcslen(cmdexe) + _tcslen(_T(" /c ")) + (_tcslen(cmdstring)) +1) * sizeof(_TSCHAR))) == NULL)
            goto error3;
        _tcscpy(CommandLine, cmdexe);
        _tcscat(CommandLine, _T(" /c "));
        _tcscat(CommandLine, cmdstring);


        /* Check if cmdexe can be accessed. If yes CreateProcess else try
         * Searching Path.
         */
        if (_taccess(cmdexe, 0) != -1) {
            childstatus = CreateProcess( (LPTSTR) cmdexe,
                                         (LPTSTR) CommandLine,
                                         NULL,
                                         NULL,
                                         TRUE,
                                         0,
                                         NULL,
                                         NULL,
                                         &StartupInfo,
                                         &ProcessInfo
                                         );
        }
        else {
            env = _tgetenv(_T("PATH"));
            if ((buf = _malloc_crt(_MAX_PATH * sizeof(_TSCHAR))) == NULL)
            {
                _free_crt(CommandLine);
                goto error3;
            }
#ifdef  WPRFLAG
            while ( (env = _wgetpath(env, buf, _MAX_PATH -1)) && (*buf) ) {
#else
            while ( (env = _getpath(env, buf, _MAX_PATH -1)) && (*buf) ) {
#endif
                pfin = buf + _tcslen(buf) -1;
                
#ifdef  _MBCS
                if (*pfin == SLASHCHAR) {
                    if (pfin != _mbsrchr(buf, SLASHCHAR))
                        strcat(buf, SLASH);
                }
                else if (*pfin != XSLASHCHAR)
                    strcat(buf, SLASH);
                
#else   /* _MBCS */
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                    _tcscat(buf, SLASH);
#endif
                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _spawnve()).
                 */
                if ( (_tcslen(buf) + _tcslen(cmdexe)) < _MAX_PATH )
                    _tcscat(buf, cmdexe);
                else
                    break;
            
                /* Check if buf can be accessed. If yes CreateProcess else try
                 * again.
                 */
                if (_taccess(buf, 0) != -1) {
                    childstatus = CreateProcess( (LPTSTR) buf,
                                                 CommandLine,
                                                 NULL,
                                                 NULL,
                                                 TRUE,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 &StartupInfo,
                                                 &ProcessInfo
                                                 );
                    break;
                }
            }
            _free_crt(buf);
        }
        _free_crt(CommandLine);
        CloseHandle((HANDLE)newhnd);
        CloseHandle((HANDLE)ProcessInfo.hThread);

        /* check if the CreateProcess was sucessful.
         */
        if ( childstatus)
            childhnd = (intptr_t)ProcessInfo.hProcess;
        else
            goto error4;
        locidpair->prochnd = childhnd;
        locidpair->stream = pstream;

        /* success, return the stream to the caller
         */
        goto done;

        /**
         * error handling code. all detected errors end up here, entering
         * via a goto one of the labels. note that the logic is currently
         * a straight fall-thru scheme (e.g., if entered at error4, the
         * code for error4, error3,...,error1 is all executed).
         **********************************************************************/

error4:         /* make sure locidpair is reusable
                 */
                locidpair->stream = NULL;

error3:         /* close pstream (also, clear ph_open[i2] since the stream
                 * close will also close the pipe handle)
                 */
                (void)fclose( pstream );
                ph_open[ i2 ] = 0;
                pstream = NULL;

error2:         /* close handles on pipe (if they are still open)
                 */

                if ( ph_open[i1] )
                        _close( phdls[i1] );
                if ( ph_open[i2] )
                        _close( phdls[i2] );
done:

#ifdef  _MT
        ;}
        __finally {
            _munlock(_POPEN_LOCK);
        }
#endif

                
error1:
        return pstream;
}

#ifndef _UNICODE

/***
*int _pclose(pstream) - wait on a child command and close the stream on the
*   associated pipe
*
*Purpose:
*       Closes pstream then waits on the associated child command. The
*       argument, pstream, must be the return value from a previous call to
*       _popen. _pclose first looks up the process handle of child command
*       started by that _popen and does a cwait on it. Then, it closes pstream
*       and returns the exit status of the child command to the caller.
*
*Entry:
*       FILE *pstream - file stream returned by a previous call to _popen
*
*Exit:
*       If successful, _pclose returns the exit status of the child command.
*       The format of the return value is that same as for cwait, except that
*       the low order and high order bytes are swapped.
*
*       If an error occurs, -1 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _pclose (
        FILE *pstream
        )
{
        IDpair *locidpair;        /* pointer to entry in idpairs table */
        int termstat;             /* termination status word */
        int retval = -1;          /* return value (to caller) */

#ifdef  _MT
        if (!_mtinitlocknum(_POPEN_LOCK))
            return -1;
        _mlock(_POPEN_LOCK);
        __try {
#endif

        if ( (pstream == NULL) || ((locidpair = idtab(pstream)) == NULL) )
                /* invalid pstream, exit with retval == -1
                 */
                goto done;

        /* close pstream
         */
        (void)fclose(pstream);

        /* wait on the child (copy of the command processor) and all of its
         * children.
         */
        if ( (_cwait(&termstat, locidpair->prochnd, _WAIT_GRANDCHILD) != -1) ||
             (errno == EINTR) )
                retval = termstat;

        /* Mark the IDpairtable entry as free (note: prochnd was closed by the
         * preceding call to _cwait).
         */
        locidpair->stream = NULL;
        locidpair->prochnd = 0;

        /* only return path!
         */
        done:

#ifdef  _MT
        ; }
        __finally {
            _munlock(_POPEN_LOCK);
        }
#endif
        return(retval);
}

#endif /* _UNICODE */

/***
* static IDpair * idtab(FILE *pstream) - find an idpairs table entry
*
*Purpose:
*   Find an entry in the idpairs table.  This function finds the entry the
*   idpairs table entry corresponding to pstream. In the case where pstream
*   is NULL, the entry being searched for is any free entry. In this case,
*   idtab will create the idpairs table if it doesn't exist, or expand it (by
*   exactly one entry) if there are no free entries.
*
*   [MTHREAD NOTE:  This routine assumes that the caller has acquired the
*   idpairs table lock.]
*
*Entry:
*   FILE *pstream - stream corresponding to table entry to be found (if NULL
*                   then find any free table entry)
*
*Exit:
*   if successful, returns a pointer to the idpairs table entry. otherwise,
*   returns NULL.
*
*Exceptions:
*
*******************************************************************************/

static IDpair * __cdecl idtab (
        FILE *pstream
        )
{

        IDpair * pairptr;       /* ptr to entry */
        IDpair * newptr;        /* ptr to newly malloc'd memory */


        /* search the table. if table is empty, appropriate action should
         * fall out automatically.
         */
        for ( pairptr = __idpairs ; pairptr < (__idpairs+__idtabsiz) ; pairptr++ )
                if ( pairptr->stream == pstream )
                        break;

        /* if we found an entry, return it.
         */
        if ( pairptr < (__idpairs + __idtabsiz) )
                return(pairptr);

        /* did not find an entry in the table.  if pstream was NULL, then try
         * creating/expanding the table. otherwise, return NULL. note that
         * when the table is created or expanded, exactly one new entry is
         * produced. this must not be changed unless code is added to mark
         * the extra entries as being free (i.e., set their stream fields to
         * to NULL).
         */
        if ( (pstream != NULL) || ((newptr = (IDpair *)_realloc_crt((void *)__idpairs,
             (__idtabsiz + 1)*sizeof(IDpair))) == NULL) )
                /* either pstream was non-NULL or the attempt to create/expand
                 * the table failed. in either case, return a NULL to indicate
                 * failure.
                 */
                return( NULL );

        __idpairs = newptr;             /* new table ptr */
        pairptr = newptr + __idtabsiz;  /* first new entry */
        __idtabsiz++;                   /* new table size */

        return( pairptr );

}


#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\printf.c ===
/***
*printf.c - print formatted
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines printf() - print formatted data
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made printf conform to ANSI prototype and use the
*                       va_ macros; (2) removed SS_NE_DS conditionals.
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on stdout using the format string to
*       format data and getting as many arguments as called for
*       Uses temporary buffering to improve efficiency.
*       _output does the real work here
*
*Entry:
*       char *format - format string to control data format/number of arguments
*       followed by list of arguments, number and type controlled by
*       format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl printf (
        const char *format,
        ...
        )
/*
 * stdout 'PRINT', 'F'ormatted
 */
{
        va_list arglist;
        int buffing;
        int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(1, stdout);
        __try {
#endif

        buffing = _stbuf(stdout);

        retval = _output(stdout,format,arglist);

        _ftbuf(buffing, stdout);

#ifdef  _MT
        }
        __finally {
            _unlock_str2(1, stdout);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\putws.c ===
/***
*putws.c - put a string to stdout (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _putws() - put a string to stdout
*
*Revision History:
*	01-31-94  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "puts.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\rewind.c ===
/***
*rewind.c - rewind a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines rewind() - rewinds a stream to the beginning.
*
*
*Revision History:
*       09-02-83  RN    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL/normal versions
*       06-01-88  JCR   Clear lowio flags as well as stdio flags
*       06-14-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-09-93  GJF   Merged in NT SDK version (a fix for POSIX bug).
*                       Replaced MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-25-95  GJF   Replaced _osfile() with _osfile_safe().
*       03-02-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <io.h>
#include <mtdll.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#endif
#include <internal.h>

/***
*void rewind(stream) - rewind a string
*
*Purpose:
*       Back up a stream to the beginning (if not terminal).  First flush it.
*       If read/write, allow next i/o operation to set mode.
*
*Entry:
*       FILE *stream - file to rewind
*
*Exit:
*       returns 0 if success
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

void __cdecl rewind (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int fd;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _POSIX_
        fd = fileno(stream);
#else
        fd = _fileno(stream);
#endif

#ifdef  _MT
        /* Lock the file */
        _lock_str(stream);
        __try {
#endif

        /* Flush the stream */
        _flush(stream);

        /* Clear errors */
        stream->_flag &= ~(_IOERR|_IOEOF);
#ifndef _POSIX_
        _osfile_safe(fd) &= ~(FEOFLAG);
#endif

        /* Set flags */
        /* [note: _flush set _cnt=0 and _ptr=_base] */
        if (stream->_flag & _IORW)
            stream->_flag &= ~(_IOREAD|_IOWRT);

        /* Position to beginning of file */
#ifdef  _POSIX_
        /* [note: posix _flush doesn't discard buffer */

        stream->_ptr = stream->_base;
        stream->_cnt = 0;
        lseek(fd,0L,0);
#else
        _lseek(fd,0L,0);
#endif

#ifdef  _MT
        }
        __finally {
            /* unlock stream */
            _unlock_str(stream);
        }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\scanf.c ===
/***
*scanf.c - read formatted data from stdin
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines scanf() - reads formatted data from stdin
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macro.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int scanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       Reads formatted data from stdin into arguments.  _input does the real
*       work here.
*
*Entry:
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl scanf (
        const char *format,
        ...
        )
/*
 * stdin 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(0, stdin);
        __try {
#endif

        retval = (_input(stdin,format,arglist));

#ifdef  _MT
        }
        __finally {
            _unlock_str2(0, stdin);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\rmtmp.c ===
/***
*rmtmp.c - remove temporary files created by tmpfile.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       09-15-83  TC    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged normal and DLL versions
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       10-03-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       07-30-91  GJF   Added support for termination scheme used on
*                       non-Cruiser targets [_WIN32_].
*       03-11-92  GJF   Replaced _tmpnum(stream) with stream->_tmpfname for
*                       Win32.
*       03-17-92  GJF   Got rid of definition of _tmpoff.
*       03-31-92  GJF   Merged with Stevesa's changes.
*       04-16-92  GJF   Merged with Darekm's changes.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       10-29-93  GJF   Define entry for termination section (used to be in
*                       i386\cinittmp.asm). Also, replaced MTHREAD with _MT
*                       and deleted old Cruiser support.
*       04-04-94  GJF   #ifdef-ed out definition _tmpoff for msvcrt*.dll, it
*                       is unnecessary. Made definitions of _tempoff and
*                       _old_pfxlen conditional on ndef DLL_FOR_WIN32S.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   Converted to walk the __piob[] table (rather than
*                       the _iob[] table).
*       03-16-95  GJF   Must be sure __piob[i]!=NULL before trying to lock it!
*       03-28-95  SKS   Fix declaration of _prmtmp (__cdecl goes BEFORE the *)
*       08-01-96  RDK   For PMac, change termination pointer data type to static.
*       03-02-98  GJF   Exception-safe locking.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*       02-19-01  PML   Avoid allocating unnecessary locks in _rmtmp, part of
*                       vs7#172586.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

#pragma data_seg(".CRT$XPX")
_CRTALLOC(".CRT$XPX") static _PVFV pterm = _rmtmp;

#pragma data_seg()

/*
 * Definitions for _tmpoff, _tempoff and _old_pfxlen. These will cause this
 * module to be linked in whenever the termination code needs it.
 */
#ifndef CRTDLL
unsigned _tmpoff = 1;
#endif  /* CRTDLL */

unsigned _tempoff = 1;
unsigned _old_pfxlen = 0;


/***
*int _rmtmp() - closes and removes temp files created by tmpfile
*
*Purpose:
*       closes and deletes all open files that were created by tmpfile.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _rmtmp (
        void
        )
{
        REG2 int count = 0;
        REG1 int i;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        for ( i = 0 ; i < _nstream ; i++)

                if ( __piob[i] != NULL && inuse( (FILE *)__piob[i] )) {

#ifdef  _MT
                        /*
                         * lock the stream. this is not done until testing
                         * the stream is in use to avoid unnecessarily creating
                         * a lock for every stream. the price is having to
                         * retest the stream after the lock has been asserted.
                         */
                        _lock_str2(i, __piob[i]);
                        __try {
                                /*
                                 * if the stream is STILL in use (it may have
                                 * been closed before the lock was asserted),
                                 * see about flushing it.
                                 */
                                if ( inuse( (FILE *)__piob[i] )) {
#endif

                        if ( ((FILE *)__piob[i])->_tmpfname != NULL )
                        {
                                _fclose_lk( __piob[i] );
                                count++;
                        }

#ifdef  _MT
                                }
                        }
                        __finally {
                                _unlock_str2(i, __piob[i]);
                        }
#endif
                }

#ifdef  _MT
        }
        __finally {
                _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\setvbuf.c ===
/***
*setvbuf.c - set buffer size for a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines setvbuf() - set the buffering mode and size for a stream.
*
*Revision History:
*       09-19-83  RN    initial version
*       06-26-85  TC    modified to allow user defined buffers of various sizes
*       06-24-86  DFW   kludged to fix incompatability with Xenix values of
*                       _IOFBF, _IOLBF
*       02-09-87  JCR   added "buffer=&(_iob2[fileno(stream)]._charbuf);"
*                       to handle _IONBF case
*       02-25-87  JCR   added support for default buffer and IBMC20-condition
*                       code
*       04-13-87  JCR   changed type of szie from int to size_t (unsigned int)
*                       and changed a related comparison
*       06-29-87  JCR   Took out the _OLD_IOFBF/_OLD_IOLBF kludge for MSC.
*                       Should be taken out for IBM too...
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2 references
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-09-88  JCR   Buffer size can't be greater than INT_MAX
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, cleanup, a little tuning
*                       and fixed copyright.
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-27-93  CFW   Change _IONBF size to 2 bytes to hold wide char.
*       06-22-93  GJF   Set _IOSETVBUF (new) to indicate user-specified
*                       buffering (in addition to setting  _IOYOURBUF or
*                       _IOMYBUF).
*       11-12-93  GJF   Return failure if size == 1 (instead of putting
*                       0 into stream->_bufsiz, preventing any i/o)
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <malloc.h>
#include <internal.h>
#include <mtdll.h>
#include <limits.h>
#include <dbgint.h>

/***
*int setvbuf(stream, buffer, type, size) - set buffering for a file
*
*Purpose:
*       Controls buffering and buffer size for the specified stream.  The
*       array pointed to by buf is used as a buffer, unless NULL, in which
*       case we'll allocate a buffer automatically. type specifies the type
*       of buffering: _IONBF = no buffer, _IOFBF = buffered, _IOLBF = same
*       as _IOFBF.
*
*Entry:
*       FILE *stream - stream to control buffer on
*       char *buffer - pointer to buffer to use (NULL means auto allocate)
*       int type     - type of buffering (_IONBF, _IOFBF or _IOLBF)
*       size_t size  - size of buffer
*
*Exit:
*       return 0 if successful
*       returns non-zero if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl setvbuf (
        FILE *str,
        char *buffer,
        int type,
        size_t size
        )
{
        REG1 FILE *stream;
        int retval=0;   /* assume good return */

        _ASSERTE(str != NULL);

        /*
         * (1) Make sure type is one of the three legal values.
         * (2) If we are buffering, make sure size is greater than 0.
         */
        if ( (type != _IONBF) && ((size < 2) || (size > INT_MAX) ||
             ((type != _IOFBF) && (type != _IOLBF))) )
                return(-1);

        /*
         * force size to be even by masking down to the nearest multiple
         * of 2
         */
        size &= (size_t)~1;

        /*
         * Init stream pointers
         */
        stream = str;

#ifdef  _MT
        /*
         * Lock the file
         */
        _lock_str(stream);
        __try {
#endif

        /*
         * Flush the current buffer and free it, if it is ours.
         */
        _flush(stream);
        _freebuf(stream);

        /*
         * Clear a bunch of bits in stream->_flag (all bits related to
         * buffering and those which used to be in stream2->_flag2). Most
         * of these should never be set when setvbuf() is called, but it
         * doesn't cost anything to be safe.
         */
        stream->_flag &= ~(_IOMYBUF | _IOYOURBUF | _IONBF |
                           _IOSETVBUF | _IOFEOF | _IOFLRTN | _IOCTRLZ);

        /*
         * CASE 1: No Buffering.
         */
        if (type & _IONBF) {
                stream->_flag |= _IONBF;
                buffer = (char *)&(stream->_charbuf);
                size = 2;
        }

        /*
         * NOTE: Cases 2 and 3 (below) cover type == _IOFBF or type == _IOLBF
         * Line buffering is treated as the same as full buffering, so the
         * _IOLBF bit in stream->_flag is never set. Finally, since _IOFBF is
         * defined to be 0, full buffering is simply assumed whenever _IONBF
         * is not set.
         */

        /*
         * CASE 2: Default Buffering -- Allocate a buffer for the user.
         */
        else if ( buffer == NULL ) {
                if ( (buffer = _malloc_crt(size)) == NULL ) {
#ifndef CRTDLL
                        /*
                         * force library pre-termination procedure (placed here
                         * because the code path should almost never be hit)
                         */
                        _cflush++;
#endif  /* CRTDLL */
                        retval = -1;
                        goto done;
                }
                stream->_flag |= _IOMYBUF | _IOSETVBUF;
        }

        /*
         * CASE 3: User Buffering -- Use the buffer supplied by the user.
         */
        else {
                stream->_flag |= _IOYOURBUF | _IOSETVBUF;
        }

        /*
         * Common return for all cases.
         */
        stream->_bufsiz = (int)size;
        stream->_ptr = stream->_base = buffer;
        stream->_cnt = 0;
done:

#ifdef  _MT
        ; }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\snprintf.c ===
/***
*snprintf.c - "Count" version of sprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _snprintf() flavor takes a count argument that is
*	the max number of bytes that should be written to the
*	user's buffer.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define _COUNT_ 1
#include "sprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\snscanf.c ===
/***
*snscanf.c - read formatted data from string of given length
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines snscanf() - reads formatted data from string of given length
*
*Revision History:
*       09-12-00  GB    initial version
*
*******************************************************************************/
#ifndef _POSIX_
#define _SNSCANF
#include "sscanf.c"
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\setbuf.c ===
/***
*setbuf.c - give new file buffer
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines setbuf() - given a buffer to a stream or make it unbuffered
*
*Revision History:
*	09-19-83  RN	initial version
*	09-28-87  JCR	Corrected _iob2 indexing (now uses _iob_index() macro).
*	11-02-87  JCR	Re-wrote to use setvbuf()
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-27-88  PHG	Merged DLL and normal versions
*	02-15-90  GJF	Fixed copyright and indents
*	03-19-90  GJF	Replaced _LOAD_DS with _CALLTYPE1 and added #include
*			<cruntime.h>.
*	07-23-90  SBM	Replaced <assertm.h> by <assert.h>
*	10-03-90  GJF	New-style function declarator.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	05-11-93  GJF	Added comments.
*	02-06-94  CFW	assert -> _ASSERTE.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>

/***
*void setbuf(stream, buffer) - give a buffer to a stream
*
*Purpose:
*	Allow user to assign his/her own buffer to a stream.
*		if buffer is not NULL, it must be BUFSIZ in length.
*		if buffer is NULL, stream will be unbuffered.
*
*	Since setbuf()'s functionality is a subset of setvbuf(), simply
*	call the latter routine to do the actual work.
*
*	NOTE: For compatibility reasons, setbuf() uses BUFSIZ as the
*	buffer size rather than _INTERNAL_BUFSIZ. The reason for this,
*	and for the two BUFSIZ constants, is to allow stdio to use larger
*	buffers without breaking (already) compiled code.
*
*Entry:
*	FILE *stream - stream to be buffered or unbuffered
*	char *buffer - buffer of size BUFSIZ or NULL
*
*Exit:
*	None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl setbuf (
	FILE *stream,
	char *buffer
	)
{
	_ASSERTE(stream != NULL);

	if (buffer == NULL)
		setvbuf(stream, NULL, _IONBF, 0);
	else
		setvbuf(stream, buffer, _IOFBF, BUFSIZ);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\snwprint.c ===
/***
*snwprintf.c - "Count" version of swprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _snwprintf() flavor takes a count argument that is
*	the max number of wide characters that should be written to
*	the user's buffer.
*
*Revision History:
*	05-16-92   KRS	Created from snprintf.c.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define _COUNT_ 1
#include "swprintf.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\setmaxf.c ===
/***
*setmaxf.c - Set the maximum number of streams
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _setmaxstdio(), a function which changes the maximum number
*       of streams (stdio-level files) which can be open simultaneously.
*
*Revision History:
*       03-08-95  GJF   Module defined (reluctantly)
*       12-28-95  GJF   Major rewrite of _setmaxstio (several bugs). Added
*                       the _getmaxstdio() function.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <malloc.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>
#include <dbgint.h>

/***
*int _setmaxstdio(maxnum) - sets the maximum number of streams to maxnum
*
*Purpose:
*       Sets the maximum number of streams which may be simultaneously open
*       to maxnum. This is done by resizing the __piob[] array and updating
*       _nstream. Note that maxnum may be either larger or smaller than the
*       current _nstream value.
*
*Entry:
*       maxnum = new maximum number of streams
*
*Exit:
*       Returns maxnum, if successful, and -1 otherwise.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _setmaxstdio (
        int maxnum
        )
{
        void **newpiob;
        int i;
        int retval;

        /* 
         * Make sure the request is reasonable.
         */
        if ( (maxnum < _IOB_ENTRIES) || (maxnum > _NHANDLE_) )
            return -1;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        /*
         * Try to reallocate the __piob array.
         */
        if ( maxnum > _nstream ) {
            if ( (newpiob = _realloc_crt( __piob, maxnum * sizeof(void *) ))
                 != NULL )
            {
                /*
                 * Initialize new __piob entries to NULL
                 */
                for ( i = _nstream ; i < maxnum ; i++ ) 
                    newpiob[i] = NULL;

                retval = _nstream = maxnum;
                __piob = newpiob;
            }
            else
                retval = -1;
        }
        else if ( maxnum == _nstream )
            retval = _nstream;
        else {  /* maxnum < _nstream */
            retval = maxnum;
            /*
             * Clean up the portion of the __piob[] to be freed.
             */
            for ( i = _nstream - 1 ; i >= maxnum ; i-- ) 
                /*
                 * If __piob[i] is non-NULL, free up the _FILEX struct it
                 * points to. 
                 */
                if ( __piob[i] != NULL )
                    if ( !inuse( (FILE *)__piob[i] ) ) {
                        _free_crt( __piob[i] );
                    }
                    else {
                        /*
                         * _FILEX is still inuse! Don't free any anything and
                         * return failure to the caller.
                         */
                        retval = -1;
                        break;
                    }

            if ( retval != -1 )
                if ( (newpiob = _realloc_crt( __piob, maxnum * sizeof(void *) ))
                     != NULL ) 
                {
                    _nstream = maxnum;      /* retval already set to maxnum */
                    __piob = newpiob;
                }
                else
                    retval = -1;
        }

#ifdef  _MT
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return retval;
}


/***
*int _getmaxstdio() - gets the maximum number of stdio files
*
*Purpose:
*       Returns the maximum number of simultaneously open stdio-level files.
*       This is the current value of _nstream.
*
*Entry:
*
*Exit:
*       Returns current value of _nstream.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getmaxstdio (
        void
        )
{
        return _nstream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\snwscanf.c ===
/***
*snwscanf.c - read formatted data from string of given length
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines snwscanf() - reads formatted data from string of given length
*
*Revision History:
*       09-12-00  GB    initial version
*
*******************************************************************************/
#ifndef _POSIX_
#ifndef _UNICODE
#define _UNICODE
#endif
#ifndef UNICODE
#define UNICODE
#endif
#define _SNSCANF
#include <wchar.h>
#include "sscanf.c"
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines sprintf() and _snprintf() - print formatted data to string
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       09-24-91  JCR   Added _snprintf()
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-10-00  GB    Added support for knowing the length of formatted
*                       string by passing NULL for input string.
*       03-16-00  GB    Added _scprintf()
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int sprintf(string, format, ...) - print formatted data to string
*else
*int _snprintf(string, cnt, format, ...) - print formatted data to string
*endif
*
*Purpose:
*       Prints formatted data to the using the format string to
*       format data and getting as many arguments as called for
*       Sets up a FILE so file i/o operations can be used, make
*       string look like a huge buffer to it, but _flsbuf will
*       refuse to flush it if it fills up.  Appends '\0' to make
*       it a true string. _output does the real work here
*
*       Allocate the 'fake' _iob[] entry statically instead of on
*       the stack so that other routines can assume that _iob[]
*       entries are in are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _snprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must
*       never try to get the stream lock (i.e., there is no stream
*       lock either). (2) Also, since there is only one statically
*       allocated 'fake' iob, we must lock/unlock to prevent collisions.
*
*Entry:
*       char *string - pointer to place to put output
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl sprintf (
        char *string,
        const char *format,
        ...
        )
#else

int __cdecl _snprintf (
        char *string,
        size_t count,
        const char *format,
        ...
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);
        _ASSERTE(string != NULL);

#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)count;
#endif
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = string;

        retval = _output(outfile,format,arglist);

        if (string != NULL)
            _putc_lk('\0',outfile); /* no-lock version */

        return(retval);
}

/***
* _scprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/


#ifndef _COUNT_
int __cdecl _scprintf (
        const char *format,
        ...
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _output(outfile,format,arglist);
        return(retval);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\swscanf.c ===
/***
*swscanf.c - read formatted data from wide-character string
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _swscanf() - reads formatted data from wide-character string
*
*Revision History:
*       11-21-91  ETC   Created from sscanf.c
*       05-16-92  KRS   Revised for new ISO spec.  format is wchar_t * now.
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       09-12-00  GB    Merged with sscanf.c
*
*******************************************************************************/

#ifndef _POSIX_
#ifndef _UNICODE
#define _UNICODE
#endif
#ifndef UNICODE
#define UNICODE
#endif
#include <wchar.h>
#include "sscanf.c"
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\swprintf.c ===
/***
*swprintf.c - print formatted to string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines swprintf() and _snwprintf() - print formatted data to string
*
*Revision History:
*       05-16-92  KRS   Created from sprintf.c
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-16-00  GB    Added _scwprintf()
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int swprintf(string, format, ...) - print formatted data to string
*else
*int _snwprintf(string, cnt, format, ...) - print formatted data to string
*endif
*
*Purpose:
*       Prints formatted data to the using the format string to
*       format data and getting as many arguments as called for
*       Sets up a FILE so file i/o operations can be used, make
*       string look like a huge buffer to it, but _flsbuf will
*       refuse to flush it if it fills up.  Appends '\0' to make
*       it a true string. _output does the real work here
*
*       Allocate the 'fake' _iob[] entry statically instead of on
*       the stack so that other routines can assume that _iob[]
*       entries are in are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _snwprintf() flavor takes a count argument that is
*       the max number of wide characters that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must
*       never try to get the stream lock (i.e., there is no stream
*       lock either). (2) Also, since there is only one statically
*       allocated 'fake' iob, we must lock/unlock to prevent collisions.
*
*Entry:
*       wchar_t *string - pointer to place to put output
*ifdef _COUNT_
*       size_t count - max number of wide characters to put in buffer
*endif
*       wchar_t *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl swprintf (
        wchar_t *string,
        const wchar_t *format,
        ...
        )
#else

int __cdecl _snwprintf (
        wchar_t *string,
        size_t count,
        const wchar_t *format,
        ...
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(string != NULL);
        _ASSERTE(format != NULL);

        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = (char *) string;
#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)(count*sizeof(wchar_t));
#endif

        retval = _woutput(outfile,format,arglist);

        _putc_lk('\0',outfile); /* no-lock version */
        _putc_lk('\0',outfile); /* 2nd null byte for wchar_t version */

        return(retval);
}


/***
* _scwprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       wchar_t *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_
int __cdecl _scwprintf (
        const wchar_t *format,
        ...
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _woutput(outfile,format,arglist);
        return(retval);
}
#endif
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\tmpfile.c ===
/***
*tmpfile.c - create unique file name or file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines tmpnam() and tmpfile().
*
*Revision History:
*       ??-??-??  TC    initial version
*       04-17-86  JMB   tmpnam - brought semantics in line with System V
*                       definition as follows: 1) if tmpnam paramter is NULL,
*                       store name in static buffer (do NOT use malloc); (2)
*                       use P_tmpdir as the directory prefix to the temp file
*                       name (do NOT use current working directory)
*       05-26-87  JCR   fixed bug where tmpnam was modifying errno
*       08-10-87  JCR   Added code to support P_tmpdir with or without trailing
*                       '\'.
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-22-88  JCR   Added per thread static namebuf area (mthread bug fix)
*       05-27-88  PHG   Merged DLL/normal versions
*       11-14-88  GJF   _openfile() now takes a file sharing flag, also some
*                       cleanup (now specific to the 386)
*       06-06-89  JCR   386 mthread support
*       11-28-89  JCR   Added check to _tmpnam so it can't loop forever
*       02-16-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <io.h>.
*       10-03-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       07-22-91  GJF   Multi-thread support for Win32 [_WIN32_].
*       03-17-92  GJF   Completely rewrote Win32 version.
*       03-27-92  DJM   POSIX support.
*       05-02-92  SRW   Use _O_TEMPORARY flag for tmpfile routine.
*       05-04-92  GJF   Force cinittmp.obj in for Win32.
*       08-26-92  GJF   Fixed POSIX build.
*       08-28-92  GJF   Oops, forgot about getpid...
*       11-06-92  GJF   Use '/' for POSIX, '\\' otherwise, as the path
*                       separator. Also, backed out JHavens' bug fix of 6-14,
*                       which was itself a bug (albeit a less serious one).
*       02-26-93  GJF   Put in per-thread buffers, purged Cruiser support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Replace access() with ANSI-conforming _access()
*       04-22-93  GJF   Fixed bug in multi-thread - multiple threads calling
*                       tmpnam would get the same names. Also, went to static
*                       namebufX buffers since failing due to a failed malloc
*                       would violate ANSI.
*       04-29-93  GJF   Multi-thread bug in tmpnam() - forgot to copy the
*                       generated name to the per-thread buffer.
*       12-07-93  CFW   Wide char enable.
*       04-01-94  GJF   #ifdef-ed out __inc_tmpoff for msvcrt*.dll, it's
*                       unnecessary.
*       04-22-94  GJF   Made definitions of namebuf0 and namebuf1 conditional
*                       on DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       01-18-95  GJF   Must replace _tcsdup with _malloc_crt/_tcscpy for
*                       _DEBUG build.
*       02-21-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also replaced WPRFLAG
*                       with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       08-08-97  GJF   Removed initialized-but-unused local variable from 
*                       tmpfile(). Also, detab-ed.
*       03-03-98  GJF   Exception-safe locking.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Set errno EMFILE when out of streams.
*       07-03-01  BWT   Fix genfname to use the correct buffer size to encode a dword (7 bytes + NULL).
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <errno.h>
#include <process.h>
#include <fcntl.h>
#include <io.h>
#include <mtdll.h>
#include <share.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <file2.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/*
 * Buffers used by tmpnam() and tmpfile() to build filenames.
 */
static _TSCHAR namebuf0[L_tmpnam] = { 0 };      /* used by tmpnam()  */
static _TSCHAR namebuf1[L_tmpnam] = { 0 };      /* used by tmpfile() */

/*
 * Initializing function for namebuf0 and namebuf1.
 */
#ifdef _UNICODE
static void __cdecl winit_namebuf(int);
#else
static void __cdecl init_namebuf(int);
#endif

/*
 * Generator function that produces temporary filenames
 */
#ifdef _UNICODE
static int __cdecl wgenfname(wchar_t *);
#else
static int __cdecl genfname(char *);
#endif


/***
*_TSCHAR *tmpnam(_TSCHAR *s) - generate temp file name
*
*Purpose:
*       Creates a file name that is unique in the directory specified by
*       _P_tmpdir in stdio.h.  Places file name in string passed by user or
*       in static mem if pass NULL.
*
*Entry:
*       _TSCHAR *s - ptr to place to put temp name
*
*Exit:
*       returns pointer to constructed file name (s or address of static mem)
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _ttmpnam (
        _TSCHAR *s
        )
{
        _TSCHAR *pfnam = NULL;
#ifdef  _MT
        _ptiddata ptd;

        if ( !_mtinitlocknum( _TMPNAM_LOCK ))
                return NULL;

        _mlock(_TMPNAM_LOCK);

        __try {
#endif

        /*
         * Initialize namebuf0, if needed. Otherwise, call genfname() to
         * generate the next filename.
         */
        if ( *namebuf0 == 0 ) {
#ifdef _UNICODE
                winit_namebuf(0);
#else
                init_namebuf(0);
#endif
        }
#ifdef _UNICODE
        else if ( wgenfname(namebuf0) )
#else
        else if ( genfname(namebuf0) )
#endif
                goto tmpnam_err;

        /*
         * Generate a filename that doesn't already exist.
         */
        while ( _taccess(namebuf0, 0) == 0 )
#ifdef _UNICODE
                if ( wgenfname(namebuf0) )
#else
                if ( genfname(namebuf0) )
#endif
                        goto tmpnam_err;

        /*
         * Filename has successfully been generated.
         */
        if ( s == NULL )
#ifdef  _MT
        {
                /*
                 * Use a per-thread buffer to hold the generated file name.
                 * If there isn't one, and one cannot be created, just use
                 * namebuf0.
                 */
                ptd = _getptd();
#ifdef _UNICODE
                if ( (ptd->_wnamebuf0 != NULL) || ((ptd->_wnamebuf0 =
                      _malloc_crt(L_tmpnam * sizeof(wchar_t))) != NULL) )
                {
                        s = ptd->_wnamebuf0;
                        wcscpy(s, namebuf0);
                }
#else
                if ( (ptd->_namebuf0 != NULL) || ((ptd->_namebuf0 =
                      _malloc_crt(L_tmpnam)) != NULL) )
                {
                        s = ptd->_namebuf0;
                        strcpy(s, namebuf0);
                }
#endif
                else
                        s = namebuf0;
        }
#else
                s = namebuf0;
#endif
        else
                _tcscpy(s, namebuf0);

        pfnam = s;

        /*
         * All errors come here.
         */
tmpnam_err:

#ifdef  _MT
        ; }
        __finally {
                _munlock(_TMPNAM_LOCK);
        }
#endif

        return pfnam;
}

#ifndef _UNICODE

/***
*FILE *tmpfile() - create a temporary file
*
*Purpose:
*       Creates a temporary file with the file mode "w+b".  The file
*       will be automatically deleted when closed or the program terminates
*       normally.
*
*Entry:
*       None.
*
*Exit:
*       Returns stream pointer to opened file.
*       Returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl tmpfile (
        void
        )
{
        FILE *stream;
        FILE *return_stream = NULL;
        int fh;

#ifdef  _MT
        int stream_lock_held = 0;

        if ( !_mtinitlocknum( _TMPNAM_LOCK ))
                return NULL;

        _mlock(_TMPNAM_LOCK);

        __try {
#endif

        /*
         * Initialize namebuf1, if needed. Otherwise, call genfname() to
         * generate the next filename.
         */
        if ( *namebuf1 == 0 ) {
                init_namebuf(1);
        }
        else if ( genfname(namebuf1) )
                goto tmpfile_err;

        /*
         * Get a free stream.
         *
         * Note: In multi-thread models, the stream obtained below is locked!
         */
        if ( (stream = _getstream()) == NULL ) {
                errno = EMFILE;
                goto tmpfile_err;
        }

#ifdef  _MT
        stream_lock_held = 1;
#endif
        /*
         * Create a temporary file.
         *
         * Note: The loop below will only create a new file. It will NOT
         * open and truncate an existing file. Either behavior is probably
         * legal under ANSI (4.9.4.3 says tmpfile "creates" the file, but
         * also says it is opened with mode "wb+"). However, the behavior
         * implemented below is compatible with prior versions of MS-C and
         * makes error checking easier.
         */
#ifdef  _POSIX_
        while ( ((fh = open(namebuf1,
                             O_CREAT | O_EXCL | O_RDWR,
                             S_IRUSR | S_IWUSR
                             ))
            == -1) && (errno == EEXIST) )
#else
        while ( ((fh = _sopen(namebuf1,
                              _O_CREAT | _O_EXCL | _O_RDWR | _O_BINARY |
                                _O_TEMPORARY,
                              _SH_DENYNO,
                              _S_IREAD | _S_IWRITE
                             ))
            == -1) && (errno == EEXIST) )
#endif
                if ( genfname(namebuf1) )
                        break;

        /*
         * Check that the loop above did indeed create a temporary
         * file.
         */
        if ( fh == -1 )
                goto tmpfile_err;

        /*
         * Initialize stream
         */
#ifdef  _DEBUG
        if ( (stream->_tmpfname = _malloc_crt( (_tcslen( namebuf1 ) + 1) *
               sizeof(_TSCHAR) )) == NULL )
#else   /* ndef _DEBUG */
        if ( (stream->_tmpfname = _tcsdup( namebuf1 )) == NULL )
#endif  /* _DEBUG */
        {
                /* close the file, then branch to error handling */
#ifdef  _POSIX_
                close(fh);
#else
                _close(fh);
#endif
                goto tmpfile_err;
        }
#ifdef  _DEBUG
        _tcscpy( stream->_tmpfname, namebuf1 );
#endif  /* _DEBUG */
        stream->_cnt = 0;
        stream->_base = stream->_ptr = NULL;
        stream->_flag = _commode | _IORW;
        stream->_file = fh;

        return_stream = stream;

        /*
         * All errors branch to the label below.
         */
tmpfile_err:

#ifdef  _MT
        ; }
        __finally {
                if ( stream_lock_held )
                        _unlock_str(stream);
                _munlock(_TMPNAM_LOCK);
        }
#endif

        return return_stream;
}

#endif /* _UNICODE */

/***
*static void init_namebuf(flag) - initializes the namebuf arrays
*
*Purpose:
*       Called once each for namebuf0 and namebuf1, to initialize
*       them.
*
*Entry:
*       int flag            - flag set to 0 if namebuf0 is to be initialized,
*                             non-zero (1) if namebuf1 is to be initialized.
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
static void __cdecl winit_namebuf(
#else
static void __cdecl init_namebuf(
#endif
        int flag
        )
{
        _TSCHAR *p, *q;

        if ( flag == 0 )
            p = namebuf0;
        else
            p = namebuf1;

        /*
         * Put in the path prefix. Make sure it ends with a slash or
         * backslash character.
         */
#ifdef _UNICODE
        wcscpy(p, _wP_tmpdir);
#else
        strcpy(p, _P_tmpdir);
#endif
        q = p + sizeof(_P_tmpdir) - 1;      /* same as p + _tcslen(p) */

#ifdef _POSIX_
        if  ( *(q - 1) != _T('/') )
                *(q++) = _T('/');
#else
        if  ( (*(q - 1) != _T('\\')) && (*(q - 1) != _T('/')) )
                *(q++) = _T('\\');
#endif

        /*
         * Append the leading character of the filename.
         */
        if ( flag )
                /* for tmpfile() */
                *(q++) = _T('t');
        else
                /* for tmpnam() */
                *(q++) = _T('s');

        /*
         * Append the process id, encoded in base 32. Note this makes
         * p back into a string again (i.e., terminated by a '\0').
         */
#ifdef  _POSIX_
        _ultot((unsigned long)getpid(), q, 32);
#else
        _ultot((unsigned long)_getpid(), q, 32);
#endif
        _tcscat(p, _T("."));
}


/***
*static int genfname(_TSCHAR *fname) -
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
static int __cdecl wgenfname (
#else
static int __cdecl genfname (
#endif
        _TSCHAR *fname
        )
{
        _TSCHAR *p;
        _TSCHAR pext[8];        // 7 positions for base 32 ulong + null terminator
        unsigned long extnum;

        p = _tcsrchr(fname, _T('.'));

        p++;

        if ( (extnum = _tcstoul(p, NULL, 32) + 1) >= (unsigned long)TMP_MAX )
                return -1;

        _tcscpy(p, _ultot(extnum, pext, 32));

        return 0;
}

#if     !defined(_UNICODE) && !defined(CRTDLL)

/***
*void __inc_tmpoff(void) - force external reference for _tmpoff
*
*Purpose:
*       Forces an external reference to be generate for _tmpoff, which is
*       is defined in cinittmp.obj. This has the forces cinittmp.obj to be
*       pulled in, making a call to rmtmp part of the termination.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


extern int _tmpoff;

void __inc_tmpoff(
        void
        )
{
        _tmpoff++;
}

#endif  /* _UNICODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\test_out.c ===
/***
*test_out.c - test output.c
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains a small test suite for output.c.  Although
*       it is certainly not comprehensive, it should catch most major bugs.
*
*Revision History:
*       06-05-89  PHG   Module created
*       03-19-90  GJF   Fixed copyright.
*       10-03-90  GJF   New-style function declarator.
*       06-08-92  KRS   Updated for 32-bit sizes and wchar_t specifiers.
*       02-24-95  GJF   Appended Mac version (probably just an old version)
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

void test (
        char *shouldbe,
        char *format,
        ...
        )
{
        va_list argptr;
        char buffer[500];

        va_start(argptr, format);

        vsprintf(buffer, format, argptr);
        if (strcmp(shouldbe, buffer) != 0)
                printf("Was:       \"%s\"\nShould be: \"%s\"\n", buffer, shouldbe);
}

main()
{
        int i;
        long l;

        /* normal */
        test("Hello, world!", "Hello, world!");

        /* test %s */
        test("Hello, world!", "%s", "Hello, world!");
        test("Hello, world!", "%.20s", "Hello, world!");
        test("Hello", "%.5s", "Hello, world!");
        test("", "%.s", "Hello, world!");
        test("(null)", "%s", NULL);
        test("       Hello, world!", "%20s", "Hello, world!");
        test("Hello, world!       ", "%-20s", "Hello, world!");
        test("               Hello", "%20.5s", "Hello, world!");
        test("Hello               ", "%-20.5s", "Hello, world!");
        test("Hello", "%3.5s", "Hello, world!");
        test("Hello", "%-3.5s", "Hello, world!");
        test("Hello, world!", "%-8s", "Hello, world!");
        test("Hello, world!", "%8s", "Hello, world!");

        /* test %ws, %ls, %Zi (should be %S) */
        test("Hello, world!", "%ws", L"Hello, world!");
        test("Hello, world!", "%.20Z", L"Hello, world!");
        test("Hello", "%.5ls", L"Hello, world!");
        test("", "%.ws", L"Hello, world!");
        test("(null)", "%ls", NULL);
        test("(null)", "%ws", NULL);
        test("(null)", "%Z", NULL);
        test("       Hello, world!", "%20ls", L"Hello, world!");
        test("Hello, world!       ", "%-20ws", L"Hello, world!");
        test("               Hello", "%20.5Z", L"Hello, world!");
        test("Hello               ", "%-20.5ls", L"Hello, world!");
        test("Hello", "%3.5ws", L"Hello, world!");
        test("Hello", "%-3.5Z", L"Hello, world!");
        test("Hello, world!", "%-8ls", L"Hello, world!");
        test("Hello, world!", "%8ws", L"Hello, world!");


        /* test %wc, %lc, should also add %C */
        test("H", "%lc", L'H');
        test("    H", "%5lc", L'H');
        test("H    ", "%-5lc", L'H');
        test("H", "%wc", L'H');
        test("    H", "%5wc", L'H');
        test("H    ", "%-5wc", L'H');

        /* test %d/%u */
        test("54", "%d", 54);
        test("-42", "%i", -42);
        test("  -102", "%6d", -102);
        test("0     ", "%-6d", 0);
        test("00000", "%.5d", 0);
        test("-0345", "%.4d", -345);
        test("-345", "%.3d", -345);
        test("00345", "%.5d", 345);
        test("00345", "%05d", 345);
        test("345  ", "%-05d", 345);
        test("    -00055", "%10.5d", -55);
        test("-00055    ", "%-10.5d", -55);
        test("     ", "%5.0d", 0);
        test("12345678", "%ld", 12345678);
        test("+123", "%+d", 123);
        test("-123", "%+d", -123);
        test("+000123", "%+07d", 123);
        test(" 000123", "% 07d", 123);
        test("+123   ", "%+-7d", 123);
        test("  +0123", "%+7.4i", 123);
        test("-1", "%d", 0xFFFFFFFF);
        test("65535", "%u", 0xFFFF);

        /* test %x */
        test("DEF", "%X", 0xdef);
        test("14d   ", "%-6x", 0x14d);
        test(" 0X14D", "%#6X", 0x14d);
        test("0x00014d  ", "%#-10.6x", 0x14d);
        test("0", "%#x", 0);
        test("", "%.0x", 0);
        test("  ", "%#2.0X", 0);
        test("000000014d", "%010x", 0x14d);
        test("14d       ", "%-010x", 0x14d);
        test("0x0000014d", "%#010x", 0x14d);
        test("FFFF", "%X", 0xffff);

        /* temp: %B/%C should go away */
        test("DEF", "%B", 0xdef);
        test("14D   ", "%-6C", 0x14d);
        test(" 0X14D", "%#6B", 0x14d);
        test("0X00014D  ", "%#-10.6C", 0x14d);
        test("0", "%#B", 0);
        test("", "%.0C", 0);
        test("  ", "%#2.0B", 0);
        test("000000014D", "%010C", 0x14d);
        test("14D       ", "%-010B", 0x14d);
        test("0X0000014D", "%#010C", 0x14d);
        test("FFFF", "%B", 0xffff);

        /* test %o */
        test("703", "%o", 0703);
        test("   703", "%6o", 0703);
        test("  0703", "%#6o", 0703);
        test("0703  ", "%#-6o", 0703);
        test("000703", "%06o", 0703);
        test("00703 ", "%-#6.5o", 0703);
        test("0703  ", "%-#06o", 0703);
        test(" 00703", "%#6.5o", 0703);
        test("0", "%#.0o", 0);
        test("", "%.0o", 0);
        test("177777", "%o", 0xFFFF);

        /* test %p */
        test("000000FE", "%p", (char *)0x00fe);
        test("00003DFE  ", "%-10p", (char *)0x3dfe);
        test("    00009DF4", "%12p", (char *)0x9df4);

        /* test %n */
        test("Hello, world", "Hello, world%n", &i);
        test("12", "%i", i);
        test("This is 423 characters ", "This is %d characters %ln", 423, &l);
        test("23", "%ld", l);
        test("0x0003f", "%#.5x%n", 0x3f, &i);
        test("7", "%d", i);

        /* test multiple specifiers */
        test("24 43", "%d %d", 24, 43);
        test("24 43", "%ld %ld", 24l, 43L);
        test("00004ABC 43", "%p %d", (char *)0x4abc, 43);
        test("43", "%n%d", &i, 43);
        test("43", "%ln%d", &l, 43);

        printf("Completed all non-FP format specifiers\n");

        printf("Processing %%e\n");

        /* test %e */
        test("-4.000000e+000", "%e", -4.0);
        test("4.000000E+000", "%E", 4.0);
        test("-7E+001", "%.0E", -68.5);
        test("-7.E+001", "%#.0E", -74.5);
        test(" 6.78e+004  ", "% -12.2e", 67844.324);
        test("  +6.78e+004", "%+12.2e", 67844.324);
        test("    0.000000e+000", "%17e", 0.0);
        test("-00007.467e-001", "%015.3e", -0.74673);

        printf("Processing %%f\n");

        /* test %f */
        test("-4.000000", "%f", -4.0);
        test("4.000000", "%f", 4.0);
        test("0.400000", "%f", 0.4);
        test("-69", "%.0f", -68.7);
        test("-74.", "%#.0f", -74.3);
        test(" 67844.32   ", "% -12.2f", 67844.324);
        test("   +67844.32", "%+12.2f", 67844.324);
        test("         0.000000", "%17f", 0.0);
        test("-0000000000.747", "%015.3f", -0.74673);

        printf("Processing %%g\n");

        /* test %g */
        test("3.14159E-005", "%G", 0.000031415926535);
        test("0.000314159", "%g", 0.00031415926535);
        test("0.00314159", "%g", 0.0031415926535);
        test("0.0314159", "%g", 0.031415926535);
        test("0.314159", "%g", 0.31415926535);
        test("3.14159", "%g", 3.1415926535);
        test("31.4159", "%g", 31.415926535);
        test("314.159", "%g", 314.15926535);
        test("3141.59", "%g", 3141.5926535);
        test("31415.9", "%g", 31415.926535);
        test("314159", "%g", 314159.26535);
        test("3.14159e+006" , "%g", 3141592.6535);
        test("3", "%g", 3.0);
        test("3e+006", "%g", 3000000.0);
        test("   3.14", "%7.4g", 3.1402);
        test(" 3.14  ", "% -7.4g", 3.1402);
        test("+0023.000", "%+#09.5g", 23.0);
        test("23.", "%#.2g", 23.0);
        test("23", "%.2g", 23.0);

        /* more multiples */
        test("3.1 43", "%g %d", 3.1, 43);
        test("3.1 43", "%Lg %d", (long double)3.1, 43);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\stream.c ===
/***
*stream.c - find a stream not in use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getstream() - find a stream not in use
*
*Revision History:
*       09-02-83  RN    initial version
*       11-01-87  JCR   Multi-thread support
*       05-24-88  PHG   Merged DLL and normal versions
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       08-17-89  GJF   Removed _NEAR_, fixed copyright and indenting.
*       02-16-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       10-03-90  GJF   New-style function declarator.
*       12-31-91  GJF   Improved multi-thread lock usage [_WIN32_].
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       03-07-95  GJF   Changes to manage streams via __piob[], rather than
*                       _iob[].
*       05-12-95  CFW   Bug fix: set _tmpfname field to NULL.
*       03-02-98  GJF   Exception-safe locking.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*       10-14-99  PML   Replace InitializeCriticalSection with wrapper function
*                       __crtInitCritSecAndSpinCount
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>

/***
*FILE *_getstream() - find a stream not in use
*
*Purpose:
*       Find a stream not in use and make it available to caller. Intended
*       for use inside library only
*
*Entry:
*       None. Scans __piob[]
*
*Exit:
*       Returns a pointer to a free stream, or NULL if all are in use.  A
*       stream becomes allocated if the caller decided to use it by setting
*       any r, w, r/w mode.
*
*       [Multi-thread note: If a free stream is found, it is returned in a
*       LOCKED state.  It is the caller's responsibility to unlock the stream.]
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _getstream (
        void
        )
{
        REG2 FILE *retval = NULL;
        REG1 int i;

#ifdef  _MT
        /* Get the iob[] scan lock */
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        /*
         * Loop through the __piob table looking for a free stream, or the
         * first NULL entry.
         */
        for ( i = 0 ; i < _nstream ; i++ ) {

            if ( __piob[i] != NULL ) {
                /*
                 * if the stream is not inuse, return it.
                 */
                if ( !inuse( (FILE *)__piob[i] ) ) {
#ifdef  _MT
		    /*
		     * Allocate the FILE lock, in case it hasn't already been
		     * allocated (only necessary for the first _IOB_ENTRIES
		     * locks, not including stdin/stdout/stderr).  Return
		     * failure if lock can't be allocated.
		     */
		    if ( i > 2 && i < _IOB_ENTRIES )
			if ( !_mtinitlocknum( _STREAM_LOCKS + i ) )
			    break;

                    _lock_str2(i, __piob[i]);

                    if ( inuse( (FILE *)__piob[i] ) ) {
                        _unlock_str2(i, __piob[i]);
                        continue;
                    }
#endif
                    retval = (FILE *)__piob[i];
                    break;
                }
            }
            else {
                /*
                 * allocate a new _FILEX, set _piob[i] to it and return a
                 * pointer to it.
                 */
                if ( (__piob[i] = _malloc_crt( sizeof(_FILEX) )) != NULL ) {

#if     defined(_MT)
                    if ( !__crtInitCritSecAndSpinCount(
                         &(((_FILEX *)__piob[i])->lock), _CRT_SPINCOUNT ))
                    {
                        /*
                         * Failed to initialize the critical section because
                         * of lack of memory, clean up and return failure.
                         */
			_free_crt( __piob[i] );
			__piob[i] = NULL;
                        break;
                    }

                    EnterCriticalSection( &(((_FILEX *)__piob[i])->lock) );
#endif
                    retval = (FILE *)__piob[i];
                }

                break;
            }
        }

        /*
         * Initialize the return stream.
         */
        if ( retval != NULL ) {
            retval->_flag = retval->_cnt = 0;
            retval->_tmpfname = retval->_ptr = retval->_base = NULL;
            retval->_file = -1;
        }

#ifdef  _MT
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\sscanf.c ===
/***
*sscanf.c - read formatted data from string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines scanf() - reads formatted data from string
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       06-13-88  JCR   Fake _iob entry is now static so that other routines can
*                       assume _iob entries are in DGROUP.
*       06-06-89  JCR   386 mthread support -- threads share one locked iob.
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed indents.
*       02-16-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <string.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*int sscanf(string, format, ...) - read formatted data from string
*
*Purpose:
*       Reads formatted data from string into arguments.  _input does the real
*       work here.  Sets up a FILE so file i/o operations can be used, makes
*       string look like a huge buffer to it, but _filbuf will refuse to refill
*       it if it is exhausted.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - string to read data from
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
/***
*int snscanf(string, size, format, ...) - read formatted data from string of 
*    given length
*
*Purpose:
*       Reads formatted data from string into arguments.  _input does the real
*       work here.  Sets up a FILE so file i/o operations can be used, makes
*       string look like a huge buffer to it, but _filbuf will refuse to refill
*       it if it is exhausted.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - string to read data from
*       size_t count - length of string
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
#ifdef _UNICODE
#ifdef _SNSCANF
int __cdecl _snwscanf (
#else
int __cdecl swscanf (
#endif
#else
#ifdef _SNSCANF
int __cdecl _snscanf (
#else
int __cdecl sscanf (
#endif
#endif
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif
        const _TCHAR *format,
        ...
        )
/*
 * 'S'tring 'SCAN', 'F'ormatted
 */
{
        va_list arglist;
        FILE str;
        REG1 FILE *infile = &str;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(string != NULL);
        _ASSERTE(format != NULL);

        infile->_flag = _IOREAD|_IOSTRG|_IOMYBUF;
        infile->_ptr = infile->_base = (char *) string;
#ifdef _SNSCANF
        infile->_cnt = (int)count*sizeof(_TCHAR);
#else
        infile->_cnt = ((int)_tcslen(string))*sizeof(_TCHAR);
#endif
#ifdef  _UNICODE
        retval = (_winput(infile,format,arglist));
#else
        retval = (_input(infile,format,arglist));
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\tempnam.c ===
/***
*tempnam.c - generate unique file name
*
*       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       ??-??-??  TC    initial version
*       04-17-86  JMB   changed directory of last resort from \tmp to tmp.
*                       eliminated use of L_tmpnam (it was incoorectly defined
*                       in stdio.h and should not be used in tempnam; see
*                       System V definition of tempnam.
*       04-23-86  TC    changed last try directory from tmp to current directory
*       04-29-86  JMB   bug fix: pfxlength was being set from strlen(pfx)
*                       even if pfx was NULL.  Fixed to set pfxlength to zero
*                       if pfx is NULL, strlen(pfx) otherwise.
*       05-28-86  TC    changed stat's to access's, and optimized code a bit
*       12-01-86  JMB   added support for Kanji file names until KANJI switch
*       12-15-86  JMB   free malloced memory if (++_tmpoff == first)
*       07-15-87  JCR   Re-init _tempoff based on length of pfx (fixes infinate
*                       loop bug; also, tempnam() now uses _tempoff instead of
*                       _tmpoff (used by tmpnam()).
*       10-16-87  JCR   Fixed bug in _tempoff re-init code if pfx is NULL.
*       11-09-87  JCR   Multi-thread version
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-09-89  GJF   Propagated MT's change of 05-17-89 (Kanji)
*       02-16-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS and _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Added #include <io.h>.
*       08-13-90  SBM   Compiles cleanly with -W3, replaced explicit register
*                       declarations by REGn references
*       10-03-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       08-19-91  JCR   Allow quotes in TMP variable path
*       08-27-91  JCR   ANSI naming
*       08-25-92  GJF   Don't build for POSIX.
*       11-30-92  KRS   Generalize KANJI support to MBCS. Port 16-bit bug fix.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       01-23-95  CFW   Debug: tempnam return freed by user.
*       02-21-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also replaced WPRFLAG
*                       with _UNICODE.
*       03-10-95  CFW   Made _tempnam() parameters const.
*       03-14-95  JCF   Made pfin _TSCHAR for the Mac.
*       07-30-96  GJF   Allow longer file names and changed the way we ensure 
*                       a file name is not too long. In particular, this
*                       corrects the absurdly long loop (appeared infinite to
*                       to users) which occurred when the user supplied prefix 
*                       was too long. Also, cleaned up the format a bit.
*       03-04-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-00  PML   Fix double-free of qptr when _stripquote succeeds but
*                       result isn't a valid directory (vs7#5416).
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       07-07-01  BWT   Initialize 's' in tempnam - in case the done2 branch is taken,
*                       's' must be something reasonable.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <malloc.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>
#include <dbgint.h>

#ifdef  _MBCS
#include <mbstring.h>
#endif

/* local tchar */
#ifdef  _UNICODE
#define _tP_tmpdir _wP_tmpdir
#else
#define _tP_tmpdir _P_tmpdir
#endif

#ifdef  _UNICODE
static wchar_t * _wstripquote (wchar_t *);
#else
static char * _stripquote (char *);
#endif

/***
*_TSCHAR *_tempnam(dir, prefix) - create unique file name
*
*Purpose:
*       Create a file name that is unique in the specified directory.
*       The semantics of directory specification is as follows:
*       Use the directory specified by the TMP environment variable
*       if that exists, else use the dir argument if non-NULL, else
*       use _P_tmpdir if that directory exists, else use the current
*       working directory), else return NULL.
*
*Entry:
*       _TSCHAR *dir - directory to be used for temp file if TMP env var
*                   not set
*       _TSCHAR *prefix - user provided prefix for temp file name
*
*Exit:
*       returns ptr to constructed file name if successful
*       returns NULL if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _ttempnam (
        const _TSCHAR *dir,
        const _TSCHAR *pfx
        )
{
        REG1 _TSCHAR *ptr;
        REG2 unsigned int pfxlength = 0;
        _TSCHAR *s = NULL;
        _TSCHAR *pfin;
        unsigned int first;
        unsigned int bufsz;
        _TSCHAR * qptr = NULL;  /* ptr to TMP path with quotes stripped out */

#ifdef  _MT
        if ( !_mtinitlocknum( _TMPNAM_LOCK ))
                return NULL;
#endif

        /* try TMP path */
        if ( ( ptr = _tgetenv( _T("TMP") ) ) && ( _taccess( ptr, 0 ) != -1 ) )
                dir = ptr;

        /* try stripping quotes out of TMP path */
#ifdef  _UNICODE
        else if ( (ptr != NULL) && (qptr = _wstripquote(ptr)) &&
#else
        else if ( (ptr != NULL) && (qptr = _stripquote(ptr)) &&
#endif
                  (_taccess(qptr, 0) != -1 ) )
                dir = qptr;

        /* TMP path not available, use alternatives */
        else if (!( dir != NULL && ( _taccess( dir, 0 ) != -1 ) ) )
        /* do not "simplify" this depends on side effects!! */
        {
                if ( _taccess( _tP_tmpdir, 0 ) != -1 )
                    dir = _tP_tmpdir;
                else
                    dir = _T(".");
        }


        if (pfx)
                pfxlength = (unsigned)_tcslen(pfx);

        if ( ((bufsz = (unsigned)_tcslen(dir) + pfxlength + 12) > FILENAME_MAX) ||
             ((s = malloc(bufsz * sizeof(_TSCHAR))) == NULL) )
                /* the 12 above allows for a backslash, 10 char temp string and
                   a null terminator */
        {
                goto done2;
        }

        *s = _T('\0');
        _tcscat( s, dir );
        pfin = (_TSCHAR *)&(dir[ _tcslen( dir ) - 1 ]);

#ifdef  _MBCS
        if (*pfin == '\\') {
                if (pfin != _mbsrchr(dir,'\\'))
                        /* *pfin is second byte of a double-byte char */
                        strcat( s, "\\" );
        }
        else if (*pfin != '/')
                strcat( s, "\\" );
#else
        if ( ( *pfin != _T('\\') ) && ( *pfin != _T('/') ) )
        {
                _tcscat( s, _T("\\") );
        }
#endif

        if ( pfx != NULL )
        {
                _tcscat( s, pfx );
        }
        ptr = &s[_tcslen( s )];

        /*
        Re-initialize _tempoff if necessary.  If we don't re-init _tempoff, we
        can get into an infinate loop (e.g., (a) _tempoff is a big number on
        entry, (b) prefix is a long string (e.g., 8 chars) and all tempfiles
        with that prefix exist, (c) _tempoff will never equal first and we'll
        loop forever).

        [NOTE: To avoid a conflict that causes the same bug as that discussed
        above, _tempnam() uses _tempoff; tmpnam() uses _tmpoff]
        */

#ifdef  _MT
        _mlock(_TMPNAM_LOCK);   /* Lock access to _old_pfxlen and _tempoff */
        __try {
#endif

        if (_old_pfxlen < pfxlength)
                _tempoff = 1;
        _old_pfxlen = pfxlength;

        first = _tempoff;

        do {
                if ( (++_tempoff - first) > TMP_MAX ) {
                        free(s);
                        s = NULL;
                        goto done1;
                }
                /* the maximum length string returned by _ultot is 10 chars
                   (assuming 32-bit unsigned long) so there is enough room in
                   the tail of s (pointed to by ptr) for it */
                _ultot( (unsigned long)_tempoff, ptr, 10 );
        }
        while ( (_taccess( s, 0 ) == 0 ) || (errno == EACCES) );


        /* Common return */
done1:

#ifdef  _MT
        ; }
        __finally {
                _munlock(_TMPNAM_LOCK);     /* release tempnam lock */
        }
#endif

done2:
        _free_crt(qptr);            /* free temp ptr, if non-NULL */
        return(s);
}



/***
*_stripquote() - Strip quotes out of a string
*
*Purpose:
*       This routine strips quotes out of a string.  This is necessary
*       in the case where a file/path name has embedded quotes (i.e.,
*       new file system.)
*
*       For example,
*                       c:\tmp\"a b c"\d --> c:\tmp\a b d\d
*
*       NOTE:  This routine makes a copy of the string since it may be
*       passed a pointer to an environment variable that shouldn't be
*       changed.  It is up to the caller to free up the memory (if the
*       return value is non-NULL).
*
*Entry:
*       _TSCHAR * ptr = pointer to string
*
*Exit:
*       _TSCHAR * ptr = pointer to copy of string with quotes gone.
*       NULL = no quotes in string.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _UNICODE
static wchar_t * _wstripquote (
#else
static char * _stripquote (
#endif
        _TSCHAR * src
        )
{
        _TSCHAR * dst;
        _TSCHAR * ret;
        unsigned int q = 0;


        /* get a buffer for the new string */

        if ((dst = _malloc_crt((_tcslen(src)+1) * sizeof(_TSCHAR))) == NULL)
                return(NULL);

        /* copy the string stripping out the quotes */

        ret = dst;          /* save base ptr */

        while (*src) {

                if (*src == _T('\"')) {
                        src++; q++;
                }
                else
                        *dst++ =  *src++;
        }

        if (q) {
                *dst = _T('\0');        /* final nul */
                return(ret);
        }
        else {
                _free_crt(ret);
                return(NULL);
        }

}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vfwprint.c ===
/***
*vfwprintf.c - fwprintf from variable arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vfwprintf() - print formatted output, but take args from
*       a stdargs pointer.
*
*Revision History:
*       05-16-92  KRS   Created from vfprintf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vfwprintf(stream, format, ap) - print to file from varargs
*
*Purpose:
*       Performs formatted output to a file.  The arg list is a variable
*       argument list pointer.
*
*Entry:
*       FILE *stream - stream to write data to
*       wchar_t *format - format string containing data format
*       va_list ap - variable arg list pointer
*
*Exit:
*       returns number of correctly output wide characters
*       returns negative number if error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vfwprintf (
        FILE *str,
        const wchar_t *format,
        va_list ap
        )
/*
 * 'V'ariable argument 'F'ile (stream) 'W'char_t 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _woutput(stream,format,ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\ungetwc.c ===
/***
*ungetwc.c - unget a wide character from a stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ungetwc() - pushes a wide character back onto an input stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       04-30-93  CFW   Bring wide char support from ungetc.c.
*       05-10-93  CFW   Optimize, fix error handling.
*       06-02-93  CFW   Wide get/put use wint_t.
*       07-16-93  SRW   ALPHA Merge
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-01-93  CFW   Test only for TEXT, update comments.
*       10-28-93  CFW   Test for both IOSTRG and TEXT.
*       11-10-93  GJF   Merged in NT SDK version (picked up fix to a cast
*                       expression). Also replaced MTHREAD with _MT.
*       02-07-94  CFW   POSIXify.
*       08-31-94  CFW   Fix for "C" locale, call wctomb().
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       03-02-98  GJF   Exception-safe locking.
*       11-05-08  GJF   Don't push back characters onto strings (i.e., when
*                       called by swscanf).
*       12-16-99  GB    Modified for the case when return value from wctomb is
*                       greater then 2.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <setlocal.h>

#ifdef  _MT     /* multi-thread; define both ungetwc and _lk_ungetwc */

/***
*wint_t ungetwc(ch, stream) - put a wide character back onto a stream
*
*Purpose:
*       Guaranteed one char pushback on a stream as long as open for reading.
*       More than one char pushback in a row is not guaranteed, and will fail
*       if it follows an ungetc which pushed the first char in buffer. Failure
*       causes return of WEOF.
*
*Entry:
*       wint_t ch - wide character to push back
*       FILE *stream - stream to push character onto
*
*Exit:
*       returns ch
*       returns WEOF if tried to push WEOF, stream not opened for reading or
*       or if we have already ungetc'd back to beginning of buffer.
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl ungetwc (
        REG2 wint_t ch,
        REG1 FILE *stream
        )
{
        wint_t retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _ungetwc_lk (ch, stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}

/***
*_ungetwc_lk() -  Ungetwc() core routine (locked version)
*
*Purpose:
*       Core ungetwc() routine; assumes stream is already locked.
*
*       [See ungetwc() above for more info.]
*
*Entry: [See ungetwc()]
*
*Exit:  [See ungetwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _ungetwc_lk (
        wint_t ch,
        FILE *str
        )
{

#else   /* non multi-thread; just define ungetc */

wint_t __cdecl ungetwc (
        wint_t ch,
        FILE *str
        )
{

#endif  /* rejoin common code */

        _ASSERTE(str != NULL);

        /*
         * Requirements for success:
         *
         * 1. Character to be pushed back on the stream must not be WEOF.
         *
         * 2. The stream must currently be in read mode, or must be open for
         *    update (i.e., read/write) and must NOT currently be in write
         *    mode.
         */
        if ( (ch != WEOF) &&
             ( (str->_flag & _IOREAD) || ((str->_flag & _IORW) &&
                !(str->_flag & _IOWRT))
             )
           )
        {
                /* If stream is unbuffered, get one. */
                if (str->_base == NULL)
                        _getbuf(str);

#ifndef _NTSUBSET_
                if (!(str->_flag & _IOSTRG) && (_osfile_safe(_fileno(str)) & 
                    FTEXT))
                {
                        /*
                         * Text mode, sigh... Convert the wc to a mbc.
                         */
                        int size, i;
                        char mbc[MB_LEN_MAX];

                        if ((size = wctomb(mbc, ch)) == -1)
                        {
                                /*
                                 * Conversion failed! Set errno and return
                                 * failure.
                                 */
                                errno = EILSEQ;
                                return WEOF;
                        }

                        /* we know _base != NULL; since file is buffered */
                        if (str->_ptr < str->_base + size)
                        {
                                if (str->_cnt)
                                    /* my back is against the wall; i've already done
                                     * ungetwc, and there's no room for this one
                                     */
                                    return WEOF;
                                if (size > str->_bufsiz)
                                    return WEOF;
                                str->_ptr = size + str->_base;
                        }

                        for ( i = size -1; i >= 0; i--)
                        {
                                *--str->_ptr = mbc[i];
                        }
                        str->_cnt += size;

                        str->_flag &= ~_IOEOF;
                        str->_flag |= _IOREAD;  /* may already be set */
                        return (wint_t) (0x0ffff & ch);
                }
#endif
                /*
                 * Binary mode or a string (from swscanf) - push back the wide 
                 * character
                 */

                /* we know _base != NULL; since file is buffered */
                if (str->_ptr < str->_base + sizeof(wchar_t))
                {
                        if (str->_cnt)
                                /* my back is against the wall; i've already done
                                 * ungetc, and there's no room for this one
                                 */
                                return WEOF;
                        if (sizeof(wchar_t) > str->_bufsiz)
                            return WEOF;
                        str->_ptr = sizeof(wchar_t) + str->_base;
                }

                if (str->_flag & _IOSTRG) {
                        /* If stream opened by swscanf do not modify buffer */
                        if (*--((wchar_t *)(str->_ptr)) != (wchar_t)ch) {
                                ++((wchar_t *)(str->_ptr));
                                return WEOF;
                        }
                } else
                        *--((wchar_t *)(str->_ptr)) = (wchar_t)(ch & 0xffff);

                str->_cnt += sizeof(wchar_t);

                str->_flag &= ~_IOEOF;
                str->_flag |= _IOREAD;  /* may already be set */

                return (wint_t)(ch & 0xffff);

        }
        return WEOF;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vprintf.c ===
/***
*vprintf.c - printf from a var args pointer
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vprintf() - print formatted data from an argument list pointer
*
*Revision History:
*       09-02-83  RN    original printf
*       06-17-85  TC    rewrote to use new varargs macros to be vprintf
*       04-13-87  JCR   added const to declaration
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>, <varargs.h> by
*                       <stdarg.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>

/***
*int vprintf(format, ap) - print formatted data from an argument list pointer
*
*Purpose:
*       Prints formatted data items to stdout.  Uses a pointer to a
*       variable length list of arguments instead of an argument list.
*
*Entry:
*       char *format - format string, describes data format to write
*       va_list ap - pointer to variable length arg list
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vprintf (
        const char *format,
        va_list ap
        )
/*
 * stdout 'V'ariable, 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream = stdout;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _output(stream, format, ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vfprintf.c ===
/***
*vfprintf.c - fprintf from variable arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vfprintf() - print formatted output, but take args from
*       a stdargs pointer.
*
*Revision History:
*       09-02-83  RN    original fprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vfprintf
*       04-13-87  JCR   added const to declaration
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>, <varargs.h> by
*                       <stdarg.h>
*       10-03-90  GJF   New-style function declarator.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vfprintf(stream, format, ap) - print to file from varargs
*
*Purpose:
*       Performs formatted output to a file.  The arg list is a variable
*       argument list pointer.
*
*Entry:
*       FILE *stream - stream to write data to
*       char *format - format string containing data format
*       va_list ap - variable arg list pointer
*
*Exit:
*       returns number of correctly output characters
*       returns negative number if error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vfprintf (
        FILE *str,
        const char *format,
        va_list ap
        )
/*
 * 'V'ariable argument 'F'ile (stream) 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _output(stream,format,ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vsnwprnt.c ===
/***
*vsnwprnt.c - "Count" version of vswprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _vsnwprintf() flavor takes a count argument that is
*	the max number of wide characters that should be written to the
*	user's buffer.
*
*Revision History:
*	05-16-91   KRS	Created from vsnprint.c
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define _COUNT_ 1
#include "vswprint.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vsnprint.c ===
/***
*vsnprintf.c - "Count" version of vsprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _vsnprintf() flavor takes a count argument that is
*	the max number of bytes that should be written to the
*	user's buffer.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define _COUNT_ 1
#include "vsprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\ungetc.c ===
/***
*ungetc.c - unget a character from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ungetc() - pushes a character back onto an input stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-16-87  JCR   added support for _IOUNGETC flag
*       08-04-87  JCR   (1) Added _IOSTRG check before setting _IOUNGETC flag.
*                       (2) Allow an ugnetc() before a read has occurred (get a
*                       buffer (ANSI).  [MSC only]
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-25-88  JCR   Allow an ungetc() before read for file opened "r+".
*       05-31-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2 references
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       04-11-89  JCR   Removed _IOUNGETC flag, fseek() no longer needs it
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-13-90  SBM   Compiles cleanly with -W3
*       10-03-90  GJF   New-style function declarators.
*       11-07-92  SRW   Dont modify buffer if stream opened by sscanf
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       04-30-93  CFW   Remove wide char support to ungetwc.c.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>

#ifdef _MT      /* multi-thread; define both ungetc and _lk_ungetc */

/***
*int ungetc(ch, stream) - put a character back onto a stream
*
*Purpose:
*       Guaranteed one char pushback on a stream as long as open for reading.
*       More than one char pushback in a row is not guaranteed, and will fail
*       if it follows an ungetc which pushed the first char in buffer. Failure
*       causes return of EOF.
*
*Entry:
*       char ch - character to push back
*       FILE *stream - stream to push character onto
*
*Exit:
*       returns ch
*       returns EOF if tried to push EOF, stream not opened for reading or
*       or if we have already ungetc'd back to beginning of buffer.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl ungetc (
        REG2 int ch,
        REG1 FILE *stream
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _ungetc_lk (ch, stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}

/***
*_ungetc_lk() -  Ungetc() core routine (locked version)
*
*Purpose:
*       Core ungetc() routine; assumes stream is already locked.
*
*       [See ungetc() above for more info.]
*
*Entry: [See ungetc()]
*
*Exit:  [See ungetc()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _ungetc_lk (
        REG2 int ch,
        FILE *str
        )

{

#else   /* non multi-thread; just define ungetc */

int __cdecl ungetc (
        REG2 int ch,
        FILE *str
        )

{

#endif  /* rejoin common code */

        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;

        /* Stream must be open for read and can NOT be currently in write mode.
           Also, ungetc() character cannot be EOF. */

        if (
              (ch == EOF) ||
              !(
                (stream->_flag & _IOREAD) ||
                ((stream->_flag & _IORW) && !(stream->_flag & _IOWRT))
               )
           )
                return(EOF);

        /* If stream is unbuffered, get one. */

        if (stream->_base == NULL)
                _getbuf(stream);

        /* now we know _base != NULL; since file must be buffered */

        if (stream->_ptr == stream->_base) {
                if (stream->_cnt)
                        /* my back is against the wall; i've already done
                         * ungetc, and there's no room for this one
                         */
                        return(EOF);

                stream->_ptr++;
        }

        if (stream->_flag & _IOSTRG) {
            /* If stream opened by sscanf do not modify buffer */
                if (*--stream->_ptr != (char)ch) {
                        ++stream->_ptr;
                        return(EOF);
                }
        } else
                *--stream->_ptr = (char)ch;

        stream->_cnt++;
        stream->_flag &= ~_IOEOF;
        stream->_flag |= _IOREAD;       /* may already be set */

        return(0xff & ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wfdopen.c ===
/***
*wfdopen.c - open a file descriptor as stream (wchar_t version)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wfdopen() - opens a file descriptor as a stream, thus allowing
*	buffering, etc.
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "fdopen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vsprintf.c ===
/***
*vsprintf.c - print formatted data into a string from var arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vsprintf() and _vsnprintf() - print formatted output to
*       a string, get the data from an argument ptr instead of explicit
*       arguments.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>, <varargs.h> by
*                       <stdarg.h>
*       10-03-90  GJF   New-style function declarator.
*       09-24-91  JCR   Added _vsnprintf()
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-10-00  GB    Added support for knowing the length of formatted
*                       string by passing NULL for input string.
*       03-16-00  GB    Added _vscprintf()
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int vsprintf(string, format, ap) - print formatted data to string from arg ptr
*else
*int _vsnprintf(string, cnt, format, ap) - print formatted data to string from arg ptr
*endif
*
*Purpose:
*       Prints formatted data, but to a string and gets data from an argument
*       pointer.
*       Sets up a FILE so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _vsnprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - place to put destination string
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       char *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of characters in string
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl vsprintf (
        char *string,
        const char *format,
        va_list ap
        )
#else

int __cdecl _vsnprintf (
        char *string,
        size_t count,
        const char *format,
        va_list ap
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(format != NULL);

#ifndef _COUNT_
        _ASSERTE(string != NULL);
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)count;
#endif
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = string;

        retval = _output(outfile,format,ap );
        if ( string!=NULL)
            _putc_lk('\0',outfile);

        return(retval);
}

/***
* _vscprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       char *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_
int __cdecl _vscprintf (
        const char *format,
        va_list ap
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _output(outfile,format,ap);
        return(retval);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wfopen.c ===
/***
*wfopen.c - open a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wfopen() and _wfsopen() - open a file as a stream and open a file
*	with a specified sharing mode as a stream
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "fopen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wfreopen.c ===
/***
*wfreope.c - close a stream and assign it to a new file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wfreopen() - close and reopen file, typically used to redirect
*	stdin/out/err/prn/aux.
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "freopen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\woutput.c ===
/***
*woutput.c - wprintf style output to a FILE (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the symbol UNICODE and then #includes the file
*	"output.c" in order to implement _woutput(), the helper for the
*	wide character versions of *wprintf() family of functions.
*
*Revision History:
*	04-27-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "output.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vswprint.c ===
/***
*vswprint.c - print formatted data into a string from var arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vswprintf() and _vsnwprintf() - print formatted output to
*       a string, get the data from an argument ptr instead of explicit
*       arguments.
*
*Revision History:
*       05-16-92  KRS   Created from vsprintf.c.
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-16-00  GB    Added _vscwprintf()
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int vswprintf(string, format, ap) - print formatted data to string from arg ptr
*else
*int _vsnwprintf(string, cnt, format, ap) - print formatted data to string from arg ptr
*endif
*
*Purpose:
*       Prints formatted data, but to a string and gets data from an argument
*       pointer.
*       Sets up a FILE so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _vsnwprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       wchar_t *string - place to put destination string
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       wchar_t *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of wide characters in string
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl vswprintf (
        wchar_t *string,
        const wchar_t *format,
        va_list ap
        )
#else

int __cdecl _vsnwprintf (
        wchar_t *string,
        size_t count,
        const wchar_t *format,
        va_list ap
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(string != NULL);
        _ASSERTE(format != NULL);

        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = (char *) string;
#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)(count*sizeof(wchar_t));
#endif

        retval = _woutput(outfile,format,ap );
        _putc_lk('\0',outfile);     /* no-lock version */
        _putc_lk('\0',outfile);     /* 2nd byte for wide char version */

        return(retval);
}


/***
* _vscwprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       wchar_t *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/


#ifndef _COUNT_
int __cdecl _vscwprintf (
        const wchar_t *format,
        va_list ap
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _woutput(outfile,format,ap);
        return(retval);
}
#endif
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\winput.c ===
/***
*winput.c - wscanf style input from a FILE (wchar_t version)
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the symbol UNICODE and then #includes the file
*	"input.c" in order to implement _winput(), the helper for the
*	wide character versions of the *wscanf() family of functions.
*
*Revision History:
*	04-27-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "input.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\vwprintf.c ===
/***
*vwprintf.c - wprintf from a var args pointer
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vwprintf() - print formatted data from an argument list pointer
*
*Revision History:
*       05-16-92  KRS   Created from vprintf.c
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>

/***
*int vwprintf(format, ap) - print formatted data from an argument list pointer
*
*Purpose:
*       Prints formatted data items to stdout.  Uses a pointer to a
*       variable length list of arguments instead of an argument list.
*
*Entry:
*       wchar_t *format - format string, describes data format to write
*       va_list ap - pointer to variable length arg list
*
*Exit:
*       returns number of wide characters written
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vwprintf (
        const wchar_t *format,
        va_list ap
        )
/*
 * stdout 'V'ariable, 'W'char_t 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream = stdout;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _woutput(stream, format, ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wtempnam.c ===
/***
*wtempnam.c - generate unique file name (wchar_t version)
*
*	Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-21-95  GJF	Deleted obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "tempnam.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wtmpfile.c ===
/***
*wtmpfile.c - create unique file name or file (wchar_t version)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wtmpnam().
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-21-95  GJF	Deleted obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "tmpfile.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wprintf.c ===
/***
*wprintf.c - print formatted
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wprintf() - print formatted data
*
*Revision History:
*       05-16-92  KRS   Created from printf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-95  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int wprintf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on stdout using the format string to
*       format data and getting as many arguments as called for
*       Uses temporary buffering to improve efficiency.
*       _output does the real work here
*
*Entry:
*       wchar_t *format - format string to control data format/number of arguments
*       followed by list of arguments, number and type controlled by
*       format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wprintf (
        const wchar_t *format,
        ...
        )
/*
 * stdout 'W'char_t 'PRINT', 'F'ormatted
 */
{
        va_list arglist;
        int buffing;
        int retval;

// UNDONE: make va_start work with wchar_t format string
        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(1, stdout);
        __try {
#endif

        buffing = _stbuf(stdout);

        retval = _woutput(stdout,format,arglist);

        _ftbuf(buffing, stdout);

#ifdef  _MT
        }
        __finally {
            _unlock_str2(1, stdout);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wpopen.c ===
/***
*wpopen.c - initiate a pipe and a child command (wchar_t version)
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wpopen().
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "popen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\wscanf.c ===
/***
*wscanf.c - read formatted data from stdin
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wscanf() - reads formatted data from stdin
*
*Revision History:
*       05-16-92  KRS   Created from scanf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macro.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int wscanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       Reads formatted data from stdin into arguments.  _input does the real
*       work here.
*
*Entry:
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wscanf (
        const wchar_t *format,
        ...
        )
/*
 * stdin 'W'char_t 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

// UNDONE: make va_start work with wchar_t format string
        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(0, stdin);
        __try {
#endif

        retval = (_winput(stdin,format,arglist));

#ifdef  _MT
        }
        __finally {
            _unlock_str2(0, stdin);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_filwbuf.c ===
/***
*_filwbuf.c - fill buffer and get wide character
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _filwbuf() - fill buffer and read first character, allocate
*	buffer if there is none.  Used from getwc().
*
*Revision History:
*	04-27-93  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-16-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_


#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "_filbuf.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_filbuf.c ===
/***
*_filbuf.c - fill buffer and get character
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _filbuf() - fill buffer and read first character, allocate
*       buffer if there is none.  Used from getc().
*       defines _filwbuf() - fill buffer and read first wide character, allocate
*       buffer if there is none.  Used from getwc().
*
*Revision History:
*       09-01-83  RN    initial version
*       06-26-85  TC    added code to handle variable length buffers
*       04-16-87  JCR   added _IOUNGETC support
*       08-04-87  JCR   added _getbuff routine
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-06-87  JCR   Multi-thread support; also, split _getbuf() off
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-11-88  JCR   Merged mthread version into normal code
*       01-13-88  SKS   Changed bogus "_fileno_lk" to "fileno"
*       03-04-88  JCR   Read() return value must be considered unsigned, not
*                       signed
*       06-06-88  JCR   Optimized _iob2 references
*       06-13-88  JCR   Use near pointer to reference _iob[] entries
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       06-20-89  PHG   Re-activate C version, propogated fixes
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       alignment.
*       03-16-90  GJF   Replaced cdecl _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       03-27-90  GJF   Added #include <io.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       05-06-93  CFW   Optimize wide char conversion.
*       05-24-93  GJF   Detect small buffer size (_SMALL_BUFSIZ) resulting
*                       from fseek call on read-access-only stream and
*                       restore the larger size (_INTERNAL_BUFSIZ) for the
*                       next _filbuf call.
*       06-22-93  GJF   Check _IOSETVBUF (new) before changing buffer size.
*       11-05-93  GJF   Merged with NT SDK version (picked up _NTSUBSET_
*                       stuff).
*       10-17-94  BWT   Move wchar.h to non-POSIX build (ino_t definitions conflict)
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-16-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-27-95  GJF   Replaced _osfile() with _osfile_safe().
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <malloc.h>
#include <internal.h>
#ifdef  _POSIX_
#include <unistd.h>
#include <errno.h>
#else
#include <msdos.h>
#include <wchar.h>
#endif
#ifdef  _MT
#include <mtdll.h>
#endif
#include <tchar.h>

#ifndef _UNICODE

/***
*int _filbuf(stream) - fill buffer and get first character
*
*Purpose:
*       get a buffer if the file doesn't have one, read into it, return first
*       char. try to get a buffer, if a user buffer is not assigned. called
*       only from getc; intended for use only within library. assume no input
*       stream is to remain unbuffered when memory is available unless it is
*       marked _IONBF. at worst, give it a single char buffer. the need for a
*       buffer, no matter how small, becomes evident when we consider the
*       ungetc's necessary in scanf
*
*       [NOTE: Multi-thread - _filbuf() assumes that the caller has aquired
*       the stream lock, if needed.]
*
*Entry:
*       FILE *stream - stream to read from
*
*Exit:
*       returns first character from buffer (next character to be read)
*       returns EOF if the FILE is actually a string, or not open for reading,
*       or if open for writing or if no more chars to read.
*       all fields in FILE structure may be changed except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _filbuf (
        FILE *str
        )

#else  /* _UNICODE */

/***
*int _filwbuf(stream) - fill buffer and get first wide character
*
*Purpose:
*       get a buffer if the file doesn't have one, read into it, return first
*       char. try to get a buffer, if a user buffer is not assigned. called
*       only from getc; intended for use only within library. assume no input
*       stream is to remain unbuffered when memory is available unless it is
*       marked _IONBF. at worst, give it a single char buffer. the need for a
*       buffer, no matter how small, becomes evident when we consider the
*       ungetc's necessary in scanf
*
*       [NOTE: Multi-thread - _filwbuf() assumes that the caller has aquired
*       the stream lock, if needed.]
*
*Entry:
*       FILE *stream - stream to read from
*
*Exit:
*       returns first wide character from buffer (next character to be read)
*       returns WEOF if the FILE is actually a string, or not open for reading,
*       or if open for writing or if no more chars to read.
*       all fields in FILE structure may be changed except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _filwbuf (
        FILE *str
        )

#endif  /* _UNICODE */

{
#ifdef  _NTSUBSET_

        return(_TEOF);

#else   /* ndef _NTSUBSET_ */

        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init pointer to _iob2 entry. */
        stream = str;

        if (!inuse(stream) || stream->_flag & _IOSTRG)
                return(_TEOF);

        if (stream->_flag & _IOWRT) {
#ifdef  _POSIX_
                errno = EBADF;
#endif
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

        stream->_flag |= _IOREAD;

        /* Get a buffer, if necessary. */

        if (!anybuf(stream))
                _getbuf(stream);
        else
                stream->_ptr = stream->_base;

#ifdef  _POSIX_
        stream->_cnt = read(fileno(stream), stream->_base, stream->_bufsiz);
#else
        stream->_cnt = _read(_fileno(stream), stream->_base, stream->_bufsiz);
#endif

#ifndef _UNICODE
        if ((stream->_cnt == 0) || (stream->_cnt == -1)) {
#else /* _UNICODE */
        if ((stream->_cnt == 0) || (stream->_cnt == 1) || stream->_cnt == -1) {
#endif /* _UNICODE */
                stream->_flag |= stream->_cnt ? _IOERR : _IOEOF;
                stream->_cnt = 0;
                return(_TEOF);
        }

#ifndef _POSIX_
        if (  !(stream->_flag & (_IOWRT|_IORW)) &&
              ((_osfile_safe(_fileno(stream)) & (FTEXT|FEOFLAG)) == 
                (FTEXT|FEOFLAG)) )
                stream->_flag |= _IOCTRLZ;
#endif
        /* Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and
           if it is our buffer, then this must be the first _filbuf after
           an fseek on a read-access-only stream. Restore _bufsiz to its
           larger value (_INTERNAL_BUFSIZ) so that the next _filbuf call,
           if one is made, will fill the whole buffer. */
        if ( (stream->_bufsiz == _SMALL_BUFSIZ) && (stream->_flag &
              _IOMYBUF) && !(stream->_flag & _IOSETVBUF) )
        {
                stream->_bufsiz = _INTERNAL_BUFSIZ;
        }
#ifndef _UNICODE
        stream->_cnt--;
        return(0xff & *stream->_ptr++);
#else   /* _UNICODE */
        stream->_cnt -= sizeof(wchar_t);
        return (0xffff & *((wchar_t *)(stream->_ptr))++);
#endif  /* _UNICODE */

#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_flswbuf.c ===
/***
*_flswbuf.c - flush buffer and output wide character.
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _flswbuf() - flush a file buffer and output a wide character.
*	If no buffer, make one.
*
*Revision History:
*	04-27-93  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-16-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_


#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "_flsbuf.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_file.c ===
/***
*_file.c - Definition of _iob[], initializer and terminator.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _iob[], the array of stdio control structures, the initializer
*       and terminator routines, and the multithread locking for stdio.
*
*Revision History:
*       04-18-84  RN    initial version
*       ??-??-??  TC    added field _bifsiz to iob2 to allow variable
*                       length buffers
*       10-02-86  SKS   _NFILE_ is now different for real-mode and prot-mode
*                       _NFILE_ must be defined by compiler -D directory
*       05-27-87  JCR   Protected mode now uses only 3 pre-defined file handles,
*                       not 5.  Added PM (prot mode) to conditionalize handles.
*       06-24-87  SKS   Make "_bufin[]" and "_bufout[]" near for Compact/Large
*                       models (MS real-mode version only)
*       07-01-87  PHG   Changed PM switch to PROTMODE
*       11-05-87  JCR   Added _buferr and modified stderr entry
*       11-09-87  SKS   Removed IBMC20 switch, Changed PROTMODE to OS2
*       01-04-88  JCR   Moved _NFILE_ definition from command line to file
*       01-11-88  JCR   Merged Mthread version into standard version
*       01-21-88  JCR   Removed reference to internal.h and added _NEAR_
*                       (thus, internal.h doesn't get released in startup
*                       sources even though _file.c does).
*       06-28-88  JCR   Remove static stdout/stderr buffers
*       07-06-88  JCR   Corrected _bufin declaration so it's always in BSS
*       08-24-88  GJF   Added check that OS2 is defined whenever M_I386 is.
*       06-08-89  GJF   Propagated SKS's fix of 02-08-89, and fixed copyright.
*       07-25-89  GJF   Cleanup (deleted DOS specific and OS/2 286 specific
*                       stuff). Now specific to the 386.
*       01-09-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright
*       03-16-90  GJF   Added #include <cruntime.h> and removed some (now)
*                       useless preprocessor stuff.
*       03-26-90  GJF   Replaced _cdecl with _VARTYPE1.
*       02-14-92  GJF   Replaced _NFILE_ with _NSTREAM_ for Win32, with _NFILE
*                       for non-Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       04-04-94  GJF   #ifndef-ed out for Win32S version of msvcrt*.dll.
*                       Also, deleted old conditionals for non-Win32 support.
*       08-18-94  GJF   Moved stdio terminator stuff from fflush.c to here
*                       and added an initializer which fixes the _file field
*                       of _iob[0], _iob[1] and _iob[2] when the underlying
*                       entries in _osfhnd[0], _osfhnd[1], _osfhnd[2] are
*                       invalid (0 or -1).
*       02-17-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       03-01-95  GJF   Changes to manage streams via __piob[], rather than
*                       _iob[].
*       06-12-95  GJF   Replaced _osfhnd[] with _osfhnd() (macro referencing
*                       field in ioinfo struct).
*       06-19-97  GJF   Moved _[un]lock_file[2]() here from startup\mlock.c.
*       02-13-98  GJF   Changes for Win32: changed long cast to intptr_t.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       09-26-97  BWT   Fix POSIX
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <rterr.h>
#include <dbgint.h>
#include <mtdll.h>

/*
 * Buffer for stdin.
 */

char _bufin[_INTERNAL_BUFSIZ];

/*
 * FILE descriptors; preset for stdin/out/err (note that the __tmpnum field
 * is not initialized)
 */
FILE _iob[_IOB_ENTRIES] = {
        /* _ptr, _cnt, _base,  _flag, _file, _charbuf, _bufsiz */

        /* stdin (_iob[0]) */

        { _bufin, 0, _bufin, _IOREAD | _IOYOURBUF, 0, 0, _INTERNAL_BUFSIZ },

        /* stdout (_iob[1]) */

        { NULL, 0, NULL, _IOWRT, 1, 0, 0 },

        /* stderr (_iob[3]) */

        { NULL, 0, NULL, _IOWRT, 2, 0, 0 },

};


/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP FILE * __cdecl __iob_func(void)
{
    return _iob;
}


/*
 * Pointer to array of FILE * or _FILEX * structures.
 */
void ** __piob;

/*
 * Number of open streams (set to _NSTREAM by default)
 */
#ifdef  CRTDLL
int _nstream = _NSTREAM_;
#else
int _nstream;
#endif


/*
 * Initializer and terminator for stdio
 */
int  __cdecl __initstdio(void);
void __cdecl __endstdio(void);

#ifdef  _MSC_VER

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __initstdio;

#pragma data_seg(".CRT$XPX")
_CRTALLOC(".CRT$XPX") static _PVFV pterm = __endstdio;

#pragma data_seg()

#endif  /* _MSC_VER */

#ifndef CRTDLL
/*
 * _cflush is a dummy variable used to pull in _endstdio() when any STDIO
 * routine is included in the user program.
 */
int _cflush = 0;
#endif  /* CRTDLL */


/***
* __initstdio - Initialize the stdio system
*
*Purpose:
*       Create and initialize the __piob array.
*
*Entry: <void>
*
*Exit:  Returns _RT_STDIOINIT if error encountered.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __initstdio(void)
{
        int i;

#ifndef CRTDLL
        /*
         * If the user has not supplied a definition of _nstream, set it
         * to _NSTREAM_. If the user has supplied a value that is too small
         * set _nstream to the minimum acceptable value (_IOB_ENTRIES).
         */
        if ( _nstream ==  0 )
            _nstream = _NSTREAM_;
        else if ( _nstream < _IOB_ENTRIES )
            _nstream = _IOB_ENTRIES;
#endif

        /*
         * Allocate the __piob array. Try for _nstream entries first. If this
         * fails then reset _nstream to _IOB_ENTRIES and try again. If it
         * still fails, bail out with an RTE.
         */
        if ( (__piob = (void **)_calloc_crt( _nstream, sizeof(void *) )) ==
             NULL ) {
            _nstream = _IOB_ENTRIES;
            if ( (__piob = (void **)_calloc_crt( _nstream, sizeof(void *) ))
                 == NULL )
                return _RT_STDIOINIT;
        }

        /*
         * Initialize the first _IOB_ENTRIES to point to the corresponding
         * entries in _iob[].
         */
        for ( i = 0 ; i < _IOB_ENTRIES ; i++ )
            __piob[i] = (void *)&_iob[i];

#ifndef _POSIX_
        for ( i = 0 ; i < 3 ; i++ ) {
            if ( (_osfhnd(i) == (intptr_t)INVALID_HANDLE_VALUE) ||
                 (_osfhnd(i) == 0) )
            {
                _iob[i]._file = -1;
            }
        }
#endif

        return 0;
}


/***
* __endstdio - Terminate the stdio system
*
*Purpose:
*       Terminate the stdio system
*
*       (1) Flush all streams.  (Do this even if we're going to
*       call fcloseall since that routine won't do anything to the
*       std streams.)
*
*       (2) If returning to caller, close all streams.  This is
*       not necessary if the exe is terminating because the OS will
*       close the files for us (much more efficiently, too).
*
*Entry: <void>
*
*Exit:  <void>
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __endstdio(void)
{
        /* flush all streams */
        _flushall();

        /* if in callable exit, close all streams */
        if (_exitflag)
                _fcloseall();
}


#ifdef  _MT

/***
* _lock_file - Lock a FILE
*
*Purpose:
*       Assert the lock for a stdio-level file
*
*Entry:
*       pf = __piob[] entry (pointer to a FILE or _FILEX)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock_file (
        void *pf
        )
{
        /*
         * The way the FILE (pointed to by pf) is locked depends on whether
         * it is part of _iob[] or not
         */
        if ( (pf >= (void *)_iob) && (pf <= (void *)(&_iob[_IOB_ENTRIES-1])) )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _lock( _STREAM_LOCKS + (int)((FILE *)pf - _iob) );
        else
            /*
             * Not part of _iob[]. Therefore, *pf is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            EnterCriticalSection( &(((_FILEX *)pf)->lock) );
}


/***
* _lock_file2(i, s) - Lock the FILE
*
*Purpose:
*       Assert the lock for a stdio-level file given by s == __piob[i].
*
*Entry:
*       s == __piob[i]
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock_file2 (
        int i,
        void *s
        )
{
        /*
         * The way the FILE is locked depends on whether it is part of _iob[]
         * _iob[] or not
         */
        if ( i < _IOB_ENTRIES )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _lock( _STREAM_LOCKS + i );
        else
            /*
             * Not part of _iob[]. Therefore, *s is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            EnterCriticalSection( &(((_FILEX *)s)->lock) );
}


/***
* _unlock_file - Unlock a FILE
*
*Purpose:
*       Release the lock for a stdio-level file
*
*Entry:
*       pf = __piob[] entry (pointer to a FILE or _FILEX)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_file (
        void *pf
        )
{
        /*
         * The way the FILE (pointed to by pf) is unlocked depends on whether
         * it is part of _iob[] or not
         */
        if ( (pf >= (void *)_iob) && (pf <= (void *)(&_iob[_IOB_ENTRIES-1])) )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _unlock( _STREAM_LOCKS + (int)((FILE *)pf - _iob) );
        else
            /*
             * Not part of _iob[]. Therefore, *pf is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            LeaveCriticalSection( &(((_FILEX *)pf)->lock) );
}


/***
* _unlock_file2(i, s) - Lock the FILE
*
*Purpose:
*       Release the lock for a stdio-level file given by s == __piob[i].
*
*Entry:
*       s == __piob[i]
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_file2 (
        int i,
        void *s
        )
{
        /*
         * The way the FILE is locked depends on whether it is part of _iob[]
         * _iob[] or not
         */
        if ( i < _IOB_ENTRIES )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _unlock( _STREAM_LOCKS + i );
        else
            /*
             * Not part of _iob[]. Therefore, *s is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            LeaveCriticalSection( &(((_FILEX *)s)->lock) );
}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_flsbuf.c ===
/***
*_flsbuf.c - flush buffer and output character.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _flsbuf() - flush a file buffer and output a character.
*       defines _flswbuf() - flush a file buffer and output a wide character.
*       If no buffer, make one.
*
*Revision History:
*       09-01-83  RN    initial version
*       06-26-85  TC    added code to handle variable length buffers
*       06-08-87  JCR   When buffer is allocated or when first write to buffer
*                       occurs, if stream is in append mode, then position file
*                       pointer to end.
*       07-20-87  SKS   Change first parameter "ch" from (char) to (int)
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-05-87  JCR   Re-wrote for simplicity and for new stderr/stdout
*                       handling
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-11-88  JCR   Merged mthread version into normal code
*       01-13-88  SKS   Changed bogus "_fileno_lk" to "fileno"
*       06-06-88  JCR   Optimized _iob2 references
*       06-13-88  JCR   Use near pointer to reference _iob[] entries
*       06-28-88  JCR   Support for dynamic buffer allocation for stdout/stderr
*       07-28-88  GJF   Set stream->_cnt to 0 if _IOREAD is set.
*       08-25-88  GJF   Added checked that OS2 is defined whenever M_I386 is.
*       06-20-89  PHG   Removed FP_OFF macro call.
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-16-90  GJF   Replaced cdecl _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       03-27-90  GJF   Added #include <io.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-07-90  SBM   Restored descriptive text in assertion
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-03-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-25-91  DJM   POSIX support
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       05-06-93  CFW   Optimize wide char conversion.
*       11-05-93  GJF   Merged with NT SDK version (picked up _NTSUBSET_
*                       stuff).
*       10-17-94  BWT   Move wchar.h to non-POSIX build (ino_t definitions conflict)
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-16-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-25-95  GJF   Replaced _osfile()with _osfile_safe().
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       02-27-98  RKP   Added 64 bit support.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <malloc.h>
#ifdef  _POSIX_
#include <unistd.h>
#include <errno.h>
#else
#include <msdos.h>
#include <wchar.h>
#endif
#include <internal.h>
#ifdef  _MT
#include <mtdll.h>
#endif
#include <tchar.h>

#ifndef _UNICODE

/***
*int _flsbuf(ch, stream) - flush buffer and output character.
*
*Purpose:
*       flush a buffer if this stream has one. if not, try to get one. put the
*       next output char (ch) into the buffer (or output it immediately if this
*       stream can't have a buffer). called only from putc. intended for use
*       only within library.
*
*       [NOTE: Multi-thread - It is assumed that the caller has aquired
*       the stream lock.]
*
*Entry:
*       FILE *stream - stream to flish and write on
*       int ch - character to output.
*
*Exit:
*       returns -1 if FILE is actually a string, or if can't write ch to
*       unbuffered file, or if we flush a buffer but the number of chars
*       written doesn't agree with buffer size.  Otherwise returns ch.
*       all fields in FILE struct can be affected except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flsbuf (
        int ch,
        FILE *str
        )

#else  /* _UNICODE */

/***
*int _flswbuf(ch, stream) - flush buffer and output wide character.
*
*Purpose:
*       flush a buffer if this stream has one. if not, try to get one. put the
*       next output wide char (ch) into the buffer (or output it immediately if this
*       stream can't have a buffer). called only from putwc. intended for use
*       only within library.
*
*       [NOTE: Multi-thread - It is assumed that the caller has aquired
*       the stream lock.]
*
*Entry:
*       FILE *stream - stream to flish and write on
*       int ch - wide character to output.
*
*Exit:
*       returns -1 if FILE is actually a string, or if can't write ch to
*       unbuffered file, or if we flush a buffer but the number of wide chars
*       written doesn't agree with buffer size.  Otherwise returns ch.
*       all fields in FILE struct can be affected except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flswbuf (
        int ch,
        FILE *str
        )

#endif  /* _UNICODE */

{
#ifdef  _NTSUBSET_

        str->_flag |= _IOERR;
        return(_TEOF);

#else   /* ndef _NTSUBSET_ */

        REG1 FILE *stream;
        REG2 int charcount;
        REG3 int written;
        int fh;

        _ASSERTE(str != NULL);

        /* Init file handle and pointers */
        stream = str;
#ifdef  _POSIX_
        fh = fileno(stream);
#else
        fh = _fileno(stream);
#endif

        if (!(stream->_flag & (_IOWRT|_IORW)) || (stream->_flag & _IOSTRG)) {
#ifdef  _POSIX_
                errno = EBADF;
#endif
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

        /* Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note
           that _IOREAD and IOEOF both being set implies switching from read to
           write at end-of-file, which is allowed by ANSI. Note that resetting
           the _cnt and _ptr fields amounts to doing an fflush() on the stream
           in this case. Note also that the _cnt field has to be reset to 0 for
           the error path as well (i.e., _IOREAD set but _IOEOF not set) as
           well as the non-error path. */

        if (stream->_flag & _IOREAD) {
                stream->_cnt = 0;
                if (stream->_flag & _IOEOF) {
                        stream->_ptr = stream->_base;
                        stream->_flag &= ~_IOREAD;
                }
                else {
                        stream->_flag |= _IOERR;
                        return(_TEOF);
                }
        }

        stream->_flag |= _IOWRT;
        stream->_flag &= ~_IOEOF;
        written = charcount = stream->_cnt = 0;

        /* Get a buffer for this stream, if necessary. */
        if (!anybuf(stream)) {

                /* Do NOT get a buffer if (1) stream is stdout/stderr, and
                   (2) stream is NOT a tty.
                   [If stdout/stderr is a tty, we do NOT set up single char
                   buffering. This is so that later temporary buffering will
                   not be thwarted by the _IONBF bit being set (see
                   _stbuf/_ftbuf usage).]
                */
                if (!( ((stream==stdout) || (stream==stderr))
#ifdef  _POSIX_
                && (isatty(fh)) ))
#else
                && (_isatty(fh)) ))
#endif

                        _getbuf(stream);

        } /* end !anybuf() */

        /* If big buffer is assigned to stream... */
        if (bigbuf(stream)) {

                _ASSERTE(("inconsistent IOB fields", stream->_ptr - stream->_base >= 0));

                charcount = (int)(stream->_ptr - stream->_base);
                stream->_ptr = stream->_base + sizeof(TCHAR);
                stream->_cnt = stream->_bufsiz - (int)sizeof(TCHAR);

                if (charcount > 0)
#ifdef  _POSIX_
                        written = write(fh, stream->_base, charcount);
#else
                        written = _write(fh, stream->_base, charcount);
#endif
                else
#ifdef  _POSIX_
                        if (stream->_flag & _IOAPPEND)
                            lseek(fh,0l,SEEK_END);
#else
                        if (_osfile_safe(fh) & FAPPEND)
                                _lseek(fh,0L,SEEK_END);
#endif

#ifndef _UNICODE
                *stream->_base = (char)ch;
#else   /* _UNICODE */
                *(wchar_t *)(stream->_base) = (wchar_t)(ch & 0xffff);
#endif  /* _UNICODE */
        }

    /* Perform single character output (either _IONBF or no buffering) */
        else {
                charcount = sizeof(TCHAR);
#ifndef _UNICODE
#ifdef  _POSIX_
                written = write(fh, &ch, charcount);
#else
                written = _write(fh, &ch, charcount);
#endif
#else   /* _UNICODE */
                {
                        char mbc[4];

                        *(wchar_t *)mbc = (wchar_t)(ch & 0xffff);
#ifdef  _POSIX_
                        written = write(fh, mbc, charcount);
#else
                        written = _write(fh, mbc, charcount);
#endif
                }
#endif  /* _UNICODE */
        }

        /* See if the _write() was successful. */
        if (written != charcount) {
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

#ifndef _UNICODE
        return(ch & 0xff);
#else   /* _UNICODE */
        return(ch & 0xffff);
#endif  /* _UNICODE */

#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_freebuf.c ===
/***
*_freebuf.c - release a buffer from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _freebuf() - release a buffer from a stream
*
*Revision History:
*       09-19-83  RN    initial version
*       02-15-90  GJF   Fixed copyright, alignment.
*       03-16-90  GJF   Replaced cdecl _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       02-14-92  GJF   Replaced _nfile with _nhandle for Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-22-93  GJF   Clear _IOSETVBUF flag (new).
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-04-95  GJF   _WIN32_ -> _WIN32.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-16-95  GJF   Merged in Mac version.
*       09-06-95  GJF   Removed inappropriate ASSERTE()-s.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <stdlib.h>

/***
*void _freebuf(stream) - release a buffer from a stream
*
*Purpose:
*       free a buffer if at all possible. free() the space if malloc'd by me.
*       forget about trying to free a user's buffer for him; it may be static
*       memory (not from malloc), so he has to take care of it. this function
*       is not intended for use outside the library.
*
*ifdef _MT
*       Multi-thread notes:
*       _freebuf() does NOT get the stream lock; it is assumed that the
*       caller has already done this.
*endif
*
*Entry:
*       FILE *stream - stream to free bufer on
*
*Exit:
*       Buffer may be freed.
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _freebuf (
        REG1 FILE *stream
        )
{
        _ASSERTE(stream != NULL);

        if (inuse(stream) && mbuf(stream))
        {
                _free_crt(stream->_base);

                stream->_flag &= ~(_IOMYBUF | _IOSETVBUF);
                stream->_base = stream->_ptr = NULL;
                stream->_cnt = 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_open.c ===
/***
*_open.c - open a stream, with string mode
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _openfile() - opens a stream, with string arguments for mode
*
*Revision History:
*       09-02-83  RN    initial version
*       03-02-87  JCR   made _openfile recognize "wb+" as equal to "w+b", etc.
*                       got rid of intermediate _openfile flags (internal) and
*                       now go straight from mode string to open system call
*                       and system->_flags.
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       02-21-88  SKS   Removed #ifdef IBMC20
*       06-06-88  JCR   Optimized _iob2 references
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       08-19-88  GJF   Initial adaption for the 386.
*       11-14-88  GJF   Added shflag (file sharing flag) parameter, also some
*                       cleanup (now specific to the 386).
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright.
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-27-90  GJF   Added const qualifier to types of filename and mode.
*                       Added #include <io.h>.
*       07-11-90  SBM   Added support for 'c' and 'n' flags
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       03-11-92  GJF   Replaced __tmpnum field with _tmpfname field for
*                       Win32.
*       03-25-92  DJM   POSIX support.
*       08-26-92  GJF   Fixed POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-24-93  PML   Added support for 'D', 'R', 'S' and 'T' flags
*       11-01-93  CFW   Enable Unicode variant, rip out CRUISER.
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <fcntl.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <internal.h>
#include <tchar.h>

#define CMASK   0644    /* rw-r--r-- */
#define P_CMASK 0666    /* different for Posix */

/***
*FILE *_openfile(filename, mode, shflag, stream) - open a file with string
*       mode and file sharing flag.
*
*Purpose:
*       parse the string, looking for exactly one of {rwa}, at most one '+',
*       at most one of {tb}, at most one of {cn}, at most one of {SR}, at most
*       one 'T', and at most one 'D'. pass the result on as an int containing
*       flags of what was found. open a file with proper mode if permissions
*       allow. buffer not allocated until first i/o call is issued. intended
*       for use inside library only
*
*Entry:
*       char *filename - file to open
*       char *mode - mode to use (see above)
*       int shflag - file sharing flag
*       FILE *stream - stream to use for file
*
*Exit:
*       set stream's fields, and causes system file management by system calls
*       returns stream or NULL if fails
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
FILE * __cdecl _wopenfile (
#else
FILE * __cdecl _openfile (
#endif
        const _TSCHAR *filename,
        REG3 const _TSCHAR *mode,
#ifndef _POSIX_
        int shflag,
#endif
        FILE *str
        )
{
        REG2 int modeflag;
#ifdef _POSIX_
        int streamflag = 0;
#else
        int streamflag = _commode;
        int commodeset = 0;
        int scanset    = 0;
#endif
        int whileflag;
        int filedes;
        REG1 FILE *stream;

        _ASSERTE(filename != NULL);
        _ASSERTE(mode != NULL);
        _ASSERTE(str != NULL);

        /* Parse the user's specification string as set flags in
               (1) modeflag - system call flags word
               (2) streamflag - stream handle flags word. */

        /* First mode character must be 'r', 'w', or 'a'. */

        switch (*mode) {
        case _T('r'):
#ifdef _POSIX_
                modeflag = O_RDONLY;
#else
                modeflag = _O_RDONLY;
#endif
                streamflag |= _IOREAD;
                break;
        case _T('w'):
#ifdef _POSIX_
                modeflag = O_WRONLY | O_CREAT | O_TRUNC;
#else
                modeflag = _O_WRONLY | _O_CREAT | _O_TRUNC;
#endif
                streamflag |= _IOWRT;
                break;
        case _T('a'):
#ifdef _POSIX_
                modeflag = O_WRONLY | O_CREAT | O_APPEND;
                streamflag |= _IOWRT | _IOAPPEND;
#else
                modeflag = _O_WRONLY | _O_CREAT | _O_APPEND;
                streamflag |= _IOWRT;
#endif
                break;
        default:
                return(NULL);
                break;
        }

        /* There can be up to three more optional mode characters:
           (1) A single '+' character,
           (2) One of 't' and 'b' and
           (3) One of 'c' and 'n'.
        */

        whileflag=1;

        while(*++mode && whileflag)
                switch(*mode) {

                case _T('+'):
#ifdef  _POSIX_
                        if (modeflag & O_RDWR)
                                whileflag=0;
                        else {
                                modeflag |= O_RDWR;
                                modeflag &= ~(O_RDONLY | O_WRONLY);
#else
                        if (modeflag & _O_RDWR)
                                whileflag=0;
                        else {
                                modeflag |= _O_RDWR;
                                modeflag &= ~(_O_RDONLY | _O_WRONLY);
#endif
                                streamflag |= _IORW;
                                streamflag &= ~(_IOREAD | _IOWRT);
                        }
                        break;

                case _T('b'):
#ifndef _POSIX_
                        if (modeflag & (_O_TEXT | _O_BINARY))
                                whileflag=0;
                        else
                                modeflag |= _O_BINARY;
#endif
                        break;

#ifndef _POSIX_
                case _T('t'):
                        if (modeflag & (_O_TEXT | _O_BINARY))
                                whileflag=0;
                        else
                                modeflag |= _O_TEXT;
                        break;

                case _T('c'):
                        if (commodeset)
                                whileflag=0;
                        else {
                                commodeset = 1;
                                streamflag |= _IOCOMMIT;
                        }
                        break;

                case _T('n'):
                        if (commodeset)
                                whileflag=0;
                        else {
                                commodeset = 1;
                                streamflag &= ~_IOCOMMIT;
                        }
                        break;

                case _T('S'):
                        if (scanset)
                                whileflag=0;
                        else {
                                scanset = 1;
                                modeflag |= _O_SEQUENTIAL;
                        }
                        break;

                case _T('R'):
                        if (scanset)
                                whileflag=0;
                        else {
                                scanset = 1;
                                modeflag |= _O_RANDOM;
                        }
                        break;

                case _T('T'):
                        if (modeflag & _O_SHORT_LIVED)
                                whileflag=0;
                        else
                                modeflag |= _O_SHORT_LIVED;
                        break;

                case _T('D'):
                        if (modeflag & _O_TEMPORARY)
                                whileflag=0;
                        else
                                modeflag |= _O_TEMPORARY;
                        break;
#endif

                default:
                        whileflag=0;
                        break;
                }

        /* Try to open the file.  Note that if neither 't' nor 'b' is
           specified, _sopen will use the default. */

#ifdef _POSIX_
        if ((filedes = _topen(filename, modeflag, P_CMASK)) < 0)
#else
        if ((filedes = _tsopen(filename, modeflag, shflag, CMASK)) < 0)
#endif
                return(NULL);

        /* Set up the stream data base. */
#ifndef CRTDLL
        _cflush++;  /* force library pre-termination procedure */
#endif  /* CRTDLL */
        /* Init pointers */
        stream = str;

        stream->_flag = streamflag;
        stream->_cnt = 0;
        stream->_tmpfname = stream->_base = stream->_ptr = NULL;

        stream->_file = filedes;

        return(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\dll\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\dlllib\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\nt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\mt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\psx\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\st\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_getbuf.c ===
/***
*_getbuf.c - Get a stream buffer
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Allocate a buffer and init stream data bases.
*
*Revision History:
*       11-06-87  JCR   Initial version (split off from _filbuf.c)
*       01-11-88  JCR   Moved from mthread/dll only to main code
*       06-06-88  JCR   Optimized _iob2 references
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       07-27-88  GJF   Added _cflush++ to force pre-terminator (necessary in
*                       case stdout has been redirected to a file and acquires
*                       a buffer here, and pre-terminator has not already been
*                       forced).
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-16-90  GJF   Replaced near cdecl with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-27-93  CFW   Change _IONBF size to 2 bytes to hold wide char.
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       11-04-93  SRW   Dont call malloc in _NTSUBSET_ version
*       11-05-93  GJF   Merged with NT SDK version (picked up _NTSUBSET_
*                       stuff).
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <malloc.h>
#include <internal.h>
#include <dbgint.h>

/***
*_getbuf() - Allocate a buffer and init stream data bases
*
*Purpose:
*       Allocates a buffer for a stream and inits the stream data bases.
*
*       [NOTE  1: This routine assumes the caller has already checked to make
*       sure the stream needs a buffer.
*
*       [NOTE 2: Multi-thread - Assumes caller has aquired stream lock, if
*       needed.]
*
*Entry:
*       FILE *stream = stream to allocate a buffer for
*
*Exit:
*       void
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _getbuf (
        FILE *str
        )
{
        REG1 FILE *stream;

        _ASSERTE(str != NULL);

#if     !defined(_NTSUBSET_) && !defined(CRTDLL)
        /* force library pre-termination procedure */
        _cflush++;
#endif

        /* Init pointers */
        stream = str;

#ifndef _NTSUBSET_

        /* Try to get a big buffer */
        if (stream->_base = _malloc_crt(_INTERNAL_BUFSIZ))
        {
                /* Got a big buffer */
                stream->_flag |= _IOMYBUF;
                stream->_bufsiz = _INTERNAL_BUFSIZ;
        }

        else {

#endif  /* _NTSUBSET_ */

                /* Did NOT get a buffer - use single char buffering. */
                stream->_flag |= _IONBF;
                stream->_base = (char *)&(stream->_charbuf);
                stream->_bufsiz = 2;

#ifndef _NTSUBSET_
        }
#endif  /* _NTSUBSET_ */

        stream->_ptr = stream->_base;
        stream->_cnt = 0;

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_wopen.c ===
/***
*_wopen.c - open a stream, with string mode (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wopenfile() - opens a stream, with string arguments for mode
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-20-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "_open.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\stdio\_sftbuf.c ===
/***
*_sftbuf.c - temporary buffering initialization and flushing
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       temporary buffering initialization and flushing. if stdout/err is
*       unbuffered, buffer it temporarily so that string is sent to kernel as
*       a batch of chars, not char-at-a-time. if appropriate, make buffering
*       permanent.
*
*       [NOTE 1: These routines assume that the temporary buffering is only
*       used for output.  In particular, note that _stbuf() sets _IOWRT.]
*
*       [NOTE 2: It is valid for this module to assign a value directly to
*       _flag instead of simply twiddling bits since we are initializing the
*       buffer data base.]
*
*Revision History:
*       09-01-83  RN    initial version
*       06-26-85  TC    added code to _stbuf to allow variable buffer lengths
*       ??-??-??  TC    fixed case in _flbuf where flag is off, but a temporary
*                       buffer still needs to be fflushed.
*       05-27-87  JCR   protect mode does not know about stdprn.
*       06-26-87  JCR   Conditionalized out code in _ftbuf that caused
*                       redirected stdout to be flushed on every call.
*       07-01-87  JCR   Put in code to support re-entrant calling from
*                       interrupt level (MSC only).
*       08-06-87  JCR   Fixed a _ftbuf() problem pertaining to stderr/stdprn
*                       when _bufout is being used by stdout.
*       08-07-87  JCR   (1) When assigning _bufout to an _iob, we now set the
*                       _IOWRT flag.  This fixes a bug involving freopen()
*                       issued against one of the std handles.
*                       (2) Removed some annoying commented out code.
*       08-13-87  JCR   _ftbuf() does NOT clear _IOWRT now.  Fixes a bug where
*                       _getstream() would reassign stdout because none of the
*                       flags were set.
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-05-87  JCR   Re-written for multi-thread support and simplicity
*       01-11-88  JCR   Merged mthread version into normal version
*       01-13-88  SKS   Changed bogus "_fileno_lk" to "fileno"
*       06-06-88  JCR   Optimized _iob2 references
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       06-27-88  JCR   Added stdprn temporary buffering support (DOS only),
*                       and made buffer allocation dynamic; also added _IOFLRTN
*                       (flush stream on per routine basis).
*       08-25-88  GJF   Modified to also work for the 386 (small model only).
*       06-20-89  PHG   Changed return value to void
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit DOS support.
*       03-27-90  GJF   Added #include <io.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary. Also, replaced MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version.
*       02-07-97  GJF   Changed _stbuf() to use _charbuf when malloc fails.
*                       Also, detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <internal.h>
#include <malloc.h>
#ifdef  _MT
#include <mtdll.h>
#endif
#include <dbgint.h>

/* Buffer pointers for stdout and stderr */
void *_stdbuf[2] = { NULL, NULL};

/***
*int _stbuf(stream) - set temp buffer on stdout, stdprn, stderr
*
*Purpose:
*       if stdout/stderr is still unbuffered, buffer it.
*       this function works intimately with _ftbuf, and accompanies it in
*       bracketing normally unbuffered output. these functions intended for
*       library use only.
*
*       Multi-thread: It is assumed that the caller has already aquired the
*       stream lock.
*
*Entry:
*       FILE *stream - stream to temp buffer
*
*Exit:
*       returns 1 if buffer initialized, 0 if not
*       sets fields in stdout or stderr to indicate buffering
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _stbuf (
        FILE *str
        )
{
        REG1 FILE *stream;
        int index;

        _ASSERTE(str != NULL);

        /* Init near stream pointer */
        stream = str;

        /* do nothing if not a tty device */
#ifdef _POSIX_
        if (!isatty(fileno(stream)))
#else
        if (!_isatty(_fileno(stream)))
#endif
                return(0);

        /* Make sure stream is stdout/stderr and init _stdbuf index */
        if (stream == stdout)
                index = 0;
        else if (stream == stderr)
                index = 1;
        else
                return(0);

#ifndef CRTDLL
        /* force library pre-termination procedure */
        _cflush++;
#endif  /* CRTDLL */

        /* Make sure the stream is not already buffered. */
        if (anybuf(stream))
                return(0);

        /* Allocate a buffer for this stream if we haven't done so yet. */
        if ( (_stdbuf[index] == NULL) &&
             ((_stdbuf[index]=_malloc_crt(_INTERNAL_BUFSIZ)) == NULL) ) {
                /* Cannot allocate buffer. Use _charbuf this time */
                stream->_ptr = stream->_base = (void *)&(stream->_charbuf);
                stream->_cnt = stream->_bufsiz = 2;
        }
        else {
                /* Set up the buffer */
                stream->_ptr = stream->_base = _stdbuf[index];
                stream->_cnt = stream->_bufsiz = _INTERNAL_BUFSIZ;
        }

        stream->_flag |= (_IOWRT | _IOYOURBUF | _IOFLRTN);

        return(1);
}


/***
*void _ftbuf(flag, stream) - take temp buffering off a stream
*
*Purpose:
*       If stdout/stderr is being buffered and it is a device, _flush and
*       dismantle the buffer. if it's not a device, leave the buffering on.
*       This function works intimately with _stbuf, and accompanies it in
*       bracketing normally unbuffered output. these functions intended for
*       library use only
*
*       Multi-thread: It is assumed that the caller has already aquired the
*       stream lock.
*
*Entry:
*       int flag     - a flag to tell whether to dismantle temp buffering on a
*                      stream
*       FILE *stream - the stream
*
*Exit:
*       no return value
*       sets fields in stdout/stderr
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _ftbuf (
        int flag,
        FILE *str
        )
{
        REG1 FILE *stream;

        _ASSERTE(flag == 0 || flag == 1);

        /* Init near stream pointers */
        stream = str;

        if (flag) {

                if (stream->_flag & _IOFLRTN) {

                        /* Flush the stream and tear down temp buffering. */
                        _flush(stream);
                        stream->_flag &= ~(_IOYOURBUF | _IOFLRTN);
                        stream->_bufsiz = 0;
                        stream->_base = stream->_ptr = NULL;
                }

                /* Note: If we expand the functionality of the _IOFLRTN bit to
                include other streams, we may want to clear that bit here under
                an 'else' clause (i.e., clear bit in the case that we leave the
                buffer permanently assigned.  Given our current use of the bit,
                the extra code is not needed. */

        } /* end flag = 1 */

#ifndef _MT
/* NOTE: Currently, writing to the same string at interrupt level does not
   work in multi-thread programs. */

/* The following code is needed if an interrupt occurs between calls
   to _stbuf/_ftbuf and the interrupt handler also calls _stbuf/_ftbuf. */

        else
                if (stream->_flag & _IOFLRTN)
                        _flush(stream);

#endif  /* _MT */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\makefile.inc ===
!if "$(SRCDIR)" == ""
SRCDIR = .^\
!endif

$(SRCDIR)strcspn.c: $(SRCDIR)strspn.c

$(SRCDIR)strpbrk.c: $(SRCDIR)strspn.c

$(SRCDIR)i386\memmove.asm: $(SRCDIR)i386\memcpy.asm

$(SRCDIR)i386\strcspn.asm: $(SRCDIR)i386\strspn.asm

$(SRCDIR)i386\strpbrk.asm: $(SRCDIR)i386\strspn.asm

!if $(IA64)
$(O)\_strcat.s : ..\ia64\strcat.s
   copy $** $@

$(O)\_strcpy.s : ..\ia64\strcpy.s
   copy $** $@

$(O)\_strcmp.s : ..\ia64\strcmp.s
   copy $** $@

$(O)\_strlen.s : ..\ia64\strlen.s
   copy $** $@

$(O)\_memmove.s : ..\ia64\memmove.s
   copy $** $@

$(O)\_memset.s : ..\ia64\memset.s
   copy $** $@

$(O)\_memcpy.s : ..\ia64\memcpy.s
   copy $** $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memccpy.c ===
/***
*memccpy.c - copy bytes until a character is found
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _memccpy() - copies bytes until a specifed character
*       is found, or a maximum number of characters have been copied.
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright. Also, fixed compiler warning.
*       08-14-90   SBM  Compiles cleanly with -W3, removed now redundant
*                       #include <stddef.h>
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       01-17-91   GJF  ANSI naming.
*       09-01-93   GJF  Replaced _CALLTYPE1 with __cdecl.
*       10-27-99   PML  Win64 fix: unsigned int -> size_t
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_memccpy(dest, src, c, count) - copy bytes until character found
*
*Purpose:
*       Copies bytes from src to dest until count bytes have been
*       copied, or up to and including the character c, whichever
*       comes first.
*
*Entry:
*       void *dest - pointer to memory to receive copy
*       void *src  - source of bytes
*       int  c     - character to stop copy at
*       size_t count - max number of bytes to copy
*
*Exit:
*       returns pointer to byte immediately after c in dest
*       returns NULL if c was never found
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _memccpy (
        void * dest,
        const void * src,
        int c,
        size_t count
        )
{
        while ( count && (*((char *)(dest = (char *)dest + 1) - 1) =
        *((char *)(src = (char *)src + 1) - 1)) != (char)c )
                count--;

        return(count ? dest : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memchr.c ===
/***
*memchr.c - search block of memory for a given character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines memchr() - search memory until a character is
*	found or a limit is reached.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3, removed now redundant
*			#include <stddef.h>
*	10-01-90   GJF	New-style function declarator. Also, rewrote expr. to
*			avoid using cast as an lvalue.
*	04-26-91   SRW	Removed level 3 warnings
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	03-15-95   GJF	Unified PMAC and Win32 versions, elimating bug in
*			PMAC version in the process
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *memchr(buf, chr, cnt) - search memory for given character.
*
*Purpose:
*	Searches at buf for the given character, stopping when chr is
*	first found or cnt bytes have been searched through.
*
*Entry:
*	void *buf  - memory buffer to be searched
*	int chr    - character to search for
*	size_t cnt - max number of bytes to search
*
*Exit:
*	returns pointer to first occurence of chr in buf
*	returns NULL if chr not found in the first cnt bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memchr (
	const void * buf,
	int chr,
	size_t cnt
	)
{
	while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
		buf = (unsigned char *)buf + 1;
		cnt--;
	}

	return(cnt ? (void *)buf : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memcmp.c ===
/***
*memcmp.c - compare two blocks of memory
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines memcmp() - compare two memory blocks lexically and
*	find their order.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-01-90   GJF	New-style function declarator. Also, rewrote expr. to
*			avoid using cast as an lvalue.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	10-11-91   GJF	Bug fix! Comparison of final bytes must use unsigned
*			chars.
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93  GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef	_MSC_VER
#pragma function(memcmp)
#endif

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*	Compares count bytes of memory starting at buf1 and buf2
*	and find if equal or which one is first in lexical order.
*
*Entry:
*	void *buf1, *buf2 - pointers to memory sections to compare
*	size_t count - length of sections to compare
*
*Exit:
*	returns < 0 if buf1 < buf2
*	returns  0  if buf1 == buf2
*	returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
	const void * buf1,
	const void * buf2,
	size_t count
	)
{
	if (!count)
		return(0);

#if defined(_M_AMD64)

    {

#if !defined(LIBCNTPR)

        __declspec(dllimport)

#endif

        size_t RtlCompareMemory( const void * src1, const void * src2, size_t length );

        size_t length;

        if ( ( length = RtlCompareMemory( buf1, buf2, count ) ) == count ) {
            return(0);
        }

        buf1 = (char *)buf1 + length;
        buf2 = (char *)buf2 + length;
    }

#else

	while ( --count && *(char *)buf1 == *(char *)buf2 ) {
		buf1 = (char *)buf1 + 1;
		buf2 = (char *)buf2 + 1;
	}

#endif

	return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memcpy.c ===
/***
*memcpy.c - contains memcpy routine
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are not treated specially, so propogation may occur.
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       04-01-91   SRW  Add #pragma function for i386 _WIN32_ and _CRUISER_
*                       builds
*       04-05-91   GJF  Speed up for large buffers by moving int-sized chunks
*                       as much as possible.
*       08-06-91   GJF  Backed out 04-05-91 change. Pointers would have to be
*                       dword-aligned for this to work on MIPS.
*       07-16-93   SRW  ALPHA Merge
*       09-01-93   GJF  Merged NT SDK and Cuda versions.
*       11-12-93   GJF  Replace _MIPS_ and _ALPHA_ with _M_MRX000 and
*                       _M_ALPHA (resp.).
*       12-03-93   GJF  Turn on #pragma function for all MS front-ends (esp.,
*                       Alpha compiler).
*       10-02-94   BWT  Add PPC support.
*       10-07-97   RDL  Added IA64.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef  _MSC_VER
#pragma function(memcpy)
#endif

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined(_M_IA64) || defined(_M_AMD64)

        {

#if !defined(LIBCNTPR)

        __declspec(dllimport)

#endif

        void RtlCopyMemory( void *, const void *, size_t count );

        RtlCopyMemory( dst, src, count );

        }

#else
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memmove.c ===
/***
*memmove.c - contains memmove routine
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memmove() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are treated specially, to avoid propogation.
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       12-28-90   SRW  Added cast of void * to char * for Mips C Compiler
*       04-09-91   GJF  Speed up a little for large buffers.
*       08-06-91   GJF  Backed out 04-09-91 change. Pointers would have to be
*                       dword-aligned for this to work on MIPS.
*       07-16-93   SRW  ALPHA Merge
*       09-01-93   GJF  Merged NT SDK and Cuda versions.
*       11-12-93   GJF  Replace _MIPS_ and _ALPHA_ with _M_MRX000 and
*                       _M_ALPHA (resp.).
*       10-02-94   BWT  Add function pragma for Alpha and PPC support
*       10-07-97   RDL  Added IA64.
*       04-30-01   BWT  Add AMD64.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*memmove - Copy source buffer to destination buffer
*
*Purpose:
*       memmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propogation.
*       For cases where propogation is not a problem, memcpy() can be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memmove (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined(_M_IA64) || defined(_M_AMD64)

        {

#if !defined(LIBCNTPR)

        __declspec(dllimport)

#endif

        void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );

        }

#else
        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                /*
                 * Non-Overlapping Buffers
                 * copy from lower addresses to higher addresses
                 */
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                /*
                 * Overlapping Buffers
                 * copy from higher addresses to lower addresses
                 */
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
#endif

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memicmp.c ===
/***
*memicmp.c - compare memory, ignore case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _memicmp() - compare two blocks of memory for lexical
*       order.  Case is ignored in the comparison.
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright. Also, fixed compiler warnings.
*       10-01-90  GJF   New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       01-17-91  GJF   ANSI naming.
*       10-11-91  GJF   Bug fix! Comparison of final bytes must use unsigned
*                       chars.
*       09-01-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       10-18-94  GJF   Sped up, especially for C locale. Also, made multi-
*                       thread safe.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       11-15-95  BWT   Fix _NTSUBSET_
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-08-98  GJF   Split out ASCII-only version.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  PML   Win64 fix: unsigned int -> size_t
*       26-01-00  GB    Modified memicmp for performance.
*       09-03-00  GB    Moved the performance code to toupper and tolower.
*                       restored the original file.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <ctype.h>
#include <setlocal.h>
#include <locale.h>

/***
*int _memicmp(first, last, count) - compare two blocks of memory, ignore case
*
*Purpose:
*       Compares count bytes of the two blocks of memory stored at first
*       and last.  The characters are converted to lowercase before
*       comparing (not permanently), so case is ignored in the search.
*
*Entry:
*       char *first, *last - memory buffers to compare
*       size_t count - maximum length to compare
*
*Exit:
*       returns < 0 if first < last
*       returns 0 if first == last
*       returns > 0 if first > last
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _memicmp (
        const void * first,
        const void * last,
        size_t count
        )
{
        int f = 0, l = 0;
        const char *dst = first, *src = last;
#if     !defined(_NTSUBSET_)
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
#endif  /* !_NTSUBSET_ */
            return __ascii_memicmp(first, last, count);
#if     !defined(_NTSUBSET_)
        }
        else {
            while (count-- && f==l)
            {
#ifdef  _MT
                f = __tolower_mt( ptloci, (unsigned char)(*(dst++)) );
                l = __tolower_mt( ptloci, (unsigned char)(*(src++)) );
#else
                f = tolower( (unsigned char)(*(dst++)) );
                l = tolower( (unsigned char)(*(src++)) );
#endif
            }
        }
#endif  /* !_NTSUBSET_ */

        return ( f - l );
}


#ifndef _M_IX86

int __cdecl __ascii_memicmp (
        const void * first,
        const void * last,
        size_t count
        )
{
        int f = 0;
        int l = 0;
        while ( count-- )
        {
            if ( (*(unsigned char *)first == *(unsigned char *)last) ||
                 ((f = __ascii_tolower( *(unsigned char *)first )) ==
                  (l = __ascii_tolower( *(unsigned char *)last ))) )
            {
                    first = (char *)first + 1;
                    last = (char *)last + 1;
            }
            else
                break;
        }
        return ( f - l );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strchr.c ===
/***
*strchr.c - search a string for a given character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strchr() - search a string for a character
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3, removed now redundant
*			#include <stddef.h>
*	10-01-90   GJF	New-style function declarator.
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strchr(string, c) - search a string for a character
*
*Purpose:
*	Searches a string for a given character, which may be the
*	null character '\0'.
*
*Entry:
*	char *string - string to search in
*	char c - character to search for
*
*Exit:
*	returns pointer to the first occurence of c in string
*	returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strchr (
	const char * string,
	int ch
	)
{
	while (*string && *string != (char)ch)
		string++;

	if (*string == (char)ch)
		return((char *)string);
	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strcat.c ===
/***
*strcat.c - contains strcat() and strcpy()
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Strcpy() copies one string onto another.
*
*	Strcat() concatenates (appends) a copy of the source string to the
*	end of the destination string, returning the destination string.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-01-90   GJF	New-style function declarator.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	04-05-91   GJF	Speed up strcat() a bit (got rid of call to strcpy()).
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93   GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*	12-30-94   JCF	Turn off #pragma function for MAC.
*	02-30-95   JCF	Add _MBSCAT check.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifndef _MBSCAT
#ifdef	_MSC_VER
#pragma function(strcat,strcpy)
#endif
#endif

/***
*char *strcat(dst, src) - concatenate (append) one string to another
*
*Purpose:
*	Concatenates src onto the end of dest.	Assumes enough
*	space in dest.
*
*Entry:
*	char *dst - string to which "src" is to be appended
*	const char *src - string to be appended to the end of "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strcat (
	char * dst,
	const char * src
	)
{
	char * cp = dst;

	while( *cp )
		cp++;			/* find end of dst */

	while( *cp++ = *src++ ) ;	/* Copy src to end of dst */

	return( dst );			/* return dst */

}


/***
*char *strcpy(dst, src) - copy one string over another
*
*Purpose:
*	Copies the string src into the spot specified by
*	dest; assumes enough room.
*
*Entry:
*	char * dst - string over which "src" is to be copied
*	const char * src - string to be copied over "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*******************************************************************************/

char * __cdecl strcpy(char * dst, const char * src)
{
	char * cp = dst;

	while( *cp++ = *src++ )
		;		/* Copy src over dst */

	return( dst );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\memset.c ===
/***
*memset.c - set a section of memory to all one byte
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the memset() routine
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       08-14-90   SBM  Compiles cleanly with -W3
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       04-01-91   SRW  Add #pragma function for i386 _WIN32_ and _CRUISER_
*                       builds
*       07-16-93   SRW  ALPHA Merge
*       09-01-93   GJF  Merged NT SDK and Cuda versions.
*       11-12-93   GJF  Replace _MIPS_ and _ALPHA_ with _M_MRX000 and
*                       _M_ALPHA (resp.).
*       11-17-93   CFW  Fix RtlFillMemory prototype typo.
*       12-03-93   GJF  Turn on #pragma function for all MS front-ends (esp.,
*                       Alpha compiler).
*       10-02-94   BWT  Add PPC support.
*       10-07-97   RDL  Added IA64.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef  _MSC_VER
#pragma function(memset)
#endif

/***
*char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
*
*Purpose:
*       Sets the first "count" bytes of the memory starting
*       at "dst" to the character value "val".
*
*Entry:
*       void *dst - pointer to memory to fill with val
*       int val   - value to put in dst bytes
*       size_t count - number of bytes of dst to fill
*
*Exit:
*       returns dst, with filled bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

#if  defined(_M_IA64) || defined(_M_AMD64)

        {

#if !defined(LIBCNTPR)

        __declspec(dllimport)

#endif

        void RtlFillMemory( void *, size_t count, char );

        RtlFillMemory( dst, count, (char)val );

        }

#else
        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }
#endif

        return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strcspn.c ===
/***
*strcspn.c - Defines the strcspn function.
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The function strcspn is mostly common code with strspn in strspn.c.
*
*Revision History:
*	??-??-??  ???	Module created.
*	09-01-94  SKS	Module commented.
*
*******************************************************************************/

#define SSTRCSPN
#include "strspn.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strcmp.c ===
/***
*strcmp.c - routine to compare two strings (for equal, less, or greater)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Compares two string, determining their lexical order.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-01-90   GJF	New-style function declarator.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	10-11-91   GJF	Bug fix! Comparison of final bytes must use unsigned
*			chars.
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93   GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef	_MSC_VER
#pragma function(strcmp)
#endif

/***
*strcmp - compare two strings, returning less than, equal to, or greater than
*
*Purpose:
*	STRCMP compares two strings and returns an integer
*	to indicate whether the first is less than the second, the two are
*	equal, or whether the first is greater than the second.
*
*	Comparison is done byte by byte on an UNSIGNED basis, which is to
*	say that Null (0) is less than any other character (1-255).
*
*Entry:
*	const char * src - string for left-hand side of comparison
*	const char * dst - string for right-hand side of comparison
*
*Exit:
*	returns -1 if src <  dst
*	returns  0 if src == dst
*	returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strcmp (
	const char * src,
	const char * dst
	)
{
	int ret = 0 ;

	while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strcoll.c ===
/***
*strcoll.c - Collate locale strings
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       03-21-89  JCR   Module created.
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-01-90  GJF   New-style function declarator.
*       10-01-91  ETC   Non-C locale support under _INTL switch.
*       12-09-91  ETC   Updated api; added multithread.
*       08-19-92  KRS   Activate NLS support.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-16-92  KRS   Optimize for CompareStringW by using -1 for string len.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-10-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl strcoll (
        const char *_string1,
        const char *_string2
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
                return strcmp(_string1, _string2);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return strcmp(_string1,_string2);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strdup.c ===
/***
*strdup.c - duplicate a string in malloc'd memory
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _strdup() - grab new memory, and duplicate the string into it.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Removed now redundant #include <stddef.h>
*	10-02-90   GJF	New-style function declarator.
*	01-18-91   GJF	ANSI naming.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <string.h>

/***
*char *_strdup(string) - duplicate string into malloc'd memory
*
*Purpose:
*	Allocates enough storage via malloc() for a copy of the
*	string, copies the string into the new memory, and returns
*	a pointer to it.
*
*Entry:
*	char *string - string to copy into new memory
*
*Exit:
*	returns a pointer to the newly allocated storage with the
*	string in it.
*
*	returns NULL if enough memory could not be allocated, or
*	string was NULL.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strdup (
	const char * string
	)
{
	char *memory;

	if (!string)
		return(NULL);

	if (memory = malloc(strlen(string) + 1))
		return(strcpy(memory,string));

	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\stricmp.c ===
/***
*stricmp.c - contains case-insensitive string comp routine _stricmp/_strcmpi
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _stricmp(), also known as _strcmpi()
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       07-25-90  SBM   Added #include <ctype.h>
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       10-11-91  GJF   Bug fix! Comparison of final bytes must use unsigned
*                       chars.
*       11-08-91  GJF   Fixed compiler warning.
*       09-02-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       09-21-93  CFW   Avoid cast bug.
*       10-18-94  GJF   Sped up C locale. Also, made multi-thread safe.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       11-15-95  BWT   Fix _NTSUBSET_
*       08-10-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       08-26-98  GJF   Split out ASCII-only version.
*       09-17-98  GJF   Silly errors in __ascii_stricmp (found by DEC folks)
*       05-17-99  PML   Remove all Macintosh support.
*       01-26-00  GB    Modified stricmp for performance.
*       03-09-00  GB    Moved the performance code to toupper and tolower.
*                       restored the original file.
*       08-22-00  GB    Self included this file so as that stricmp and strcmpi
*                       have same code.
*
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <setlocal.h>
#include <ctype.h>
#include <locale.h>



/***
*int _strcmpi(dst, src), _strcmpi(dst, src) - compare strings, ignore case
*
*Purpose:
*       _stricmp/_strcmpi perform a case-insensitive string comparision.
*       For differences, upper case letters are mapped to lower case.
*       Thus, "abc_" < "ABCD" since "_" < "d".
*
*Entry:
*       char *dst, *src - strings to compare
*
*Return:
*       <0 if dst < src
*        0 if dst = src
*       >0 if dst > src
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _stricmp (
        const char * dst,
        const char * src
        )
{

#if     !defined(_NTSUBSET_)
        int f,l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* !_NTSUBSET_ */
            return __ascii_stricmp(dst, src);
#if     !defined(_NTSUBSET_)
        }
        else {
            do {   
#ifdef  _MT
                f = __tolower_mt( ptloci, (unsigned char)(*(dst++)) );
                l = __tolower_mt( ptloci, (unsigned char)(*(src++)) );
#else
                f = tolower( (unsigned char)(*(dst++)) );
                l = tolower( (unsigned char)(*(src++)) );
#endif
            } while ( f && (f == l) );
        }

        return(f - l);
#endif  /* !_NTSUBSET_ */
}

#ifndef _M_IX86

int __cdecl __ascii_stricmp (
        const char * dst,
        const char * src
        )
{
        int f, l;

        do {
            if ( ((f = (unsigned char)(*(dst++))) >= 'A') &&
                 (f <= 'Z') )
                f -= 'A' - 'a';
            if ( ((l = (unsigned char)(*(src++))) >= 'A') &&
                 (l <= 'Z') )
                l -= 'A' - 'a';
        } while ( f && (f == l) );

        return(f - l);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\stricoll.c ===
/***
*stricoll.c - Collate locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       10-16-91  ETC   Created from strcoll.c
*       12-08-91  ETC   Remove availability under !_INTL; updated api; add mt.
*       04-06-92  KRS   Make work without _INTL switches too.
*       08-19-92  KRS   Activate NLS support.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-16-92  KRS   Optimize for CompareStringW  by using -1 for string len.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       11-25-95  BWT   stricmp simply calls strcmpi... Use strcmpi instead.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int _stricoll() - Collate locale strings without regard to case
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information
*       without regard to case.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _stricoll (
        const char *_string1,
        const char *_string2
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return _stricmp(_string1, _string2);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return _strcmpi(_string1, _string2);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strlen.c ===
/***
*strlen.c - contains strlen() routine
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	strlen returns the length of a null-terminated string,
*	not including the null byte itself.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	04-05-91   GJF	Speed up just a little bit.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93   GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef	_MSC_VER
#pragma function(strlen)
#endif

/***
*strlen - return the length of a null-terminated string
*
*Purpose:
*	Finds the length in bytes of the given string, not including
*	the final null character.
*
*Entry:
*	const char * str - string whose length is to be computed
*
*Exit:
*	length of the string "str", exclusive of the final null byte
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strlen (
	const char * str
	)
{
	const char *eos = str;

	while( *eos++ ) ;

	return( (int)(eos - str - 1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strlwr.c ===
/***
*strlwr.c - routine to map upper-case characters in a string to lower-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the upper case characters in a string to lower case,
*       in place.
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       09-18-91  ETC   Locale support under _INTL switch.
*       12-08-91  ETC   Updated nlsapi; added multithread.
*       08-19-92  KRS   Activated NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building
*                       ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Add code page for __crtxxx().
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt.
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added support for recovery from stack overflow around
*                       _alloca().
*       05-01-00  BWT   Fix Posix.
*       03-13-01  PML   Fix memory leak if _alloca failed (vs7#224860)
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <limits.h>     /* for INT_MAX */
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

/***
*char *_strlwr(string) - map upper-case characters in a string to lower-case
*
*Purpose:
*       _strlwr() converts upper-case characters in a null-terminated string
*       to their lower-case equivalents.  Conversion is done in place and
*       characters other than upper-case letters are not modified.
*
*       In the C locale, this function modifies only 7-bit ASCII characters
*       in the range 0x41 through 0x5A ('A' through 'Z').
*
*       If the locale is not the 'C' locale, LCMapString() is used to do
*       the work.  Assumes enough space in the string to hold result.
*
*Entry:
*       char *string - string to change to lower case
*
*Exit:
*       input string address
*
*Exceptions:
*       The original string is returned unchanged on any error.
*
*******************************************************************************/

char * __cdecl _strlwr (
        char * string
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        int dstlen;                 /* len of dst string, with null  */
        unsigned char *dst;         /* destination string */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            char *cp;       /* traverses string for C locale conversion */

            for ( cp = string ; *cp ; ++cp )
                if ( ('A' <= *cp) && (*cp <= 'Z') )
                    *cp -= 'A' - 'a';

            return(string);
        }   /* C locale */

        /* Inquire size of dst string */
#ifdef  _MT
        if ( 0 == (dstlen = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
        if ( 0 == (dstlen = __crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                               LCMAP_LOWERCASE,
                                               string,
                                               -1,
                                               NULL,
                                               0,
#ifdef  _MT
                                               ptloci->lc_codepage,
#else
                                               __lc_codepage,
#endif
                                               TRUE )) )
            return(string);

        /* Allocate space for dst */
        __try {
            dst = (unsigned char *)_alloca(dstlen * sizeof(unsigned char));
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            _resetstkoflw();
            dst = NULL;
        }

        if ( dst == NULL ) {
            dst = (unsigned char *)_malloc_crt(dstlen * sizeof(unsigned char));
            malloc_flag++;
        }

        /* Map src string to dst string in alternate case */
        if ( (dst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                 LCMAP_LOWERCASE,
                                 string,
                                 -1,
                                 dst,
                                 dstlen,
#ifdef  _MT
                                 ptloci->lc_codepage,
#else
                                 __lc_codepage,
#endif
                                 TRUE ) != 0) )
            /* copy dst string to return string */
            strcpy(string, dst);

        if ( malloc_flag )
            _free_crt(dst);

        return(string);

#else

        char * cp;

        for (cp=string; *cp; ++cp)
        {
            if ('A' <= *cp && *cp <= 'Z')
                *cp += 'a' - 'A';
        }

        return(string);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strncat.c ===
/***
*strncat.c - append n chars of string to new string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strncat() - appends n characters of string onto
*	end of other string
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strncat(front, back, count) - append count chars of back onto front
*
*Purpose:
*	Appends at most count characters of the string back onto the
*	end of front, and ALWAYS terminates with a null character.
*	If count is greater than the length of back, the length of back
*	is used instead.  (Unlike strncpy, this routine does not pad out
*	to count characters).
*
*Entry:
*	char *front - string to append onto
*	char *back - string to append
*	unsigned count - count of max characters to append
*
*Exit:
*	returns a pointer to string appended onto (front).
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strncat (
	char * front,
	const char * back,
	size_t count
	)
{
	char *start = front;

	while (*front++)
		;
	front--;

	while (count--)
		if (!(*front++ = *back++))
			return(start);

	*front = '\0';
	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strncoll.c ===
/***
*strncoll.c - Collate locale strings
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Revision History:
*       05-09-94  CFW   Created from strnicol.c.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int _strncoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _strncoll (
        const char *_string1,
        const char *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if ( !count )
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return strncmp(_string1, _string2, count);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              (int)count,
                                              _string2,
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return strncmp(_string1, _string2, count);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strncmp.c ===
/***
*strncmp.c - compare first n characters of two strings
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strncmp() - compare first n characters of two strings
*	for lexical order.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	10-11-91   GJF	Bug fix! Comparison of final bytes must use unsigned
*			chars.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*int strncmp(first, last, count) - compare first count chars of strings
*
*Purpose:
*	Compares two strings for lexical order.  The comparison stops
*	after: (1) a difference between the strings is found, (2) the end
*	of the strings is reached, or (3) count characters have been
*	compared.
*
*Entry:
*	char *first, *last - strings to compare
*	unsigned count - maximum number of characters to compare
*
*Exit:
*	returns <0 if first < last
*	returns  0 if first == last
*	returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strncmp (
	const char * first,
	const char * last,
	size_t count
	)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return( *(unsigned char *)first - *(unsigned char *)last );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strncpy.c ===
/***
*strncpy.c - copy at most n characters of string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strncpy() - copy at most n characters of string
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strncpy(dest, source, count) - copy at most n characters
*
*Purpose:
*	Copies count characters from the source string to the
*	destination.  If count is less than the length of source,
*	NO NULL CHARACTER is put onto the end of the copied string.
*	If count is greater than the length of sources, dest is padded
*	with null characters to length count.
*
*
*Entry:
*	char *dest - pointer to destination
*	char *source - source string for copy
*	unsigned count - max number of characters to copy
*
*Exit:
*	returns dest
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strncpy (
	char * dest,
	const char * source,
	size_t count
	)
{
	char *start = dest;

	while (count && (*dest++ = *source++))	  /* copy string */
		count--;

	if (count)				/* pad out with zeroes */
		while (--count)
			*dest++ = '\0';

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strrchr.c ===
/***
*strrchr.c - find last occurrence of character in string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strrchr() - find the last occurrence of a given character
*	in a string.
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3, removed now redundant
*			#include <stddef.h>
*	10-02-90   GJF	New-style function declarator.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strrchr(string, ch) - find last occurrence of ch in string
*
*Purpose:
*	Finds the last occurrence of ch in string.  The terminating
*	null character is used as part of the search.
*
*Entry:
*	char *string - string to search in
*	char ch - character to search for
*
*Exit:
*	returns a pointer to the last occurrence of ch in the given
*	string
*	returns NULL if ch does not occurr in the string
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strrchr (
	const char * string,
	int ch
	)
{
	char *start = (char *)string;

	while (*string++)			/* find end of string */
		;
						/* search towards front */
	while (--string != start && *string != (char)ch)
		;

	if (*string == (char)ch)		/* char found ? */
		return( (char *)string );

	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strnset.c ===
/***
*strnset.c - set first n characters to single character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _strnset() - sets at most the first n characters of a string
*	to a given character.
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3
*	10-02-90   GJF	New-style function declarator.
*	01-18-91   GJF	ANSI naming.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_strnset(string, val, count) - set at most count characters to val
*
*Purpose:
*	Sets the first count characters of string the character value.
*	If the length of string is less than count, the length of
*	string is used in place of n.
*
*Entry:
*	char *string - string to set characters in
*	char val - character to fill with
*	unsigned count - count of characters to fill
*
*Exit:
*	returns string, now filled with count copies of val.
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strnset (
	char * string,
	int val,
	size_t count
	)
{
	char *start = string;

	while (count-- && *string)
		*string++ = (char)val;

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strpbrk.c ===
/***
*strpbrk.c - Defines the strpbrk function.
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The function strpbrk is mostly common code with strspn in strspn.c.
*
*Revision History:
*	??-??-??  ???	Module created.
*	09-01-94  SKS	Module commented.
*
*******************************************************************************/

#define SSTRPBRK
#include "strspn.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strrev.c ===
/***
*strrev.c - reverse a string in place
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _strrev() - reverse a string in place (not including
*	'\0' character)
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	01-18-91   GJF	ANSI naming.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_strrev(string) - reverse a string in place
*
*Purpose:
*	Reverses the order of characters in the string.  The terminating
*	null character remains in place.
*
*Entry:
*	char *string - string to reverse
*
*Exit:
*	returns string - now with reversed characters
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strrev (
	char * string
	)
{
	char *start = string;
	char *left = string;
	char ch;

	while (*string++)		  /* find end of string */
		;
	string -= 2;

	while (left < string)
	{
		ch = *left;
		*left++ = *string;
		*string-- = ch;
	}

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strset.c ===
/***
*strset.c - sets all characters of string to given character
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _strset() - sets all of the characters in a string (except
*       the '\0') equal to a given character.
*
*Revision History:
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       09-03-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       12-03-93  GJF   _strset is an intrinsic in Alpha compiler!
*       03-01-94  GJF   Evidently on MIPS too (change taken from crt32, made
*                       there by Jeff Havens).
*       10-02-94  BWT   Add PPC support.
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#if     defined(_M_IA64) || defined(_M_AMD64)
#pragma function(_strset)
#endif

/***
*char *_strset(string, val) - sets all of string to val
*
*Purpose:
*       Sets all of characters in string (except the terminating '/0'
*       character) equal to val.
*
*
*Entry:
*       char *string - string to modify
*       char val - value to fill string with
*
*Exit:
*       returns string -- now filled with val's
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strset (
        char * string,
        int val
        )
{
        char *start = string;

        while (*string)
                *string++ = (char)val;

        return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strnicmp.c ===
/***
*strnicmp.c - compare n chars of strings, ignoring case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _strnicmp() - Compares at most n characters of two strings,
*       without regard to case.
*
*Revision History:
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       10-11-91  GJF   Bug fix! Comparison of final bytes must use unsigned
*                       chars.
*       09-03-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       09-21-93  CFW   Avoid cast bug.
*       01-13-94  CFW   Fix Comments.
*       10-19-94  GJF   Sped up C locale. Also, made multi-thread safe.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       11-15-95  BWT   Fix _NTSUBSET_
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-08-98  GJF   Split out ASCII-only version.
*       05-17-99  PML   Remove all Macintosh support.
*       26-01-00  GB    Modified strnicmp for performance.
*       09-03-00  GB    Moved the performance code to toupper and tolower.
*                       restored the original file.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <ctype.h>
#include <setlocal.h>
#include <locale.h>

/***
*int _strnicmp(first, last, count) - compares count char of strings, ignore case
*
*Purpose:
*       Compare the two strings for lexical order.  Stops the comparison
*       when the following occurs: (1) strings differ, (2) the end of the
*       strings is reached, or (3) count characters have been compared.
*       For the purposes of the comparison, upper case characters are
*       converted to lower case.
*
*Entry:
*       char *first, *last - strings to compare
*       size_t count - maximum number of characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns 0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _strnicmp (
        const char * dst,
        const char * src,
        size_t count
        )
{
        int f,l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        if ( count )
        {
#if     !defined(_NTSUBSET_)
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* !_NTSUBSET_ */
                return __ascii_strnicmp(dst, src, count);
#if     !defined(_NTSUBSET_)
            }
            else {
                do {
#ifdef  _MT
                    f = __tolower_mt( ptloci, (unsigned char)(*(dst++)) );
                    l = __tolower_mt( ptloci, (unsigned char)(*(src++)) );
#else
                    f = tolower( (unsigned char)(*(dst++)) );
                    l = tolower( (unsigned char)(*(src++)) );
#endif
                } while (--count && f && (f == l) );
            }
#endif  /* !_NTSUBSET_ */

            return( f - l );
        }

        return( 0 );
}


#ifndef _M_IX86

int __cdecl __ascii_strnicmp (
        const char * first,
        const char * last,
        size_t count
        )
{
        int f, l;

        do {

            if ( ((f = (unsigned char)(*(first++))) >= 'A') &&
                 (f <= 'Z') )
                f -= 'A' - 'a';

            if ( ((l = (unsigned char)(*(last++))) >= 'A') &&
                 (l <= 'Z') )
                l -= 'A' - 'a';

        } while ( --count && f && (f == l) );

        return ( f - l );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strnicol.c ===
/***
*strnicoll.c - Collate locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Revision History:
*       01-13-94  CFW   Created from stricoll.c.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       05-09-94  CFW   Fix !_INTL case.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int _strnicoll() - Collate locale strings without regard to case
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information
*       without regard to case.
*       Compares at most n characters of two strings.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _strnicoll (
        const char *_string1,
        const char *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if (!count)
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return _strnicmp(_string1, _string2, count);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              (int)count,
                                              _string2, 
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return _strnicmp(_string1, _string2, count);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strstr.c ===
/***
*strstr.c - search for one string inside another
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strstr() - search for one string inside another
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Removed now redundant #include <stddef.h>
*	10-02-90   GJF	New-style function declarator.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	03-14-94   GJF	If string2 is empty, return string1.
*	12-30-94   CFW	Avoid 'const' warning.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strstr(string1, string2) - search for string2 in string1
*
*Purpose:
*	finds the first occurrence of string2 in string1
*
*Entry:
*	char *string1 - string to search in
*	char *string2 - string to search for
*
*Exit:
*	returns a pointer to the first occurrence of string2 in
*	string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strstr (
	const char * str1,
	const char * str2
	)
{
	char *cp = (char *) str1;
	char *s1, *s2;

	if ( !*str2 )
	    return((char *)str1);

	while (*cp)
	{
		s1 = cp;
		s2 = (char *) str2;

		while ( *s1 && *s2 && !(*s1-*s2) )
			s1++, s2++;

		if (!*s2)
			return(cp);

		cp++;
	}

	return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strtok.c ===
/***
*strtok.c - tokenize a string with given delimiters
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strtok() - breaks string into series of token
*	via repeated calls.
*
*Revision History:
*	06-01-89  JCR	C version created.
*	02-27-90  GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90  SBM	Removed now redundant #include <stddef.h>
*	10-02-90  GJF	New-style function declarator.
*	07-17-91  GJF	Multi-thread support for Win32 [_WIN32_].
*	10-26-91  GJF	Fixed nasty bug - search for end-of-token could run
*			off the end of the string.
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	05-25-93  GJF	Revised to use unsigned char * pointers to access
*			the token and delimiter strings.
*	09-03-93  GJF	Replaced MTHREAD with _MT.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#ifdef	_MT
#include <mtdll.h>
#endif

/***
*char *strtok(string, control) - tokenize string with delimiter in control
*
*Purpose:
*	strtok considers the string to consist of a sequence of zero or more
*	text tokens separated by spans of one or more control chars. the first
*	call, with string specified, returns a pointer to the first char of the
*	first token, and will write a null char into string immediately
*	following the returned token. subsequent calls with zero for the first
*	argument (string) will work thru the string until no tokens remain. the
*	control string may be different from call to call. when no tokens remain
*	in string a NULL pointer is returned. remember the control chars with a
*	bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*	char *string - string to tokenize, or NULL to get next token
*	char *control - string of characters to use as delimiters
*
*Exit:
*	returns pointer to first token in string, or if string
*	was NULL, to next token
*	returns NULL when no more tokens remain.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strtok (
	char * string,
	const char * control
	)
{
	unsigned char *str;
	const unsigned char *ctrl = control;

	unsigned char map[32];
	int count;

#ifdef	_MT
	_ptiddata ptd = _getptd();
#else
	static char *nextoken;
#endif

	/* Clear control map */
	for (count = 0; count < 32; count++)
		map[count] = 0;

	/* Set bits in delimiter table */
	do {
		map[*ctrl >> 3] |= (1 << (*ctrl & 7));
	} while (*ctrl++);

	/* Initialize str. If string is NULL, set str to the saved
	 * pointer (i.e., continue breaking tokens out of the string
	 * from the last strtok call) */
	if (string)
		str = string;
	else
#ifdef	_MT
		str = ptd->_token;
#else
		str = nextoken;
#endif

	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets str to point to the terminal
	 * null (*str == '\0') */
	while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
		str++;

	string = str;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *str ; str++ )
		if ( map[*str >> 3] & (1 << (*str & 7)) ) {
			*str++ = '\0';
			break;
		}

	/* Update nextoken (or the corresponding field in the per-thread data
	 * structure */
#ifdef	_MT
	ptd->_token = str;
#else
	nextoken = str;
#endif

	/* Determine if a token has been found. */
	if ( string == str )
		return NULL;
	else
		return string;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcscat.c ===
/***
*wcscat.c - contains wcscat() and wcscpy()
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcscat() appends one wchar_t string onto another.
*	wcscpy() copies one wchar_t string into another.
*
*	wcscat() concatenates (appends) a copy of the source string to the
*	end of the destination string, returning the destination string.
*	Strings are wide-character strings.
*
*	wcscpy() copies the source string to the spot pointed to be
*	the destination string, returning the destination string.
*	Strings are wide-character strings.
*
*Revision History:
*	09-09-91  ETC	Created from strcat.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcscat(dst, src) - concatenate (append) one wchar_t string to another
*
*Purpose:
*	Concatenates src onto the end of dest.	Assumes enough
*	space in dest.
*
*Entry:
*	wchar_t *dst - wchar_t string to which "src" is to be appended
*	const wchar_t *src - wchar_t string to be appended to the end of "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcscat (
	wchar_t * dst,
	const wchar_t * src
	)
{
	wchar_t * cp = dst;

	while( *cp )
		cp++;			/* find end of dst */

	while( *cp++ = *src++ ) ;	/* Copy src to end of dst */

	return( dst );			/* return dst */

}


/***
*wchar_t *wcscpy(dst, src) - copy one wchar_t string over another
*
*Purpose:
*	Copies the wchar_t string src into the spot specified by
*	dest; assumes enough room.
*
*Entry:
*	wchar_t * dst - wchar_t string over which "src" is to be copied
*	const wchar_t * src - wchar_t string to be copied over "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*******************************************************************************/

wchar_t * __cdecl wcscpy(wchar_t * dst, const wchar_t * src)
{
	wchar_t * cp = dst;

	while( *cp++ = *src++ )
		;		/* Copy src over dst */

	return( dst );
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strspn.c ===
/***
*strspn.c - find length of initial substring of chars from a control string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strspn() - finds the length of the initial substring of
*	a string consisting entirely of characters from a control string.
*
*	defines strcspn()- finds the length of the initial substring of
*	a string consisting entirely of characters not in a control string.
*
*	defines strpbrk()- finds the index of the first character in a string
*	that is not in a control string
*
*Revision History:
*	06-01-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Removed now redundant #include <stddef.h>
*	10-02-90   GJF	New-style function declarators.
*	12-04-90   SRW	Made it default to compiling for strspn
*	05-21-93   GJF	Used unsigned char pointers to access control and
*			source strings.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

/* Determine which routine we're compiling for (default to STRSPN) */

#define _STRSPN 	1
#define _STRCSPN	2
#define _STRPBRK	3

#if defined(SSTRCSPN)
#define ROUTINE _STRCSPN
#elif defined(SSTRPBRK)
#define ROUTINE _STRPBRK
#else
#define ROUTINE _STRSPN
#endif

#include <cruntime.h>
#include <string.h>

/***
*int strspn(string, control) - find init substring of control chars
*
*Purpose:
*	Finds the index of the first character in string that does belong
*	to the set of characters specified by control.	This is
*	equivalent to the length of the initial substring of string that
*	consists entirely of characters from control.  The '\0' character
*	that terminates control is not considered in the matching process.
*
*Entry:
*	char *string - string to search
*	char *control - string containing characters not to search for
*
*Exit:
*	returns index of first char in string not in control
*
*Exceptions:
*
*******************************************************************************/

/***
*int strcspn(string, control) - search for init substring w/o control chars
*
*Purpose:
*	returns the index of the first character in string that belongs
*	to the set of characters specified by control.	This is equivalent
*	to the length of the length of the initial substring of string
*	composed entirely of characters not in control.  Null chars not
*	considered.
*
*Entry:
*	char *string - string to search
*	char *control - set of characters not allowed in init substring
*
*Exit:
*	returns the index of the first char in string
*	that is in the set of characters specified by control.
*
*Exceptions:
*
*******************************************************************************/

/***
*char *strpbrk(string, control) - scans string for a character from control
*
*Purpose:
*	Finds the first occurence in string of any character from
*	the control string.
*
*Entry:
*	char *string - string to search in
*	char *control - string containing characters to search for
*
*Exit:
*	returns a pointer to the first character from control found
*	in string.
*	returns NULL if string and control have no characters in common.
*
*Exceptions:
*
*******************************************************************************/



/* Routine prototype */
#if ROUTINE == _STRSPN /*IFSTRIP=IGN*/
size_t __cdecl strspn (
#elif ROUTINE == _STRCSPN /*IFSTRIP=IGN*/
size_t __cdecl strcspn (
#else /* ROUTINE == STRPBRK */
char * __cdecl strpbrk (
#endif
	const char * string,
	const char * control
	)
{
	const unsigned char *str = string;
	const unsigned char *ctrl = control;

	unsigned char map[32];
	int count;

	/* Clear out bit map */
	for (count=0; count<32; count++)
		map[count] = 0;

	/* Set bits in control map */
	while (*ctrl)
	{
		map[*ctrl >> 3] |= (1 << (*ctrl & 7));
		ctrl++;
	}

#if ROUTINE == _STRSPN /*IFSTRIP=IGN*/

	/* 1st char NOT in control map stops search */
	if (*str)
	{
		count=0;
		while (map[*str >> 3] & (1 << (*str & 7)))
		{
			count++;
			str++;
		}
		return(count);
	}
	return(0);

#elif ROUTINE == _STRCSPN /*IFSTRIP=IGN*/

	/* 1st char in control map stops search */
	count=0;
	map[0] |= 1;	/* null chars not considered */
	while (!(map[*str >> 3] & (1 << (*str & 7))))
	{
		count++;
		str++;
	}
	return(count);

#else /* (ROUTINE == _STRPBRK) */

	/* 1st char in control map stops search */
	while (*str)
	{
		if (map[*str >> 3] & (1 << (*str & 7)))
			return((char *)str);
		str++;
	}
	return(NULL);

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strxfrm.c ===
/***
*strxfrm.c - Transform a string using locale information
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       03-21-89  JCR   Module created.
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       10-02-91  ETC   Non-C locale support under _INTL switch.
*       12-09-91  ETC   Updated api; added multithread.
*       12-18-91  ETC   Don't convert output of LCMapString.
*       08-18-92  KRS   Activate NLS API.  Fix behavior.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-11-92  SKS   Need to handle count=0 in non-INTL code
*       12-15-92  KRS   Handle return value according to ANSI.
*       01-18-93  CFW   Removed unreferenced variable "dummy".
*       03-10-93  CFW   Remove UNDONE comment.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       07-16-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>

/***
*size_t strxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the string pointer to by _string2 and place the
*       resulting string into the array pointer to by _string1.
*       No more than _count characters are place into the
*       resulting string (including the null).
*
*       The transformation is such that if strcmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of strcoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*       [ANSI]
*
*       The value of the following expression is the size of the array
*       needed to hold the transformation of the source string:
*
*           1 + strxfrm(NULL,string,0)
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*       Thus, strxfrm() simply resolves to strncpy()/strlen().
*
*Entry:
*       char *_string1       = result string
*       const char *_string2 = source string
*       size_t _count        = max chars to move
*
*       [If _count is 0, _string1 is permitted to be NULL.]
*
*Exit:
*       Length of the transformed string (not including the terminating
*       null).  If the value returned is >= _count, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl strxfrm (
        char *_string1,
        const char *_string2,
        size_t _count
        )
{
#ifdef  _NTSUBSET_
        if (_string1)
            strncpy(_string1, _string2, _count);
        return strlen(_string2);
#else
        int dstlen;
        int retval = INT_MAX;   /* NON-ANSI: default if OM or API error */
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if ( _count > INT_MAX )
            return (size_t)retval;

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( (ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE) &&
             (ptloci->lc_collate_cp == _CLOCALECP) )
#else

        if ( (__lc_handle[LC_COLLATE] == _CLOCALEHANDLE) &&
             (__lc_collate_cp == _CLOCALECP) )
#endif
        {
            strncpy(_string1, _string2, _count);
            return strlen(_string2);
        }

        /* Inquire size of dst string in BYTES */
#ifdef  _MT
        if ( 0 == (dstlen = __crtLCMapStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (dstlen = __crtLCMapStringA( __lc_handle[LC_COLLATE],
#endif
                                               LCMAP_SORTKEY,
                                               _string2,
                                               -1,
                                               NULL,
                                               0,
#ifdef  _MT
                                               ptloci->lc_collate_cp,
#else
                                               __lc_collate_cp,
#endif
                                               TRUE )) )
            goto error_cleanup;

        retval = dstlen;

        /* if not enough room, return amount needed */
        if ( dstlen > (int)_count )
            goto error_cleanup;

        /* Map src string to dst string */
#ifdef  _MT
        if ( 0 == __crtLCMapStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == __crtLCMapStringA( __lc_handle[LC_COLLATE],
#endif
                                     LCMAP_SORTKEY,
                                     _string2,
                                     -1,
                                     _string1,
                                     (int)_count,
#ifdef  _MT
                                     ptloci->lc_collate_cp,
#else
                                     __lc_collate_cp,
#endif
                                     TRUE ) )
            retval = INT_MAX;

error_cleanup:
        return (size_t)retval;
#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcscmp.c ===
/***
*wcscmp.c - routine to compare two wchar_t strings (for equal, less, or greater)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Compares two wide-character strings, determining their lexical order.
*
*Revision History:
*	09-09-91  ETC	Created from strcmp.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wcscmp - compare two wchar_t strings,
*	 returning less than, equal to, or greater than
*
*Purpose:
*	wcscmp compares two wide-character strings and returns an integer
*	to indicate whether the first is less than the second, the two are
*	equal, or whether the first is greater than the second.
*
*	Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*	say that Null wchar_t(0) is less than any other character.
*
*Entry:
*	const wchar_t * src - string for left-hand side of comparison
*	const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*	returns -1 if src <  dst
*	returns  0 if src == dst
*	returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcscmp (
	const wchar_t * src,
	const wchar_t * dst
	)
{
	int ret = 0 ;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcschr.c ===
/***
*wcschr.c - search a wchar_t string for a given wchar_t character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcschr() - search a wchar_t string for a wchar_t character
*
*Revision History:
*	09-09-91  ETC	Created from strchr.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcschr(string, c) - search a string for a wchar_t character
*
*Purpose:
*	Searches a wchar_t string for a given wchar_t character,
*	which may be the null character L'\0'.
*
*Entry:
*	wchar_t *string - wchar_t string to search in
*	wchar_t c - wchar_t character to search for
*
*Exit:
*	returns pointer to the first occurence of c in string
*	returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcschr (
	const wchar_t * string,
	wchar_t ch
	)
{
	while (*string && *string != (wchar_t)ch)
		string++;

	if (*string == (wchar_t)ch)
		return((wchar_t *)string);
	return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\strupr.c ===
/***
*strupr.c - routine to map lower-case characters in a string to upper-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the lower case characters in a string to upper case,
*       in place.
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       09-18-91  ETC   Locale support under _INTL switch.
*       12-08-91  ETC   Updated nlsapi; added multithread.
*       08-19-92  KRS   Activated NLS Support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building
*                       ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       03-10-93  CFW   Remove UNDONE comment.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       10-07-93  CFW   Fix macro name.
*       11-09-93  CFW   Add code page for __crtxxx().
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-12-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt.
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added support for recovery from stack overflow around
*                       _alloca().
*       05-01-00  BWT   Fix Posix.
*       03-13-01  PML   Pass per-thread cp to __crtLCMapStringA (vs7#224974).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <limits.h>     /* for INT_MAX */
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

/***
*char *_strupr(string) - map lower-case characters in a string to upper-case
*
*Purpose:
*       _strupr() converts lower-case characters in a null-terminated string
*       to their upper-case equivalents.  Conversion is done in place and
*       characters other than lower-case letters are not modified.
*
*       In the C locale, this function modifies only 7-bit ASCII characters
*       in the range 0x61 through 0x7A ('a' through 'z').
*
*       If the locale is not the 'C' locale, LCMapString() is used to do
*       the work.  Assumes enough space in the string to hold result.
*
*Entry:
*       char *string - string to change to upper case
*
*Exit:
*       input string address
*
*Exceptions:
*       The original string is returned unchanged on any error.
*
*******************************************************************************/

char * __cdecl _strupr (
        char * string
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        int dstlen;                 /* len of dst string, with null  */
        unsigned char *dst;         /* destination string */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            char *cp;       /* traverses string for C locale conversion */

            for ( cp = string ; *cp ; ++cp )
                if ( ('a' <= *cp) && (*cp <= 'z') )
                    *cp -= 'a' - 'A';

            return(string);
        }   /* C locale */

        /* Inquire size of dst string */
#ifdef  _MT
        if ( 0 == (dstlen = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
        if ( 0 == (dstlen = __crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                               LCMAP_UPPERCASE,
                                               string,
                                               -1,
                                               NULL,
                                               0,
#ifdef  _MT
                                               ptloci->lc_codepage,
#else
                                               __lc_codepage,
#endif
                                               TRUE )) )
            return(string);

        /* Allocate space for dst */
        __try {
            dst = (unsigned char *)_alloca(dstlen * sizeof(unsigned char));
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            _resetstkoflw();
            dst = NULL;
        }

        if ( dst == NULL ) {
            dst = (unsigned char *)_malloc_crt(dstlen * sizeof(unsigned char));
            malloc_flag++;
        }

        /* Map src string to dst string in alternate case */
        if ( (dst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                 LCMAP_UPPERCASE,
                                 string,
                                 -1,
                                 dst,
                                 dstlen,
#ifdef  _MT
                                 ptloci->lc_codepage,
#else
                                 __lc_codepage,
#endif
                                 TRUE ) != 0) )
            /* copy dst string to return string */
            strcpy(string, dst);

        if ( malloc_flag )
            _free_crt(dst);

        return(string);

#else

        char * cp;

        for (cp=string; *cp; ++cp)
        {
            if ('a' <= *cp && *cp <= 'z')
                *cp += 'A' - 'a';
        }

        return(string);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcscoll.c ===
/***
*wcscoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*
*Revision History:
*       09-09-91  ETC   Created from strcoll.c.
*       04-06-92  KRS   Make work without _INTL also.
*       08-19-92  KRS   Activate NLS support.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       02-07-94  CFW   POSIXify.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-12-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int wcscoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       In the C locale, wcscmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl wcscoll (
        const wchar_t *_string1,
        const wchar_t *_string2
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else 
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
                return (wcscmp(_string1, _string2));

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_collate_cp)) )
#else
                                              __lc_collate_cp)) )
#endif
        {
                errno = EINVAL;
                return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return wcscmp(_string1, _string2);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcscspn.c ===
/***
*wcscspn.c - find length of initial substring of wide characters
*        not in a control string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wcscspn()- finds the length of the initial substring of
*       a string consisting entirely of characters not in a control string
*       (wide-character strings).
*
*Revision History:
*       11-04-91  ETC   Created with source from crtdll.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       02-27-98  RKP   Added 64 bit support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*size_t wcscspn(string, control) - search for init substring w/o control wchars
*
*Purpose:
*       returns the index of the first character in string that belongs
*       to the set of characters specified by control.  This is equivalent
*       to the length of the length of the initial substring of string
*       composed entirely of characters not in control.  Null chars not
*       considered (wide-character strings).
*
*Entry:
*       wchar_t *string - string to search
*       wchar_t *control - set of characters not allowed in init substring
*
*Exit:
*       returns the index of the first wchar_t in string
*       that is in the set of characters specified by control.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcscspn (
        const wchar_t * string,
        const wchar_t * control
        )
{
        wchar_t *str = (wchar_t *) string;
        wchar_t *wcset;

        /* 1st char in control string stops search */
        while (*str) {
            for (wcset = (wchar_t *)control; *wcset; wcset++) {
                if (*wcset == *str) {
                    return (size_t)(str - string);
                }
            }
            str++;
        }
        return (size_t)(str - string);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsicmp.c ===
/***
*wcsicmp.c - contains case-insensitive wide string comp routine _wcsicmp
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _wcsicmp()
*
*Revision History:
*       09-09-91  ETC   Created from stricmp.c.
*       12-09-91  ETC   Use C for neutral locale.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       08-19-92  KRS   Actived use of CompareStringW.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-15-92  KRS   Added robustness to non-_INTL code.  Optimize.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Remove locale-sensitive portion.
*       02-07-94  CFW   POSIXify.
*       10-25-94  GJF   Now works in non-C locales.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <setlocal.h>
#include <string.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <mtdll.h>

/***
*int _wcsicmp(dst, src) - compare wide-character strings, ignore case
*
*Purpose:
*       _wcsicmp perform a case-insensitive wchar_t string comparision.
*       _wcsicmp is independent of locale.
*
*Entry:
*       wchar_t *dst, *src - strings to compare
*
*Return:
*       <0 if dst < src
*        0 if dst = src
*       >0 if dst > src
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _wcsicmp (
        const wchar_t * dst,
        const wchar_t * src
        )
{
        wchar_t f,l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

#ifndef _NTSUBSET_
#ifdef  _MT
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* _NTSUBSET_ */
            do  {
                f = __ascii_towlower(*dst);
                l = __ascii_towlower(*src);
                dst++;
                src++;
            } while ( (f) && (f == l) );
#ifndef _NTSUBSET_
        }
        else {
            do  {
#ifdef  _MT
                f = __towlower_mt( ptloci, (unsigned short)(*(dst++)) );
                l = __towlower_mt( ptloci, (unsigned short)(*(src++)) );
#else
                f = towlower( (unsigned short)(*(dst++)) );
                l = towlower( (unsigned short)(*(src++)) );
#endif
            } while ( (f) && (f == l) );
        }
#endif  /* _NTSUBSET_ */

        return (int)(f - l);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsdup.c ===
/***
*wcsdup.c - duplicate a wide-character string in malloc'd memory
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsdup() - grab new memory, and duplicate the string into it
*	(wide-character).
*
*Revision History:
*	09-09-91  ETC	Created from strdup.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <malloc.h>
#include <string.h>

/***
*wchar_t *_wcsdup(string) - duplicate string into malloc'd memory
*
*Purpose:
*	Allocates enough storage via malloc() for a copy of the
*	string, copies the string into the new memory, and returns
*	a pointer to it (wide-character).
*
*Entry:
*	wchar_t *string - string to copy into new memory
*
*Exit:
*	returns a pointer to the newly allocated storage with the
*	string in it.
*
*	returns NULL if enough memory could not be allocated, or
*	string was NULL.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsdup (
	const wchar_t * string
	)
{
	wchar_t *memory;

	if (!string)
		return(NULL);

	if (memory = (wchar_t *) malloc((wcslen(string)+1) * sizeof(wchar_t)))
		return(wcscpy(memory,string));

	return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsicoll.c ===
/***
*wcsicoll.c - Collate wide-character locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*
*Revision History:
*       10-16-91  ETC   Created from wcscoll.c.
*       12-08-91  ETC   Added multithread lock.
*       04-06-92  KRS   Make work without _INTL also.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       02-07-94  CFW   POSIXify.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int _wcsicoll() - Collate wide-character locale strings without regard to case
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*       In the C locale, _wcsicmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _wcsicoll (
        const wchar_t *_string1,
        const wchar_t *_string2
        )
{
#if     !defined(_NTSUBSET_)
        int ret;
        wchar_t f, l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE ) {
#endif
            do  {
                f = __ascii_towlower(*_string1);
                l = __ascii_towlower(*_string2);
                _string1++;
                _string2++;
            } while ( (f) && (f == l) );

            return (int)(f - l);
        }

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_codepage )) )
#else
                                              __lc_codepage )) )
#endif
        {
                errno = EINVAL;
                return _NLSCMPERROR;
        }
    
        return (ret - 2);

#else

        return _wcsicmp(_string1, _string2);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsncat.c ===
/***
*wcsncat.c - append n chars of string to new string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncat() - appends n characters of string onto
*	end of other string
*
*Revision History:
*	09-09-91  ETC	Created from strncat.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsncat(front, back, count) - append count chars of back onto front
*
*Purpose:
*	Appends at most count characters of the string back onto the
*	end of front, and ALWAYS terminates with a null character.
*	If count is greater than the length of back, the length of back
*	is used instead.  (Unlike wcsncpy, this routine does not pad out
*	to count characters).
*
*Entry:
*	wchar_t *front - string to append onto
*	wchar_t *back - string to append
*	size_t count - count of max characters to append
*
*Exit:
*	returns a pointer to string appended onto (front).
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsncat (
	wchar_t * front,
	const wchar_t * back,
	size_t count
	)
{
	wchar_t *start = front;

	while (*front++)
		;
	front--;

	while (count--)
		if (!(*front++ = *back++))
			return(start);

	*front = L'\0';
	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcslen.c ===
/***
*wcslen.c - contains wcslen() routine
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcslen returns the length of a null-terminated wide-character string,
*	not including the null wchar_t itself.
*
*Revision History:
*	09-09-91  ETC	Created from strlen.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wcslen - return the length of a null-terminated wide-character string
*
*Purpose:
*	Finds the length in wchar_t's of the given string, not including
*	the final null wchar_t (wide-characters).
*
*Entry:
*	const wchar_t * wcs - string whose length is to be computed
*
*Exit:
*	length of the string "wcs", exclusive of the final null wchar_t
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen (
	const wchar_t * wcs
	)
{
	const wchar_t *eos = wcs;

	while( *eos++ ) ;

	return( (size_t)(eos - wcs - 1) );
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcslwr.c ===
/***
*wcslwr.c - routine to map upper-case characters in a wchar_t string 
*       to lower-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the upper case characters in a wchar_t string 
*       to lower case, in place.
*
*Revision History:
*       09-09-91  ETC   Created from strlwr.c.
*       04-06-92  KRS   Make work without _INTL also.
*       08-19-92  KRS   Activate NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Add code page for __crtxxx().
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       08-12-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt if
*                       possible.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

/***
*wchar_t *_wcslwr(string) - map upper-case characters in a string to lower-case
*
*Purpose:
*       wcslwr converts upper-case characters in a null-terminated wchar_t 
*       string to their lower-case equivalents.  The result may be longer or
*       shorter than the original string.  Assumes enough space in string
*       to hold the result.
*
*Entry:
*       wchar_t *wsrc - wchar_t string to change to lower case
*
*Exit:
*       input string address
*
*Exceptions:
*       on an error, the original string is unaltered
*
*******************************************************************************/

wchar_t * __cdecl _wcslwr (
        wchar_t * wsrc
        )
{
#ifndef _NTSUBSET_

        wchar_t *p;             /* traverses string for C locale conversion */
        wchar_t *wdst;          /* wide version of string in alternate case */
        int dstlen;             /* len of wdst string, wide chars, with null */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
            for ( p = wsrc ; *p ; p++ )
                if ( (*p >= (wchar_t)L'A') && (*p <= (wchar_t)L'Z') )
                    *p -= L'A' - L'a';

            return(wsrc);
        }   /* C locale */

        /* Inquire size of wdst string */
#ifdef  _MT
        if ( (dstlen = __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
        if ( (dstlen = __crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                          LCMAP_LOWERCASE,
                                          wsrc,
                                          -1,
                                          NULL,
                                          0,
#ifdef  _MT
                                          ptloci->lc_codepage )) == 0 )
#else
                                          __lc_codepage )) == 0 )
#endif
            return(wsrc);

        /* Allocate space for wdst */
        __try {
            wdst = (wchar_t *)_alloca(dstlen * sizeof(wchar_t));
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            wdst = NULL;
        }

        if ( wdst == NULL ) {
            wdst = (wchar_t *)_malloc_crt(dstlen * sizeof(wchar_t));
            malloc_flag++;
        }

        /* Map wrc string to wide-character wdst string in alternate case */
        if ( (wdst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                LCMAP_LOWERCASE,
                                wsrc,
                                -1,
                                wdst,
                                dstlen,
#ifdef  _MT
                                ptloci->lc_codepage ) != 0) )
#else
                                __lc_codepage ) != 0) )
#endif
            /* Copy wdst string to user string */
            wcscpy(wsrc, wdst);

        if ( malloc_flag )
            _free_crt(wdst);
#else

        wchar_t * p;

        for (p=wsrc; *p; ++p)
        {
            if (L'A' <= *p && *p <= L'Z')
                *p += (wchar_t)L'a' - (wchar_t)L'A';
        }

#endif
        return(wsrc);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsncpy.c ===
/***
*wcsncpy.c - copy at most n characters of wide-character string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncpy() - copy at most n characters of wchar_t string
*
*Revision History:
*	09-09-91  ETC	Created from strncpy.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsncpy(dest, source, count) - copy at most n wide characters
*
*Purpose:
*	Copies count characters from the source string to the
*	destination.  If count is less than the length of source,
*	NO NULL CHARACTER is put onto the end of the copied string.
*	If count is greater than the length of sources, dest is padded
*	with null characters to length count (wide-characters).
*
*
*Entry:
*	wchar_t *dest - pointer to destination
*	wchar_t *source - source string for copy
*	size_t count - max number of characters to copy
*
*Exit:
*	returns dest
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsncpy (
	wchar_t * dest,
	const wchar_t * source,
	size_t count
	)
{
	wchar_t *start = dest;

	while (count && (*dest++ = *source++))	  /* copy string */
		count--;

	if (count)				/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsncmp.c ===
/***
*wcsncmp.c - compare first n characters of two wide-character strings
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncmp() - compare first n characters of two wchar_t strings
*	for lexical order.
*
*Revision History:
*	09-09-91  ETC	Created from strncmp.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*int wcsncmp(first, last, count) - compare first count chars of wchar_t strings
*
*Purpose:
*	Compares two strings for lexical order.  The comparison stops
*	after: (1) a difference between the strings is found, (2) the end
*	of the strings is reached, or (3) count characters have been
*	compared (wide-character strings).
*
*Entry:
*	wchar_t *first, *last - strings to compare
*	size_t count - maximum number of characters to compare
*
*Exit:
*	returns <0 if first < last
*	returns  0 if first == last
*	returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsncmp (
	const wchar_t * first,
	const wchar_t * last,
	size_t count
	)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return((int)(*first - *last));
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsncoll.c ===
/***
*wcsncoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Revision History:
*       05-09-94  CFW   Created from wcsnicoll.c.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-13-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int _wcsncoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       Compares at most n characters of two strings.
*       In the C locale, _wcsncmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _wcsncoll (
        const wchar_t *_string1,
        const wchar_t *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if (!count)
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

#ifdef  _MT
        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return wcsncmp(_string1, _string2, count);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              (int)count,
                                              _string2,
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }
    
        return (ret - 2);

#else

        return wcsncmp(_string1, _string2, count);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsnicmp.c ===
/***
*wcsnicmp.c - compare n chars of wide-character strings, ignoring case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wcsnicmp() - Compares at most n characters of two wchar_t
*       strings, without regard to case.
*
*Revision History:
*       09-09-91  ETC   Created from strnicmp.c and wcsicmp.c.
*       12-09-91  ETC   Use C for neutral locale.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Remove locale-sensitive portion.
*       09-07-93  GJF   Fixed bug introduced on 4-14 (return value not was
*                       not well-defined if count == 0).
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Now works in non-C locales.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>

/***
*int _wcsnicmp(first, last, count) - compares count wchar_t of strings,
*       ignore case
*
*Purpose:
*       Compare the two strings for lexical order.  Stops the comparison
*       when the following occurs: (1) strings differ, (2) the end of the
*       strings is reached, or (3) count characters have been compared.
*       For the purposes of the comparison, upper case characters are
*       converted to lower case (wide-characters).
*
*Entry:
*       wchar_t *first, *last - strings to compare
*       size_t count - maximum number of characters to compare
*
*Exit:
*       -1 if first < last
*        0 if first == last
*        1 if first > last
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _wcsnicmp (
        const wchar_t * first,
        const wchar_t * last,
        size_t count
        )
{
        wchar_t f,l;
        int result = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        if ( count ) {
#ifndef _NTSUBSET_
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* _NTSUBSET_ */
                do {
                    f = __ascii_towlower(*first);
                    l = __ascii_towlower(*last);
                    first++;
                    last++;
                } while ( (--count) && f && (f == l) );
#ifndef _NTSUBSET_
            }
            else {
                do {
#ifdef  _MT
                    f = __towlower_mt( ptloci, (unsigned short)(*(first++)) );
                    l = __towlower_mt( ptloci, (unsigned short)(*(last++)) );
#else
                    f = towlower( (unsigned short)(*(first++)) );
                    l = towlower( (unsigned short)(*(last++)) );
#endif
                } while ( (--count) && f && (f == l) );
            }
#endif  /* _NTSUBSET_ */

            result = (int)(f - l);
        }
        return result;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsnicol.c ===
/***
*wcsnicoll.c - Collate wide-character locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*       Compares at most n characters of two strings.
*
*Revision History:
*       01-13-94  CFW   Created from wcsicoll.c.
*       02-07-94  CFW   POSIXify.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       05-09-94  CFW   Fix !_INTL case.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/***
*int _wcsnicoll() - Collate wide-character locale strings without regard to case
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*       Compares at most n characters of two strings.
*       In the C locale, _wcsicmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _wcsnicoll (
        const wchar_t *_string1,
        const wchar_t *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if (!count)
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

#ifdef  _MT
        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
        {
            wchar_t f, l;

            do {
                f = __ascii_towlower(*_string1);
                l = __ascii_towlower(*_string2);
                _string1++;
                _string2++;
            } while ( (--count) && f && (f == l) );

            return (int)(f - l);
        }

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              (int)count,
                                              _string2,
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return _wcsnicmp(_string1, _string2, count);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsrchr.c ===
/***
*wcsrchr.c - find last occurrence of wchar_t character in wide string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsrchr() - find the last occurrence of a given character
*	in a string (wide-characters).
*
*Revision History:
*	09-09-91  ETC	Created from strrchr.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsrchr(string, ch) - find last occurrence of ch in wide string
*
*Purpose:
*	Finds the last occurrence of ch in string.  The terminating
*	null character is used as part of the search (wide-characters).
*
*Entry:
*	wchar_t *string - string to search in
*	wchar_t ch - character to search for
*
*Exit:
*	returns a pointer to the last occurrence of ch in the given
*	string
*	returns NULL if ch does not occurr in the string
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsrchr (
	const wchar_t * string,
	wchar_t ch
	)
{
	wchar_t *start = (wchar_t *)string;

	while (*string++)			/* find end of string */
		;
						/* search towards front */
	while (--string != start && *string != (wchar_t)ch)
		;

	if (*string == (wchar_t)ch)		/* wchar_t found ? */
		return( (wchar_t *)string );

	return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsnset.c ===
/***
*wcsnset.c - set first n wide-characters to single wide-character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsnset() - sets at most the first n characters of a 
*	wchar_t string to a given character.
*
*Revision History:
*	09-09-91  ETC	Created from strnset.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *_wcsnset(string, val, count) - set at most count characters to val
*
*Purpose:
*	Sets the first count characters of string the character value.
*	If the length of string is less than count, the length of
*	string is used in place of n (wide-characters).
*
*Entry:
*	wchar_t *string - string to set characters in
*	wchar_t val - character to fill with
*	size_t count - count of characters to fill
*
*Exit:
*	returns string, now filled with count copies of val.
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsnset (
	wchar_t * string,
	wchar_t val,
	size_t count
	)
{
	wchar_t *start = string;

	while (count-- && *string)
		*string++ = (wchar_t)val;

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcspbrk.c ===
/***
*wcspbrk.c - scans wide character string for a character from control string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcspbrk()- returns pointer to the first wide-character in
*	a wide-character string in the control string.
*
*Revision History:
*	11-04-91  ETC	Created with source from crtdll.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcspbrk(string, control) - scans string for a character from control
*
*Purpose:
*	Returns pointer to the first wide-character in
*	a wide-character string in the control string.
*
*Entry:
*	wchar_t *string - string to search in
*	wchar_t *control - string containing characters to search for
*
*Exit:
*	returns a pointer to the first character from control found
*	in string.
*	returns NULL if string and control have no characters in common.
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcspbrk (
	const wchar_t * string,
	const wchar_t * control
	)
{
        wchar_t *wcset;

        /* 1st char in control string stops search */
        while (*string) {
            for (wcset = (wchar_t *) control; *wcset; wcset++) {
                if (*wcset == *string) {
                    return (wchar_t *) string;
                }
            }
            string++;
        }
        return NULL;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\dll\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsset.c ===
/***
*wcsset.c - sets all characters of wchar_t string to given character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsset() - sets all of the characters in a string (except
*	the L'\0') equal to a given character (wide-characters).
*
*Revision History:
*	09-09-91  ETC	Created from strset.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *_wcsset(string, val) - sets all of string to val (wide-characters)
*
*Purpose:
*	Sets all of wchar_t characters in string (except the terminating '/0'
*	character) equal to val (wide-characters).
*
*
*Entry:
*	wchar_t *string - string to modify
*	wchar_t val - value to fill string with
*
*Exit:
*	returns string -- now filled with val's
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsset (
	wchar_t * string,
	wchar_t val
	)
{
	wchar_t *start = string;

	while (*string)
		*string++ = (wchar_t)val;

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsspn.c ===
/***
*wcsspn.c - find length of initial substring of chars from a control string
*       (wide-character strings)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wcsspn() - finds the length of the initial substring of
*       a string consisting entirely of characters from a control string
*       (wide-character strings).
*
*Revision History:
*       11-04-91  ETC   Created with source from crtdll.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       02-27-98  RKP   Added 64 bit support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*int wcsspn(string, control) - find init substring of control chars
*
*Purpose:
*       Finds the index of the first character in string that does belong
*       to the set of characters specified by control.  This is
*       equivalent to the length of the initial substring of string that
*       consists entirely of characters from control.  The L'\0' character
*       that terminates control is not considered in the matching process
*       (wide-character strings).
*
*Entry:
*       wchar_t *string - string to search
*       wchar_t *control - string containing characters not to search for
*
*Exit:
*       returns index of first wchar_t in string not in control
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcsspn (
        const wchar_t * string,
        const wchar_t * control
        )
{
        wchar_t *str = (wchar_t *) string;
        wchar_t *ctl;

        /* 1st char not in control string stops search */
        while (*str) {
            for (ctl = (wchar_t *)control; *ctl != *str; ctl++) {
                if (*ctl == (wchar_t)0) {
                    /*
                     * reached end of control string without finding a match
                     */
                    return (size_t)(str - string);
                }
            }
            str++;
        }
        /*
         * The whole string consisted of characters from control
         */
        return (size_t)(str - string);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsstr.c ===
/***
*wcsstr.c - search for one wide-character string inside another
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wcsstr() - search for one wchar_t string inside another
*
*Revision History:
*       09-09-91  ETC   Created from strstr.c.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       08-02-00  GB    fixed str2 = ""
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsstr(string1, string2) - search for string2 in string1 
*       (wide strings)
*
*Purpose:
*       finds the first occurrence of string2 in string1 (wide strings)
*
*Entry:
*       wchar_t *string1 - string to search in
*       wchar_t *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsstr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;

        if ( !*wcs2)
            return (wchar_t *)wcs1;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                while ( *s1 && *s2 && !(*s1-*s2) )
                        s1++, s2++;

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcstok.c ===
/***
*wcstok.c - tokenize a wide-character string with given delimiters
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcstok() - breaks wide-character string into series of token
*	via repeated calls.
*
*Revision History:
*	09-09-91  ETC	Created from strtok.c.
*	08-17-92  KRS	Activate multithread support.
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	09-27-93  CFW	Remove Cruiser support.
*	09-29-93  GJF	Replaced MTHREAD with _MT.
*       02-07-94  CFW   POSIXify.
*	09-06-94  CFW	Replace MTHREAD with _MT (again).
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#ifdef	_MT
#include <mtdll.h>
#endif

/***
*wchar_t *wcstok(string, control) - tokenize string with delimiter in control
*	(wide-characters)
*
*Purpose:
*	wcstok considers the string to consist of a sequence of zero or more
*	text tokens separated by spans of one or more control chars. the first
*	call, with string specified, returns a pointer to the first wchar_t of
*	the first token, and will write a null wchar_t into string immediately
*	following the returned token. subsequent calls with zero for the first
*	argument (string) will work thru the string until no tokens remain. the
*	control string may be different from call to call. when no tokens remain
*	in string a NULL pointer is returned. remember the control chars with a
*	bit map, one bit per wchar_t. the null wchar_t is always a control char
*	(wide-characters).
*
*Entry:
*	wchar_t *string - wchar_t string to tokenize, or NULL to get next token
*	wchar_t *control - wchar_t string of characters to use as delimiters
*
*Exit:
*	returns pointer to first token in string, or if string
*	was NULL, to next token
*	returns NULL when no more tokens remain.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcstok (
	wchar_t * string,
	const wchar_t * control
	)
{
	wchar_t *token;
	const wchar_t *ctl;

#ifdef	_MT

	_ptiddata ptd = _getptd();

#else

	static wchar_t *nextoken;

#endif

	/* If string==NULL, continue with previous string */
	if (!string)

#ifdef	_MT

		string = ptd->_wtoken;

#else

		string = nextoken;

#endif

	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets string to point to the terminal
	 * null (*string == '\0') */

	while (*string) {
		for (ctl=control; *ctl && *ctl != *string; ctl++)
			;
		if (!*ctl) break;
		string++;
	}

	token = string;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *string ; string++ ) {
		for (ctl=control; *ctl && *ctl != *string; ctl++)
			;
		if (*ctl) {
			*string++ = '\0';
			break;
		}
	}

	/* Update nextoken (or the corresponding field in the per-thread data
	 * structure */
#ifdef	_MT

	ptd->_wtoken = string;

#else

	nextoken = string;

#endif

	/* Determine if a token has been found. */
	if ( token == string )
		return NULL;
	else
		return token;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsrev.c ===
/***
*wcsrev.c - reverse a wide-character string in place
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsrev() - reverse a wchar_t string in place (not including
*	L'\0' character)
*
*Revision History:
*	09-09-91  ETC	Created from strrev.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *_wcsrev(string) - reverse a wide-character string in place
*
*Purpose:
*	Reverses the order of characters in the string.  The terminating
*	null character remains in place (wide-characters).
*
*Entry:
*	wchar_t *string - string to reverse
*
*Exit:
*	returns string - now with reversed characters
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsrev (
	wchar_t * string
	)
{
	wchar_t *start = string;
	wchar_t *left = string;
	wchar_t ch;

	while (*string++)		  /* find end of string */
		;
	string -= 2;

	while (left < string)
	{
		ch = *left;
		*left++ = *string;
		*string-- = ch;
	}

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsupr.c ===
/***
*wcsupr.c - routine to map lower-case characters in a wchar_t string
*       to upper-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the lower case characters in a wchar_t string
*       to upper case, in place.
*
*Revision History:
*       09-09-91  ETC   Created from strupr.c and wcslwr.c
*       04-06-92  KRS   Make work without _INTL also.
*       08-19-92  KRS   Activate NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       02-16-93  CFW   Optimize test for lowercase in "C" locale.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Add code page for __crtxxx().
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       08-17-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt if
*                       possible.
*       10-19-98  GJF   Major typo, = should have been ==
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

/***
*wchar_t *_wcsupr(string) - map lower-case characters in a string to upper-case
*
*Purpose:
*       wcsupr converts lower-case characters in a null-terminated wchar_t 
*       string to their upper-case equivalents.  The result may be longer or
*       shorter than the original string.  Assumes enough space in string
*       to hold the result.
*
*Entry:
*       wchar_t *wsrc - wchar_t string to change to upper case
*
*Exit:
*       input string address
*
*Exceptions:
*       on an error, the original string is unaltered
*
*******************************************************************************/

wchar_t * __cdecl _wcsupr (
        wchar_t * wsrc
        )
{
#ifndef _NTSUBSET_

        wchar_t *p;             /* traverses string for C locale conversion */
        wchar_t *wdst;          /* wide version of string in alternate case */
        int dstlen;             /* len of wdst string, wide chars, with null */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
            for ( p = wsrc ; *p ; p++ )
            {
                if ( (*p >= (wchar_t)L'a') && (*p <= (wchar_t)L'z') )
                    *p = *p - (L'a' - L'A');
            }
            return(wsrc);
        }   /* C locale */


        /* Inquire size of wdst string */
#ifdef  _MT
        if ( (dstlen = __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
        if ( (dstlen = __crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                          LCMAP_UPPERCASE,
                                          wsrc,
                                          -1,
                                          NULL,
                                          0,
#ifdef  _MT
                                          ptloci->lc_codepage )) == 0 )
#else
                                          __lc_codepage )) == 0 )
#endif
            return(wsrc);

        /* Allocate space for wdst */
        __try {
            wdst = (wchar_t *)_alloca(dstlen * sizeof(wchar_t));
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            wdst = NULL;
        }

        if ( wdst == NULL ) {
            wdst = (wchar_t *)_malloc_crt(dstlen * sizeof(wchar_t));
            malloc_flag++;
        }

        /* Map wrc string to wide-character wdst string in alternate case */
        if ( (wdst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                 LCMAP_UPPERCASE,
                                 wsrc,
                                 -1,
                                 wdst,
                                 dstlen,
#ifdef  _MT
                                 ptloci->lc_codepage ) != 0) )
#else
                                 __lc_codepage ) != 0) )
#endif
            /* Copy wdst string to user string */
            wcscpy (wsrc, wdst);

        if ( malloc_flag )
            _free_crt(wdst);

#else

        wchar_t * p;

        for (p=wsrc; *p; ++p)
        {
                if (L'a' <= *p && *p <= L'z')
                        *p += (wchar_t)(L'A' - L'a');
        }


#endif
        return(wsrc);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\memccpy.asm ===
page	,132
	title	memccpy - copy bytes until character found
;***
;memccpy.asm - copy bytes until a character is found
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _memccpy() - copies bytes until a specifed character
;	is found, or a maximum number of characters have been copied.
;
;Revision History:
;	05-16-84  RN	initial version
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	Minor 386 adjustments
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-17-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	10-27-92  SKS	Avoid using a MASM keyword ("C") as a parameter name
;	01-19-95  GJF	Faster version courtesy of Intel Israel.
;	01-24-95  GJF	Added FPO directive.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_memccpy(dest, src, _c, count) - copy bytes until character found
;
;Purpose:
;	Copies bytes from src to dest until count bytes have been
;	copied, or up to and including the character _c, whichever
;	comes first.
;
;	Algorithm:
;	char *
;	_memccpy (dest, src, _c, count)
;	      char *dest, *src, _c;
;	      unsigned int count;
;	      {
;	      while (count && (*dest++ = *src++) != _c)
;		      count--;
;
;	      return(count ? dest : NULL);
;	      }
;
;Entry:
;	char *dest - pointer to memory to receive copy
;	char *src - source of bytes
;	char _c - character to stop copy at
;	int count - max number of bytes to copy
;
;Exit:
;	returns pointer to byte immediately after _c in dest;
;	returns NULL if _c was never found
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_memccpy
_memccpy proc

	.FPO	( 0, 4, 0, 0, 0, 0 )

	mov	ecx,[esp + 10h]	; ecx = max byte count
	push	ebx		; save ebx
 
	test	ecx,ecx 	; if it's nothing to move
	jz	ret_zero_len	; restore ebx, and return NULL
 
	mov	bh,[esp + 10h]	; bh = byte to look for
	push	esi		; save esi
 
	test	ecx,1		; test if counter is odd or even
 
	mov	eax,[esp + 0ch]	; eax = dest   , don't affect flags
	mov	esi,[esp + 10h]	; esi = source , don't affect flags
 
;	nop
	jz	lupe2		; if counter is even, do double loop
				; else do one iteration, and drop into double loop
	mov	bl,[esi]	; get first byte into bl
	inc	esi		; kick src (esi points to src)
 
	mov	[eax],bl	; store it in dest
	inc	eax		; kick dest
 
	cmp	bl,bh		; see if we just moved the byte
	je	short toend
 
	dec	ecx		; decriment counter
	jz	retnull		; drop into double loop if nonzero
 
lupe2:
	mov	bl,[esi]	; get first byte into bl
	add	esi,2		; kick esi (src)
 
	cmp	bl,bh		; check if we just moved the byte (from bl)
	je	toend_mov_inc	; store bl & exit
 
	mov	[eax],bl	; store first byte from bl
	mov	bl,[esi - 1]	; get second byte  into bl
 
	mov	[eax + 1],bl	; store second byte from bl
	add	eax,2		; kick eax (dest)
 
	cmp	bl,bh		; see if we just moved the byte
	je	short toend	; end of string
 
	sub	ecx,2		; modify counter, and if nonzero continue
	jnz	lupe2		; else drop out & return NULL
 
retnull:
	pop	esi
ret_zero_len:
	xor	eax,eax 	; null pointer
	pop	ebx
 
	ret			; _cdecl return
 
toend_mov_inc:
	mov	[eax],bl	; store first byte from bl
	inc	eax		; eax points rihgt after the value
 
toend:	pop	esi
	pop	ebx
 
	ret			; _cdecl return
 
_memccpy endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\memmove.asm ===
;***
;memmove.asm -
;
;	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	memmove() copies a source memory buffer to a destination buffer.
;	Overlapping buffers are treated specially, to avoid propogation.
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

MEM_MOVE EQU 1
INCLUDE I386\MEMCPY.ASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\memcmp.asm ===
page	,132
	title	memcmp - compare to blocks of memory
;***
;memcmp.asm - compare two blocks of memory
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines memcmp() - compare two memory blocks lexically and
;	find their order.
;
;Revision History:
;	05-16-83  RN	initial version
;	07-20-87  SKS	rewritten for speed
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	05-01-95  GJF	New, faster version from Intel!
;	05-09-95  GJF	Replaced a bad ret with a good jz retnull (my editing
;			error, not Intel's).
;       11-06-95  GJF   Corrected order in which esi and edi are saved.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int memcmp(buf1, buf2, count) - compare memory for lexical order
;
;Purpose:
;	Compares count bytes of memory starting at buf1 and buf2
;	and find if equal or which one is first in lexical order.
;
;	Algorithm:
;	int
;	memcmp (buf1, buf2, count)
;		char *buf1, *buf2;
;		unsigned count;
;	{
;		if (!count)
;			return(0);
;		while (--count && *buf1 == *buf2)
;			{
;			buf1++;
;			buf2++;
;			}
;		return(*buf1 - *buf2);
;	}
;
;Entry:
;	char *buf1, *buf2 - pointers to memory sections to compare
;	unsigned count - length of sections to compare
;
;Exit:
;	returns -1 if buf1 < buf2
;	returns  0 if buf1 == buf2
;	returns +1 if buf1 > buf2
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memcmp
memcmp	proc

	.FPO	( 0, 3, 0, 0, 0, 0 )

	mov	eax,[esp+0ch]	; eax = counter
	test	eax,eax 	; test if counter is zero
	jz	short retnull	; return 0

	mov	edx,[esp+4]	; edx = buf1
	push	esi
	push	edi
	mov	esi,edx		; esi = buf1
	mov	edi,[esp+10h]	; edi = buf2

; Check for dword (32 bit) alignment
	or	edx,edi
	and	edx,3		; edx=0 iff buf1 are buf2 are aligned
	jz	short dwords
 
; Strings are not aligned. If the caller knows the strings (buf1 and buf2) are
; different, the function may be called with length like -1. The difference 
; may be found in the last dword of aligned string, and because the other 
; string is misaligned it may cause page fault. So, to be safe. the comparison
; must be done byte by byte.
	test	eax,1
	jz	short main_loop
 
	mov	cl,[esi]
	cmp	cl,[edi]
	jne	short not_equal
	inc	esi
	inc	edi
	dec	eax
	jz	short done	; eax is already 0

main_loop:
	mov	cl,[esi]
	mov	dl,[edi]
	cmp	cl,dl
	jne	short not_equal
 
	mov	cl,[esi+1]
	mov	dl,[edi+1]
	cmp	cl,dl
	jne	short not_equal
 
	add	edi,2
	add	esi,2
 
	sub	eax,2
	jnz	short main_loop
done:
	pop	edi
	pop	esi
retnull:
	ret			; _cdecl return
 
 
dwords:
	mov	ecx,eax
	and	eax,3		; eax= counter for tail loop
 
	shr	ecx,2
	jz	short tail_loop_start
				; counter was >=4 so may check one dword
	rep	cmpsd
 
	jz	short tail_loop_start
 
; in last dword was difference
	mov	ecx,[esi-4]	; load last dword from buf1 to ecx
	mov	edx,[edi-4]	; load last dword from buf2 to edx
	cmp	cl,dl		; test first bytes
	jne	short difference_in_tail
	cmp	ch,dh		; test seconds bytes
	jne	short difference_in_tail
	shr	ecx,10h
	shr	edx,10h
	cmp	cl,dl		; test third bytes
	jne	short difference_in_tail
	cmp	ch,dh		; they are different, but each one is bigger?
;	jmp	short difference_in_tail
 
difference_in_tail:
	mov	eax,0
				; buf1 < buf2 buf1 > buf2
not_equal:
	sbb	eax,eax		; AX=-1, CY=1 AX=0, CY=0
	pop	edi		; counter
	sbb	eax,-1		; AX=-1	AX=1
	pop	esi
	ret			; _cdecl return
 
; in tail loop we test last three bytes (esi and edi are aligned on dword
; boundary)
tail_loop_start:
 
	test	eax,eax 	; eax is counter%4 (number of bytes for tail
				; loop)
	jz	short done	; taken if there is no tail bytes
	mov	edx,[esi]	; load dword from buf1
	mov	ecx,[edi]	; load dword from buf2
	cmp	dl,cl		; test first bytes
	jne	short difference_in_tail
	dec	eax		; counter--
	jz	short tail_done
	cmp	dh,ch		; test second bytes
	jne	short difference_in_tail
	dec	eax		; counter--
	jz	short tail_done
	and	ecx,00ff0000h	; test third bytes
	and	edx,00ff0000h
	cmp	edx,ecx
	jne	short difference_in_tail
	dec	eax
tail_done:
	pop	edi
	pop	esi
	ret			; _cdecl return
 
memcmp	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\wcsxfrm.c ===
/***
*wcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       09-09-91  ETC   Created from strxfrm.c.
*       12-09-91  ETC   Updated api; Added multithread lock.
*       12-18-91  ETC   Changed back LCMAP_SORTKEYA --> LCMAP_SORTKEY.
*       04-06-92  KRS   Fix so it works without _INTL too.
*       08-19-92  KRS   Activate use of NLS API.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-15-92  KRS   Fix return value to match ANSI/ISO Std.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-23-93  CFW   Complete re-write. Non-C locale totally broken.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       07-16-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt if
*                       possible.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       10-12-00  GB    Changed the function to be similar to strxfrm()
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <stdlib.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

/***
*size_t wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _count wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = result string
*       const wchar_t *_string2 = source string
*       size_t _count           = max wide chars to move
*
*       [If _count is 0, _string1 is permitted to be NULL.]
*
*Exit:
*       Length of the transformed string (not including the terminating
*       null).  If the value returned is >= _count, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl wcsxfrm (
        wchar_t *_string1,
        const wchar_t *_string2,
        size_t _count
        )
{
#ifdef  _NTSUBSET_
        if (_string1)
            wcsncpy(_string1, _string2, _count);
        return wcslen(_string2);
#else
        int size = INT_MAX;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if ( _count > INT_MAX )
            return (size_t)size;

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else

        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
        {
            wcsncpy(_string1, _string2, _count);
            return wcslen(_string2);
        }

#ifdef  _MT
        if ( 0 == (size = __crtLCMapStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (size = __crtLCMapStringW( __lc_handle[LC_COLLATE],
#endif
                                             LCMAP_SORTKEY,
                                             _string2,
                                             -1,
                                             NULL,
                                             0,
#ifdef  _MT
                                             ptloci->lc_collate_cp )) )
#else
                                             __lc_collate_cp )) )
#endif
        {
            size = INT_MAX;
        } else
        {
            if ( (size_t)size <= _count)
            {
#ifdef  _MT
                if ( 0 == (size = __crtLCMapStringW( ptloci->lc_handle[LC_COLLATE],
#else
                if ( 0 == (size = __crtLCMapStringW( __lc_handle[LC_COLLATE],
#endif
                                                     LCMAP_SORTKEY,
                                                     _string2,
                                                     -1,
                                                     (wchar_t *)_string1,
                                                     (int)_count,
#ifdef  _MT
                                                     ptloci->lc_collate_cp )) )
#else
                                                     __lc_collate_cp )) )
#endif
                {
                    size = INT_MAX; /* default error */
                }
            }
        }

        return (size_t)size;

#endif  /* _NTSUBSET_ */

}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\memchr.asm ===
page	,132
	title	memchr - search memory for a given character
;***
;memchr.asm - search block of memory for a given character
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines memchr() - search memory until a character is
;	found or a limit is reached.
;
;Revision History:
;	05-16-84  RN	initial version
;	07-20-87  SKS	rewritten for speed
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	05-01-95  GJF	New, faster version from Intel!
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *memchr(buf, chr, cnt) - search memory for given character.
;
;Purpose:
;	Searched at buf for the given character, stopping when chr is
;	first found or cnt bytes have been searched through.
;
;	Algorithm:
;	char *
;	memchr (buf, chr, cnt)
;		char *buf;
;		int chr;
;		unsigned cnt;
;	{
;		while (cnt && *buf++ != c)
;			cnt--;
;		return(cnt ? --buf : NULL);
;	}
;
;Entry:
;	char *buf - memory buffer to be searched
;	char chr - character to search for
;	unsigned cnt - max number of bytes to search
;
;Exit:
;	returns pointer to first occurence of chr in buf
;	returns NULL if chr not found in the first cnt bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memchr
memchr	proc

	.FPO	( 0, 1, 0, 0, 0, 0 )

	mov	eax,[esp+0ch]	; eax = count
	push	ebx		; Preserve ebx

	test	eax,eax 	; check if count=0
	jz	short retnull	; if count=0, leave

	mov	edx,[esp+8]	; edx = buffer
	xor	ebx,ebx

	mov	bl,[esp+0ch]	; bl = search char

	test	edx,3		; test if string is aligned on 32 bits
	jz	short main_loop_start

str_misaligned: 		; simple byte loop until string is aligned
	mov	cl,byte ptr [edx]
	inc	edx
	xor	cl,bl
	je	short found
	dec	eax		; counter--
	jz	short retnull
	test	edx,3		; already aligned ?
	jne	short str_misaligned

main_loop_start:
	sub	eax,4
	jb	short tail_less_then_4

; set all 4 bytes of ebx to [value]
	push	edi		; Preserve edi
	mov	edi,ebx		; edi=0/0/0/char
	shl	ebx,8		; ebx=0/0/char/0
	add	ebx,edi		; ebx=0/0/char/char
	mov	edi,ebx		; edi=0/0/char/char
	shl	ebx,10h		; ebx=char/char/0/0
	add	ebx,edi		; ebx = all 4 bytes = [search char]
	jmp	short main_loop_entry	; ecx >=0

return_from_main:
	pop	edi

tail_less_then_4:
	add	eax,4
	jz	retnull

tail_loop:			; 0 < eax < 4
	mov	cl,byte ptr [edx]
	inc	edx
	xor	cl,bl
	je	short found
	dec	eax
	jnz	short tail_loop
retnull:
	pop	ebx
	ret			; _cdecl return

main_loop:
	sub	eax,4
	jb	short return_from_main
main_loop_entry:
	mov	ecx,dword ptr [edx]	; read 4 bytes

	xor	ecx,ebx		; ebx is byte\byte\byte\byte
	mov	edi,7efefeffh

	add	edi,ecx
	xor	ecx,-1

	xor	ecx,edi
	add	edx,4

	and	ecx,81010100h
	je	short main_loop

; found zero byte in the loop?
char_is_found:
	mov	ecx,[edx - 4]
	xor	cl,bl		; is it byte 0
	je	short byte_0
	xor	ch,bl		; is it byte 1
	je	short byte_1
	shr	ecx,10h		; is it byte 2
	xor	cl,bl
	je	short byte_2
        xor     ch,bl           ; is it byte 3
        je      short byte_3
	jmp	short main_loop ; taken if bits 24-30 are clear and bit
				; 31 is set

byte_3:
	pop	edi		; restore edi
found:
	lea	eax,[edx - 1]
	pop	ebx		; restore ebx
	ret			; _cdecl return

byte_2:
	lea	eax,[edx - 2]
	pop	edi
	pop	ebx
	ret			; _cdecl return

byte_1:
	lea	eax,[edx - 3]
	pop	edi
	pop	ebx
	ret			; _cdecl return

byte_0:
	lea	eax,[edx - 4]
	pop	edi		; restore edi
	pop	ebx		; restore ebx
	ret			; _cdecl return

memchr	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\memset.asm ===
page	,132
	title	memset - set sections of memory all to one byte
;***
;memset.asm - set a section of memory to all one byte
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	contains the memset() routine
;
;Revision History:
;	05-07-84  RN	initial version
;	06-30-87  SKS	faster algorithm
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-19-88  JCR	Enable word alignment code for all models/CPUs,
;			Some code improvement
;	10-25-88  JCR	General cleanup for 386-only code
;	10-27-88  JCR	More optimization (dword alignment, no ebx usage, etc)
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	01-23-95  GJF	Improved routine from Intel Israel. I fixed up the
;			formatting and comments.
;	01-24-95  GJF	Added FPO directive.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *memset(dst, value, count) - sets "count" bytes at "dst" to "value"
;
;Purpose:
;	Sets the first "count" bytes of the memory starting
;	at "dst" to the character value "value".
;
;	Algorithm:
;	char *
;	memset (dst, value, count)
;		char *dst;
;		char value;
;		unsigned int count;
;		{
;		char *start = dst;
;
;		while (count--)
;			*dst++ = value;
;		return(start);
;		}
;
;Entry:
;	char *dst - pointer to memory to fill with value
;	char value - value to put in dst bytes
;	int count - number of bytes of dst to fill
;
;Exit:
;	returns dst, with filled bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memset
memset proc

	.FPO	( 0, 3, 0, 0, 0, 0 )

	mov	edx,[esp + 0ch]	; edx = "count"
	mov	ecx,[esp + 4]	; ecx points to "dst"
 
	test	edx,edx 	; 0?
	jz	short toend	; if so, nothing to do
 
	xor	eax,eax
	mov	al,[esp + 8]	; the byte "value" to be stored
 
 
; Align address on dword boundary
 
	push	edi		; preserve edi
	mov	edi,ecx		; edi = dest pointer
 
	cmp	edx,4		; if it's less then 4 bytes
	jb	tail		; tail needs edi and edx to be initialized
 
	neg	ecx
	and	ecx,3		; ecx = # bytes before dword boundary
	jz	short dwords	; jump if address already aligned
 
	sub	edx,ecx		; edx = adjusted count (for later)
adjust_loop:
	mov	[edi],al
	inc	edi
	dec	ecx
	jnz	adjust_loop
 
dwords:
; set all 4 bytes of eax to [value]
	mov	ecx,eax		; ecx=0/0/0/value
	shl	eax,8		; eax=0/0/value/0
 
	add	eax,ecx		; eax=0/0val/val
 
	mov	ecx,eax		; ecx=0/0/val/val
 
	shl	eax,10h		; eax=val/val/0/0
 
	add	eax,ecx		; eax = all 4 bytes = [value]
 
; Set dword-sized blocks
	mov	ecx,edx		; move original count to ecx
	and	edx,3		; prepare in edx byte count (for tail loop)
	shr	ecx,2		; adjust ecx to be dword count
	jz	tail		; jump if it was less then 4 bytes
 
	rep	stosd
main_loop_tail:
	test	edx,edx 	; if there is no tail bytes,
	jz	finish		; we finish, and it's time to leave
; Set remaining bytes
 
tail:
	mov	[edi],al	; set remaining bytes
	inc	edi
 
	dec	edx		; if there is some more bytes
	jnz	tail		; continue to fill them
 
; Done
finish:
	mov	eax,[esp + 8]	; return dest pointer
	pop	edi		; restore edi

	ret

toend:
	mov	eax,[esp + 4]	; return dest pointer
 
	ret
 
memset	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\memcpy.asm ===
page    ,132
        title   memcpy - Copy source memory bytes to destination
;***
;memcpy.asm - contains memcpy and memmove routines
;
;       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are not treated specially, so propogation may occur.
;       memmove() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are treated specially, to avoid propogation.
;
;Revision History:
;       02-06-87  JCR   Added memmove entry
;       04-08-87  JCR   Conditionalized memmove/memcpy entries
;       06-30-87  SKS   Rewritten for speed and size
;       08-21-87  SKS   Fix return value for overlapping copies
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-19-88  JCR   Minor 386 corrections/enhancements
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       11-13-92  SRW   Make it fast with unaligned arguments
;       09-26-96  RDK   Total rewrite to optimize for Pentium execution.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

M_EXIT  macro
ifdef   _STDCALL_
        ret     2*DPSIZE + ISIZE ; _stdcall return
else
        ret                     ; _cdecl return
endif
        endm    ; M_EXIT

        CODESEG

page
;***
;memcpy - Copy source buffer to destination buffer
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination memory buffer.
;       This routine does NOT recognize overlapping buffers, and thus can lead
;       to propogation.
;       For cases where propogation must be avoided, memmove() must be used.
;
;       Algorithm:
;
;       void * memcpy(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               /*
;                * copy from lower addresses to higher addresses
;                */
;               while (count--)
;                       *dst++ = *src++;
;
;               return(ret);
;       }
;
;memmove - Copy source buffer to destination buffer
;
;Purpose:
;       memmove() copies a source memory buffer to a destination memory buffer.
;       This routine recognize overlapping buffers to avoid propogation.
;       For cases where propogation is not a problem, memcpy() can be used.
;
;   Algorithm:
;
;       void * memmove(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               if (dst <= src || dst >= (src + count)) {
;                       /*
;                        * Non-Overlapping Buffers
;                        * copy from lower addresses to higher addresses
;                        */
;                       while (count--)
;                               *dst++ = *src++;
;                       }
;               else {
;                       /*
;                        * Overlapping Buffers
;                        * copy from higher addresses to lower addresses
;                        */
;                       dst += count - 1;
;                       src += count - 1;
;
;                       while (count--)
;                               *dst-- = *src--;
;                       }
;
;               return(ret);
;       }
;
;
;Entry:
;       void *dst = pointer to destination buffer
;       const void *src = pointer to source buffer
;       size_t count = number of bytes to copy
;
;Exit:
;       Returns a pointer to the destination buffer in AX/DX:AX
;
;Uses:
;       CX, DX
;
;Exceptions:
;*******************************************************************************

ifdef   MEM_MOVE
        _MEM_     equ <memmove>
else
        _MEM_     equ <memcpy>
endif

%       public  _MEM_
_MEM_   proc \
        dst:ptr byte, \
        src:ptr byte, \
        count:IWORD

              ; destination pointer
              ; source pointer
              ; number of bytes to copy

;       push    ebp             ;U - save old frame pointer
;       mov     ebp, esp        ;V - set new frame pointer

        push    edi             ;U - save edi
        push    esi             ;V - save esi

        mov     esi,[src]       ;U - esi = source
        mov     ecx,[count]     ;V - ecx = number of bytes to move

        mov     edi,[dst]       ;U - edi = dest

;
; Check for overlapping buffers:
;       If (dst <= src) Or (dst >= src + Count) Then
;               Do normal (Upwards) Copy
;       Else
;               Do Downwards Copy to avoid propagation
;

        mov     eax,ecx         ;V - eax = byte count...

        mov     edx,ecx         ;U - edx = byte count...
        add     eax,esi         ;V - eax = point past source end

        cmp     edi,esi         ;U - dst <= src ?
        jbe     short CopyUp    ;V - yes, copy toward higher addresses

        cmp     edi,eax         ;U - dst < (src + count) ?
        jb      CopyDown        ;V - yes, copy toward lower addresses

;
; Copy toward higher addresses.
;
;
; The algorithm for forward moves is to align the destination to a dword
; boundary and so we can move dwords with an aligned destination.  This
; occurs in 3 steps.
;
;   - move x = ((4 - Dest & 3) & 3) bytes
;   - move y = ((L-x) >> 2) dwords
;   - move (L - x - y*4) bytes
;

CopyUp:
        test    edi,11b         ;U - destination dword aligned?
        jnz     short CopyLeadUp ;V - if we are not dword aligned already, align

        shr     ecx,2           ;U - shift down to dword count
        and     edx,11b         ;V - trailing byte count

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

;
; Code to do optimal memory copies for non-dword-aligned destinations.
;

; The following length check is done for two reasons:
;
;    1. to ensure that the actual move length is greater than any possiale
;       alignment move, and
;
;    2. to skip the multiple move logic for small moves where it would
;       be faster to move the bytes with one instruction.
;

        align   @WordSize
CopyLeadUp:

        mov     eax,edi         ;U - get destination offset
        mov     edx,11b         ;V - prepare for mask

        sub     ecx,4           ;U - check for really short string - sub for adjust
        jb      short ByteCopyUp ;V - branch to just copy bytes

        and     eax,11b         ;U - get offset within first dword
        add     ecx,eax         ;V - update size after leading bytes copied

        jmp     dword ptr LeadUpVec[eax*4-4] ;N - process leading bytes

        align   @WordSize
ByteCopyUp:
        jmp     dword ptr TrailUpVec[ecx*4+16] ;N - process just bytes

        align   @WordSize
CopyUnwindUp:
        jmp     dword ptr UnwindUpVec[ecx*4] ;N - unwind dword copy

        align   @WordSize
LeadUpVec       dd      LeadUp1, LeadUp2, LeadUp3

        align   @WordSize
LeadUp1:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get second byte from source

        mov     [edi+1],al      ;U - write second byte to destination
        mov     al,[esi+2]      ;V - get third byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+2],al      ;V - write third byte to destination

        add     esi,3           ;U - advance source pointer
        add     edi,3           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadUp2:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get second byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+1],al      ;V - write second byte to destination

        add     esi,2           ;U - advance source pointer
        add     edi,2           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadUp3:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        inc     esi             ;V - advance source pointer

        shr     ecx,2           ;U - shift down to dword count
        inc     edi             ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes
        
        align   @WordSize
UnwindUpVec     dd      UnwindUp0, UnwindUp1, UnwindUp2, UnwindUp3
                dd      UnwindUp4, UnwindUp5, UnwindUp6, UnwindUp7

UnwindUp7:
        mov     eax,[esi+ecx*4-28] ;U - get dword from source
                                   ;V - spare
        mov     [edi+ecx*4-28],eax ;U - put dword into destination
UnwindUp6:
        mov     eax,[esi+ecx*4-24] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-24],eax ;U - put dword into destination
UnwindUp5:
        mov     eax,[esi+ecx*4-20] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-20],eax ;U - put dword into destination
UnwindUp4:
        mov     eax,[esi+ecx*4-16] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-16],eax ;U - put dword into destination
UnwindUp3:
        mov     eax,[esi+ecx*4-12] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-12],eax ;U - put dword into destination
UnwindUp2:
        mov     eax,[esi+ecx*4-8] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4-8],eax ;U - put dword into destination
UnwindUp1:
        mov     eax,[esi+ecx*4-4] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4-4],eax ;U - put dword into destination

        lea     eax,[ecx*4]     ;V - compute update for pointer

        add     esi,eax         ;U - update source pointer
        add     edi,eax         ;V - update destination pointer
UnwindUp0:
        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

;-----------------------------------------------------------------------------

        align   @WordSize
TrailUpVec      dd      TrailUp0, TrailUp1, TrailUp2, TrailUp3

        align   @WordSize
TrailUp0:
        mov     eax,[dst]       ;U - return pointer to destination
        pop     esi             ;V - restore esi
        pop     edi             ;U - restore edi
                                ;V - spare
        M_EXIT

        align   @WordSize
TrailUp1:
        mov     al,[esi]        ;U - get byte from source
                                ;V - spare
        mov     [edi],al        ;U - put byte in destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailUp2:
        mov     al,[esi]        ;U - get first byte from source
                                ;V - spare
        mov     [edi],al        ;U - put first byte into destination
        mov     al,[esi+1]      ;V - get second byte from source
        mov     [edi+1],al      ;U - put second byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailUp3:
        mov     al,[esi]        ;U - get first byte from source
                                ;V - spare
        mov     [edi],al        ;U - put first byte into destination
        mov     al,[esi+1]      ;V - get second byte from source
        mov     [edi+1],al      ;U - put second byte into destination
        mov     al,[esi+2]      ;V - get third byte from source
        mov     [edi+2],al      ;U - put third byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------

;
; Copy down to avoid propogation in overlapping buffers.
;
        align   @WordSize
CopyDown:
        lea     esi,[esi+ecx-4] ;U - point to 4 bytes before src buffer end
        lea     edi,[edi+ecx-4] ;V - point to 4 bytes before dest buffer end
;
; See if the destination start is dword aligned
;

        test    edi,11b         ;U - test if dword aligned
        jnz     short CopyLeadDown ;V - if not, jump

        shr     ecx,2           ;U - shift down to dword count
        and     edx,11b         ;V - trailing byte count

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag back

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
CopyUnwindDown:
        neg     ecx             ;U - negate dword count for table merging
                                ;V - spare

        jmp     dword ptr UnwindDownVec[ecx*4+28] ;N - unwind copy

        align   @WordSize
CopyLeadDown:

        mov     eax,edi         ;U - get destination offset
        mov     edx,11b         ;V - prepare for mask

        cmp     ecx,4           ;U - check for really short string
        jb      short ByteCopyDown ;V - branch to just copy bytes

        and     eax,11b         ;U - get offset within first dword
        sub     ecx,eax         ;U - to update size after lead copied

        jmp     dword ptr LeadDownVec[eax*4-4] ;N - process leading bytes

        align   @WordSize
ByteCopyDown:
        jmp     dword ptr TrailDownVec[ecx*4] ;N - process just bytes

        align   @WordSize
LeadDownVec     dd      LeadDown1, LeadDown2, LeadDown3

        align   @WordSize
LeadDown1:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        dec     esi             ;V - point to last src dword

        shr     ecx,2           ;U - shift down to dword count
        dec     edi             ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes
        
        align   @WordSize
LeadDown2:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        mov     al,[esi+2]      ;V - get second byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+2],al      ;V - write second byte to destination

        sub     esi,2           ;U - point to last src dword
        sub     edi,2           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadDown3:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        mov     al,[esi+2]      ;V - get second byte from source

        mov     [edi+2],al      ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get third byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+1],al      ;V - write third byte to destination

        sub     esi,3           ;U - point to last src dword
        sub     edi,3           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      CopyUnwindDown  ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

;------------------------------------------------------------------

        align   @WordSize
UnwindDownVec   dd      UnwindDown7, UnwindDown6, UnwindDown5, UnwindDown4
                dd      UnwindDown3, UnwindDown2, UnwindDown1, UnwindDown0

UnwindDown7:
        mov     eax,[esi+ecx*4+28] ;U - get dword from source
                                   ;V - spare
        mov     [edi+ecx*4+28],eax ;U - put dword into destination
UnwindDown6:
        mov     eax,[esi+ecx*4+24] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+24],eax ;U - put dword into destination
UnwindDown5:
        mov     eax,[esi+ecx*4+20] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+20],eax ;U - put dword into destination
UnwindDown4:
        mov     eax,[esi+ecx*4+16] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+16],eax ;U - put dword into destination
UnwindDown3:
        mov     eax,[esi+ecx*4+12] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+12],eax ;U - put dword into destination
UnwindDown2:
        mov     eax,[esi+ecx*4+8] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+8],eax ;U - put dword into destination
UnwindDown1:
        mov     eax,[esi+ecx*4+4] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4+4],eax ;U - put dword into destination

        lea     eax,[ecx*4]     ;V - compute update for pointer

        add     esi,eax         ;U - update source pointer
        add     edi,eax         ;V - update destination pointer
UnwindDown0:
        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

;-----------------------------------------------------------------------------

        align   @WordSize
TrailDownVec    dd      TrailDown0, TrailDown1, TrailDown2, TrailDown3

        align   @WordSize
TrailDown0:
        mov     eax,[dst]       ;U - return pointer to destination
                                ;V - spare
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown1:
        mov     al,[esi+3]      ;U - get byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put byte in destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown2:
        mov     al,[esi+3]      ;U - get first byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put first byte into destination
        mov     al,[esi+2]      ;V - get second byte from source
        mov     [edi+2],al      ;U - put second byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown3:
        mov     al,[esi+3]      ;U - get first byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put first byte into destination
        mov     al,[esi+2]      ;V - get second byte from source
        mov     [edi+2],al      ;U - put second byte into destination
        mov     al,[esi+1]      ;V - get third byte from source
        mov     [edi+1],al      ;U - put third byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

_MEM_   endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strcmp.asm ===
page	,132
	title	strcmp.asm - compare two strings
;***
;strcmp.asm - routine to compare two strings (for equal, less, or greater)
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	STRCMP compares two strings and returns an integer
;	to indicate whether the first is less than the second, the two are
;	equal, or whether the first is greater than the second, respectively.
;	Comparison is done byte by byte on an UNSIGNED basis, which is to
;	say that Null (0) is less than any other character (1-255).
;
;Revision History:
;	04-21-87  SKS	Module rewritten to be fast and small
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	Minor 386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	05-26-93  GJF	Tuned for the 486.
;	06-14-93  GJF	Testing wrong byte of ax against 0 in one case.
;	06-16-93  GJF	Added .FPO directive.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;strcmp - compare two strings, returning less than, equal to, or greater than
;
;Purpose:
;	Compares two string, determining their lexical order.  Unsigned
;	comparison is used.
;
;	Algorithm:
;	   int strcmp ( src , dst )
;		   unsigned char *src;
;		   unsigned char *dst;
;	   {
;		   int ret = 0 ;
;
;		   while( ! (ret = *src - *dst) && *dst)
;			   ++src, ++dst;
;
;		   if ( ret < 0 )
;			   ret = -1 ;
;		   else if ( ret > 0 )
;			   ret = 1 ;
;
;		   return( ret );
;	   }
;
;Entry:
;	const char * src - string for left-hand side of comparison
;	const char * dst - string for right-hand side of comparison
;
;Exit:
;	AX < 0, 0, or >0, indicating whether the first string is
;	Less than, Equal to, or Greater than the second string.
;
;Uses:
;	CX, DX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strcmp
strcmp	proc

	.FPO	( 0, 2, 0, 0, 0, 0 )

	mov	edx,[esp + 4]	; edx = src
	mov	ecx,[esp + 8]	; ecx = dst

	test	edx,3
	jnz	short dopartial

	align	4
dodwords:
	mov	eax,[edx]

	cmp	al,[ecx]
	jne	short donene
	or	al,al
	jz	short doneeq
	cmp	ah,[ecx + 1]
	jne	short donene
	or	ah,ah
	jz	short doneeq

	shr	eax,16

	cmp	al,[ecx + 2]
	jne	short donene
	or	al,al
	jz	short doneeq
	cmp	ah,[ecx + 3]
	jne	short donene
	add	ecx,4
	add	edx,4
	or	ah,ah
	jnz	short dodwords

	align	4
doneeq:
	xor	eax,eax
	ret

	align	4
donene:
	; The instructions below should place -1 in eax if src < dst,
	; and 1 in eax if src > dst.

	sbb	eax,eax
	sal	eax,1
	inc	eax
	ret

	align	4
dopartial:
	test	edx,1
	jz	short doword

	mov	al,[edx]
	inc	edx
	cmp	al,[ecx]
	jne	short donene
	inc	ecx
	or	al,al
	jz	short doneeq

	test	edx,2
	jz	short dodwords


	align	4
doword:
	mov	ax,[edx]
	add	edx,2
	cmp	al,[ecx]
	jne	short donene
	or	al,al
	jz	short doneeq
	cmp	ah,[ecx + 1]
	jne	short donene
	or	ah,ah
	jz	short doneeq
	add	ecx,2
	jmp	short dodwords

strcmp	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strchr.asm ===
page    ,132
        title   strchr - search string for given character
;***
;strchr.asm - search a string for a given character
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strchr() - search a string for a character
;
;Revision History:
;       10-27-83  RN    initial version
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   386 cleanup
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;	09-08-94  GJF	Smaller and faster.
;       11-28-95  GJF   Much faster version from Intel.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strchr(string, chr) - search a string for a character
;
;Purpose:
;       Searches a string for a given character, which may be the
;       null character '\0'.
;
;       Algorithm:
;       char *
;       strchr (string, chr)
;       char *string, chr;
;       {
;         while (*string && *string != chr)
;             string++;
;         if (*string == chr)
;             return(string);
;         return((char *)0);
;       }
;
;Entry:
;       char *string - string to search in
;       char chr     - character to search for
;
;Exit:
;       returns pointer to the first occurence of c in string
;       returns NULL if chr does not occur in string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

found_bx:
        lea     eax,[edx - 1]
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

        align   16
        public  strchr, __from_strstr_to_strchr
strchr  proc

	.FPO	( 0, 2, 0, 0, 0, 0 )

        xor     eax,eax
        mov     al,[esp + 8]        ; al = chr (search char)

__from_strstr_to_strchr label proc

        push    ebx                 ; PRESERVE EBX
        mov     ebx,eax             ; ebx = 0/0/0/chr
        shl     eax,8               ; eax = 0/0/chr/0
        mov     edx,[esp + 8]       ; edx = buffer
        test    edx,3               ; test if string is aligned on 32 bits
        jz      short main_loop_start

str_misaligned:                     ; simple byte loop until string is aligned
        mov     cl,[edx]
        inc     edx
        cmp     cl,bl
        je      short found_bx
        test    cl,cl
        jz      short retnull_bx
        test    edx,3               ; now aligned ?
        jne     short str_misaligned

main_loop_start:                    ; set all 4 bytes of ebx to [chr]
        or      ebx,eax             ; ebx = 0/0/chr/chr
        push    edi                 ; PRESERVE EDI
        mov     eax,ebx             ; eax = 0/0/chr/chr
        shl     ebx,10h             ; ebx = chr/chr/0/0
        push    esi                 ; PRESERVE ESI
        or      ebx,eax             ; ebx = all 4 bytes = [chr]

; in the main loop (below), we are looking for chr or for EOS (end of string)

main_loop:
        mov     ecx,[edx]           ; read  dword (4 bytes)
        mov     edi,7efefeffh       ; work with edi & ecx for looking for chr

        mov     eax,ecx             ; eax = dword
        mov     esi,edi             ; work with esi & eax for looking for EOS

        xor     ecx,ebx             ; eax = dword xor chr/chr/chr/chr
        add     esi,eax

        add     edi,ecx
        xor     ecx,-1

        xor     eax,-1
        xor     ecx,edi

        xor     eax,esi
        add     edx,4

        and     ecx,81010100h       ; test for chr
        jnz     short chr_is_found  ; chr probably has been found

        ; chr was not found, check for EOS

        and     eax,81010100h       ; is any flag set ??
        jz      short main_loop     ; EOS was not found, go get another dword

        and     eax,01010100h       ; is it in high byte?
        jnz     short retnull       ; no, definitely found EOS, return failure

        and     esi,80000000h       ; check was high byte 0 or 80h
        jnz     short main_loop     ; it just was 80h in high byte, go get 
                                    ; another dword
retnull:
        pop     esi
        pop     edi
retnull_bx:
        pop     ebx
        xor     eax,eax
        ret                         ; _cdecl return

chr_is_found:
        mov     eax,[edx - 4]       ; let's look one more time on this dword
        cmp     al,bl               ; is chr in byte 0?
        je      short byte_0
        test    al,al               ; test if low byte is 0
        je      retnull
        cmp     ah,bl               ; is it byte 1
        je      short byte_1
        test    ah,ah               ; found EOS ?
        je      retnull
        shr     eax,10h             ; is it byte 2
        cmp     al,bl
        je      short byte_2
        test    al,al               ; if in al some bits were set, bl!=bh
        je      retnull
        cmp     ah,bl
        je      short byte_3
        test    ah,ah
        jz      retnull
        jmp     short main_loop     ; neither chr nor EOS found, go get
                                    ; another dword
byte_3:
        pop     esi
        pop     edi
        lea     eax,[edx - 1]
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

byte_2:
        lea     eax,[edx - 2]
        pop     esi
        pop     edi
        pop     ebx
        ret                         ; _cdecl return

byte_1:
        lea     eax,[edx - 3]
        pop     esi
        pop     edi
        pop     ebx
        ret                         ; _cdecl return

byte_0:
        lea     eax,[edx - 4]
        pop     esi                 ; restore esi
        pop     edi                 ; restore edi
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

strchr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strcat.asm ===
page	,132
	title	strcat - concatenate (append) one string to another
;***
;strcat.asm - contains strcat() and strcpy() routines
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	STRCAT concatenates (appends) a copy of the source string to the
;	end of the destination string, returning the destination string.
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	07-27-88  SJM	Rewritten to be 386-specific and to include strcpy
;	08-29-88  JCR	386 cleanup...
;	10-07-88  JCR	Correct off-by-1 strcat bug; optimize ecx=-1
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	04-23-93  GJF	Tuned for the 486.
;	04-30-93  GJF	If (4*K + 1)-st char was null, didn't copy/cat it
;			it properly.
;	06-16-93  GJF	Added .FPO directive.
;	05-01-95  GJF	New, faster version from Intel!
;       11-13-95  GJF   Aligned strcat on paragraph boundary.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list


page
;***
;char *strcat(dst, src) - concatenate (append) one string to another
;
;Purpose:
;	Concatenates src onto the end of dest.	Assumes enough
;	space in dest.
;
;	Algorithm:
;	char * strcat (char * dst, char * src)
;	{
;	    char * cp = dst;
;
;	    while( *cp )
;		    ++cp;	    /* Find end of dst */
;	    while( *cp++ = *src++ )
;		    ;		    /* Copy src to end of dst */
;	    return( dst );
;	}
;
;Entry:
;	char *dst - string to which "src" is to be appended
;	const char *src - string to be appended to the end of "dst"
;
;Exit:
;	The address of "dst" in EAX
;
;Uses:
;	EAX, ECX
;
;Exceptions:
;
;*******************************************************************************

page
;***
;char *strcpy(dst, src) - copy one string over another
;
;Purpose:
;	Copies the string src into the spot specified by
;	dest; assumes enough room.
;
;	Algorithm:
;	char * strcpy (char * dst, char * src)
;	{
;	    char * cp = dst;
;
;	    while( *cp++ = *src++ )
;		    ;		    /* Copy src over dst */
;	    return( dst );
;	}
;
;Entry:
;	char * dst - string over which "src" is to be copied
;	const char * src - string to be copied over "dst"
;
;Exit:
;	The address of "dst" in EAX
;
;Uses:
;	EAX, ECX
;
;Exceptions:
;*******************************************************************************

 
	CODESEG

%	public	strcat, strcpy	    ; make both functions available
strcpy	proc
	push	edi		    ; preserve edi
	mov	edi,[esp+8]	    ; edi points to dest string
	jmp	short copy_start

strcpy	endp

	align	16

strcat	proc
 
	.FPO	( 0, 2, 0, 0, 0, 0 )
 
	mov	ecx,[esp+4]	    ; ecx -> dest string
	push	edi		    ; preserve edi
	test	ecx,3		    ; test if string is aligned on 32 bits
	je	short find_end_of_dest_string_loop
 
dest_misaligned:		    ; simple byte loop until string is aligned
	mov	al,byte ptr [ecx]
	inc	ecx
	test	al,al
	je	short start_byte_3
	test	ecx,3
	jne	short dest_misaligned
 
	align	4
 
find_end_of_dest_string_loop:
	mov	eax,dword ptr [ecx] ; read 4 bytes
	mov	edx,7efefeffh
	add	edx,eax
	xor	eax,-1
	xor	eax,edx
	add	ecx,4
	test	eax,81010100h
	je	short find_end_of_dest_string_loop
	; found zero byte in the loop
	mov	eax,[ecx - 4]
	test	al,al		    ; is it byte 0
	je	short start_byte_0
	test	ah,ah		    ; is it byte 1
	je	short start_byte_1
	test	eax,00ff0000h	    ; is it byte 2
	je	short start_byte_2
	test	eax,0ff000000h	    ; is it byte 3
	je	short start_byte_3
	jmp	short find_end_of_dest_string_loop
				    ; taken if bits 24-30 are clear and bit
				    ; 31 is set
start_byte_3:
	lea	edi,[ecx - 1]
	jmp	short copy_start
start_byte_2:
	lea	edi,[ecx - 2]
	jmp	short copy_start
start_byte_1:
	lea	edi,[ecx - 3]
	jmp	short copy_start
start_byte_0:
	lea	edi,[ecx - 4]
;	jmp	short copy_start
 
;	edi points to the end of dest string.
copy_start::
	mov	ecx,[esp+0ch]	    ; ecx -> sorc string
	test	ecx,3		    ; test if string is aligned on 32 bits
	je	short main_loop_entrance
 
src_misaligned: 		    ; simple byte loop until string is aligned
	mov	dl,byte ptr [ecx]
	inc	ecx
	test	dl,dl
	je	short byte_0
	mov	[edi],dl
	inc	edi
	test	ecx,3
	jne	short src_misaligned
	jmp	short main_loop_entrance
 
main_loop:			    ; edx contains first dword of sorc string
	mov	[edi],edx	    ; store one more dword
	add	edi,4		    ; kick dest pointer
main_loop_entrance:
	mov	edx,7efefeffh
	mov	eax,dword ptr [ecx] ; read 4 bytes
 
	add	edx,eax
	xor	eax,-1
 
	xor	eax,edx
	mov	edx,[ecx]	    ; it's in cache now
 
	add	ecx,4		    ; kick dest pointer
	test	eax,81010100h
 
	je	short main_loop
	; found zero byte in the loop
; main_loop_end:
	test	dl,dl		    ; is it byte 0
	je	short byte_0
	test	dh,dh		    ; is it byte 1
	je	short byte_1
	test	edx,00ff0000h	    ; is it byte 2
	je	short byte_2
	test	edx,0ff000000h	    ; is it byte 3
	je	short byte_3
	jmp	short main_loop	    ; taken if bits 24-30 are clear and bit
				    ; 31 is set
byte_3:
	mov	[edi],edx
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	pop	edi
	ret
byte_2:
	mov	[edi],dx
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	mov	byte ptr [edi+2],0
	pop	edi
	ret
byte_1:
	mov	[edi],dx
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	pop	edi
	ret
byte_0:
	mov	[edi],dl
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	pop	edi
	ret
 
strcat	endp
 
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strlen.asm ===
page	,132
	title	strlen - return the length of a null-terminated string
;***
;strlen.asm - contains strlen() routine
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	strlen returns the length of a null-terminated string,
;	not including the null byte itself.
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-02-88  SJM	Add 32 bit code, use cruntime vs cmacros
;	08-23-88  JCR	386 cleanup
;	10-05-88  GJF	Fixed off-by-2 error.
;	10-10-88  JCR	Minor improvement
;	10-25-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	04-23-93  GJF	Tuned for the 486.
;	06-16-93  GJF	Added .FPO directive.
;	11-28-94  GJF	New, faster version from Intel.
;       11-28-95  GJF   Align main_loop on para boundary for 486 and P6
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;strlen - return the length of a null-terminated string
;
;Purpose:
;	Finds the length in bytes of the given string, not including
;	the final null character.
;
;	Algorithm:
;	int strlen (const char * str)
;	{
;	    int length = 0;
;
;	    while( *str++ )
;		    ++length;
;
;	    return( length );
;	}
;
;Entry:
;	const char * str - string whose length is to be computed
;
;Exit:
;	EAX = length of the string "str", exclusive of the final null byte
;
;Uses:
;	EAX, ECX, EDX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strlen

strlen	proc

	.FPO	( 0, 1, 0, 0, 0, 0 )
 
string  equ     [esp + 4]
 
        mov     ecx,string              ; ecx -> string
        test    ecx,3                   ; test if string is aligned on 32 bits
        je      short main_loop
 
str_misaligned:
        ; simple byte loop until string is aligned
        mov     al,byte ptr [ecx]
        inc     ecx
        test    al,al
        je      short byte_3
        test    ecx,3
        jne     short str_misaligned

	add	eax,dword ptr 0         ; 5 byte nop to align label below

	align	16                      ; should be redundant
 
main_loop:
        mov     eax,dword ptr [ecx]     ; read 4 bytes
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     ecx,4
        test    eax,81010100h
        je      short main_loop
        ; found zero byte in the loop
        mov     eax,[ecx - 4]
        test    al,al                   ; is it byte 0
        je      short byte_0
        test    ah,ah                   ; is it byte 1
        je      short byte_1
        test    eax,00ff0000h           ; is it byte 2
        je      short byte_2
	test	eax,0ff000000h		; is it byte 3
        je      short byte_3
	jmp	short main_loop 	; taken if bits 24-30 are clear and bit
                                        ; 31 is set
 
byte_3:
        lea     eax,[ecx - 1]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_2:
        lea     eax,[ecx - 2]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_1:
        lea     eax,[ecx - 3]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_0:
        lea     eax,[ecx - 4]
        mov     ecx,string
        sub     eax,ecx
        ret
 
strlen  endp
 
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strcspn.asm ===
;***
;strcspn.asm -
;
;	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines strcspn()- finds the length of the initial substring of
;	a string consisting entirely of characters not in a control string.
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

SSTRCSPN EQU 1
INCLUDE I386\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strncat.asm ===
page    ,132
        title   strncat - append n chars of string1 to string2
;***
;strncat.asm - append n chars of string to new string
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strncat() - appends n characters of string onto
;       end of other string
;
;Revision History:
;       10-25-83  RN    initial version
;       08-05-87  SKS   Fixed bug: extra null was stored if n > strlen(back)
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   Minor 386 cleanup
;       10-26-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       12-15-96  GJF   Faster version from Intel.
;       12-19-96  GJF   Fixed bugs in Intel code
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strncat(front, back, count) - append count chars of back onto front
;
;Purpose:
;       Appends at most count characters of the string back onto the
;       end of front, and ALWAYS terminates with a null character.
;       If count is greater than the length of back, the length of back
;       is used instead.  (Unlike strncpy, this routine does not pad out
;       to count characters).
;
;       Algorithm:
;       char *
;       strncat (front, back, count)
;           char *front, *back;
;           unsigned count;
;       {
;           char *start = front;
;
;           while (*front++)
;               ;
;           front--;
;           while (count--)
;               if (!(*front++ = *back++))
;                   return(start);
;           *front = '\0';
;           return(start);
;       }
;
;Entry:
;       char *   front - string to append onto
;       char *   back  - string to append
;       unsigned count - count of max characters to append
;
;Exit:
;       returns a pointer to string appended onto (front).
;
;Uses:  ECX, EDX
;
;Exceptions:
;
;*******************************************************************************

    CODESEG

    public  strncat
strncat proc
;   front:ptr byte,
;   back:ptr byte,
;   count:IWORD

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     ecx,[esp + 0ch]     ; ecx = count
        push    edi                 ; preserve edi
        test    ecx,ecx
        jz      finish              ; leave if count is zero

        mov     edi,[esp + 8]       ; edi -> front string
        push    esi                 ; preserve esi
        test    edi,3               ; is string aligned on dword (4 bytes)
        push    ebx                 ; preserve ebx
        je      short find_end_of_front_string_loop

        ; simple byte loop until string is aligned

front_misaligned:
        mov     al,byte ptr [edi]
        inc     edi
        test    al,al
        je      short start_byte_3
        test    edi,3
        jne     short front_misaligned

find_end_of_front_string_loop:
        mov     eax,dword ptr [edi] ; read dword (4 bytes)
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     edi,4
        test    eax,81010100h
        je      short find_end_of_front_string_loop

; found zero byte in the loop
        mov     eax,[edi - 4]
        test    al,al               ; is it byte 0
        je      short start_byte_0
        test    ah,ah               ; is it byte 1
        je      short start_byte_1
        test    eax,00ff0000h       ; is it byte 2
        je      short start_byte_2
        test    eax,0ff000000h      ; is it byte 3
        jne     short find_end_of_front_string_loop
                                    ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
start_byte_3:
        dec     edi
        jmp     short copy_start
start_byte_2:
        sub     edi,2
        jmp     short copy_start
start_byte_1:
        sub     edi,3
        jmp     short copy_start
start_byte_0:
        sub     edi,4

; edi now points to the end of front string.

copy_start:
        mov     esi,[esp + 14h]     ; esi -> back string
        test    esi,3               ; is back string is dword aligned?
        jnz     back_misaligned

        mov     ebx,ecx             ; store count for tail loop

        shr     ecx,2
        jnz     short main_loop_entrance
        jmp     short tail_loop_start   ; 0 < counter < 4

; simple byte loop until back string is aligned

back_misaligned:
        mov     dl,byte ptr [esi]
        inc     esi
        test    dl,dl
        je      short byte_0
        mov     [edi],dl
        inc     edi
        dec     ecx
        jz      empty_counter
        test    esi,3
        jne     short back_misaligned
        mov     ebx,ecx             ; store count for tail loop
        shr     ecx,2               ; convert ecx to dword count
        jnz     short main_loop_entrance

tail_loop_start:
        mov     ecx,ebx 
        and     ecx,3               ; ecx = count of leftover bytes after the
                                    ; dwords have been concatenated
        jz      empty_counter

tail_loop:
        mov     dl,byte ptr [esi]
        inc     esi
        mov     [edi],dl
        inc     edi
        test    dl,dl
        je      short finish1       ; '\0' was already copied
        dec     ecx
        jnz     tail_loop

empty_counter:
        mov     [edi],cl            ; cl=0;
finish1:
        pop     ebx
        pop     esi
finish:
        mov     eax,[esp + 8]       ; return in eax pointer to front string
        pop     edi
        ret                         ; _cdecl return


byte_0:
        mov     [edi],dl
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return


main_loop:                          ; edx contains first dword of back string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick pointer to front string

        dec     ecx
        jz      tail_loop_start
main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [esi] ; read 4 bytes

        add     edx,eax
        xor     eax,-1

        xor     eax,edx
        mov     edx,[esi]           ; it's in cache now

        add     esi,4               ; kick pointer to back string
        test    eax,81010100h

        je      short main_loop

; may be found zero byte in the loop
        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        jne short main_loop         ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
byte_3:
        mov     [edi],edx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

byte_2:
        mov     [edi],dx
        xor     edx,edx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        mov     [edi + 2],dl
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

byte_1:
        mov     [edi],dx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

strncat endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strncmp.asm ===
page	,132
	title	strncmp - compare first n chars of two strings
;***
;strncmp.asm - compare first n characters of two strings
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strncmp() - compare first n characters of two strings
;	for lexical order.
;
;Revision History:
;	10-26-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int strncmp(first, last, count) - compare first count chars of strings
;
;Purpose:
;	Compares two strings for lexical order.  The comparison stops
;	after: (1) a difference between the strings is found, (2) the end
;	of the strings is reached, or (3) count characters have been
;	compared.
;
;	Algorithm:
;	int
;	strncmp (first, last, count)
;	      char *first, *last;
;	      unsigned count;
;	      {
;	      if (!count)
;		      return(0);
;	      while (--count && *first && *first == *last)
;		      {
;		      first++;
;		      last++;
;		      }
;	      return(*first - *last);
;	      }
;
;Entry:
;	char *first, *last - strings to compare
;	unsigned count - maximum number of characters to compare
;
;Exit:
;	returns <0 if first < last
;	returns 0 if first == last
;	returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strncmp
strncmp proc \
	uses edi esi ebx, \
	first:ptr byte, \
	last:ptr byte, \
	count:IWORD


	mov	ecx,[count]	; cx=max number of bytes to compare
	jecxz	short toend	; it's as if strings are equal

	mov	ebx,ecx 	; bx saves count

	mov	edi,[first]	; di=first pointer (es=segment part)

	mov	esi,edi 	; si saves first pointer
	xor	eax,eax 	; ax=0
repne	scasb			; count bytes
	neg	ecx		; cx=count - strlen
	add	ecx,ebx 	; strlen + count - strlen

okay:
	mov	edi,esi 	; restore first pointer
	mov	esi,[last]	; si = last pointer
repe	cmpsb			; compare strings
	mov	al,[esi-1]
	xor	ecx,ecx 	; set return value = 0

	cmp	al,[edi-1]	; last-first
	ja	short lastbig	; <last is bigger>
	je	short toend	; <equal>
	;jb	short firstbig	; <first is bigger>

firstbig:
	dec	ecx		; first string is bigger
	dec	ecx		; make FFFE so 'not' will give 0001

lastbig:			; last string is bigger
	not	ecx		; return -1

toend:
	mov	eax,ecx 	; return value

ifdef	_STDCALL_
	ret	2*DPSIZE + ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

strncmp endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strncpy.asm ===
page    ,132
        title   strncpy - copy at most n characters of string
;***
;strncpy.asm - copy at most n characters of string
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strncpy() - copy at most n characters of string
;
;Revision History:
;       10-25-83  RN    initial version
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   386 cleanup
;       10-26-88  JCR   General cleanup for 386-only code
;       10-26-88  JCR   Re-arrange regs to avoid push/pop ebx
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       12-20-96  GJF   Faster version from Intel.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strncpy(dest, source, count) - copy at most n characters
;
;Purpose:
;       Copies count characters from the source string to the
;       destination.  If count is less than the length of source,
;       NO NULL CHARACTER is put onto the end of the copied string.
;       If count is greater than the length of sources, dest is padded
;       with null characters to length count.
;
;       Algorithm:
;       char *
;       strncpy (dest, source, count)
;       char *dest, *source;
;       unsigned count;
;       {
;         char *start = dest;
;
;         while (count && (*dest++ = *source++))
;             count--;
;         if (count)
;             while (--count)
;                 *dest++ = '\0';
;         return(start);
;       }
;
;Entry:
;       char *dest     - pointer to spot to copy source, enough space
;                        is assumed.
;       char *source   - source string for copy
;       unsigned count - characters to copy
;
;Exit:
;       returns dest, with the character copied there.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  strncpy
strncpy proc

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     ecx,[esp + 0ch]     ; ecx = count
        push    edi                 ; preserve edi
        test    ecx,ecx         
        jz      short finish        ; leave if count is zero

        push    esi                 ; preserve edi
        push    ebx                 ; preserve ebx
        mov     ebx,ecx             ; store count for tail loop
        mov     esi,[esp + 14h]     ; esi -> source string
        test    esi,3               ; test if source string is aligned on 32 bits
        mov     edi,[esp + 10h]     ; edi -> dest string
        jnz     short src_misaligned    ; (almost always source is aligned)

        shr     ecx,2               ; convert ecx to dword count
        jnz     short main_loop_entrance
        jmp     short copy_tail_loop    ; 0 < count < 4

; simple byte loop until string is aligned

src_misaligned:
        mov     al,byte ptr [esi]   ; copy a byte from source to dest
        inc     esi
        mov     [edi],al
        inc     edi
        dec     ecx
        jz      fill_tail_end1      ; if count == 0, leave
        test    al,al               ; was last copied byte zero?
        jz      short align_dest    ; if so, go align dest and pad it out
                                    ; with zeros
        test    esi,3               ; esi already aligned ?
        jne     short src_misaligned
        mov     ebx,ecx             ; store count for tail loop
        shr     ecx,2
        jnz     short main_loop_entrance

tail_loop_start:
        and     ebx,3               ; ebx = count_before_main_loop%4
        jz      short fill_tail_end1    ; if ebx == 0 then leave without
                                        ; appending a null byte

; while ( EOS (end-of-string) not found and count > 0 ) copy bytes

copy_tail_loop:
        mov     al,byte ptr [esi]   ; load byte from source
        inc     esi
        mov     [edi],al            ; store byte to dest
        inc     edi
        test    al,al               ; EOS found?
        je      short fill_tail_zero_bytes  ; '\0' was already copied
        dec     ebx
        jnz     copy_tail_loop
fill_tail_end1:
        mov     eax,[esp + 10h]     ; prepare return value
        pop     ebx
        pop     esi
        pop     edi
        ret

; EOS found. Pad with null characters to length count

align_dest:
        test    edi,3               ; dest string aligned?
        jz      dest_align_loop_end
dest_align_loop:
        mov     [edi],al
        inc     edi
        dec     ecx                 ; count == 0?
        jz      fill_tail_end       ; if so, finished
        test    edi,3               ; is edi aligned ?
        jnz     dest_align_loop
dest_align_loop_end:
        mov     ebx,ecx             ; ebx > 0
        shr     ecx,2               ; convert ecx to count of dwords
        jnz     fill_dwords_with_EOS
        ; pad tail bytes
finish_loop:                        ; 0 < ebx < 4
        mov     [edi],al
        inc     edi
fill_tail_zero_bytes:
        dec     ebx
        jnz     finish_loop
        pop     ebx
        pop     esi
finish:
        mov     eax,[esp + 8]       ; return in eax pointer to dest string
        pop     edi
        ret

; copy (source) string to (dest). Also look for end of (source) string

main_loop:                          ; edx contains first dword of source string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick dest pointer
        dec     ecx
        jz      tail_loop_start

main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [esi] ; read 4 bytes (dword)
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        mov     edx,[esi]           ; it's in cache now
        add     esi,4               ; kick dest pointer
        test    eax,81010100h
        je      short main_loop

        ; may have found zero byte in the dword

        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        jne     short main_loop     ; taken if bits 24-30 are clear and bit
                                    ; 31 is set

; a null character was found, so dest needs to be padded out with null chars
; to count length.

        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_2:
        and     edx,0ffffh          ; fill high 2 bytes with 0
        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_1:
        and     edx,0ffh            ; fill high 3 bytes with 0
        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_0:
        xor     edx,edx             ; fill whole dword with 0
        mov     [edi],edx

; End of string was found. Pad out dest string with dwords of 0

fill_with_EOS_dwords:               ; ecx > 0   (ecx is dword counter)
        add     edi,4
        xor     eax,eax             ; it is instead of ???????????????????
        dec     ecx
        jz      fill_tail           ; we filled all dwords

fill_dwords_with_EOS:
        xor     eax,eax
fill_with_EOS_loop:
        mov     [edi],eax
        add     edi,4
        dec     ecx
        jnz     short fill_with_EOS_loop
fill_tail:                          ; let's pad tail bytes with zero
        and     ebx,3               ; ebx = ebx % 4
        jnz     short finish_loop   ; taken, when there are some tail bytes
fill_tail_end:
        mov     eax,[esp + 10h]
        pop     ebx
        pop     esi
        pop     edi
        ret

strncpy endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strpbrk.asm ===
;***
;strpbrk.asm -
;
;	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines strpbrk()- finds the index of the first character in a string
;	that is not in a control string
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

SSTRPBRK EQU 1
INCLUDE I386\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strset.asm ===
page	,132
	title	strset - set all characters of string to character
;***
;strset.asm - sets all charcaters of string to given character
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strset() - sets all of the characters in a string (except
;	the '\0') equal to a given character.
;
;Revision History:
;	11-18-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strset(string, val) - sets all of string to val
;
;Purpose:
;	Sets all of characters in string (except the terminating '/0'
;	character) equal to val.
;
;	Algorithm:
;	char *
;	_strset (string, val)
;	      char *string;
;	      char val;
;	      {
;	      char *start = string;
;
;	      while (*string)
;		      *string++ = val;
;	      return(start);
;	      }
;
;Entry:
;	char *string - string to modify
;	char val - value to fill string with
;
;Exit:
;	returns string -- now filled with val's
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strset
_strset proc \
	uses edi, \
	string:ptr byte, \
	val:byte


	mov	edi,[string]	; di = string
	mov	edx,edi 	; dx=string addr; save return value

	xor	eax,eax 	; ax = 0
	or	ecx,-1		; cx = -1
repne	scasb			; scan string & count bytes
	inc	ecx
	inc	ecx		; cx=-strlen
	neg	ecx		; cx=strlen
	mov	al,[val]	; al = byte value to store
	mov	edi,edx 	; di=string addr
rep	stosb

	mov	eax,edx 	; return value: string addr

ifdef	_STDCALL_
	ret	DPSIZE + ISIZE	; _stdcall return
else
	ret			; _cdecl return
endif

_strset endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strrev.asm ===
page	,132
	title	strrev - reverse a string in place
;***
;strrev.asm - reverse a string in place
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strrev() - reverse a string in place (not including
;	'\0' character)
;
;Revision History:
;	10-26-83  RN	initial version
;	07-16-87  JCR	Added check for empty string (fixes large model bug)
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup, minor alterations
;	10-26-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strrev(string) - reverse a string in place
;
;Purpose:
;	Reverses the order of characters in the string.  The terminating
;	null character remains in place.
;
;	Algorithm:
;	char *
;	_strrev (string)
;	      char *string;
;	      {
;	      char *start = string;
;	      char *left = string;
;	      char ch;
;
;	      while (*string++)
;		      ;
;	      string -= 2;
;	      while (left < string)
;		      {
;		      ch = *left;
;		      *left++ = *string;
;		      *string-- = ch;
;		      }
;	      return(start);
;	      }
;
;	NOTE: There is a check for an empty string in the following code.
;	Normally, this would fall out of the "cmp si,di" instruction in the
;	loop portion of the routine.  However, if the offset of the empty
;	string is 0 (as it could be in large model), then the cmp does not
;	catch the empty string and the routine essentially hangs (i.e., loops
;	moving bytes one at a time FFFFh times).  An explicit empty string
;	check corrects this.
;
;Entry:
;	char *string - string to reverse
;
;Exit:
;	returns string - now with reversed characters
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strrev
_strrev proc \
	uses edi esi, \
	string:ptr byte

	mov	edi,[string]	; di = string
	mov	edx,edi 	; dx=pointer to string; save return value

	mov	esi,edi 	; si=pointer to string
	xor	eax,eax 	; search value (null)
	or	ecx,-1		; cx = -1
repne	scasb			; find null
	cmp	ecx,-2		; is string empty? (if offset value is 0, the
	je	short done	; cmp below will not catch it and we'll hang).

	dec	edi		; string is not empty, move di pointer back
	dec	edi		; di points to last non-null byte

lupe:
	cmp	esi,edi 	; see if pointers have crossed yet
	jae	short done	; exit when pointers meet (or cross)

	mov	ah,[esi]	; get front byte...
	mov	al,[edi]	;   and end byte
	mov	[esi],al	; put end byte in front...
	mov	[edi],ah	;   and front byte at end
	inc	esi		; front moves up...
	dec	edi		;   and end moves down
	jmp	short lupe	; keep switching bytes

done:
	mov	eax,edx 	; return value: string addr

ifdef	_STDCALL_
	ret	DPSIZE		; _stdcall return
else
	ret			; _cdecl return
endif

_strrev endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strnset.asm ===
page	,132
	title	strnset - set first n characters to one char.
;***
;strnset.asm - set first n characters to single character
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strnset() - sets at most the first n characters of a string
;	to a given character.
;
;Revision History:
;	11-18-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	05-23-88  WAJ	If count = strlen(string)+1 then strlen+1 bytes were set.
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strnset(string, val, count) - set at most count characters to val
;
;Purpose:
;	Sets the first count characters of string the character value.
;	If the length of string is less than count, the length of
;	string is used in place of n.
;
;	Algorithm:
;	char *
;	_strnset (string, val, count)
;	      char *string,val;
;	      unsigned int count;
;	      {
;	      char *start = string;
;
;	      while (count-- && *string)
;		      *string++ = val;
;	      return(start);
;	      }
;
;Entry:
;	char *string - string to set characters in
;	char val - character to fill with
;	unsigned count - count of characters to fill
;
;Exit:
;	returns string, now filled with count copies of val.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strnset
_strnset proc \
	uses edi ebx, \
	string:ptr byte, \
	val:byte, \
	count:IWORD


	mov	edi,[string]	; di = string
	mov	edx,edi 	; dx=string addr; save return value
	mov	ebx,[count]	; cx = max chars to set
	xor	eax,eax 	; null byte
	mov	ecx,ebx
	jecxz	short done	; zero length specified

repne	scasb			; find null byte & count bytes in cx
	jne	short nonull	; null not found
	inc	ecx		; don't want the null

nonull:
	sub	ebx,ecx 	; bx=strlen (not null)
	mov	ecx,ebx 	; cx=strlen (not null)

	mov	edi,edx 	; restore string pointer
	mov	al,val		; byte value
rep	stosb			; fill 'er up

done:
	mov	eax,edx 	; return value: string addr

ifdef	_STDCALL_
	ret	DPSIZE + 2*ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

_strnset endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strstr.asm ===
page    ,132
        title   strstr - search for one string inside another
;***
;strstr.asm - search for one string inside another
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strstr() - search for one string inside another
;
;Revision History:
;       02-02-88  SKS   Rewritten from scratch.  Now works correctly with
;                       strings > 32 KB in length.  Also smaller and faster.
;       03-01-88  SKS   Ensure that ES = DS right away (Small/Medium models)
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-18-88  PHG   Corrected return value when src is empty string
;                       to conform with ANSI.
;       08-23-88  JCR   Minor 386 cleanup
;       10-26-88  JCR   General cleanup for 386-only code
;       03-26-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       12-19-94  GJF   Revised to improve performance a bit.
;       12-04-95  GJF   Much faster version from Intel.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strstr(str1, str2) - search for str2 in str1
;
;Purpose:
;       finds the first occurrence of str2 in str1
;
;Entry:
;       char *str1 - string to search in
;       char *str2 - string to search for
;
;Exit:
;       returns a pointer to the first occurrence of string2 in
;       string1, or NULL if string2 does not occur in string1
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


__from_strstr_to_strchr proto

        CODESEG

        public  strstr

strstr  proc

        mov     ecx,[esp + 8]       ; str2 (the string to be searched for)

        push    edi                 ; Preserve edi, ebx and esi
        push    ebx
        push    esi

        mov     dl,[ecx]            ; dl contains first char from str2

        mov     edi,[esp + 10h]     ; str1 (the string to be searched)

        test    dl,dl               ; is str2 empty?
        jz      empty_str2

        mov     dh,[ecx + 1]        ; second char from str2
        test    dh,dh               ; is str2 a one-character string?
        jz      strchr_call         ; if so, go use strchr code

; length of str2 is now known to be > 1 (used later)
; dl contains first char from str2
; dh contains second char from str2
; edi holds str1

findnext:
        mov     esi,edi             ; esi = edi = pointers to somewhere in str1
        mov     ecx,[esp + 14h]     ; str2

;use edi instead of esi to eliminate AGI
        mov     al,[edi]            ; al is next char from str1

        inc     esi                 ; increment pointer into str1

        cmp     al,dl
        je      first_char_found

        test    al,al               ; end of str1?    
        jz      not_found           ; yes, and no match has been found

loop_start:
        mov     al,[esi]            ; put next char from str1 into al
        inc     esi                 ; increment pointer in str1
in_loop:
        cmp     al,dl
        je      first_char_found

        test    al,al               ; end of str1?
        jnz     loop_start          ; no, go get another char from str1

not_found:
        pop     esi
        pop     ebx
        pop     edi
        xor     eax,eax
        ret

; recall that dh contains the second char from str2

first_char_found:
        mov     al,[esi]            ; put next char from str1 into al
        inc     esi

        cmp     al,dh               ; compare second chars
        jnz     in_loop             ; no match, continue search

two_first_chars_equal:
        lea     edi,[esi - 1]       ; store position of last read char in str1

compare_loop:
        mov     ah,[ecx + 2]        ; put next char from str2 into ah
        test    ah,ah               ; end of str2?
        jz      match               ; if so, then a match has been found

        mov     al,[esi]            ; get next char from str1
        add     esi,2               ; bump pointer into str1 by 2

        cmp     al,ah               ; are chars from str1 and str2 equal?
        jne     findnext            ; no

; do one more iteration

        mov     al,[ecx + 3]        ; put the next char from str2 into al
        test    al,al               ; end of str2
        jz      match               ; if so, then a match has been found

        mov     ah,[esi - 1]        ; get next char from str1 
        add     ecx,2               ; bump pointer in str1 by 2
        cmp     al,ah               ; are chars from str1 and str2 equal?
        je      compare_loop

; no match. test some more chars (to improve execution time for bad strings).

        jmp     findnext

; str2 string contains only one character so it's like the strchr functioin

strchr_call:
        xor     eax,eax
        pop     esi
        pop     ebx
        pop     edi
        mov     al,dl
        jmp     __from_strstr_to_strchr

;
;
; Match!  Return (ebx - 1)
;
match:
        lea     eax,[edi - 1]
        pop     esi
        pop     ebx
        pop     edi
        ret

empty_str2:           ; empty target string, return src (ANSI mandated)
        mov     eax,edi
        pop     esi
        pop     ebx
        pop     edi
        ret

strstr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strrchr.asm ===
page	,132
	title	strrchr - find last occurence of character in string
;***
;strrchr.asm - find last occurrence of character in string
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strrchr() - find the last occurrence of a given character
;	in a string.
;
;Revision History:
;	10-27-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *strrchr(string, ch) - find last occurrence of ch in string
;
;Purpose:
;	Finds the last occurrence of ch in string.  The terminating
;	null character is used as part of the search.
;
;	Algorithm:
;	char *
;	strrchr (string, ch)
;	      char *string, ch;
;	      {
;	      char *start = string;
;
;	      while (*string++)
;		      ;
;	      while (--string != start && *string != ch)
;		      ;
;	      if (*string == ch)
;		      return(string);
;	      return(NULL);
;	      }
;
;Entry:
;	char *string - string to search in
;	char ch - character to search for
;
;Exit:
;	returns a pointer to the last occurrence of ch in the given
;	string
;	returns NULL if ch does not occurr in the string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strrchr
strrchr proc \
	uses edi, \
	string:ptr byte, \
	chr:byte

	mov	edi,[string]	; di = string
	xor	eax,eax 	; al=null byte
	or	ecx,-1		; cx = -1
repne	scasb			; find the null & count bytes
	inc	ecx		; cx=-byte count (with null)
	neg	ecx		; cx=+byte count (with null)
	dec	edi		; di points to terminal null
	mov	al,chr		; al=search byte
	std			; count 'down' on string this time
repne	scasb			; find that byte
	inc	edi		; di points to byte which stopped scan

	cmp	[edi],al	; see if we have a hit
	je	short returndi	; yes, point to byte

	xor	eax,eax 	; no, return NULL
	jmp	short toend	; do return sequence

returndi:
	mov	eax,edi 	; ax=pointer to byte

toend:
	cld

ifdef	_STDCALL_
	ret	DPSIZE + ISIZE	; _stdcall return
else
	ret			; _cdecl return
endif

strrchr endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\strspn.asm ===
page	,132
	title	strspn - search for init substring of chars from control str
;***
;strspn.asm - find length of initial substring of chars from a control string
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strspn() - finds the length of the initial substring of
;	a string consisting entirely of characters from a control string.
;
;	defines strcspn()- finds the length of the initial substring of
;	a string consisting entirely of characters not in a control string.
;
;	defines strpbrk()- finds the index of the first character in a string
;	that is not in a control string
;
;Revision History:
;	10-28-83  RN	initial version
;	06-30-87  SKS	Faster version -- also reentrant
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-02-88  SJM	Created 386-specific version.
;	08-23-88  JCR	386 cleanup
;	10-10-88  JCR	Misc bug fixes
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	09-25-91  JCR	Build "strspn" if no other directives are given
;	01-17-92  GJF	Fixed build of "strspn".
;	01-17-95  GJF	Tuned.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int strspn(string, control) - find init substring of control chars
;
;Purpose:
;	Finds the index of the first character in string that does belong
;	to the set of characters specified by control.	This is
;	equivalent to the length of the initial substring of string that
;	consists entirely of characters from control.  The '\0' character
;	that terminates control is not considered in the matching process.
;
;	Algorithm:
;	int
;	strspn (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		if (*string)
;		{
;			while (map[*string >> 3] & (1 << (*string & 7)))
;			{
;				count++;
;				string++;
;			}
;			return(count);
;		}
;		return(0);
;	}
;
;Entry:
;	char *string - string to search
;	char *control - string containing characters not to search for
;
;Exit:
;	returns index of first char in string not in control
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;int strcspn(string, control) - search for init substring w/o control chars
;
;Purpose:
;	returns the index of the first character in string that belongs
;	to the set of characters specified by control.	This is equivalent
;	to the length of the length of the initial substring of string
;	composed entirely of characters not in control.  Null chars not
;	considered.
;
;	Algorithm:
;	int
;	strcspn (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		map[0] |= 1;
;		while (!(map[*string >> 3] & (1 << (*string & 7))))
;		{
;			count++;
;			string++;
;		}
;		return(count);
;	}
;
;Entry:
;	char *string - string to search
;	char *control - set of characters not allowed in init substring
;
;Exit:
;	returns the index of the first char in string
;	that is in the set of characters specified by control.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;char *strpbrk(string, control) - scans string for a character from control
;
;Purpose:
;	Finds the first occurence in string of any character from
;	the control string.
;
;	Algorithm:
;	char *
;	strpbrk (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		while (*string)
;		{
;			if (map[*string >> 3] & (1 << (*string & 7)))
;				return(string);
;			string++;
;		}
;		return(NULL);
;	}
;
;Entry:
;	char *string - string to search in
;	char *control - string containing characters to search for
;
;Exit:
;	returns a pointer to the first character from control found
;	in string.
;	returns NULL if string and control have no characters in common.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


ifdef SSTRCSPN

    _STRSPN_ equ <strcspn>

elseifdef SSTRPBRK

    _STRSPN_ equ <strpbrk>

else

; Default is to build strspn()

    SSTRSPN equ 1
    _STRSPN_ equ <strspn>

endif

% public  _STRSPN_

    CODESEG

_STRSPN_ proc \
	uses esi, \
	string:ptr byte, \
	control:ptr byte

; create and zero out char bit map

	xor	eax,eax
	push	eax		; 32
	push	eax
	push	eax
	push	eax		; 128
	push	eax
	push	eax
	push	eax
	push	eax		; 256

map	equ	[esp]

; Set control char bits in map

	mov	edx,control	; si = control string

	align	@WordSize
lab listnext			; init char bit map
	mov	al,[edx]
	or	al,al
	jz	short listdone
	inc	edx
	bts	map,eax
	jmp	short listnext

lab listdone

; Loop through comparing source string with control bits

	mov	esi,string	; si = string

_ifnd	SSTRPBRK <or	 ecx,-1> ; set ecx to -1

	align	@WordSize
lab dstnext

_ifnd	SSTRPBRK <inc	 ecx>

	mov	al,[esi]
	or	al,al
	jz	short dstdone
	inc	esi
	bt	map, eax

ifdef SSTRSPN
	jc	short dstnext	; strspn: found char, continue
elseifdef SSTRCSPN
	jnc	short dstnext	; strcspn: did not find char, continue
elseifdef SSTRPBRK
	jnc	short dstnext	; strpbrk: did not find char, continue
	lea	eax,[esi - 1]	; found char, return address of it
endif

; Return code

lab dstdone

_ifnd	SSTRPBRK <mov	eax,ecx> ; strspn/strcspn: return index

	add	esp,32

	ret			; _cdecl return

_STRSPN_ endp
	 end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\memcpy.s ===
#include "ksia64.h"

        LEAF_ENTRY(memcpy)
        .prologue
        .regstk     3,7,0,8
        alloc       t17 = ar.pfs,3,31,0,32
        .save       pr, r64
        mov         r64 = pr
        and         t3 = -32, a1
        ;;
        
        lfetch      [t3], 32        //0
        .save       ar.lc, r65
        mov.i       r65 = ar.lc 
        and         t1 = 7, a1
        ;;
        
        .body        
        lfetch      [t3], 32        //32
        mov         v0 = a0
        and         t0 = 7, a0
        ;;
        
        or          t2 = t0, t1
        cmp.eq      pt1 = zero, a2
 (pt1)  br.ret.spnt brp
        ;;
        

        lfetch      [t3], 32        //64
        cmp.lt      pt2 = 16, a2
        nop.b 	    0
        ;;
 
        lfetch      [t3], 32        //96 
        cmp.lt      pt6 = 127, a2
        cmp.le      pt4 = 8, a2
        ;;

 (pt6)  lfetch      [t3], 32        //128
 (pt4)  cmp.eq.unc  pt3 = 0, t2
 (pt4)  cmp.eq.unc  pt5 = t0, t1       
        

 (pt3)  br.cond.sptk QwordMoveUp
 (pt5)  br.cond.spnt AlignedMove
 (pt2)  br.cond.sptk UnalignedMove
   

ByteMoveUpLoop:
        ld1         t10 = [a1], 1
        nop.f       0
        add         a2 = -1, a2
        ;;

        st1         [a0] = t10, 1
        cmp.ne      pt1 = zero, a2
 (pt1)  br.cond.sptk ByteMoveUpLoop
          
        nop.m       0
        nop.f       0
        br.ret.sptk brp

UnalignedMove:
        cmp.eq      pt0 = 0, t1
        sub         t1 = 8, t1
 (pt0)  br.cond.spnt SkipUnalignedMoveByteLoop
        ;;
          

UnalignedMoveByteLoop:
        ld1         t10 = [a1], 1
        add         t1 = -1, t1
        add         a2 = -1, a2
        ;;

        st1         [a0] = t10, 1
        cmp.eq      p0, pt1 = zero, t1
 (pt1)  br.cond.sptk UnalignedMoveByteLoop
        ;;


SkipUnalignedMoveByteLoop:
        and         t0 = 7, a0
        mov         pr.rot = 3<<16
        or          t1 = a1, r0
        ;;

        add         t2 = a2, t0
        mov.i       ar.ec = 32
        sub         t21 = 8, t0
        ;;
        
        sub         t4 = a0, t0
        shr         t10 = t2, 3
        shl         t21 = t21, 3
        ;;
        
        ld8         r33 = [t4], 0
        add         t10 = -1,t10
        and         t2 = 7, t2
        ;;

        cmp.eq      pt0 = 2, t0
        cmp.eq      pt3 = 4, t0
        cmp.eq      pt5 = 6, t0
        ;;

        nop.m       0
        shl         r33 = r33,t21     // Prime r39
        mov.i       ar.lc = t10

 (pt0)  br.cond.spnt SpecialLoop2
 (pt3)  br.cond.spnt SpecialLoop4
 (pt5)  br.cond.spnt SpecialLoop6

        cmp.eq      pt1 = 3, t0
        cmp.eq      pt4 = 5, t0
        cmp.eq      pt6 = 7, t0

 (pt1)  br.cond.spnt SpecialLoop3
 (pt4)  br.cond.spnt SpecialLoop5
 (pt6)  br.cond.spnt SpecialLoop7
        ;;

SpecialLoop1:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop1E, SpecialLoop1

SpecialLoop1E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,56
        br.ctop.sptk.many SpecialLoop1

        br          UnalignedByteDone

SpecialLoop2:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop2E, SpecialLoop2

SpecialLoop2E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,48
        br.ctop.sptk.many SpecialLoop2

        br          UnalignedByteDone

SpecialLoop3:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop3E, SpecialLoop3

SpecialLoop3E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,40
        br.ctop.sptk.many SpecialLoop3

        br          UnalignedByteDone

SpecialLoop4:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop4E, SpecialLoop4

SpecialLoop4E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,32
        br.ctop.sptk.many SpecialLoop4

        br          UnalignedByteDone

SpecialLoop5:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0 
        brp.sptk.imp SpecialLoop5E, SpecialLoop5

SpecialLoop5E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,24
        br.ctop.sptk.many SpecialLoop5

        br          UnalignedByteDone

SpecialLoop6:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop6E, SpecialLoop6

SpecialLoop6E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,16
        br.ctop.sptk.many SpecialLoop6

        br          UnalignedByteDone

SpecialLoop7:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop7E, SpecialLoop7

SpecialLoop7E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,8
        br.ctop.sptk.many SpecialLoop7;;

UnalignedByteDone:
        sub         t1 = t1, t0
        mov         pr = r64
        mov.i       ar.lc = r65
        ;;

        cmp.eq      pt0 = zero, t2
 (pt0)  br.ret.spnt brp

UnAlignedByteDoneLoop:
        ld1         t10 = [t1], 1
        add         t2 = -1, t2
        ;;
        cmp.ne      pt1 = zero, t2

        st1         [t4] = t10, 1
 (pt1)  br.cond.sptk UnAlignedByteDoneLoop
        br.ret.spnt brp
        

AlignedMove:
        add         t4 = 64, t3
 (pt6)  lfetch      [t3], 32        //160
        sub         t22 = 8, t0
        ;;
        
 (pt6)  lfetch      [t3], 64        //192
 (pt6)  lfetch      [t4], 96        //224
        sub         a2 = a2, t22
        ;;


AlignedMoveByteLoop:
        ld1         t10 = [a1], 1
        nop.f       0
        add         t22 = -1, t22
        ;;

        st1         [a0] = t10, 1
        cmp.ne      pt1 = zero, t22
 (pt1)  br.cond.sptk AlignedMoveByteLoop
        ;;
        
 (pt6)  lfetch      [t3], 32        //256
        cmp.eq.unc  pt0 = zero, a2
        cmp.gt      pt2 = 8, a2

 (pt6)  lfetch      [t4], 128       //320
 (pt0)  br.ret.spnt brp
 (pt2)  br.cond.sptk ByteMoveUpLoop
        ;;

//
// both src & dest are now 8-byte aligned
//

QwordMoveUp:
        add         t3 = 128, a1
        add         t4 = 288, a1
        add         t7 = 8, a1

        add         t8 = 8, a0
        cmp.gt      pt3 = 64, a2
 (pt3)  br.cond.spnt QwordMoveUpLoop
        ;;

UnrolledQwordMoveUpLoop:

        ld8         t10 = [a1], 16
        ld8         t11 = [t7], 16
        add         a2 = -64, a2
        ;;

        ld8         t12 = [a1], 16
        ld8         t13 = [t7], 16
        cmp.le      pt3 = 128, a2
        ;;

        ld8         t14 = [a1], 16
        ld8         t15 = [t7], 16
        cmp.gt      pt2 = 8, a2
        ;;

        ld8         t16 = [a1], 16
        ld8         t17 = [t7], 16
        ;;

 (pt3)  lfetch      [t3], 64
 (pt3)  lfetch      [t4], 64

        st8         [a0] = t10, 16
        st8         [t8] = t11, 16
        ;;

        st8         [a0] = t12, 16
        st8         [t8] = t13, 16
        ;;

        st8         [a0] = t14, 16
        st8         [t8] = t15, 16
        ;;

        st8         [a0] = t16, 16
        st8         [t8] = t17, 16
 (pt3)  br.cond.dptk UnrolledQwordMoveUpLoop

 (pt2)  br.cond.spnt ByteMoveUp
        ;;

QwordMoveUpLoop:

        ld8         t10 = [a1], 8
        add         a2 = -8, a2
        ;;
        cmp.le      pt1 = 8, a2

        st8         [a0] = t10, 8
 (pt1)  br.cond.sptk QwordMoveUpLoop
        ;;

ByteMoveUp:
        cmp.eq      pt0 = zero, a2
 (pt0)  br.ret.spnt brp
        ;;

AlignedByteDoneLoop:
        ld1         t10 = [a1], 1
        add         a2 = -1, a2
        ;;
        cmp.ne      pt1 = zero, a2

        st1         [a0] = t10, 1
 (pt1)  br.cond.sptk AlignedByteDoneLoop
        br.ret.spnt brp
        ;;
	LEAF_EXIT(memcpy)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\_memicmp.asm ===
page        ,132
        title        memicmp - compare blocks of memory, ignore case
;***
;memicmp.asm - compare memory, ignore case
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines __ascii_memicmp() - compare two blocks of memory for lexical
;       order. Case is ignored in the comparison.
;
;Revision History:
;       05-16-83  RN    initial version
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   Cleanup...
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       01-17-91  GJF   ANSI naming.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       10-20-94  GJF   Made locale sensitive (i.e., now works for all
;                       single-byte character locales). Made multi-thread
;                       safe. Also, deleted obsolete _STDCALL_ code.
;       10-27-94  GJF   Adapted above change for Win32S.
;       11-12-94  GJF   Must avoid volatile regs or save them across function
;                       calls. Also, fixed bug in reg operand size.
;       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity check 
;                       to crtlib.c to catch changes to win32s.h that modify offset.
;       10-03-95  GJF   New locale locking scheme.
;       07-17-96  GJF   Added lock prefix to increment and decrement of 
;                       __unguarded_readlc_active.
;       07-18-96  GJF   Fixed race condition.
;       09-08-98  GJF   All locale and multithread support moved up to
;                       memicmp.c. Renamed this file to _memicmp.asm.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_memicmp(first, last, count) - compare two blocks of memory, ignore case
;
;Purpose:
;       Compares count bytes of the two blocks of memory stored at first
;       and last.  The characters are converted to lowercase before
;       comparing (not permanently), so case is ignored in the search.
;
;       Algorithm:
;       int
;       _memicmp (first, last, count)
;               char *first, *last;
;               unsigned count;
;               {
;               if (!count)
;                       return(0);
;               while (--count && tolower(*first) == tolower(*last))
;                       {
;                       first++;
;                       last++;
;                       }
;               return(tolower(*first) - tolower(*last));
;               }
;
;Entry:
;       char *first, *last - memory buffers to compare
;       unsigned count - maximum length to compare
;
;Exit:
;       returns <0 if first < last
;       returns 0 if first == last
;       returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_memicmp
__ascii_memicmp proc \
        uses edi esi ebx, \
        first:ptr byte, \
        last:ptr byte, \
        count:IWORD

        mov     ecx,[count]     ; cx = count
        or      ecx,ecx
        jz      short toend     ; if count=0, nothing to do

        mov     esi,[first]     ; si = first
        mov     edi,[last]      ; di = last

        ; C locale

        mov     bh,'A'
        mov     bl,'Z'
        mov     dh,'a'-'A'      ; add to cap to make lower

        align   4

lupe:
        mov     ah,[esi]        ; ah = *first
        inc     esi             ; first++
        mov     al,[edi]        ; al = *last
        inc     edi             ; last++

        cmp     ah,al           ; test for equality BEFORE converting case
        je      short dolupe

        cmp     ah,bh           ; ah < 'A' ??
        jb      short skip1

        cmp     ah,bl           ; ah > 'Z' ??
        ja      short skip1

        add     ah,dh           ; make lower case

skip1:
        cmp     al,bh           ; al < 'A' ??
        jb      short skip2

        cmp     al,bl           ; al > 'Z' ??
        ja      short skip2

        add     al,dh           ; make lower case

skip2:
        cmp     ah,al           ; *first == *last ??
        jne     short differ    ; nope, found mismatched chars

dolupe:
        dec     ecx
        jnz     short lupe

        jmp     short toend     ; cx = 0, return 0

differ:
        mov     ecx,-1          ; assume last is bigger
                                ; *** can't use "or ecx,-1" due to flags ***
        jb      short toend     ; last is, in fact, bigger (return -1)
        neg     ecx             ; first is bigger (return 1)

toend:
        mov     eax,ecx         ; move return value to ax

        ret                     ; _cdecl return

__ascii_memicmp endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\memmove.s ===
#include "ksia64.h"
        
	LEAF_ENTRY(memmove)
        .prologue
        .regstk     3,7,0,8
        alloc       t17 = ar.pfs,3,31,0,32
        .save       pr, r64
        mov         r64 = pr
        and         t3 = -32, a1
        ;;
        
        lfetch      [t3], 32        //0
        .save       ar.lc, r65
        mov.i       r65 = ar.lc 
        and         t1 = 7, a1
        ;;
        
        .body        
        lfetch      [t3], 32        //32
        mov         v0 = a0
        and         t0 = 7, a0
        ;;
        
        add         t21 = a1, a2
        cmp.gtu     pt0 = a0, a1 
        or          t2 = t0, t1
        ;;
        
 (pt0)  cmp.ltu.unc pt0 = a0, t21
        cmp.eq      pt1 = zero, a2
 (pt1)  br.ret.spnt brp

        lfetch      [t3], 32        //64
        cmp.lt      pt2 = 16, a2
 (pt0)  br.cond.spnt CopyDown
        ;;
 
        lfetch      [t3], 32        //96 
        cmp.lt      pt6 = 127, a2
        cmp.le      pt4 = 8, a2
        ;;

 (pt6)  lfetch      [t3], 32        //128
 (pt4)  cmp.eq.unc  pt3 = 0, t2
 (pt4)  cmp.eq.unc  pt5 = t0, t1       
        

 (pt3)  br.cond.sptk QwordMoveUp
 (pt5)  br.cond.spnt AlignedMove
 (pt2)  br.cond.sptk UnalignedMove
   

ByteMoveUpLoop:
        ld1         t10 = [a1], 1
        nop.f       0
        add         a2 = -1, a2
        ;;

        st1         [a0] = t10, 1
        cmp.ne      pt1 = zero, a2
 (pt1)  br.cond.sptk ByteMoveUpLoop
          
        nop.m       0
        nop.f       0
        br.ret.sptk brp

UnalignedMove:
        cmp.eq      pt0 = 0, t1
        sub         t1 = 8, t1
 (pt0)  br.cond.spnt SkipUnalignedMoveByteLoop
        ;;
          

UnalignedMoveByteLoop:
        ld1         t10 = [a1], 1
        add         t1 = -1, t1
        add         a2 = -1, a2
        ;;

        st1         [a0] = t10, 1
        cmp.eq      p0, pt1 = zero, t1
 (pt1)  br.cond.sptk UnalignedMoveByteLoop
        ;;


SkipUnalignedMoveByteLoop:
        and         t0 = 7, a0
        mov         pr.rot = 3<<16
        or          t1 = a1, r0
        ;;

        add         t2 = a2, t0
        mov.i       ar.ec = 32
        sub         t21 = 8, t0
        ;;
        
        sub         t4 = a0, t0
        shr         t10 = t2, 3
        shl         t21 = t21, 3
        ;;
        
        ld8         r33 = [t4], 0
        add         t10 = -1,t10
        and         t2 = 7, t2
        ;;

        cmp.eq      pt0 = 2, t0
        cmp.eq      pt3 = 4, t0
        cmp.eq      pt5 = 6, t0
        ;;

        nop.m       0
        shl         r33 = r33,t21     // Prime r39
        mov.i       ar.lc = t10

 (pt0)  br.cond.spnt SpecialLoop2
 (pt3)  br.cond.spnt SpecialLoop4
 (pt5)  br.cond.spnt SpecialLoop6

        cmp.eq      pt1 = 3, t0
        cmp.eq      pt4 = 5, t0
        cmp.eq      pt6 = 7, t0

 (pt1)  br.cond.spnt SpecialLoop3
 (pt4)  br.cond.spnt SpecialLoop5
 (pt6)  br.cond.spnt SpecialLoop7
        ;;

SpecialLoop1:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop1E, SpecialLoop1

SpecialLoop1E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,56
        br.ctop.sptk.many SpecialLoop1

        br          UnalignedByteDone

SpecialLoop2:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop2E, SpecialLoop2

SpecialLoop2E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,48
        br.ctop.sptk.many SpecialLoop2

        br          UnalignedByteDone

SpecialLoop3:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop3E, SpecialLoop3

SpecialLoop3E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,40
        br.ctop.sptk.many SpecialLoop3

        br          UnalignedByteDone

SpecialLoop4:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop4E, SpecialLoop4

SpecialLoop4E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,32
        br.ctop.sptk.many SpecialLoop4

        br          UnalignedByteDone

SpecialLoop5:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0 
        brp.sptk.imp SpecialLoop5E, SpecialLoop5

SpecialLoop5E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,24
        br.ctop.sptk.many SpecialLoop5

        br          UnalignedByteDone

SpecialLoop6:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop6E, SpecialLoop6

SpecialLoop6E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,16
        br.ctop.sptk.many SpecialLoop6

        br          UnalignedByteDone

SpecialLoop7:
 (p16)  ld8         r32 = [t1], 8
        nop.f       0
        brp.sptk.imp SpecialLoop7E, SpecialLoop7

SpecialLoop7E:
 (p48)  st8         [t4] = r10, 8
 (p47)  shrp        r10 = r62,r63,8
        br.ctop.sptk.many SpecialLoop7;;

UnalignedByteDone:
        sub         t1 = t1, t0
        mov         pr = r64
        mov.i       ar.lc = r65
        ;;

        cmp.eq      pt0 = zero, t2
 (pt0)  br.ret.spnt brp

UnAlignedByteDoneLoop:
        ld1         t10 = [t1], 1
        add         t2 = -1, t2
        ;;
        cmp.ne      pt1 = zero, t2

        st1         [t4] = t10, 1
 (pt1)  br.cond.sptk UnAlignedByteDoneLoop
        br.ret.spnt brp
        

AlignedMove:
        add         t4 = 64, t3
 (pt6)  lfetch      [t3], 32        //160
        sub         t22 = 8, t0
        ;;
        
 (pt6)  lfetch      [t3], 64        //192
 (pt6)  lfetch      [t4], 96        //224
        sub         a2 = a2, t22
        ;;


AlignedMoveByteLoop:
        ld1         t10 = [a1], 1
        nop.f       0
        add         t22 = -1, t22
        ;;

        st1         [a0] = t10, 1
        cmp.ne      pt1 = zero, t22
 (pt1)  br.cond.sptk AlignedMoveByteLoop
        ;;
        
 (pt6)  lfetch      [t3], 32        //256
        cmp.eq.unc  pt0 = zero, a2
        cmp.gt      pt2 = 8, a2

 (pt6)  lfetch      [t4], 128       //320
 (pt0)  br.ret.spnt brp
 (pt2)  br.cond.sptk ByteMoveUpLoop
        ;;

//
// both src & dest are now 8-byte aligned
//

QwordMoveUp:
        add         t3 = 128, a1
        add         t4 = 288, a1
        add         t7 = 8, a1

        add         t8 = 8, a0
        cmp.gt      pt3 = 64, a2
 (pt3)  br.cond.spnt QwordMoveUpLoop
        ;;

UnrolledQwordMoveUpLoop:

        ld8         t10 = [a1], 16
        ld8         t11 = [t7], 16
        add         a2 = -64, a2
        ;;

        ld8         t12 = [a1], 16
        ld8         t13 = [t7], 16
        cmp.le      pt3 = 128, a2
        ;;

        ld8         t14 = [a1], 16
        ld8         t15 = [t7], 16
        cmp.gt      pt2 = 8, a2
        ;;

        ld8         t16 = [a1], 16
        ld8         t17 = [t7], 16
        ;;

 (pt3)  lfetch      [t3], 64
 (pt3)  lfetch      [t4], 64

        st8         [a0] = t10, 16
        st8         [t8] = t11, 16
        ;;

        st8         [a0] = t12, 16
        st8         [t8] = t13, 16
        ;;

        st8         [a0] = t14, 16
        st8         [t8] = t15, 16
        ;;

        st8         [a0] = t16, 16
        st8         [t8] = t17, 16
 (pt3)  br.cond.dptk UnrolledQwordMoveUpLoop

 (pt2)  br.cond.spnt ByteMoveUp
        ;;

QwordMoveUpLoop:

        ld8         t10 = [a1], 8
        add         a2 = -8, a2
        ;;
        cmp.le      pt1 = 8, a2

        st8         [a0] = t10, 8
 (pt1)  br.cond.sptk QwordMoveUpLoop
        ;;

ByteMoveUp:
        cmp.eq      pt0 = zero, a2
 (pt0)  br.ret.spnt brp
        ;;

AlignedByteDoneLoop:
        ld1         t10 = [a1], 1
        add         a2 = -1, a2
        ;;
        cmp.ne      pt1 = zero, a2

        st1         [a0] = t10, 1
 (pt1)  br.cond.sptk AlignedByteDoneLoop
        br.ret.spnt brp
        ;;

CopyDown:
        cmp.eq      pt0 = zero, a2
        cmp.ne      pt6 = t0, t1
(pt0)   br.ret.spnt brp                              // return if length is zero

        cmp.gt      pt4 = 16, a2
        add         t20 = a2, a0
        add         t21 = a2, a1

        nop.m       0
(pt4)   br.cond.sptk ByteMoveDown                 // less than 16 bytes to copy
(pt6)   br.cond.spnt UnalignedMoveDown            // incompatible alignment
        ;;

        nop.m       0
        nop.m       0
        and         t22 = 0x7, t21
        ;;

        add         t20 = -1, t20
        add         t21 = -1, t21
        sub         a2 = a2, t22
        ;;

TailMove:
        cmp.eq      pt0, pt1 = zero, t22
        ;;

 (pt1)  ld1         t10 = [t21], -1
 (pt1)  add         t22 = -1, t22
        ;;

 (pt1)  st1         [t20] = t10, -1
 (pt1)  br.cond.sptk TailMove


Block8Move:
        nop.m       0
        add         t20 = -7, t20
        add         t21 = -7, t21
        ;;

Block8MoveLoop:
        cmp.gt      pt5, pt6 = 8, a2
        ;;

(pt6)   ld8         t10 = [t21], -8
(pt6)   add         a2 = -8, a2
        ;;

(pt6)   st8         [t20] = t10, -8
(pt6)   br.cond.sptk Block8MoveLoop

        add         t20 = 8, t20                 // adjust dest
        add         t21 = 8, t21                 // adjust source
        br.cond.sptk ByteMoveDown
        ;;


UnalignedMoveDown:
        and         t1 = 7, t21
        ;;
        cmp.eq      pt0 = 0, t1
 (pt0)  br.cond.spnt SkipUnalignedMoveDownByteLoop
        ;;

        add         t20 = -1, t20
        add         t21 = -1, t21
        ;;

UnalignedMoveDownByteLoop:
        ld1         t10 = [t21], -1
        add         t1 = -1, t1
        add         a2 = -1, a2
        ;;

        st1         [t20] = t10, -1
        cmp.eq      p0, pt1 = zero, t1
 (pt1)  br.cond.sptk UnalignedMoveDownByteLoop
        ;;

        add         t20 = 1, t20
        add         t21 = 1, t21
        ;;

SkipUnalignedMoveDownByteLoop:
        add         t21 = -8, t21
        ;;

        and         t0 = 7, t20
        mov         pr.rot = 3<<16
        or          t1 = t21, r0
        ;;

        sub         t7 = 8, t0
        ;;

        add         t2 = a2, t7
        mov.i       ar.ec = 32
        ;;
        
        sub         t4 = t20, t0
        shr         t10 = t2, 3
        shl         t6 = t0, 3
        ;;
        
        ld8         r33 = [t4], 0
        add         t10 = -1,t10
        and         t2 = 7, t2
        ;;

        cmp.eq      pt0 = 2, t0
        cmp.eq      pt3 = 4, t0
        cmp.eq      pt5 = 6, t0
        ;;

        shr         r33 = r33,t6     // Prime r39
        mov.i       ar.lc = t10

 (pt0)  br.cond.spnt SpecialLoopDown2
 (pt3)  br.cond.spnt SpecialLoopDown4
 (pt5)  br.cond.spnt SpecialLoopDown6

        cmp.eq      pt1 = 3, t0
        cmp.eq      pt4 = 5, t0
        cmp.eq      pt6 = 7, t0

 (pt1)  br.cond.spnt SpecialLoopDown3
 (pt4)  br.cond.spnt SpecialLoopDown5
 (pt6)  br.cond.spnt SpecialLoopDown7
        ;;

SpecialLoopDown1:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0
        brp.sptk.imp SpecialLoopDown1E, SpecialLoopDown1

SpecialLoopDown1E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,56
        br.ctop.sptk.many SpecialLoopDown1

        br          UnalignedByteDownDone

SpecialLoopDown2:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0
        brp.sptk.imp SpecialLoopDown2E, SpecialLoopDown2

SpecialLoopDown2E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,48
        br.ctop.sptk.many SpecialLoopDown2

        br          UnalignedByteDownDone

SpecialLoopDown3:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0
        brp.sptk.imp SpecialLoopDown3E, SpecialLoopDown3

SpecialLoopDown3E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,40
        br.ctop.sptk.many SpecialLoopDown3

        br          UnalignedByteDownDone

SpecialLoopDown4:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0
        brp.sptk.imp SpecialLoopDown4E, SpecialLoopDown4

SpecialLoopDown4E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,32
        br.ctop.sptk.many SpecialLoopDown4

        br          UnalignedByteDownDone

SpecialLoopDown5:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0 
        brp.sptk.imp SpecialLoopDown5E, SpecialLoopDown5

SpecialLoopDown5E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,24
        br.ctop.sptk.many SpecialLoopDown5

        br          UnalignedByteDownDone

SpecialLoopDown6:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0
        brp.sptk.imp SpecialLoopDown6E, SpecialLoopDown6

SpecialLoopDown6E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,16
        br.ctop.sptk.many SpecialLoopDown6

        br          UnalignedByteDownDone

SpecialLoopDown7:
 (p16)  ld8         r32 = [t1], -8
        nop.f       0
        brp.sptk.imp SpecialLoopDown7E, SpecialLoopDown7

SpecialLoopDown7E:
 (p48)  st8         [t4] = r10, -8
 (p47)  shrp        r10 = r63,r62,8
        br.ctop.sptk.many SpecialLoopDown7;;

UnalignedByteDownDone:
        add         t1 = 7, t1
        add         t4 = 7, t4
        ;;

        add         t1 = t1, t7
        mov         pr = r64
        mov.i       ar.lc = r65
        ;;

        cmp.eq      pt0 = zero, t2
 (pt0)  br.ret.spnt brp
        ;;

UnAlignedByteDoneDownLoop:
        ld1         t10 = [t1], -1
        add         t2 = -1, t2
        ;;
        cmp.ne      pt1 = zero, t2

        st1         [t4] = t10, -1
 (pt1)  br.cond.sptk UnAlignedByteDoneDownLoop
        br.ret.spnt brp

ByteMoveDown:
        nop.m       0
        add         t20 = -1, t20                 // adjust source
        add         t21 = -1, t21                 // adjust destination
        ;;

ByteMoveDownLoop:
        cmp.ne      pt1 = zero, a2
        ;;
 (pt1)  ld1         t10 = [t21], -1
 (pt1)  add         a2 = -1, a2
        ;;

 (pt1)  st1         [t20] = t10, -1
 (pt1)  br.cond.sptk ByteMoveDownLoop
        br.ret.spnt brp
          ;;
	LEAF_EXIT(memmove)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\strcmp.s ===
// string.s: function to compare two strings	

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

	.file "string.s"
	.section .text
// -- Begin  strcmp
	.proc  strcmp#
	.global strcmp#
	.align 32


strcmp:
{   .mib
	alloc	r14=ar.pfs,1,7,0,8	   //8 rotating registers, 7 locals
	mov	r11=pr			   //Save predicate register file
	brp.loop.imp .b1_4, .bw1 ;;  // Put loop backedge target in TAR
 } 
 // Setup for doing software pipelined loops
 { .mii
	mov	r8=r33			// r8 = s2
	mov	pr.rot=0x10000		// p16=1
	mov	ar.ec=0 
 } { .mfb
	mov     r9=r32			// r9 = s1
	nop.f	 0			
	nop.b	 0 ;;
 }
.b1_4:
 {   .mii
	ld1.s	r37=[r9],1		// *s1  (r37,r38)
       	cmp4.eq.unc	p16,p0=r0,r0	// p16 = 1
  (p17)	chk.s	r38,.natfault1_0	//
 } 

.b1_5:
{  .mmi
	ld1.s	r32=[r8],1 ;;		// *s2  (r32,r33)
  (p17)	cmp4.ne.and	p16,p0=r38,r0	// *s1!=0 (p16,p17)
  (p17)	chk.s	r33,.natfault1_1	//
 } 
 .bw1:
 { .mib
  (p17)	cmp4.ne.and	p16,p0=r33,r0	// *s2!=0 (p16,p17)
  (p17)	cmp4.eq.and	p16,p0=r38,r33	// *s1==*s2 (p16,p17)
  (p16)	br.wtop.dptk	.b1_4 ;;	//
 }
.b1_1:
 { .mii
	mov	r8=r0			// return 0 for *s1 == *s2
	cmp4.geu.unc	p0,p6=r38,r33	// do unsigned comparison *s1 : *s2
	cmp4.leu.unc	p0,p7=r38,r33 ;;
 } { .mmi
  (p6)	mov	r8=-1 ;;		// return -1 if *s1 < *s2
  (p7)	mov	r8=1			// return +1 if *s1 > *s2
	mov	pr=r11,0x1003e			
 } { .mib
	nop.m	0
	nop.i	0
	br.ret.sptk.many	b0 ;;
 }

.natfault1_0:
        add r9 = -2, r9;;
        ld1 r38 = [r9],2
        br.cond.sptk .b1_5;;

.natfault1_1:
        add r8 = -2, r8;;
        ld1 r33 = [r8],2
        br.cond.sptk .bw1;;
_2_1_2auto_size == 0x0
// -- End  strcmp
	.endp  strcmp#
// mark_proc_addr_taken strcmp;
// End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\_stricmp.asm ===
page    ,132
        title   stricmp
;***
;stricmp.asm - contains ASCII only, case-insensitive, string comparision routine
;       __ascii_stricmp
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       contains __ascii_stricmp()
;
;Revision History:
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   Minor 386 cleanup
;       10-10-88  JCR   Added strcmpi() entry for compatiblity with early revs
;       10-25-88  JCR   General cleanup for 386-only code
;       10-27-88  JCR   Shuffled regs so no need to save/restore ebx
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       01-18-91  GJF   ANSI naming.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       10-20-94  GJF   Made locale sensitive (i.e., now works for all
;                       single-byte character locales). Made multi-thread
;                       safe. Also, deleted obsolete _STDCALL_ code.
;       10-27-94  GJF   Adapted above change for Win32S.
;       11-12-94  GJF   Must avoid volatile regs or save them across function
;                       calls. Also, fixed bug in reg operand size.
;       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity check 
;                       to crtlib.c to catch changes to win32s.h that modify offset.
;       10-03-95  GJF   New locale locking scheme.
;       11-13-95  GJF   Made _strcmpi a proc instead of a label.
;       07-17-96  GJF   Added lock prefix to increment and decrement of 
;                       __unguarded_readlc_active
;       07-18-96  GJF   Fixed race condition.
;       08-26-98  GJF   All locale and multithread support moved up to
;                       stricmp.c. Renamed this file to _stricmp.asm.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_stricmp(dst, src) - compare strings, ignore case
;
;Purpose:
;       _stricmp/_strcmpi perform a case-insensitive string comparision.
;       For differences, upper case letters are mapped to lower case.
;       Thus, "abc_" < "ABCD" since "_" < "d".
;
;       Algorithm:
;
;       int _strcmpi (char * dst, char * src)
;       {
;               int f,l;
;
;               do {
;                       f = tolower(*dst);
;                       l = tolower(*src);
;                       dst++;
;                       src++;
;               } while (f && f == l);
;
;               return(f - l);
;       }
;
;Entry:
;       char *dst, *src - strings to compare
;
;Exit:
;       AX = -1 if dst < src
;       AX =  0 if dst = src
;       AX = +1 if dst > src
;
;Uses:
;       CX, DX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_stricmp
__ascii_stricmp proc \
        uses edi esi ebx, \
        dst:ptr, \
        src:ptr

        ; load up args

        mov     esi,[src]       ; esi = src
        mov     edi,[dst]       ; edi = dst

        mov     al,-1           ; fall into loop

        align   4

chk_null:
        or      al,al
        jz      short done

        mov     al,[esi]        ; al = next source byte
        inc     esi
        mov     ah,[edi]        ; ah = next dest byte
        inc     edi

        cmp     ah,al           ; first try case-sensitive comparision
        je      short chk_null  ; match

        sub     al,'A'
        cmp     al,'Z'-'A'+1
        sbb     cl,cl
        and     cl,'a'-'A'
        add     al,cl
        add     al,'A'          ; tolower(*dst)

        xchg    ah,al           ; operations on AL are shorter than AH

        sub     al,'A'
        cmp     al,'Z'-'A'+1
        sbb     cl,cl
        and     cl,'a'-'A'
        add     al,cl
        add     al,'A'          ; tolower(*src)

        cmp     al,ah           ; inverse of above comparison -- AL & AH are swapped
        je      short chk_null

                                ; dst < src     dst > src
        sbb     al,al           ; AL=-1, CY=1   AL=0, CY=0
        sbb     al,-1           ; AL=-1         AL=1
done:
        movsx   eax,al          ; extend al to eax

        ret

__ascii_stricmp endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\strcat.s ===
// string.s:	function to concatenate 2 strings
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//

	.file "string.s"
	.section .text
// -- Begin  strcat
	.proc  strcat#
	.global strcat#
	.align 32


strcat:
 {   .mib
	alloc	r14=ar.pfs,2,6,0,8	//8 rotating registers, 7 locals
	mov	r11=pr			//Save predicate register file
	brp.loop.imp .bs1len, .bws1 // Put loop backedge target in TAR
 } 
 // Setup for doing software pipelined loops
 { .mib
	mov     r9=r33	
	mov	pr.rot=0x30000		// p16=p17=1
	nop.b	0
 };;
 { .mib
	mov     r14=r32				
	mov	ar.ec=0 
	nop.b	0
 } { .mib				// Extra bundle to align bs1len.
	mov     r8=r32				
	nop.i	0
	brp.loop.imp .bcat, .bwcat ;; // Put loop backedge target in TAR
 }
.bs1len:
 {   .mii
	ld1.s	r37=[r14],1		// *s  (r37,r38,r39)
  	nop.i	0
  (p19)	chk.s	r39,.natfault1_0	//
 } 
 .bws1:
 { .mfb
  (p19)	cmp4.ne	p17,p0=r39,r0		// *s==0 (p16,p17,p18)
	nop.f	0		
  (p17)	br.wtop.dptk	.bs1len ;;	//
 }
//
// Now concatenate s2 into the end of s1
//
 {   .mib
	add	r14=-3,r14		// Since ld1.s is 2 stages ahead
	dep     r15=1,r0,32,32		// rb = 0xffffffff00000000		
	clrrrb	;;
 } { .mii
 // Setup for doing software pipelined loops
	or	r32=r14,r9 
	mov	pr.rot=0x30000 ;;	// p16=p17=1
	and	r32=3,r32 ;;
 } { .mib
	cmp4.ne	p10,p0=r32,r0
	mov	ar.ec=0 
  (p10)	br.spnt .b_notaligned  ;;
 }
.bcat:
 {   .mii
	ld4.s	r32=[r9],4		// *s1  (r32,r33,r34)
  (p18)	chk.s	r33,.natfault2_0	//
  (p18) pcmp1.eq r16=r33,r15 ;;		// r16 !=0 only if a zero byte is found
 } 
 .bwcat:
 { .mib
  (p19)	st4	[r14]=r34,4		// *s2=*s1
  (p18)	cmp4.eq p17,p0=r16,r0		// zero byte found?
  (p17)	br.wtop.dptk	.bcat ;;	//
 } 
{ .mfi      
  nop.m         0 
  nop.f         0 
  czx1.r       r16 = r33
 } ;;
 { .mfi
   cmp.leu       p2, p0 = 2, r16 
   nop.f         0 
   shr.u r35 = r33, 8 
 }
 { .mfi
   cmp.eq        p4, p0 = 3, r16 
   nop.f         0 
   cmp.ne        p5, p0 = r0, r16 
 } ;;			    
 { .mfi    
   (p5)st1           [r14] = r33, 1 
   nop.f         0 
   shr.u         r36 = r33, 16 
 };;
 { .mfi
 (p2)st1           [r14] = r35,1 
   nop.f         0 
   nop.i         0 
 } ;;
 { .mfi    
  (p4)st1           [r14] = r36,1 
  nop.f         0 
  nop.i         0 
 };;
 { .mib
  (p0) st1           [r14] = r0 
   nop.i        0 
   clrrrb	    
} ;; 
{   .mib
	nop.m 0
	mov	pr=r11,0x1003e			
	br.ret.sptk.many	b0 ;;
 }
.b_notaligned:
 {   .mmi
        ld1     r32=[r9],1  ;;           // 2 cycle load causes 1 cycle stall
        st1     [r14]=r32,1              // 3 cycles between st1 to avoid flush
        cmp4.ne.unc     p7,p0=r32,r0 ;;  // Extra stop bit to force 3 cycles
 } { .mib
        nop.m   0
        nop.i   0
  (p7)  br.cond.dptk    .b_notaligned ;;
 } { .mib
        nop.m   0
        mov     pr=r11,0x1003e
        br.ret.sptk.many        b0 ;;
 }
.natfault1_0:
{ .mmi
	add	r39=-3,r14 ;;
	ld1	r39=[r39]		// Redo the load    
	nop.i	0 
} { .mib
	nop.m   0
	nop.i   0
	br.sptk	.bws1 ;;
}
.natfault2_0:
{ .mmi
	add	r33=-8,r9 ;;
	ld4	r33=[r33]		// *s1  (r32,r33,r34)
	nop.i	0;;
} { .mib
	nop.m	0
  (p18) pcmp1.eq r16=r33,r15 		// r16 !=0 only if a zero byte is found
	br.sptk	.bwcat ;;
}
_2_1_2auto_size == 0x0
// -- End  strcat
	.endp  strcat#
// mark_proc_addr_taken strcat;
// End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\mt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\i386\_strnicm.asm ===
page    ,132
        title   strnicmp - compare n chars of strings, ignore case
;***
;strnicmp.asm - compare n chars of strings, ignoring case
;
;       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines __ascii_strnicmp() - Compares at most n characters of two 
;       strings, without regard to case.
;
;Revision History:
;       04-04-85  RN    initial version
;       07-11-85  TC    zeroed cx, to allow correct return value if not equal
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   386 cleanup and improved return value sequence
;       10-26-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       01-18-91  GJF   ANSI naming.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       10-20-94  GJF   Made locale sensitive (i.e., now works for all
;                       single-byte character locales). Made multi-thread
;                       safe. Also, deleted obsolete _STDCALL_ code.
;       10-27-94  GJF   Adapted above change for Win32S.
;       11-12-94  GJF   Must avoid volatile regs or save them across function
;                       calls.
;       11-22-94  GJF   Forgot to increment pointers in non-C locales.
;       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity check 
;                       to crtlib.c to catch changes to win32s.h that modify offset.
;       09-22-95  GJF   Fixed first line at label differ2 to loaded -1 into
;                       ecx (same as code a label differ).
;       10-03-95  GJF   New locale locking scheme.
;       07-17-96  GJF   Added lock prefix to increment and decrement of 
;                       __unguarded_readlc_active
;       07-18-96  GJF   Fixed race condition.
;       09-10-98  GJF   All locale and multithread support moved up to
;                       strnicmp.c. Renamed this file to _strnicm.asm.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_strnicmp(first, last, count) - compares count char of strings,
;       ignore case
;
;Purpose:
;       Compare the two strings for lexical order.  Stops the comparison
;       when the following occurs: (1) strings differ, (2) the end of the
;       strings is reached, or (3) count characters have been compared.
;       For the purposes of the comparison, upper case characters are
;       converted to lower case.
;
;       Algorithm:
;       int
;       _strncmpi (first, last, count)
;             char *first, *last;
;             unsigned int count;
;             {
;             int f,l;
;             int result = 0;
;
;             if (count) {
;                     do      {
;                             f = tolower(*first);
;                             l = tolower(*last);
;                             first++;
;                             last++;
;                             } while (--count && f && l && f == l);
;                     result = f - l;
;                     }
;             return(result);
;             }
;
;Entry:
;       char *first, *last - strings to compare
;       unsigned count - maximum number of characters to compare
;
;Exit:
;       returns <0 if first < last
;       returns 0 if first == last
;       returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_strnicmp
__ascii_strnicmp proc \
        uses edi esi ebx, \
        first:ptr byte, \
        last:ptr byte, \
        count:IWORD

        mov     ecx,[count]     ; cx = byte count
        or      ecx,ecx
        jz      toend           ; if count = 0, we are done

        mov     esi,[first]     ; si = first string
        mov     edi,[last]      ; di = last string

        mov     bh,'A'
        mov     bl,'Z'
        mov     dh,'a'-'A'      ; add to cap to make lower

        align   4

lupe:
        mov     ah,[esi]        ; *first

        or      ah,ah           ; see if *first is null

        mov     al,[edi]        ; *last

        jz      short eject     ;   jump if *first is null

        or      al,al           ; see if *last is null
        jz      short eject     ;   jump if so

        inc     esi             ; first++
        inc     edi             ; last++

        cmp     ah,bh           ; 'A'
        jb      short skip1

        cmp     ah,bl           ; 'Z'
        ja      short skip1

        add     ah,dh           ; make lower case

skip1:
        cmp     al,bh           ; 'A'
        jb      short skip2

        cmp     al,bl           ; 'Z'
        ja      short skip2

        add     al,dh           ; make lower case

skip2:
        cmp     ah,al           ; *first == *last ??
        jne     short differ

        dec     ecx
        jnz     short lupe

eject:
        xor     ecx,ecx
        cmp     ah,al           ; compare the (possibly) differing bytes
        je      short toend     ; both zero; return 0

differ:
        mov     ecx,-1          ; assume last is bigger (* can't use 'or' *)
        jb      short toend     ; last is, in fact, bigger (return -1)
        neg     ecx             ; first is bigger (return 1)

toend:
        mov     eax,ecx

        ret                     ; _cdecl return

__ascii_strnicmp endp
         end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\nt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\st\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\psx\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\memset.s ===
// memset.s:	function to set a number of bytes to a char value
	
// Copyright  (C) 1998 Intel Corporation.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined, or
// reproduced in whole or in part without explicit written authorization from
// the Company.

//       Author: Steve Skedzielewski
//       Date:   June, 2000
// 
	.section .text
// -- Begin  memset
	.proc  memset#
	.align 32
// Replicate the value into all bytes using mmx broadcast
// live out:	r21 (alignment), r11(ar.lc), r33(replicated c),
//		r32(s), r34(n)
	.global memset#
	.prologue
memset:
	and	r21=7,r32
	.save	ar.lc,r11,t01
[t01:]	mov	r11=ar.lc				 //0:  2 MS
	brp.dptk.imp	Longloop, Longloop_br
	mov	r8=r32				//0:
	mux1	r33=r33,@brcst
	;;
// If we're not on an 8-byte boundary, move to one
// live out:	r11(ar.lc), r33(unsigned c), r32(sext s), r34(unsigned n)
//		p14 (n>=MINIMUM_LONG)
	.body
	MINIMUM_LONG=0x4f
Check_align:
	cmp.le	p14,p0=MINIMUM_LONG,r34	//0: MINIMUM_LONG < n?
	cmp.ne	p15,p0=0,r21			//0: Low 3 bits zero?
  (p15)	br.cond.dpnt	Align			//0:
	;;
// Now that p is aligned,
//     use straight-line code for n<=64, a loop otherwise
// Exit if n<=0
// live out:	r11(ar.lc), r33(unsigned c), r32(sext s), r34(n)
//		r17(s+8), p13(n>8), p12(n>16), p14 (n>=MINIMUM_LONG)
Is_aligned:
	cmp.ge	p15,p0=0,r34		//0: n <= 0? 
	cmp.le	p13,p0=0x10,r34		//0: 16 <= n?
	cmp.le	p12,p0=0x20,r34		//0: 32 <= n?
	add	r17=8,r32			//0: second pointer
  (p15)	br.cond.dpnt	Exit			//0: 21 MS
  (p14)	br.cond.dpnt	Long 			//0: 21 MS
	;;
// Short memsets are done with predicated straightline code
// live out:	r8 (return value, original value of r32
	;;				// stall 1 cycle for MMX to complete
 (p13)	st8	[r32]=r33,16			//0:
 (p13)	st8	[r17]=r33,16			//0:
	cmp.le	p11,p0=0x30,r34		//0: 48 <= n?
	;;
 (p12)	st8	[r32]=r33,16			//1:
 (p12)	st8	[r17]=r33,16			//1:
	cmp.le	p10,p0=0x40,r34		//1: 64 <= n?
	;;
 (p11)	st8	[r32]=r33,16			//2:
 (p11)	st8	[r17]=r33,16			//2:
	tbit.nz	p9,p0=r34,3			//2: odd number of st8s?
	;;
 (p10)	st8	[r32]=r33,16			//3:
 (p10)	st8	[r17]=r33			//3:
	tbit.nz	p8,p0=r34,2			//3: bit 2 on?
	;;
 (p9)	st8	[r32]=r33,8			//4:
	tbit.nz	p7,p0=r34,1			//4: bit 1 on?
	and	r18=1,r34			//4: bit 0 on?
	;;
// 
// Clean up any partial word stores.
//	
 (p8)	st4	[r32]=r33,4			//5:
	;;
 (p7)	st2	[r32]=r33,2			//6:
	cmp.ne	p6,p0=0,r18			//6:
	;;
 (p6)	st1	[r32]=r33,1			//7:
	br.ret.sptk.many	b0		//7:
	;;
// Cycles = 8 , Instr = 21
//
// Block 11: Bchanged  Pred: 8     Succ: 15
// Counted loop setup.  We know n>0 (exit above otherwise),
//    so we can just shift n right 4 bits (2 st8/iteration)
// live out:	r8(return value), r11(ar.lc), r17(s+8), r32(sext s)
//              r33(replicated c), r34(n), p5(n&4), p6(n&8)
Long:
	add	r17=8,r32			//0: second pointer
	shr.u	r30=r34,4			//0: 29 MS
	and	r18=0x8,r34			//0:
	and	r19=0x4,r34			//0:
	;;
	cmp.ne	p6,p0=0,r18			//1:
	add	r30=-2,r30			//1:
	cmp.ne	p15,p0=0,r19			//1:
	;;
	st8	[r32]=r33,16			//2: Use the otherwise empty
	st8	[r17]=r33,16			//2: m slots
	mov	ar.lc=r30			//2:
	;;
// Cycles = 2, Instr = 9
// Block 15: lentry lexit Bchanged  Pred: 15 11     Succ: 15 13 
// Counted loop storing 16 bytes/iteration, TAR hinted.
// live out:	r11(ar.lc), r17(s+8), r21(n&7), r32(sext s)
//              r33(replicated c), r34(n), p5(n&4), p6(n&8)
Longloop:
Longloop_br:
	st8	[r32]=r33,16			//0: 30 MS
	st8	[r17]=r33,16			//0: 31 MS
	br.cloop.sptk	Longloop		//0:  0 MS
	;;
// Cycles = 1, Instr = 3
// Block 13:  Pred: 11 15     Succ: 12 24
// Exit, or cleanup and exit
// live out:	r17(s+8), r32(sext s), r33(replicated c), r34(n)
//              p4(n&2), p5(n&4)
Loopdone:
 (p6)	st8	[r32]=r33,8			//0:
	tbit.nz	p14,p0=r34,1			//0:
	;;
// Block 24: Bchanged  Pred: 13     Succ:
// Cleanup partial words after loop
 (p15)	st4	[r32]=r33,4			//0:
	;;
 (p14)	st2	[r32]=r33,2			//1:
	tbit.nz	p13,p0=r34,0			//1:
	;;
Loopexit:
 (p13)	st1	[r32]=r33			//2:
	mov	ar.lc=r11			//2:
	br.ret.sptk.many	b0		//2:
	;;
// Cycles = 6, Instr = 12
/// 
/// Align the input pointer to an 8-byte boundary
// Block 5: lentry lexit Bchanged  Pred: 3 6     Succ: 8 6 
// Freq 0, prob 0
.b1_5:
Align:
	cmp.ge	p9,p0=0,r34			//0: 18 MS
	sub	r22=8,r21			//0: 16 B6 MS S
  (p9)	br.cond.dpnt	Exit			//0: 18 MS
	;;
// Cycles = 1, Instr = 3
// Block 6: lexit Bchanged  Pred: 5     Succ: 5 8 
Align_loop:
	st1	[r32]=r33,1			//0: 19 MS
	cmp.ge	p10,p0=1,r22			//0:
	add	r34=-1,r34			//0:
 (p10)	br.cond.dpnt	Is_aligned		//0:
	;;
	add	r22=-1,r22
	cmp.lt	p9,p0=0,r34			//0: 16 MS
  (p9)	br.cond.dptk	Align_loop		//0: 16 MS
	;;
// Cycles = 2, Instr = 6
Exit:
	br.ret.sptk.many	b0		//0:
	;;
// Cycles = 1, Instr = 3
// -- End  memset
	.endp  memset#
// End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\strlen.s ===
// string.s:	function to compute length of string

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

	.file "string.s"
	.section .text
// -- Begin  strlen
	.proc  strlen#
	.global strlen#
	.align 32


strlen:
 {   .mib
	alloc	r14=ar.pfs,1,7,0,8	//8 rotating registers, 7 locals
	mov	r11=pr			//Save predicate register file
	brp.loop.imp .b1_4, .bw1	// Put loop backedge target in TAR
 } { .mib
	add	r35=0,r0		// i = 0; 
	cmp.eq.unc	p7,p0=r32,r0	//check if input s (r32) = 0
  (p7)	br.cond.dpnt .b1_1 ;;		// exit if s=0
 } 
 // Setup for doing software pipelined loops
 { .mii
	add	r33=0,r0			
	mov	pr.rot=0x30000		// p16=p17=1
	mov	ar.ec=0 ;;
 } { .mfb
	mov     r9=r32				
	nop.f	 0			
	nop.b	 0;;
 }
.b1_4:
 {   .mii
	ld1.s	r37=[r9],1		// *s  (r37,r38,r39)
  	add	r32=1,r33 	 	// i++ (r32,r33,r34,r35)
  (p19)	chk.s	r39,.natfault1_0	//
 } 
 .bw1:
 { .mfb
  (p19)	cmp4.ne	p17,p0=r39,r0		// *s==0 (p16,p17,p18)
	nop.f	0		
  (p17)	br.wtop.dptk	.b1_4 ;;	//
 }
.b1_1:
 {   .mfi
	nop.m	0
	nop.f	0
	sxt4	r8=r35				 
 } {   .mib
	nop.m	0
	mov	pr=r11,0x1003e			
	br.ret.sptk.many	b0 ;;
 }
.natfault1_0:
	add r9 = -3, r9;;
        ld1 r39 = [r9],3
        br.cond.sptk .bw1;;
_2_1_2auto_size == 0x0
// -- End  strlen
	.endp  strlen#
// mark_proc_addr_taken strlen;
// End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\string\ia64\strcpy.s ===
// strcpy.s:	function to copy the contents of one string to another

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

	.file "strcpy.s"
	.section .text
// -- Begin  strcpy
	.proc  strcpy#
	.global strcpy#
	.align 32


strcpy:
 {   .mib
	alloc	r14=ar.pfs,2,6,0,8	//8 rotating registers, 6 locals
	mov	r11=pr			//Save predicate register file
   brp.loop.imp     .b1_4, .bw1;;	// Put loop backedge target in TAR
 } { .mib
 // Setup for doing software pipelined loops
	or	r14=r32,r33 
	mov	pr.rot=0x30000		// p16=p17=1
	nop.b	0	;;
 } { .mfi 
	mov	r8=r32			
	nop.f	0
	and	r14=3,r14 
 } { .mii
	mov     r9=r33				
	mov	ar.ec=0 ;;
	cmp4.ne	p10,p0=r14,r0
 } { .mib
	mov	r14=r32			
	dep     r15=1,r0,32,32		// rb = 0xffffffff00000000		
  (p10)	br.spnt .b_notaligned  ;;
 }
.b1_4:
 {   .mii
	ld4.s	r32=[r9],4		// *s1  (r32,r33,r34)
  (p18)	chk.s	r33,.natfault1_0	//
  (p18) pcmp1.eq r16=r33,r15 ;;		// r16 !=0 only if a zero byte is found
 } 
 .bw1:
 { .mib
  (p19)	st4	[r14]=r34,4		// *s2=*s1
  (p18)	cmp4.eq p17,p0=r16,r0		// zero byte found?
  (p17)	br.wtop.dptk	.b1_4 ;;	//
 } 
 { .mfi      
  nop.m         0 
  nop.f         0 
  czx1.r       r16 = r33
 } ;;
 { .mfi
   cmp.leu       p2, p0 = 2, r16 
   nop.f         0 
   shr.u r35 = r33, 8 
 }
 { .mfi
   cmp.eq        p4, p0 = 3, r16 
   nop.f         0 
   cmp.ne        p5, p0 = r0, r16 
 } ;;			    
 { .mfi    
   (p5)st1           [r14] = r33, 1 
   nop.f         0 
   shr.u         r36 = r33, 16 
 };;
 { .mfi
 (p2)st1           [r14] = r35,1 
   nop.f         0 
   nop.i         0 
 } ;;
 { .mfi    
  (p4)st1           [r14] = r36,1 
  nop.f         0 
  nop.i         0 
 };;
 { .mib
  (p0) st1           [r14] = r0 
   nop.i        0 
   clrrrb	    
} ;; 
.b1_2:
 {   .mib
	nop.m 0
	mov	pr=r11,0x1003e			
	br.ret.sptk.many	b0 ;;
 }
.b_notaligned:
 {   .mmi
	ld1	r32=[r9],1  ;;		 // 2 cycle load causes 1 cycle stall
	st1	[r14]=r32,1		 // 3 cycles between st1 to avoid flush
	cmp4.ne.unc	p7,p0=r32,r0 ;;	 // Extra stop bit to force 3 cycles
 } { .mib
	nop.m	0
	nop.i	0 				
  (p7)	br.cond.dptk	.b_notaligned ;;	
 } { .mib
	nop.m	0
	mov	pr=r11,0x1003e			
	br.ret.sptk.many	b0 ;;
 }
.natfault1_0:
{ .mmi
	add	r33=-8,r9 ;;
	ld4	r33=[r33]		// Redo the load
	nop.i	0 ;;
} { .mib
	nop.m	0
  (p18) pcmp1.eq r16=r33,r15 		// r16 !=0 only if a zero byte is found
	br.sptk .bw1 ;;
}
_2_1_2auto_size == 0x0
// -- End  strcpy
	.endp  strcpy#
// mark_proc_addr_taken strcpy;
// End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\clock.c ===
/***
*clock.c - Contains the clock runtime
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The clock runtime returns the processor time used by
*       the current process.
*
*Revision History:
*       01-17-87  JCR   Module created
*       06-01-87  SKS   "itime" must be declared static
*       07-20-87  JCR   Changes "inittime" to "_inittime"
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       10-04-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       07-25-91  GJF   Added _pinittime definition for new initialization
*                       scheme [_WIN32_].
*       03-13-92  SKS   Changed itime from static local to external as
*                       a part of return to initializer table scheme.
*                       Changed _inittime to __inittime.
*       05-19-92  DJM   POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       10-29-93  GJF   Define entry for initialization section (used to be
*                       in i386\cinitclk.asm). Also, deleted old Cruiser
*                       support.
*       04-12-94  GJF   Made definition of __itimeb conditional on ndef
*                       DLL_FOR_WIN32S.
*       02-10-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       07-25-96  RDK   Moved PMAC init ptr here from tzset.c.
*       08-26-97  GJF   Use GetSystemTimeAsFileTime API.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <time.h>

#ifdef  _POSIX_
#include <posix/sys/times.h>
#else   /* ndef _POSIX_ */
#include <internal.h>
#include <sys\timeb.h>
#include <sys\types.h>
#endif  /* _POSIX_ */


#ifndef _POSIX_

int __cdecl __inittime(void);

#ifdef  _MSC_VER

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __inittime;

#pragma data_seg()

#endif  /* _MSC_VER */

static unsigned __int64 start_tics;

/***
*clock_t clock() - Return the processor time used by this process.
*
*Purpose:
*       This routine calculates how much time the calling process
*       has used.  At startup time, startup calls __inittime which stores
*       the initial time.  The clock routine calculates the difference
*       between the current time and the initial time.
*
*       Clock must reference _cinitime so that _cinitim.asm gets linked in.
*       That routine, in turn, puts __inittime in the startup initialization
*       routine table.
*
*Entry:
*       No parameters.
*       itime is a static structure of type timeb.
*
*Exit:
*       If successful, clock returns the number of CLK_TCKs (milliseconds)
*       that have elapsed.  If unsuccessful, clock returns -1.
*
*Exceptions:
*       None.
*
*******************************************************************************/

clock_t __cdecl clock (
        void
        )
{
        unsigned __int64 current_tics;
        FILETIME ct;

        GetSystemTimeAsFileTime( &ct );

        current_tics = (unsigned __int64)ct.dwLowDateTime + 
                       (((unsigned __int64)ct.dwHighDateTime) << 32);

        /* calculate the elapsed number of 100 nanosecond units */
        current_tics -= start_tics;

        /* return number of elapsed milliseconds */
        return (clock_t)(current_tics / 10000);
}

/***
*int __inittime() - Initialize the time location
*
*Purpose:
*       This routine stores the time of the process startup.
*       It is only linked in if the user issues a clock runtime call.
*
*Entry:
*       No arguments.
*
*Exit:
*       Returns 0 to indicate no error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl __inittime (
        void
        )
{
        FILETIME st;

        GetSystemTimeAsFileTime( &st );

        start_tics = (unsigned __int64)st.dwLowDateTime + 
                     (((unsigned __int64)st.dwHighDateTime) << 32);

        return 0;
}

#else   /* _POSIX_ */

/***
*clock_t clock() - Return the processor time used by this process.
*
*Purpose:
*       This routine calculates how much time the calling process
*       has used. It uses the POSIX system call times().
*
*
*Entry:
*       No parameters.
*
*Exit:
*       If successful, clock returns the number of CLK_TCKs (milliseconds)
*       that have elapsed.  If unsuccessful, clock returns -1.
*
*Exceptions:
*       None.
*
*******************************************************************************/

clock_t __cdecl clock (
        void
        )
{
        struct tms now;
        clock_t elapsed;

        elapsed= times(&now);
        if (elapsed == (clock_t) -1)
            return((clock_t) -1);
        else
            return(now.tms_utime+now.tms_stime);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\ctime.c ===
/***
*ctime.c - convert time argument into ASCII string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains ctime() - convert time value to string
*
*Revision History:
*       03-??-84  RLB   initial version
*       05-??-84  DFW   split off into seperate module
*       02-18-87  JCR   put in NULL ptr support
*       04-10-87  JCR   changed long declaration ot time_t and added const.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       05-21-90  GJF   Fixed compiler warning.
*       10-04-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       08-30-99  PML   Fix function header comment, detab.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <stddef.h>
#include <tchar.h>

/***
*_TSCHAR *ctime(time) - converts a time stored as a long to a ASCII string
*
*Purpose:
*       Converts a time stored as a time_t to an ASCII string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       time_t *time - time value in XENIX format
*
*Exit:
*       returns pointer to static string or NULL if time is before
*       Jan 1 1980.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tctime (
        const time_t *timp
        )
{
        struct tm *tmtemp;

        if ((tmtemp=localtime(timp)) != NULL)
                return(_tasctime((const struct tm *)tmtemp));
        else
                return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\days.c ===
/***
*days.c - static arrays with days from beg of year for each month
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains static arrays used by gmtime and statconv to determine
*	date and time values.  Shows days from beg of year.
*
*Revision History:
*	03-??-84  RLB	initial version
*	05-??-84  DFW	split out definitions from ctime routines
*	07-03-89  PHG	removed _NEAR_ for 386
*	03-20-90  GJF	Fixed copyright.
*
*******************************************************************************/

#include <internal.h>

int _lpdays[] = {
	-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
};

int _days[] = {
	-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\asctime.c ===
/***
*asctime.c - convert date/time structure to ASCII string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains asctime() - convert a date/time structure to ASCII string.
*
*Revision History:
*	03-??-84  RLB	Module created
*	05-??-84  DCW	Removed use of sprintf, to avoid loading stdio
*			functions
*	04-13-87  JCR	Added "const" to declarations
*	05-21-87  SKS	Declare the static buffer and helper routines as NEAR
*			Replace store_year() with in-line code
*
*	11-24-87  WAJ	allocated a static buffer for each thread.
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-24-88  PHG	Merged DLL and normal versions; Removed initializers to
*			save memory
*	06-06-89  JCR	386 mthread support
*	03-20-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h>, removed #include <register.h>, fixed
*			the copyright and removed some leftover 16-bit support.
*			Also, cleaned up the formatting a bit.
*	08-16-90  SBM	Compiles cleanly with -W3
*	10-04-90  GJF	New-style function declarators.
*	07-17-91  GJF	Multi-thread support for Win32 [_WIN32_].
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	11-01-93  CFW	Enable Unicode variant, rip out Cruiser.
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	01-10-95  CFW	Debug CRT allocs.
*	02-09-95  GJF	Replaced WPRFLAG with _UNICODE.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <mtdll.h>
#ifdef	_MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <tchar.h>
#include <dbgint.h>

#define _ASCBUFSIZE   26
static _TSCHAR buf[_ASCBUFSIZE];

/*
** This prototype must be local to this file since the procedure is static
*/

static _TSCHAR * __cdecl store_dt(_TSCHAR *, int);

static _TSCHAR * __cdecl store_dt (
	REG1 _TSCHAR *p,
	REG2 int val
	)
{
	*p++ = (_TSCHAR)(_T('0') + val / 10);
	*p++ = (_TSCHAR)(_T('0') + val % 10);
	return(p);
}


/***
*char *asctime(time) - convert a structure time to ascii string
*
*Purpose:
*	Converts a time stored in a struct tm to a charcater string.
*	The string is always exactly 26 characters of the form
*		Tue May 01 02:34:55 1984\n\0
*
*Entry:
*	struct tm *time - ptr to time structure
*
*Exit:
*	returns pointer to static string with time string.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tasctime (
	REG1 const struct tm *tb
	)
{
#ifdef	_MT

	_ptiddata ptd = _getptd();

	REG2 _TSCHAR *p;			/* will point to asctime buffer */
	_TSCHAR *retval;			/* holds retval pointer */

#else

	REG2 _TSCHAR *p = buf;

#endif

	int day, mon;
	int i;

#ifdef	_MT

	/* Use per thread buffer area (malloc space, if necessary) */

#ifdef	_UNICODE
	if ( (ptd->_wasctimebuf != NULL) || ((ptd->_wasctimebuf =
	    (wchar_t *)_malloc_crt(_ASCBUFSIZE * sizeof(wchar_t))) != NULL) )
		p = ptd->_wasctimebuf;
#else
	if ( (ptd->_asctimebuf != NULL) || ((ptd->_asctimebuf =
	    (char *)_malloc_crt(_ASCBUFSIZE * sizeof(char))) != NULL) )
		p = ptd->_asctimebuf;
#endif
	else
		p = buf;	/* error: use static buffer */

	retval = p;			/* save return value for later */

#endif

	/* copy day and month names into the buffer */

	day = tb->tm_wday * 3;		/* index to correct day string */
	mon = tb->tm_mon * 3;		/* index to correct month string */
	for (i=0; i < 3; i++,p++) {
		*p = *(__dnames + day + i);
		*(p+4) = *(__mnames + mon + i);
	}

	*p = _T(' ');			/* blank between day and month */

	p += 4;

	*p++ = _T(' ');
	p = store_dt(p, tb->tm_mday);	/* day of the month (1-31) */
	*p++ = _T(' ');
	p = store_dt(p, tb->tm_hour);	/* hours (0-23) */
	*p++ = _T(':');
	p = store_dt(p, tb->tm_min);	/* minutes (0-59) */
	*p++ = _T(':');
	p = store_dt(p, tb->tm_sec);	/* seconds (0-59) */
	*p++ = _T(' ');
	p = store_dt(p, 19 + (tb->tm_year/100)); /* year (after 1900) */
	p = store_dt(p, tb->tm_year%100);
	*p++ = _T('\n');
	*p = _T('\0');

#ifdef	_POSIX_
	/* Date should be padded with spaces instead of zeroes. */

	if (_T('0') == buf[8])
		buf[8] = _T(' ');
#endif

#ifdef	_MT
	return (retval);
#else
	return ((_TSCHAR *) buf);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\ctime64.c ===
/***
*ctime64.c - convert time argument to a string
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _ctime64() - convert time value to string
*
*Revision History:
*       05-21-98  GJF   Created.
*       08-30-99  PML   Fix function header comment.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <stddef.h>
#include <tchar.h>

/***
*_TSCHAR *_ctime64(time) - converts a time stored as a __time64_t to a string
*
*Purpose:
*       Converts a time stored as a __time64_t to a string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       __time64_t *time - time value in internal, 64-bit format
*
*Exit:
*       returns pointer to static string or NULL if an error occurs
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tctime64 (
        const __time64_t *timp
        )
{
        struct tm *tmtemp;

        if ( (tmtemp = _localtime64(timp)) != NULL )
            return(_tasctime((const struct tm *)tmtemp));
        else
            return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\difftime.c ===
/***
*difftime.c - return difference between two times as a double
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Find difference between two time in seconds.
*
*Revision History:
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       08-15-89  PHG   Made MTHREAD version _pascal
*       11-20-89  JCR   difftime() always _cdecl (not pascal even under
*                       mthread)
*       03-20-90  GJF   Replaced _LOAD_DS with CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       10-04-90  GJF   New-style function declarator.
*       05-19-92  DJM   ifndef for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       08-30-99  PML   Fix function header comment, detab.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>

/***
*double difftime(b, a) - find difference between two times
*
*Purpose:
*       returns difference between two times (b-a)
*
*Entry:
*       time_t a, b - times to difference
*
*Exit:
*       returns a double with the time in seconds between two times
*
*Exceptions:
*
*******************************************************************************/

double __cdecl difftime (
        time_t b,
        time_t a
        )
{
        return( (double)( b - a ) );
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\dtoxtm64.c ===
/***
*dtoxtm64.c - convert OS local time to __time64_t
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __loctotime64_t() - convert OS local time to internal format
*       (__time64_t).
*
*Revision History:
*       05-21-98  GJF   Created.
*       10-19-98  GJF   Fill in tm_min and tm_sec before calling _isindst
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*__time64_t __loctotime64_t(yr, mo, dy, hr, mn, sc, dstflag) - converts OS 
*       local time to internal time format (i.e., a __time64_t value)
*
*Purpose:
*       Converts a local time value, obtained in a broken down format from
*       the host OS, to __time64_t format (i.e., the number elapsed seconds
*       since 01-01-70, 00:00:00, UTC).
*
*Entry:
*       int yr, mo, dy -    date
*       int hr, mn, sc -    time
*       int dstflag    -    1 if Daylight Time, 0 if Standard Time, -1 if
*                           not specified.
*
*Exit:
*       Returns calendar time value.
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl __loctotime64_t (
        int yr,         /* 0 based */
        int mo,         /* 1 based */
        int dy,         /* 1 based */
        int hr,
        int mn,
        int sc,
        int dstflag )
{
        int tmpdays;
        __time64_t tmptim;
        struct tm tb;

        /*
         * Do a quick range check on the year and convert it to a delta
         * off of 1900.
         */
        if ( ((long)(yr -= 1900) < _BASE_YEAR) || ((long)yr > _MAX_YEAR64) )
            return (__time64_t)(-1);

        /*
         * Compute the number of elapsed days in the current year.
         */
        tmpdays = dy + _days[mo - 1];
        if ( _IS_LEAP_YEAR(yr) && (mo > 2) )
            tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((__time64_t)yr - _BASE_YEAR) * 365

                 /* one day for each elapsed leap year */
                 + (__time64_t)_ELAPSED_LEAP_YEARS(yr)

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24 + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60 + mn)

                 /* convert to seconds and add in sec */
                 * 60 + sc;
        /*
         * Account for time zone.
         */
        __tzset();
        tmptim += _timezone;

        /*
         * Fill in enough fields of tb for _isindst(), then call it to
         * determine DST.
         */
        tb.tm_yday = tmpdays;
        tb.tm_year = yr;
        tb.tm_mon  = mo - 1;
        tb.tm_hour = hr;
        tb.tm_min  = mn;
        tb.tm_sec  = sc;
        if ( (dstflag == 1) || ((dstflag == -1) && _daylight && 
                                _isindst(&tb)) )
            tmptim += _dstbias;
        return(tmptim);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\dtoxtime.c ===
/***
*dtoxtime.c - convert OS local time to time_t
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __loctotime_t() - convert OS local time to internal format
*       (time_t).
*
*Revision History:
*       03-??-84  RLB   written
*       11-18-87  SKS   change tzset() to __tzset(), change source file name
*                       make _dtoxtime a near procedure
*       01-26-88  SKS   _dtoxtime is no longer a near procedure (for QC)
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       10-04-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       05-19-92  DJM   ifndef for POSIX build.
*       03-30-93  GJF   Revised. Old _dtoxtime is replaced by __gmtotime_t,
*                       which is more useful on Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-06-93  GJF   Rewrote computation to avoid compiler warnings.
*       07-20-93  GJF   Replaced __gmtotime_t with function very similar to
*                       _dostotime_t() in 16-bit C 8.00. The reason for the
*                       change is that only local time values can be trusted
*                       on a Win32 platform. System time may be UTC (as
*                       documented), and is on NT, or may be the same as
*                       local time, as on Win32S and Win32C
*       02-10-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       09-25-95  GJF   Added DST flag to __loctotime_t's arguments. Also, 
*                       use _dstbias instead of assuming a DST bias of -3600.
*       02-07-98  GJF   Changes for Win64: replaced long type with time_t
*       10-19-98  GJF   Fill in tm_min and tm_sec before calling _isindst
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added support for years beyond 2099.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*time_t __loctotime_t(yr, mo, dy, hr, mn, sc, dstflag) - converts OS local
*       time to internal time format (i.e., a time_t value)
*
*Purpose:
*       Converts a local time value, obtained in a broken down format from
*       the host OS, to time_t format (i.e., the number elapsed seconds since
*       01-01-70, 00:00:00, UTC).
*
*Entry:
*       int yr, mo, dy -    date
*       int hr, mn, sc -    time
*       int dstflag    -    1 if Daylight Time, 0 if Standard Time, -1 if
*                           not specified.
*
*Exit:
*       Returns calendar time value.
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __loctotime_t (
        int yr,         /* 0 based */
        int mo,         /* 1 based */
        int dy,         /* 1 based */
        int hr,
        int mn,
        int sc,
        int dstflag )
{
        int tmpdays;
        time_t tmptim;
        struct tm tb;

        /*
         * Do a quick range check on the year and convert it to a delta
         * off of 1900.
         */
        if ( ((yr -= 1900) < _BASE_YEAR) || (yr > _MAX_YEAR) )
                return (time_t)(-1);

        /*
         * Compute the number of elapsed days in the current year. Note the
         * test for a leap year would fail in the year 2100, if this was in
         * range (which it isn't).
         */
        tmpdays = dy + _days[mo - 1];
        if ( _IS_LEAP_YEAR(yr) && (mo > 2) )
                tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((time_t)yr - _BASE_YEAR) * 365

                 /* one day for each elapsed leap year */
                 + (time_t)_ELAPSED_LEAP_YEARS(yr)

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24 + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60 + mn)

                 /* convert to seconds and add in sec */
                 * 60 + sc;
        /*
         * Account for time zone.
         */
        __tzset();
        tmptim += _timezone;

        /*
         * Fill in enough fields of tb for _isindst(), then call it to
         * determine DST.
         */
        tb.tm_yday = tmpdays;
        tb.tm_year = yr;
        tb.tm_mon  = mo - 1;
        tb.tm_hour = hr;
        tb.tm_min  = mn;
        tb.tm_sec  = sc;
        if ( (dstflag == 1) || ((dstflag == -1) && _daylight && 
                                _isindst(&tb)) )
                tmptim += _dstbias;
        return(tmptim);
}


#if 0

/*
 * THE FOLLOWING FUNCTION WAS DEFINED AND USED (IN PLACE OF THE ONE ABOVE)
 * FOR THE CUDA PRODUCT AND THE NT 1.0 SDK. IT WAS REPLACED (BY THE ONE
 * ABOVE) BECAUSE NON-NT WIN32 PLATFORMS MAY USE LOCAL TIME FOR SYSTEM TIME,
 * RATHER THAN UTC.
 */

/***
*time_t __gmtotime_t(yr, mo, dy, hr, mn, sc) - convert broken down time (UTC)
*   to time_t
*
*Purpose:
*       Converts a broken down UTC (GMT) time to time_t. This is similar to
*       _mkgmtime() except there is minimal overflow checking and no updating
*       of the input values (i.e., the fields of tm structure).
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns time_t value
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __gmtotime_t (
        int yr,     /* 0 based */
        int mo,     /* 1 based */
        int dy,     /* 1 based */
        int hr,
        int mn,
        int sc
        )
{
        int tmpdays;
        long tmptim;

        /*
         * Do a quick range check on the year and convert it to a delta
         * off of 1900.
         */
        if ( ((long)(yr -= 1900) < _BASE_YEAR) || ((long)yr > _MAX_YEAR) )
                return (time_t)(-1);

        /*
         * Compute the number of elapsed days in the current year minus
         * one. Note the test for leap year and the would fail in the year 2100
         * if this was in range (which it isn't).
         */
        tmpdays = dy + _days[mo - 1];
        if ( !(yr & 3) && (mo > 2) )
                /*
                 * in a leap year, after Feb. add one day for elapsed
                 * Feb 29.
                 */
                tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((long)yr - _BASE_YEAR) * 365L

                 /* one day for each elapsed leap year */
                 + (long)((yr - 1) >> 2) - _LEAP_YEAR_ADJUST

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24L + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60L + mn)

                 /* convert to seconds and add in sec */
                 * 60L + sc;

        return (tmptim >= 0) ? (time_t)tmptim : (time_t)(-1);
}

#endif

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\ftime.c ===
/***
*ftime.c - return system time
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns the system date/time in a structure form.
*
*Revision History:
*       03-??-84  RLB   initial version
*       05-17-86  SKS   ported to OS/2
*       03-09-87  SKS   correct Daylight Savings Time flag
*       11-18-87  SKS   Change tzset() to __tzset()
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       04-12-89  JCR   New syscall interface
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed some leftover 16-bit support
*                       and fixed the copyright. Also, cleaned up the
*                       formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       08-13-90  SBM   Compiles cleanly with -W3
*       08-20-90  SBM   Removed old incorrect, redundant tp->dstflag assignment
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-21-91  GJF   ANSI naming.
*       01-23-92  GJF   Change in time zone field name for Win32, to support
*                       crtdll.dll [_WIN32_].
*       03-30-93  GJF   Revised to use mktime(). Also purged Cruiser support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Restore correct spelling of "timezone" struct member.
*       07-15-93  GJF   Call __tzset() instead of _tzset().
*       02-10-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       01-15-98  GJF   Complete rewrite of _ftime to eliminate incorrect dst
*                       status during the fall-back hour.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  GB    Remove #inlcude <dostypes.h>
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <msdos.h>
#include <dos.h>
#include <stdlib.h>
#include <windows.h>
#include <internal.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/*
 * Cache for the minutes count for with DST status was last assessed
 */
static time_t elapsed_minutes_cache = 0;

/*
 * Three values of dstflag_cache
 */
#define DAYLIGHT_TIME   1
#define STANDARD_TIME   0
#define UNKNOWN_TIME    -1

/*
 * Cache for the last determined DST status
 */
static int dstflag_cache = UNKNOWN_TIME;

/***
*void _ftime(timeptr) - return DOS time in a structure
*
*Purpose:
*       returns the current DOS time in a struct timeb structure
*
*Entry:
*       struct timeb *timeptr - structure to fill in with time
*
*Exit:
*       no return value -- fills in structure
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl _ftime (
        struct _timeb *tp
        )
{
        FT nt_time;
        time_t t;
        TIME_ZONE_INFORMATION tzinfo;
        DWORD tzstate;

        __tzset();

        tp->timezone = (short)(_timezone / 60);

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        /*
         * Obtain the current DST status. Note the status is cached and only
         * updated once per minute, if necessary.
         */
        if ( (t = (time_t)(nt_time.ft_scalar / 600000000i64))
             != elapsed_minutes_cache )
        {
            if ( (tzstate = GetTimeZoneInformation( &tzinfo )) != 0xFFFFFFFF ) 
            {
                /*
                 * Must be very careful in determining whether or not DST is
                 * really in effect.
                 */
                if ( (tzstate == TIME_ZONE_ID_DAYLIGHT) &&
                     (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                    dstflag_cache = DAYLIGHT_TIME;
                else
                    /*
                     * When in doubt, assume standard time
                     */
                    dstflag_cache = STANDARD_TIME;
            }
            else
                dstflag_cache = UNKNOWN_TIME;

            elapsed_minutes_cache = t;
        }

        tp->dstflag = (short)dstflag_cache;

        tp->millitm = (unsigned short)((nt_time.ft_scalar / 10000i64) % 
                      1000i64);

        tp->time = (time_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\ftime64.c ===
/***
*ftime64.c - return system time
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns the system date/time in a structure form.
*
*Revision History:
*       05-22-98  GJF   Created.
*
*******************************************************************************/


#include <cruntime.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <msdos.h>
#include <dos.h>
#include <stdlib.h>
#include <windows.h>
#include <internal.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/*
 * Cache for the minutes count for with DST status was last assessed
 */
static __time64_t elapsed_minutes_cache;

/*
 * Three values of dstflag_cache
 */
#define DAYLIGHT_TIME   1
#define STANDARD_TIME   0
#define UNKNOWN_TIME    -1

/*
 * Cache for the last determined DST status
 */
static int dstflag_cache = UNKNOWN_TIME;

/***
*void _ftime(timeptr) - return DOS time in a structure
*
*Purpose:
*       returns the current DOS time in a struct timeb structure
*
*Entry:
*       struct timeb *timeptr - structure to fill in with time
*
*Exit:
*       no return value -- fills in structure
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl _ftime64 (
        struct __timeb64 *tp
        )
{
        FT nt_time;
        __time64_t t;
        TIME_ZONE_INFORMATION tzinfo;
        DWORD tzstate;

        __tzset();

        tp->timezone = (short)(_timezone / 60);

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        /*
         * Obtain the current DST status. Note the status is cached and only
         * updated once per minute, if necessary.
         */
        if ( (t = (__time64_t)(nt_time.ft_scalar / 600000000i64))
             != elapsed_minutes_cache )
        {
            if ( (tzstate = GetTimeZoneInformation( &tzinfo )) != 0xFFFFFFFF ) 
            {
                /*
                 * Must be very careful in determining whether or not DST is
                 * really in effect.
                 */
                if ( (tzstate == TIME_ZONE_ID_DAYLIGHT) &&
                     (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                    dstflag_cache = DAYLIGHT_TIME;
                else
                    /*
                     * When in doubt, assume standard time
                     */
                    dstflag_cache = STANDARD_TIME;
            }
            else
                dstflag_cache = UNKNOWN_TIME;

            elapsed_minutes_cache = t;
        }

        tp->dstflag = (short)dstflag_cache;

        tp->millitm = (unsigned short)((nt_time.ft_scalar / 10000i64) % 
                      1000i64);

        tp->time = (__time64_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\gmtime64.c ===
/***
*gmtime64.c - breaks down a time value into GMT date/time info
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _gmtime64() - breaks the clock value down into GMT time/date
*       information; returns pointer to structure with the data.
*
*Revision History:
*       05-13-98  GJF   Created. Adapted from Win64 version of _gmtime64.c.
*       06-12-98  GJF   Fixed elapsed years calculation.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>
#ifdef  _MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <dbgint.h>

static struct tm tb = { 0 };    /* time block */

/***
*struct tm *_gmtime64(timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in internal 64-bit format to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const __time64_t *timp - pointer to time_t value to convert
*
*Exit:
*       returns pointer to filled-in tm structure.
*       returns NULL if *timp < 0
*
*Exceptions:
*
*******************************************************************************/

struct tm * __cdecl _gmtime64 (
        const __time64_t *timp
        )
{

        __time64_t caltim = *timp;      /* calendar time to convert */
        int islpyr = 0;                 /* is-current-year-a-leap-year flag */
        int tmptim;
        int *mdays;                     /* pointer to days or lpdays */

#ifdef  _MT

        struct tm *ptb;                 /* will point to gmtime buffer */
        _ptiddata ptd = _getptd();

#else
        struct tm *ptb = &tb;
#endif

        if ( (caltim < 0) || (caltim > _MAX__TIME64_T) )
                return(NULL);

#ifdef  _MT

        /* Use per thread buffer area (malloc space, if necessary) */

        if ( (ptd->_gmtimebuf != NULL) || ((ptd->_gmtimebuf =
            _malloc_crt(sizeof(struct tm))) != NULL) )
                ptb = ptd->_gmtimebuf;
        else
                ptb = &tb;      /* malloc error: use static buffer */

#endif

        /*
         * Determine the years since 1900. Start by ignoring leap years.
         */
        tmptim = (int)(caltim / _YEAR_SEC) + 70;
        caltim -= ((__time64_t)(tmptim - 70) * _YEAR_SEC);

        /*
         * Correct for elapsed leap years
         */
        caltim -= ((__time64_t)_ELAPSED_LEAP_YEARS(tmptim) * _DAY_SEC);

        /*
         * If we have underflowed the __time64_t range (i.e., if caltim < 0), 
         * back up one year, adjusting the correction if necessary.
         */
        if ( caltim < 0 ) {
            caltim += (__time64_t)_YEAR_SEC;
            tmptim--;
            if ( _IS_LEAP_YEAR(tmptim) ) {
                caltim += _DAY_SEC;
                islpyr++;
            }
        }
        else
            if ( _IS_LEAP_YEAR(tmptim) )
                islpyr++;

        /*
         * tmptim now holds the value for tm_year. caltim now holds the
         * number of elapsed seconds since the beginning of that year.
         */
        ptb->tm_year = tmptim;

        /*
         * Determine days since January 1 (0 - 365). This is the tm_yday value.
         * Leave caltim with number of elapsed seconds in that day.
         */
        ptb->tm_yday = (int)(caltim / _DAY_SEC);
        caltim -= (__time64_t)(ptb->tm_yday) * _DAY_SEC;

        /*
         * Determine months since January (0 - 11) and day of month (1 - 31)
         */
        if ( islpyr )
            mdays = _lpdays;
        else
            mdays = _days;


        for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

        ptb->tm_mon = --tmptim;

        ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

        /*
         * Determine days since Sunday (0 - 6)
         */
        ptb->tm_wday = ((int)(*timp / _DAY_SEC) + _BASE_DOW) % 7;

        /*
         *  Determine hours since midnight (0 - 23), minutes after the hour
         *  (0 - 59), and seconds after the minute (0 - 59).
         */
        ptb->tm_hour = (int)(caltim / 3600);
        caltim -= (__time64_t)ptb->tm_hour * 3600L;

        ptb->tm_min = (int)(caltim / 60);
        ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

        ptb->tm_isdst = 0;
        return( (struct tm *)ptb );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\loctim64.c ===
/***
*loctim64.c - Convert __time64_t value to time structure
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts time stored as a __time64_t value to a structure of type
*       struct tm expressed as local time.
*
*Revision History:
*       05-11-98  GJF   Created, adapted from the Win64 version.
*       09-25-98  GJF   Set tm_isdst, when appropriate, at beginning/end of the
*                       Epoch
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <time.h>
#include <stddef.h>
#include <ctime.h>
#include <internal.h>

/***
*struct tm *_localtime64(ptime) - convert __time64_t value to tm structure
*
*Purpose:
*       Convert a value in 64-bit internal (__time64_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime, _gtime64, localtime and _localtime64() all use a single 
*           statically allocated buffer. Each call to one of these routines 
*           destroys the contents of the previous call.
*       (3) It is assumed that __time64_t is a 64-bit integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       __time64_t *ptime - pointer to a long time value
*
*Exit:
*       If *ptime is non-negative, returns a pointer to the tm structure.
*       Otherwise, returns NULL.
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

struct tm * __cdecl _localtime64 (
        const __time64_t *ptime
        )
{
        REG1 struct tm *ptm;
        __time64_t ltime;

        /*
         * Check for illegal __time64_t value
         */
        if ( (*ptime < 0) || (*ptime > _MAX__TIME64_T) )
                return( NULL );

        __tzset();

        if ( *ptime > 3 * _DAY_SEC ) {
                /*
                 * The date does not fall within the first three representable
                 * days of the Epoch. Therefore, there is no possibility of 
                 * underflowing the __time64_t representation as we compensate 
                 * for timezone and Daylight Savings Time.
                 */

                ltime = *ptime - _timezone;
                ptm = _gmtime64( &ltime );

                /*
                 * Check and adjust for Daylight Saving Time.
                 */
                if ( _daylight && _isindst( ptm ) ) {
                        ltime -= _dstbias;
                        ptm = _gmtime64( &ltime );
                        ptm->tm_isdst = 1;
                }
        }
        else {
                ptm = _gmtime64( ptime );

                /*
                 * The date falls with the first three days of the Epoch.
                 * It is possible the time_t representation would underflow
                 * while compensating for timezone and Daylight Savings Time
                 * Therefore, make the timezone and Daylight Savings Time
                 * adjustments directly in the tm structure. The beginning of
                 * the Epoch is 00:00:00, 01-01-70 (UTC).
                 *
                 * First, adjust for the timezone.
                 */
                if ( _isindst(ptm) ) {
                        ltime = (__time64_t)ptm->tm_sec - (_timezone + _dstbias);
                        ptm->tm_isdst;
                }
                else
                        ltime = (__time64_t)ptm->tm_sec - _timezone;

                ptm->tm_sec = (int)(ltime % 60);
                if ( ptm->tm_sec < 0 ) {
                        ptm->tm_sec += 60;
                        ltime -= 60;
                }

                ltime = (__time64_t)ptm->tm_min + ltime/60;
                ptm->tm_min = (int)(ltime % 60);
                if ( ptm->tm_min < 0 ) {
                        ptm->tm_min += 60;
                        ltime -= 60;
                }

                ltime = (__time64_t)ptm->tm_hour + ltime/60;
                ptm->tm_hour = (int)(ltime % 24);
                if ( ptm->tm_hour < 0 ) {
                        ptm->tm_hour += 24;
                        ltime -=24;
                }

                ltime /= 24;

                if ( ltime < 0 ) {
                        /*
                         * It is possible to underflow the tm_mday and tm_yday
                         * fields. If this happens, then adjusted date must
                         * lie in December 1969.
                         */
                        ptm->tm_wday = (ptm->tm_wday + 7 + (int)ltime) % 7;
                        if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                ptm->tm_mday += 31;
                                ptm->tm_yday = 364;
                                ptm->tm_mon = 11;
                                ptm->tm_year--;
                        }
                        else {
                                ptm->tm_yday += (int)ltime;
                        }
                }
        }


        return(ptm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\gmtime.c ===
/***
*gmtime.c - breaks down a time value into GMT date/time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines gmtime() - breaks the clock value down into GMT time/date
*       information; return pointer to structure with the data.
*
*Revision History:
*       01-??-84  RLB   Module created
*       05-??-84  DCW   Split off from rest off ctime routines.
*       02-18-87  JCR   For MS C, gmtime now returns NULL for out of range
*                       time/date.      (This is for ANSI compatibility.)
*       04-10-87  JCR   Changed long declaration to time_t and added const
*       05-21-87  SKS   Declare "struct tm tb" as NEAR data
*       11-10-87  SKS   Removed IBMC20 switch
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-24-88  PHG   Merge DLL and regular versions
*       06-06-89  JCR   386 mthread support
*       11-06-89  KRS   Add (unsigned) to handle years 2040-2099 correctly
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       10-04-90  GJF   New-style function declarator.
*       07-17-91  GJF   Multi-thread support for Win32 [_WIN32_].
*       02-17-93  GJF   Changed for new _getptd().
*       03-24-93  GJF   Propagated changes from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-07-98  GJF   Changes for Win64: replaced long with time_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>
#ifdef _MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <dbgint.h>

static struct tm tb = { 0 };    /* time block */

/***
*struct tm *gmtime(timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in internal format (time_t), to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const time_t *timp - pointer to time_t value to convert
*
*Exit:
*       returns pointer to filled-in tm structure.
*       returns NULL if *timp < 0L
*
*Exceptions:
*
*******************************************************************************/

struct tm * __cdecl gmtime (
        const time_t *timp
        )
{

        time_t caltim = *timp;          /* calendar time to convert */
        int islpyr = 0;                 /* is-current-year-a-leap-year flag */
        REG1 int tmptim;
        REG3 int *mdays;                /* pointer to days or lpdays */

#ifdef  _MT

        REG2 struct tm *ptb;            /* will point to gmtime buffer */
        _ptiddata ptd = _getptd();

#else
        REG2 struct tm *ptb = &tb;
#endif

        if ( caltim < 0 )
                return(NULL);

#ifdef  _MT

        /* Use per thread buffer area (malloc space, if necessary) */

        if ( (ptd->_gmtimebuf != NULL) || ((ptd->_gmtimebuf =
            _malloc_crt(sizeof(struct tm))) != NULL) )
                ptb = ptd->_gmtimebuf;
        else
                ptb = &tb;      /* malloc error: use static buffer */

#endif

        /*
         * Determine years since 1970. First, identify the four-year interval
         * since this makes handling leap-years easy (note that 2000 IS a
         * leap year and 2100 is out-of-range).
         */
        tmptim = (int)(caltim / _FOUR_YEAR_SEC);
        caltim -= ((time_t)tmptim * _FOUR_YEAR_SEC);

        /*
         * Determine which year of the interval
         */
        tmptim = (tmptim * 4) + 70;         /* 1970, 1974, 1978,...,etc. */

        if ( caltim >= _YEAR_SEC ) {

            tmptim++;                       /* 1971, 1975, 1979,...,etc. */
            caltim -= _YEAR_SEC;

            if ( caltim >= _YEAR_SEC ) {

                tmptim++;                   /* 1972, 1976, 1980,...,etc. */
                caltim -= _YEAR_SEC;

                /*
                 * Note, it takes 366 days-worth of seconds to get past a leap
                 * year.
                 */
                if ( caltim >= (_YEAR_SEC + _DAY_SEC) ) {

                        tmptim++;           /* 1973, 1977, 1981,...,etc. */
                        caltim -= (_YEAR_SEC + _DAY_SEC);
                }
                else {
                        /*
                         * In a leap year after all, set the flag.
                         */
                        islpyr++;
                }
            }
        }

        /*
         * tmptim now holds the value for tm_year. caltim now holds the
         * number of elapsed seconds since the beginning of that year.
         */
        ptb->tm_year = tmptim;

        /*
         * Determine days since January 1 (0 - 365). This is the tm_yday value.
         * Leave caltim with number of elapsed seconds in that day.
         */
        ptb->tm_yday = (int)(caltim / _DAY_SEC);
        caltim -= (time_t)(ptb->tm_yday) * _DAY_SEC;

        /*
         * Determine months since January (0 - 11) and day of month (1 - 31)
         */
        if ( islpyr )
            mdays = _lpdays;
        else
            mdays = _days;


        for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

        ptb->tm_mon = --tmptim;

        ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

        /*
         * Determine days since Sunday (0 - 6)
         */
        ptb->tm_wday = ((int)(*timp / _DAY_SEC) + _BASE_DOW) % 7;

        /*
         *  Determine hours since midnight (0 - 23), minutes after the hour
         *  (0 - 59), and seconds after the minute (0 - 59).
         */
        ptb->tm_hour = (int)(caltim / 3600);
        caltim -= (time_t)ptb->tm_hour * 3600L;

        ptb->tm_min = (int)(caltim / 60);
        ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

        ptb->tm_isdst = 0;
        return( (struct tm *)ptb );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\crts\crtw32\time\mktime64.c ===
/***
*mktime64.c - Convert struct tm value to __time64_t value.
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _mktime64() and _mkgmtime64(), routines to converts a time 
*       value in a tm structure (possibly incomplete) into a __time64_t value,
*       then update (all) the structure fields with "normalized" values.
*
*Revision History:
*       05-07-98  GJF   Created, adapted from Win64 version of mktime.c
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <ctime.h>
#include <time.h>
#include <internal.h>


/*
 * Core function for both _mktime64() and _mkgmtime64()
 */
static __time64_t __cdecl _make__time64_t( struct tm *, int);


/***
*__time64_t _mktime64(tb) - Normalize user time block structure
*
*Purpose:
*       _mktime64 converts a time structure, passed in as an argument, into a
*       64-bit calendar time value in internal format (__time64_t). It also 
*       completes and updates the fields the of the passed in structure with 
*       'normalized' values. There are three practical uses for this routine:
*
*       (1) Convert broken-down time to internal time format (__time64_t).
*       (2) To have _mktime64 fill in the tm_wday, tm_yday, or tm_isdst fields.
*       (3) To pass in a time structure with 'out of range' values for some
*           fields and have _mktime64 "normalize" them (e.g., pass in 1/35/87 and
*           get back 2/4/87).
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mktime64 returns the specified calender time encoded as
*       a __time64_t value. Otherwise, (__time64_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

__time64_t __cdecl _mktime64 (
        struct tm *tb
        )
{
        return( _make__time64_t(tb, 1) );
}


/***
*__time64_t _mkgmtime64(tb) - Convert broken down UTC time to __time64_t
*
*Purpose:
*       Convert a tm structure, passed in as an argument, containing a UTC
*       time value to 64-bit internal format (__time64_t). It also completes
*       and updates the fields the of the passed in structure with 'normalized'
*       values.
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mkgmtime64 returns the calender time encoded as a
*       __time64_t value.
*       Otherwise, (__time64_t)(-1) is returned to indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

__time64_t __cdecl _mkgmtime64 (
        struct tm *tb
        )
{
        return( _make__time64_t(tb, 0) );
}


/***
*static __time64_t make_time_t(tb, ultflag) -
*
*Purpose:
*       Converts a struct tm value to a __time64_t value, then updates the 
*       struct tm value. Either local time or UTC is supported, based on 
*      