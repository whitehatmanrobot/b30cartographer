                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnFocusChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                         LONG idChild, DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    TCHAR           szName[256];
	TCHAR           buffer[100];
    IAccessible*    pIAcc;
    VARIANT         varChild;
	VARIANT         varRole;
	VARIANT         varState;
	BOOL			switchWnd = FALSE;

	hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (FAILED(hr))
		return FALSE;

	// Check for Bogus events...
	if( !IsFocussedItem(hwnd, pIAcc, varChild) )
	{
		pIAcc->Release();
		return FALSE;
	}

	// Ignore the first Start pressed events...
	if ( g_pGlobalData->fStartPressed )
	{
		g_pGlobalData->fStartPressed = FALSE;
		pIAcc->Release();
		return FALSE;
	}

	g_pGlobalData->fDoingPassword = FALSE;
	
	// Have we got a password char in this one
	// if so then tell them and get out
	VariantInit(&varState); 
	hr = pIAcc->get_accState(varChild, &varState);
    if ( FAILED(hr) )
    {
        pIAcc->Release();
        return FALSE;
    }

    if ( varState.vt == VT_EMPTY )
        varState.lVal = 0;
    
	g_pGlobalData->fDoingPassword = (varState.lVal & STATE_SYSTEM_PROTECTED);

	GetClassName(hwnd,buffer,100); // is it Internet Explorer in any of its many forms?
    DBPRINTF(TEXT("OnFocusChangedEvent:  class name = %s\r\n"), buffer);
	g_pGlobalData->fInternetExplorer = IsTridentWindow(buffer);
    g_pGlobalData->fHTML_Help = FALSE;

	if (lstrcmpi(buffer, CLASS_WINSWITCH) == 0)
		switchWnd = TRUE;

	GetClassName(GetForegroundWindow(),buffer,100);
	if ((lstrcmpi(buffer, CLASS_HTMLHELP) == 0)|| (lstrcmpi(buffer, CLASS_IE_FRAME) == 0) ) { // have we got HTML Help?
		g_pGlobalData->fInternetExplorer = TRUE;
		g_pGlobalData->fHTML_Help = TRUE;
	}

    // Check to see if we are getting rapid focus changes
    // Consider using the Time stamp and saving away the last object
    
	VariantInit(&varRole); 

    // If the focus is being set to a list, a combo, or a dialog, 
    // don't say anything. We'll say something when the focus gets
    // set to one of the children.

	hr = pIAcc->get_accRole(varChild, &varRole); // heuristic!
	if ( FAILED(hr) )
	{
        pIAcc->Release();
        return FALSE;
	}

	// Special casing stuff.. Avoid repeatation for list items...
	// Required to correctly process Auto suggest list boxes.
	// As list items also send SelectionChange : AK
	if (varRole.vt == VT_I4 )
    {
		switch ( varRole.lVal )
		{
			case ROLE_SYSTEM_DIALOG:
				pIAcc->Release();
				return FALSE; 
				break;

			case ROLE_SYSTEM_TITLEBAR:
				g_pGlobalData->fMouseUp = FALSE;
				break;

			case ROLE_SYSTEM_LISTITEM:
				g_pGlobalData->fListFocus = TRUE;
				break;

			default:
				break;
		}
	}


	if (idObject == OBJID_WINDOW) 
    {
		SpeakMute(0);
		SpeakStringId(IDS_WINDOW);
		GetWindowText(hwnd, szName, sizeof(szName)/sizeof(TCHAR));	// raid #113789
		SpeakString(szName);
	}

	RECT rcCursor;
	
	if ( pIAcc->accLocation(&rcCursor.left, &rcCursor.top, &rcCursor.right, &rcCursor.bottom, varChild) == S_OK )
	{
        const POINT ptLoc = { rcCursor.left + (rcCursor.right/2), rcCursor.top + (rcCursor.bottom/2) };
  
    	if (g_pGlobalData->fTrackInputFocus && g_pGlobalData->fMouseUp) 
        {
            
            POINT CursorPosition;		
            GetCursorPos(&CursorPosition);
            // mouse to follow if it's not already in rectangle 
            // (e.g manually moving mouse in menu) and mouse button up
    		if (CursorPosition.x < rcCursor.left 
    			|| CursorPosition.x > (rcCursor.left+rcCursor.right)
    			|| CursorPosition.y < rcCursor.top
    			|| CursorPosition.y > (rcCursor.top+rcCursor.bottom))
    		{
            	g_ptMoveCursor.x = ptLoc.x;
            	g_ptMoveCursor.y =  ptLoc.y;

            	// If we set the cursor immediately extraneous events the 
            	// hovering on menu items causes feed back which results 
            	// in the cursor going back and forth between menu items.  
            	// This code sets a timer so that the cursor is set after things settle down
                if ( g_uTimer == 0 )
                    g_uTimer = SetTimer( NULL, 0, 100, TrackCursor );

                // If the focus events are from cursor movement this will ignore the extra
                // event that cause the feed back
                if ( g_pGlobalData->nMsrDoNext != MSR_DONOWT )
                    g_pGlobalData->fMouseUp = FALSE;
    		}
    	}
    	else
    	{
    	    SetSecondary(ptLoc.x, ptLoc.y, FALSE);
    	}
	}
	OBJINFO objCurrent;

	objCurrent.hwnd = hwnd;
	objCurrent.plObj = (long*)pIAcc;
	objCurrent.varChild = varChild;
	
	// If the event is from the switch window, 
	// Then mute the current speech before proceeding...AK
	if ( switchWnd && g_pGlobalData->fListFocus )
		SpeakMute(0);

    DBPRINTF(TEXT("OnFocusChangedEvent:  Calling SpeakObjectInfo...\r\n"));
	SpeakObjectInfo(&objCurrent,TRUE);
	
	if (g_pGlobalData->fDoingPassword)
	{
		pIAcc->Release();
		return FALSE;
	}

	if (g_pGlobalData->nSpeakWindowSoon) 
    {   
        DBPRINTF(TEXT("OnFocusChangedEvent:  Calling SpeakWindow\r\n"));
		SpeakWindow(0);
		g_pGlobalData->nSpeakWindowSoon = FALSE;
	}
    pIAcc->Release();

    return TRUE;
}


/*************************************************************************
    Function:   OnStateChangedEvent
    Purpose:    Receives focus events
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnStateChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                         LONG idChild, DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    IAccessible*    pIAcc;
    VARIANT         varChild;
	VARIANT         varRole;

	hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (FAILED(hr))
        return (FALSE);

	// Check for Bogus events...
	if( !IsFocussedItem(hwnd, pIAcc, varChild) )
	{
		pIAcc->Release();
		return (FALSE);
	}

	VariantInit(&varRole); 

	hr = pIAcc->get_accRole(varChild, &varRole); 
    if ( FAILED(hr) )
    {
        pIAcc->Release();
        return FALSE;
    }
	    
	// Special casing stuff.. Handle State change for 
	// Outline items only for now
	if (varRole.vt == VT_I4 )
    {
		switch ( varRole.lVal )
		{
			case ROLE_SYSTEM_OUTLINEITEM:
				{
					OBJINFO objCurrent;

					objCurrent.hwnd = hwnd;
					objCurrent.plObj = (long*)pIAcc;
					objCurrent.varChild = varChild;
					
					SpeakObjectInfo(&objCurrent,TRUE);
				}
				break;

			default:
				break;
		}
	}

    pIAcc->Release();
    return(TRUE);
}

/*************************************************************************
    Function:   OnLocationChangedEvent
    Purpose:    Receives location change events - for the caret
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnLocationChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                            LONG idChild, DWORD dwmsTimeStamp)
{
	//
	// Get the caret position and save it.
	//
	
	// flag set by key down code - here do appropriate action after 
	// caret has moved

	if (g_pGlobalData->nMsrDoNext) 
	{ // read char, word etc.
		WORD    wLineNumber;
		WORD    wLineIndex;
		WORD    wLineLength;
		DWORD   dwGetSel;
		DWORD    wStart;
		DWORD    wEnd;
		WORD    wColNumber;
		WORD    wEndWord;
        LPTSTR  pszTextShared;
        HANDLE  hProcess;
        int     nSomeInt;
		int *p; // PB 22 Nov 1998 Use this to get the size of the buffer in to array
		DWORD   LineStart;
		// Send the EM_GETSEL message to the edit control.
		// The low-order word of the return value is the character
		// position of the caret relative to the first character in the
		// edit control.
		dwGetSel = (WORD)SendMessage(hwnd, EM_GETSEL, (WPARAM)(LPDWORD) &wStart, (LPARAM)(LPDWORD) &wEnd);
		if (dwGetSel == -1) 
		{
			return FALSE;
		}
		
		LineStart = wStart;

		// New: Check for the selected text: AK
		if ( g_pGlobalData->nMsrDoNext == MSR_DOCHARR ) 
			LineStart = wEnd;
		else if ( g_pGlobalData->nMsrDoNext == MSR_DOLINED )
			LineStart = wEnd - 1;
		else if ( g_pGlobalData->nMsrDoNext == MSR_DOWORDR )
			LineStart = wEnd;

        // SteveDon: get the line for the start of the selection 
		wLineNumber = (WORD)SendMessage(hwnd,EM_LINEFROMCHAR, LineStart, 0L);
        
        // get the first character on that line that we're on.
		wLineIndex = (WORD)SendMessage(hwnd,EM_LINEINDEX, wLineNumber, 0L);
		
        // get the length of the line we're on
		wLineLength = (WORD)SendMessage(hwnd,EM_LINELENGTH, LineStart, 0L);
		
		// Subtract the LineIndex from the start of the selection,
		// This result is the column number of the caret position.
		wColNumber = LineStart - wLineIndex;

        // if we can't hold the text we want, say nothing.
		if (wLineLength > MAX_TEXT) 
		{
			return FALSE;
		}
		
        // To get the text of a line, send the EM_GETLINE message. When 
        // the message is sent, wParam is the line number to get and lParam
        // is a pointer to the buffer that will hold the text. When the message
        // is sent, the first word of the buffer specifies the maximum number 
        // of characters that can be copied to the buffer. 
        // We'll allocate the memory for the buffer in "shared" space so 
        // we can all see it. 
        // Allocate a buffer to hold it

		
		// PB 22 Nov 1998  Make it work!!! next 6 lines new.  Use global shared memory to do this!!!
        nSomeInt = wLineLength+1;
		if (nSomeInt >= 2000)
				nSomeInt = 1999;
		p = (int *) g_pGlobalData->pszTextLocal;
		*p = nSomeInt;
        SendMessage(hwnd, EM_GETLINE, (WPARAM)wLineNumber, (LPARAM)g_pGlobalData->pszTextLocal);
		g_pGlobalData->pszTextLocal[nSomeInt] = 0;

		// At this stage, pszTextLocal points to a (possibly) empty string.
		// We deal with that later...

		switch (g_pGlobalData->nMsrDoNext) 
		{
			case MSR_DOWORDR:
			case MSR_DOWORD:
				if (wColNumber >= wLineLength) 
				{
					SpeakMute(0);
					SpeakStringId(IDS_LINEEND);
					break;
				}
				else 
				{
					for (wEndWord = wColNumber; wEndWord < wLineLength; wEndWord++) 
					{
						if (g_pGlobalData->pszTextLocal[wEndWord] <= ' ') 
						{
							break;
						}
					} 
					wEndWord++;
					lstrcpyn(g_pGlobalData->pszTextLocal,g_pGlobalData->pszTextLocal+wColNumber,wEndWord-wColNumber);
					g_pGlobalData->pszTextLocal[wEndWord-wColNumber] = 0;
					SpeakMute(0);
					SpeakStringAll(g_pGlobalData->pszTextLocal);
				}
				break;
			
			case MSR_DOCHARR:
					wColNumber = LineStart - wLineIndex - 1;
					// Fall Through
			case MSR_DOCHAR: // OK now read character to left and right

				if (wColNumber >= wLineLength)
				{
					SpeakMute(0);
					SpeakStringId(IDS_LINEEND);
				}
				else if (g_pGlobalData->pszTextLocal[wColNumber] == TEXT(' '))
				{
					SpeakMute(0);
					SpeakStringId(IDS_SPACE);
				}
				else 
				{
					g_pGlobalData->pszTextLocal[0] = g_pGlobalData->pszTextLocal[wColNumber];
					g_pGlobalData->pszTextLocal[1] = 0;
					SpeakMute(0);
					SpeakStringAll(g_pGlobalData->pszTextLocal);
				}
				break;

			case MSR_DOLINED:
					// Fall through
			case MSR_DOLINE:
				g_pGlobalData->pszTextLocal[wLineLength] = 0; // add null
				SpeakMute(0);
				SpeakStringAll(g_pGlobalData->pszTextLocal);
				break;
		} // end switch (g_pGlobalData->nMsrDoNext)
	} // end if (g_pGlobalData->nMsrDoNext)

    RECT            rcCursor;
    IAccessible*    pIAcc;
    HRESULT         hr;
    VARIANT         varChild;

   	SetRectEmpty(&rcCursor); // now sort out mouse position as apprpropriate

    
    hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (SUCCEEDED(hr))
    {
    	hr = pIAcc->accLocation(&rcCursor.left, &rcCursor.top, 
	    						&rcCursor.right, &rcCursor.bottom, 
		    					varChild);
		// Move mouse cursor, Only when Track mouse option is selcted: AK
        if (SUCCEEDED(hr) && g_pGlobalData->fTrackInputFocus && g_pGlobalData->fTrackCaret && g_pGlobalData->fMouseUp )
        {
            const POINT ptLoc = { rcCursor.left + (rcCursor.right/2), rcCursor.top + (rcCursor.bottom/2) };
        	g_ptMoveCursor.x = ptLoc.x;
        	g_ptMoveCursor.y = ptLoc.y;
            if ( g_uTimer == 0 )
                g_uTimer = SetTimer( NULL, 0, 100, TrackCursor );
            else
                SetSecondary( ptLoc.x, ptLoc.y, FALSE );
        }
        pIAcc->Release();
    }
    
    return TRUE;
}

/*************************************************************************
    Function:   OnObjectShowEvent
    Purpose:    Receives object show events - This is used for balloon tips
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnObjectShowEvent(DWORD event, HWND hwnd, LONG idObject, 
                            LONG idChild, DWORD dwmsTimeStamp)
{
    IAccessible* pAcc = NULL;
    HRESULT hr;
    VARIANT varChild;
    varChild.vt = VT_EMPTY;

    IAccessible* pAccTemp = NULL;
    VARIANT varChildTemp;
    varChildTemp.vt = VT_I4;
    varChildTemp.lVal = CHILDID_SELF;
    if( idObject == OBJID_WINDOW )
    {
        // Most common case - get the client object, check if role is balloon tip...
        hr = AccessibleObjectFromWindow( hwnd, OBJID_CLIENT, IID_IAccessible, (void **) &pAccTemp );
        if( hr == S_OK && pAccTemp )
        {
            if( !CheckIsBalloonTipElseRelease( pAccTemp, varChild, &pAcc, &varChild ) )
                return FALSE;
        }
    }
    // if we didn't find a balloon tip try and get it from the event instead
    if ( !pAcc && varChild.vt != VT_I4 )
    {
        hr = AccessibleObjectFromEvent( hwnd, idObject, idChild, &pAccTemp, &varChildTemp );
        if( hr == S_OK && pAccTemp )
        {
            if( !CheckIsBalloonTipElseRelease( pAccTemp, varChildTemp, &pAcc, &varChild ) )
                return FALSE;
        }
        else
        {
            return FALSE;
        }
    }
    
    TCHAR szRole[ 128 ] = TEXT("");
    VARIANT varRole;
    hr = pAcc->get_accRole( varChild, & varRole );
    if( hr == S_OK && varRole.vt == VT_I4 )
        GetRoleText( varRole.lVal, szRole, ARRAYSIZE( szRole ) );

    BSTR bstrName = NULL;

    TCHAR szName [ 1025 ] = TEXT("");
    TCHAR * pszName;
    hr = pAcc->get_accName( varChild, & bstrName );
    if( hr == S_OK && bstrName != NULL && bstrName[ 0 ] != '\0' )
    {
#ifdef UNICODE
        pszName = bstrName;
#else
        WideCharToMultiByte( CP_ACP, 0, bstrName, -1, szName, ARRAYSIZE( szName ), NULL, NULL );
        pszName = szName;
#endif
    }

    TCHAR szText[ 1025 ];
    wsprintf( szText, TEXT("%s: %s"), szRole, pszName );

	SpeakString(szText);
	
    return TRUE;
}


/*************************************************************************
    Function:   InitMSAA
    Purpose:    Initalize the Active Accessibility subsystem, including
				initializing the helper thread, installing the WinEvent
				hook, and registering custom messages.
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:    
*************************************************************************/
BOOL InitMSAA(void)
{
	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return FALSE;

    // Call this FIRST to initialize the helper thread
    InitHelperThread();

    // Set up event call back
    g_hEventHook = SetWinEventHook(EVENT_MIN,            // We want all events
                                 EVENT_MAX,            
                                 GetModuleHandle(TEXT("NarrHook.dll")), // Use our own module
                                 WinEventProc,         // Our callback function
                                 0,                    // All processes
                                 0,                    // All threads
                                 WINEVENT_OUTOFCONTEXT /* WINEVENT_INCONTEXT */);
// Receive async events
// JMC: For Safety, lets always be 'out of context'.  Who cares if there is a 
// performance penalty.
// By being out of context, we guarantee the we won't bring down other apps if 
// there is a bug in our  event hook.


    // Did we install correctly? 
    if (g_hEventHook) 
	{
        //
        // register own own message for giving the cursor position
        //
		g_pGlobalData->uMSG_MSR_Cursor = RegisterWindowMessage(TEXT("MSR cursor")); 
        return TRUE;
	}

    // Did not install properly - clean up and fail
    UnInitHelperThread();
    return FALSE;
}   



/*************************************************************************
    Function:   UnInitMSAA
    Purpose:    Shuts down the Active Accessibility subsystem
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:    
*************************************************************************/
BOOL UnInitMSAA(void)
{
	CScopeMutex csMutex;
	if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
    {
        // Remove the WinEvent hook
	    UnhookWinEvent(g_hEventHook);

        // Call this LAST so that the helper thread can finish up. 
        UnInitHelperThread();
    }
    
    // return true; we're exiting and there's not much that can be done
    return TRUE;
}

// --------------------------------------------------------------------------
//
//  GetObjectAtCursor()
//
//  Gets the object the cursor is over.
//
// --------------------------------------------------------------------------
IAccessible * GetObjectAtCursor(VARIANT * pvarChild,HRESULT* pResult)
{
    POINT   pt;
    IAccessible * pIAcc;
    HRESULT hr;

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&pt);
	else
		pt = g_pGlobalData->ptCurrentMouse;
	
    //
    // Get object here.
    //
    VariantInit(pvarChild);
    hr = AccessibleObjectFromPoint(pt, &pIAcc, pvarChild);

    *pResult = hr;
    if (!SUCCEEDED(hr)) {
        return NULL;
	}
    
    return pIAcc;
}


/*************************************************************************
    Function:   SpeakItem
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakItem(int nOption)
{
    TCHAR tszDesc[256];
    VARIANT varChild;
    IAccessible* pIAcc;
    HRESULT hr;
    POINT ptMouse;
    BSTR bstr;

	SpeakString(TEXT(" ")); // reset last utterence
    // Important to init variants
    VariantInit(&varChild);

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&ptMouse);
	else
		ptMouse = g_pGlobalData->ptCurrentMouse;

    hr = AccessibleObjectFromPoint(ptMouse, &pIAcc, &varChild);
    
    // Check to see if we got a valid pointer
    if (SUCCEEDED(hr))
    {
        hr = pIAcc->get_accDescription(varChild, &bstr);
	    if ( FAILED(hr) )
            bstr = NULL;
	    
	    if (bstr)
		{
#ifdef UNICODE
			lstrcpyn(tszDesc,bstr,ARRAYSIZE(tszDesc));
#else
			// If we got back a string, use that instead.
			WideCharToMultiByte(CP_ACP, 0, bstr, -1, tszDesc, sizeof(tszDesc), NULL, NULL);
#endif
	        SysFreeString(bstr);
            SpeakStringAll(tszDesc);
		}
        if (pIAcc)
            pIAcc->Release();
        
    }
    return;
}



/*************************************************************************
    Function:   SpeakMute
    Purpose:    causes the system to shut up.
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakMute(int nOption)
{
	SendMessage(g_pGlobalData->hwndMSR, WM_MUTE, 0, 0);
}


/*************************************************************************
    Function:   SpeakObjectInfo
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakObjectInfo(LPOBJINFO poiObj, BOOL ReadExtra)
{
    BSTR            bstrName;
    IAccessible*    pIAcc;
    long*           pl;
    HRESULT         hr;
    CAutoArray<TCHAR> aaName( new TCHAR[MAX_TEXT] );
    TCHAR *         szName = aaName.Get();
    CAutoArray<TCHAR> aaSpeak( new TCHAR[MAX_TEXT] );
    TCHAR *         szSpeak = aaSpeak.Get();
    if ( !szName || !szSpeak )
        return;     // no memory
    
    
    TCHAR           szRole[MAX_TEXT_ROLE];  
    TCHAR           szState[MAX_TEXT_ROLE];
    TCHAR           szValue[MAX_TEXT_ROLE];
	VARIANT         varRole;
    VARIANT         varState;
	BOOL            bSayValue = TRUE;
	BOOL			bReadHTMLEdit = FALSE;
	DWORD			Role = 0;

    bstrName = NULL;
    
    // Truncate them 
    szName[0] = TEXT('\0');
    szSpeak[0] = TEXT('\0');
    szRole[0] = TEXT('\0');
    szState[0] = TEXT('\0');
    szValue[0] = TEXT('\0');

    // Get the object out of the struct
    pl = poiObj->plObj;
    pIAcc =(IAccessible*)pl;

	GetObjectProperty(pIAcc, poiObj->varChild.lVal, ID_NAME, szName, MAX_NAME);
	if (szName[0] == -1) // name going to be garbage
		LoadString(g_Hinst, IDS_NAMELESS, szSpeak, MAX_TEXT); // For now change "IDS_NAMELESS" in Resources to be just space!
	else
		lstrcpyn(szSpeak, szName, MAX_TEXT);

	szName[0] = TEXT('\0');

	VariantInit(&varRole);
	hr = pIAcc->get_accRole(poiObj->varChild, &varRole);

	if (FAILED(hr)) 
    {
		DBPRINTF (TEXT("Failed role!\r\n"));
		MessageBeep(MB_OK);
		return;
	}

	if (varRole.vt == VT_I4) 
    {
		Role = varRole.lVal; // save for use below (if ReadExtra)

    	GetRoleText(varRole.lVal,szRole, ARRAYSIZE(szRole));

		// Special casing stuff: 
		// Outline Items give out their level No. in the tree in the Value
		// field, So Don't speak it. 
		switch(varRole.lVal)
		{
			case ROLE_SYSTEM_STATICTEXT:
			case ROLE_SYSTEM_OUTLINEITEM:
			{
				bSayValue = FALSE; // don't speak value for text - it may be HTML link
			}
				break;

			// If the text is from combo -box then speak up 
			case ROLE_SYSTEM_TEXT:
				bReadHTMLEdit = TRUE;
				bSayValue = TRUE; // Speak text in combo box
				break;

			case ROLE_SYSTEM_LISTITEM:
			{
				FilterGUID(szSpeak); 
			}
			break;

            case ROLE_SYSTEM_SPINBUTTON:
				// Remove the Wizard97 spin box utterances....AK
				{
					HWND hWnd, hWndP;
					WindowFromAccessibleObject(pIAcc, &hWnd);
					if ( hWnd != NULL)
					{
						hWndP = GetParent(hWnd);

						LONG_PTR style = GetWindowLongPtr(hWndP, GWL_STYLE);
						if ( style & WS_DISABLED)
							return;
					}
				
				}
				break;

			default:
				break;
		}
	}
	
	if (g_pGlobalData->fDoingPassword)
        LoadString(g_Hinst, IDS_PASSWORD, szRole, 128);

    // This will free a BSTR, etc.
    VariantClear(&varRole);

	if ( (lstrlen(szRole) > 0) && 
		(varRole.lVal != ROLE_SYSTEM_CLIENT) ) 
    {
	    lstrcatn(szSpeak, TEXT(", "),MAX_TEXT);
	    lstrcatn(szSpeak, szRole, MAX_TEXT);
		szRole[0] = TEXT('\0');
	}

    //
    // add value string if there is one
    //
    hr = pIAcc->get_accValue(poiObj->varChild, &bstrName);
    if ( FAILED(hr) )
        bstrName = NULL;

    if (bstrName)
    {
#ifdef UNICODE
		lstrcpyn(szName, bstrName, MAX_TEXT);
#else
		// If we got back a string, use that instead.
        WideCharToMultiByte(CP_ACP, 0, bstrName,-1, szName, MAX_TEXT, NULL, NULL);
#endif
        SysFreeString(bstrName);
    }

// ROBSI: 10-10-99, Bug?
// We are not properly testing bSayValue here. Therefore, outline items are
// speaking their indentation level -- their accValue. According to comments
// above, this should be skipped. However, below we are explicitly loading
// IDS_TREELEVEL and using this level. Which is correct?
	// If not IE, read values for combo box, Edit etc.., For IE, read only for edit boxes

	if ( ((!g_pGlobalData->fInternetExplorer && bSayValue ) 
		|| ( g_pGlobalData->fInternetExplorer && bReadHTMLEdit ) )
		&& lstrlen(szName) > 0)  
	{       // i.e. got a value
			lstrcatn(szSpeak,TEXT(", "),MAX_TEXT);
			lstrcatn(szSpeak,szName,MAX_TEXT);
			szName[0] = TEXT('\0');
	}

	hr = pIAcc->get_accState(poiObj->varChild, &varState);

	if (FAILED(hr)) 
    {
		MessageBeep(MB_OK);
		return;
	}

    if (varState.vt == VT_I4)
    {
        GetStateString(varState.lVal, STATE_MASK, szState, ARRAYSIZE(szState) );
    }

	if (lstrlen(szState) > 0) 
    {
	    lstrcatn(szSpeak, TEXT(", "), MAX_TEXT);
	    lstrcatn(szSpeak, szState, MAX_TEXT);
        szState[0] = TEXT('\0');
	}

	if (ReadExtra && ( // Speak extra information if just got focus on this item
		Role == ROLE_SYSTEM_CHECKBUTTON || 
		Role == ROLE_SYSTEM_PUSHBUTTON || 
		Role == ROLE_SYSTEM_RADIOBUTTON ||
        Role == ROLE_SYSTEM_MENUITEM || 
		Role == ROLE_SYSTEM_OUTLINEITEM || 
		Role == ROLE_SYSTEM_LISTITEM ||
		Role == ROLE_SYSTEM_OUTLINEBUTTON)
	   ) {
		switch (Role) {
			case ROLE_SYSTEM_CHECKBUTTON:
				{
					// Change due to localization issues:a-anilk
					TCHAR szTemp[MAX_TEXT_ROLE];
					
					if (varState.lVal & STATE_SYSTEM_CHECKED)
						LoadString(g_Hinst, IDS_TO_UNCHECK, szTemp, MAX_TEXT_ROLE);
					else
						LoadString(g_Hinst, IDS_TO_CHECK, szTemp, MAX_TEXT_ROLE);
					// GetObjectProperty(pIAcc, poiObj->varChild.lVal, ID_DEFAULT, szName, 256);
					// wsprintf(szTemp, szTempLate, szName);
					lstrcatn(szSpeak, szTemp, MAX_TEXT);
				}
				break;

			case ROLE_SYSTEM_PUSHBUTTON:
				{
					if ( !(varState.lVal & STATE_SYSTEM_UNAVAILABLE) )
					{
						LoadString(g_Hinst, IDS_TOPRESS, szName, 256);
						lstrcatn(szSpeak, szName, MAX_TEXT);
					}
				}
				break;

			case ROLE_SYSTEM_RADIOBUTTON:
	            LoadString(g_Hinst, IDS_TOSELECT, szName, 256);
				lstrcatn(szSpeak, szName, MAX_TEXT);
                break;

                // To distinguish between menu items with sub-menu and without one.
                // For submenus, It speaks - ', Has a sub-menu': a-anilk
            case ROLE_SYSTEM_MENUITEM:
                {
                    long count = 0;
                    pIAcc->get_accChildCount(&count);
                    
                    // count = 1 for all menu items with sub menus
                    if ( count == 1 || varState.lVal & STATE_SYSTEM_HASPOPUP )
                    {
                        LoadString(g_Hinst, IDS_SUBMENU, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
                    }
                }
				
				break;

			case ROLE_SYSTEM_OUTLINEITEM:
				{
					// Read out the level in the tree....
					// And also the status as Expanded or Collapsed....:AK
					TCHAR buffer[64];

					if ( varState.lVal & STATE_SYSTEM_COLLAPSED )
					{
						LoadString(g_Hinst, IDS_TEXPAND, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
					else if ( varState.lVal & STATE_SYSTEM_EXPANDED )
					{
						LoadString(g_Hinst, IDS_TCOLLAP, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
					
					hr = pIAcc->get_accValue(poiObj->varChild, &bstrName);

					LoadString(g_Hinst, IDS_TREELEVEL, szName, 256);
                    wsprintf(buffer, szName, bstrName);
					lstrcatn(szSpeak, buffer, MAX_TEXT);
					
					SysFreeString(bstrName);
				}
				break;

			case ROLE_SYSTEM_LISTITEM:
				{
					// The list item is selectable, But not selected...:a-anilk
					if ( (varState.lVal & STATE_SYSTEM_SELECTABLE ) &&
							(!(varState.lVal & STATE_SYSTEM_SELECTED)) )
					{
						LoadString(g_Hinst, IDS_NOTSEL, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
				}
				break;
            case ROLE_SYSTEM_OUTLINEBUTTON:
                {
					if ( varState.lVal & STATE_SYSTEM_COLLAPSED )
					{
						LoadString(g_Hinst, IDS_OB_EXPAND, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
					else if ( varState.lVal & STATE_SYSTEM_EXPANDED )
					{
						LoadString(g_Hinst, IDS_OB_COLLAPSE, szName, 256);
                        lstrcatn(szSpeak, szName, MAX_TEXT);
					}
                }
		}
	}

    SpeakString(szSpeak);

    return;
}

/*************************************************************************
    Function:   SpeakMainItems
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakMainItems(int nOption)
{
    VARIANT varChild;
    IAccessible* pIAcc=NULL;
    HRESULT hr;
    POINT ptMouse;
 
	SpeakString(TEXT(" "));

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&ptMouse);
	else
		ptMouse = g_pGlobalData->ptCurrentMouse;

    // Important to init variants
    VariantInit(&varChild);

    hr = AccessibleObjectFromPoint(ptMouse, &pIAcc, &varChild);
   // Check to see if we got a valid pointer
    if (SUCCEEDED(hr))
    {
	        OBJINFO objCurrent;

	        objCurrent.hwnd = WindowFromPoint(ptMouse);
		    objCurrent.plObj = (long*)pIAcc;
			objCurrent.varChild = varChild;
			SpeakObjectInfo(&objCurrent,FALSE);
            pIAcc->Release();
	}
	return;
}


/*************************************************************************
    Function:   SpeakKeyboard
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpeakKeyboard(int nOption)
{
    TCHAR szName[128];
    VARIANT varChild;
    IAccessible* pIAcc;
    HRESULT hr;
    POINT ptMouse;

    //
    // Get cursor object & position
    //
    if (g_pGlobalData->ptCurrentMouse.x < 0)
		GetCursorPos(&ptMouse);
	else
		ptMouse = g_pGlobalData->ptCurrentMouse;

   // Important to init variants
   VariantInit(&varChild);
   hr = AccessibleObjectFromPoint(ptMouse, &pIAcc, &varChild);
    
    // Check to see if we got a valid pointer
    if (SUCCEEDED(hr))
    {
		SpeakStringId(IDS_KEYBOARD);

		GetObjectProperty(pIAcc, varChild.lVal, ID_SHORTCUT, szName, ARRAYSIZE(szName));
        SpeakString(szName);

        if (pIAcc)
            pIAcc->Release();
        
    }
    return;
}

/*************************************************************************
    Function:   Home
    Purpose:    
    Inputs:     
    Returns:    
    History:
    
      ALT_HOME to take secondary cursor to top of this window
*************************************************************************/
void Home(int x)
{
    RECT rect;
    GetWindowRect(GetForegroundWindow(),&rect);

	// Set it to show the title bar 48, max system icon size
    SetSecondary(rect.left + 48/*(rect.right - rect.left)/2*/, rect.top + 5,g_pGlobalData->fTrackSecondary);
    SpeakMainItems(0);
}


/*************************************************************************
    Function:   MoveToEnd
    Purpose:    
    Inputs:     
    Returns:    
    History:
    
        ALT_END to take secondary cursor to top of this window
*************************************************************************/
void MoveToEnd(int x)
{
    RECT rect;
    GetWindowRect(GetForegroundWindow(),&rect);

    SetSecondary(rect.left+ 48 /*(rect.right - rect.left)/2*/,rect.bottom - 8,g_pGlobalData->fTrackSecondary);
    SpeakMainItems(0);
}

#define LEFT_ID		0
#define RIGHT_ID	1
#define TOP_ID		2
#define BOTTOM_ID	3
#define SPOKEN_ID	4
#define SPATIAL_SIZE 2500
long ObjLocation[5][SPATIAL_SIZE];
int ObjIndex;

#define MAX_SPEAK 8192
/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
void SpatialRead(RECT rc)
{
    int left_min, top_min, width_min, height_min, index_min; // current minimum object
    int i, j; // loop vars

    for (i = 0; i < ObjIndex; i++) 
    {
        left_min = 20000;
        top_min = 20000;
        index_min = -1;
        
        if (g_pGlobalData->fInternetExplorer)
        {
            for (j = 0; j < ObjIndex; j++) 
            {
                // Skip items that have been spoken before...
                if (ObjLocation[SPOKEN_ID][j] != 0)
                    continue;

                // if this is the first non-spoken object, just use it
                if( index_min == -1 )
                {
                    index_min = j;
                    top_min = ObjLocation[TOP_ID][j];
                    left_min = ObjLocation[LEFT_ID][j];
                    width_min = ObjLocation[RIGHT_ID][j];
                    height_min = ObjLocation[BOTTOM_ID][j];
                }
                else
                {
                    // If same top, different heights, and overlapping widths, then give smaller one priority
                    if( ObjLocation[TOP_ID][j] == top_min
                     && ObjLocation[BOTTOM_ID][j] != height_min
                     && ObjLocation[LEFT_ID][j] < left_min + width_min
                     && ObjLocation[LEFT_ID][j] + ObjLocation[RIGHT_ID][j] > left_min )
                    {
                        if( ObjLocation[BOTTOM_ID][j] < height_min )
                        {
                            index_min = j;
                            top_min = ObjLocation[TOP_ID][j];
                            left_min = ObjLocation[LEFT_ID][j];
                            width_min = ObjLocation[RIGHT_ID][j];
                            height_min = ObjLocation[BOTTOM_ID][j];
                        }
                    }
                    else if ( (ObjLocation[TOP_ID][j] < top_min  || // check if more top-left than previous ones - give or take on height (i.e. 5 pixels)
                              (ObjLocation[TOP_ID][j] == top_min && ObjLocation[LEFT_ID][j] < left_min ) ) ) // more left on this line
                    {
                        // OK got a candidate
                        index_min = j;
                        top_min = ObjLocation[TOP_ID][j];
                        left_min = ObjLocation[LEFT_ID][j];
                        width_min = ObjLocation[RIGHT_ID][j];
                        height_min = ObjLocation[BOTTOM_ID][j];
                    }
                }
            } // for j
        } // end if Internet Explorer
        else 
        {
            for (j = 0; j < ObjIndex; j++) 
            { 
                if (ObjLocation[SPOKEN_ID][j] == 0 && // not been spoken before
                    // check if enclosed by current rectangle (semi-hierarcical - with recursion!)
                    (ObjLocation[LEFT_ID][j] >= rc.left && ObjLocation[LEFT_ID][j] <= rc.left + rc.right &&
                     ObjLocation[TOP_ID][j] >= rc.top && ObjLocation[TOP_ID][j] <= rc.top + rc.bottom
                    ) &&
                    
                    // also check if more top-left than previous ones - give or take on height (i.e. 10 pixels)
                    ( (ObjLocation[TOP_ID][j] < top_min + 10 && ObjLocation[LEFT_ID][j] < left_min)
                    //      or just higher up
                    || (ObjLocation[TOP_ID][j] < top_min)
                    )
                   ) 
                { // OK got a candidate
                    index_min = j;
                    top_min = ObjLocation[TOP_ID][j];
                    left_min = ObjLocation[LEFT_ID][j];
                }
            } // for j
        } // end not Internet Explorer

        if (index_min >= 0) 
        { // got one!
            HWND hwndList; 
            CAutoArray<TCHAR> aaText( new  TCHAR[MAX_SPEAK] );
            TCHAR * szText = aaText.Get();
            RECT rect;
            ObjLocation[SPOKEN_ID][index_min] = 1; // don't do this one again
            hwndList = GetDlgItem(g_pGlobalData->hwndMSR, IDC_WINDOWINFO);
            SendMessage(hwndList, LB_GETTEXT, index_min, (LPARAM) szText);
            SpeakString(szText);
            if (g_pGlobalData->fInternetExplorer) // no recursion for IE
                continue;
            rect.left = ObjLocation[LEFT_ID][index_min];
            rect.right = ObjLocation[RIGHT_ID][index_min];
            rect.top = ObjLocation[TOP_ID][index_min];
            rect.bottom = ObjLocation[BOTTOM_ID][index_min];
            SpatialRead(rect);
        }
    } // for i
}

//--------------------------------------------------------------------------
//
//  SpeakWindow()
//
//  Fills in a tree view with the descendants of the given top level window.
//  If hwnd is 0, use the previously saved hwnd to build the tree.
//
//--------------------------------------------------------------------------
void SpeakWindow(int nOption)
{
    IAccessible*  pacc;
    RECT rect;
    TCHAR szName[128];
    VARIANT varT;
    HWND ForeWnd;
    TCHAR buffer[100];

    szName[0] = NULL;
    buffer[0] = NULL;
    g_pGlobalData->nAutoRead = nOption; // set global flag to tell code in AddItem if we're to read edit box contents (don't do it if just got focus as the edit box has probably been spoken already
    
    ForeWnd = GetForegroundWindow();		// Check if we're in HTML Help
    GetClassName(ForeWnd,buffer,100); 
    g_pGlobalData->fHTML_Help = 0;
	if ((lstrcmpi(buffer, CLASS_HTMLHELP) == 0) ) 
    {
        g_pGlobalData->fInternetExplorer = TRUE;
        g_pGlobalData->fHTML_Help = TRUE;
        GetWindowRect(ForeWnd, &rect); // get the left hand side of our window to use later
        g_pGlobalData->nLeftHandSide = rect.left;
    }
    
	else if ( IsTridentWindow(buffer) )
	{
        g_pGlobalData->fInternetExplorer = TRUE;
        g_pGlobalData->fHTML_Help = FALSE;
        GetWindowRect(ForeWnd, &rect); // get the left hand side of our window to use later
        g_pGlobalData->nLeftHandSide = rect.left;
	}

    // Inititalise stack for tree information
    ObjIndex = 0; 
    //
    // Get the object for the root.
    //
    pacc = NULL;
    AccessibleObjectFromWindow(GetForegroundWindow(), OBJID_WINDOW, IID_IAccessible, (void**)&pacc);
    
    if (nOption == 1) 
    { // if it was a keyboard press then speak the window's name
        SpeakStringId(IDS_WINDOW);
        GetWindowText(GetForegroundWindow(), szName, sizeof(szName)/sizeof(TCHAR));	// raid #113789
        SpeakString(szName);
    }
    
    if (pacc)
    {
        HWND hwndList; // first clear the list box used to store the window info
        hwndList = GetDlgItem(g_pGlobalData->hwndMSR, IDC_WINDOWINFO);
        SendMessage(hwndList, LB_RESETCONTENT, 0, 0); 

        // AddAccessibleObjects changes this - so need to save and restore it
        // so that it is correct when we call SpatialRead...
        BOOL fIsInternetExplorer = g_pGlobalData->fInternetExplorer;

        InitChildSelf(&varT);
        AddAccessibleObjects(pacc, varT); // recursively go off and get the information
        pacc->Release();
        GetWindowRect(GetForegroundWindow(),&rect);

        if (g_pGlobalData->fReviewStyle) 
        {
            g_pGlobalData->fInternetExplorer = fIsInternetExplorer;

            SpatialRead(rect);
        }
    }
}

//--------------------------------------------------------------------------
//
//  AddItem()
//
//  Parameters:     pacc - the IAccessible object to [maybe] add
//                  varChild - if pacc is parent, the child id
//  Return Values:  Returns TRUE if caller should continue to navigate the
//                  UI tree or FALSE if it should stop.
//
//--------------------------------------------------------------------------
BOOL AddItem(IAccessible* pacc, const VARIANT &varChild)
{
    TCHAR           szName[MAX_NAME] = TEXT(" ");
    TCHAR           szRole[128] = TEXT(" ");
    TCHAR           szState[128] = TEXT(" ");
	TCHAR			szValue[MAX_VALUE] = TEXT(" ");
	TCHAR			szLink[32];
    VARIANT         varT;
    BSTR            bszT;
	BOOL			DoMore = TRUE;
	BOOL			GotStaticText = FALSE;
	BOOL			GotGraphic = FALSE;
	BOOL			GotText = FALSE;
	BOOL			GotNameless = FALSE;
	BOOL			GotInvisible = FALSE;
	BOOL			GotOffScreen = FALSE;
	BOOL			GotLink = FALSE;
	int				lastRole = 0;
	static TCHAR	szLastName[MAX_NAME] = TEXT(" ");

	BOOL fInternetExplorer = g_pGlobalData->fInternetExplorer;
	int nAutoRead = g_pGlobalData->nAutoRead;
	BOOL fHTMLHelp = g_pGlobalData->fHTML_Help;
	int nLeftHandSide = g_pGlobalData->nLeftHandSide;
	HWND hwndMSR = g_pGlobalData->hwndMSR;
	HRESULT hr;

    //
    // Get object state first.  If we are skipping invisible dudes, we want
    // to bail out now.
    //
    VariantInit(&varT);
    hr = pacc->get_accState(varChild, &varT);
    if ( FAILED(hr) )
    {
        DBPRINTF( TEXT("AddItem get_accState returned 0x%x\r\n"), hr ); 
        return FALSE;
    }
    
    DWORD dwState = 0;
    
    if (varT.vt == VT_I4)
    {
        LONG lStateMask = STATE_SYSTEM_UNAVAILABLE | STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_CHECKED;
        GetStateString(varT.lVal, lStateMask, szState, ARRAYSIZE(szState) );

        dwState = varT.lVal;

		GotInvisible = varT.lVal & STATE_SYSTEM_INVISIBLE;
		GotOffScreen = varT.lVal & STATE_SYSTEM_OFFSCREEN;

        // Bail out if not shown. If it's not IE, ignore both invisible and scrolled-off...
        if (!fInternetExplorer && GotInvisible) 
            return FALSE;

        // ...but if it's IE, only ignore 'really' invisible (display:none), and allow
        // scrolled-off (which has the offscreen bit set) to be read...
        if (fInternetExplorer && GotInvisible && ! GotOffScreen )
            return FALSE;
    }

    VariantClear(&varT);
    //
    // Get object role.
    //
    VariantInit(&varT);
    hr = pacc->get_accRole(varChild, &varT);
    if ( FAILED(hr) )
    {
        DBPRINTF( TEXT("AddItem get_accRole returned 0x%x\r\n"), hr ); 
        return FALSE;
    }

    LONG lRole = varT.lVal;
    
    if (varT.vt == VT_I4) 
    {
		switch (varT.lVal) 
        {
            case ROLE_SYSTEM_WINDOW: 
            case ROLE_SYSTEM_TABLE : 
            case ROLE_SYSTEM_DOCUMENT:
            {
                // it's a window - don't read it - read its kids
				return TRUE; // but carry on searching down
            }

            case ROLE_SYSTEM_LIST:       
            case ROLE_SYSTEM_SLIDER:     
            case ROLE_SYSTEM_STATUSBAR:
            case ROLE_SYSTEM_BUTTONMENU: 
            case ROLE_SYSTEM_COMBOBOX: 
            case ROLE_SYSTEM_DROPLIST:   
            case ROLE_SYSTEM_OUTLINE:    
            case ROLE_SYSTEM_TOOLBAR:
                DoMore = FALSE;    // i.e. speak it but no more children
                break;

            case ROLE_SYSTEM_GROUPING:
                if (fInternetExplorer)
                {
                    return TRUE;
                }
                else
                {
                    DoMore = FALSE;    // speak it but no more children
                }
                break;
                
            // Some of the CLIENT fields in office2000 are not spoken because 
            // we don't add. We may need to specail case for office :a-anilk
            // Micw:  Special case for IE and let the rest thru (Whistler raid #28777)
            case ROLE_SYSTEM_CLIENT : // for now work with this for IE ...???
                if (fInternetExplorer)
                {
                    return TRUE;
                }
                break;

            case ROLE_SYSTEM_PANE :
                if ( fInternetExplorer )
                {
                    LONG lLeft = 0, lTop = 0, lHeight = 0, lWidth = 0;
                    HRESULT hr = pacc->accLocation( &lLeft, &lTop, &lHeight, &lWidth, varChild );
                    
                    // If they don't know where they are don't speak them 
                    // We do not want to read zero width or height and the elements like in
                    // Remote Assistance or location of 0,0,0,0 like in oobe 
                    if ( hr != S_OK || lHeight == 0 || lWidth == 0 )
                    {
                        return FALSE;
                    }
                }

				return TRUE;

			case ROLE_SYSTEM_CELL: // New - works for HTML Help!
				return TRUE;

            case ROLE_SYSTEM_SEPARATOR:  
            case ROLE_SYSTEM_TITLEBAR: 
            case ROLE_SYSTEM_GRIP: 
            case ROLE_SYSTEM_MENUBAR:    
            case ROLE_SYSTEM_SCROLLBAR:
                return FALSE; // don't speak it or it's children

            case ROLE_SYSTEM_GRAPHIC: // this works for doing icons!
                GotGraphic = TRUE;
                break;

			case ROLE_SYSTEM_LINK:
				GotLink = TRUE;
				break;

            case ROLE_SYSTEM_TEXT:
                GotText = TRUE;
                break;
            case ROLE_SYSTEM_SPINBUTTON:
				// Remove the Wizard97 spin box utterances....
				{
					HWND hWnd, hWndP;
					WindowFromAccessibleObject(pacc, &hWnd);
					if ( hWnd != NULL)
					{
						hWndP = GetParent(hWnd);

						LONG_PTR style = GetWindowLongPtr(hWndP, GWL_STYLE);
						if ( style & WS_DISABLED)
                        {
							return FALSE;
                        }
					}
				
					DoMore = FALSE;    // i.e. speak it but no more children
				}

			case ROLE_SYSTEM_PAGETAB:
				// Hack to not read them if they are disabled...
				// Needed for WIZARD97 style :AK
				{
					HWND hWnd;
					WindowFromAccessibleObject(pacc, &hWnd);
					if ( hWnd != NULL)
					{
						LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
						if ( style & WS_DISABLED)
                        {
							return FALSE;
                        }
					}
				}
				break;
		} // switch

		
		GetRoleText(varT.lVal, szRole, 128);

// ROBSI: 10-10-99, BUG? Why (Role == Static) or (IE)??
		if (varT.lVal == ROLE_SYSTEM_STATICTEXT || fInternetExplorer) 
        {
            // don't speak role for this 
            // speech is better without
			szRole[0] = 0;                  
			GotStaticText = TRUE;
		}
	}
    else
    {
        szRole[0] = 0;	// lstrcpy(szRole, TEXT("UNKNOWN"));
    }

	VariantClear(&varT);

    //
    // Get object name.
    //
    bszT = NULL;
    hr = pacc->get_accName(varChild, &bszT);
    if ( FAILED(hr) )
        bszT = NULL;
       
    if (bszT)
    {
#ifdef UNICODE
		lstrcpyn(szName, bszT, MAX_NAME);
#else
        WideCharToMultiByte(CP_ACP, 0, bszT, -1, szName, MAX_NAME, NULL, NULL);
#endif
        SysFreeString(bszT);
		if (szName[0] == -1) 
        { // name going to be garbage
			LoadString(g_Hinst, IDS_NAMELESS, szName, 256);
			GotNameless = TRUE;
		}
    }
    else 
    {
		LoadString(g_Hinst, IDS_NAMELESS, szName, 256);
		GotNameless = TRUE;
	}

    bszT = NULL;
    hr = pacc->get_accValue(varChild, &bszT); // get value string if there is one
    if ( FAILED(hr) )
        bszT = NULL;
    
	szValue[0] = 0;
    if (bszT)
    {
#ifdef UNICODE
		lstrcpyn(szValue, bszT, MAX_VALUE);
		// lstrcpy(szValue, bszT);
#else
        WideCharToMultiByte(CP_ACP, 0, bszT, -1, szValue, MAX_VALUE, NULL, NULL);
#endif
        SysFreeString(bszT);
    }

    // There is no reason for us to speak client client client all time
    if ( GotNameless && lRole & ROLE_SYSTEM_CLIENT && szValue[0] == NULL )
        return TRUE;
    
    //
    // make sure these are terminated for the compare
    //
    szLastName[MAX_NAME - 1]=TEXT('\0');
    szName[MAX_NAME - 1]=TEXT('\0');

    //
    // don't want to repeat name that OLEACC got from static text
    // so if this name is the same as the previous name - don't speak it.
    //
	if (lstrcmp(szName,szLastName) == 0)
		szName[0] = 0; 

	if (GotStaticText)
		lstrcpyn(szLastName, szName, MAX_NAME);
	else
		szLastName[0] = 0;

    CAutoArray<TCHAR> aaItemString( new  TCHAR[MAX_TEXT] );
    TCHAR *         szItemString = aaItemString.Get();
    if ( !szItemString )
        return FALSE;       // no memory
        
	lstrcpy(szItemString,szName);

    if (fInternetExplorer) 
    {
        if (GotText && szName[0] == 0)      // no real text
        {
            return FALSE;
        }
        
        if (GotNameless && szValue[0] == 0) // nameless with no link
        {
            return FALSE;
        }
        
        if (GotLink/*szValue[0]*/)  
        {
            // got a link
            // GotLink = TRUE;
            LoadString(g_Hinst, IDS_LINK, szLink, 32);
            lstrcatn(szItemString,szLink,MAX_TEXT);
        }
    }
    else
    {
        // the focused item has already been read so if the item does not have
        // focus it should be read in this case edit controls. 
        if (GotText && ( nAutoRead || !(dwState & STATE_SYSTEM_FOCUSED) ) )
            lstrcatn(szItemString,szValue,MAX_TEXT);
    }
    
    if (!GotText && !GotLink && !GotGraphic) 
    {
        
        if (lstrlen(szName) && lstrlen(szRole))
            lstrcatn(szItemString,TEXT(", "),MAX_TEXT);
        
        if (lstrlen(szRole)) 
        {
            lstrcatn(szItemString,szRole,MAX_TEXT);
            if (lstrlen(szValue) || lstrlen(szState))
                lstrcatn(szItemString, TEXT(", "),MAX_TEXT);
        }
        if (lstrlen(szValue)) 
        {
            lstrcatn(szItemString,szValue,MAX_TEXT);
            
            if (lstrlen(szState))
                lstrcatn(szItemString,TEXT(", "),MAX_TEXT);
        }
        if (lstrlen(szState))
            lstrcatn(szItemString,szState,MAX_TEXT);
        
		// Too much speech of period/comma. Just a space is fine...
        lstrcatn(szItemString, TEXT(" "),MAX_TEXT);
    }

    if (g_pGlobalData->fReviewStyle)  
    {
        HWND hwndList; 
        
        if (ObjIndex >= SPATIAL_SIZE) // only store so many
        {
            return DoMore;
        }
        
        pacc->accLocation(&ObjLocation[LEFT_ID][ObjIndex], 
                          &ObjLocation[TOP_ID][ObjIndex],
                          &ObjLocation[RIGHT_ID][ObjIndex], 
                          &ObjLocation[BOTTOM_ID][ObjIndex], 
                          varChild);
        
        // Dreadfull Hack/heuristic!
        // bin information as it's the left hand side of the HTML help window
        if (fHTMLHelp && (ObjLocation[LEFT_ID][ObjIndex] < nLeftHandSide + 220))
        {
            return DoMore;
        }
        
        hwndList = GetDlgItem(hwndMSR, IDC_WINDOWINFO);
        SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) szItemString); 
        ObjLocation[SPOKEN_ID][ObjIndex] = 0;
        ObjIndex++;
    }
    else
        SpeakString(szItemString);

    return DoMore;
}
        

// --------------------------------------------------------------------------
//
//  AddAccessibleObjects()
//    
//  This is a recursive function.  It adds an item for the parent, then 
//  adds items for its children if it has any.
//
//	Parameters:
//	IAccessible* pacc       Pointer to an IAccessible interface for the
//                          object being added. Start with the 'root' object.
//	VARIANT		 varChild	Variant that contains the ID of the child object
//                          to retrieve.
//
//	The first call, pIAcc points to the top level window object,
//					varChild is a variant that is VT_I4, CHILDID_SELF
// 
//  ISSUE:  The calling code isn't prepared to deal with errors so I'm making
//  the return void.  A re-engineered version should do better error handling.
//
void AddAccessibleObjects(IAccessible* pIAcc, const VARIANT &varChild)
{
	if (varChild.vt != VT_I4)
    {
        DBPRINTF(TEXT("BUG??: Got child ID other than VT_I4 (%d)\r\n"), varChild.vt);
		return;
    }

    // Find the window class so we can find embedded trdent windows
    HWND hwndCurrentObj;
    TCHAR szClassName[64];
    if ( WindowFromAccessibleObject( pIAcc, &hwndCurrentObj ) == S_OK )
    {
        if ( GetClassName( hwndCurrentObj, szClassName, ARRAYSIZE(szClassName) ) )
        {
            // is it Internet Explorer in any of its many forms?
            g_pGlobalData->fInternetExplorer = IsTridentWindow(szClassName);
        }
    }
    // Add the object itself and, if AddItem determines it wants children, do those

    if (AddItem(pIAcc, varChild))
    {
        // Traverse the children to see if any of them should be added

	    if (varChild.lVal != CHILDID_SELF)
		    return;	// only do this for container objects

        // Loop through pIAcc's children.

        long cChildren = 0;
        pIAcc->get_accChildCount(&cChildren);

	    if (!cChildren)
		    return;	// no children

	    // Allocate memory for the array of child variants
        CAutoArray<VARIANT> aaChildren( new VARIANT [cChildren] );
	    VARIANT * pavarChildren = aaChildren.Get();
	    if( ! pavarChildren )
	    {
            DBPRINTF(TEXT("Error: E_OUTOFMEMORY allocating pavarChildren\r\n"));
		    return;
	    }

	    long cObtained = 0;
	    HRESULT hr = AccessibleChildren( pIAcc, 0L, cChildren, pavarChildren, & cObtained );
	    if( hr != S_OK )
	    {
            DBPRINTF(TEXT("Error: AccessibleChildren returns 0x%x\r\n"), hr);
		    return;
	    }
	    else if( cObtained != cChildren)
	    {
            DBPRINTF(TEXT("Error: get_accChildCount returned %d but AccessibleChildren returned %d\r\n"), cChildren, cObtained);
		    return;
	    }
	    else 
	    {
		    // Loop through VARIANTs in ARRAY.  Object_Normalize returns a proper
            // pAccChild and varAccChild pair regardless of whether the array
            // element is VT_DISPATCH or VT_I4.

		    for( int i = 0 ; i < cChildren ; i++ )
		    {
			    IAccessible * pAccChild = NULL;
			    VARIANT       varAccChild;

			    // Object_Normalize consumes the variant, so no VariantClear() needed.

			    if( Object_Normalize( pIAcc, & pavarChildren[ i ], & pAccChild, & varAccChild ) )
			    {
				    AddAccessibleObjects(pAccChild, varAccChild);
				    pAccChild->Release();
			    }
		    }
	    }
    }
}

// --------------------------------------------------------------------------
// Helper method to filter out bogus focus events...
// Returns FALSE if the focus event is bogus, Otherwise returns TRUE
// a-anilk: 05-28-99
// --------------------------------------------------------------------------
BOOL IsFocussedItem( HWND hWnd, IAccessible * pAcc, VARIANT varChild )
{
	TCHAR buffer[100];

	GetClassName(hWnd,buffer,100); 
	// Is it toolbar, We cannot determine who had focus!!!
	if ((lstrcmpi(buffer, CLASS_TOOLBAR) == 0) ||
		(lstrcmpi(buffer, CLASS_IE_MAINWND) == 0))
			return TRUE;

	VARIANT varState;
	HRESULT hr;
	
	VariantInit(&varState); 
	hr = pAcc->get_accState(varChild, &varState);

	
	if ( hr == S_OK)
	{
		if ( ! (varState.lVal & STATE_SYSTEM_FOCUSED) )
			return FALSE;
	}
	else if (FAILED(hr)) // ROBSI: 10-11-99. If OLEACC returns an error, assume no focus.
	{
		return FALSE;
	}

	return TRUE;
}

#define TAB_KEY 0x09
#define CURLY_KEY 0x7B
// Helper method Filters GUID's that can appear in names: AK
void FilterGUID(TCHAR* szSpeak)
{
	// the GUID's have a Tab followed by a {0087....
	// If you find this pattern. Then donot speak that:AK
	while(*szSpeak != NULL)
	{
		if ( (*szSpeak == TAB_KEY) &&
			  (*(++szSpeak) == CURLY_KEY) )
		{
			*(--szSpeak) = NULL;
			return;
		}

		szSpeak++;
	}
}

///////////////////////////////////////////////////////////////////////////
// Helper functions 

// Convert an IDispatch to an IAccessible/varChild pair (Releases the IDispatch)

BOOL Object_IDispatchToIAccessible( IDispatch *     pdisp,
                                    IAccessible **  ppAccOut,
                                    VARIANT *       pvarChildOut)
{
    IAccessible * pAccTemp = NULL;
    HRESULT hr = pdisp->QueryInterface( IID_IAccessible, (void**) & pAccTemp );
    pdisp->Release();

    if( hr != S_OK || ! pAccTemp )
    {
        return FALSE;
    }

    *ppAccOut = pAccTemp;
    if( pvarChildOut )
    {
        InitChildSelf(pvarChildOut);
    }
    return TRUE;
}

// Given an IAccessible and a variant (may be I4 or DISP), returns a 'canonical'
// IAccessible/varChild, using getChild, etc.
// The variant is consumed.
BOOL Object_Normalize( IAccessible *    pAcc,
                       VARIANT *        pvarChild,
                       IAccessible **   ppAccOut,
                       VARIANT *        pvarChildOut)
{
	BOOL fRv = FALSE;

    if( pvarChild->vt == VT_DISPATCH )
    {
        fRv = Object_IDispatchToIAccessible( pvarChild->pdispVal, ppAccOut, pvarChildOut );
    }
    else if( pvarChild->vt == VT_I4 )
    {
        if( pvarChild->lVal == CHILDID_SELF )
        {
            // No normalization necessary...
            pAcc->AddRef();
            *ppAccOut = pAcc;
            pvarChildOut->vt = VT_I4;
            pvarChildOut->lVal = pvarChild->lVal;
            fRv = TRUE;
        } else
		{
			// Might still be a full object - try get_accChild...
			IDispatch * pdisp = NULL;
			HRESULT hr = pAcc->get_accChild( *pvarChild, & pdisp );

			if( hr == S_OK && pdisp )
			{
				// It's a full object...
				fRv = Object_IDispatchToIAccessible( pdisp, ppAccOut, pvarChildOut );
			}
			else
			{
				// Just a regular leaf node...
				pAcc->AddRef();
				*ppAccOut = pAcc;
				pvarChildOut->vt = VT_I4;
				pvarChildOut->lVal = pvarChild->lVal;
				fRv = TRUE;
			}	
		}
    }
    else
    {
        DBPRINTF( TEXT("Object_Normalize unexpected error") );
        *ppAccOut = NULL;    // unexpected error...
        VariantClear( pvarChild );
        fRv = FALSE;
    }

	return fRv;
}

/*************************************************************************
    THE INFORMATION AND CODE PROVIDED HEREUNDER (COLLECTIVELY REFERRED TO
    AS "SOFTWARE") IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
    NO EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
    ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
    MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE EXCLUSION OR
    LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES SO THE
    FOREGOING LIMITATION MAY NOT APPLY.
*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\list.cpp ===
#include <windows.h>

#include "list.h"

//----------------------------------------------------------------------------
// 
// Description:
//   this implements a simple C++ list class routine that will let us build
//   up a list of an arbitrary long number of items.  An item can be any 
//   simple type or structure.  
//
//----------------------------------------------------------------------------

CList::CList()
{
    m_pListHead=m_pListCurr=m_pListTail=NULL;
}

CList::~CList()
{
    RemoveAll();
}

//----------------------------------------------------------------------------
// 
// Description:
//   Add an item to the list.  The length of the item is assumed correct
//   for the passed in item.  Items are added to the end of the list.
//
// Arguments:
//   pData  - pointer to the data to add
//   nBytes - the number of bytes of pData
// 
// Returns: TRUE if the data is succesfully added, otherwise FALSE.
//           a-anilk; Just donot absolutely Duplicate Entries
//   
//----------------------------------------------------------------------------
BOOL
CList::Add(PVOID pData, UINT nBytes)
{
    PLIST tmp;

    if ((nBytes == 0) || (pData == NULL))
        return FALSE;

    tmp=new LIST;

    if (NULL == tmp)
        return FALSE;

    tmp->pData=new BYTE[nBytes];

    if (NULL == tmp->pData)
    {
        delete tmp;
        return FALSE;
    }

	// Donot add duplicate entries that come one after another...
	if ( m_pListHead != NULL )
	{
		if (! memcmp(m_pListHead->pData, pData, nBytes ) )
		{
			delete [] tmp->pData;	// raid 113787
			delete tmp;
			return FALSE;
		}
	}

    CopyMemory(tmp->pData,pData,nBytes);

    tmp->nBytes=nBytes;
    tmp->next=NULL;
    tmp->prev=m_pListTail;

    if (IsEmpty())
    {
        m_pListHead=tmp;
    }
    else
    {
        if (m_pListTail != NULL)
            m_pListTail->next=tmp;
    }

    m_pListTail=tmp;

    return TRUE;
}


//----------------------------------------------------------------------------
// 
// Description:
//   Remove all the items from the list.
//
//----------------------------------------------------------------------------
void
CList::RemoveAll()
{
    while(!IsEmpty())
        RemoveHead(NULL);
}


//----------------------------------------------------------------------------
//
// Description:
//   Remove just the item at the head of the list.  If the passed in buffer
//   is not NULL, it will overwrite the buffer with the contents of the data.
//   This code assumes the passed in pData buffer is large enough for the
//   stored data item.  If the passed in pData is NULL, then the head item
//   is simply discarded.
//
// Arguments:
//   pData - a buffer to overwrite with the head item. Can be NULL.
//  
//----------------------------------------------------------------------------
void
CList::RemoveHead(PVOID pData)
{
    PLIST tmp;

    if (!IsEmpty())
    {
        // make sure m_pListCurr is always NULL or someplace valid

        if (m_pListCurr == m_pListHead)
            m_pListCurr=m_pListHead->next;

        tmp=m_pListHead;
        m_pListHead=m_pListHead->next;

        if (tmp->pData != NULL)
        {
            if (pData != NULL)
                CopyMemory(pData,tmp->pData,tmp->nBytes);

            delete[] (tmp->pData);
        }

        delete tmp;

        if (!IsEmpty())
            m_pListHead->prev=NULL;
        else
            m_pListTail=NULL;
    }
}


//----------------------------------------------------------------------------
//
// Description:
//    RemoveHead(NULL, NULL)  <=>   RemoveHead(NULL)
//
//    RemoveHead(pData,NULL)  <=>   RemoveHead(pData)
//
//    RemoveHead(NULL,&nBytes) - sets nBytes to the size of the data in the 
//                               head of the list, nothing is removed
//
//    RemoveHead(pData,&nBytes)- copies the data in the head of the list into
//                               pData up to the min of the size of data in the
//                               head of the list or nBytes. The head of the
//                               list is removed. 
//
//----------------------------------------------------------------------------
void
CList::RemoveHead(PVOID pData, PUINT pnBytes)
{
    PLIST tmp;
    UINT  nBytes;

    if (pnBytes == NULL)
    {
        RemoveHead(pData);
        return;
    }

    if (pData == NULL)
    {
        // they just want the size, so return it.

        if (IsEmpty())
            *pnBytes=0;
        else
            *pnBytes=m_pListHead->nBytes;

        return;
    }

    if (IsEmpty())
    {
        *pnBytes=0;
        return;
    }

    // make sure m_pListCurr is always NULL or someplace valid

    if (m_pListCurr == m_pListHead)
        m_pListCurr=m_pListHead->next;

    tmp=m_pListHead;
    m_pListHead=m_pListHead->next;

    //
    // only copy the min size of the two
    //
        
    nBytes=min((*pnBytes),tmp->nBytes);

    if (tmp->pData != NULL)
    {
        CopyMemory(pData,tmp->pData,nBytes);

        *pnBytes=nBytes;

        delete[] (tmp->pData);
    }
    else
        *pnBytes=0;

    delete tmp;

    if (!IsEmpty())
        m_pListHead->prev=NULL;
    else
        m_pListTail=NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\other.cpp ===
#include <windows.h>

#include "keys.h"

//--------------------------------------------------------------------------
// Description:
//   This implements lstrcat except that we always only cat up to the
//   passed on maxDest length.  This prevents cases where we cat past
//   the end of the destination buffer.
//
// Arguments:
//   pDest   - destination string to append to
//   pSrc    - src string to append 
//   maxDest - the maxuium number of characters of the destination buffer
//
// Returns: the destination buffer or NULL on error.  
//          GetLastError() will return the reason for the failure.
// 
//--------------------------------------------------------------------------
LPTSTR
lstrcatn(LPTSTR pDest, LPTSTR pSrc, int maxDest)
{
    int destLen;

    destLen=lstrlen(pDest);

    if (destLen < maxDest)
        return (lstrcpyn(pDest+destLen,pSrc,maxDest-destLen) ? pDest : NULL);

    //
    // if the buffer is the exact length and we have nothing to append
    // then this is ok, just return the destination buffer.
    //
    if ((destLen == maxDest) && ((NULL == pSrc) || (*pSrc == TEXT('\0'))))
        return pDest;

    //
    // the destination buffer is too small, so return an error.
    //
    SetLastError(ERROR_INSUFFICIENT_BUFFER);

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\sources.inc ===
C_DEFINES=$(C_DEFINES)  -DUNICODE

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0500

TARGETNAME=NarrHook
TARGETPATH=obj
TARGETTYPE=DYNLINK
USE_MSVCRT=1
USE_NATIVE_EH=1
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\uuid.lib \
           $(SDK_LIB_PATH)\ole32.lib    \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\oleacc.lib

NOT_LEAN_AND_MEAN=1

DLLENTRY=_DllMainCRTStartup

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..\..\inc

SOURCES= ..\other.cpp   \
         ..\list.cpp    \
         ..\helpthd.cpp \
         ..\getprop.cpp \
         ..\keys.cpp    \
         ..\NarrHook.rc

UMTYPE=windows
UMRES=$(O)\main.res
DLLDEF=..\NarrHook.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NarrHook.rc
//
#define IDD_DIALOG1                     103
#define TXT_NOMORE                      196
#define IDS_MENUEND                     197
#define IDS_MENU                        198
#define IDS_POPUP                       199
#define IDS_DIALOGEND                   200
#define IDS_WINDOW                      201
#define IDS_LINEEND                     202
#define IDS_KEYBOARD                    203
#define IDS_SPACE                       204
#define IDS_DELETE                      205
#define IDS_BACKSPACE                   206
#define IDS_TAB                         207
#define IDS_CONTROL                     208
#define IDS_ALT                         209
#define IDS_SHIFT                       210
#define IDS_RETURN                      211
#define IDS_POPUPEND                    212
#define IDS_NAMELESS                    213
#define IDS_SHOW                        214
#define IDS_VALUE                       216
#define IDS_FOREGROUND                  217
#define IDS_TOOLTIP                     218
#define IDS_LINESTART                   219
#define IDS_DIALOG                      220
#define IDS_LINK                        221
#define IDS_PASSWORD                    222
#define IDS_TOPRESS                     223
#define IDS_TOSELECT                    224
#define IDS_TO_CHECK                    225
#define IDS_PRESSSPACE                  226
#define IDS_SUBMENU                     227
#define IDS_TO_UNCHECK                  228
#define IDS_DRIVE                       230
#define IDS_TREELEVEL                   231
#define IDS_TEXPAND                     232
#define IDS_TCOLLAP                     233
#define IDS_LEAF                        234
#define IDS_ROOT                        235
#define IDS_NOTSEL                      236
#define IDS_WINKEY                      237
#define IDS_PASS                        238
#define IDS_INSERT                      239
#define IDS_HOME                        240
#define IDS_END                         241
#define IDS_PAGEUP                      242
#define IDS_PAGEDOWN                    243
#define IDS_CAPS_ON                     244
#define IDS_NUM_ON                      245
#define IDS_PRINT                       246
#define IDS_NUM_OFF                     247
#define IDS_CAPS_OFF                    248
#define IDS_ESC                         249
#define IDS_OB_EXPAND					250
#define IDS_OB_COLLAPSE					251


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\version.h ===
// NARRHOOK.DLL version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Narrator Keyboard and WinEvent hook"
#define VER_INTERNALNAME_STR        "NARRHOOK"
#define VER_ORIGINALFILENAME_STR    "NARRHOOK.DLL"
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\dgadvsca.h ===
INT_PTR AdvScanDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK AdvScanDlgProc(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam);

void ConfigSwitchKey(UINT vk, BOOL bSet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\credits.h ===
/* Modal dialog box procedure */

INT_PTR CALLBACK CreditsDlgProc(HWND hDlg, UINT message, 
                                WPARAM wParam, LPARAM lParam); 

 /* Startup procedure for modal dialog box */

INT_PTR CreditsDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL CreditsDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\dgsett.h ===
//  dgSetting.h


/****************************************************************************/
/*    FUNCTIONS IN THIS FILE			*/
/****************************************************************************/
INT_PTR Type_ModeDlgFunc(HWND hWnd, UINT message,WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK Type_ModeDlgProc(HWND hDlg, UINT message, 
                                  WPARAM wParam, LPARAM lParam);

BOOL Type_ModeDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


void ChangeDwellTime(HWND hDlg, UINT message, WPARAM wParam);
void ChangeScanTime(HWND hDlg, UINT message, WPARAM wParam);
void SwitchToBlockKB(void);
void SwitchToActualKB(void);
void SwitchToJapaneseKB(void);
void SwitchToEuropeanKB(void);
void BlockKB(void);
void ActualKB(void);
void JapaneseKB(void);
void EuropeanKB(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\about.h ===
// about.h


//**********************************************************************
// About dialog management
//**********************************************************************

//
// Modal dialog box procedure 
//
INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam);

//
// Startup procedure for modal dialog box 
//

INT_PTR AboutDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); 

BOOL AboutDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);




//**********************************************************************
// Initial Warning Message dialog management
//**********************************************************************
//
// Modal dialog box procedure 
//
INT_PTR CALLBACK WarningMsgDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam);

//
// Startup procedure for modal dialog box 
//

INT_PTR WarningMsgDlgFunc(HWND hWnd); 

BOOL WarningMsgDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\fileutil.h ===
/****************************************************************************/
/*    FUNCTIONS IN THIS FILE						    				    */
/****************************************************************************/
PSID GetCurrentUserInfo(void);
BOOL RunningAsAdministrator(void);
BOOL OpenUserSetting(void);
BOOL SaveUserSetting(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\init_end.h ===
/* Global vars */
extern HINSTANCE hInst;
extern HWND MainhWnd;
extern BOOL settingChanged;
extern DWORD platform;

/**************************************************************/
//			Functions in this file
/**************************************************************/
void Create_The_Rest(LPSTR lpCmdLine, HINSTANCE hInstance);
void ReadIn_OldDict(HINSTANCE hInstance);
BOOL BLDExitApplication(HWND hWnd);
void ConfigSwitchKey(UINT vk, BOOL bSet);
void ConfigPort(BOOL bSet);
BOOL BLDMenuCommand(HWND, unsigned , WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\door.h ===
/*****************************************************************************/
/*  Data structure for DEFAULT AND PREFERENCES SETTING                       */
/*****************************************************************************/

#ifndef _DOOR_H		//v_mjgran: To avoid data redefinitions
#define _DOOR_H

typedef struct tagKBPREFINFO
{
	//keyboard preference
	int 			g_margin;         	// Margin between rows and columns
	BOOL			smallKb;			// TRUE when working with Small Keyboard
	COLORREF		PrefTextKeyColor;  		// Prefered Color for text in keys
	COLORREF 		PrefCharKeyColor; 		// normal key
	COLORREF 		PrefModifierKeyColor;	// modifier key
	COLORREF 	    PrefDeadKeyColor; 		// dead key
	COLORREF		PrefBackgroundColor; 	// ditto Keyboard backgraund
	int			    PrefDeltakeysize;		// Preference increment in key size
	BOOL			PrefshowActivekey;		// Show cap letters in keys
    int				KBLayout;				// 101, 102, 106, KB layout
	BOOL			Pref3dkey;              // Use 3d keys
	BOOL			Prefusesound;			// Use click sound
	BOOL			PrefAlwaysontop;		// windows always on top control
	BOOL			Prefhilitekey;			// True for hilite eky under cursor
	BOOL			PrefDwellinkey;			// use dwelling system
	UINT			PrefDwellTime;	  		// Dwell time preference
	LOGFONTA	    lf;						// default font


	//import Dlg
	BOOL			DICT_LRNNEXT;
	BOOL			DICT_LRNNUM;
	BOOL			bReadLonger;
	BOOL			bWordToKeep;
	int			    minLength;
	long			maxWords;

	//Predict Dlg
	BOOL			typeFast;      //use clipboard ?
	BOOL			WListVisib;    //Word list visible
	BOOL			PredictNext;   //Predict next words
	BOOL    		Cap;           //Cap after period
	int    		    ShortestWord;  //Shorest Word
	int             space;         //how many space AFTER SENTENCE
	BOOL    		VorH;          //v = vertical h = horizontal word list
                                   //  (TRUE is V)
	int             WordShown;     //how many predict keys to create
	int			    WordFound;	   //how many words to find
	LOGFONTA        PredLF;        //store the font for predict window
	COLORREF		PredTextColor; //prefer color for predict text
    COLORREF        PredKeyColor;  //prefer color for predict key
    BOOL            AddSpace;      //Add space after , : ; or not

    //Scanning Option
    UINT            uKBKey;         // vk of scan key
    BOOL            bKBKey;         // use scan key
    BOOL            bPort;         // open the serial, parallel, game port 

	//Option Dlg
	BOOL			DICT_LRNNEW;
	BOOL			DICT_LRNFREQ;
	BOOL			DICT_PURGAUTO;
	BOOL			DICT_AUTOINCREASE;
	BOOL            WAIT_DLG_SHOWWORDS;

	//size and position of KB and Predictor
	RECT            KB_Rect;
	RECT            Pred_Rect;
    RECT            Pred_Crect;
	float           Pred_Width;
    float           Pred_Height;

	//HotKeys Dlg
	UINT            HotKeyList[30];    //array to store HotKeys
	BOOL            HK_F11;            //disable / enable the f11 hot key
	BOOL            HK_Show;
	UINT            Choice;            //choices for Func, numbers, keypad, all
	BOOL			HK_Enable;         //diasable / enable hotkey
	BOOL            HK_Front;
	BOOL			FastSel;

	BOOL            PrefScanning;      //use scanning
	UINT            PrefScanTime;
	
	BOOL			Actual;            // T - Actual or F - Block KB

	//Application preference
	BOOL			fShowWarningAgain;		// Show the initial warning dialog again


} KBPREFINFO;

typedef KBPREFINFO*  LPKBPREFINFO;

//
// Pointer to keyboard preference and other dialog option
// and the buffer we use to save and read from file
//
extern KBPREFINFO   *kbPref;   

#endif   //_DOOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\kbfunc.h ===
/****************************************************************************/
/* FUNCTIONS IN THIS FILE */
/****************************************************************************/
BOOL InitProc(void);
BOOL RegisterWndClass(HINSTANCE hInst);
HWND CreateMainWindow(BOOL re_size);
void mlGetSystemParam(void);
BOOL SetZOrder(void);
void FinishProcess(void);
void udfDraw3D(HDC hdc, RECT brect);
void udfDraw3Dpush(HDC hdc, RECT brect);

void UpdateKey(HWND hwndKey, HDC hdc, RECT brect, int index, int iKeyVal);

BOOL ChooseNewFont(HWND hWnd);
void ChangeTextKeyColor(void);
BOOL RDrawIcon(HDC hDC, TCHAR *pIconName, RECT rect);
BOOL RDrawBitMap(HDC hDC, TCHAR *pIconName, RECT rect, BOOL transform);
BOOL SavePreferences(void);
BOOL OpenPreferences(void);
void DeleteChildBackground(void);
HFONT	ReSizeFont(int index, LOGFONT *plf, int outsize);
BOOL NumLockLight(void);
void RedrawKeys(void);
void DrawIcon_KeyLight(HDC hDC, int which, RECT rect);
void SetKeyRegion(HWND hwnd, int w, int h);
void CapShift_Redraw(void);
int GetKeyText(UINT vk, UINT sc, BYTE *kbuf, TCHAR *cbuf, HKL hkl);
BOOL RedrawNumLock(void);
BOOL RedrawScrollLock(void);
void ChangeBitmapColorDC (HDC hdcBM, LPBITMAP lpBM, COLORREF rgbOld, COLORREF rgbNew);
void ChangeBitmapColor (HBITMAP hbmSrc, COLORREF rgbOld, COLORREF rgbNew, HPALETTE hPal);
BOOL RegisterKeyClasses(HINSTANCE hInst);

// Handy defines
#define GWLP_USERDATA_TEXTCOLOR GWLP_USERDATA

void InitKeys();
void UninitKeys();
void UpdateKeyLabels(HKL hkl);

extern int g_cAltGrKeys;
__inline BOOL CanDisplayAltGr() { return (g_cAltGrKeys)?TRUE:FALSE; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\kbmain.h ===
// KBMAIN.H      KEYBOARD MAIN HEADER FILE


/**************************************************************************/
/* GLOBAL DEFINES  */
/**************************************************************************/
// WINDOW TYPES
#define KB_MAIN_WND    	1
#define KB_KEY_WND	  	2
#define KB_MODIFIER_WND 3
#define KB_DEAD_WND		4
#define KB_NUMBASE_WND 	5
#define KB_NUMKEY_WND  	6
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5

// KEYBOARD MARGINS
//The smallest width (pixel) you can get for KB
//#define KB_SMALLRMARGIN  152//137     //for width(smallKB).  152 - Block, 137 - Actual  (Moved to kbmain, WM_SIZE) 
#define KB_LARGERMARGIN  202     //for width
#define KB_CHARBMARGIN   57        //for height


#define KB_NUMRMARGIN
#define KB_NUMBMARGIN

// KEYBOARD NUMBERKEY
#define KB_HOWMANYKEY	 130    // IT HAS TO INCLUDE THE NUMERIC KEYBOARD 

// SOUND TYPES
#define SND_UP 		1
#define SND_DOWN 		2

// TIMERS
#define TIMER_HELPTOOLTIP 1014

#include "door.h"

LRESULT WINAPI kbMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI kbKeyWndProc(HWND hwndKey, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK KeybdInputProc(WPARAM  wParam, LPARAM  lParam);
void RelocateDialog(HWND hDlg);

#define CAPLOCK_SCANCODE 0x3A
#define LSHIFT_SCANCODE  0x2A
#define RSHIFT_SCANCODE  0x36
#define TAB_SCANCODE     0x0f
#define BREAK_SCANCODE   0xE1
#define LMENU_SCANCODE   0x38
#define RMENU_SCANCODE   0x38 // extended 0xE0
#define CONTROL_SCANCODE 0x1D

#define RGB_KEYBGHIGHLIGHT COLOR_HIGHLIGHT /*RGB(0,0,0)*/

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) sizeof(x)/sizeof(x[0])
#endif

/**************************************************************************/
/* GLOBAL VARIABLES  */
/**************************************************************************/

extern LPKBPREFINFO lpkbPref;				// Pointer to KB structure
extern LPKBPREFINFO lpkbDefault;			// ditto Default
extern HINSTANCE 	hInst;					// iinstance of keyboard process
extern HWND   	   *lpkeyhwnd;				// ptr to array of HWND
extern HWND 		numBasehwnd;			// HWND to the num base window
extern HWND			g_hwndOSK;				// HWND to the kbmain window
extern int 			lenKBkey;				// How Many Keys?
extern int          scrCY;					// Screen Height
extern int 			scrCX;					// Screen Width
extern int 			captionCY;				// Caption Bar Height
extern HHOOK		hkJRec;					// HHOOK to the Journal Record
extern int 			g_margin;         		// Margin between rows and columns
extern BOOL			smallKb;				// TRUE when working with Small Keyboard
extern COLORREF	PrefTextKeyColor;   		// Prefered Color for text in keys
extern COLORREF 	PrefCharKeyColor; 		// ditto normal key
extern COLORREF 	PrefModifierKeyColor;	// ditto modifier key
extern COLORREF 	PrefDeadKeyColor;       // ditto dead key
extern COLORREF	PrefBackgroundColor;        // ditto Keyboard backgraund
extern BOOL			PrefAlwaysontop;			// Always on Top control
extern int			PrefDeltakeysize;			// Preference increment in key size
extern BOOL			PrefshowActivekey;		// Show cap letters in keys
extern int			KBLayout;				// 101, 102, 106, KB layout
extern BOOL			Prefusesound;				// Use click sound
extern BOOL			newFont;						// Font is changed
extern LOGFONT		*plf;            			// pointer to the actual char font
extern HGDIOBJ 	oldFontHdle;     			// Old object handle
extern COLORREF	InvertTextColor; 			//Font color on inversion
extern COLORREF	InvertBKGColor;			//BKG color on inversion
extern BOOL			Prefhilitekey;				// True for hilite eky under cursor

// Dwelling time control variables
extern BOOL			PrefDwellinkey;			// use dwelling system
extern UINT			PrefDwellTime;		    // Dwell time preference

extern BOOL         PrefScanning;           //use scanning
extern UINT         PrefScanTime;           //Prefer scan time

extern BOOL		    g_fShowWarningAgain;		// Show initial warning dialog again

extern HWND			Dwellwindow;	  		// dwelling window

extern int	 		stopPaint;				// stop the bucket paint
extern 				UINT_PTR timerK1;       // timer id for keyboard
extern 				UINT_PTR timerK2;		// timer for print line on key
/*****************************************************************************/

extern BOOL g_fDrawCapital;
extern BOOL g_fCapsLockOn;
extern BOOL g_fShiftKeyDn;
extern BOOL g_fRAltKey;			// TRUE if the RALT key is down
extern BOOL	g_fLAltKey;			// TRUE if the left ALT key is down
extern BOOL g_fLCtlKey;         // TRUE if the left CTRL key is donw
extern HWND g_hwndInputFocus;   // the window we are inputting to


//
// These are the different 'modified' states a key can have. Note that shifted,
// caps-lock, and shifted-caps-lock are all different states, since alphabetic
// numbers and symbols behave differently in these states.
//
typedef enum {
    KEYMOD_NORMAL,
    KEYMOD_SHIFTED,
    KEYMOD_CAPSLOCK,
    KEYMOD_SHIFTEDCAPSLOCK,
    KEYMOD_ALTGR,
    KEYMOD_STATES
} KEYMODSTATE;



__inline BOOL AltGrKeyPressed()	
{ 
    // this check is relaxed because the OS sets LCTRL toggled when LALT key is pressed
    return (g_fRAltKey || (g_fLAltKey && g_fLCtlKey))? TRUE:FALSE; 
}

__inline BOOL CapsLockIsOn() 
{ 
	return (g_fCapsLockOn)?TRUE:FALSE; 
}

__inline KEYMODSTATE GetModifierState()
{
	// The order of keyboard state checking is important; ALTGR takes
	// precedence over the shift/capslock variants, which takes precedence
    // over normal.
    if( AltGrKeyPressed() )
        return KEYMOD_ALTGR;

    if( g_fCapsLockOn && g_fShiftKeyDn )
        return KEYMOD_SHIFTEDCAPSLOCK;

    if( g_fCapsLockOn )
        return KEYMOD_CAPSLOCK;

    if( g_fShiftKeyDn )
        return KEYMOD_SHIFTED;

    return KEYMOD_NORMAL;
}


__inline HWND OurInputTarget() 
{ 
	if (!IsWindow(g_hwndInputFocus))
	{
		g_hwndInputFocus = NULL;
	}
	return g_hwndInputFocus; 
}

__inline HKL GetCurrentHKL()
{
    DWORD dwProcessId;
    HWND hwnd = OurInputTarget();
	return GetKeyboardLayout(GetWindowThreadProcessId((hwnd)?hwnd:g_hwndOSK, &dwProcessId));
}

__inline void SetBackgroundColor(HWND hwnd, unsigned long ulColor)
{
    SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)(ulColor+1));
}

BOOL OSKRunSecure();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\keyrc.h ===
/*Filename: KEYRC.H                                         */

/* Give access to handles in all code modules */
extern HINSTANCE hInst;
extern HWND MainhWnd;
 



/***************************************************************/ 
/* Variables, types and constants for controls in main window. */ 
/***************************************************************/ 
 
extern HWND hClient;     /* Handle to window in client area.   */
extern FARPROC lpClient; /* Function for window in client area.*/
 
#define CLIENTSTRIP WS_MINIMIZE|WS_MAXIMIZE|WS_CAPTION|WS_BORDER|WS_DLGFRAME|WS_SYSMENU|WS_POPUP|WS_THICKFRAME|DS_MODALFRAME
 
typedef struct 
  {
  unsigned long dtStyle;
  BYTE dtItemCount;
  int dtX;
  int dtY;
  int dtCX;
  int dtCY;
  } BLD_DLGTEMPLATE;
 
typedef BLD_DLGTEMPLATE  *LPBLD_DLGTEMPLATE;
 

    
/* User Defined ID Values               */
    
#define IDOK							  1
#define IDCANCEL						  2
#define COLORKBBACKGROUND			 10
#define COLORKBCHARACTERKEYS	  	 11
#define COLORKBTEXT				  	 12
#define COLORKBMODIFIERKEYS	  	 13
#define COLORKBDEFAULTSETTING		 14
#define COLORKBDEADKEYS				 15

#define SETDEFAULTSETTINGS			108
#define KBLANGUAGECOMBO				110
#define ALWAYSONTOP					111
#define KEYSIZE_0						112
#define KEYSIZE_1						113
#define KEYSIZE_2						114
#define KEYSIZE_3						115
#define KEYSIZE_4						116
#define DWELLONKEYS					118
#define DWELLMS					   119
#define HILITEKEY						120
#define DWELLTIMESCROLL				121
#define KBSHOWACTIVEKEYSCK			122
#define KBKEEPPROPORTIONSCK	 	123
#define KBUSE3DKEYSCK			  	124
#define KBUSECLICKSOUNDCK		 	125
#define KBSIZEBUT						126
#define KBFONTBUT						127
#define KBCOLORSBUT					128
#define IDC_LTEXT1					129
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\kbkeydef.h ===
// KBKEYDEF.H        KEY DEFINITIONS

#define ECOLNUMB     21   // NUMBER OF COLUMNS IN ENHANCED KEYBOARD
#define EROWNUMB	  7   // DITO ROWS
#define ETOTALKEY	125   // ENHANCED KEYBOARD only main keys. 
                          // included separators

// KEY NAMES
#define KB_LSHIFT   	0
#define KB_RSHIFT	 	1
#define KB_CAPLOCK		2
#define KB_SPACE		3
#define KB_LCTR			4
#define KB_RCTR			5
#define KB_LALT			6
#define KB_RALT			7
#define KB_NUMLOCK      8
#define KB_PSC          9
#define NO_NAME			10
#define LED_NUMLOCK     11
#define LED_CAPSLOCK    12
#define LED_SCROLLLOCK  13
#define ICON            14
#define KB_SCROLL       15
#define BITMAP			16

// KEY TYPES
#define KNORMAL_TYPE	     1
#define KMODIFIER_TYPE       2
#define KDEAD_TYPE           3
#define LED_NUMLOCK_TYPE     4
#define LED_CAPSLOCK_TYPE    5
#define LED_SCROLLLOCK_TYPE  6
#define NUMLOCK_TYPE         7
#define SCROLLOCK_TYPE       8


// TYPE OF KEYBOARD
#define LARGE    1
#define SMALL	 2
#define BOTH	 3
#define NOTSHOW  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\ms32dll.h ===
/***************************************************************************/
/*     Functions Declaration      */
/***************************************************************************/

void RedrawKeysOnLanguageChange();
BOOL IsOneOfOurKey(HWND hwnd);
void DoAllUp (HWND hwnd, BOOL sendchr);
void DoButtonDOWN(HWND hwnd);
void SendWord(LPCSTR lpszKeys);
BOOL udfKeyUpProc(HWND khwnd, int keyname);
void MakeClick(int what);
void InvertColors(HWND hwnd, BOOL fForceUpdate);
void ReturnColors(HWND hwnd, BOOL inval);
void CALLBACK YourTimeIsOver(HWND hwnd, UINT uMsg, 
                             UINT_PTR idEvent, DWORD dwTime);
void killtime(void);
void Cursorover(void);
void SetTimeControl(HWND hwnd);
void PaintBucket(HWND hwnd);
void CALLBACK Painttime(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
void SendChar(HWND hwndKey);

int CharTrans(int index, BOOL *SkipSendkey);

void ReDrawModifierKey(void);

void Extra_Key(HWND hwnd, int index);

void PaintLine(HWND hwnd, HDC hdc, RECT rect);
void ReleaseAltCtrlKeys(void);
BOOL IsModifierPressed(HWND hwndKey);

#define MENUKEY_NONE  0
#define MENUKEY_LEFT  1
#define MENUKEY_RIGHT 2
extern int g_nMenu;				// holds menu key state
extern BOOL g_fControlPressed;	// TRUE if the CTRL key is down
extern BOOL g_fDoingAltTab;		// TRUE if LALT is down and TAB is being pressed

static __inline BOOL LAltKeyPressed()		{ return g_nMenu == MENUKEY_LEFT; }
static __inline BOOL LCtrlKeyPressed()	    { return g_fControlPressed; }
static __inline BOOL DoingAltTab()          { return g_fDoingAltTab; }
void SetCapsLock(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\msswch.h ===
/***** Normal use, default configuration *****/

// global keyboard hook entry

#define WM_GLOBAL_KBDHOOK WM_USER+3

BOOL APIENTRY RegisterHookSendWindow(HWND hwnd, UINT uiMsg);

// hidden switch window information

#define SWITCH_TIMER 1015

void SwitchOnCreate(HWND hWnd);
void SwitchOnEndSession(HWND hWnd);
void SwitchOnTimer(HWND hWnd);
void SwitchOnPollMsg(HWND hWnd);
BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam);

// msswch.dll header information

typedef HANDLE HSWITCHPORT;

HSWITCHPORT APIENTRY swchOpenSwitchPort(
	HWND				hWnd,
	DWORD				dwPortStyle );

#define PS_POLLING	1
#define PS_EVENTS		2

BOOL APIENTRY swchCloseSwitchPort(
	HSWITCHPORT		hSwitchPort );

#define NUM_SWITCHES		6
#define BIT_SWITCHES		0x003F

#define SWITCH_NONE 		0x0000
#define SWITCH_1			0x0001
#define SWITCH_2			0x0002
#define SWITCH_3			0x0004
#define SWITCH_4			0x0008
#define SWITCH_5			0x0010
#define SWITCH_6			0x0020

// These messages need to be reserved with Microsoft
#define SW_SWITCHDOWNBASE	0x00E0
#define SW_SWITCH1DOWN		(SW_SWITCHDOWNBASE + 1)
#define SW_SWITCH2DOWN		(SW_SWITCHDOWNBASE + 2)
#define SW_SWITCH3DOWN		(SW_SWITCHDOWNBASE + 3)
#define SW_SWITCH4DOWN		(SW_SWITCHDOWNBASE + 4)
#define SW_SWITCH5DOWN		(SW_SWITCHDOWNBASE + 5)
#define SW_SWITCH6DOWN		(SW_SWITCHDOWNBASE + 6)

// These messages need to be reserved with Microsoft
#define SW_SWITCHUPBASE		0x00F0
#define SW_SWITCH1UP			(SW_SWITCHUPBASE + 1)
#define SW_SWITCH2UP			(SW_SWITCHUPBASE + 2)
#define SW_SWITCH3UP			(SW_SWITCHUPBASE + 3)
#define SW_SWITCH4UP			(SW_SWITCHUPBASE + 4)
#define SW_SWITCH5UP			(SW_SWITCHUPBASE + 5)
#define SW_SWITCH6UP			(SW_SWITCHUPBASE + 6)

/***** Configuration *****/

typedef HANDLE HSWITCHDEVICE;

// make this a dword rather then a handle this is to make this 64 bit portable
typedef DWORD  HJOYDEVICE;

// This message needs to be reserved with Microsoft
#define SW_SWITCHCONFIGCHANGED	0x00D0

#define SC_TYPE_COM				1
#define SC_TYPE_LPT				2
#define SC_TYPE_JOYSTICK		3
#define SC_TYPE_KEYS				4

// Not defined yet
#define SC_TYPE_USB				5
#define SC_TYPE_1394				6

typedef struct _SWITCHLIST {
 DWORD dwSwitchCount;
 HSWITCHDEVICE hsd[ANYSIZE_ARRAY];
} SWITCHLIST, *PSWITCHLIST;

typedef struct _SWITCHCONFIG_LPT {
 DWORD dwReserved1;	// possible future Status register preset
 DWORD dwReserved2;	// possible future Data register preset
} SWITCHCONFIG_LPT, *PSWITCHCONFIG_LPT;

typedef struct _SWITCHCONFIG_JOYSTICK {
 DWORD dwJoySubType;
 DWORD dwJoyThresholdMinX;
 DWORD dwJoyThresholdMaxX;
 DWORD dwJoyThresholdMinY;
 DWORD dwJoyThresholdMaxY;
 DWORD dwJoyHysteresis;
} SWITCHCONFIG_JOYSTICK, *PSWITCHCONFIG_JOYSTICK;

typedef struct _SWITCHCONFIG_KEYS {
 DWORD dwKeySwitch1;
 DWORD dwKeySwitch2;
} SWITCHCONFIG_KEYS, *PSWITCHCONFIG_KEYS;

typedef struct _SWITCHCONFIG_USB {
 // *** NOT DEFINED YET ***
 DWORD dwReserved;
} SWITCHCONFIG_USB, *PSWITCHCONFIG_USB;

typedef struct _SWITCHCONFIG_IEEE1394 {
 // *** NOT DEFINED YET ***
 DWORD dwReserved;
} SWITCHCONFIG_IEEE1394, *PSWITCHCONFIG_IEEE1394;

typedef struct _SWITCHCONFIG_COM {
 DWORD dwComStatus;
} SWITCHCONFIG_COM, *PSWITCHCONFIG_COM;

typedef struct _SWITCHCONFIG {
 DWORD cbSize;
 UINT uiDeviceType;
 UINT uiDeviceNumber;
 DWORD dwFlags;
 DWORD dwSwitches;
 DWORD dwErrorCode;
 union {
   SWITCHCONFIG_COM  Com;
   SWITCHCONFIG_LPT  Lpt;
   SWITCHCONFIG_JOYSTICK   Joystick;
   SWITCHCONFIG_KEYS Keys;
   SWITCHCONFIG_USB  USB;
   SWITCHCONFIG_IEEE1394 IEEE1394;
 } u;
} SWITCHCONFIG, *PSWITCHCONFIG;

HSWITCHDEVICE swchGetSwitchDevice(
	HSWITCHPORT		hSwitchPort,
	UINT				uiDeviceType,
	UINT				uiDeviceNumber	);

UINT swchGetDeviceType( 
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd );

UINT swchGetPortNumber(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd	);

BOOL swchGetSwitchConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );

BOOL swchSetSwitchConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );

//v-mjgran: API to modify return value in keyboard hook. Avoid to send the scan char.
void APIENTRY swchCheckForScanChar (BOOL fCheckForScanKey);
LRESULT CALLBACK swcKeyboardHookProc( int nCode, WPARAM wParam, LPARAM lParam );

// bitflags
#define SC_FLAG_ACTIVE			0x00000001
#define SC_FLAG_DEFAULT			0x00000002
#define SC_FLAG_ERROR			0x00000004
#define SC_FLAG_UNAVAILABLE	0x00000080

// bitflags
#define SC_COM_DTR		0x00000010
#define SC_COM_RTS		0x00000020
#define SC_COM_DEFAULT	SC_COM_RTS

// bitflags
#define SC_LPT_STROBE	0x00000100
#define SC_LPT_AF			0x00000200
#define SC_LPT_INIT		0x00000400
#define SC_LPT_SLCTIN	0x00000800
#define SC_LPT_DEFAULT	0

#define SC_LPTDATA_DEFAULT  0x000000FF

#define SC_JOY_BUTTONS	0
#define SC_JOY_XYSWITCH	1
#define SC_JOY_XYANALOG	2
#define SC_JOY_DEFAULT	SC_JOY_BUTTONS

#define SC_JOYVALUE_DEFAULT	0


// Error return values
#define SWCHERR_NO_ERROR				0
#define SWCHERR_ERROR					1
#define SWCHERR_INVALID_PARAMETER	2
#define SWCHERR_MAXIMUM_USERS			3
#define SWCHERR_ALREADY_OPEN			4
#define SWCHERR_NULL_POINTER			5
#define SWCHERR_INVALID_BUFFER_SIZE	6
#define SWCHERR_ALLOCATING_MEMORY	7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\osk.h ===
#define IDH_OSK_CLICK_MODE 70500 //options dialog
#define IDH_OSK_DWELL_MODE 70505//options dialog
#define IDH_OSK_DWELL_TIME 70510//options dialog
#define IDH_OSK_SCAN_MODE 70515//options dialog
#define IDH_OSK_SCAN_TIME 70520//options dialog
#define IDH_OSK_OK		70525//OK button
#define IDH_OSK_CANCEL	70530//Cancel button
#define IDH_ADVANCED	70535//Advanced button
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\kbus.h ===
//  KB_US.H     KEY DEFINITIONS FOR US EXTENDED KEYBOARD (101 KEYS)


#include "KBKEYDEF.H"

	/* the position of the key is given in relative units to the
		comence of the drawing.  That means that an X or Y position of
		350 means that the x or y edge is drawing begining in the position
		p + 350. In this case the 'p' value is the offset from the edge.*/

typedef	struct KBkeyRec
		{
		LPTSTR  textL;       // text in key lower
		LPTSTR  textC;       // text in key capital
		LPTSTR	skLow;       // What has to be printed low letter
		LPTSTR  skCap;   	 // What has to be printed cap letter
		int 	name;		 // BITMAP, LSHIFT, RSHIF...
		short	posY;		 // See explanation above
		short	posX;		 // same as above
		short	ksizeY;		 // key size in conventional units
		short	ksizeX;		 // same as above
		BOOL 	smallF;		 // TRUE = text has to be written in smaller font
		int  	ktype;		 // 1 - normal, 2 - modifier, 3 - dead
		int		smallKb;	 // SMALL, LARGE, BOTH, NOTSHOW
        BOOL    Caps_Redraw; // Redraw the window for shift, caps
		int 	print;	     //1 - print use ToAscii(), 2 - print the text provided by the header file   
		UINT	scancode[4]; // key scan-code
        LPTSTR  apszKeyStr[KEYMOD_STATES];// key labels for each keyboard layout (0=no modifiers 1=SHIFTED 2=ALTGR)
		BYTE    abKeyType[KEYMOD_STATES];// "ktype" for each keyboard layout
		}KBkeyRec;

extern struct KBkeyRec KBkey[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\osksetti.h ===
//-----------------------------------------------------------------
//
//  Copyright (c) 1998 Microsoft Corporation
//
//  This H file was generated by the perl script regtoh.pl.
//
//  This file was last generated on: 7/7/100 at: 10:53:2.
//
//  Be sure to bump up the CURRENT_STEPPING when the structure changes.
//  Changing the stepping will force an update to the registry.
//
//  Please do not edit this file directly.
//
//-----------------------------------------------------------------

#define CURRENT_STEPPING 3

BYTE g_DefaultSettings[] = {

 0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0x00,0xff,0x80,0xc0,0x00,0x00, 
  0xff,0x40,0x00,0x80,0x80,0xff,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe8,0x03,0x00,0x00,0xf5,0xff,0xff,0xff,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x02,0x01,0x22,0x4d,0x53,0x20,0x53, 
  0x68,0x65,0x6c,0x6c,0x20,0x44,0x6c,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x98,0x3a, 
  0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00, 
  0x00,0x01,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0xbc,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x22,0x53,0x79,0x73,0x74,0x65,0x6d,0x00,0x10,0x68, 
  0x8a,0xf7,0x0c,0xac,0x00,0x01,0x00,0x94,0x33,0x02,0x00,0x00,0x00,0x57,0x01,0x00,0x00,0x09,0x00,0x8b,0x01,0xa4,0x01,0x00,0x00, 
  0x00,0x00,0x80,0xff,0x80,0x00,0x01,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00, 
  0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xb8,0x00,0x00,0x00,0x9d,0x01,0x00,0x00,0x20,0x03,0x00,0x00, 
  0x01,0x04,0x00,0x00,0xe3,0x03,0x00,0x00,0x6d,0x01,0x00,0x00,0xee,0x02,0x00,0x00,0x39,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x72,0x00,0x00,0x00,0xb1,0x00,0x00,0x00,0x00,0x00,0xbc,0x42,0x00,0x00,0xc8,0x41,0x71,0x00,0x00,0x00,0x72,0x00, 
  0x00,0x00,0x73,0x00,0x00,0x00,0x74,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x76,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x78,0x00,0x00, 
  0x00,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00, 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf4,0x01,0x00,0x00, 
  0x01,0x00,0x00,0x00,0x01,0x3b,0x2e,0x4a
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\scan.h ===
/***********************************************/
//			Functions in this file
/***********************************************/
void Scanning(int from);
void CALLBACK LineScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK KeyScanProc_Actual_101(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK KeyScanProc_Actual_106(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK KeyScanProc_Actual_102(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void RestoreRowColor(int Row);
void RestoreKeyColor(int i);
void KillScanTimer(BOOL reset);

void Scanning_Actual(int from);
void Scanning_Block(int from);
void CALLBACK KeyScanProc_Block(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void CALLBACK BlockScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
void RestoreBlockColor(int ColStart, int ColEnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\pd32002.h ===
/*Filename: PD32002.H                                       */


/* Global vars */
extern HINSTANCE hInst;
extern HWND MainhWnd;
extern BOOL settingChanged;
extern HWND hClient;     /* Handle to window in client area.   */
extern FARPROC lpClient; /* Function for window in client area.*/

extern DWORD platform;




#define BLD_CannotRun          5000
#define BLD_CannotCreate       5001
#define BLD_CannotLoadMenu     5002
#define BLD_CannotLoadIcon     5003
#define BLD_CannotLoadBitmap   5004

#if !defined(THISISBLDRC)


/***************************************************************/
/* Variables, types and constants for controls in main window. */
/***************************************************************/

#define CLIENTSTRIP WS_MINIMIZE|WS_MAXIMIZE|WS_CAPTION|WS_BORDER|WS_DLGFRAME|WS_SYSMENU|WS_POPUP|WS_THICKFRAME|DS_MODALFRAME

typedef struct
  {
  unsigned long dtStyle;
  BYTE dtItemCount;
  int dtX;
  int dtY;
  int dtCX;
  int dtCY;
  } BLD_DLGTEMPLATE;

typedef BLD_DLGTEMPLATE            *LPBLD_DLGTEMPLATE;

#endif


//DIALOG DEFINES

#define CHECK     1
#define UNCHECK   0

/* User Defined ID Values               */
#define DLG_OK			 1
#define DLG_CANCEL  	 2

//About Dlg
#define About_Credits_but	101
#define shade	102



/**************************************************************/
//          Functions in this file
/**************************************************************/
void Create_The_Rest(LPSTR lpCmdLine, HINSTANCE hInstance);
void ReadIn_OldDict(HINSTANCE hInstance);


/****************************************************************/
//      Functions in pd32f2.c  and pd32002.c
/****************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine
, int nCmdShow);
LRESULT WINAPI MainWndProc(HWND,unsigned,WPARAM, LPARAM);
BOOL BLDKeyTranslation(HWND, HACCEL, MSG *);
BOOL BLDInitApplication(HINSTANCE,HINSTANCE,int *,LPSTR);
BOOL BLDExitApplication(HWND hWnd);      /* Called just before exit of applicati
on  */
BOOL BLDMenuCommand(HWND, unsigned , WPARAM, LPARAM);
int SaveChangesMessage(HWND hwnd, char *msg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\sdgutil.h ===
/*************************************************************/
//Functions in this file
/*************************************************************/
void SendErrorMessage(UINT ids_string);
void GetPreferences(void);
DWORD WhatPlatform(void);
BOOL IsOutOfScreen(int scrCX, int scrCY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\tpoption.h ===
//#pragma once
#include <time.h>
#define MAX_HISTORY	10
#define STATVERSION 249 

/*typedef struct Statistics	{
	short	version;
	short	index;
	time_t	begTime[MAX_HISTORY];
	time_t	endTime[MAX_HISTORY];
	short	realKeys[MAX_HISTORY];
	short	postKeys[MAX_HISTORY];
	short	newDicts[MAX_HISTORY];
	short	newWords[MAX_HISTORY];
	short	newNexts[MAX_HISTORY];
	short	hitWords[MAX_HISTORY];
	short	hitAbbrs[MAX_HISTORY];
	short	mouseDowns[MAX_HISTORY];
	short	switches[MAX_HISTORY];
	} Statistics;
*/

typedef struct TSDict {
//	short	version;	
// structure version
	char	name[32];	 // name of this topic 

    //flags
//	unsigned DICT_LRNNEW  : 1;	// learn new words
//	unsigned DICT_LRNNEXT : 1;	// learn next words
//	unsigned DICT_LRNFREQ : 1;	// adjust word freq
//	unsigned DICT_SYMBOL  : 1;	// Symbolic dictionary (ie: Minspeak)
//	unsigned DICT_2BYTE   : 1;	// Two byte symbols (ie: Kanji)
//	unsigned DICT_REVERSE : 1;	// Runs right to left (ie: Hebrew)
//	unsigned DICT_PREDICT : 1;	// Use for predictions
//	unsigned DICT_PURGAUTO: 1;	// Autopurge if too full?
//	unsigned DICT_PURGASK : 1;	// Ask before purging
//	unsigned DICT_CURRENT : 1;	// current option item
//	unsigned DICT_LRNNUM  : 1;  // learn number
//	unsigned CAP		  : 1;  // capitialize new sentence

//	short	maxWords;	// words per topic
//	short	minLength;	// minimum word length
//	short	weight;		// how much to weight the probs
//	short   space;      //how many space after sentence

	short	tnmbr[256];	// how many in chain
	struct TSFreq *atops[256];	// first word in alpha chain
	struct TSFreq *ftops[256];	// first word in freq chain

//	struct TSFreq *dtops[256];	// first word in disamb chain
//	short	indx;		        // TSFreq Group selected
//	short	nmbr;		        // how many in chain?
	struct TSFreq  *last;	    // last word seen
//	struct TSFreq  *nearest;	// word nearest to word to insert
	}	TSDict;

extern struct TSDict *dp;

typedef struct TSFreq
	{
	// flags
//	unsigned WORD_SLCT   	:1;	// this word was selected in last match
	unsigned WORD_LOCK   	:1; // never delete word
//	unsigned WORD_CASE   	:1;	// word is case sensitive
	unsigned WORD_ABBR   	:1;	// word is an abbreviation
//	unsigned WORD_IGNR   	:1;	// ignore this word
//	unsigned WORD_SAY    	:1;	// say this word
	unsigned WORD_TYPE   	:1;	// type this word
//	unsigned WORD_NNXT   	:1;	// don't learn next words
//	unsigned WORD_SCRIPT 	:1;	// word data is a script
//	unsigned WORD_FPROB		:1;	// don't change freq
//	unsigned WORD_PREV		:1;	// this word was previously shown
//	unsigned WORD_HELD		:1;	// this word was held over for next
//	unsigned WORD_DELETED 	:1;	// this word was deleted
//	unsigned WORD_BIAS		:1;	// this is a preferred word in this session
//	unsigned WORD_VOICE		:1;	// the word/abbr special pronounciation

	short	 freq;	//	freq for this word

	struct TSNext	*nhead;	//	head of next word list for this word
	struct TSFreq	*anext;	//	next entry alphabetical
	struct TSFreq	*fnext;	//	next entry frequency
//	struct TSFreq	*dnext;	//	next entry disambiguation
	char 	 	*word;	//	actual data
	char		*abbr;	//	actual data
	} TSFreq;

extern struct TSFreq  *wordCur,  *abbrCur;

typedef struct TSNext
	{
	short	freq;	// this word pair's freq
	struct TSFreq	*nword;	// next word
	struct TSNext	*nnext;	// next word pair in chain
	} TSNext;

//extern void *MemPool;
//extern BYTE *MemPoolPtr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\kbdhook.c ===
//
// KbdHook.c - contains the functions for global keyboard hooking in OSK
//
#include <windows.h>
#include <msswch.h>
#include <msswchh.h>
#include "mappedfile.h"
#include "w95trace.h"

#define THIS_DLL TEXT("MSSWCH.DLL")

//
//  Function Prototypes.
//
LRESULT CALLBACK OSKHookProc(int nCode, WPARAM wParam, LPARAM lParam);

////////////////////////////////////////////////////////////////////////////
//  DllMain
////////////////////////////////////////////////////////////////////////////
BOOL WINAPI MSSwchDll_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            DBPRINTF(TEXT("MSSwchDll_DllMain:  DLL_PROCESS_ATTACH\r\n"));
			swchOpenSharedMemFile();
            break;
        }

        case ( DLL_PROCESS_DETACH ) :
        {
            DBPRINTF(TEXT("MSSwchDll_DllMain:  DLL_PROCESS_DETACH\r\n"));
            swchCloseSharedMemFile();
            break;
        }
    }
    return (TRUE);

    UNREFERENCED_PARAMETER(lpvReserved);
}

////////////////////////////////////////////////////////////////////////////
//
//  RegisterHookSendWindow
//
//  The hwnd can be zero to indicate the app is closing down.
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY RegisterHookSendWindow(HWND hwnd, UINT uiMsg)
{
    if (!g_pGlobalData)
    {
        swchOpenSharedMemFile();
        if (!g_pGlobalData)
        {
            DBPRINTF(TEXT("RegisterHookSendWindow: ERROR !g_pGlobalData\r\n"));
            return TRUE;    // internal error! ignore we'll see it later.
        }
    }

    if (hwnd)
    {
        g_pGlobalData->hwndOSK = hwnd;
        g_pGlobalData->uiMsg = uiMsg;
		g_pGlobalData->fSyncKbd = TRUE;

		if (!g_pGlobalData->hKbdHook)
		{
			g_pGlobalData->hKbdHook = SetWindowsHookEx(
										WH_KEYBOARD,
										OSKHookProc,
										GetModuleHandle(THIS_DLL),
										0);
		}
    }
    else
    {
		g_pGlobalData->fSyncKbd;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  OSKHookProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK OSKHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	HANDLE hMutex;

    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHKEY, 5000))
    {
		HHOOK hhook;

		if (!g_pGlobalData)
		{
			ScopeUnaccessMemory(hMutex);
			return 1;
		}

        if (nCode == HC_ACTION)
        {
		    // Check if this key is the key that causes scanning to begin.  When this is 
		    // the scan key, scan mode gets detected in the msswch dll timer (it see's
		    // the "key up" on the scan key) and sends out the "do scanning" message.

		    if (swcKeyboardHookProc(nCode, wParam, lParam))
		    {
			    ScopeUnaccessMemory(hMutex);
			    return 1;
		    }

		    // if sync'ing with physical keyboard then pass
		    // this keystroke on to the OSK window

		    if (g_pGlobalData->fSyncKbd)
		    {
			    if (nCode >= 0)
			    {
				    PostMessage(g_pGlobalData->hwndOSK, // hwnd to receive the messagae
							    g_pGlobalData->uiMsg,   // the message
							    wParam,                 // the virtual key code
							    lParam );               // keystroke message flags
			    }
		    }
        }

		hhook = g_pGlobalData->hKbdHook;
		ScopeUnaccessMemory(hMutex);

		return CallNextHookEx(hhook, nCode, wParam, lParam);
    }
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\mappedfile.c ===
//Copyright (c) 1997-2000 Microsoft Corporation

// Memory mapped file routines

#include <windows.h>
#include <assert.h>
#include "msswch.h"
#include "mappedfile.h"
#include <malloc.h>
#include "w95trace.h"

HANDLE      g_hMapFile = NULL;     // handle to memory mapped file
PGLOBALDATA g_pGlobalData = NULL;  // pointer into memory mapped file

/****************************************************************************
   FUNCTION: ScopeAccessMemory() and ScopeUnaccessMemory()

	DESCRIPTION:
	Scoping functions protecting access to this DLL's shared memory file.

****************************************************************************/
BOOL ScopeAccessMemory(HANDLE *phMutex, LPCTSTR szMutex, unsigned long ulWait)
{
    assert(phMutex);
    if (phMutex)
    {
	    *phMutex = CreateMutex( NULL, FALSE, szMutex );
        if (*phMutex)
        {
    	    WaitForSingleObject( *phMutex, ulWait );
			return TRUE;
        }
    }
	DBPRINTF(TEXT("ScopeAccessMemory FAILED\r\n"));
    
    return FALSE;
}

void ScopeUnaccessMemory(HANDLE hMutex)
{
    if (hMutex)
    {
	    ReleaseMutex( hMutex );
	    CloseHandle( hMutex );
    }
}

/****************************************************************************

   FUNCTION: AccessSharedMemFile()

	DESCRIPTION:
		Create a shared memory file from system pagefile or open it if it
        already exists.  Returns TRUE if pvMapAddress is valid otherwise 
        returns FALSE.
    NOTE:
        pvMapAddress should be set to NULL before calling this function; 
       it allows calling multiple times, ignoring all but
        the first call.
				
****************************************************************************/

BOOL AccessSharedMemFile(
    LPCTSTR szName,         // name of the mapped file
    unsigned long ulMemSize,// size of the mapped file
    void **ppvMapAddress    // returned pointer to mapped file memory
    )
{
    assert(ppvMapAddress);
    if (!ppvMapAddress)
        return FALSE;

    if (!(*ppvMapAddress) && !g_hMapFile)
    {
        // Concatenate the passed in name with SHAREDMEMFILE

        LPTSTR pszName = (LPTSTR)malloc((lstrlen(szName) + lstrlen(SHAREDMEMFILE) + 1) *sizeof(TCHAR));
        if (!pszName)
            return FALSE;

        lstrcpy(pszName, szName);
        lstrcat(pszName, SHAREDMEMFILE);

        // Create the mapped file from system page file.  If it has been created
        // previously, then CreateFileMapping acts like OpenFileMapping.

        g_hMapFile = CreateFileMapping(
            INVALID_HANDLE_VALUE,    // Current file handle. 
            NULL,                    // Default security. 
            PAGE_READWRITE,          // Read/write permission. 
            0,                       // Hi-order DWORD of file size
            ulMemSize,               // Lo-order DWORD of file size
            pszName);                // Name of mapping object. 
 
        if (NULL == g_hMapFile) 
        {
            DBPRINTF(TEXT("CreateFileMapping for %s FAILED 0x%x\r\n"), pszName, GetLastError());
            free(pszName);
            return FALSE;
        }

        // Get a pointer to the mapped memory

        *ppvMapAddress = MapViewOfFile(
            g_hMapFile,              // Handle to mapping object. 
            FILE_MAP_ALL_ACCESS,     // Read/write permission 
            0,                       // Max. object size. 
            0,                       // Size of hFile. 
            0);                      // Map entire file. 
 
        if (NULL == *ppvMapAddress) 
        {
            DBPRINTF(TEXT("MapViewOfFile FAILED 0x%x\r\n"), GetLastError());
            free(pszName);
            return FALSE;
        }
        DBPRINTF(TEXT("CreateFileMapping for %s Succeeded\r\n"), pszName);
        free(pszName);
    }

    return TRUE;
}

/****************************************************************************

   FUNCTION: UnaccessSharedMemFile()

	DESCRIPTION:
		Clean up the shared memory file.
				
****************************************************************************/
void UnaccessSharedMemFile()
{
    if (g_pGlobalData)
    {
        UnmapViewOfFile(g_pGlobalData);
    }

    if (g_hMapFile)
    {
        CloseHandle(g_hMapFile);
        g_hMapFile = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\inc\sendkeys.h ===
/****************************************************************************
Module name  : SendKeys.H
Description  : Include File for SendKeys utility functions.
*****************************************************************************/

#ifndef _INC_SENDKEYS
#define _INC_SENDKEYS		/* #defined if SendKeys.h has been included */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define ARRAY_LEN(Array)			(sizeof(Array) / sizeof(Array[0]))
#define INRANGE(low, val, high) ((low <= val) && (val <= high))
#define TOUPPER(Char)		((BYTE) (DWORD) AnsiUpper((LPSTR) MAKEINTRESOURCE(Char)))



// ************************ Function Prototypes ******************************
typedef enum {
	SK_NOERROR, SK_MISSINGCLOSEBRACE, SK_INVALIDKEY,
	SK_MISSINGCLOSEPAREN, SK_INVALIDCOUNT, SK_STRINGTOOLONG,
	SK_CANTINSTALLHOOK
} SENDKEYSERR;

SENDKEYSERR WINAPI _export SendKeys (LPCSTR szKeys);
SENDKEYSERR WINAPI VMSendKeys (LPCSTR szKeys);
void WINAPI PostVirtualKeyEvent (BYTE bVirtKey, BOOL fUp);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
#endif  /* _INC_SENDKEYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\mappedfile.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

// This header contains the defines, typedefs and prototypes
// for managing the memory mapped file for this DLL.
//
#define SHAREDMEMFILE TEXT("_msswch")
#define SHAREDMEMFILE_MUTEX _T("MutexMSSwch")
#define SZMUTEXCONFIG _T("MutexMSSwchConfig")
#define SZMUTEXWNDLIST _T("MutexMSSwchWnd")
#define SZMUTEXSWITCHSTATUS _T("MutexMSSwchStatus")
#define SZMUTEXSWITCHKEY _T("MutexSwchKey")
#define SZMUTEXSWITCHLIST _T("MutexMSSwchList")

#define MAXWNDS	64
#define BIOS_SIZE 16
#define MAX_COM	4
#define MAX_JOYSTICKS	2
#define NUM_KEYS  2
#define MAX_LPT	3
// For now the list is static, since number of possible devices is known.
// 4 Com + 3 Lpt + 2 Joystick + 1 Key = 10 devices.
#define MAX_SWITCHDEVICES  10

typedef struct _USEWNDLIST
{
	HWND		hWnd;
	DWORD		dwPortStyle;
	DWORD		dwLastError;
} USEWNDLIST, *PUSEWNDLIST;

typedef struct _JOYSETTINGS
{
	DWORD		XMaxOn;
	DWORD		XMaxOff;
	DWORD		XMinOn;
	DWORD		XMinOff;
	DWORD		YMaxOn;
	DWORD		YMaxOff;
	DWORD		YMinOn;
	DWORD		YMinOff;
} JOYSETTINGS;

typedef struct _HOTKEY
{
	UINT mod;
	UINT vkey;
	UINT dwSwitch;
} HOTKEY;

typedef struct _INTERNALSWITCHLIST {
    DWORD dwSwitchCount;
    HSWITCHDEVICE hsd[MAX_SWITCHDEVICES];
} INTERNALSWITCHLIST, *PINTERNALSWITCHLIST;

typedef struct _GLOBALDATA
{
    // main global data

    HWND       hwndHelper;			      // The helper windows which owns shared resources
    DWORD      dwLastError;		          // The last error caused within this library
    USEWNDLIST rgUseWndList[MAXWNDS+1];   // list of using apps
    int	       cUseWndList;               // Count of using apps
    DWORD      dwSwitchStatus;		      // Bit field of status of switches
    BYTE       rgbBiosDataArea[BIOS_SIZE];// common bios status area

    // com port switch data

    SWITCHCONFIG_COM scDefaultCom;
    SWITCHCONFIG     rgscCom[MAX_COM];

    // joy stick switch data

    SWITCHCONFIG_JOYSTICK scDefaultJoy;
    SWITCHCONFIG          rgscJoy[MAX_JOYSTICKS];
    JOYSETTINGS	          rgJoySet[MAX_JOYSTICKS];

    // keyboard hook data for key press scan mode

    BOOL              fCheckForScanKey;	    // Check if sent key is a scan key
    HHOOK             hKbdHook;
    SWITCHCONFIG_KEYS scDefaultKeys;
    SWITCHCONFIG      scKeys;
    HOTKEY            rgHotKey[NUM_KEYS];
	BOOL              fScanKeys;            // TRUE if scanning based on key press

    // keyboard hook data for sync'ing soft keyboard with physical keyboard

    HWND			  hwndOSK;			// where to send key press information
    UINT			  uiMsg;			// the message expected by hwndOSK
	BOOL              fSyncKbd;         // TRUE if want to sync with physical keyboard

    // printer port switch data

    OSVERSIONINFO    osv;
    WORD             wPrtStatus;		// Printer status byte
    WORD             wCtrlStatus;		// Printer control byte
    WORD             wCurrByteData;		// Current data byte
    SWITCHCONFIG_LPT scDefaultLpt;
    SWITCHCONFIG     rgscLpt[MAX_LPT];

    // data for common handling of any switch device

    INTERNALSWITCHLIST SwitchList;
    DWORD              dwCurrentCount;
    DWORD              dwCurrentSize;
    DWORD              rgSwitches[NUM_SWITCHES]; // Array of bit field constants
    DWORD              rgSwDown[NUM_SWITCHES];   // Array of DOWN messages
    DWORD              rgSwUp[NUM_SWITCHES];     // Array of UP messages

} GLOBALDATA, *PGLOBALDATA;

extern PGLOBALDATA g_pGlobalData;  // pointer into memory mapped file

BOOL ScopeAccessMemory(HANDLE *phMutex, LPCTSTR szMutex, unsigned long ulWait);
void ScopeUnaccessMemory(HANDLE hMutex);
BOOL AccessSharedMemFile(LPCTSTR szName, unsigned long ulMemSize, void **ppvMapAddress);
void UnaccessSharedMemFile();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\msswchh.h ===
// MSSWCHH.H
// Functions and defines global to MSSWCH but not exported 
// to the rest of the world

// Functions with an X prefix must be called within the context
// of the helper window.

#ifndef _INC_TCHAR
	#include <tchar.h>
#endif
#define SZ_DLLMODULENAME	_TEXT("MSSWCH")

// MSSWCH is the main module and communicates with the outside world

BOOL swchPostSwitches(
	HSWITCHDEVICE	hsd,
	DWORD				dwSwitch );
BOOL swchPostConfigChanged( void );
void XswchStoreLastError(
	HSWITCHPORT		hSwitchPort,
	DWORD				dwError );
BOOL swchOpenSharedMemFile();
void swchCloseSharedMemFile();

// The List module distributes calls to the rest of the modules

BOOL XswcListInit( void );
BOOL XswcListEnd( void );
BOOL swcListGetList(
	HSWITCHPORT		hSwitchPort,
	PSWITCHLIST		pSL,
	DWORD				dwSize,
	PDWORD			pdwReturnSize );
HSWITCHDEVICE swcListGetSwitchDevice(
	HSWITCHPORT		hSwitchPort,
	UINT				uiDeviceType,
	UINT				uiDeviceNumber );
UINT swcListGetDeviceType(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd );
UINT swcListGetDeviceNumber(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd	);
BOOL swcListGetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcListSetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcListPollSwitches( void );


// Here are the rest of the modules

void swchComInit();
void swchJoyInit();
void swchKeyInit();
void swchListInit();

BOOL XswcComInit( HSWITCHDEVICE	hsd );
BOOL XswcComEnd( HSWITCHDEVICE	hsd );
BOOL swcComGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcComSetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcComPollStatus( HSWITCHDEVICE	hsd );

BOOL XswcJoyInit( HSWITCHDEVICE	hsd );
BOOL XswcJoyEnd( HSWITCHDEVICE	hsd );
BOOL swcJoyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcJoySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcJoyPollStatus( HSWITCHDEVICE	hsd );

BOOL XswcKeyInit( HSWITCHDEVICE	hsd );
BOOL XswcKeyEnd( HSWITCHDEVICE	hsd );
BOOL swcKeyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcKeySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcKeyPollStatus( HSWITCHDEVICE	hsd );

BOOL XswcLptInit( HSWITCHDEVICE	hsd );
BOOL XswcLptEnd( HSWITCHDEVICE	hsd );
BOOL swcLptGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
BOOL XswcLptSetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc );
DWORD XswcLptPollStatus( HSWITCHDEVICE	hsd );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\msswch.c ===
/****************************************************************************
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

  MSSWCH.C - Global and external communication

		This module handles the list of calling windows, starts up the
		hidden helper window, and communicates with the helper window.

		The first user window that opens a port causes this DLL to start.
		The DLL executes the hidden helper window, which registers itself
		to the DLL through XswchRegHelpeWnd. When the last user window 
		closes a port, the  helper window is asked to shut down.
		The helper window calls down to to XswchEndAll to close down all
		global resources.

		For polling the switches, the helper window has started a timer, 
		which causes XswchTimerProc to be called continuously. This causes
		the switch devices to be polled, and swchPostSwitches to be
		called for each switch on each device that has changed status.

		When a user window tries to change the configuration, the request
		is posted up to the hidden window which calls down to
		XswchSetConfig on behalf of the user window in order to manipulate
		the global switch devices.

		Ideally all of this should be written as interrupt driven
		device drivers.

		IPC is handled in several ways:
		1) Communication between the 16-bit and 32-bit helper apps is via DDE
		2) The SetConfig call uses the WM_COPYDATA message to get the information
			transferred from the using app to the helper app.
		3) Currently all other information is in a global static, shared memory 
			area. Much of it could be in a memory-mapped file area which would allow
			more dynamic allocation of memory, but the static model is simpler to 
			implement for now, and provides faster performance with less overhead.
			When USB is added	it may be worthwhile moving to a memory-mapped file.

  18-Jul-97	GEH	First Microsoft version

  Notes:
	Clock resolution is 55 ms but clock time is 54.9 ms.

	Boundary condition 55 ms:
		0-54 = 1 tick, 56-109 = 2 ticks, 55 = 1 or 2 ticks
	
	*** AVOID THE BOUNDARY CONDITION ***

	SetTimer() experience:
		0 -54 	steady 55ms ticks
		55			55 ms ticks, misses (every tenth?)
		56-109 	steady 110ms ticks
		110		110 ms ticks, misses some
		111-		steady 165 ms ticks

	54.9 ms intervals:

		 55, 110, 165, 220, 275, 330, 385, 440, 495, 549,
		604, 659, 714, 769, 824

	We check the time because WM_TIMER messages may be combined

*******************************************************************************/

#include <windows.h>
#include <assert.h>
#include <mmsystem.h>
#include <msswch.h>
#include "msswchh.h"
#include "msswcher.h"
#include "mappedfile.h"
#include "w95trace.c"

// Helper Window / Timer related procs

BOOL APIENTRY XswchRegHelperWnd( HWND, PBYTE );
BOOL APIENTRY XswchEndAll( void );
LRESULT APIENTRY XswchSetSwitchConfig(WPARAM wParam, PCOPYDATASTRUCT pCopyData);
void APIENTRY XswchPollSwitches( HWND );
void APIENTRY XswchTimerProc( HWND );

// Internal functions

BOOL swchInitSharedMemFile();

__inline swchSetLastError(DWORD err)
{
	SetLastError(err);
}

/****************************************************************************

   FUNCTION: XswchRegHelperWnd()

	DESCRIPTION:
		Called by the helper window (SWCHX) to register itself for
		shutdown later on. 

****************************************************************************/

BOOL APIENTRY XswchRegHelperWnd(HWND hWndApp, PBYTE pbda)
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SZMUTEXCONFIG, INFINITE))
    {
		if (g_pGlobalData)
		{
			g_pGlobalData->hwndHelper = hWndApp;
			memcpy( g_pGlobalData->rgbBiosDataArea, pbda, BIOS_SIZE );

			XswcListInit();
		}

        ScopeUnaccessMemory(hMutex);
    }
	return TRUE;
}


/****************************************************************************

   FUNCTION: XswchEndAll()

	DESCRIPTION:
		Called by the helper window.
		Frees all the switch resources

****************************************************************************/

BOOL APIENTRY XswchEndAll( void )
{
    BOOL fRv = FALSE;
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, 5000))
    {
        fRv = XswcListEnd();
        ScopeUnaccessMemory(hMutex);
    }
	return fRv;
}


/****************************************************************************

    FUNCTION: swchOpenSwitchPort()

    DESCRIPTION:
		All applications using the DLL whether in event or in polling
		mode must call swchOpenSwitchPort() with their window handle.
		On exit they must call swchCloseSwitchPort().

		Perform any initialization needed when someone loads the DLL.
		Also keeps track of how many windows are using this DLL.

		In the future this should be a dynamically allocated list, not limited
		to a compile time array.

		Also, we assume that window handles are unique and therefore simply
		turn around and use the passed in windows handle as the HSWITCHPORTs.
****************************************************************************/

HSWITCHPORT APIENTRY swchOpenSwitchPort(HWND hWnd, DWORD dwPortStyle)
{
	HANDLE      hMutex;

	if (NULL == hWnd)
	{
		swchSetLastError( SWCHERROR_INVALID_HWND );
		return NULL;
	}

	if (!IsWindow( hWnd ))
	{
		swchSetLastError( SWCHERROR_INVALID_HWND );
		return NULL;
	}

    if (ScopeAccessMemory(&hMutex, SZMUTEXWNDLIST, INFINITE))
    {
	    int i;

        // setup to use the shared memory file w/in calling process
		if (!swchInitSharedMemFile())
		    goto Exit_OpenSwitchPort;

        // hit max using windows?
	    if (g_pGlobalData->cUseWndList >= MAXWNDS)
		{
		    swchSetLastError( SWCHERROR_MAXIMUM_PORTS );
		    goto Exit_OpenSwitchPort;
		}

        // hWnd must be unique; only 1 switch device per hwnd
	    for (i=0; i<g_pGlobalData->cUseWndList; i++)
		{
		    if (hWnd == g_pGlobalData->rgUseWndList[i].hWnd)
		    {
		        swchSetLastError( SWCHERROR_HWND_ALREADY_USED );
		        goto Exit_OpenSwitchPort;
		    }
		}

        // got unique window
	    g_pGlobalData->rgUseWndList[g_pGlobalData->cUseWndList].hWnd = hWnd;
	    g_pGlobalData->rgUseWndList[g_pGlobalData->cUseWndList].dwPortStyle = dwPortStyle;
	    i = ++g_pGlobalData->cUseWndList;

		// release mutex before starting helper window to avoid deadlock
        ScopeUnaccessMemory(hMutex);

	    if (1 == i)	// first caller starts port resource owner exe
        {  
			WinExec("MSSWCHX.EXE SWCH", SW_HIDE);
		}
	    
	    // Return a handle to the switch port
	    swchSetLastError( SWCHERROR_SUCCESS );
		return (HSWITCHPORT) hWnd;
    }

Exit_OpenSwitchPort:
    ScopeUnaccessMemory(hMutex);
	return NULL;
}


/****************************************************************************

    FUNCTION: swchCloseSwitchPort()

	 DESCRIPTION:

		Perform any deallocation/cleanup when the DLL is no longer needed.
		
		Note that the passed in HSWITCHPORT handle is simply a window handle,
		but the user doesn't know that.

****************************************************************************/

BOOL APIENTRY swchCloseSwitchPort(HSWITCHPORT hSwitchPort )
{
	HWND hWndRemove = (HWND)hSwitchPort;
	HANDLE hMutex;

	if (NULL == hWndRemove) 
        return FALSE;

    if (ScopeAccessMemory(&hMutex, SZMUTEXWNDLIST, INFINITE))
    {
	    short  i,j;

        // find the one caller wants to remove
	    for (i=0; i<g_pGlobalData->cUseWndList; i++)
	    {
		    if (hWndRemove == g_pGlobalData->rgUseWndList[i].hWnd)
			    break;
	    }
		
	    if (i < g_pGlobalData->cUseWndList)
	    {
            // move items in list down one
	        for (j=i; j<g_pGlobalData->cUseWndList; j++)
	        {
		        g_pGlobalData->rgUseWndList[j] = g_pGlobalData->rgUseWndList[j+1];
	        }

            // reduce count of users
	        g_pGlobalData->cUseWndList--;

            // if no more users then close port watcher
	        if (0 == g_pGlobalData->cUseWndList)
	        {
                // unhook the keyboard

                if (g_pGlobalData->hKbdHook)
                {
                    g_pGlobalData->fSyncKbd = FALSE;
                    UnhookWindowsHookEx(g_pGlobalData->hKbdHook);
                    g_pGlobalData->hKbdHook = NULL;
                }

				if (g_pGlobalData->hwndHelper && IsWindow( g_pGlobalData->hwndHelper ))
				{
					PostMessage( g_pGlobalData->hwndHelper, WM_CLOSE, 0, 0L );
				}
				g_pGlobalData->hwndHelper = NULL;
	        }
	    } // Else if not found, ignore it

        ScopeUnaccessMemory(hMutex);
    }

	return TRUE;
}


/****************************************************************************

    FUNCTION: swchGetSwitchDevice()

	 DESCRIPTION:
	   Return a handle to a switch device, given the PortType and PortNumber.
****************************************************************************/

HSWITCHDEVICE swchGetSwitchDevice(
    HSWITCHPORT hSwitchPort, 
    UINT uiDeviceType, 
    UINT uiDeviceNumber)
{
	HSWITCHDEVICE hsd = NULL;
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
	    hsd = swcListGetSwitchDevice( hSwitchPort, uiDeviceType, uiDeviceNumber );
        ScopeUnaccessMemory(hMutex);
    }
    return hsd;
}


/****************************************************************************

    FUNCTION: swchGetDeviceType()

	 DESCRIPTION:
		Return the Device Type value given the handle to the switch device.
****************************************************************************/

UINT swchGetDeviceType(HSWITCHPORT hSwitchPort, HSWITCHDEVICE hsd)
{
    BOOL fRv = FALSE;
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
    	fRv = swcListGetDeviceType( hSwitchPort, hsd );
        ScopeUnaccessMemory(hMutex);
    }
    return fRv;
}


/****************************************************************************

    FUNCTION: swchGetSwitchConfig()

	 DESCRIPTION:
		Returns with the buffer filled in with the configuration information
		for the given switch device.
****************************************************************************/

BOOL swchGetSwitchConfig(HSWITCHPORT hSwitchPort, HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	BOOL fRv = FALSE;
	HANDLE hMutex;

    if (ScopeAccessMemory(&hMutex, SZMUTEXCONFIG, INFINITE))
    {
	    fRv = swcListGetConfig( hSwitchPort, hsd, psc );
        ScopeUnaccessMemory(hMutex);
    }
	return fRv;
}


/****************************************************************************

    FUNCTION: swchSetSwitchConfig()

	 DESCRIPTION: Called by user applications that wish to change the configuration
		of a switch device.  Since all devices must be owned by the helper
		window, the parameters are copied to shared address space and a message
		posted to the helper window which will call down to XswchSetSwitchConfig.

	 Currently we send a WM_COPYDATA message for cheap IPC.
	 In the memory block we simply include the SWITCHCONFIG information.
****************************************************************************/

BOOL swchSetSwitchConfig(HSWITCHPORT hSwitchPort, HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	DWORD dwAllocSize;
	COPYDATASTRUCT CopyData;
	PBYTE pData;
	LRESULT lRes = SWCHERR_ERROR;
    HANDLE hMutex;

	if (!psc)
	{
		swchSetLastError( SWCHERROR_INVALID_PARAMETER );
		return FALSE;
	}

	dwAllocSize = sizeof(SWITCHCONFIG);
    if (!(psc->cbSize) || (dwAllocSize < psc->cbSize))
	{
        swchSetLastError( SWCHERROR_INSUFFICIENT_BUFFER );
		return FALSE;
	}

	assert( sizeof(HSWITCHDEVICE) == sizeof(DWORD_PTR) );
	assert( sizeof(HSWITCHPORT) == sizeof(WPARAM) );

	pData = (PBYTE) LocalAlloc( LPTR, dwAllocSize );
    if (!pData)
        return FALSE;   // LocalAlloc called swchSetLastError

	CopyData.dwData = (DWORD_PTR)hsd;
	CopyData.lpData = pData;
	CopyData.cbData = dwAllocSize;
	memcpy( pData, psc, sizeof(SWITCHCONFIG));

    // send config data to owner (it will call back with it)
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
		HWND hWnd = g_pGlobalData->hwndHelper;
        // avoid problems with callback into DLL while mutex is open
        ScopeUnaccessMemory(hMutex);
	    lRes = SendMessage(hWnd, WM_COPYDATA, (WPARAM) hSwitchPort, (LPARAM) &CopyData);
    }

	LocalFree( pData );
    return (lRes == SWCHERR_NO_ERROR)?FALSE:TRUE;
}


/****************************************************************************

    FUNCTION: XswchSetSwitchConfig()

	 DESCRIPTION:
		Gets called by the helper window to set the configuration.
		Note: we are in SendMessage() above.

****************************************************************************/

LRESULT APIENTRY XswchSetSwitchConfig(WPARAM wParam, PCOPYDATASTRUCT pCopyData)
{
	HSWITCHPORT   hSwitchPort = (HSWITCHPORT) wParam;
	HSWITCHDEVICE hsd;
	SWITCHCONFIG  scConfig;
	BOOL          bReturn = FALSE;
    HANDLE        hMutex;

	memcpy( &scConfig, pCopyData->lpData, sizeof(SWITCHCONFIG));
	hsd = (HSWITCHDEVICE) pCopyData->dwData;

    if (ScopeAccessMemory(&hMutex, SZMUTEXCONFIG, INFINITE))
    {
	    bReturn = XswcListSetConfig( hSwitchPort, hsd, &scConfig );
        ScopeUnaccessMemory(hMutex);
    }
		
    return (bReturn) ? SWCHERR_NO_ERROR : SWCHERR_ERROR;
}

/****************************************************************************

    FUNCTION: XswchPollSwitches()

    DESCRIPTION:
		The helper windows calls this.
		XswcListPollSwitches() ultimately calls swchPostSwitches() for each switch
		on each device that has changed state.
****************************************************************************/

void APIENTRY XswchPollSwitches( HWND hWnd )
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, 5000))
    {
    	g_pGlobalData->dwSwitchStatus = XswcListPollSwitches();
        ScopeUnaccessMemory(hMutex);
    }
}
	
	
/****************************************************************************

    FUNCTION: XswchTimerProc()

    DESCRIPTION:
		Timer call-back function for the regularly scheduled timer.
		The helper app calls this proc everytime it receives a timer message.
		XswcListPollSwitches() ultimately calls swchPostSwitches() for each switch
		on each device that has changed state.

		Currently we use the timer whether or not any application has requested
		events. In the future we could check and see if any applications are
		requesting events and only then start up the timer for non-interrupt
		driven devices.
****************************************************************************/

void APIENTRY XswchTimerProc( HWND hWnd )
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHSTATUS, 5000))
    {
	    g_pGlobalData->dwSwitchStatus = XswcListPollSwitches();
        ScopeUnaccessMemory(hMutex);
    }
}

/****************************************************************************

   FUNCTION: swchCheckForScanChar (BOOL fCheckForScanKey)

	DESCRIPTION:
      Called just before the key designated as the scan mode key is sent
	  out to allow the keyboard filter to treat that key as a regular key
	  (send it to the target app) vs treating it as the scan key.
****************************************************************************/

void APIENTRY swchCheckForScanChar (BOOL fCheckForScanKey)
{
	HANDLE hMutex;
    if (ScopeAccessMemory(&hMutex, SHAREDMEMFILE_MUTEX, INFINITE))
    {
		g_pGlobalData->fCheckForScanKey = fCheckForScanKey;
        ScopeUnaccessMemory(hMutex);
    }
}


/****************************************************************************

   FUNCTION: swchPostSwitches()

	DESCRIPTION:
		Post the given switch up or down message to all applications
		which have requested posted messages.

		We would like to use timeGetTime() instead of GetTickCount, but
		it is unclear under what circumstances the multimedia timer is
		working at a more precise level. On my old PS/2 Model 95 with
		a 16-bit Microchannel Sound Blaster Pro, there does not seem
		to be a multimedia timer.

****************************************************************************/

BOOL swchPostSwitches(HSWITCHDEVICE hsd, DWORD dwSwitch)
{
	DWORD dwMsec = timeGetTime();
	int i;

	assert( sizeof(WPARAM) >= sizeof(HSWITCHDEVICE) );

	for (i=0; i<g_pGlobalData->cUseWndList; i++)
	{
        HWND hWnd = g_pGlobalData->rgUseWndList[i].hWnd;
        if (!IsWindow(hWnd))
            continue;   // skip over dead windows

		if (PS_EVENTS == g_pGlobalData->rgUseWndList[i].dwPortStyle)
		{
			PostMessage(hWnd, dwSwitch, (WPARAM)hsd, dwMsec);
		}
	}

	return TRUE;
}


/****************************************************************************

   FUNCTION: swchPostConfigChanged()

	DESCRIPTION:
		Post the CONFIGCHANGED message to all apps which have registered
		with this DLL.
				
****************************************************************************/

BOOL swchPostConfigChanged( void )
{
	int i;
	for (i=0; i<g_pGlobalData->cUseWndList; i++)
	{
        HWND hWnd = g_pGlobalData->rgUseWndList[i].hWnd;
		if (IsWindow(hWnd))
		{
			PostMessage(hWnd, SW_SWITCHCONFIGCHANGED, 0, 0);
		}
	}
	return TRUE;
}

/****************************************************************************

   FUNCTION: GetDesktopName()

	DESCRIPTION:
		Internal function retrieve the name of the input desktop
				
****************************************************************************/
BOOL GetDesktopName(LPTSTR szDeskName, int cchDeskName)
{
    HDESK hdesk;
    DWORD nl;

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    DBPRINTF(TEXT("GetDesktopName:  OpenInputDesktop returns hdesk=0x%x error=%d\r\n"), hdesk, GetLastError());
    if (!hdesk)
    {
        TCHAR szWinlogon[] = TEXT("Winlogon");
		hdesk = OpenDesktop(szWinlogon, 0, FALSE, MAXIMUM_ALLOWED);
        DBPRINTF(TEXT("GetDesktopName:  OpenDesktop returns hdesk=0x%x error=%d\r\n"), hdesk, GetLastError());
		if (!hdesk)
		{
            DBPRINTF(TEXT("GetDesktopName:  FAILING\r\n"));
		    return FALSE;
        }
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, szDeskName, cchDeskName, &nl);
    
    CloseDesktop(hdesk);
    DBPRINTF(TEXT("GetDesktopName:  desktop name is %s\r\n"), szDeskName);
	return TRUE;
}

/****************************************************************************

   FUNCTION: swchInitSharedMemFile()

	DESCRIPTION:
		Internal function to open the shared memory file and initialize it.
				
****************************************************************************/

BOOL swchInitSharedMemFile()
{
    // Init memory on first open if DLL_Attach didn't do it
    if (!g_pGlobalData)
    {
        swchOpenSharedMemFile();
        if (!g_pGlobalData)
        {
            DBPRINTF(TEXT("swchInitSharedMemFile: ERROR !g_pGlobalData\r\n"));
            return FALSE;    // internal error! ignore we'll see it later.
        }
    }

    memset((void *)g_pGlobalData, 0, sizeof(GLOBALDATA));
    swchComInit();
    swchJoyInit();
    swchKeyInit();
    swchListInit();

	return TRUE;
}

/****************************************************************************

   FUNCTION: swchOpenSharedMemFile()

	DESCRIPTION:
		Internal function to open the shared memory file.
				
****************************************************************************/

BOOL swchOpenSharedMemFile()
{
    if (!g_pGlobalData)
    {
        TCHAR szName[256];

        // Fail quietly on GetDesktopName; it can fail when OSK attaches
        // to msswch.dll because we've not assigned ourselves to a desktop
        // yet.  OSK will go thru this code when it explicitly registers.

        if (GetDesktopName(szName, 256))
        {
            if (!AccessSharedMemFile(
                      szName
                    , sizeof(GLOBALDATA)
                    , &g_pGlobalData))
            {
                swchSetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
        }
    }
	return TRUE;
}

/****************************************************************************

   FUNCTION: swchCloseSharedMemFile()

	DESCRIPTION:
		Internal function to close the shared memory file.
				
****************************************************************************/

void swchCloseSharedMemFile()
{
    if (g_pGlobalData)
    {
        UnaccessSharedMemFile();
        g_pGlobalData = 0;
    }
}

/****************************************************************************

   FUNCTION: XswchStoreLastError()

	DESCRIPTION:

	Internal function to store the last error code for the process specific
	switch port, which is also the window handle at this point.
	If no switch port handle is passed, store the error code in
	a global variable.
	
	The Windows swchSetLastError call can be made
	just before the process specific call which caused the error
	returns to the application.
	
****************************************************************************/

void XswchStoreLastError(HSWITCHPORT hSwitchPort, DWORD dwError)
{
	if (NULL == hSwitchPort)
	{
		g_pGlobalData->dwLastError = dwError;
	}
	else
	{
	    int i;
		for (i=0; i<g_pGlobalData->cUseWndList; i++)
		{
			if (hSwitchPort == g_pGlobalData->rgUseWndList[i].hWnd)
            {
    			g_pGlobalData->rgUseWndList[i].dwLastError = dwError;
                return;
            }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\ntddpar.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntddpar.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Parallel device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_PAR_BASE                  FILE_DEVICE_PARALLEL_PORT
#define IOCTL_PAR_QUERY_INFORMATION     CTL_CODE(FILE_DEVICE_PARALLEL_PORT,1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_INFORMATION       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_QUERY_DEVICE_ID       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_QUERY_DEVICE_ID_SIZE  CTL_CODE(FILE_DEVICE_PARALLEL_PORT,4,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

typedef struct _PAR_QUERY_INFORMATION{
       UCHAR Status;
} PAR_QUERY_INFORMATION, *PPAR_QUERY_INFORMATION;

typedef struct _PAR_SET_INFORMATION{
       UCHAR Init;
} PAR_SET_INFORMATION, *PPAR_SET_INFORMATION;

#define PARALLEL_INIT            0x1
#define PARALLEL_AUTOFEED        0x2
#define PARALLEL_PAPER_EMPTY     0x4
#define PARALLEL_OFF_LINE        0x8
#define PARALLEL_POWER_OFF       0x10
#define PARALLEL_NOT_CONNECTED   0x20
#define PARALLEL_BUSY            0x40
#define PARALLEL_SELECTED        0x80

//
// This is the structure returned by IOCTL_PAR_QUERY_DEVICE_ID_SIZE.
//

typedef struct _PAR_DEVICE_ID_SIZE_INFORMATION {
    ULONG   DeviceIdSize;
} PAR_DEVICE_ID_SIZE_INFORMATION, *PPAR_DEVICE_ID_SIZE_INFORMATION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\msswcher.h ===
/***** Internal Error codes *****/

#define SWCHERROR_SUCCESS					ERROR_SUCCESS
#define SWCHERROR_INVALID_HWND			ERROR_INVALID_WINDOW_HANDLE
#define SWCHERROR_INVALID_HSWITCHPORT	ERROR_INVALID_HANDLE
#define SWCHERROR_INVALID_HSD				ERROR_INVALID_HANDLE
#define SWCHERROR_MAXIMUM_PORTS			ERROR_ACCESS_DENIED
#define SWCHERROR_HWND_ALREADY_USED		ERROR_ACCESS_DENIED
#define SWCHERROR_INVALID_PARAMETER		ERROR_INVALID_PARAMETER
#define SWCHERROR_INVALID_DEVICETYPE	ERROR_INVALID_PARAMETER
#define SWCHERROR_INVALID_DEVICENUMBER	ERROR_INVALID_PARAMETER
#define SWCHERROR_INSUFFICIENT_BUFFER	ERROR_INSUFFICIENT_BUFFER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msswch.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\swchcom.c ===
/****************************************************************************
   Switch Input Library DLL - Serial port routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

  Currently this uses polling of the serial ports.
  To move to an interrupt-based system, our helper window
  would need to be the target for notifications.

*******************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#include <msswch.h>
#include "msswchh.h"
#include "mappedfile.h"

/***** Internal Prototypes *****/

HANDLE XswcComOpen( DWORD uiPort );
BOOL XswcComSet(HANDLE hCom, PSWITCHCONFIG_COM pC );

// Handles cannot be shared across processes
// These are port/file handles
HANDLE hCom[MAX_COM] = {0,0,0,0};

/****************************************************************************

   FUNCTION: swchComInit()

	DESCRIPTION:
		Called once per DLL load to initialize the com port specific 
        data in the memory mapped file.  We are w/in an open mutex.

****************************************************************************/

void swchComInit()
{
    int i;
    long lSize = sizeof(SWITCHCONFIG);
    for (i=0;i<MAX_COM;i++)
    {
        g_pGlobalData->rgscCom[i].cbSize = lSize;
        g_pGlobalData->rgscCom[i].uiDeviceType = SC_TYPE_COM;
        g_pGlobalData->rgscCom[i].uiDeviceNumber = i+1;
        g_pGlobalData->rgscCom[i].dwFlags = SC_FLAG_DEFAULT;
    }
    g_pGlobalData->scDefaultCom.dwComStatus = SC_COM_DEFAULT;
}

/****************************************************************************

   FUNCTION: XswcComInit()

	DESCRIPTION:
		Initialize the particular hardware device structures and variables.
		Any global initialization of resources will have to be done based
		on some version of a reference counter.  We are w/in an open mutex.

****************************************************************************/

BOOL XswcComInit( HSWITCHDEVICE hsd )
{
    UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

    g_pGlobalData->rgscCom[uiDeviceNumber-1].u.Com = g_pGlobalData->scDefaultCom;
    hCom[uiDeviceNumber-1] = (HANDLE) 0;
	
    return TRUE;
}


/****************************************************************************

   FUNCTION: XswcComEnd()

	DESCRIPTION:
		Free the resources for the given hardware port.
		We assume that if CloseHandle fails, the handle is
		invalid and/or already closed, so we zero it out anyways,
		and return TRUE for success.
		Global releases will need to be based on a reference counter.

****************************************************************************/

BOOL XswcComEnd( HSWITCHDEVICE hsd )
{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (hCom[uiDeviceNumber-1])
	{
		CloseHandle( hCom[uiDeviceNumber-1] );
		hCom[uiDeviceNumber-1] = 0;
	}
	g_pGlobalData->rgscCom[uiDeviceNumber-1].dwSwitches = 0;

	return TRUE;
}


/****************************************************************************

   FUNCTION: swcComGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcComGetConfig(HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
   *psc = g_pGlobalData->rgscCom[uiDeviceNumber-1];
	return TRUE;
}


/****************************************************************************

   FUNCTION: XswcComSetConfig()

	DESCRIPTION:
		Activate/Deactivate the device.
		
		Four cases: 
		1) hCom = 0 and active = 0		- do nothing
		2)	hCom = x and active = 1		- just set the configuration
		3) hCom = 0 and active = 1		- activate and set the configuration
		4) hCom = x and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set. This all probably needs some work.

****************************************************************************/

BOOL XswcComSetConfig(HSWITCHDEVICE hsd, PSWITCHCONFIG psc)
{
	BOOL		bSuccess;
	BOOL		bJustOpened;
	UINT		uiDeviceNumber;
	HANDLE	*phCom;
	PSWITCHCONFIG prgscCom;

	bSuccess = FALSE;
	bJustOpened = FALSE;

	// Simplify our code
	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phCom = &hCom[uiDeviceNumber-1];
	prgscCom = &g_pGlobalData->rgscCom[uiDeviceNumber-1];
	
	// Should we activate?
	if (	(0==*phCom)
		&&	(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{ // Yes
		*phCom = XswcComOpen( uiDeviceNumber );
		if (*phCom)
			{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			prgscCom->dwFlags |= SC_FLAG_ACTIVE;
			prgscCom->dwFlags &= ~SC_FLAG_UNAVAILABLE;
			}
		else
			{ // Not OK
			bSuccess = FALSE;
			prgscCom->dwFlags &= ~SC_FLAG_ACTIVE;
			prgscCom->dwFlags |= SC_FLAG_UNAVAILABLE;
			}
		}

	// Should we deactivate?
	else if (	(0!=*phCom)
		&&	!(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{
		XswcComEnd( hsd ); // This will also zero out *phCom
		bSuccess = TRUE;
		prgscCom->dwFlags &= ~SC_FLAG_ACTIVE;
		}
	
	// If the above steps leave a valid hCom, let's try setting the config
	if ( 0!=*phCom )
		{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
			{
			bSuccess = XswcComSet( *phCom, &g_pGlobalData->scDefaultCom );
			if (bSuccess)
				{
				prgscCom->dwFlags |= SC_FLAG_DEFAULT;
				prgscCom->u.Com = g_pGlobalData->scDefaultCom;
				}
			}
		else
			{
			bSuccess = XswcComSet( *phCom, &(psc->u.Com) );
			if (bSuccess)
				{
            prgscCom->u.Com = psc->u.Com;
				}
			}

		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
			{
			XswcComEnd( hsd );
			prgscCom->dwFlags &= ~SC_FLAG_ACTIVE;
			}
		}

	return bSuccess;
}


/****************************************************************************

   FUNCTION: XswcComPollStatus()

	DESCRIPTION:
		Must be called in the context of the helper window.
		TODO: tell List which switch caused the last change?
****************************************************************************/

DWORD XswcComPollStatus( HSWITCHDEVICE	hsd )
{
	UINT uiDeviceNumber;
	HANDLE *phCom;
	DWORD dwStatus;
	DWORD dwModem;
	BOOL	bResult;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phCom = &hCom[uiDeviceNumber-1];
	dwStatus = 0;
	if (*phCom)
		{
		bResult = GetCommModemStatus( *phCom, &dwModem );
		dwStatus |= (dwModem & MS_CTS_ON ) ? SWITCH_1 : 0;
		dwStatus |= (dwModem & MS_DSR_ON ) ? SWITCH_2 : 0;
		dwStatus |= (dwModem & MS_RLSD_ON) ? SWITCH_3 : 0;
		dwStatus |= (dwModem & MS_RING_ON) ? SWITCH_4 : 0;
		}
	g_pGlobalData->rgscCom[uiDeviceNumber-1].dwSwitches = dwStatus;
	return dwStatus;
}


/****************************************************************************

   FUNCTION: XswcComOpen()

	DESCRIPTION:
		Opens a file handle to the particular com port, based on
		the 1-based uiPort.
		
		If uiPort is invalid, this will automatically set up GetLastError().
		This is currently unlikely to happen since we make sure uiPort is valid in
		order to have a valid index into the array of device configs.
****************************************************************************/

HANDLE XswcComOpen( DWORD uiPort )
{
	HANDLE hComPort;
	TCHAR szComPort[20];

	hComPort = 0;
	wsprintf( szComPort, _TEXT("COM%1.1d"), uiPort );
	hComPort = CreateFile( szComPort, GENERIC_READ | GENERIC_WRITE, 0, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

	if (INVALID_HANDLE_VALUE == hComPort) 
	{
		hComPort = 0;
	}

	return hComPort;
}


/****************************************************************************

   FUNCTION: XswcComSet()

	DESCRIPTION:
		Sets the configuration of the particular Port.
		Return FALSE (0) if an error occurs.
		GetLastError is automatically set up for us.
		
****************************************************************************/

BOOL XswcComSet(
	HANDLE hCom,
	PSWITCHCONFIG_COM pC )
{
	DCB dcb;
	BOOL bSuccess;

	dcb.DCBlength = sizeof( DCB );
	GetCommState( hCom, &dcb );
	// ENABLE = set low (+10V)
	// DISABLE = set high (-10V)
	dcb.fDtrControl = pC->dwComStatus & SC_COM_DTR ? 
		DTR_CONTROL_DISABLE : DTR_CONTROL_ENABLE;
	dcb.fRtsControl = pC->dwComStatus & SC_COM_RTS ? 
		RTS_CONTROL_DISABLE : RTS_CONTROL_ENABLE;
	bSuccess = SetCommState( hCom, &dcb );
	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\swchkey.c ===
/****************************************************************************
   Switch Input Library DLL - Keyboard hook routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre


*******************************************************************************/

#include <windows.h>
#include <msswch.h>
#include "msswchh.h"
#include "mappedfile.h"
#include "w95trace.h"

// Hook proc
BOOL XswcKeyOpen( void );
BOOL XswcKeySet( PSWITCHCONFIG_KEYS pK );
BOOL swcKeyModKeysDown( UINT dwMod );

void swchKeyInit()
{
    g_pGlobalData->fCheckForScanKey = TRUE;
	g_pGlobalData->fScanKeys = FALSE;
    g_pGlobalData->scKeys.cbSize = sizeof(SWITCHCONFIG);
    g_pGlobalData->scKeys.uiDeviceType = SC_TYPE_KEYS;
    g_pGlobalData->scKeys.uiDeviceNumber = 1;
    g_pGlobalData->rgHotKey[0].dwSwitch = SWITCH_1;
    g_pGlobalData->rgHotKey[1].dwSwitch = SWITCH_2;

	g_pGlobalData->fSyncKbd = FALSE;
	g_pGlobalData->hwndOSK = 0;
	g_pGlobalData->uiMsg = 0;
}



/****************************************************************************

   FUNCTION: swcKeyboardHookProc()

	DESCRIPTION:
      When the hook is set set, this blocks the specified keys from
		being processed by anyone else.

		We could use this to set the switch status as well, but for 
		consistency we do it in the PollStatus routine.

      This must be released before unloading the DLL.

****************************************************************************/

LRESULT CALLBACK swcKeyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    // Only check for the scanning key if we are in scan mode and not blocked
	// from checking for the key.  We are blocked when the key is sent out from
	// scan mode (eg. the user wants to "type" that key).

    if (nCode >= 0 && g_pGlobalData->fScanKeys && g_pGlobalData->fCheckForScanKey)
    {
		int i;
		for (i=0; i<NUM_KEYS; i++ )
		{
			// is this the scan hot key?
			if (g_pGlobalData->rgHotKey[i].vkey && (wParam == g_pGlobalData->rgHotKey[i].vkey))
			{
				// and are any requested modifier keys down?
				if (swcKeyModKeysDown(g_pGlobalData->rgHotKey[i].mod))
				{
					return 1;  // don't send out scan hotkey
				}
			}
		}
	}

	swchCheckForScanChar(TRUE);	// check next key
	
    // not in scan mode pass it on
    return 0;
}



/****************************************************************************

   FUNCTION: XswcKeyInit()

	DESCRIPTION:

****************************************************************************/

BOOL XswcKeyInit( HSWITCHDEVICE hsd )
	{
	BOOL bSuccess = TRUE;

	g_pGlobalData->scKeys.u.Keys = g_pGlobalData->scDefaultKeys;

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: XswcKeyEnd()

	DESCRIPTION:

****************************************************************************/

BOOL XswcKeyEnd( HSWITCHDEVICE hsd )
{
	// clear the keyboard hook
	if (g_pGlobalData->fScanKeys)
	{
        g_pGlobalData->fScanKeys = FALSE;
	}
	g_pGlobalData->scKeys.dwSwitches = 0;
	return TRUE;
}


/****************************************************************************

   FUNCTION: swcKeyGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcKeyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	*psc = g_pGlobalData->scKeys;
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcKeySetConfig()

	DESCRIPTION:
		Activate/Deactivate the hook.
		
		Four cases: 
		1) g_pGlobalData->fScanKeys = 0 and active = 0		- do nothing
		2) g_pGlobalData->fScanKeys = 1 and active = 1		- just set the configuration
		3) g_pGlobalData->fScanKeys = 0 and active = 1		- activate and set the configuration
		4) g_pGlobalData->fScanKeys = 1 and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set. This all probably needs some work.

****************************************************************************/

BOOL XswcKeySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
{	
	BOOL bSuccess = FALSE;
	BOOL bJustOpened = FALSE;

	// Should we activate?
	if (!g_pGlobalData->fScanKeys && (psc->dwFlags & SC_FLAG_ACTIVE))
	{ // Yes
		g_pGlobalData->fScanKeys = XswcKeyOpen();
		if (g_pGlobalData->fScanKeys)
		{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			g_pGlobalData->scKeys.dwFlags |= SC_FLAG_ACTIVE;
			g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_UNAVAILABLE;
		}
		else
		{ // Not OK
			bSuccess = FALSE;
			g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_ACTIVE;
			g_pGlobalData->scKeys.dwFlags |= SC_FLAG_UNAVAILABLE;
		}
	}
	// Should we deactivate?
	else if (g_pGlobalData->fScanKeys && !(psc->dwFlags & SC_FLAG_ACTIVE))
	{
		XswcKeyEnd( hsd ); // This will set fScanKeys FALSE 
		bSuccess = TRUE;
		g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_ACTIVE;
	}

	// If the above steps leave a valid g_pGlobalData->hKbdHook, let's try setting the config
	// currently we don't do any error checking, so anything goes.
	if (g_pGlobalData->fScanKeys)
	{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
		{
			bSuccess = XswcKeySet( &g_pGlobalData->scDefaultKeys );
			if (bSuccess)
			{
				g_pGlobalData->scKeys.dwFlags |= SC_FLAG_DEFAULT;
				g_pGlobalData->scKeys.u.Keys = g_pGlobalData->scDefaultKeys;
			}
		}
		else
		{
			bSuccess = XswcKeySet( &(psc->u.Keys) );
			if (bSuccess)
			{
				g_pGlobalData->scKeys.u.Keys = psc->u.Keys;
			}
		}

		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
		{
			XswcKeyEnd( hsd );
			g_pGlobalData->scKeys.dwFlags &= ~SC_FLAG_ACTIVE;
		}
	}

	return bSuccess;
}


/****************************************************************************

   FUNCTION: XswcKeyPollStatus()

	DESCRIPTION:

  Assumes that if there is no keyboard hook, then this "device" is not active.

****************************************************************************/

DWORD XswcKeyPollStatus( HSWITCHDEVICE	hsd )
{
	int i;
	DWORD dwStatus;

	dwStatus = 0;
	if (g_pGlobalData->fScanKeys)
	{
		for (i=0; i<NUM_KEYS; i++)
		{
			if ((GetAsyncKeyState( g_pGlobalData->rgHotKey[i].vkey ) & 0x8000)
				&& swcKeyModKeysDown( g_pGlobalData->rgHotKey[i].mod ) )
            {
				dwStatus |= g_pGlobalData->rgHotKey[i].dwSwitch;
            }
		}
	}
	g_pGlobalData->scKeys.dwSwitches = dwStatus;

	return dwStatus;
}


/****************************************************************************

   FUNCTION: XswcKeyOpen()

	DESCRIPTION:
	Set the Windows keyboard hook.

****************************************************************************/

BOOL XswcKeyOpen( void )
{
	extern HOOKPROC OSKHookProc(int nCode, WPARAM wParam, LPARAM lParam);

	if (g_pGlobalData && !g_pGlobalData->hKbdHook)
	{
		g_pGlobalData->hKbdHook = SetWindowsHookEx(
									  WH_KEYBOARD
									, (HOOKPROC) OSKHookProc
									, GetModuleHandle(SZ_DLLMODULENAME)
									, 0);
	}

	return (g_pGlobalData && g_pGlobalData->hKbdHook) ? TRUE : FALSE;
}


/****************************************************************************

   FUNCTION: XswcKeySet()

	DESCRIPTION:

  Sets the configuration of the keys, storing the virtual key number and
  modifier states.

  In the future this routine can be used to limit the valid virtual keys.
		
****************************************************************************/

BOOL XswcKeySet( PSWITCHCONFIG_KEYS pK )
	{
	BOOL bSuccess;

	g_pGlobalData->rgHotKey[0].mod = HIWORD( pK->dwKeySwitch1 );
	g_pGlobalData->rgHotKey[0].vkey = LOWORD( pK->dwKeySwitch1 );
	g_pGlobalData->rgHotKey[1].mod = HIWORD( pK->dwKeySwitch2 );
	g_pGlobalData->rgHotKey[1].vkey = LOWORD( pK->dwKeySwitch2 );

	bSuccess = TRUE;
	return bSuccess;
	}


/****************************************************************************

   FUNCTION: swcKeyModKeysDown()

	DESCRIPTION:
	
	Are all the requested modifier keys down?
	If any requested key is not down, return FALSE.
	If any key is down but not requested, return FALSE.

****************************************************************************/

BOOL swcKeyModKeysDown( UINT dwMod )
	{
	DWORD		dwTest = 0;

	if (dwMod ^ dwTest)
		return FALSE;
	else
		return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswchx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msswchx.rc
//

#define IDS_NOT_USER_PROG         2
#define IDS_PROC_NOT_FOUND        3
#define IDS_MSSWCH_DLL_NOT_FOUND  4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\version.h ===
s// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "msswch\0"
#define VER_INTERNALNAME_STR        "msswch\0"
#define VER_ORIGINALFILENAME_STR    "msswch.dll\0"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\swchjoy.c ===
/****************************************************************************
   Switch Input Library DLL - Joystick routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

	Link with winmm.lib
*******************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include <msswch.h>
#include "msswchh.h"
#include "mappedfile.h"

HJOYDEVICE XswcJoyOpen( DWORD uiPort );
BOOL XswcJoySet(HJOYDEVICE hJoy, PSWITCHCONFIG_JOYSTICK pJ );

// Handles cannot be shared across processes
// These are faked handles, to keep the module logic similar to the serial port.
HJOYDEVICE ghJoy[MAX_JOYSTICKS] = {0,0};

void swchJoyInit()
{
    int i;
    long lSize = sizeof(SWITCHCONFIG);
    for (i=0;i<MAX_JOYSTICKS;i++)
    {
        g_pGlobalData->rgscJoy[i].cbSize = lSize;
        g_pGlobalData->rgscJoy[i].uiDeviceType = SC_TYPE_JOYSTICK;
        g_pGlobalData->rgscJoy[i].uiDeviceNumber = i+1;
        g_pGlobalData->rgscJoy[i].dwFlags = SC_FLAG_DEFAULT;
    }

    memset(&g_pGlobalData->rgJoySet, 0, MAX_JOYSTICKS * sizeof(JOYSETTINGS));

    g_pGlobalData->scDefaultJoy.dwJoySubType = SC_JOY_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMinX = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMaxX = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMinY = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyThresholdMaxY = SC_JOYVALUE_DEFAULT;
    g_pGlobalData->scDefaultJoy.dwJoyHysteresis = SC_JOYVALUE_DEFAULT;
}

/****************************************************************************

   FUNCTION: XswcJoyInit()

	DESCRIPTION:

****************************************************************************/

BOOL XswcJoyInit( HSWITCHDEVICE hsd )
	{
    UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

    g_pGlobalData->rgscJoy[uiDeviceNumber-1].u.Joystick = g_pGlobalData->scDefaultJoy;
	ghJoy[uiDeviceNumber-1] = 0;
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcJoyEnd()

	DESCRIPTION:

****************************************************************************/

BOOL XswcJoyEnd( HSWITCHDEVICE hsd )
	{
	BOOL bSuccess = TRUE;
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	ghJoy[uiDeviceNumber-1] = 0;
	g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwSwitches = 0;

	// ignore bSuccess since we can't do anything anyways.
	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcJoyGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcJoyGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	*psc = g_pGlobalData->rgscJoy[uiDeviceNumber-1];
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcJoySetConfig()

	DESCRIPTION:
		Activate/Deactivate the device.
		
		Four cases: 
		1) hJoy = 0 and active = 0		- do nothing
		2)	hJoy = x and active = 1		- just set the configuration
		3) hJoy = 0 and active = 1		- activate and set the configuration
		4) hJoy = x and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set. This all probably needs some work.

****************************************************************************/

BOOL XswcJoySetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	BOOL		bSuccess;
	BOOL		bJustOpened;
	UINT		uiDeviceNumber;
    HJOYDEVICE  *pghJoy;
	PSWITCHCONFIG pgscJoy;

	bSuccess = FALSE;
	bJustOpened = FALSE;

	// Simplify our code
	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	pghJoy = &ghJoy[uiDeviceNumber-1];
	pgscJoy = &g_pGlobalData->rgscJoy[uiDeviceNumber-1];
	
	// Should we activate?
	if (	(0==*pghJoy)
		&&	(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{ // Yes
		*pghJoy = XswcJoyOpen( uiDeviceNumber );
		if (*pghJoy)
			{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			pgscJoy->dwFlags |= SC_FLAG_ACTIVE;
			pgscJoy->dwFlags &= ~SC_FLAG_UNAVAILABLE;
			}
		else
			{ // Not OK
			bSuccess = FALSE;
			pgscJoy->dwFlags &= ~SC_FLAG_ACTIVE;
			pgscJoy->dwFlags |= SC_FLAG_UNAVAILABLE;
			}
		}

	// Should we deactivate?
	else if (	(0!=*pghJoy)
		&&	!(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{
		XswcJoyEnd( hsd ); // This will also zero out *pghJoy
		bSuccess = TRUE;
		pgscJoy->dwFlags &= ~SC_FLAG_ACTIVE;
		}
	
	// If the above steps leave a valid hJoy, let's try setting the config
	if ( 0!=*pghJoy )
		{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
			{
			bSuccess = XswcJoySet( *pghJoy, &g_pGlobalData->scDefaultJoy );
			if (bSuccess)
				{
				pgscJoy->dwFlags |= SC_FLAG_DEFAULT;
				pgscJoy->u.Joystick = g_pGlobalData->scDefaultJoy;
				}
			}
		else
			{
			bSuccess = XswcJoySet( *pghJoy, &(psc->u.Joystick) );
			if (bSuccess)
				{
            pgscJoy->u.Joystick = psc->u.Joystick;
				}
			}

		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
			{
			XswcJoyEnd( hsd );
			pgscJoy->dwFlags &= ~SC_FLAG_ACTIVE;
			}
		}

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: XswcJoyPollStatus()

	DESCRIPTION:
		Must be called in the context of the helper window.
		(Actually it's not strictly necessary for the joystick,
		but we say so in order to be consistent with the other ports.)
****************************************************************************/

DWORD XswcJoyPollStatus( HSWITCHDEVICE	hsd )
	{
	JOYINFOEX	joyinfoex;
	MMRESULT		mmr;
	DWORD			dwStatus = 0;	// PREFIX 133793 init to default value
	UINT			uiDeviceNumber;
	UINT			uiJoyID;

	joyinfoex.dwSize = sizeof( JOYINFOEX );
	uiDeviceNumber = swcListGetDeviceNumber( NULL, hsd );

	assert( JOYSTICKID1 == 0 );	// assume JOYSTICKIDx is zero based
	uiJoyID = uiDeviceNumber -1;

	if (SC_FLAG_ACTIVE & g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwFlags)
		{
		switch (g_pGlobalData->rgscJoy[uiDeviceNumber-1].u.Joystick.dwJoySubType)
			{
			case SC_JOY_BUTTONS:
				{
				dwStatus = 0;
				joyinfoex.dwFlags = JOY_RETURNBUTTONS;
				mmr = joyGetPosEx( uiJoyID, &joyinfoex );

				if (JOYERR_NOERROR == mmr)
					{
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON1) ? SWITCH_1 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON2) ? SWITCH_2 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON3) ? SWITCH_3 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON4) ? SWITCH_4 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON5) ? SWITCH_5 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON6) ? SWITCH_6 : 0;
					}
				}
				break;

			case SC_JOY_XYSWITCH:
				{
				dwStatus = 0;
				joyinfoex.dwFlags = JOY_RETURNBUTTONS | JOY_RETURNX | JOY_RETURNY;
				mmr = joyGetPosEx( uiJoyID, &joyinfoex );
				if (JOYERR_NOERROR == mmr)
					{
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON1) ? SWITCH_1 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON2) ? SWITCH_2 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON3) ? SWITCH_3 : 0;
					dwStatus |= (joyinfoex.dwButtons & JOY_BUTTON4) ? SWITCH_4 : 0;
					// No hysteresis needed, since it should be a switch
					if (joyinfoex.dwXpos < g_pGlobalData->rgJoySet[uiJoyID].XMinOn)
						dwStatus |=  SWITCH_5;
					if (joyinfoex.dwYpos < g_pGlobalData->rgJoySet[uiJoyID].YMinOn)
						dwStatus |=  SWITCH_6;
					}
				}
				break;

			case SC_JOY_XYANALOG:
				{
				// Hysteresis is necessary because of the "noisiness" of the joystick
				dwStatus = 0;
				joyinfoex.dwFlags = JOY_RETURNBUTTONS | JOY_RETURNX | JOY_RETURNY;
				mmr = joyGetPosEx( uiJoyID, &joyinfoex );

				if (JOYERR_NOERROR == mmr)
					{
					// In order to deal with the hysteresis,
					// we must explicity turn on or off each switch bit.
					dwStatus = g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwSwitches;

					// left and right
					if (joyinfoex.dwXpos < g_pGlobalData->rgJoySet[uiJoyID].XMinOn)
						dwStatus |=  SWITCH_4;
					if (joyinfoex.dwXpos > g_pGlobalData->rgJoySet[uiJoyID].XMinOff)
						dwStatus &= ~SWITCH_4;

					if (joyinfoex.dwXpos > g_pGlobalData->rgJoySet[uiJoyID].XMaxOn)
						dwStatus |=  SWITCH_1;
					if (joyinfoex.dwXpos < g_pGlobalData->rgJoySet[uiJoyID].XMaxOff)
						dwStatus &= ~SWITCH_1;

					// top and bottom
					if (joyinfoex.dwYpos < g_pGlobalData->rgJoySet[uiJoyID].YMinOn)
						dwStatus |=  SWITCH_1;
					if (joyinfoex.dwYpos > g_pGlobalData->rgJoySet[uiJoyID].YMinOff)
						dwStatus &= ~SWITCH_1;

					if (joyinfoex.dwYpos > g_pGlobalData->rgJoySet[uiJoyID].YMaxOn)
						dwStatus |=  SWITCH_3;
					if (joyinfoex.dwYpos < g_pGlobalData->rgJoySet[uiJoyID].YMaxOff)
						dwStatus &= ~SWITCH_3;

					// 2 buttons
					if (joyinfoex.dwButtons & JOY_BUTTON1)
						dwStatus |=  SWITCH_5;
					else
						dwStatus &= ~SWITCH_5;

					if (joyinfoex.dwButtons & JOY_BUTTON2)
						dwStatus |=  SWITCH_6;
					else
						dwStatus &= ~SWITCH_6;
					}
				}
				break;

			default:
				dwStatus = 0;
				break;
			}
		g_pGlobalData->rgscJoy[uiDeviceNumber-1].dwSwitches = dwStatus;
		}

	return dwStatus;
	}

/****************************************************************************

   FUNCTION: XswcJoyOpen()

	DESCRIPTION:
	 uiPort is 1 based.
	 Return a non-zero value if the port is useable.
	 The joystick driver doesn't have a port to open, so
	 we fake the handle by using the PortNumber.

****************************************************************************/

HJOYDEVICE XswcJoyOpen( DWORD uiPort )
	{
	JOYINFOEX   joyinfoex;
	MMRESULT    mmr;
	UINT        uiJoyID;
    HJOYDEVICE  hJoy;	//faked, for success it must be non-zero

	assert( JOYSTICKID1 == 0 );	// assume JOYSTICKIDx is zero based

	joyinfoex.dwSize = sizeof( JOYINFOEX );

	// To check if a joystick is attached, set RETURNX and RETURNY as well.
	// If no joystick is attached, we will be OK just calling RETURNBUTTONS,
	// but a user will not be able to use the Windows calibration in 
    // Control Panel.

	joyinfoex.dwFlags = JOY_RETURNBUTTONS;
	uiJoyID = uiPort - 1;

	mmr = joyGetPosEx( uiJoyID, &joyinfoex );

	if (JOYERR_NOERROR == mmr)
		{
		hJoy = (HJOYDEVICE)uiPort;
		}
	else
		{
		hJoy = 0;
		}

	return hJoy;
	}


/****************************************************************************

   FUNCTION: XswcJoySet()

	DESCRIPTION:
		Sets the configuration of the particular Port.
		Remember that hJoy is actually the joystick port number.
		Return FALSE (0) if an error occurs.
		
****************************************************************************/

BOOL XswcJoySet(
	HJOYDEVICE hJoy,
	PSWITCHCONFIG_JOYSTICK pJ )
	{
	UINT uiJoyID = hJoy -1;
	BOOL bSuccess = TRUE;

	switch (pJ->dwJoySubType)
		{
		case SC_JOY_BUTTONS:
			bSuccess = TRUE;	//nothing to do
			break;

		case SC_JOY_XYSWITCH:
			// XY Switch only uses XMin and YMin
		case SC_JOY_XYANALOG:
			{
			DWORD	dwHy;
			// Set X values
			if (pJ->dwJoyThresholdMinX)
				g_pGlobalData->rgJoySet[uiJoyID].XMinOn = pJ->dwJoyThresholdMinX;
			else
				g_pGlobalData->rgJoySet[uiJoyID].XMinOn = 0x4000;
			g_pGlobalData->rgJoySet[uiJoyID].XMinOff = g_pGlobalData->rgJoySet[uiJoyID].XMinOn;
			if (pJ->dwJoyThresholdMaxX)
				g_pGlobalData->rgJoySet[uiJoyID].XMaxOn = pJ->dwJoyThresholdMaxX;
			else
				g_pGlobalData->rgJoySet[uiJoyID].XMaxOn = 0xC000;
			g_pGlobalData->rgJoySet[uiJoyID].XMaxOff = g_pGlobalData->rgJoySet[uiJoyID].XMaxOn;

			// Set Y values
			if (pJ->dwJoyThresholdMinY)
				g_pGlobalData->rgJoySet[uiJoyID].YMinOn = pJ->dwJoyThresholdMinY;
			else
				g_pGlobalData->rgJoySet[uiJoyID].YMinOn = 0x4000;
			g_pGlobalData->rgJoySet[uiJoyID].YMinOff = g_pGlobalData->rgJoySet[uiJoyID].YMinOn;
			if (pJ->dwJoyThresholdMaxY)
				g_pGlobalData->rgJoySet[uiJoyID].YMaxOn = pJ->dwJoyThresholdMaxY;
			else
				g_pGlobalData->rgJoySet[uiJoyID].YMaxOn = 0xC000;
			g_pGlobalData->rgJoySet[uiJoyID].YMaxOff = g_pGlobalData->rgJoySet[uiJoyID].YMaxOn;

			// Set hysteresis
			if (pJ->dwJoyHysteresis)
				dwHy = pJ->dwJoyHysteresis/2; // +/- half the value
			else
				dwHy = 0xFFFF/20;		// +/- 5%

			// Adjust for hysteresis
			g_pGlobalData->rgJoySet[uiJoyID].XMinOn -= dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].XMinOff += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].XMaxOn += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].XMaxOff -= dwHy;

			g_pGlobalData->rgJoySet[uiJoyID].YMinOn -= dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].YMinOff += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].YMaxOn += dwHy;
			g_pGlobalData->rgJoySet[uiJoyID].YMaxOff -= dwHy;
			bSuccess = TRUE;
			break;
			}

		default:
			bSuccess = FALSE;
			break;
		}

	return bSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\swchlist.c ===
/****************************************************************************
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre

   SWCHLIST.C -  Dynamic List of switch devices

  Think of the specific switch device modules as objects. Then
  this module performs the "method overloading" by distributing
  the general calls to the respective specific device objects.
  Who needs C++ objects when you can just add another case to each of a
  dozen switch() statements? :-)
  We could solve this by adding a list of function pointers to the
  data structure of each object, but that adds another layer of
  complexity to create, debug, and maintain.

  In addition this module keeps the list of devices and manipulates the registry
  entries for each device.

  Assumptions:

  For now the Switch List is a static shared memory location. In the future
  it will become a dynamic shared memory mapped file, probably as a linked list.

  The registry entries are contiguously numbered, one for each switch device.
  While we are running, the position of a device in the Switch List is the
  same as its position in the Registry List.

  TODO:
  Some of the swcList functions are called by each other, but there is
  some overhead in testing for valid parameters each time. This
  should be eliminated, by creating "Unchecked" functions.
*******************************************************************************/

#include <windows.h>
#include <assert.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#include <msswch.h>
#include "msswchh.h"
#include "msswcher.h"
#include "mappedfile.h"
#include "w95trace.h"

/***** Internal Prototypes *****/
BOOL swcListIsValidHsd(HSWITCHDEVICE hsd);
BOOL swcListIsValidDevice(UINT uiDeviceType, UINT uiDeviceNumber);
BOOL XswcListInitSwitchDevice(HSWITCHDEVICE hsd);
swcListRegSetValue(DWORD dwPos, PSWITCHCONFIG psc);
HKEY swcListRegCreateKey(void);
DWORD swcListFindInList(HSWITCHDEVICE	hsd);
BOOL swcListHsdInUse(HSWITCHDEVICE hsd);
DWORD swcListAddToList(HSWITCHDEVICE hsd);
BOOL swcListPostSwitches(HSWITCHDEVICE hsd, DWORD dwPrevStatus,	DWORD dwNewStatus);

void swchListInit()
{
    g_pGlobalData->rgSwitches[0] = SWITCH_1;
    g_pGlobalData->rgSwitches[1] = SWITCH_2;
    g_pGlobalData->rgSwitches[2] = SWITCH_3;
    g_pGlobalData->rgSwitches[3] = SWITCH_4;
    g_pGlobalData->rgSwitches[4] = SWITCH_5;
    g_pGlobalData->rgSwitches[5] = SWITCH_6;

    g_pGlobalData->rgSwDown[0] = SW_SWITCH1DOWN;
    g_pGlobalData->rgSwDown[1] = SW_SWITCH2DOWN;
    g_pGlobalData->rgSwDown[2] = SW_SWITCH3DOWN;
    g_pGlobalData->rgSwDown[3] = SW_SWITCH4DOWN;
    g_pGlobalData->rgSwDown[4] = SW_SWITCH5DOWN;
    g_pGlobalData->rgSwDown[5] = SW_SWITCH6DOWN;

    g_pGlobalData->rgSwUp[0] = SW_SWITCH1UP;
    g_pGlobalData->rgSwUp[1] = SW_SWITCH2UP;
    g_pGlobalData->rgSwUp[2] = SW_SWITCH3UP;
    g_pGlobalData->rgSwUp[3] = SW_SWITCH4UP;
    g_pGlobalData->rgSwUp[4] = SW_SWITCH5UP;
    g_pGlobalData->rgSwUp[5] = SW_SWITCH6UP;
}

/****************************************************************************

   FUNCTION: XswcListInit()

	DESCRIPTION:

   Called in the context of the helper window
   
   Individual devices are initialized during GetSwitchDevice,
   and are added to the switch list during SetConfig.

   Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL XswcListInit( void )
	{
	HKEY		hKey;
	DWORD		dwAllocSize;
	PBYTE		pData;
	LONG		lError;
	TCHAR		szName[20];
	DWORD		dwNameSize = 20;
	DWORD		dwDataSize;
	DWORD		ui;

	HSWITCHDEVICE	hsd;
	SWITCHCONFIG	sc;

	// When we go dynamic, use something like this:
	//g_pGlobalData->dwCurrentSize = sizeof( DWORD ) + MAX_SWITCHDEVICES * sizeof( HSWITCHDEVICE );
	// For now we are cheating:
	g_pGlobalData->dwCurrentSize = sizeof( INTERNALSWITCHLIST );

	hKey = swcListRegCreateKey();
	// In future, get maximum list size from registry.
	// For now, assume it is MAX_SWITCHDEVICES
	//RegQueryKeyInfo();

	dwAllocSize = sizeof(SWITCHCONFIG);
	pData = (PBYTE) LocalAlloc( LPTR, dwAllocSize );

	// Enumerate through the registry, configuring appropriate switches and 
	// adding them to the switch list.
	if (pData)
		{
		for (ui=0; ui<MAX_SWITCHDEVICES; ui++ )
			{
			dwDataSize = dwAllocSize;
			lError = RegEnumValue( hKey, ui,
				szName,
				&dwNameSize,
				NULL,
				NULL,
				pData,
				&dwDataSize );
			if (	(ERROR_SUCCESS == lError)
				||	(ERROR_MORE_DATA == lError)
				)
				{
				memcpy( &sc, pData, sizeof(SWITCHCONFIG) );
				// Note that this depends on the correctness of the stored
				// uiDeviceType and uiDeviceNumber. We can handle a variable
				// uiDeviceNumber, but the uiDeviceType cannot vary.
				// GetSwitchDevice also calls InitSwitchDevice
				hsd = swcListGetSwitchDevice( NULL, sc.uiDeviceType, sc.uiDeviceNumber );
				XswcListSetConfig( NULL, hsd, &sc );
				}
			else
				{
				break;
				}
			}

		LocalFree( pData );
		}

	RegCloseKey( hKey );
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcListEnd()

	DESCRIPTION:
		Iterate through the list of switches and release all resources
		for each switch.

  Called in the context of the helper window

****************************************************************************/

BOOL XswcListEnd()
{
	PINTERNALSWITCHLIST pSwitchList;
	HSWITCHDEVICE hsd;
	BOOL		bRtn = FALSE;
	UINT		ui;

	pSwitchList = &g_pGlobalData->SwitchList;

	for (ui=0; ui<pSwitchList->dwSwitchCount; ui++ )
	{
		hsd = pSwitchList->hsd[ui];
		switch (swcListGetDeviceType( NULL, hsd ))
		{
			case SC_TYPE_COM:
				bRtn = XswcComEnd( hsd );
				break;

			case SC_TYPE_LPT:
				bRtn = XswcLptEnd( hsd );
				break;

			case SC_TYPE_JOYSTICK:
				bRtn = XswcJoyEnd( hsd );
				break;

			case SC_TYPE_KEYS:
				bRtn = XswcKeyEnd( hsd );
				break;

			default:
				bRtn = FALSE;
				break;
		}
	}

	return bRtn;
}


/****************************************************************************

   FUNCTION: swcListGetList()

	DESCRIPTION:

   Returns the list of switch device handles (hsd's).  Currently this is
	a static list with a count of the active elements in it.

   Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL swcListGetList(
	HSWITCHPORT		hSwitchPort,
	PSWITCHLIST		pSL,
	DWORD				dwSize,
	PDWORD			pdwReturnSize )
	{
	PINTERNALSWITCHLIST pSwitchList;

	pSwitchList = &g_pGlobalData->SwitchList;
	*pdwReturnSize = g_pGlobalData->dwCurrentSize;
	if (!pSL || !pSwitchList)
		return FALSE;
	if (dwSize < *pdwReturnSize)
		return FALSE;

	memcpy( pSL, pSwitchList, *pdwReturnSize );
	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcListGetSwitchDevice()

	DESCRIPTION:
	   Return a handle to a switch device, given the PortType and PortNumber.
	   If the device is not in use yet, initialize it.

		The current way to create the handle is to put the PortType in the HIWORD
		and the PortNumber in the LOWORD, but that is not a documented part of the
		specification.
		In the future it may become a real handle and we will need to search
		for it or create it. Creation will require allocation of config buffers
		for each device. and will probably occur as part of the initialization.
		This dynamic hsd will have to be created and kept in a "created"
		list, separate from the "active" list, until it gets added to the active list.

****************************************************************************/

HSWITCHDEVICE swcListGetSwitchDevice(
	HSWITCHPORT		hSwitchPort,
	UINT				uiDeviceType,
	UINT				uiDeviceNumber	)
	{
	HSWITCHDEVICE	hsd;

	if (swcListIsValidDevice( uiDeviceType, uiDeviceNumber ))
		{
		hsd = (HSWITCHDEVICE)
			( MAKELPARAM( (WORD)uiDeviceNumber, (WORD)uiDeviceType ) );
		if (!swcListHsdInUse( hsd )) // It's a new one
			XswcListInitSwitchDevice( hsd );
		}
   else
      {
      hsd = 0;
		// SetLastError has been called by swcListIsValidDevice
      }

	return hsd;
	}


/****************************************************************************

   FUNCTION: swcListIsValidHsd()

	DESCRIPTION:
		Check if the hsd is valid.

		This routine is currently only for non-dynamically allocated
		devices COM, LPT, KEYS, and JOYSTICK.

		For dynamic Hsd's the validity of the Hsd will have to be checked
		from the lists of active or created hsd's.

		Sets LastError.

****************************************************************************/

BOOL swcListIsValidHsd( HSWITCHDEVICE hsd )
	{
	if (!swcListIsValidDevice( 
			(UINT)(HIWORD( (DWORD)((DWORD_PTR)hsd) )),	// type
			(UINT)(LOWORD( (DWORD)((DWORD_PTR)hsd) ))	// number
		))
		{
		XswchStoreLastError( NULL, SWCHERROR_INVALID_HSD );
		return FALSE;
		}

	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcListIsValidDevice()

	DESCRIPTION:
		Check if the uiDeviceType and uiDeviceNumber are valid.
		This routine is currently only for non-dynamically allocated
		devices COM, LPT, KEYS, and JOYSTICK.

		For dynamic Hsd's the validity of the Hsd will have to be checked
		from the lists of active or created hsd's.

		Sets LastError.

****************************************************************************/

BOOL swcListIsValidDevice(
	UINT		uiDeviceType,
	UINT		uiDeviceNumber	)
	{
	BOOL		bTypeOK;
	BOOL		bNumberOK = FALSE;

	// Need to add better error checking for valid parameters here.
	switch (uiDeviceType)
		{
		case SC_TYPE_COM:
			bTypeOK = TRUE;
			if (uiDeviceNumber >= 1 && uiDeviceNumber <= 4)
				bNumberOK = TRUE;
			break;

		case SC_TYPE_LPT:
			bTypeOK = TRUE;
			if (uiDeviceNumber >= 1 && uiDeviceNumber <= 3)
				bNumberOK = TRUE;
			break;

		case SC_TYPE_JOYSTICK:
			bTypeOK = TRUE;
			if (uiDeviceNumber >= 1 && uiDeviceNumber <= 2)
				bNumberOK = TRUE;
			break;

		case SC_TYPE_KEYS:
			bTypeOK = TRUE;
         if (1 == uiDeviceNumber)
				bNumberOK = TRUE;
			break;

      default:
         bTypeOK = FALSE;
         bNumberOK = FALSE;
		}

	if (!bTypeOK)
		{
		XswchStoreLastError( NULL, SWCHERROR_INVALID_DEVICETYPE );
		return FALSE;
		}

	if (!bNumberOK)
		{
		XswchStoreLastError( NULL, SWCHERROR_INVALID_DEVICENUMBER );
		return FALSE;
		}

	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcListGetDeviceType()

	DESCRIPTION:
		Return the PortType value given the handle to the switch device.
		Currently the handle is implemented with the HIWORD as the Type.
		In the future we may wish to access the SWITCHCONFIG information
		instead.
****************************************************************************/

UINT swcListGetDeviceType(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd )
	{
	if (!swcListIsValidHsd( hsd ))
		return 0;
	else
		return (UINT)(HIWORD( (DWORD)((UINT_PTR)hsd) ));
	}


/****************************************************************************

   FUNCTION: swcListGetDeviceNumber()

	DESCRIPTION:
		Return the PortNumber value, given the handle to the switch device.
		Currently the handle is implemented with the LOWORD as the Number.
		In the future we may wish to access the SWITCHCONFIG information
		instead.
****************************************************************************/

UINT swcListGetDeviceNumber(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd	)
	{
	if (!swcListIsValidHsd( hsd ))
		return 0;
	else
		return (UINT)(LOWORD( hsd ));
	}


/****************************************************************************

   FUNCTION: swcListGetConfig()

	DESCRIPTION:
		Return the configuration information for the specified device.

     Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL swcListGetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	BOOL bRtn;

	switch (swcListGetDeviceType( hSwitchPort, hsd ))
		{
		case SC_TYPE_COM:
			bRtn = swcComGetConfig( hsd, psc );
			break;

		case SC_TYPE_LPT:
			bRtn = swcLptGetConfig( hsd, psc );
			break;

		case SC_TYPE_JOYSTICK:
			bRtn = swcJoyGetConfig( hsd, psc );
			break;

		case SC_TYPE_KEYS:
			bRtn = swcKeyGetConfig( hsd, psc );
			break;

		default:
			bRtn = FALSE;
		}
	return bRtn;
	}


/****************************************************************************

   FUNCTION: XswcListSetConfig()

	DESCRIPTION:
		Called in the context of the helper window
		Set the device configuration.
		If successful:
			If not in list, add to list
			Set registry value

		For a device to be in the registry, it must have had
		at least one successful config.

		This is also the "gatekeeper" for the uiDeviceType and uiDeviceNumber
		fields. These fields are "readonly" and cannot be changed by the user.
			
   Protected by "MutexConfig" when called from msswch.c.

****************************************************************************/

BOOL XswcListSetConfig(
	HSWITCHPORT		hSwitchPort,
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{	
	BOOL	bRtn;
	DWORD	dwRegPosition;

   // assume cbSize error checking has been done in swchSetConfig in msswch.c
   // we'll be doing "lazy copies" later, so make sure the user doesn't overwrite
   // this.
   psc->cbSize = sizeof(SWITCHCONFIG);

   // make sure the user doesn't overwrite these
	psc->uiDeviceType = swcListGetDeviceType( hSwitchPort, hsd );
	psc->uiDeviceNumber = swcListGetDeviceNumber( hSwitchPort, hsd );

	switch (	psc->uiDeviceType )
		{
		case SC_TYPE_COM:
			bRtn = XswcComSetConfig( hsd, psc );
			break;

		case SC_TYPE_LPT:
			bRtn = XswcLptSetConfig( hsd, psc );
			break;

		case SC_TYPE_JOYSTICK:
			bRtn = XswcJoySetConfig( hsd, psc );
			break;

		case SC_TYPE_KEYS:
			bRtn = XswcKeySetConfig( hsd, psc );
			break;

		default:
			bRtn = FALSE;
			break;
		}

	if (bRtn)
		{
		if (swcListHsdInUse( hsd ))
			{
			dwRegPosition = swcListFindInList( hsd );
			}
		else	 // It's a new one
			{
			dwRegPosition = swcListAddToList( hsd );
			}
		swcListRegSetValue( dwRegPosition, psc );
		swchPostConfigChanged();
		}

	return bRtn;
	}


/****************************************************************************

   FUNCTION: XswcListPollSwitches()

	DESCRIPTION:
		Polls the status of all possible switches and returns the
		bitwise OR combined status of the polled switch devices.
		Causes messages to be posted for any changed switches of 
		any device.
		Currently, we check the previous switch status of each device 
		before it is polled and changed. When any devices go
		to an interrupt driven mechanism, this will need to
		be changed.

		Must be called in the context of the helper window.

****************************************************************************/

DWORD XswcListPollSwitches( void )
	{
	PINTERNALSWITCHLIST	pSwitchList;
	SWITCHCONFIG		SwitchConfig;
	HSWITCHDEVICE		hsd;
	DWORD				dwPrevStatus;
	DWORD				dwNewStatus;
	DWORD				dwAllPolledStatus = 0;
	HANDLE				hMutex;
	UINT				ui;

    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHLIST, INFINITE))
    {
		pSwitchList = &g_pGlobalData->SwitchList;
		memset(&SwitchConfig, 0, sizeof(SWITCHCONFIG));	// PREFIX 113795 init struct

		for (ui=0; ui<pSwitchList->dwSwitchCount; ui++ )
		{
			// For each switch device, get the old status before we poll it and
			// it changes to its new status.
			hsd = pSwitchList->hsd[ui];
			swcListGetConfig( NULL, hsd, &SwitchConfig );
			if (SC_FLAG_ACTIVE & SwitchConfig.dwFlags)
			{
				dwPrevStatus = SwitchConfig.dwSwitches;
				switch (swcListGetDeviceType( NULL, hsd ))
				{
					case SC_TYPE_COM:
					dwNewStatus = XswcComPollStatus( hsd );
					break;

					case SC_TYPE_LPT:
					dwNewStatus = XswcLptPollStatus( hsd );
					break;

					case SC_TYPE_JOYSTICK:
					dwNewStatus = XswcJoyPollStatus( hsd );
					break;

					case SC_TYPE_KEYS:
					dwNewStatus = XswcKeyPollStatus( hsd );
					break;

					default:
					dwNewStatus = 0;
					break;
				}
				swcListPostSwitches( hsd, dwPrevStatus, dwNewStatus );
				dwAllPolledStatus |= dwNewStatus;
			}
		}
        ScopeUnaccessMemory(hMutex);
    }

	return dwAllPolledStatus;
	}


/****************************************************************************

	FUNCTION: XswcListInitSwitchDevice()

	DESCRIPTION:

	Called in GetSwitchDevice to initialize a new hsd.

	Called in the context of the helper window

****************************************************************************/

BOOL XswcListInitSwitchDevice( HSWITCHDEVICE hsd )
	{
	BOOL bRtn;

	switch (swcListGetDeviceType( NULL, hsd ))
		{
		case SC_TYPE_COM:
			bRtn = XswcComInit( hsd );
			break;

		case SC_TYPE_LPT:
			bRtn = XswcLptInit( hsd );
			break;

		case SC_TYPE_JOYSTICK:
			bRtn = XswcJoyInit( hsd );
			break;

		case SC_TYPE_KEYS:
			bRtn = XswcKeyInit( hsd );
			break;

		default:
			bRtn = FALSE;
		}
	return bRtn;
	}

	
/****************************************************************************

   FUNCTION: swcListRegSetValue()

	DESCRIPTION:
		Stores the given config structure in the registry.
		Note that the structure is actually two structures,
		with a pointer from the base structure to the More Info structure.
		We simply copy both structures to the registry, concatenating them.

		The position in the registry and the position in the switch list
		are kept in sync.

  *** Note ***
		The correctness of this information is dependent on a side effect
		of the XswcListSetConfig function, which verifies the correctness
		of the read-only uiDeviceType and uiDeviceNumber fields of the config
		structure.

****************************************************************************/

swcListRegSetValue(
	DWORD		dwPos,
	PSWITCHCONFIG	psc)
	{
	HKEY		hKey;
	DWORD		dwAllocSize;
	PBYTE		pData;
	TCHAR		szValue[10];

	// Sanity checks for developers and testers
	assert( sizeof(HSWITCHDEVICE) == sizeof(DWORD) );

	dwAllocSize = sizeof(SWITCHCONFIG);
	pData = (PBYTE) LocalAlloc( LPTR, dwAllocSize );
	if (pData)
		{
		memcpy( pData, psc, sizeof(SWITCHCONFIG));		
		hKey = swcListRegCreateKey();
		// Create incrementing value names: "0000", "0001", "0002", etc.
		wsprintf( szValue, TEXT("%4.4d"), dwPos );
		if (hKey)
		{	// PREFIX 113792 dereference of NULL pointer
			RegSetValueEx( hKey, szValue, 0, REG_BINARY, pData, dwAllocSize );
			RegCloseKey( hKey );
		}
		}

	if (pData)
		LocalFree( pData );
	
	return 0;
	}


/****************************************************************************

   FUNCTION: swcListRegCreateKey()

	DESCRIPTION:
		Creates/Opens the registry key associated with the MSSWITCH entries.
		Temporary keys used to traverse the tree are closed again.
		The open key returned from this function must be closed by the
		caller.

		Currently the key opened is:
		HKEY_CURRENT_USER/Software/Microsoft/MS Switch

****************************************************************************/

HKEY swcListRegCreateKey( void )
	{
	LONG		lResult;
	DWORD		dwDisposition;
	HKEY		hKey1, hKey2, hKey3;
	
	lResult = RegCreateKeyEx( HKEY_CURRENT_USER,
		_TEXT("Software"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,	// security
		&hKey1,
		&dwDisposition );

	lResult = RegCreateKeyEx( hKey1,
		_TEXT("Microsoft"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,	// security
		&hKey2,
		&dwDisposition );

	lResult = RegCreateKeyEx( hKey2,
		_TEXT("MS Switch"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,	// security
		&hKey3,
		&dwDisposition );

	RegCloseKey( hKey1 );
	RegCloseKey( hKey2 );
	return hKey3;
	}


/****************************************************************************

   FUNCTION: swcListFindInList()

	DESCRIPTION:
		Find the list position of the given switchdevice.
		We assume the list position is the same in the g_pGlobalData->SwitchList
		and in the Registry List.

		Returns the zero based position or -1 if there is an error.
		If this changes, synchronize with ListHsdInList.

		Should we mutex this to synchronize with swcAddToList()?
****************************************************************************/

DWORD swcListFindInList( HSWITCHDEVICE	hsd )
	{
	PINTERNALSWITCHLIST	pSwitchList;
	DWORD		ui;

	pSwitchList = &g_pGlobalData->SwitchList;
	for (ui=0; ui < pSwitchList->dwSwitchCount; ui++)
		{
		if (hsd == pSwitchList->hsd[ui])
			break;
		}
	
	// if not found, return error
	if (ui == pSwitchList->dwSwitchCount)
		{
		ui = (DWORD)-1;
		}

	return ui;
	}


/****************************************************************************

	FUNCTION: swcListHsdInUse()

	DESCRIPTION:
	Return TRUE if the Hsd is one of the devices that is already initialized
	and in use.
****************************************************************************/

BOOL swcListHsdInUse( HSWITCHDEVICE hsd )
	{
	return (DWORD)-1 != swcListFindInList( hsd );
	}


/****************************************************************************

   FUNCTION: swcListAddToList()

	DESCRIPTION:
		Adds the switch device to our list,
		returning its new position in the list.
		This assumes that swcListFindInList has been called first
		or some other check has been made to make sure the device is not
		already there.		

****************************************************************************/

DWORD swcListAddToList( HSWITCHDEVICE hsd )
{
	PINTERNALSWITCHLIST  pSwitchList;
	HANDLE	hMutex;
    DWORD dwRv = 0;

    if (ScopeAccessMemory(&hMutex, SZMUTEXSWITCHLIST, INFINITE))
    {
		// When we go dynamic:
		// pSwitchList = MapViewOfFileEx();
		// For now, cheat:
		pSwitchList = &g_pGlobalData->SwitchList;

		pSwitchList->hsd[pSwitchList->dwSwitchCount] = hsd;
		pSwitchList->dwSwitchCount++;
        dwRv = pSwitchList->dwSwitchCount - 1;

        ScopeUnaccessMemory(hMutex);
    }

	return dwRv; 
}


/****************************************************************************

   FUNCTION: swcListPostSwitches()

	DESCRIPTION:

		For each switch up or down that has occured, request that a message
		gets posted to all apps which requested messages.

****************************************************************************/

BOOL swcListPostSwitches(HSWITCHDEVICE hsd, DWORD dwPrevStatus, DWORD dwNewStatus)
{
	int		i;
	DWORD	dwBit;                              // look at one bit at a time
	DWORD	dwChg = dwPrevStatus ^ dwNewStatus; // Isolate changes

	for (i=0; i<NUM_SWITCHES; i++)		// For each bit, check for a change
	{
		dwBit = dwChg & g_pGlobalData->rgSwitches[i];
		if (dwBit)                       // This switch has changed
		{
			if (!(dwBit & dwNewStatus))	// ... to "up"
			{
				swchPostSwitches( hsd, g_pGlobalData->rgSwUp[i] );
			}
		}
	}

	for (i=0; i<NUM_SWITCHES; i++)	// For each bit, check for a change
	{
		dwBit = dwChg & g_pGlobalData->rgSwitches[i];
		if (dwBit)                    // This switch has changed
		{
			if (dwBit & dwNewStatus)	// ... to "down"
			{
				swchPostSwitches( hsd, g_pGlobalData->rgSwDown[i] );
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswch\swchlpt.c ===
/****************************************************************************
   Switch Input Library DLL - Parallel port routines

   Copyright (c) 1992-1997 Bloorview MacMillan Centre


*******************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <conio.h>
#include <stdio.h>
#include <winioctl.h>
#include <msswch.h>
#include "msswchh.h"
#include "ntddpar.h"
#include "mappedfile.h"

// Internal functions
HANDLE XswcLptOpen( DWORD uiPort );
BOOL XswcLptSet(HANDLE hCom, PSWITCHCONFIG_LPT pC );

HANDLE swcLptOpen_Win( DWORD uiPort );
BOOL swcLptEnd_Win( HANDLE hsd );
DWORD swcLptStatus_Win( HANDLE hsd );
BOOL swcLptSet_Win(	HANDLE hLpt, PSWITCHCONFIG_LPT pC );

HANDLE swcLptOpen_NT( DWORD uiPort );
BOOL swcLptEnd_NT( HANDLE hsd );
DWORD swcLptStatus_NT( HANDLE hsd );
BOOL swcLptSet_NT(HANDLE hLpt, PSWITCHCONFIG_LPT pC );

void swchLptInit()
{
    int i;
    long lSize = sizeof(SWITCHCONFIG_LPT);

    g_pGlobalData->scDefaultLpt.dwReserved1 = SC_LPT_DEFAULT;
    g_pGlobalData->scDefaultLpt.dwReserved2 = SC_LPTDATA_DEFAULT;

    for (i=0;i<MAX_LPT;i++)
    {
        g_pGlobalData->rgscLpt[i].cbSize = lSize;
        g_pGlobalData->rgscLpt[i].uiDeviceType = SC_TYPE_LPT;
        g_pGlobalData->rgscLpt[i].uiDeviceNumber = i+1;
        g_pGlobalData->rgscLpt[i].dwFlags = SC_FLAG_DEFAULT;
    }
}

// Handles cannot be shared across processes.
// For NT, these are port/file handles, for '95 these are port addresses
HANDLE hLpt[MAX_LPT] = {0,0,0};


// Printer Ports
#define PRT_DATA		0x00
#define PRT_STAT		0x01
#define PRT_CTRL		0x02

// Printer Status Port
//			- inputs are straight in, switch pulls pin low = bit low
//			ERR, SEL, ACK are active low
//			PE is active high
//			NB is inverted state of BUSY line, BUSY is active high
//				- therefore, NB is sort of active low

#define PRT_TO		0x01
#define PRT_Resv1	0x02
#define PRT_IRQS	0x04	// IRQ pending
#define PRT_ERR	0x08	// pin 15 - MSI switch 3 - PRC sw2/5
#define PRT_SEL	0x10	// pin 13 - MSI switch 1 - PRC sw1/4
#define PRT_PE		0x20	// pin 12 - MSI switch 2
#define PRT_ACK	0x40	// pin 10 - switch 4 -		PRC sw3/6
#define PRT_NB		0x80	// pin 11 - switch 5 	*inverted*

// Printer Control Port

#define PRT_STRB	0x01	// pin 1
#define PRT_AUTO	0x02	// pin 14 *inverted*
#define PRT_INIT	0x04	// pin 16
#define PRT_SELI	0x08	// pin 17 *inverted*
#define PRT_IRQ	0x10	// IRQ enable - is this writable?

#define PRT_CTRL_IO 0x20	// input enable for parallel port - not possible

/****************************************************************************

   FUNCTION: XswcLptInit()

	DESCRIPTION:
		Initialize the particular hardware device structures and variables.
		Any global initialization of resources will have to be done based
		on some version of a reference counter

****************************************************************************/

BOOL XswcLptInit( HSWITCHDEVICE hsd )
	{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );		

	g_pGlobalData->osv.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	GetVersionEx( &g_pGlobalData->osv );

   g_pGlobalData->rgscLpt[uiDeviceNumber-1].u.Lpt = g_pGlobalData->scDefaultLpt;
	hLpt[uiDeviceNumber-1] = (HANDLE) 0;
	
	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcLptEnd

	DESCRIPTION:
		Free the resources for the given hardware port.
		We assume that if CloseHandle fails, the handle is
		invalid and/or already closed, so we zero it out anyways,
		and return TRUE for success.
		Global releases will need to be based on a reference counter.

****************************************************************************/

BOOL XswcLptEnd( HANDLE hsd )
	{
	BOOL bSuccess;

	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId) // Windows 95
		{
		bSuccess = swcLptEnd_Win( hsd );
		}
	else	// Windows NT
		{	
		bSuccess = swcLptEnd_NT( hsd );
		}

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: swcLptGetConfig()

	DESCRIPTION:

****************************************************************************/

BOOL swcLptGetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	
	*psc = g_pGlobalData->rgscLpt[uiDeviceNumber-1];
 	return TRUE;
	}


/****************************************************************************

   FUNCTION: XswcLptSetConfig

	DESCRIPTION:
		Activate/Deactivate the device.
		
		Four cases:
		1) hLpt = 0 and active = 0		- do nothing
		2)	hLpt = x and active = 1		- just set the configuration
		3) hLpt = 0 and active = 1		- activate and set the configuration
		4) hLpt = x and active = 0		- deactivate

		If there are no errors, TRUE is returned and ListSetConfig
		will write the configuration to the registry.
		If there is any error, FALSE is returned so the registry
		entry remains unchanged.

		Plug and Play can check the registry for SC_FLAG_ACTIVE and
		start up the device if it is set.

****************************************************************************/

BOOL XswcLptSetConfig(
	HSWITCHDEVICE	hsd,
	PSWITCHCONFIG	psc )
	{
	BOOL		bSuccess;
	BOOL		bJustOpened;
	UINT		uiDeviceNumber;
	HANDLE	*phLpt;
	PSWITCHCONFIG pscLpt;

	bSuccess = FALSE;
	bJustOpened = FALSE;

	// Simplify our code
	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phLpt = &hLpt[uiDeviceNumber-1];
	pscLpt = &g_pGlobalData->rgscLpt[uiDeviceNumber-1];
	
	// Should we activate?
	if (	(0==*phLpt)
		&&	(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{ // Yes
		*phLpt = XswcLptOpen( uiDeviceNumber );
		if (*phLpt)
			{ //OK
			bSuccess = TRUE;
			bJustOpened = TRUE;
			pscLpt->dwFlags |= SC_FLAG_ACTIVE;
			pscLpt->dwFlags &= ~SC_FLAG_UNAVAILABLE;
			}
		else
			{ // Not OK
			bSuccess = FALSE;
			pscLpt->dwFlags &= ~SC_FLAG_ACTIVE;
			pscLpt->dwFlags |= SC_FLAG_UNAVAILABLE;
			}
		}

	// Should we deactivate?
	else if (	(0!=*phLpt)
		&&	!(psc->dwFlags & SC_FLAG_ACTIVE)
		)
		{
		XswcLptEnd( hsd ); // This will also zero out *phLpt
		bSuccess = TRUE;
		pscLpt->dwFlags &= ~SC_FLAG_ACTIVE;
		}
	
	// If the above steps leave a valid hLpt, let's try setting the config
	if ( 0!=*phLpt )
		{
		if (psc->dwFlags & SC_FLAG_DEFAULT)
			{
			bSuccess = XswcLptSet( *phLpt, &g_pGlobalData->scDefaultLpt );
			if (bSuccess)
				{
				pscLpt->dwFlags |= SC_FLAG_DEFAULT;
            pscLpt->u.Lpt = g_pGlobalData->scDefaultLpt;
				}
			}
		else
			{
			bSuccess = XswcLptSet( *phLpt, &(psc->u.Lpt) );
			if (bSuccess)
				{
            pscLpt->u.Lpt = psc->u.Lpt;
				}
			}
		// If we can't set config and we just opened the port, better close it up.
		if (bJustOpened && !bSuccess)
			{
			XswcLptEnd( *phLpt );
			pscLpt->dwFlags &= ~SC_FLAG_ACTIVE;
			}
		}

	return bSuccess;
	}


/****************************************************************************

   FUNCTION: XswcLptPollStatus

	DESCRIPTION:
		Must be called in the context of the helper window.
****************************************************************************/

DWORD XswcLptPollStatus( HSWITCHDEVICE	hsd )
	{
	DWORD		dwNewStatus;
	UINT		uiDeviceNumber;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId)
		{
		dwNewStatus = swcLptStatus_Win( hsd );
		}
	else
		{
		dwNewStatus = swcLptStatus_NT( hsd );
		}

	g_pGlobalData->rgscLpt[uiDeviceNumber-1].dwSwitches = dwNewStatus;
	return dwNewStatus;
	}


/****************************************************************************

   FUNCTION: XswcLptOpen()

	DESCRIPTION:
		Opens a file handle to the particular lpt port, based on
		the 1-based nPort.
		
		If nPort is valid, this will automatically set up GetLastError().
****************************************************************************/

HANDLE XswcLptOpen( DWORD uiPort )
{
	HANDLE hLptPort;

	hLptPort = 0;
	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId) // Windows 95
	{
		hLptPort = swcLptOpen_Win( uiPort );
	}
	else	// Windows NT
	{
		hLptPort = swcLptOpen_NT( uiPort );
	}

	return hLptPort;
}


/****************************************************************************

   FUNCTION: XswcLptSet()

	DESCRIPTION:
		Sets the configuration of the particular nPort.
		Return FALSE (0) if an error occurs.
		GetLastError is automatically set up for us.
		
****************************************************************************/

BOOL XswcLptSet(
	HANDLE hLpt,
	PSWITCHCONFIG_LPT pC )
	{
	BOOL bSuccess;;
	if (VER_PLATFORM_WIN32_WINDOWS == g_pGlobalData->osv.dwPlatformId) // Windows 95
		{
		bSuccess = swcLptSet_Win( hLpt, pC );
		}
	else	// Windows NT
		{
		bSuccess = swcLptSet_NT( hLpt, pC );
		}
	return bSuccess;
	}


/***** Internal functions for Windows95 *****/

/****************************************************************************

   FUNCTION: swcLptOpen_Win()

	DESCRIPTION:
		Gets the base wInPort address for the given device, and
		increments by one to get the address for the "status in" port.
		
		This is cast into a HANDLE value for convenience.

		g_pGlobalData->rgbBiosDataArea has 7 entries of 2 bytes each.
		The first 4 are the com ports.
		The next 3 are the lpt ports.
****************************************************************************/

HANDLE swcLptOpen_Win( DWORD uiPort )
	{
	WORD wInPort = 0;

	switch (uiPort)
		{
		case 1:
		 	wInPort = (g_pGlobalData->rgbBiosDataArea[0x09] << 8)
				| (g_pGlobalData->rgbBiosDataArea[0x08] & 0x00FF);
			break;

		case 2:
		 	wInPort = (g_pGlobalData->rgbBiosDataArea[0x0B] << 8)
				| (g_pGlobalData->rgbBiosDataArea[0x0A] & 0x00FF);
			break;

		case 3:
		 	wInPort = (g_pGlobalData->rgbBiosDataArea[0x0D] << 8)
				| (g_pGlobalData->rgbBiosDataArea[0x0C] & 0x00FF);
			break;

		default:
			wInPort = 0;
			break;
		}

	if (wInPort)
		{
		wInPort += 1;	// Status In is base + 1;
		}
	return (HANDLE) wInPort;
	}


/****************************************************************************

   FUNCTION: swcLptEnd_Win()

	DESCRIPTION:
		Close the given lpt port.
		For Windows95, there is nothing to close, so just zero the port "handle"
		which is actually the wInPort address.
****************************************************************************/

BOOL swcLptEnd_Win( HANDLE hsd )
	{	
	BOOL bSuccess = TRUE;
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (hLpt[uiDeviceNumber-1])
		{
		hLpt[uiDeviceNumber-1] = 0;
		}
	g_pGlobalData->rgscLpt[uiDeviceNumber-1].dwSwitches = 0;

	// ignore bSuccess since we can't do anything anyways.
	return TRUE;
	}


/****************************************************************************

   FUNCTION: swcLptStatus_Win()

	DESCRIPTION:

****************************************************************************/

DWORD swcLptStatus_Win( HSWITCHDEVICE hsd )
	{
	UINT		uiDeviceNumber;
	DWORD		dwStatus;
	DWORD		dwLptStatus;
	WORD		wInPort;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	dwStatus = 0;

    // on a risc platform _inp() will not be defined, but since we should
    // not enter this code anyways, just #ifdef it so it will compile on
    // risc.

#if defined(_M_IX86) || defined(_X86_)

	wInPort = (WORD) hLpt[uiDeviceNumber-1];
	if (wInPort)
		{
		dwLptStatus = _inp( wInPort );	

		g_pGlobalData->wCurrByteData = (WORD)_inp( (USHORT)(wInPort-1) );	// save data for dbg
		g_pGlobalData->wPrtStatus = (WORD)dwLptStatus;
		g_pGlobalData->wCtrlStatus = (WORD)_inp( (USHORT)(wInPort+1) );

		dwStatus |= (dwLptStatus & PRT_SEL) ? 0 : SWITCH_1;
		dwStatus |= (dwLptStatus & PRT_PE ) ? 0 : SWITCH_2;
		dwStatus |= (dwLptStatus & PRT_ERR) ? 0 : SWITCH_3;
		dwStatus |= (dwLptStatus & PRT_ACK) ? 0 : SWITCH_4;
		dwStatus |= (dwLptStatus & PRT_NB ) ? SWITCH_5 : 0;
		}
#endif

	return dwStatus;
	}


/****************************************************************************

   FUNCTION: swcLptSet_Win()

	DESCRIPTION:

  The original intent was to activate the data lines to use as pullups,
  and whatever control lines were requested.
  Since we have so little control over this on the NT side, we are leaving
  this for future improvement if there is demand for it.

****************************************************************************/

BOOL swcLptSet_Win(
	HANDLE hLpt,
	PSWITCHCONFIG_LPT pC )
	{
	//WORD wInPort;
	BOOL bSuccess = TRUE;

	//	wInPort = (WORD) hLpt;
	//	_outp( (USHORT)(wInPort - 1), 0xFF );				// activate pull ups

	return bSuccess;
	}


/*****	Internal functions for WindowsNT *****/

/****************************************************************************

   FUNCTION: swcLptOpen_NT()

	DESCRIPTION:
	Open a file handle to the port.

	CreateFile will return no error for non-existant, valid ports,
	so we need to check the return from a DeviceIoControl to see if the device
	is available.

 ****************************************************************************/

HANDLE swcLptOpen_NT( DWORD uiPort )
	{
	BOOL		bSuccess;
	TCHAR		szLptPort[40];
	PAR_QUERY_INFORMATION ParQueryInfo;
	DWORD		dwBytesRet;
	HANDLE		hLptPort;

	wsprintf( szLptPort, _TEXT("\\\\.\\lpt%1.1d"), uiPort );
	
	// Use overlapped i/o in order for the Write operation to be asynchronous?
	hLptPort = CreateFile(
		szLptPort,
		GENERIC_WRITE,
		0, NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL //| FILE_FLAG_OVERLAPPED,
		,NULL );

	if (INVALID_HANDLE_VALUE != hLptPort)
		{
		bSuccess = DeviceIoControl(
				hLptPort,
				IOCTL_PAR_QUERY_INFORMATION,
				NULL, 0,
				&ParQueryInfo, sizeof(PAR_QUERY_INFORMATION),
				&dwBytesRet, NULL);

		if (!bSuccess)
			{
			CloseHandle( hLptPort );
			hLptPort = 0;
			}
		}
	else
		{
		hLptPort = 0;
		}

	return hLptPort;
	}


/****************************************************************************

   FUNCTION: swcLptEnd_NT()

	DESCRIPTION:
		Close the given lpt port.
****************************************************************************/

BOOL swcLptEnd_NT( HANDLE hsd )
	{
	BOOL bSuccess = TRUE;
	UINT uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );

	if (hLpt[uiDeviceNumber-1])
		{
		bSuccess = CloseHandle( hLpt[uiDeviceNumber-1] );
		hLpt[uiDeviceNumber-1] = 0;
		}
	g_pGlobalData->rgscLpt[uiDeviceNumber-1].dwSwitches = 0;

	// ignore bSuccess since we can't do anything anyways.
	return TRUE;
	}


/******************************************************************************
	FUNCTION: swcLptStatus_NT()

   DESCRIPTION:

  Under construction.

  For the "standard" passive box, we can read information on four of
  the five status lines, although two of them look the same.

  To read these more explicitly we will need to write a parallel port
  "class driver".
******************************************************************************/

DWORD swcLptStatus_NT( HSWITCHDEVICE hsd )
	{
	PAR_QUERY_INFORMATION Pqi;
	DWORD		dwNewStatus = 0;	// PREFIX 113794 init to default
	BOOL		bResult;
	DWORD		dwBytesRet;
	UINT		uiDeviceNumber;
	HANDLE		*phLpt;

	uiDeviceNumber  = swcListGetDeviceNumber( NULL, hsd );
	phLpt = &hLpt[uiDeviceNumber-1];

	if (*phLpt)
		{
		bResult = DeviceIoControl( *phLpt,
						  IOCTL_PAR_QUERY_INFORMATION,
						  NULL, 0,
						  &Pqi, sizeof(PAR_QUERY_INFORMATION),
						  &dwBytesRet, NULL);

		g_pGlobalData->wPrtStatus = Pqi.Status;
		dwNewStatus = 0;

		dwNewStatus |= (Pqi.Status & PARALLEL_SELECTED) ? 0 : SWITCH_1;

		// When nothing is pulled low, NT says the power is off
		// AND sets PAPER_EMPTY to zero (active).
		// So we need to check for PAPER_EMPTY active and no power off
		if (    !(Pqi.Status & PARALLEL_PAPER_EMPTY)
			  && !(Pqi.Status & PARALLEL_POWER_OFF )
			)
			dwNewStatus |= SWITCH_2;

		dwNewStatus |= (Pqi.Status & PARALLEL_BUSY ) ? 0 : SWITCH_3;

		// These don't work because they cannot be disambiguated
		//dwNewStatus |= (Pqi.Status & PRT_ERR) ? 0 : 0;//SWITCH_3;
		//dwNewStatus |= (Pqi.Status & PRT_ACK) ? 0 : 0;//SWITCH_4;
		//dwNewStatus |= (Pqi.Status & PARALLEL_BUSY ) ? 0 : SWITCH_5;
		}

	return dwNewStatus;
	}


/* This code is unused. It is here as sample code.
void set( HSWITCHDEVICE hsd )
	{
	PAR_SET_INFORMATION Psi;
	DWORD		dwBytesRet;
	UINT		uiDeviceNumber;
	HANDLE		*phLpt;
	BOOL		bResult;
	
	uiDeviceNumber  = swcListGetDeviceNumber( hsd );
	phLpt = &hLpt[uiDeviceNumber-1];

	// Set SelectIn high and AF high

	//Psi.Init = PARALLEL_INIT;
	//Psi.Init = PARALLEL_AUTOFEED;
	//Psi.Init = PARALLEL_OFF_LINE;
	//Psi.Init = PARALLEL_NOT_CONNECTED;
	//Psi.Init = Pqi.Status;
	// For output does this set SelectIn high or just the SLCT input?
	//Psi.Init = Psi.Init & ~PARALLEL_SELECTED;
	//Psi.Init = Psi.Init & ~PARALLEL_AUTOFEED;
	bResult = DeviceIoControl( *phLpt,
               IOCTL_PAR_SET_INFORMATION,
               &Psi, sizeof(PAR_SET_INFORMATION),
               NULL, 0,
               &dwBytesRet, NULL);
	}
*/
	
/****************************************************************************

	FUNCTION: swcLptSet_NT()

	DESCRIPTION:

	The intent is to write data to the port to use the data lines as
	pullups.

	We cannot write to the port if there is no printer attached, since
	the NT driver times out waiting for a valid printer status.
	We only have access to the INIT and AF lines for setting the
	control bits.

	So for now, ignore setup. We will have to depend on the "floating"
	property of TTL outputs to keep the status lines up.

    In the future, we may try to use a parallel port "class driver" to
	make this work.

****************************************************************************/

BOOL swcLptSet_NT(
	HANDLE hLpt,
	PSWITCHCONFIG_LPT pC )
	{
	//DWORD		dwBytesWritten;
	BOOL		bSuccess = TRUE;

	/*
	if (!WriteFile( hLpt, &PullUpBuff, 2, &dwBytesWritten,
		//&Overlapped
		NULL
		))
		{
		DBGERR( TEXT("lpt> WriteFile Error"), TRUE );
		}
	else
		{
		DBGMSG( TEXT("lpt> WriteFile Success bytes:%d\n"), dwBytesWritten );
		}
	*/
	return bSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswchx\version.h ===
s// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "msswchx\0"
#define VER_INTERNALNAME_STR        "msswchx\0"
#define VER_ORIGINALFILENAME_STR    "msswch.exe\0"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswchx\msswchx.c ===
/****************************************************************************
   Hidden 32-bit window for
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre
   
   This application performs several helper tasks:

   1) It owns any global resources (hooks, hardware devices) that are
      opened on behalf of applications using switch input

   2) It catches timer messages to keep polling the hardware devices

   3) In Windows 95 it receives the 16-bit bios table address information
      from the 16-bit hidden application and forwards it into the 
      32-bit world of the Switch Input Library

   If the window is not hidden on startup, it is in debug mode.
****************************************************************************/

/**************************************************************** Headers */

#include <windows.h>
#include <tchar.h>
#include "w95trace.c"
#include "msswch.h"
#include "resource.h"


// Types and pointer decls to DLL entry points

typedef BOOL (APIENTRY *LPFNXSWCHREGHELPERWND)( HWND hWnd, PBYTE bda );
typedef void (APIENTRY *LPFNXSWCHPOLLSWITCHES)( HWND hWnd );
typedef void (APIENTRY *LPFNXSWCHTIMERPROC)( HWND hWnd );
typedef LRESULT (APIENTRY *LPFNXSWCHSETSWITCHCONFIG)( WPARAM wParam, PCOPYDATASTRUCT pcd );
typedef BOOL (APIENTRY *LPFNXSWCHENDALL)( void );

LPFNXSWCHREGHELPERWND lpfnXswchRegHelperWnd;
LPFNXSWCHPOLLSWITCHES lpfnXswchPollSwitches;
LPFNXSWCHTIMERPROC lpfnXswchTimerProc;
LPFNXSWCHSETSWITCHCONFIG lpfnXswchSetSwitchConfig;
LPFNXSWCHENDALL lpfnXswchEndAll;

// Helper macro to get pointers to DLL entry points

#define GET_FUNC_PTR(name, ordinal, hlib, type, fUseDLL) \
{ \
	lpfn ## name = (type)GetProcAddress(hlib, LongToPtr(MAKELONG(ordinal, 0))); \
	if (!lpfn ## name) { \
		fUseDLL = FALSE; \
		ErrMessage(TEXT( #name ), IDS_PROC_NOT_FOUND, 0 ); \
	} \
}

static TCHAR x_szSwitchDll[] = TEXT("msswch.dll");
#define MAX_MSGLEN    256
#define SW_APPNAME    TEXT("msswchx")
#define SWITCH_TIMER_POLL_INTERVAL 0
#define MAJIC_CMDOPT  "SWCH"

// g_bios_data_area[] is a hold-over from Win9x code, unused in NT or W2K
#define BIOS_SIZE 16
BYTE g_bios_data_area[BIOS_SIZE];

INT_PTR APIENTRY SwchWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR APIENTRY WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
void SwitchOnCreate(HWND hWnd);
BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam);
BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam);
void SwitchOnTimer(HWND hWnd);
void SwitchOnPoll(HWND hWnd);
void SwitchOnEndSession(HWND hWnd);
void ErrMessage(LPCTSTR szTitle, UINT uMsg, UINT uFlags);

static BOOL AssignDesktop();
static BOOL InitMyProcessDesktopAccess(VOID);
static VOID ExitMyProcessDesktopAccess(VOID);

HINSTANCE  g_hInst = NULL;
HANDLE g_hLibrary = 0;

/********************************************************\
 Windows initialization
\********************************************************/

int PASCAL WinMain(
	HINSTANCE	hInstance,
	HINSTANCE   hPrevInstance,
	LPSTR	    lpszCmdLine,
	int		    nCmdShow )
{
	HWND		hWnd;
	MSG         msg;
	WNDCLASS	wndclass;

	// Look for magic word

	if (strcmp(lpszCmdLine, MAJIC_CMDOPT))
	{
		TCHAR szErrBuf[MAX_MSGLEN];
		if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszCmdLine, -1, szErrBuf, MAX_MSGLEN))
			ErrMessage( szErrBuf, IDS_NOT_USER_PROG, MB_OK | MB_ICONHAND );
		return FALSE;
	}

    //************************************************************************
    // 
    // The following two calls initialize the desktop so that, if we are on
    // the Winlogon desktop (secure desktop) our keyboard hook will be
    // associated with the correct window station. 
    //
    // Do not cause any windows to be created (eg. CoInitialize) prior to calling
    // these functions.  Doing so will cause them to fail and the application
    // will not appear on the Winlogon desktop.
    //
    InitMyProcessDesktopAccess();
    AssignDesktop();
    //************************************************************************

	if(!hPrevInstance) 
	{
		wndclass.style		= CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
		wndclass.lpfnWndProc	= WndProc;
		wndclass.cbClsExtra	= 0;
		wndclass.cbWndExtra	= 0;
		wndclass.hInstance	= hInstance;
		wndclass.hIcon		= NULL;
		wndclass.hCursor		= NULL;
		wndclass.hbrBackground	= GetStockObject(WHITE_BRUSH);
		wndclass.lpszMenuName	= NULL;
		wndclass.lpszClassName	= SW_APPNAME;

		if(!RegisterClass(&wndclass))
        {
            ExitMyProcessDesktopAccess();
			return FALSE;
        }
	}

    g_hInst=hInstance;

	hWnd = CreateWindow(SW_APPNAME, SW_APPNAME,
					WS_OVERLAPPEDWINDOW,
					0,0,10,10,
					NULL, NULL, hInstance, NULL);

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	while(GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
    ExitMyProcessDesktopAccess();

	return (int)msg.wParam;
}

/********************************************************\
 Main window procedure
\********************************************************/

INT_PTR APIENTRY WndProc(
	HWND	hWnd,
	UINT	uMsg,
	WPARAM	wParam,
	LPARAM	lParam)
{
	switch(uMsg)
    {
		case WM_TIMER:
		SwitchOnTimer( hWnd );
		break;

		case WM_COPYDATA:
		return SwitchOnCopyData( wParam, lParam );
		break;
		
		case WM_CREATE:
        SwitchOnCreate( hWnd );
		break;
		
		case WM_CLOSE:
		DestroyWindow( hWnd );
		break;

		case WM_QUERYENDSESSION:
		return 1L;
        break;

		case WM_DESTROY:
		PostQuitMessage(0);
        // intentional fall-thru to hit clean-up code

		case WM_ENDSESSION:
        SwitchOnEndSession( hWnd );
		break;

		default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;
	}
    return 0L;
}

void SwitchOnCreate(HWND hWnd)
{
	SetErrorMode(SEM_FAILCRITICALERRORS);	/* Bypass Windows error message */
	g_hLibrary = LoadLibrary( x_szSwitchDll );
	SetErrorMode(0);

	if (g_hLibrary)
	{
		BOOL fUseDLL = TRUE;

		GET_FUNC_PTR(XswchRegHelperWnd, 4, g_hLibrary, LPFNXSWCHREGHELPERWND, fUseDLL)
		GET_FUNC_PTR(XswchPollSwitches, 3, g_hLibrary, LPFNXSWCHPOLLSWITCHES, fUseDLL)
		GET_FUNC_PTR(XswchTimerProc, 6, g_hLibrary, LPFNXSWCHTIMERPROC, fUseDLL)
		GET_FUNC_PTR(XswchSetSwitchConfig, 5, g_hLibrary, LPFNXSWCHSETSWITCHCONFIG, fUseDLL)
		GET_FUNC_PTR(XswchEndAll, 2, g_hLibrary, LPFNXSWCHENDALL, fUseDLL)

		if (fUseDLL)
		{
            // register OSK's hWnd as switch resource owner
			(*lpfnXswchRegHelperWnd)( hWnd, g_bios_data_area );
            // send WM_TIMER messages to poll for switch activity
			SetTimer( hWnd, SWITCH_TIMER, SWITCH_TIMER_POLL_INTERVAL, NULL );
		}
	}
	else
	{
		FreeLibrary( g_hLibrary );
        g_hLibrary = 0;
		ErrMessage(NULL, IDS_MSSWCH_DLL_NOT_FOUND, 0 );
	}
}

void SwitchOnEndSession(HWND hWnd)
{
	if (g_hLibrary)
	{
		KillTimer( hWnd, SWITCH_TIMER );
		(*lpfnXswchEndAll)( );
		FreeLibrary( g_hLibrary );
        g_hLibrary = 0;
	}
}

void SwitchOnTimer(HWND hWnd)
{
	if (g_hLibrary)
	{
        (*lpfnXswchTimerProc)( hWnd );
    }
}

void SwitchOnPoll(HWND hWnd)
{
	if (g_hLibrary)
	{
		(*lpfnXswchPollSwitches)( hWnd );
    }
}

BOOL SwitchOnCopyData(WPARAM wParam, LPARAM lParam)
{
	if (g_hLibrary)
	{
        LRESULT rv = (*lpfnXswchSetSwitchConfig)( wParam, (PCOPYDATASTRUCT)lParam );
        return (rv == SWCHERR_NO_ERROR)?TRUE:FALSE;
    }
    return FALSE;
}

void ErrMessage(LPCTSTR szTitle, UINT uMsg, UINT uFlags)
{
    TCHAR szMessage[MAX_MSGLEN];
    TCHAR szTitle2[MAX_MSGLEN];
    LPCTSTR psz = szTitle;

    if (!psz)
        psz = x_szSwitchDll;
    
    LoadString(g_hInst, uMsg, szMessage, MAX_MSGLEN);

    MessageBox(GetFocus(), szMessage, psz, uFlags);
}

static HWINSTA g_origWinStation = NULL;
static HWINSTA g_userWinStation = NULL;
static BOOL  AssignDesktop()
{
    HDESK hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
    }

    CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
    SetThreadDesktop(hdesk);
    return TRUE;
}

static BOOL InitMyProcessDesktopAccess(VOID)
{
  g_origWinStation = GetProcessWindowStation();
  g_userWinStation = OpenWindowStation(__TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
  if (!g_userWinStation)
      return FALSE;

  SetProcessWindowStation(g_userWinStation);
  return TRUE;
}

static VOID ExitMyProcessDesktopAccess(VOID)
{
  if (g_origWinStation)
    SetProcessWindowStation(g_origWinStation);

  if (g_userWinStation)
  {
    CloseWindowStation(g_userWinStation);
    g_userWinStation = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\msswch\msswchy\msswchy.c ===
/****************************************************************************
   Hidden 16-bit window for
   Switch Input Library DLL

   Copyright (c) 1992-1997 Bloorview MacMillan Centre
   
   This mini-application reports the 16-bit bios table address information
   back to the 32-bit world of the Switch Input Library
****************************************************************************/

//#define DEBUGMSG
/**************************************************************** Headers */

#include <windows.h>
#include <dde.h>
#include <memory.h>

#define APIENTRY FAR PASCAL

long APIENTRY WndProc( HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam );
   
char  szAppName[]       = "MSSWCHY";

int   nShow;      // if Debug this will be SHOW
BYTE  bios_data_area[16];
HANDLE   hData;
DDEDATA FAR *pdata;

extern WORD _0040h;

#ifdef DEBUGMSG
char  szDbgMsg[80];
#endif

/********************************************* Windows Callback Functions */

   /********************************************************\
    Windows initialization
   \********************************************************/

int PASCAL WinMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
   HANDLE   hInstance, hPrevInstance;
   LPSTR    lpszCmdLine;
   int      nCmdShow;
   {
   HWND     hWnd;
   MSG      msg;
   WNDCLASS wndclass;


   // Look for magic word

   if (
         ( lpszCmdLine[0] != 'S' )
      || ( lpszCmdLine[1] != 'W' )
      || ( lpszCmdLine[2] != 'C' )
      || ( lpszCmdLine[3] != 'H' )
      )
      {
      MessageBox( GetFocus(), "This is not a user program", "MSSWCHY",
         MB_OK | MB_ICONHAND );
      return FALSE;
      }

   if(!hPrevInstance) 
      {
      wndclass.style    = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
      wndclass.lpfnWndProc = WndProc;
      wndclass.cbClsExtra  = 0;
      wndclass.cbWndExtra  = 0;
      wndclass.hInstance   = hInstance;
      wndclass.hIcon    = NULL;
      wndclass.hCursor     = NULL;
      wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
      wndclass.lpszMenuName   = NULL;
      wndclass.lpszClassName  = szAppName;

      if(!RegisterClass(&wndclass))
         return FALSE;
      }

   hWnd = CreateWindow(szAppName, szAppName,
               WS_OVERLAPPEDWINDOW,
               0,0,10,10,
               NULL, NULL, hInstance, NULL);

   nShow = nCmdShow;
   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   while(GetMessage(&msg, NULL, 0, 0))
      {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
      }

   return msg.wParam;
   }

   /********************************************************\
    Main window procedure
   \********************************************************/

long APIENTRY WndProc(HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam)
   {
   #ifdef xDEBUGMSG
   sprintf( szDbgMsg, "MP Msg: %X %X %lX\r\n", iMessage, wParam, lParam );
   OutputDebugString( szDbgMsg );
   #endif

   switch(uMsg)
      {
      case WM_CREATE:
         {
         HWND hSwchx;
         
         hSwchx = FindWindow( "MSSWCHX", NULL );
         _fmemcpy( bios_data_area,
          (LPSTR)(MAKELONG(0,&_0040h)),
           sizeof( bios_data_area ) );
         
         hData = GlobalAlloc( GMEM_DDESHARE, sizeof( DDEDATA ) + sizeof( bios_data_area ));
         if (hData)
            {
            pdata = (DDEDATA FAR *) GlobalLock( hData );
            pdata->fResponse =  TRUE;
            pdata->fRelease = FALSE;
            pdata->fAckReq = FALSE;
            pdata->cfFormat = CF_OWNERDISPLAY;
            _fmemcpy( pdata->Value, bios_data_area, sizeof( bios_data_area ) );
            GlobalUnlock( hData );
            
            PostMessage( hSwchx, WM_DDE_DATA, hWnd, MAKELONG( hData, 0 ));
            }
         }
         break;
         
      case WM_DDE_ACK:
         {
         if (hData)
            GlobalFree( hData );
         if (nShow != SW_SHOW)
            PostMessage( hWnd, WM_CLOSE, 0, 0L );
         }
            break;
            
      case WM_PAINT: // should only happen in debug mode
         {
         PAINTSTRUCT ps;
         char  szOutBuff[100];
         int i;

         BeginPaint( hWnd, &ps );
         i = 0;
         wsprintf( szOutBuff, "Bios Data Area" );
         TextOut( ps.hdc,0,10 * i,szOutBuff,lstrlen(szOutBuff));
      
         for ( i=0;i<8;i++ )
            {// note reversed pairs
            wsprintf( szOutBuff, "Port%d: %02X %02X", i,
             bios_data_area[2*i+1], bios_data_area[2*i] );
            TextOut( ps.hdc,0,30 + 30 * i,szOutBuff,lstrlen(szOutBuff));
            }
         EndPaint( hWnd, &ps );
         }
         break;
      
      case WM_CLOSE:
      case WM_QUERYENDSESSION:

         if (uMsg == WM_QUERYENDSESSION)
            return 1L;
         else
            DestroyWindow( hWnd );

         break;

      /* Window has just been closed   */
      case WM_DESTROY:

         PostQuitMessage(0);

      case WM_ENDSESSION:
         if (!uParam && (uMsg == WM_ENDSESSION))      /* Windows is not terminating */
            break;
         /* else continue */

         break;

      default:
         return DefWindowProc(hWnd, uMsg, uParam, lParam);
      }
   return 0L;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\credits.c ===
// Credit.c
#define STRICT

#include <windows.h>
#include "Init_End.h"
#include "resource.h"

#include "credits.h"


/***************************************************/
/* Startup procedure for modal dialog box */
/***************************************************/

INT_PTR CreditsDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) 
{
    INT_PTR  ReturnValue;
    TCHAR    str[256]=TEXT("");
    TCHAR    title[256]=TEXT("");

    ReturnValue = DialogBox(hInst,  MAKEINTRESOURCE(IDD_CREDITS), 
                            hWnd, CreditsDlgProc);

    if (ReturnValue==-1)
    {
        LoadString(hInst, IDS_CANNOTCREATEDLG, &str[0], 256);
        LoadString(hInst, IDS_CREDITSBOX, &title[0], 256);
        MessageBox(hWnd, str, title, MB_OK|MB_ICONHAND);
    }
    return ReturnValue;
}


/*****************************************************************************/
/* Modal dialog box procedure */
/*****************************************************************************/

INT_PTR CALLBACK CreditsDlgProc(HWND hDlg, UINT message, 
                                WPARAM wParam, LPARAM lParam)
{	
    switch(message)
    {
        case WM_INITDIALOG:
            return CreditsDlgDefault(hDlg,message,wParam,lParam);
            break;


        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    if (!CreditsDlgDefault(hDlg,message,wParam,lParam))
                    { 	
                        EndDialog(hDlg,IDOK);
				    }
					  
                    break;

				case IDCANCEL:
						EndDialog(hDlg,IDCANCEL);
					 break; 


				default:
					  return CreditsDlgDefault(hDlg,message,wParam,lParam);
					  break;
					 }
		  default:
		  return CreditsDlgDefault(hDlg,message,wParam,lParam);
		  break;
		}
	 return TRUE;/* Did process the message */
}


/***************************************************************/

BOOL CreditsDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{	
		
	 switch(message)
		  {
		  case WM_INITDIALOG:

		  return TRUE;       /* TRUE means Windows will process WM_INITDIALOG */
		  break;

		  case WM_COMMAND:
				switch(wParam)
					 {

				default:
					  return FALSE; /* Didn't process the message */
					  break;
					 }
				break;

		  case WM_DRAWITEM:      /* Draw graphic button(s)     */
				{
				LPDRAWITEMSTRUCT lpDrawItem;

				lpDrawItem = (LPDRAWITEMSTRUCT)lParam;
				if (lpDrawItem->CtlType!=ODT_BUTTON)
					 return FALSE;
				if (lpDrawItem->itemAction!=ODA_DRAWENTIRE)
					 return FALSE;
				switch(lpDrawItem->CtlID)
					 {

				default:
					  return FALSE; /* Didn't process the message */
					  break;
					 }
				}
				break;

		  default:
				return FALSE; /* Didn't process the message */
				break;
		  }
	 return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\dgsett.c ===
// dgSetting.c
// Copyright (c) 1997-1999 Microsoft Corporation
// KBMAIN.C 
// Additions, Bug Fixes 1999 Anil Kumar

#define STRICT

#include <windows.h>
#include <winnt.h>
#include <stdio.h>
#include <tchar.h>

#include "kbmain.h"
#include "resource.h"
#include "kbus.h"
#include "osk.h"
#include "commctrl.h"
#include "w95trace.h"

#define  REDRAW     TRUE
#define  NREDRAW    FALSE

/****************************************************************************/
/*    FUNCTIONS IN THIS FILE			                                    */
/****************************************************************************/
#include "dgsett.h"

/******************************************/
//    Functions in other file
/******************************************/
#include "kbfunc.h"
#include "scan.h"
#include "sdgutil.h"
#include "dgadvsca.h"
#include "Init_End.h"

/******************************************************************************/

__inline int SendMessageInt(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return (int)SendMessage(hWnd, uMsg, wParam, lParam);
}

BOOL DwellSel=0;
BOOL ScanSel=0;

int GetComboItemData(HWND hwnd);
void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iIncr, int iSelVal, LPTSTR pszLabel);
void SelNearestComboItem(HWND hwnd, int iFindVal);

extern float g_KBC_length;
extern DWORD GetDesktop();

LPTSTR CvtToDblString(int iVal)
{
    static TCHAR szbuf2[30];
    TCHAR szbuf[30];

    // first create non-localized string
    wsprintf(szbuf, TEXT("%d.%d"), iVal/1000, (iVal%1000)/100);

    // convert to localized the number
    if (!GetNumberFormat(LOCALE_USER_DEFAULT, 0, szbuf, NULL, szbuf2, ARRAY_SIZE(szbuf2)))
        lstrcpy(szbuf2, szbuf); // do the best we can

    return szbuf2;
}

void EnableDwellCtrls(HWND hDlg, BOOL fEnable)
{
    CheckDlgButton(hDlg, chk_Dwell, (fEnable)?BST_CHECKED:BST_UNCHECKED);
    EnableWindow(GetDlgItem(hDlg, IDC_HOVER_DESC), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CMB_DWELL), fEnable);
    if (!fEnable)
        SendMessage(GetDlgItem(hDlg, IDC_CMB_DWELL), CB_SETCURSEL, -1, 0);
}

void EnableScanCtrls(HWND hDlg, BOOL fEnable)
{
    CheckDlgButton(hDlg, chk_Scan, (fEnable)?BST_CHECKED:BST_UNCHECKED);
    EnableWindow(GetDlgItem(hDlg, IDC_SCAN_DESC), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CMB_SCAN), fEnable);
    if (!fEnable)
        SendMessage(GetDlgItem(hDlg, IDC_CMB_SCAN), CB_SETCURSEL, -1, 0);
	EnableWindow(GetDlgItem(hDlg, BUT_ADVANCED), fEnable);
}

/******************************************************************************/
/* Typing Mode
/******************************************************************************/
INT_PTR Type_ModeDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ReturnValue;

    ReturnValue = DialogBox(hInst, MAKEINTRESOURCE(DLG_TYPE_MODE),
                            NULL, Type_ModeDlgProc);

    if (ReturnValue==-1)
    {
        SendErrorMessage(IDS_CANNOTCREATEDLG);
    }
    return ReturnValue;
}

/******************************************************************************/
INT_PTR CALLBACK Type_ModeDlgProc(HWND hDlg, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{	
    TCHAR		buf[50];
    int         cch;
	TCHAR		filename[MAX_PATH]=TEXT("");
	LPHELPINFO	lphi;
	DWORD		m_dwHelpMap[] ={
		chk_Click,	        IDH_OSK_CLICK_MODE,
		chk_Dwell,	        IDH_OSK_DWELL_MODE,
		IDC_HOVER_DESC,     IDH_OSK_DWELL_TIME,
        IDC_CMB_DWELL,      IDH_OSK_DWELL_TIME,
		chk_Scan,	        IDH_OSK_SCAN_MODE,
		IDC_SCAN_DESC,      IDH_OSK_SCAN_TIME,
        IDC_CMB_SCAN,       IDH_OSK_SCAN_TIME,
        IDOK,               IDH_OSK_OK,
        IDCANCEL,           IDH_OSK_CANCEL,
		BUT_ADVANCED,       IDH_ADVANCED,
	};


	switch(message)
    {
        case WM_INITDIALOG:
			RelocateDialog(hDlg);

			KillScanTimer(TRUE);  //kill scanning

            // set up the combo box info

            cch = LoadString(hInst, IDS_SECONDS, buf, ARRAY_SIZE(buf));
            if (!cch) lstrcpy(buf, TEXT("Error!"));
            FillAndSetCombo(GetDlgItem(hDlg, IDC_CMB_DWELL), 500, 3000, 500, PrefDwellTime, buf);
            FillAndSetCombo(GetDlgItem(hDlg, IDC_CMB_SCAN), 500, 3000, 500, PrefScanTime, buf);

			// enable dwell info?

            DwellSel = PrefDwellinkey;
			if(DwellSel)
            {
                EnableDwellCtrls(hDlg, TRUE);
                EnableScanCtrls(hDlg, FALSE);
            }

			// enable scan info?
			
            ScanSel = PrefScanning;
			if (ScanSel)
            {
                EnableDwellCtrls(hDlg, FALSE);
                EnableScanCtrls(hDlg, TRUE);
            }

			//Check the Click check box?

			if (!DwellSel && !ScanSel)
            {
				CheckDlgButton(hDlg, chk_Click, BST_CHECKED);
                EnableDwellCtrls(hDlg, FALSE);
                EnableScanCtrls(hDlg, FALSE);
            } else
            {
				CheckDlgButton(hDlg, chk_Click, BST_UNCHECKED);
            }
    		return TRUE;
		break;


		case WM_HELP:
			if ( !OSKRunSecure() )
            {
			    lphi = (LPHELPINFO) lParam;

			    if(lphi->iContextType == HELPINFO_WINDOW)
                {
                    TCHAR szPath[MAX_PATH+9] = TEXT(""); // add some for szHelpFile
                    TCHAR szHelpFile[] = TEXT("\\OSK.hlp");

                    GetSystemWindowsDirectory(szPath, MAX_PATH);

                    if (szPath[0]) 
                    {
                        // skip over leading backslash in text string if at root
                        int cchLen = lstrlen(szPath) - 1;
                        int cchShift = (szPath[cchLen] == TEXT('\\')) ? 1 : 0;
                        lstrcat(szPath, szHelpFile + cchShift);
                    } else 
                    {
                        // no windows directory?
                        lstrcpy(szPath, szHelpFile + 1);
                    }

				    WinHelp((HWND)lphi->hItemHandle, szPath,  HELP_WM_HELP
                                , (DWORD_PTR)m_dwHelpMap);
                }
		        return TRUE;
            }
			return FALSE;
		break;

		case WM_CONTEXTMENU:
			if ( !OSKRunSecure() )
            {
                TCHAR szPath[MAX_PATH+9] = TEXT(""); // add some for szHelpFile
                TCHAR szHelpFile[] = TEXT("\\OSK.hlp");

                GetSystemWindowsDirectory(szPath, MAX_PATH);

                if (szPath[0]) 
                {
                    // skip over leading backslash in text string if at root
                    int cchLen = lstrlen(szPath) - 1;
                    int cchShift = (szPath[cchLen] == TEXT('\\')) ? 1 : 0;
                    lstrcat(szPath, szHelpFile + cchShift);
                } else 
                {
                    // no windows directory?
                    lstrcpy(szPath, szHelpFile + 1);
                }

                WinHelp((HWND)wParam, szHelpFile,  HELP_CONTEXTMENU,
                        (DWORD_PTR)m_dwHelpMap);

		        return TRUE;
            }
			return FALSE;
		break;

		case WM_COMMAND:
            switch LOWORD(wParam)
            {
            case IDOK:
			    kbPref->PrefDwellinkey = PrefDwellinkey = DwellSel;
                kbPref->PrefScanning = PrefScanning = ScanSel;
				if (DwellSel)
				{
                    kbPref->PrefDwellTime = PrefDwellTime 
                        = GetComboItemData(GetDlgItem(hDlg, IDC_CMB_DWELL));
                }

                if (ScanSel)
				{
				    kbPref->PrefScanning = PrefScanning = TRUE;
				 	kbPref->PrefScanTime = PrefScanTime 
                        = GetComboItemData(GetDlgItem(hDlg, IDC_CMB_SCAN));

					Prefhilitekey = FALSE;   // stop hilighting when the mouse moves

					// If we have Switch key check, then config the Switch key
					if(kbPref->bKBKey)
						ConfigSwitchKey(kbPref->uKBKey, TRUE);  //Turn on the key

					// If we have Switch port check, then config the Switch port
					if(kbPref->bPort)
						ConfigPort(TRUE);  //Turn on the port
                } else
                {
				    kbPref->PrefScanning = PrefScanning = FALSE;

                    Prefhilitekey = TRUE;   // start hilighting when the mouse moves

					// Disable scan key, in case it is set
					ConfigSwitchKey(0, FALSE);

					// Disable serial, lpt, game port from scanning
					ConfigPort(FALSE);
                }

				EndDialog(hDlg,IDOK);
			break;

			case IDCANCEL:
				EndDialog(hDlg,IDCANCEL);
			break;

			case chk_Click:    // Using click mode. Disable both Dwell and Scanning
				CheckDlgButton(hDlg, chk_Click, BST_CHECKED);

				//Disable Dwelling
				DwellSel = FALSE;
                EnableDwellCtrls(hDlg, FALSE);

				//Disable Scanning
				ScanSel = FALSE;
                EnableScanCtrls(hDlg, FALSE);
			break;

			case chk_Dwell:
				DwellSel = !DwellSel;

				CheckDlgButton(hDlg, chk_Click, BST_UNCHECKED);

				if (DwellSel)
				{
                    SelNearestComboItem(GetDlgItem(hDlg, IDC_CMB_DWELL), PrefDwellTime);
                    EnableDwellCtrls(hDlg, TRUE);

					// Disable Scanning
					ScanSel = FALSE;
                    EnableScanCtrls(hDlg, FALSE);
				}
			break;

			case chk_Scan:
				ScanSel = !ScanSel;
				
				CheckDlgButton(hDlg, chk_Click, BST_UNCHECKED);
				
				if (ScanSel)
				{
                    SelNearestComboItem(GetDlgItem(hDlg, IDC_CMB_SCAN), PrefScanTime);
                    EnableScanCtrls(hDlg, TRUE);

					// Disable Dwelling			
					DwellSel = FALSE;
                    EnableDwellCtrls(hDlg, FALSE);
				}
			break;

			case BUT_ADVANCED:
				AdvScanDlgFunc(hDlg, 0, (WPARAM)NULL, (LPARAM)NULL);
			break;

			default:
			    return FALSE;
            break;
			}   // switch LOWORD(wParam)

		    return TRUE;
	    break;

	default:
		return FALSE;
	}

	return TRUE;

}

void SwitchToNewLayout()
{
    int i;
	RECT KBC_rect;

    // destroy the current key windows

	InvalidateRect(g_hwndOSK, NULL, TRUE);

	for (i = 1; i < lenKBkey; i++)
    {
		DestroyWindow(lpkeyhwnd[i]);
    }

	// RegisterWndClass depends on the key types so update them before

	InitKeys();
	UpdateKeyLabels(GetCurrentHKL());

	RegisterWndClass(hInst);

    // tell the main window to recreate the key windows

	SendMessage(g_hwndOSK, WM_CREATE, 0L, 0L);

	//Since we want the same key size, but smaller (2/3) of the KB.
	//We need to increase the KB size by 3/2. -12 because we need little bit bigger than 3/2

	GetClientRect(g_hwndOSK, &KBC_rect);
	g_KBC_length = (float)KBC_rect.right * 3 / 2 - 12;

    // tell the main window to resize

	SendMessage(g_hwndOSK, WM_SIZE, 0L, 0L);

	RedrawNumLock();	// highlight the NUMLOCK key if it is on
	RedrawScrollLock();	// highlight the Scroll Key if it is on
}

/******************************************************************************/
void SwitchToBlockKB(void)
{	
    UninitKeys();
	BlockKB();
    SwitchToNewLayout();
}
/****************************************************************************/
void SwitchToActualKB(void)
{	
    UninitKeys();
	ActualKB();
    SwitchToNewLayout();
}

/**************************************************************************/
void SwitchToJapaneseKB(void)
{	
    UninitKeys();
	JapaneseKB();
    SwitchToNewLayout();
}
/**************************************************************************/
void SwitchToEuropeanKB(void)
{	
    UninitKeys();
	EuropeanKB();
    SwitchToNewLayout();
}

/**************************************************************************/
//Construct the Block layout structure
/**************************************************************************/
void BlockKB(void)
{
    KBkeyRec KBkey2[]= {
	

//0
    {TEXT(""),      TEXT(""),       TEXT(""),       TEXT(""),
     NO_NAME, 0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},    //DUMMY

//1
    {TEXT("esc"),   TEXT("esc"),    TEXT("{esc}"),  TEXT("{esc}"),
     NO_NAME, 1,1,8,9, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

//2
    {TEXT("F1"),    TEXT("F1"),     TEXT("{f1}"),   TEXT("{f1}"),
     NO_NAME, 1,11,8,9,FALSE,KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},	

//3
    {TEXT("F2"),    TEXT("F2"),     TEXT("{f2}"),   TEXT("{f2}"),
     NO_NAME, 1,21,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

//4
    {TEXT("F3"),    TEXT("F3"),     TEXT("{f3}"),   TEXT("{f3}"),
     NO_NAME, 1,31,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

//5
    {TEXT("F4"),    TEXT("F4"),     TEXT("{f4}"),   TEXT("{f4}"),
     NO_NAME, 1,41,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},


//6
    {TEXT("F5"),    TEXT("F5"),     TEXT("{f5}"),   TEXT("{f5}"),
     NO_NAME, 1,52,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

//7
    {TEXT("F6"),    TEXT("F6"),     TEXT("{f6}"),   TEXT("{f6}"),
     NO_NAME, 1,62,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

//8
    {TEXT("F7"),    TEXT("F7"),     TEXT("{f7}"),   TEXT("{f7}"),
     NO_NAME, 1,72,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

//9
    {TEXT("F8"),    TEXT("F8"),     TEXT("{f8}"),   TEXT("{f8}"),
     NO_NAME, 1,82,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},

//10
    {TEXT("F9"),    TEXT("F9"), 	TEXT("{f9}"),	TEXT("{f9}"),
     NO_NAME,1,103,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

//11
    {TEXT("F10"),	TEXT("F10"),   TEXT("{f10}"),	TEXT("{f10}"),
     KB_LALT,1,113,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

//12
    {TEXT("F11"),	TEXT("F11"),   TEXT("{f11}"),	TEXT("{f11}"),
     NO_NAME,1,123,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

//13
    {TEXT("F12"),	TEXT("F12"),   TEXT("{f12}"),	TEXT("{f12}"),
     NO_NAME,1,133,8,9,FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},


//14
    {TEXT("psc"),   TEXT("psc"),   TEXT("{PRTSC}"), TEXT("{PRTSC}"),
     KB_PSC,1,153,8,9, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

//15
    {TEXT("slk"), TEXT("slk"),TEXT("{SCROLLOCK}"),TEXT("{SCROLLOCK}"),
     KB_SCROLL, 1,163,8,9, TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

//16
    {TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME, 1,173,8,9, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},

//17
    {TEXT("pup"), TEXT("pup"), TEXT("{PGUP}"), TEXT("{PGUP}"),
     NO_NAME, 1,183,8,9, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x49,0x00,0x00}},

//18
    {TEXT("pdn"), TEXT("pdn"), TEXT("{PGDN}"), TEXT("{PGDN}"),
     NO_NAME, 1,193,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x51,0x00,0x00}},


//19
	{TEXT("`"), TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

//20
    {TEXT("1"),	TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,11,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

//21
    {TEXT("2"), TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,21,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

//22
    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME, 12,31,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

//23
    {TEXT("4"),	TEXT("$"), TEXT("4"), TEXT("$"),
     NO_NAME, 12,41,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x05,0x00,0x00,0x00}},

//24	
    {TEXT("5"),	TEXT("%"), TEXT("5"), TEXT("{%}"),
     NO_NAME, 12,52,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x06,0x00,0x00,0x00}},

//25
    {TEXT("6"),	TEXT("^"), TEXT("6"), TEXT("{^}"),
     NO_NAME, 12,62,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x07,0x00,0x00,0x00}},

//26
	{TEXT("7"),	TEXT("&"), TEXT("7"), TEXT("&"),
     NO_NAME, 12,72,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x08,0x00,0x00,0x00}},

//27
    {TEXT("8"), TEXT("*"), TEXT("8"), TEXT("*"),
     NO_NAME, 12,82,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x09,0x00,0x00,0x00}},

//28
    {TEXT("9"),	TEXT("("), TEXT("9"), TEXT("("),
     NO_NAME, 12,92,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0A,0x00,0x00,0x00}},
	
//29
    {TEXT("0"),	TEXT(")"), TEXT("0"), TEXT(")"),
     NO_NAME, 12,103,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0B,0x00,0x00,0x00}},

//30
    {TEXT("-"), TEXT("_"), TEXT("-"), TEXT("_"),
     NO_NAME, 12,113,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0C,0x00,0x00,0x00}},

//31
    {TEXT("="),	TEXT("+"), TEXT("="), TEXT("{+}"),
     NO_NAME, 12,123,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0D,0x00,0x00,0x00}},

//32
     //Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

//33
    {TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME, 12,133,8,18, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},

//34
    {TEXT("nlk"), TEXT("nlk"), TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),	
     KB_NUMLOCK, 12,153,8,9, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x45,0x00,0x00,0x00}},

//35
	{TEXT("/"),		TEXT("/"),		TEXT("/"),		TEXT("/"),	
	NO_NAME,	 12,	 163,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, 
	 {0xE0,0x35,0x00,0x00}},
	
//36	
	{TEXT("*"),		TEXT("*"),		TEXT("*"),		TEXT("*"),	
	NO_NAME,	 12,	 173,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, 
	 {0xE0,0x37,0x00,0x00}},

//37	
	{TEXT("-"),		TEXT("-"),		TEXT("-"),		TEXT("-"),	
	NO_NAME,	 12,	 183,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1, 
	 {0x4A,0x00,0x00,0x00}},

//38
    {TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"),
     NO_NAME, 12,193,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x52,0x00,0x00}},




//39
	{TEXT("tab"),	TEXT("tab"),	TEXT("{TAB}"),	TEXT("{TAB}"),			
	NO_NAME,	 21,	   1,	  8,	19, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, 
	{0x0F,0x00,0x00,0x00}},
	
//40	
	{TEXT("q"),		TEXT("Q"),		TEXT("q"),		TEXT("+q"),		
	NO_NAME,	 21,	  21,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x10,0x00,0x00,0x00}},
	
//41
	{TEXT("w"),		TEXT("W"),		TEXT("w"),		TEXT("+w"),		
	NO_NAME,	 21,	  31,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x11,0x00,0x00,0x00}},
	
//42	
	{TEXT("e"),		TEXT("E"),		TEXT("e"),		TEXT("+e"),		
	NO_NAME,	 21,	  41,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, 
	REDRAW, 1, {0x12,0x00,0x00,0x00}},

//43
	{TEXT("r"),		TEXT("R"),		TEXT("r"),		TEXT("+r"),		
	NO_NAME,	 21,	  52,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, 
	REDRAW, 1, {0x13,0x00,0x00,0x00}},
	
//44
	{TEXT("t"),		TEXT("T"),		TEXT("t"),		TEXT("+t"),		
	NO_NAME,	 21,	  62,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x14,0x00,0x00,0x00}},
	
//45
	{TEXT("y"),		TEXT("Y"),		TEXT("y"),		TEXT("+y"),		
	NO_NAME,	 21,	  72,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x15,0x00,0x00,0x00}},

//46	
	{TEXT("u"),		TEXT("U"),		TEXT("u"),		TEXT("+u"),		
	NO_NAME,	 21,	  82,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x16,0x00,0x00,0x00}},

//47
	{TEXT("i"),		TEXT("I"),		TEXT("i"),		TEXT("+i"),		
	NO_NAME,	 21,	  92,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x17,0x00,0x00,0x00}},
	
//48
	{TEXT("o"),		TEXT("O"),		TEXT("o"),		TEXT("+o"),		
	NO_NAME,	 21,	 103,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x18,0x00,0x00,0x00}},
	
//49
	{TEXT("p"),		TEXT("P"),		TEXT("p"),		TEXT("+p"),		
	NO_NAME,	 21,	 113,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x19,0x00,0x00,0x00}},

//50
	{TEXT("["),		TEXT("{"),		TEXT("["),		TEXT("{{}"),		
	NO_NAME,	 21,	 123,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, 
	{0x1A,0x00,0x00,0x00}},

//51
	{TEXT("]"),		TEXT("}"),		TEXT("]"),		TEXT("{}}"),		NO_NAME,	 21,	 133,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1B,0x00,0x00,0x00}},

//52
	{TEXT("\\"),	TEXT("|"),		TEXT("\\"),		TEXT("|"),			NO_NAME,	 21,	 143,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

//53
	{TEXT("7"),		TEXT("7"),		TEXT("7"),		TEXT("7"),		NO_NAME,	 21,	 153,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x47,0x00,0x00,0x00}},

//54	
	{TEXT("8"),		TEXT("8"),		TEXT("8"),		TEXT("8"),		NO_NAME,	 21,	 163,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x48,0x00,0x00,0x00}},

//55
	{TEXT("9"),		TEXT("9"),		TEXT("9"),		TEXT("9"),		NO_NAME,	 21,	 173,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x49,0x00,0x00,0x00}},

//56	
	{TEXT("+"),		TEXT("+"),		TEXT("{+}"),  	TEXT("{+}"),		NO_NAME,	 21,	 183,	  8,	 9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x4E,0x00,0x00,0x00}},

//57	
	{TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"), 				NO_NAME,	 21,	 193,	  8,	 8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x47,0x00,0x00}},




//58
	{TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),		KB_CAPLOCK,	  30,	   1,	  8,	19,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2, {0x3A,0x00,0x00,0x00}},

//59
	{TEXT("a"),		TEXT("A"),		TEXT("a"),		TEXT("+a"),	NO_NAME,	  30,	  21,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1E,0x00,0x00,0x00}},

//60
	{TEXT("s"),		TEXT("S"),		TEXT("s"),		TEXT("+s"),	NO_NAME,	  30,	  31,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1F,0x00,0x00,0x00}},

//61	
	{TEXT("d"),		TEXT("D"),		TEXT("d"),		TEXT("+d"),	NO_NAME,	  30,	  41,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x20,0x00,0x00,0x00}},

//62
	{TEXT("f"),		TEXT("F"),		TEXT("f"),		TEXT("+f"),	NO_NAME,	  30,	  52,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x21,0x00,0x00,0x00}},

//63
	{TEXT("g"),		TEXT("G"),		TEXT("g"),		TEXT("+g"),	NO_NAME,	  30,	  62,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x22,0x00,0x00,0x00}},

//64	
	{TEXT("h"),		TEXT("H"),		TEXT("h"),		TEXT("+h"),	NO_NAME,	  30,	  72,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x23,0x00,0x00,0x00}},

//65
	{TEXT("j"),		TEXT("J"),		TEXT("j"),		TEXT("+j"),	NO_NAME,	  30,	  82,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x24,0x00,0x00,0x00}},

//66	
	{TEXT("k"),		TEXT("K"),		TEXT("k"),		TEXT("+k"),	NO_NAME,	  30,	  92,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x25,0x00,0x00,0x00}},

//67
	{TEXT("l"),		TEXT("L"),		TEXT("l"),		TEXT("+l"),	NO_NAME,	  30,	 103,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x26,0x00,0x00,0x00}},

//68
	{TEXT(";"),		TEXT(":"),		TEXT(";"),		TEXT("+;"),	NO_NAME,	  30,	 113,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x27,0x00,0x00,0x00}},

//69	
	{TEXT("'"),		TEXT("''"),		TEXT("'"),		TEXT("''"),	NO_NAME,	  30,	 123,	  8,	 9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x28,0x00,0x00,0x00}},

//70
//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},	

//71
	{TEXT("ent"),	   TEXT("ent"), TEXT("{enter}"),   TEXT("{enter}"),	NO_NAME,	  30,	 133,	  8,     18, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, {0x1C,0x00,0x00,0x00}},


//72
    {TEXT("4"),	TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,153,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

//73
    {TEXT("5"),	TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,163,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

//74
    {TEXT("6"), TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,173,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},

//75
    {TEXT("del"), TEXT("del"), TEXT("{DEL}"), TEXT("{DEL}"),
     NO_NAME, 30,183,8,9,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x53,0x00,0x00}},

//76
    {TEXT("end"), TEXT("end"), TEXT("{END}"), TEXT("{END}"),
     NO_NAME, 30,193,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x4F,0x00,0x00}},


//77
    {TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,19, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

//78
    {TEXT("z"),	TEXT("Z"), TEXT("z"), TEXT("+z"),
     NO_NAME, 39,21,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2C,0x00,0x00,0x00}},

//79
    {TEXT("x"), TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,31,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

//80
    {TEXT("c"), TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},


//81
    {TEXT("v"), TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,52,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

//82
    {TEXT("b"),	TEXT("B"), TEXT("b"), TEXT("+b"),
     NO_NAME, 39,62,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

//83
    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME, 39,72,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

//84
    {TEXT("m"), TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,82,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

//85
    {TEXT(","), TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,92,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},


//86
    {TEXT("."),	TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,103,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x34,0x00,0x00,0x00}},

//87
    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,113,8,9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},

//88
     //Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//89
    {TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_RSHIFT, 39,123,8,28, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


//90
    {TEXT("1"),	TEXT("1"), TEXT("1"), TEXT("1"),
     NO_NAME, 39,153,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

//91
    {TEXT("2"),	TEXT("2"), TEXT("2"), TEXT("2"),
     NO_NAME, 39,163,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

//92
	{TEXT("3"),	TEXT("3"), TEXT("3"), TEXT("3"),
     NO_NAME, 39,173,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

//93
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 39,183,8,9, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//94
    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 39,193,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},


//95
    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_LCTR, 48,1,8,19,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

//96
    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("lwin"),	
     ICON, 48,21,8,9,TRUE, KMODIFIER_TYPE, BOTH, NREDRAW},

//97
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_LALT, 48,31,8,19,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//98
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,52,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//99
    {TEXT(""),  TEXT(""),   TEXT(" "),  TEXT(" "),
     KB_SPACE, 48,52,8,49, FALSE, KNORMAL_TYPE, LARGE, NREDRAW,  1,
     {0x39,0x00,0x00,0x00}},

	
//100	
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//101
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


//102
    {TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,103,8,9, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//103
    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("rwin"),
     ICON, 48,113,8,9,	TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

//104
    {TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,123,8,9,	TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

//105
    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_RCTR, 48,133,8,18, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


//106
    {TEXT("0"),	TEXT("0"), TEXT("0"), TEXT("0"),
     NO_NAME, 48,153,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

//107
    {TEXT("."),	TEXT("."), TEXT("."), TEXT("."),
     NO_NAME, 48,163,8,9, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},

//108
    {TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 48,173,8,9,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},

//109
    {TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,183,8,9, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//110
    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,193,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


//111
	{TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE, 48,52,8,39, FALSE, KNORMAL_TYPE, SMALL, REDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//112
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,92,8,9, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//113
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,103,8,9, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},

//114
	{TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,113,8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//115
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,123,8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//116
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,133,8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//117
	{TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,143,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};

	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));
}

/**************************************************************************/
//Contract the Actual KB layout structure
/**************************************************************************/
void ActualKB(void)
{
	KBkeyRec	KBkey2[]=
	{
	//0
    {TEXT(""), TEXT(""), TEXT(""), TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //to be investigated??????

    {TEXT("esc"), TEXT("esc"), TEXT("{esc}"), TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},


    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},


    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

    {TEXT("F10"), TEXT("F10"), TEXT("{f10}"), TEXT("{f10}"),
     KB_LALT, 1,110,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

    {TEXT("F11"), TEXT("F11"), TEXT("{f11}"), TEXT("{f11}"),
     NO_NAME, 1,119,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

    {TEXT("F12"), TEXT("F12"), TEXT("{f12}"), TEXT("{f12}"),
     NO_NAME, 1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},


    {TEXT("psc"), TEXT("psc"), TEXT("{PRTSC}"), TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

    {TEXT("slk"), TEXT("slk"), TEXT("{SCROLLOCK}"), TEXT("{SCROLLOCK}"),
     KB_SCROLL, 1,147,8, 8,  TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

    {TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME, 1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},


    //17
    {TEXT("`"),	TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME, 12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

    {TEXT("4"),	TEXT("$"), TEXT("4"), TEXT("$"),
     NO_NAME, 12,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x05,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("%"), TEXT("5"), TEXT("{%}"),
     NO_NAME, 12,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x06,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("^"), TEXT("6"), TEXT("{^}"),
     NO_NAME, 12,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x07,0x00,0x00,0x00}},

    {TEXT("7"), TEXT("&"), TEXT("7"), TEXT("&"),
     NO_NAME, 12,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x08,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("*"), TEXT("8"), TEXT("*"),
     NO_NAME, 12,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x09,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("("), TEXT("9"), TEXT("("),
     NO_NAME, 12,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0A,0x00,0x00,0x00}},

    {TEXT("0"),	TEXT(")"), TEXT("0"), TEXT(")"),
     NO_NAME, 12,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0B,0x00,0x00,0x00}},

    {TEXT("-"), TEXT("_"), TEXT("-"), TEXT("_"),
     NO_NAME, 12,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0C,0x00,0x00,0x00}},

    {TEXT("="),	TEXT("+"), TEXT("="), TEXT("{+}"),
     NO_NAME, 12,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0D,0x00,0x00,0x00}},


//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


    {TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME, 12,118,8,18,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},


    {TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"),
     NO_NAME, 12,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x52,0x00,0x00}},

    {TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"),
     NO_NAME, 12,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x47,0x00,0x00}},

    {TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),
     NO_NAME, 12,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x49,0x00,0x00}},


    {TEXT("nlk"),TEXT("nlk"),TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),
     KB_NUMLOCK, 12,166,8,8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x45,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("/"), TEXT("/"), TEXT("/"),
     NO_NAME, 12,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x35,0x00,0x00}},

    {TEXT("*"),	TEXT("*"), TEXT("*"), TEXT("*"),
     NO_NAME, 12,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x37,0x00,0x00}},

    {TEXT("-"),	TEXT("-"), TEXT("-"), TEXT("-"),
     NO_NAME, 12,193,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
    {0x4A,0x00,0x00,0x00}},


	//38
    {TEXT("tab"), TEXT("tab"), TEXT("{TAB}"), TEXT("{TAB}"),
     NO_NAME, 21,1,8,13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0F,0x00,0x00,0x00}},

    {TEXT("q"),	TEXT("Q"), TEXT("q"), TEXT("+q"),
     NO_NAME, 21,15,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x10,0x00,0x00,0x00}},

    {TEXT("w"),	TEXT("W"), TEXT("w"), TEXT("+w"),
     NO_NAME, 21,24,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x11,0x00,0x00,0x00}},

    {TEXT("e"),	TEXT("E"), TEXT("e"), TEXT("+e"),
     NO_NAME, 21,33,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x12,0x00,0x00,0x00}},

    {TEXT("r"),	TEXT("R"), TEXT("r"), TEXT("+r"),
     NO_NAME, 21,42,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x13,0x00,0x00,0x00}},

    {TEXT("t"),	TEXT("T"), TEXT("t"), TEXT("+t"),
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

    {TEXT("y"),	TEXT("Y"), TEXT("y"), TEXT("+y"),
     NO_NAME, 21,60,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x15,0x00,0x00,0x00}},

    {TEXT("u"),	TEXT("U"), TEXT("u"), TEXT("+u"),
     NO_NAME, 21,69,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x16,0x00,0x00,0x00}},

    {TEXT("i"),	TEXT("I"), TEXT("i"), TEXT("+i"),
     NO_NAME, 21,78,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x17,0x00,0x00,0x00}},

    {TEXT("o"),	TEXT("O"), TEXT("o"), TEXT("+o"),
     NO_NAME, 21,87,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x18,0x00,0x00,0x00}},

    {TEXT("p"),	TEXT("P"), TEXT("p"), TEXT("+p"),
     NO_NAME, 21,96,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x19,0x00,0x00,0x00}},

    {TEXT("["),	TEXT("{"), TEXT("["), TEXT("{{}"),
     NO_NAME, 21,105,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1A,0x00,0x00,0x00}},

    {TEXT("]"),	TEXT("}"), TEXT("]"), TEXT("{}}"),
     NO_NAME, 21,114,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1B,0x00,0x00,0x00}},

    {TEXT("\\"), TEXT("|"),	TEXT("\\"),	TEXT("|"),
     NO_NAME, 21,123,8,13, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2B,0x00,0x00,0x00}},


    {TEXT("del"), TEXT("del"), TEXT("{DEL}"), TEXT("{DEL}"),
     NO_NAME, 21,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x53,0x00,0x00}},

    {TEXT("end"), TEXT("end"), TEXT("{END}"), TEXT("{END}"),
     NO_NAME, 21,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x4F,0x00,0x00}},

    {TEXT("pdn"), TEXT("pdn"), TEXT("{PGDN}"),TEXT("{PGDN}"),
     NO_NAME, 21,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x51,0x00,0x00}},


    {TEXT("7"),	TEXT("7"), TEXT("7"), TEXT("7"),
     NO_NAME, 21,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x47,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("8"), TEXT("8"), TEXT("8"),
     NO_NAME, 21,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x48,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("9"), TEXT("9"), TEXT("9"),
     NO_NAME, 21,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x49,0x00,0x00,0x00}},

    {TEXT("+"),	TEXT("+"), TEXT("{+}"), TEXT("{+}"),
     NO_NAME, 21,193,17,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4E,0x00,0x00,0x00}},


	//59
    {TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),
     KB_CAPLOCK, 30,1,8,17, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x3A,0x00,0x00,0x00}},

    {TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

    {TEXT("s"),	TEXT("S"), TEXT("s"), TEXT("+s"),
     NO_NAME, 30,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1F,0x00,0x00,0x00}},

    {TEXT("d"),	TEXT("D"), TEXT("d"), TEXT("+d"),
     NO_NAME, 30,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x20,0x00,0x00,0x00}},

    {TEXT("f"), TEXT("F"), TEXT("f"), TEXT("+f"),
     NO_NAME, 30,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x21,0x00,0x00,0x00}},

    {TEXT("g"),	TEXT("G"), TEXT("g"), TEXT("+g"),
     NO_NAME, 30,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x22,0x00,0x00,0x00}},

    {TEXT("h"), TEXT("H"), TEXT("h"), TEXT("+h"),
     NO_NAME, 30,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x23,0x00,0x00,0x00}},

    {TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x24,0x00,0x00,0x00}},

    {TEXT("k"),	TEXT("K"), TEXT("k"), TEXT("+k"),
     NO_NAME, 30,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x25,0x00,0x00,0x00}},

    {TEXT("l"),	TEXT("L"), TEXT("l"), TEXT("+l"),
     NO_NAME, 30,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x26,0x00,0x00,0x00}},

    {TEXT(";"),	TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x27,0x00,0x00,0x00}},

    {TEXT("'"),	TEXT("''"),	TEXT("'"), TEXT("''"),
     NO_NAME, 30,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x28,0x00,0x00,0x00}},


//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),
     NO_NAME, 30,118,8,18, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x1C,0x00,0x00,0x00}},


    {TEXT("4"),	TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},

	//75
	{TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

    {TEXT("z"), TEXT("Z"), TEXT("z"), TEXT("+z"),
     NO_NAME, 39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x2C,0x00,0x00,0x00}},

    {TEXT("x"), TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

    {TEXT("c"),	TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

    {TEXT("v"),	TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

    {TEXT("b"), TEXT("B"), TEXT("b"), TEXT("+b"),
     NO_NAME, 39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME, 39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

    {TEXT("m"),	TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

    {TEXT("."),	TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x34,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},

     //Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

	{TEXT("shft"),  TEXT("shft"),   TEXT(""),   TEXT(""),
     KB_RSHIFT, 39,113,8,23, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


    // 87
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},


    {TEXT("1"), TEXT("1"), TEXT("1"), TEXT("1"),
     NO_NAME, 39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("2"), TEXT("2"), TEXT("2"),
     NO_NAME, 39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

    {TEXT("3"),	TEXT("3"), TEXT("3"), TEXT("3"),
     NO_NAME, 39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


	//92
    {TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

    {TEXT("alt"), TEXT("alt"),	TEXT(""), TEXT(""),
     KB_LALT, 48,24,8,13, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    //95
    {TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,48,38,8,52, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    {TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,91,8,13, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("rwin"),
     ICON, 48, 105 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48, 114 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_RCTR, 48,123,8,13, TRUE, KMODIFIER_TYPE,LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8, 8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


    {TEXT("0"), TEXT("0"), TEXT("0"), TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

    {TEXT("."),	TEXT("."), TEXT("."), TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},


    //105
    {TEXT(""),      TEXT(""),       TEXT(" "),  TEXT(" "),
     KB_SPACE, 48,38,8,38, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},


	{TEXT("alt"),   TEXT("alt"),    TEXT(""),   TEXT(""),
     KB_RALT, 48,77,8,13, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

	{TEXT("MenuKeyUp"),TEXT("MenuKeyDn"),TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

    {TEXT("IDB_DNUPARW"),TEXT("DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,127,8, 9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};
	
	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));
}


/***************************************************************************/
//Contract the Japanese KB layout structure
//Japanese KB the Enter is in different position then English KB
/***************************************************************************/
void JapaneseKB(void)
{
	KBkeyRec KBkey2[] = {
	
//0
    {TEXT(""),TEXT(""),	TEXT(""),TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //DUMMY

//1
    {TEXT("esc"),TEXT("esc"),TEXT("{esc}"),TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE,  KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

//2
    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

//3
    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

//4
    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

//5
    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},

//6
    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

//7
    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

//8
    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

//9
    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},


//10
    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

//11
    {TEXT("F10"),TEXT("F10"), TEXT("{f10}"),TEXT("{f10}"),
     KB_LALT,  1,110, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

//12
    {TEXT("F11"),TEXT("F11"), TEXT("{f11}"),TEXT("{f11}"),
     NO_NAME,  1,119, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

//13
    {TEXT("F12"),TEXT("F12"), TEXT("{f12}"),TEXT("{f12}"),
     NO_NAME,1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},

//14
    {TEXT("psc"), TEXT("psc"),TEXT("{PRTSC}"),TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

//15
    {TEXT("slk"), TEXT("slk"),TEXT("{SCROLLOCK}"),TEXT("{SCROLLOCK}"),
     KB_SCROLL,1,147,8, 8, TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

//16
	{TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME,1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},

//17
    {TEXT("IDB_KANJI"), TEXT("IDB_KANJI"), TEXT("IDB_KANJIB"), TEXT("{~}"),
     BITMAP, 12,1,8,8, FALSE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

//18
    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

//19
	{TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

//20
    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME,12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

//21
	{TEXT("4"),		TEXT("$"),		TEXT("4"),		TEXT("$"),		NO_NAME,	 12,	  37,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x05,0x00,0x00,0x00}},
	
//22
	{TEXT("5"), 	TEXT("%"), 		TEXT("5"),		TEXT("{%}"),	NO_NAME,	 12,	  46,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x06,0x00,0x00,0x00}},
	
//23	
	{TEXT("6"),		TEXT("^"),		TEXT("6"),		TEXT("{^}"),	NO_NAME,	 12,	  55,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x07,0x00,0x00,0x00}},
	
//24	
	{TEXT("7"),		TEXT("&"),		TEXT("7"),		TEXT("&"),		NO_NAME,	 12,	  64,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x08,0x00,0x00,0x00}},
	
//25	
	{TEXT("8"), 	TEXT("*"), 		TEXT("8"),		TEXT("*"),		NO_NAME,	 12,	  73,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x09,0x00,0x00,0x00}},
	
//26	
	{TEXT("9"),		TEXT("("),		TEXT("9"),		TEXT("("),		NO_NAME,	 12,	  82,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0A,0x00,0x00,0x00}},
	
//27
	{TEXT("0"),		TEXT(")"),		TEXT("0"),		TEXT(")"),		NO_NAME,	 12,	  91,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0B,0x00,0x00,0x00}},
	
//28	
	{TEXT("-"), 	TEXT("_"), 		TEXT("-"),		TEXT("_"),		NO_NAME,	 12,	 100,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0C,0x00,0x00,0x00}},
	
//29	
	{TEXT("="),		TEXT("+"),		TEXT("="),		TEXT("{+}"),	NO_NAME,	 12,	 109,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0D,0x00,0x00,0x00}},

//30
//Japanese KB extra key
	{TEXT("jp"),		TEXT("jp"),		TEXT("jp"),		TEXT("{jp}"),	NO_NAME,	 12,	 118,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x7D,0x00,0x00,0x00}},


//31
	{TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME,12, 127,8,9,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},

//32
	{TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"), NO_NAME, 12,138, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x52,0x00,0x00}},
	
//33	
	{TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"), 	NO_NAME, 12,147, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x47,0x00,0x00}},
	
//34	
	{TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),		NO_NAME, 12,156, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x49,0x00,0x00}},

//35
	{TEXT("nlk"),TEXT("nlk"),	TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),KB_NUMLOCK,12,166,  8,	 8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2, {0x45,0x00,0x00,0x00}},
	
//36
	{TEXT("/"),	TEXT("/"),	TEXT("/"),	TEXT("/"),	NO_NAME, 12, 175,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x35,0x00,0x00}},
	
//37
	{TEXT("*"),	TEXT("*"),	TEXT("*"),	TEXT("*"),	NO_NAME, 12, 184,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x37,0x00,0x00}},
	
//38	
	{TEXT("-"),	TEXT("-"),	TEXT("-"),	TEXT("-"),	NO_NAME, 12, 193,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1, {0x4A,0x00,0x00,0x00}},


//39
	{TEXT("tab"),	TEXT("tab"),	TEXT("{TAB}"),TEXT("{TAB}"),NO_NAME, 21,   1,  8,	13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, {0x0F,0x00,0x00,0x00}},

//40
	{TEXT("q"),	TEXT("Q"),	TEXT("q"),	TEXT("+q"),	NO_NAME, 21,  15,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x10,0x00,0x00,0x00}},

//41	
	{TEXT("w"),	TEXT("W"),	TEXT("w"),	TEXT("+w"),	NO_NAME, 21,  24,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x11,0x00,0x00,0x00}},
	
//42	
	{TEXT("e"),	TEXT("E"),	TEXT("e"),	TEXT("+e"),	NO_NAME, 21,  33,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x12,0x00,0x00,0x00}},
	
//43	
	 {TEXT("r"),	TEXT("R"),	TEXT("r"),	TEXT("+r"),	NO_NAME, 21,  42,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x13,0x00,0x00,0x00}},


//44
    {TEXT("t"),	TEXT("T"),	TEXT("t"),	TEXT("+t"),	
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

//45
	{TEXT("y"),	TEXT("Y"),	TEXT("y"),	TEXT("+y"),	NO_NAME, 21,  60,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x15,0x00,0x00,0x00}},

//46
	{TEXT("u"),	TEXT("U"),	TEXT("u"),	TEXT("+u"),	NO_NAME, 21,  69,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x16,0x00,0x00,0x00}},
	
//47	
	{TEXT("i"),	TEXT("I"),	TEXT("i"),	TEXT("+i"),	NO_NAME, 21,  78,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x17,0x00,0x00,0x00}},
	
//48	
	{TEXT("o"),	TEXT("O"),	TEXT("o"),	TEXT("+o"),	NO_NAME, 21,  87,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x18,0x00,0x00,0x00}},
	
//49	
	{TEXT("p"),	TEXT("P"),	TEXT("p"),	TEXT("+p"),	NO_NAME, 21,  96,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x19,0x00,0x00,0x00}},

//50	
	{TEXT("["),	TEXT("{"),	TEXT("["),	TEXT("{{}"),	NO_NAME, 21, 105,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1A,0x00,0x00,0x00}},

//51
	{TEXT("]"),	TEXT("}"),	TEXT("]"),	TEXT("{}}"),	NO_NAME, 21, 114,  8,	 12, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1B,0x00,0x00,0x00}},

//52	
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

//53	
// ***Japanese KB the ENTER key is in here whcih is different from English KB***
	{TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),	NO_NAME,  21,	 127,	  17,  9, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 2, {0x1C,0x00,0x00,0x00}},

//54
	{TEXT("del"), TEXT("del"), 	TEXT("{DEL}"),TEXT("{DEL}"),NO_NAME, 21,   138,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x53,0x00,0x00}},

//55
	{TEXT("end"),	TEXT("end"), 	TEXT("{END}"),TEXT("{END}"),NO_NAME, 21,   147,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x4F,0x00,0x00}},

//56
	{TEXT("pdn"), TEXT("pdn"), 	TEXT("{PGDN}"),TEXT("{PGDN}"),NO_NAME, 21, 156,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x51,0x00,0x00}},


//57
	{TEXT("7"),		TEXT("7"),		TEXT("7"),		TEXT("7"),		NO_NAME,	 21,	 166,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x47,0x00,0x00,0x00}},

//58
	{TEXT("8"),		TEXT("8"),		TEXT("8"),		TEXT("8"),		NO_NAME,	 21,	 175,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x48,0x00,0x00,0x00}},

//59
	{TEXT("9"),		TEXT("9"),		TEXT("9"),		TEXT("9"),		NO_NAME,	 21,	 184,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x49,0x00,0x00,0x00}},

//60	
	{TEXT("+"),		TEXT("+"),		TEXT("{+}"),  	TEXT("{+}"),	NO_NAME,	 21,	 193,	 17,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x4E,0x00,0x00,0x00}},

//61
    {TEXT("IDB_BITMAP7"),TEXT("IDB_BITMAP7"),TEXT("IDB_BITMAP9"),TEXT("CAPS"),
     BITMAP, 30,1,8,17, FALSE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x3A,0x00,0x00,0x00}},

//62
	{TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

//63
	{TEXT("s"),		TEXT("S"),		TEXT("s"),		TEXT("+s"),		NO_NAME,	  30,	  28,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1F,0x00,0x00,0x00}},

//64	
	{TEXT("d"),		TEXT("D"),		TEXT("d"),		TEXT("+d"),		NO_NAME,	  30,	  37,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x20,0x00,0x00,0x00}},

//65
	{TEXT("f"),		TEXT("F"),		TEXT("f"),		TEXT("+f"),		NO_NAME,	  30,	  46,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x21,0x00,0x00,0x00}},

//66
	{TEXT("g"),		TEXT("G"),		TEXT("g"),		TEXT("+g"),		NO_NAME,	  30,	  55,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x22,0x00,0x00,0x00}},

//67	
	{TEXT("h"),		TEXT("H"),		TEXT("h"),		TEXT("+h"),		NO_NAME,	  30,	  64,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x23,0x00,0x00,0x00}},

//68
    {TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x24,0x00,0x00,0x00}},

//69
	{TEXT("k"),		TEXT("K"),		TEXT("k"),		TEXT("+k"),		NO_NAME,	  30,	  82,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x25,0x00,0x00,0x00}},

//70
	{TEXT("l"),		TEXT("L"),		TEXT("l"),		TEXT("+l"),		NO_NAME,	  30,	  91,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x26,0x00,0x00,0x00}},

//71
	{TEXT(";"), TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x27,0x00,0x00,0x00}},

//72
	{TEXT("'"),		TEXT("''"),		TEXT("'"),		TEXT("''"),		NO_NAME,	  30,	 109,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x28,0x00,0x00,0x00}},
	
//73
//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 30, 118,  8,	8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x2B,0x00,0x00,0x00}},


//74
    {TEXT("4"), TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

//75
    {TEXT("5"),	TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

//76
    {TEXT("6"),	TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},


//77
	{TEXT("shft"),TEXT("shft"),	TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

//78
    {TEXT("z"), TEXT("Z"),  TEXT("z"),  TEXT("+z"),
     NO_NAME,39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2C,0x00,0x00,0x00}},

//79
    {TEXT("x"),	TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

//80
    {TEXT("c"), TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

//81
    {TEXT("v"), TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

//82
    {TEXT("b"),TEXT("B"),TEXT("b"),TEXT("+b"),
     NO_NAME,39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

//83
    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME,39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

//84
    {TEXT("m"), TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8,FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

//85
    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

//86
    {TEXT("."), TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x34,0x00,0x00,0x00}},

//87
    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},

//88
//Japanese KB extra key
    {TEXT("jp"),	TEXT("jp"), TEXT("jp"), TEXT("jp"),
     NO_NAME, 39,113,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x73,0x00,0x00,0x00}},

//89	
	{TEXT("shft"),TEXT("shft"),TEXT(""),TEXT(""),
     KB_RSHIFT,39,122,8,14,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


//90
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP,39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//91
	{TEXT("1"), TEXT("1"),TEXT("1"),TEXT("1"),
     NO_NAME,39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

//92
	{TEXT("2"), TEXT("2"),TEXT("2"),TEXT("2"),
     NO_NAME,39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

//93
	{TEXT("3"),TEXT("3"),TEXT("3"),TEXT("3"),
     NO_NAME,39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

//94
	{TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


//95
	{TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

//96
    {TEXT("winlogoUp"), TEXT("winlogoDn"),TEXT("I_winlogo"),TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

//97
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
	 KB_LALT,48,24,8,8,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//98
//Japanese KB extra key  NO COVERT
    {TEXT("IDB_MHENKAN"),TEXT("IDB_MHENKAN"),TEXT("IDB_MHENKANB"),TEXT("jp"),
	 BITMAP,48,33,8,8,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x7B,0x00,0x00,0x00}},

//99
    {TEXT(""),TEXT(""),TEXT(" "),TEXT(" "),
     KB_SPACE,48,42,8,35, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//100
//Japanese KB extra key   CONVERT
    {TEXT("IDB_HENKAN"),TEXT("IDB_HENKAN"),TEXT("IDB_HENKANB"),TEXT(""),
     BITMAP,48,78,8,8, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x79,0x00,0x00,0x00}},

//101
//Japanese KB extra key
    {TEXT("IDB_KANA"),TEXT("IDB_KANA"),TEXT("IDB_KANAB"),TEXT(""),
     BITMAP,48,87,8,8, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 1,
     {0x70,0x00,0x00,0x00}},

//102
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
     KB_RALT,48,96,8,8, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//103
	{TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"),TEXT("rwin"),
     ICON, 48,105,8,8,TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//104
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,114,8,8, TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//105
    {TEXT("ctrl"),TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_RCTR,48,123,8,13,TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},

//106
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//107
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//108
	{TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

//109
    {TEXT("0"),	TEXT("0"),	TEXT("0"),	TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

//110
    {TEXT("."),	TEXT("."),	TEXT("."),	TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},


//111
	{TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,  48,42,8,21, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//112
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT,  48,82,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//113
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


//114
	{TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//115
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//116
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//117
    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP,48,127, 8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};

	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));

	if(kbPref->smallKb)
	{	KBkey[100].posX = 64;
		KBkey[101].posX = 73;
	}
}
/**********************************************************************/
//Contract the EuropeanKB KB laout structure
/**********************************************************************/
void EuropeanKB(void)
{
	KBkeyRec	KBkey2[]=
	{
	//0
    {TEXT(""), TEXT(""), TEXT(""), TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //to be investigated??????

    {TEXT("esc"), TEXT("esc"), TEXT("{esc}"), TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},


    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},


    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

    {TEXT("F10"), TEXT("F10"), TEXT("{f10}"), TEXT("{f10}"),
     KB_LALT, 1,110,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

    {TEXT("F11"), TEXT("F11"), TEXT("{f11}"), TEXT("{f11}"),
     NO_NAME, 1,119,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

    {TEXT("F12"), TEXT("F12"), TEXT("{f12}"), TEXT("{f12}"),
     NO_NAME, 1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},


    {TEXT("psc"), TEXT("psc"), TEXT("{PRTSC}"), TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

    {TEXT("slk"), TEXT("slk"), TEXT("{SCROLLOCK}"), TEXT("{SCROLLOCK}"),
     KB_SCROLL, 1,147,8, 8,  TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

    {TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME, 1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x10,0x45,0x00}},


    //17
    {TEXT("`"),	TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME, 12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

    {TEXT("4"),	TEXT("$"), TEXT("4"), TEXT("$"),
     NO_NAME, 12,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x05,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("%"), TEXT("5"), TEXT("{%}"),
     NO_NAME, 12,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x06,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("^"), TEXT("6"), TEXT("{^}"),
     NO_NAME, 12,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x07,0x00,0x00,0x00}},

    {TEXT("7"), TEXT("&"), TEXT("7"), TEXT("&"),
     NO_NAME, 12,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x08,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("*"), TEXT("8"), TEXT("*"),
     NO_NAME, 12,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x09,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("("), TEXT("9"), TEXT("("),
     NO_NAME, 12,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0A,0x00,0x00,0x00}},

    {TEXT("0"),	TEXT(")"), TEXT("0"), TEXT(")"),
     NO_NAME, 12,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0B,0x00,0x00,0x00}},

    {TEXT("-"), TEXT("_"), TEXT("-"), TEXT("_"),
     NO_NAME, 12,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0C,0x00,0x00,0x00}},

    {TEXT("="),	TEXT("+"), TEXT("="), TEXT("{+}"),
     NO_NAME, 12,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x0D,0x00,0x00,0x00}},


//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY


    {TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME, 12,118,8,18,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},


    {TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"),
     NO_NAME, 12,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x52,0x00,0x00}},

    {TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"),
     NO_NAME, 12,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x47,0x00,0x00}},

    {TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),
     NO_NAME, 12,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x49,0x00,0x00}},


    {TEXT("nlk"),TEXT("nlk"),TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),
     KB_NUMLOCK, 12,166,8,8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x45,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("/"), TEXT("/"), TEXT("/"),
     NO_NAME, 12,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x35,0x00,0x00}},

    {TEXT("*"),	TEXT("*"), TEXT("*"), TEXT("*"),
     NO_NAME, 12,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x37,0x00,0x00}},

    {TEXT("-"),	TEXT("-"), TEXT("-"), TEXT("-"),
     NO_NAME, 12,193,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
    {0x4A,0x00,0x00,0x00}},


	//38
    {TEXT("tab"), TEXT("tab"), TEXT("{TAB}"), TEXT("{TAB}"),
     NO_NAME, 21,1,8,13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0F,0x00,0x00,0x00}},

    {TEXT("q"),	TEXT("Q"), TEXT("q"), TEXT("+q"),
     NO_NAME, 21,15,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x10,0x00,0x00,0x00}},

    {TEXT("w"),	TEXT("W"), TEXT("w"), TEXT("+w"),
     NO_NAME, 21,24,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x11,0x00,0x00,0x00}},

    {TEXT("e"),	TEXT("E"), TEXT("e"), TEXT("+e"),
     NO_NAME, 21,33,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x12,0x00,0x00,0x00}},

    {TEXT("r"),	TEXT("R"), TEXT("r"), TEXT("+r"),
     NO_NAME, 21,42,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x13,0x00,0x00,0x00}},

    {TEXT("t"),	TEXT("T"), TEXT("t"), TEXT("+t"),
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

    {TEXT("y"),	TEXT("Y"), TEXT("y"), TEXT("+y"),
     NO_NAME, 21,60,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x15,0x00,0x00,0x00}},

    {TEXT("u"),	TEXT("U"), TEXT("u"), TEXT("+u"),
     NO_NAME, 21,69,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x16,0x00,0x00,0x00}},

    {TEXT("i"),	TEXT("I"), TEXT("i"), TEXT("+i"),
     NO_NAME, 21,78,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x17,0x00,0x00,0x00}},

    {TEXT("o"),	TEXT("O"), TEXT("o"), TEXT("+o"),
     NO_NAME, 21,87,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x18,0x00,0x00,0x00}},

    {TEXT("p"),	TEXT("P"), TEXT("p"), TEXT("+p"),
     NO_NAME, 21,96,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x19,0x00,0x00,0x00}},

    {TEXT("["),	TEXT("{"), TEXT("["), TEXT("{{}"),
     NO_NAME, 21,105,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1A,0x00,0x00,0x00}},

    {TEXT("]"),	TEXT("}"), TEXT("]"), TEXT("{}}"),
     NO_NAME, 21,114,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1B,0x00,0x00,0x00}},

    {TEXT("\\"), TEXT("|"),	TEXT("\\"),	TEXT("|"),
     NO_NAME, 21,123,8,13, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2B,0x00,0x00,0x00}},


    {TEXT("del"), TEXT("del"), TEXT("{DEL}"), TEXT("{DEL}"),
     NO_NAME, 21,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x53,0x00,0x00}},

    {TEXT("end"), TEXT("end"), TEXT("{END}"), TEXT("{END}"),
     NO_NAME, 21,147,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x4F,0x00,0x00}},

    {TEXT("pdn"), TEXT("pdn"), TEXT("{PGDN}"),TEXT("{PGDN}"),
     NO_NAME, 21,156,8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x51,0x00,0x00}},


    {TEXT("7"),	TEXT("7"), TEXT("7"), TEXT("7"),
     NO_NAME, 21,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x47,0x00,0x00,0x00}},

    {TEXT("8"),	TEXT("8"), TEXT("8"), TEXT("8"),
     NO_NAME, 21,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x48,0x00,0x00,0x00}},

    {TEXT("9"),	TEXT("9"), TEXT("9"), TEXT("9"),
     NO_NAME, 21,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x49,0x00,0x00,0x00}},

    {TEXT("+"),	TEXT("+"), TEXT("{+}"), TEXT("{+}"),
     NO_NAME, 21,193,17,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4E,0x00,0x00,0x00}},


	//59
    {TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),
     KB_CAPLOCK, 30,1,8,17, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x3A,0x00,0x00,0x00}},

    {TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

    {TEXT("s"),	TEXT("S"), TEXT("s"), TEXT("+s"),
     NO_NAME, 30,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1F,0x00,0x00,0x00}},

    {TEXT("d"),	TEXT("D"), TEXT("d"), TEXT("+d"),
     NO_NAME, 30,37,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x20,0x00,0x00,0x00}},

    {TEXT("f"), TEXT("F"), TEXT("f"), TEXT("+f"),
     NO_NAME, 30,46,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x21,0x00,0x00,0x00}},

    {TEXT("g"),	TEXT("G"), TEXT("g"), TEXT("+g"),
     NO_NAME, 30,55,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x22,0x00,0x00,0x00}},

    {TEXT("h"), TEXT("H"), TEXT("h"), TEXT("+h"),
     NO_NAME, 30,64,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x23,0x00,0x00,0x00}},

    {TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x24,0x00,0x00,0x00}},

    {TEXT("k"),	TEXT("K"), TEXT("k"), TEXT("+k"),
     NO_NAME, 30,82,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x25,0x00,0x00,0x00}},

    {TEXT("l"),	TEXT("L"), TEXT("l"), TEXT("+l"),
     NO_NAME, 30,91,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x26,0x00,0x00,0x00}},

    {TEXT(";"),	TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x27,0x00,0x00,0x00}},

    {TEXT("'"),	TEXT("''"),	TEXT("'"), TEXT("''"),
     NO_NAME, 30,109,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x28,0x00,0x00,0x00}},


//Japanese KB extra key      //DUMMY
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),
     NO_NAME, 30,118,8,18, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x1C,0x00,0x00,0x00}},


    {TEXT("4"),	TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

    {TEXT("5"), TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

    {TEXT("6"), TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},
/*
	//75
	{TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},
*/

	//75
	{TEXT("shft"), TEXT("shft"), TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,12, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

     //Japanese KB extra key and also
	 //European KB extra key
    {TEXT("jp"),	TEXT("jp"), TEXT("jp"), TEXT("jp"),
     NO_NAME, 39,14,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x56,0x00,0x00,0x00}},

    {TEXT("z"), TEXT("Z"), TEXT("z"), TEXT("+z"),
     NO_NAME, 39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x2C,0x00,0x00,0x00}},

    {TEXT("x"), TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

    {TEXT("c"),	TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

    {TEXT("v"),	TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

    {TEXT("b"), TEXT("B"), TEXT("b"), TEXT("+b"),
     NO_NAME, 39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME, 39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

    {TEXT("m"),	TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

    {TEXT("."),	TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x34,0x00,0x00,0x00}},

    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},
/*
     //Japanese KB extra key and also
	 //European KB extra key
    {TEXT("jp"),	TEXT("jp"), TEXT("jp"), TEXT("jp"),
     NO_NAME, 39,113,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x56,0x00,0x00,0x00}},

	{TEXT("shft"),  TEXT("shft"),   TEXT(""),   TEXT(""),
     KB_RSHIFT, 39,122,8,14, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},
*/
	{TEXT("shft"),  TEXT("shft"),   TEXT(""),   TEXT(""),
     KB_RSHIFT, 39,113,8,23, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},

    // 87
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},


    {TEXT("1"), TEXT("1"), TEXT("1"), TEXT("1"),
     NO_NAME, 39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

    {TEXT("2"),	TEXT("2"), TEXT("2"), TEXT("2"),
     NO_NAME, 39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

    {TEXT("3"),	TEXT("3"), TEXT("3"), TEXT("3"),
     NO_NAME, 39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

    {TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


	//92
    {TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

    {TEXT("alt"), TEXT("alt"),	TEXT(""), TEXT(""),
     KB_LALT, 48,24,8,13, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    //95
    {TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,48,38,8,52, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW, NREDRAW},  //DUMMY

    {TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT, 48,91,8,13, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

    {TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"), TEXT("rwin"),
     ICON, 48, 105 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48, 114 ,8,8,TRUE, KMODIFIER_TYPE, LARGE, REDRAW},

    {TEXT("ctrl"), TEXT("ctrl"), TEXT(""), TEXT(""),
     KB_RCTR, 48,123,8,13, TRUE, KMODIFIER_TYPE,LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8, 8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


    {TEXT("0"), TEXT("0"), TEXT("0"), TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

    {TEXT("."),	TEXT("."), TEXT("."), TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},


    //105
    {TEXT(""),      TEXT(""),       TEXT(" "),  TEXT(" "),
     KB_SPACE, 48,38,8,38, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},


	{TEXT("alt"),   TEXT("alt"),    TEXT(""),   TEXT(""),
     KB_RALT, 48,77,8,13, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

	{TEXT("MenuKeyUp"),TEXT("MenuKeyDn"),TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

    {TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

    {TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,127,8, 9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};
	
	CopyMemory(KBkey, KBkey2, sizeof(KBkey2));

}

// Helper functions for combo boxes

int GetComboItemData(HWND hwnd)
{
    int iValue = CB_ERR;
    LRESULT iCurSel = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iCurSel != CB_ERR)
        iValue = SendMessageInt(hwnd, CB_GETITEMDATA, iCurSel, 0);

    return iValue;
}

void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iIncr, int iSelVal, LPTSTR pszLabel)
{
    int i;
    int iSelPos = -1;

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    for (i=0;iMaxVal >= iMinVal;i++)
    {
        TCHAR pszItem[100];
        int iPos;

        wsprintf(pszItem, TEXT("%s %s"), CvtToDblString(iMaxVal), pszLabel);
        iPos = SendMessageInt(hwnd, CB_ADDSTRING, 0, (LPARAM)pszItem);
        if (iPos != CB_ERR)
        {
            SendMessage(hwnd, CB_SETITEMDATA, iPos, iMaxVal);

            // This used to be finer granularity so 
            // iSelVal may be between two items
            if (iSelPos < 0 && iSelVal >= iMaxVal)
                iSelPos = iPos; // note the current selection
        }
        iMaxVal-=iIncr;
    }

    // show the current value
    SendMessage(hwnd, CB_SETCURSEL, iSelPos, 0);
}

void SelNearestComboItem(HWND hwnd, int iFindVal)
{
    int i;
    int iSelPos = -1;
    int cItems = SendMessageInt(hwnd, CB_GETCOUNT, 0, 0);
    // search thru item data of combo box for iFindVal
    // (allow finding values between items)
    for (i=0;i<cItems;i++)
    {
        int iItemData = SendMessageInt(hwnd, CB_GETITEMDATA, i, 0);
        if (iItemData != CB_ERR)
        {
            if (iFindVal >= iItemData)
            {
                iSelPos = i;
                break;
            }
        }
    }

    // show the current value
    SendMessage(hwnd, CB_SETCURSEL, iSelPos, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\init_end.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// Additions, Bug Fixes 1999 Anil

#define STRICT

#include <windows.h>
#include <winable.h>
#include "kbmain.h"
#include "Msswch.h"
#include "resource.h"
#include "htmlhelp.h"
#include "Init_End.h"
#include "kbus.h"
#include "dgsett.h"
#include "ms32dll.h"
#include "sdgutil.h"
#include "fileutil.h"
#include "kbfunc.h"
#include "about.h"
#include "w95trace.h"

/**************************************************************/
//      Global Vars
/**************************************************************/
HLOCAL				HkbPref  = NULL;
BOOL				KillTime = FALSE;
HSWITCHPORT	        g_hSwitchPort = NULL;
extern HWND			OpeningHwnd;
extern HINSTANCE	hInst;
extern float        g_KBC_length;
extern BOOL	        g_startUM;
extern KBkeyRec	    KBkey[];

extern DWORD GetDesktop();

/******************************************************************************/
void Create_The_Rest(LPSTR lpCmdLine, HINSTANCE hInstance)
{	
	// Opening the switch port initializes the msswch dll memory
	// mapped file so call it before calling RegisterHookSendWindow
	
	g_hSwitchPort = swchOpenSwitchPort( g_hwndOSK, PS_EVENTS );

	if(g_hSwitchPort == NULL)
    {
		SendErrorMessage(IDS_CANNOT_OPEN_SWPORT);
        return;
    }

	// RegisterHookSendWindow is new in Whistler and takes part of
	// the place of the old WH_JOURNALRECORD hook

    if (!RegisterHookSendWindow(g_hwndOSK, WM_GLOBAL_KBDHOOK))
	{	
		SendErrorMessage(IDS_JOURNAL_HOOK);
		SendMessage(g_hwndOSK, WM_DESTROY,0L,0L);  //destroy myself
		return;
	}

	//Config the scan key and port if the user has choosen these options
	if (kbPref->PrefScanning && kbPref->bKBKey)   //want switch key
		ConfigSwitchKey(kbPref->uKBKey, TRUE);
	else if (kbPref->PrefScanning)    //don't want switch key
		ConfigSwitchKey(0, FALSE);
    else if (kbPref->bPort)
        ConfigPort(TRUE);

}
/****************************************************************************/
/* void FinishProcess(void) */
/****************************************************************************/
void FinishProcess(void)
{	
	INPUT	rgInput[6];

    // Stop keyboard processing
    RegisterHookSendWindow(0, 0);

	// Close the Switch Port
	swchCloseSwitchPort(g_hSwitchPort);     

	KillTimer(g_hwndOSK, timerK1);           	// timer id
	KillTimer(g_hwndOSK,timerK2);				// timer for bucket

	// Send the shift, alt, ctrl key up message in case they still down
	//LSHIFT
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = VK_LSHIFT;
	rgInput[0].ki.wScan = 0x2A;

	//RSHIFT
	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = VK_RSHIFT;
	rgInput[1].ki.wScan = 0x36;

	//LMENU
	rgInput[2].type = INPUT_KEYBOARD;
	rgInput[2].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[2].ki.dwExtraInfo = 0;
	rgInput[2].ki.wVk = VK_LMENU;
	rgInput[2].ki.wScan = 0x38;

	//RMENU
	rgInput[3].type = INPUT_KEYBOARD;
	rgInput[3].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
	rgInput[3].ki.dwExtraInfo = 0;
	rgInput[3].ki.wVk = VK_RMENU;
	rgInput[3].ki.wScan = 0x38;

	//LCONTROL
	rgInput[4].type = INPUT_KEYBOARD;
	rgInput[4].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[4].ki.dwExtraInfo = 0;
	rgInput[4].ki.wVk = VK_LCONTROL;
	rgInput[4].ki.wScan = 0x1D;

	//RCONTROL
	rgInput[5].type = INPUT_KEYBOARD;
	rgInput[5].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
	rgInput[5].ki.dwExtraInfo = 0;
	rgInput[5].ki.wVk = VK_RCONTROL;
	rgInput[5].ki.wScan = 0x1D;

	SendInput(6, rgInput, sizeof(INPUT));

} // FinishProcess
/******************************************************************************/
//  Explaination how Large and Small KB switching:
//  All the keys are sizing according to the size of the KB window. So change 
//  from Large KB to Small KB and make the KB to (2/3) of the original but 
//  same key size. We need to set the KB size to (2/3) first. But use the original
//  KB client window length to calculate "colMargin" to get the same key size.									                                         
/******************************************************************************/
BOOL BLDMenuCommand(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	HMENU	hMenu=NULL;
	RECT KBW_rect;
	RECT KBC_rect;
	static BOOL isTypeDlg = FALSE;
	static BOOL isFontDlg = FALSE;
	static BOOL isAboutDlg = FALSE;

	hMenu= GetMenu(hWnd);

	switch(wParam)
	{
	
	case IDM_Exit:
		return(BLDExitApplication(hWnd));      // Clean up if necessary
		break;

	case IDM_ALWAYS_ON_TOP:
		PrefAlwaysontop = kbPref->PrefAlwaysontop = !kbPref->PrefAlwaysontop;
		SetZOrder();
		break;

	case IDM_CLICK_SOUND:
		Prefusesound = kbPref->Prefusesound = !kbPref->Prefusesound;
		break;

	case IDM_LARGE_KB:
		if ( !smallKb )
			break;
		smallKb = kbPref->smallKb = FALSE;

		//For the 106 KB, we need to fix the position for the two extra Japanese keys
		if(kbPref->KBLayout == 106)
		{
			KBkey[100].posX = 78;
			KBkey[101].posX = 87;
		}

		//see explaination
		GetWindowRect(g_hwndOSK, &KBW_rect);
		MoveWindow(g_hwndOSK, KBW_rect.left, KBW_rect.top, (KBW_rect.right - KBW_rect.left) * 3 / 2, KBW_rect.bottom - KBW_rect.top, TRUE);
		break;

	case IDM_SMALL_KB:
		if ( smallKb )
			break;
		smallKb = kbPref->smallKb = TRUE;

		//For the 106 KB, we need to fix the position for the two extra Japanese keys
		if(kbPref->KBLayout == 106)
		{
			KBkey[100].posX = 64;
			KBkey[101].posX = 73;
		}

		//see explaination
		GetWindowRect(g_hwndOSK, &KBW_rect);
		GetClientRect(g_hwndOSK, &KBC_rect);
		
		g_KBC_length = (float)KBC_rect.right;

		g_KBC_length -= 12;

		MoveWindow(g_hwndOSK, KBW_rect.left, KBW_rect.top, (KBW_rect.right - KBW_rect.left) * 2 /3, KBW_rect.bottom - KBW_rect.top, TRUE);
		break;

	case IDM_REGULAR_LAYOUT:
		kbPref->Actual = TRUE;
		SwitchToActualKB();
		kbPref->KBLayout = 101;
		break;

	case IDM_BLOCK_LAYOUT:
		kbPref->Actual = FALSE;
		SwitchToBlockKB();
		kbPref->KBLayout = 101;
		break;

	case IDM_101_LAYOUT:
		kbPref->Actual ? SwitchToActualKB(): SwitchToBlockKB();
		kbPref->KBLayout = 101;
		break;

	case IDM_102_LAYOUT:
		SwitchToEuropeanKB();
		kbPref->KBLayout = 102;
		break;

	case IDM_106_LAYOUT:
		SwitchToJapaneseKB();
		kbPref->KBLayout = 106;
		break;

	case IDM_TYPE_MODE:
		if ( !isTypeDlg )
		{
			isTypeDlg = TRUE;

			Type_ModeDlgFunc(hWnd, message, wParam, lParam);

			isTypeDlg = FALSE;
		}
		break;

    case IDM_SET_FONT:
		if ( OSKRunSecure() )
			return FALSE;

		if ( !isFontDlg )
		{
			isFontDlg = TRUE;
			ChooseNewFont(hWnd);
			isFontDlg = FALSE;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		break;

	case CM_HELPABOUT:
		if ( !isAboutDlg )
		{
			isAboutDlg = TRUE;
			AboutDlgFunc(hWnd, message, wParam, lParam);
			isAboutDlg = FALSE;
		}
		break;

	case CM_HELPTOPICS:
		if ( !OSKRunSecure() )
		{
            TCHAR szPath[MAX_PATH+14] = TEXT(""); // add some for szHelpFile
            TCHAR szHelpFile[] = TEXT("\\HELP\\OSK.CHM");

            GetSystemWindowsDirectory(szPath, MAX_PATH);

            if (szPath[0]) 
            {
                // skip over leading backslash in text string if at root
                int cchLen = lstrlen(szPath) - 1;
                int cchShift = (szPath[cchLen] == TEXT('\\')) ? 1 : 0;
                lstrcat(szPath, szHelpFile + cchShift);
            } else 
            {
                // no windows directory?
                lstrcpy(szPath, szHelpFile + 1);
            }

			HtmlHelp(NULL, szPath, HH_DISPLAY_TOPIC, 0);

		}
		break;

	default:
		return FALSE;   
	}
	
	return TRUE;     
}
/******************************************************************************/
/* Called just before exit of application  */
/******************************************************************************/
BOOL BLDExitApplication(HWND hWnd)
{  
	//Automatic save setting when quit
	SaveUserSetting();  

	SendMessage(hWnd, WM_DESTROY, (WPARAM) NULL, (LPARAM) NULL);
	return TRUE;
}
/***********************************************************************/
// Set the Serial, LPT, Game ports to ON or OFF
// according to bSet
/***********************************************************************/
void ConfigPort(BOOL bSet)
{
	SWITCHCONFIG	Config;
	HSWITCHDEVICE	hsd;
	BOOL            fRv;

	//Set the Com port
	Config.cbSize = sizeof( SWITCHCONFIG );
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_COM, 1 );
	swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	if (SC_TYPE_COM == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 

		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );

	//Set the LPT port
	Config.cbSize = sizeof( SWITCHCONFIG );	
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_LPT, 1 );

	// POSSIBLE ISSUE 03/26/01 micw There is a bug here.  swchGetSwitchConfig changes
	// Config.cbSize to 0.  This is happening in swchlpt.c in swcLptGetConfig() when it
	// copies static data from g_pGlobalData.  Is this area of shared memory getting trashed? 
    // It doesn't cause any apparent problem for the user so I didn't look at it more closely.
    
	fRv = swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	if (SC_TYPE_LPT == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 

		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );

	//Set the Game port
	Config.cbSize = sizeof( SWITCHCONFIG );
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_JOYSTICK, 1 );
	swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	if (SC_TYPE_JOYSTICK == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 
		
		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;

		Config.u.Joystick.dwJoySubType = SC_JOY_XYSWITCH;
		Config.u.Joystick.dwJoyThresholdMinX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMinY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyHysteresis = SC_JOYVALUE_DEFAULT;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );
}
/***********************************************************************/
// Set the Switch key to active
// Given the vk, set the switch key to the given vk
/***********************************************************************/
void ConfigSwitchKey(UINT vk, BOOL bSet)
{
	SWITCHCONFIG	Config;
	HSWITCHDEVICE	hsd;

	Config.cbSize = sizeof( SWITCHCONFIG );
	hsd = swchGetSwitchDevice( g_hSwitchPort, SC_TYPE_KEYS, 1 );
	swchGetSwitchConfig( g_hSwitchPort, hsd, &Config );

	//Set the Switch Key active and Set the Switch Key as 'vk' pass in as one param
	if (SC_TYPE_KEYS == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 

		if(bSet)   //set it to active
			Config.dwFlags |= 0x00000001 ;

		Config.u.Keys.dwKeySwitch1 = MAKELONG( vk, 0 );
	}

	if (SC_TYPE_JOYSTICK == swchGetDeviceType( g_hSwitchPort, hsd ))
	{
		//Clear all the bits
		Config.dwFlags &= 0x00000000; 
		
		//set it to active
		Config.dwFlags |= 0x00000001 ;

		Config.u.Joystick.dwJoySubType = SC_JOY_XYSWITCH;
		Config.u.Joystick.dwJoyThresholdMinX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxX = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMinY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyThresholdMaxY = SC_JOYVALUE_DEFAULT;
		Config.u.Joystick.dwJoyHysteresis = SC_JOYVALUE_DEFAULT;
	}

	swchSetSwitchConfig( g_hSwitchPort, hsd, &Config );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\dgadvsca.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// KBMAIN.C 
// Additions, Bug Fixes 1999 Anil Kumar
//  

#define STRICT


#include <windows.h>
#include <malloc.h>

#include "kbmain.h"
#include "Init_End.h"
#include "door.h"
#include "resource.h"


//*****************************************************************************
//    Functions prototype
//*****************************************************************************
#include "sdgutil.h"
#include "dgadvsca.h"
#include "Init_End.h"

#define MAX_KEY_TEXT		8

extern DWORD GetDesktop();

DWORD	g_rgHelpIds[] ={
		IDOK,	        70525,
		IDCANCEL,	    70530,
		CHK_KEY,        70545,
        COMBO_KB_KEY,   70545,
        CHK_PORT,       70540
    };

/*****************************************************************************/

INT_PTR AdvScanDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	INT_PTR ReturnValue;

    ReturnValue = DialogBox(hInst,  MAKEINTRESOURCE(IDD_ADVANCE_SCANNING), 
                            hWnd, AdvScanDlgProc);

    if (ReturnValue==-1)
	{	
        SendErrorMessage(IDS_CANNOTCREATEDLG);
	}
	return ReturnValue;
}

/*****************************************************************************/
INT_PTR CALLBACK AdvScanDlgProc(HWND hDlg, UINT message, 
                                WPARAM wParam, LPARAM lParam) 
{	
	HWND	hComboBox;
	int		nSel;
	static  BOOL bKBKey;
	static  UINT uKBKey;
	static  BOOL bPort;
    // F1 key is always for help and F10 for menu , So donot 
    // use these for scanning. a-anilk
/*	TCHAR	sKBKey[11][6]={ TEXT("Space"), TEXT("Enter"), 
                            TEXT("F2"),  TEXT("F3"), TEXT("F4"),
                            TEXT("F5"),    TEXT("F6"),  TEXT("F7"), TEXT("F8"),
                            TEXT("F9"),  TEXT("F12") };
*/
	LPTSTR sKBKey[11];
	UINT    ary_KBKey[11]={VK_SPACE, VK_RETURN, 
                           VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, 
		                   VK_F7, VK_F8, VK_F9, VK_F12};
	int i;
	
	int nCopiedChars, nTextSpace, nOldCopied;

	BOOL bRetValue = TRUE;


	//v-mjgran: Init sKBKey;
	for (i=0; i<11; i++)
	{
		nTextSpace = MAX_KEY_TEXT;

		sKBKey[i] = (LPTSTR) malloc (nTextSpace*sizeof(TCHAR));

		nCopiedChars = LoadString(hInst, IDS_SPACE_KEY+i, sKBKey[i], nTextSpace);
		nOldCopied = 0;
		while (nCopiedChars == (nTextSpace-1) && nOldCopied != nCopiedChars)
		{
			// To allow more space in diferent languages
			free(sKBKey[i]);
			nTextSpace = nTextSpace << 1;		//duplicate the available space
			sKBKey[i] = (LPTSTR) malloc (nTextSpace*sizeof(TCHAR));
			nOldCopied = nCopiedChars;
			nCopiedChars = LoadString(hInst, IDS_SPACE_KEY+i, sKBKey[i], nTextSpace);
		}
	}


	switch(message)
		{
		case WM_INITDIALOG:

			CheckDlgButton(hDlg, CHK_PORT,
							((bPort = kbPref->bPort) ? BST_CHECKED : \
													   BST_UNCHECKED));
			
			CheckDlgButton(hDlg, CHK_KEY,
                           ((bKBKey = kbPref->bKBKey) ? BST_CHECKED : \
                                                        BST_UNCHECKED));

			EnableWindow(GetDlgItem(hDlg, COMBO_KB_KEY), bKBKey ? TRUE : FALSE);
			
			//Set the Switch key from the setting
			uKBKey = kbPref->uKBKey;

			//Combo box
			hComboBox = GetDlgItem(hDlg, COMBO_KB_KEY);

            // Number of choices = 11 :a-anilk
			for(i=0; i < 11; i++)
            {
				SendMessage(hComboBox, CB_ADDSTRING, 0, (LPARAM)sKBKey[i]);
            }
			
			for(i=0; i < 11; i++)
            {
				if(uKBKey == ary_KBKey[i])
				{	
                    //set which choice be in the combo box at starting
                    SendMessage(hComboBox, CB_SETCURSEL, i, 0L);     
					break;
				}
            }

			//return TRUE;
			bRetValue = TRUE;
		break;

		case WM_COMMAND:
				switch(LOWORD(wParam))
					{
				case IDOK:
					
					//Switch Key
					if((bKBKey != kbPref->bKBKey) || (uKBKey != kbPref->uKBKey))
					{	
						//Save it to the setting record
						kbPref->bKBKey = bKBKey;
						kbPref->uKBKey = uKBKey;
						
						if(bKBKey)   //Config the scan key
							ConfigSwitchKey(kbPref->uKBKey, TRUE);
						else         //disable the scan key
							ConfigSwitchKey(0, FALSE);
					}

					//Switch Port
					if(bPort != kbPref->bPort)
					{
						kbPref->bPort = bPort;
						
						//Config the port (On or OFF)
						ConfigPort(bPort);
					}


					EndDialog(hDlg,IDOK);
				break;

				case IDCANCEL:
					EndDialog(hDlg,IDCANCEL);
				break;

				case CHK_PORT:
					bPort = !bPort;
				break;

				case CHK_KEY:
					bKBKey = !bKBKey;

					EnableWindow(GetDlgItem(hDlg, COMBO_KB_KEY), 
                                 (bKBKey ? TRUE : FALSE));
	
				break;

				case COMBO_KB_KEY:
					nSel= (int)SendMessage(GetDlgItem(hDlg, COMBO_KB_KEY), 
                                           CB_GETCURSEL, 0, 0L);
					
					uKBKey = ary_KBKey[nSel];

				break;

				default:
					//return FALSE;
					bRetValue = FALSE;
				break;
					}
		break;
		
        case WM_HELP:
			if ( OSKRunSecure() )
			{
				return FALSE;
			}

            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, __TEXT("osk.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_rgHelpIds);
            //return(TRUE);
			bRetValue = TRUE;
        
        case WM_CONTEXTMENU:  // right mouse click
			if ( OSKRunSecure() )
			{
				return FALSE;
			}

            WinHelp((HWND) wParam, __TEXT("osk.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);
            break;

		default:
			//return FALSE;
			bRetValue = FALSE;
		break;
		}		


	for (i=0; i<11; i++)
		free(sKBKey[i]);

	//return TRUE;
	return bRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\about.c ===
// about.c
#define STRICT

#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>

#include "Init_End.h"
#include "resource.h"

#include "scan.h"
#include "credits.h"
#include "about.h"
#include "door.h"
#include "kbmain.h"

extern DWORD GetDesktop();
extern BOOL g_fShowWarningAgain;

extern KBPREFINFO  *kbPref;

/**************************************************************************/

/* Startup procedure for modal dialog box */

INT_PTR AboutDlgFunc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	INT_PTR ReturnValue;
	TCHAR   str[256];
	TCHAR   title[256];

    ReturnValue = DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUT), NULL,
                            AboutDlgProc);

	 if (ReturnValue==-1)
	 {	
        LoadString(hInst, IDS_CANNOTCREATEDLG, &str[0], 256);
        LoadString(hInst, IDS_ABOUTBOX, &title[0], 256);
		MessageBox(hWnd, str, title, MB_OK|MB_ICONHAND);
	 }
	 return ReturnValue;
}


/*****************************************************************************/

/* Modal dialog box procedure */

INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam) 
{	
    switch(message)
    {
        case WM_INITDIALOG:
        {
			RelocateDialog(hDlg);
            KillScanTimer(TRUE);  //kill scanning
            EnableWindow(GetDlgItem(hDlg, IDC_ENABLEWEB2), (OSKRunSecure())?FALSE:TRUE);
        }
        return AboutDlgDefault(hDlg,message,wParam,lParam);
        break;

		case WM_NOTIFY:
		{
			// Web address linked: Anil
			INT idCtl		= (INT)wParam;
			LPNMHDR pnmh	= (LPNMHDR)lParam;
			switch ( pnmh->code)
			{
				case NM_RETURN:
				case NM_CLICK:
				if ( (idCtl == IDC_ENABLEWEB2) && !OSKRunSecure())
				{
					TCHAR webAddr[256];
					LoadString(hInst, IDS_ENABLEWEB, webAddr, 256);
					ShellExecute(hDlg, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
				}
				break;
			}
		}
		break;

        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    if (!AboutDlgDefault(hDlg,message,wParam,lParam))
                    {
                         EndDialog(hDlg,IDOK);
                    }
					  
                break;

				case IDCANCEL:
						EndDialog(hDlg,IDCANCEL);
					 break; 

				default:
					  return AboutDlgDefault(hDlg,message,wParam,lParam);
					  break;
					 }
		  default:
		  return AboutDlgDefault(hDlg,message,wParam,lParam);
		  break;
		}
	 return TRUE;/* Did process the message */
}


/***************************************************************/

BOOL AboutDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{	
		
	 switch(message)
		  {
		  case WM_INITDIALOG:

		  return TRUE;       /* TRUE means Windows will process WM_INITDIALOG */
		  break;

		  default:
				return FALSE; /* Didn't process the message */
				break;
		  }
	 return TRUE;
}


/*****************************************************************************/


/**************************************************************************/
// Initial Warning Message Management
/**************************************************************************/

/* Startup procedure for modal dialog box */

INT_PTR WarningMsgDlgFunc(HWND hWnd)
{
	INT_PTR ReturnValue;
	TCHAR   str[256];
	TCHAR   title[256];

    ReturnValue = DialogBox(hInst, MAKEINTRESOURCE(IDD_WARNING_MSG), NULL,
                            WarningMsgDlgProc);

	 if (ReturnValue==-1)
	 {	
        LoadString(hInst, IDS_CANNOTCREATEDLG, &str[0], 256);
        LoadString(hInst, IDS_WARNING_MSG, &title[0], 256);
		MessageBox(hWnd, str, title, MB_OK|MB_ICONHAND);
	 }

//	 hWarningIcon = LoadIcon(NULL, IDI_WARNING);
	 return ReturnValue;
}


/*****************************************************************************/

/* Modal dialog box procedure */

INT_PTR CALLBACK WarningMsgDlgProc(HWND hDlg, UINT message, 
                              WPARAM wParam, LPARAM lParam) 
{	
    switch(message)
    {
		case WM_INITDIALOG:
			RelocateDialog(hDlg);
			KillScanTimer(TRUE);  //kill scanning
            EnableWindow(GetDlgItem(hDlg, IDC_ENABLEWEB), (OSKRunSecure())?FALSE:TRUE);
			return WarningMsgDlgDefault(hDlg,message,wParam,lParam);
			break;
			
		case WM_NOTIFY:
		{
			INT idCtl		= (INT)wParam;
			LPNMHDR pnmh	= (LPNMHDR)lParam;
			switch ( pnmh->code)
			{
				case NM_RETURN:
				case NM_CLICK:
				if ( (idCtl == IDC_ENABLEWEB) && !OSKRunSecure())
				{
					TCHAR webAddr[256];
					LoadString(hInst, IDS_ENABLEWEB, webAddr, 256);
					ShellExecute(hDlg, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
				}
				break;
			}
		}
		break;

		case WM_CLOSE:
			EndDialog(hDlg,IDOK);
			break;
			
		case WM_COMMAND:
			switch(wParam)
			{
				case IDOK:
					if (!WarningMsgDlgDefault(hDlg,message,wParam,lParam))
					{
						EndDialog(hDlg,IDOK);
					}
					break;
				default:
					return WarningMsgDlgDefault(hDlg,message,wParam,lParam);
					break;
			}
		default:
			return WarningMsgDlgDefault(hDlg,message,wParam,lParam);
			break;
	}
	return TRUE;/* Did process the message */
}


/***************************************************************/
BOOL WarningMsgDlgDefault(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{	
		
	 switch(message)
		  {
		  case WM_INITDIALOG:

		  return TRUE;       /* TRUE means Windows will process WM_INITDIALOG */
		  break;

		  case WM_COMMAND:
				switch(wParam)
				{
					case IDOK:
					{
						LRESULT lRes = SendMessage(GetDlgItem(hDlg, IDC_SHOW_AGAIN), BM_GETCHECK, 0, 0);

						if (lRes == BST_CHECKED)
						{
							g_fShowWarningAgain = FALSE;
						}
						else
						{
							g_fShowWarningAgain = TRUE;
						}

						kbPref->fShowWarningAgain = g_fShowWarningAgain;

						return FALSE;
					}
					break;
				
					case IDCANCEL:
						EndDialog(hDlg,IDCANCEL);
					 break; 

					default:
					  return FALSE; /* Didn't process the message */
					  break;
				}
				break;

		  default:
				return FALSE; /* Didn't process the message */
				break;
		  }
	 return TRUE;
}


/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\fileutil.c ===
//FILEUTIL.C    file utilities

#define STRICT

#include <windows.h>
#include <malloc.h>

#include "kbmain.h"
#include "resource.h"

//
// This header contains the default settings in a global variable.
// This file was generated from the osksetti.reg file using a perl
// script.  If the:
//   Software\\Microsoft\\Osk  key is missing or the 
//   Settings value is empty then we will create this value from this varable.
//
#include "osksetti.h"


#define ACL_BUFFER_SIZE     1024
#define REG_INSTALLED       TEXT("Installed")      // Last value written during
                                                   // application installation.
/****************************************************************************/
extern BOOL settingChanged;
extern DWORD platform;

/****************************************************************************/
/*    FUNCTIONS IN THIS FILE											    */
/****************************************************************************/

PSID GetCurrentUserInfo(void);
BOOL RunningAsAdministrator(void);
BOOL OpenUserSetting(void);
BOOL SaveUserSetting(void);

/**************************************************************/


PSID GetCurrentUserInfo(void)
{
   // This function returns security information about the person who owns
   // this thread.

   HANDLE htkThread;

   TOKEN_USER *ptu;
   DWORD      cbtu;

   TOKEN_GROUPS *ptg = NULL;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;

   // First we must open a handle to the access token for this thread.

   if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &htkThread))
      if (GetLastError() == ERROR_NO_TOKEN)
      {
         // If the thread does not have an access token, we'll examine the
         // access token associated with the process.

         if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &htkThread))
         return NULL;
      }
      else return NULL;


   if (GetTokenInformation(htkThread, TokenUser, NULL, 0, &cbtu))
      return NULL;

   // Here we verify that GetTokenInformation failed for lack of a large
   // enough buffer.

   if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
      return NULL;

   // Now we allocate a buffer for the group information.
   // Since _alloca allocates on the stack, we don't have
   // to explicitly deallocate it. That happens automatically
   // when we exit this function.

   if (!(ptu= LocalAlloc(LPTR, cbtu))) return NULL;

   // Now we ask for the user information again.
   // This may fail if an administrator has changed SID information
   // for this user.

   if (!GetTokenInformation(htkThread, TokenUser, ptu, cbtu, &cbtu))
   {
       LocalFree(ptu);
       return NULL;
   }

   return ptu;
}
/***************************************************************************/

typedef HRESULT (*CHECKTOKENMEMBERSHIP)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

// CheckToken Returns TRUE if we were able to GetProcAddress on NT5's CheckTokenMembership,
// returns FALSE otherwise.
BOOL CheckToken(HANDLE hAccessToken, BOOL *pfIsAdmin)
{
    BOOL bNewNT5check = FALSE;
    HINSTANCE hAdvapi32 = NULL;
    CHECKTOKENMEMBERSHIP pf;
    PSID AdministratorsGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));
    if (hAdvapi32)
    {
        pf = (CHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
        if (pf)
        {
            bNewNT5check = TRUE;

            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                pf(hAccessToken, AdministratorsGroup, pfIsAdmin);
                FreeSid(AdministratorsGroup);
            }
        }
        FreeLibrary(hAdvapi32);
    }
    return bNewNT5check;
}

// Returns true if our process has admin priviliges.
// Returns false otherwise.
// We need to know this in order to start UtilMan as an app when we
// do it from menu under non-admin account
// We also return FALSE when any allocation or other error is encountered
BOOL RunningAsAdministrator()
{
   BOOL  fAdmin = FALSE;
   HANDLE htkThread;
   TOKEN_GROUPS *ptg = NULL;
   DWORD cbTokenGroups;
   DWORD iGroup;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
   PSID psidAdmin = 0;

   // This function returns TRUE if the user identifier associated with this
   // process is a member of the the Administrators group.

   // First we must open a handle to the access token for this thread.

   if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &htkThread))
   {
      if (GetLastError() == ERROR_NO_TOKEN)
      {
         // If the thread does not have an access token, we'll examine the
         // access token associated with the process.

         if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &htkThread))
         {
             return FALSE;
         }
      }
      else
      {
          return FALSE;
      }
   }

   // early out by calling NT5's new CheckTokenMembership function
   if (CheckToken(htkThread, &fAdmin))
   {
       goto bail;
   }
   // Then we must query the size of the group information associated with
   // the token. Note that we expect a FALSE result from GetTokenInformation
   // because we've given it a NULL buffer. On exit cbTokenGroups will tell
   // the size of the group information.

   if (GetTokenInformation(htkThread, TokenGroups, NULL, 0, &cbTokenGroups))
   {
       goto bail;
   }

   // Here we verify that GetTokenInformation failed for lack of a large
   // enough buffer.

   if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
      goto bail;

   // Now we allocate a buffer for the group information.
   // Since _alloca allocates on the stack, we don't have
   // to explicitly deallocate it. That happens automatically
   // when we exit this function.

   if (!(ptg= LocalAlloc(LPTR, cbTokenGroups))) return FALSE;

   // Now we ask for the group information again.
   // This may fail if an administrator has added this account
   // to an additional group between our first call to
   // GetTokenInformation and this one.

    if (!GetTokenInformation(htkThread, TokenGroups, ptg, cbTokenGroups, 
                            &cbTokenGroups))
    {
        goto bail;
    }

   // Now we must create a System Identifier for the Admin group.

   if (!AllocateAndInitializeSid
          (&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &psidAdmin
          )
      )
   {
      goto bail;
   }

   // Finally we'll iterate through the list of groups for this access
   // token looking for a match against the SID we created above.


   for (iGroup= 0; iGroup < ptg->GroupCount; iGroup++)
   {
      if (EqualSid(ptg->Groups[iGroup].Sid, psidAdmin))
      {
         fAdmin = TRUE;
         break;
      }
   }

bail:
   CloseHandle(htkThread);

   if (psidAdmin)
      FreeSid(psidAdmin);

   if (ptg)
       LocalFree(ptg);

   return fAdmin;
}

/****************************************************************************/
BOOL OpenUserSetting(void)
{  
//   HKEY hkGlobal;
   TCHAR pathbuff[50]=TEXT("Software\\Microsoft\\Osk");
   
   HKEY hkPerUser  = NULL;
   LONG lResult;
   DWORD dwType, cbData, dwStepping;
   DWORD dwDisposition;
   TOKEN_USER *ptu = NULL;
   PSID psidUser   = NULL,
        psidAdmins = NULL;
   PACL  paclKey = NULL;
   SID_IDENTIFIER_AUTHORITY		SystemSidAuthority= SECURITY_NT_AUTHORITY;
   SECURITY_ATTRIBUTES sa;
   SECURITY_DESCRIPTOR sdPermissions;

   TCHAR errstr[256]=TEXT("");
   TCHAR title[256]=TEXT("");
    //a-anilk
   int actualKeybdType;
   // First we'll setup the security attributes we're going to
   // use with the application's global key.

   sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
   sa.bInheritHandle       = FALSE;
   sa.lpSecurityDescriptor = &sdPermissions;

	// ***  Do extra checking if we are in NT  ***
	if(platform == VER_PLATFORM_WIN32_NT)   
	{	
		// Here we're creating a System Identifier (SID) to represent
		// the Admin group.
		if (!AllocateAndInitializeSid
			  (&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &psidAdmins))
        {
			goto security_failure;
        }

		// We also need a SID for the current user.

		if (!(ptu= GetCurrentUserInfo()) || !(psidUser= ptu->User.Sid)) 
			goto security_failure;

		if (!InitializeSecurityDescriptor(&sdPermissions, 
                                          SECURITY_DESCRIPTOR_REVISION1))
        {
			goto security_failure;
        }

		// We want the current user to own this key.

		if (!SetSecurityDescriptorOwner(&sdPermissions, psidUser, 0))
			goto security_failure;

		// Finally we must allocate and construct the discretionary
		// access control list (DACL) for the key.

		// Note that _alloca allocates memory on the stack frame
		// which will automatically be deallocated when this routine
		// exits.

		if (!(paclKey= (PACL) LocalAlloc(LPTR, ACL_BUFFER_SIZE)))
			goto memory_limited;

		if (!InitializeAcl(paclKey, ACL_BUFFER_SIZE, ACL_REVISION2))
			goto security_failure;

		// Our DACL will two access control entries (ACEs). The first ACE
		// provides full access to the current user. The second ACE gives
		// the Admin group full access. By default all other users will have
		// no access to the key.

		// The reason for admin access is to allow an administrator to
		// run special utilties to cleanup inconsistencies and disasters
		// in the per-user data area.

		if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, psidUser))
			goto security_failure;

		if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, psidAdmins))
			goto security_failure;

		// We must bind this DACL to the security descriptor...

		if (!SetSecurityDescriptorDacl(&sdPermissions, TRUE, paclKey, FALSE))
			goto security_failure;

	}   //end of extra checking for NT
    
	// Now we'll attempt to create the key with the security attributes...

	lResult= RegCreateKeyEx(HKEY_CURRENT_USER, 
                            &pathbuff[0], 
                            0,
                            TEXT("Application Per-User Data"), 
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            &sa, 
                            &hkPerUser, 
                            &dwDisposition);

	if (lResult != ERROR_SUCCESS) 
    {
        goto registry_access_error;
    }

   // Usually the disposition value will indicate that we've created a
   // new key. Sometimes it may instead state that we've opened an existing
   // key. This can happen when installation is incomplete and interrupted,
   // say by loss of electrical power.

	if ((dwDisposition != REG_CREATED_NEW_KEY) && 
        (dwDisposition != REG_OPENED_EXISTING_KEY)) 
    {
		goto registry_access_error;
    }

	
	kbPref = (KBPREFINFO *)malloc(sizeof(KBPREFINFO));   

    if (kbPref == NULL)
        goto memory_limited;

    dwType=REG_DWORD;
    cbData=sizeof(DWORD);
    lstrcpy(pathbuff,TEXT("Stepping"));
	lResult=RegQueryValueEx(hkPerUser, &pathbuff[0], NULL, &dwType, 
                            (LPBYTE)&dwStepping, &cbData); 

    if (lResult != ERROR_SUCCESS)
        dwStepping=0;

	dwType= REG_BINARY;
	cbData= sizeof(KBPREFINFO);
	lstrcpy(pathbuff, TEXT("Setting"));
	lResult=RegQueryValueEx(hkPerUser, &pathbuff[0], NULL, &dwType, 
                            (LPBYTE)kbPref, &cbData); 

	if((lResult != ERROR_SUCCESS) || (dwStepping < CURRENT_STEPPING)) 
    {
        //
        // if it is not there then create the default Settings value
        //
        RegSetValueEx(hkPerUser, pathbuff, 0, REG_BINARY,  
                      g_DefaultSettings, sizeof(g_DefaultSettings));
        
    	cbData= sizeof(KBPREFINFO);
	    lResult=RegQueryValueEx(hkPerUser, &pathbuff[0], NULL, &dwType, 
                                (LPBYTE)kbPref, &cbData); 

        // HACK by a-anilk
        // This is the place where the Default values are taken by OSK. 
        // Just change the keyboard layout based on the keyboard type used
        actualKeybdType = GetKeyboardType(0);
        switch(actualKeybdType)
        {
            case 1:
            case 3:
            case 4:
            case 5:
            case 6:
                // 101 keyboard
                kbPref->KBLayout = 101;
                break;

            case 2:
                // 102 keyboard
                kbPref->KBLayout = 102;
                break;

            case 7:
                // Japanese Keyboard
                kbPref->KBLayout = 106;
                break;

            default:
                // 101 keyboard
                kbPref->KBLayout = 101;
                break;
        }

        if (lResult != ERROR_SUCCESS)
    		goto registry_access_error;

        //
        // update the stepping
        //
        dwType=REG_DWORD;
	    cbData=sizeof(DWORD);
        lstrcpy(pathbuff,TEXT("Stepping"));
        dwStepping=CURRENT_STEPPING;

        RegSetValueEx(hkPerUser, pathbuff, 0, REG_DWORD,  
                      (LPBYTE)&dwStepping, sizeof(DWORD));
    }

	RegCloseKey(hkPerUser);
	FreeSid(psidAdmins);
	LocalFree(ptu);
    if (paclKey)
    {
        LocalFree(paclKey);
        paclKey = NULL;
    }

	return(TRUE);

//**************
//Error handler
//**************

registry_access_error:

	LoadString(hInst, IDS_REGISTRY_ACCESS_ERROR, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

memory_limited:

	LoadString(hInst, IDS_MEMORY_LIMITED, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

security_failure:

	LoadString(hInst, IDS_SECURITY_FAILURE, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);

clean_up_after_failure:

    if (psidAdmins) 
        FreeSid(psidAdmins);
    if (ptu) 
	    LocalFree(ptu);
    if (paclKey)
    {
        LocalFree(paclKey);
        paclKey = NULL;
    }

   return FALSE;
}
/****************************************************************************/
BOOL SaveUserSetting(void)
{  
//    HKEY hkGlobal;
    TCHAR pathbuff[50]=TEXT("Software\\Microsoft\\Osk");
    TCHAR errstr[256];
    TCHAR title[256];
   
    HKEY hkPerUser  = NULL;
    LONG lResult;
    DWORD dwDisposition;

    TOKEN_USER *ptu = NULL;

    PSID psidUser   = NULL;
    PSID psidAdmins = NULL;

    PACL  paclKey = NULL;

    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sdPermissions;

	

   // First we'll see whether this user has admin privileges...
//   if (RunningAsAdministrator())
//		MessageBox(0, TEXT("Running as administrator"), TEXT("Admin"), MB_OK);




   // First we'll setup the security attributes we're going to
   // use with the application's global key.

   sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
   sa.bInheritHandle       = FALSE;
   sa.lpSecurityDescriptor = &sdPermissions;

	// ***  Do extra checking if we are in NT  ***
	if(platform == VER_PLATFORM_WIN32_NT)   
	{
   
		// Here we're creating a System Identifier (SID) to represent
		// the Admin group.

		if (!AllocateAndInitializeSid
			  (&SystemSidAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
				                       DOMAIN_ALIAS_RID_ADMINS,
					                   0, 0, 0, 0, 0, 0,
						               &psidAdmins))
        {
			goto security_failure;
        }

		// We also need a SID for the current user.

		if (!(ptu= GetCurrentUserInfo()) || !(psidUser= ptu->User.Sid)) 
			goto security_failure;

        if (!InitializeSecurityDescriptor(&sdPermissions, 
                                          SECURITY_DESCRIPTOR_REVISION1))
        {
			goto security_failure;
        }

		// We want the current user to own this key.

		if (!SetSecurityDescriptorOwner(&sdPermissions, psidUser, 0))
			goto security_failure;

		// Finally we must allocate and construct the discretionary
		// access control list (DACL) for the key.

		// Note that _alloca allocates memory on the stack frame
		// which will automatically be deallocated when this routine
		// exits.

		if (!(paclKey= (PACL) LocalAlloc(LPTR, ACL_BUFFER_SIZE)))
			goto memory_limited;

		if (!InitializeAcl(paclKey, ACL_BUFFER_SIZE, ACL_REVISION2))
			goto security_failure;

		// Our DACL will two access control entries (ACEs). The first ACE
		// provides full access to the current user. The second ACE gives
		// the Admin group full access. By default all other users will have
		// no access to the key.

		// The reason for admin access is to allow an administrator to
		// run special utilties to cleanup inconsistencies and disasters
		// in the per-user data area.

		if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, 
                                 psidUser))
        {
            goto security_failure;
        }

        if (!AddAccessAllowedAce(paclKey, ACL_REVISION2, KEY_ALL_ACCESS, 
                                 psidAdmins))
        {
            goto security_failure;
        }

		// We must bind this DACL to the security descriptor...

		if (!SetSecurityDescriptorDacl(&sdPermissions, TRUE, paclKey, FALSE))
			goto security_failure;

	}	//end of extra checking for NT

   
   // Now we'll attempt to create the key with the security attributes...

   lResult= RegCreateKeyEx(HKEY_CURRENT_USER, &pathbuff[0], 0,
                           TEXT("Application Per-User Data"), 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           &sa, &hkPerUser, &dwDisposition
                          );

   if (lResult != ERROR_SUCCESS) goto registry_access_error;

   // Usually the disposition value will indicate that we've created a
   // new key. Sometimes it may instead state that we've opened an existing
   // key. This can happen when installation is incomplete and interrupted,
   // say by loss of electrical power.

    if (dwDisposition != REG_CREATED_NEW_KEY  &&
        dwDisposition != REG_OPENED_EXISTING_KEY) 
    {
        goto registry_access_error;
    }


	//Save the whole setting
	lstrcpy(pathbuff, TEXT("Setting"));
	lResult= RegSetValueEx(hkPerUser, &pathbuff[0], 0, REG_BINARY,
                           (LPBYTE) kbPref, sizeof(KBPREFINFO));

	if (lResult != ERROR_SUCCESS) 
		goto registry_access_error;

   RegCloseKey(hkPerUser);
   FreeSid(psidAdmins);
   LocalFree(ptu);

   free(kbPref);		//v-mjgran: Memory Leak fixed

   if (paclKey)
   {
       LocalFree(paclKey);
       paclKey = NULL;
   }

   return(TRUE);

//Error handling

registry_access_error:

    LoadString(hInst, IDS_REGISTRY_ACCESS_ERROR, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
    MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

memory_limited:

    LoadString(hInst, IDS_MEMORY_LIMITED, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
    MessageBox(0, errstr,title, MB_OK|MB_ICONHAND);
    goto clean_up_after_failure;

security_failure:

    LoadString(hInst, IDS_SECURITY_FAILURE, &errstr[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
    MessageBox(0, errstr, title, MB_OK|MB_ICONHAND);

clean_up_after_failure:

   if (psidAdmins) 
	   FreeSid(psidAdmins);
   if (ptu) 
	   LocalFree(ptu);
   if (paclKey)
   {
       LocalFree(paclKey);
       paclKey = NULL;
   }

   return FALSE;
}



/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\kbfunc.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// KBFUNC.C    // Function library to KBMAIN.C
// File modified to paint bitmaps instead of icons : a-anilk :02-16-99
// Last updated Maria Jose and Anil Kumar
// 
#define STRICT

#include <windows.h>
#include <commdlg.h>
#include "kbmain.h"
#include "kbus.h"
#include "kbfunc.h"
#include "ms32dll.h"
#include "resource.h"
#include "dgsett.h"
#include <malloc.h>
#include <stdlib.h>
#include "w95trace.h"


// local functions
int GetKeyLabel(UINT vk, UINT sc, LPBYTE achKbdState, LPTSTR pszBuf, int cchBuf, HKL hkl);
LPTSTR SetKeyText(UINT vk, UINT sc, LPBYTE achKbdState, HKL hkl, LPTSTR pszDefLabel, int *piType);
LPTSTR CopyDefKey(LPTSTR pszDefLabel);

#define RGBBLACK     RGB(0,0,0)
#define RGBWHITE     RGB(255,255,255)
#define RGBBACK     RGB(107,107,107)
#define DSPDxax   0x00E20746L

#define REDRAW			1
#define NREDRAW			2

static BOOL s_fLastDown = FALSE;
int g_cAltGrKeys = 0;	// non-zero if there are ALTGR keys to show

extern KBkeyRec	KBkey[] =
	{
	//0
    {TEXT(""),TEXT(""),	TEXT(""),TEXT(""),
     NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,BOTH},  //DUMMY

//1
	{TEXT("esc"),TEXT("esc"),TEXT("{esc}"),TEXT("{esc}"),
     NO_NAME, 1,1,8,8, TRUE,  KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x01,0x00,0x00,0x00}},

//2
    {TEXT("F1"), TEXT("F1"), TEXT("{f1}"), TEXT("{f1}"),
     NO_NAME, 1,19, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3B,0x00,0x00,0x00}},

//3
    {TEXT("F2"), TEXT("F2"), TEXT("{f2}"), TEXT("{f2}"),
     NO_NAME, 1,28, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3C,0x00,0x00,0x00}},

//4
    {TEXT("F3"), TEXT("F3"), TEXT("{f3}"), TEXT("{f3}"),
     NO_NAME, 1,37, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3D,0x00,0x00,0x00}},

//5
    {TEXT("F4"), TEXT("F4"), TEXT("{f4}"), TEXT("{f4}"),
     NO_NAME, 1,46, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3E,0x00,0x00,0x00}},

//6
    {TEXT("F5"), TEXT("F5"), TEXT("{f5}"), TEXT("{f5}"),
     NO_NAME, 1,60, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x3F,0x00,0x00,0x00}},

//7
    {TEXT("F6"), TEXT("F6"), TEXT("{f6}"), TEXT("{f6}"),
     NO_NAME, 1,69, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x40,0x00,0x00,0x00}},

//8
    {TEXT("F7"), TEXT("F7"), TEXT("{f7}"), TEXT("{f7}"),
     NO_NAME, 1,78, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x41,0x00,0x00,0x00}},

//9
    {TEXT("F8"), TEXT("F8"), TEXT("{f8}"), TEXT("{f8}"),
     NO_NAME, 1,87, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x42,0x00,0x00,0x00}},

//10
    {TEXT("F9"), TEXT("F9"), TEXT("{f9}"), TEXT("{f9}"),
     NO_NAME, 1,101, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x43,0x00,0x00,0x00}},

//11
    {TEXT("F10"),TEXT("F10"), TEXT("{f10}"),TEXT("{f10}"),
     NO_NAME,  1,110, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x44,0x00,0x00,0x00}},

//12
    {TEXT("F11"),TEXT("F11"), TEXT("{f11}"),TEXT("{f11}"),
     NO_NAME,  1,119, 8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x57,0x00,0x00,0x00}},

//13
    {TEXT("F12"),TEXT("F12"), TEXT("{f12}"),TEXT("{f12}"),
     NO_NAME,1,128,8,8, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x58,0x00,0x00,0x00}},

//14
    {TEXT("psc"), TEXT("psc"),TEXT("{PRTSC}"),TEXT("{PRTSC}"),
     KB_PSC, 1,138,8,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x2A,0xE0,0x37}},

//15
    {TEXT("slk"), TEXT("slk"),TEXT("{SCROLLOCK}"),TEXT("{SCROLLOCK}"),
     KB_SCROLL,1,147,8, 8, TRUE, SCROLLOCK_TYPE, LARGE, NREDRAW, 2,
     {0x46,0x00,0x00,0x00}},

//16
	{TEXT("brk"), TEXT("pau"), TEXT("{BREAK}"), TEXT("{^s}"),
     NO_NAME,1,156,8,8, TRUE, KNORMAL_TYPE, LARGE, REDRAW, 2,
     {0xE1,0x1D,0x45,0x00}},

//17
    {TEXT("`"), TEXT("~"), TEXT("`"), TEXT("{~}"),
     NO_NAME, 12,1,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x29,0x00,0x00,0x00}},

//18
    {TEXT("1"), TEXT("!"), TEXT("1"), TEXT("!"),
     NO_NAME, 12,10,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x02,0x00,0x00,0x00}},

//19
	{TEXT("2"),	TEXT("@"), TEXT("2"), TEXT("@"),
     NO_NAME, 12,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x03,0x00,0x00,0x00}},

//20
    {TEXT("3"), TEXT("#"), TEXT("3"), TEXT("#"),
     NO_NAME,12,28,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x04,0x00,0x00,0x00}},

//21
	{TEXT("4"),		TEXT("$"),		TEXT("4"),		TEXT("$"),		NO_NAME,	 12,	  37,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x05,0x00,0x00,0x00}},
	
//22	
	{TEXT("5"), 	TEXT("%"), 		TEXT("5"),		TEXT("{%}"),	NO_NAME,	 12,	  46,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x06,0x00,0x00,0x00}},
	
//23	
	{TEXT("6"),		TEXT("^"),		TEXT("6"),		TEXT("{^}"),	NO_NAME,	 12,	  55,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x07,0x00,0x00,0x00}},
	
//24
	{TEXT("7"),		TEXT("&"),		TEXT("7"),		TEXT("&"),		NO_NAME,	 12,	  64,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x08,0x00,0x00,0x00}},
	
//25
	{TEXT("8"), 	TEXT("*"), 		TEXT("8"),		TEXT("*"),		NO_NAME,	 12,	  73,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x09,0x00,0x00,0x00}},
	
//26
	{TEXT("9"),		TEXT("("),		TEXT("9"),		TEXT("("),		NO_NAME,	 12,	  82,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0A,0x00,0x00,0x00}},
	
//27
	{TEXT("0"),		TEXT(")"),		TEXT("0"),		TEXT(")"),		NO_NAME,	 12,	  91,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0B,0x00,0x00,0x00}},
	
//28
	{TEXT("-"), 	TEXT("_"), 		TEXT("-"),		TEXT("_"),		NO_NAME,	 12,	 100,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0C,0x00,0x00,0x00}},
	
//29
	{TEXT("="),		TEXT("+"),		TEXT("="),		TEXT("{+}"),	NO_NAME,	 12,	 109,   8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x0D,0x00,0x00,0x00}},

//30
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY

//31
	{TEXT("bksp"),TEXT("bksp"),TEXT("{BS}"),TEXT("{BS}"),
     NO_NAME,12, 118,8,18,  TRUE, KNORMAL_TYPE, BOTH, NREDRAW, 2,
     {0x0E,0x00,0x00,0x00}},

//32
	{TEXT("ins"),TEXT("ins"),TEXT("{INSERT}"),TEXT("{INSERT}"), NO_NAME, 12,138, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x52,0x00,0x00}},
	
//33	
	{TEXT("hm"), TEXT("hm"), TEXT("{HOME}"), TEXT("{HOME}"), 	NO_NAME, 12,147, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x47,0x00,0x00}},

//34
	{TEXT("pup"),TEXT("pup"),TEXT("{PGUP}"),TEXT("{PGUP}"),		NO_NAME, 12,156, 8,8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x49,0x00,0x00}},

//35
	{TEXT("nlk"),TEXT("nlk"),TEXT("{NUMLOCK}"),TEXT("{NUMLOCK}"),
    KB_NUMLOCK, 12,166,8,8, FALSE, NUMLOCK_TYPE, LARGE, NREDRAW, 2, 
    {0x45,0x00,0x00,0x00}},
	
//36
	{TEXT("/"),	TEXT("/"),	TEXT("/"),	TEXT("/"),	NO_NAME, 12, 175,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x35,0x00,0x00}},
	
//37
	{TEXT("*"),	TEXT("*"),	TEXT("*"),	TEXT("*"),	NO_NAME, 12, 184,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x37,0x00,0x00}},
	
//38	
	{TEXT("-"),	TEXT("-"),	TEXT("-"),	TEXT("-"),	NO_NAME, 12, 193,  8, 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1, {0x4A,0x00,0x00,0x00}},

//39
	{TEXT("tab"),	TEXT("tab"),	TEXT("{TAB}"),TEXT("{TAB}"),NO_NAME, 21,   1,  8,	13, FALSE, KNORMAL_TYPE, BOTH, NREDRAW, 2, {0x0F,0x00,0x00,0x00}},

//40
	{TEXT("q"),	TEXT("Q"),	TEXT("q"),	TEXT("+q"),	NO_NAME, 21,  15,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x10,0x00,0x00,0x00}},
	
//41
	{TEXT("w"),	TEXT("W"),	TEXT("w"),	TEXT("+w"),	NO_NAME, 21,  24,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x11,0x00,0x00,0x00}},
	
//42
	{TEXT("e"),	TEXT("E"),	TEXT("e"),	TEXT("+e"),	NO_NAME, 21,  33,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x12,0x00,0x00,0x00}},
	
//43
	{TEXT("r"),	TEXT("R"),	TEXT("r"),	TEXT("+r"),	NO_NAME, 21,  42,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x13,0x00,0x00,0x00}},

//44
    {TEXT("t"),	TEXT("T"),	TEXT("t"),	TEXT("+t"),	
     NO_NAME, 21,51,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x14,0x00,0x00,0x00}},

//45
	{TEXT("y"),	TEXT("Y"),	TEXT("y"),	TEXT("+y"),	NO_NAME, 21,  60,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x15,0x00,0x00,0x00}},
	
//46	
	{TEXT("u"),	TEXT("U"),	TEXT("u"),	TEXT("+u"),	NO_NAME, 21,  69,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x16,0x00,0x00,0x00}},
	
//47	
	{TEXT("i"),	TEXT("I"),	TEXT("i"),	TEXT("+i"),	NO_NAME, 21,  78,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x17,0x00,0x00,0x00}},
	
//48
	{TEXT("o"),	TEXT("O"),	TEXT("o"),	TEXT("+o"),	NO_NAME, 21,  87,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x18,0x00,0x00,0x00}},
	
//49	
	{TEXT("p"),	TEXT("P"),	TEXT("p"),	TEXT("+p"),	NO_NAME, 21,  96,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x19,0x00,0x00,0x00}},
	
//50
	{TEXT("["),	TEXT("{"),	TEXT("["),	TEXT("{{}"),	NO_NAME, 21, 105,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1A,0x00,0x00,0x00}},
	
//51	
	{TEXT("]"),	TEXT("}"),	TEXT("]"),	TEXT("{}}"),	NO_NAME, 21, 114,  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1B,0x00,0x00,0x00}},
	
//52	
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 123,  8,	13, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x2B,0x00,0x00,0x00}},

//53
	{TEXT("del"), TEXT("del"), 	TEXT("{DEL}"),TEXT("{DEL}"),NO_NAME, 21,   138,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x53,0x00,0x00}},

//54	
	{TEXT("end"),	TEXT("end"), 	TEXT("{END}"),TEXT("{END}"),NO_NAME, 21,   147,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x4F,0x00,0x00}},

//55	
	{TEXT("pdn"), TEXT("pdn"), 	TEXT("{PGDN}"),TEXT("{PGDN}"),NO_NAME, 21, 156,  8, 8, TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0xE0,0x51,0x00,0x00}},

//56
	{TEXT("7"),		TEXT("7"),		TEXT("hm"),		TEXT("7"),		NO_NAME,	 21,	 166,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x47,0x00,0x00,0x00}},

//57	
	{TEXT("8"),		TEXT("8"),		TEXT("8"),		TEXT("8"),		NO_NAME,	 21,	 175,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x48,0x00,0x00,0x00}},

//58	
	{TEXT("9"),		TEXT("9"),		TEXT("pup"),		TEXT("9"),		NO_NAME,	 21,	 184,	  8,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x49,0x00,0x00,0x00}},
	
//59
	{TEXT("+"),		TEXT("+"),		TEXT("{+}"),  	TEXT("{+}"),	NO_NAME,	 21,	 193,	 17,	 8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2, {0x4E,0x00,0x00,0x00}},


//60
    {TEXT("lock"),TEXT("lock"),TEXT("{caplock}"),TEXT("{caplock}"),
     KB_CAPLOCK, 30,1,8,17, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x3A,0x00,0x00,0x00}},

//61
	{TEXT("a"),	TEXT("A"), TEXT("a"), TEXT("+a"),
     NO_NAME, 30,19,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x1E,0x00,0x00,0x00}},

//62
	{TEXT("s"),		TEXT("S"),		TEXT("s"),		TEXT("+s"),		NO_NAME,	  30,	  28,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x1F,0x00,0x00,0x00}},
	
//63
	{TEXT("d"),		TEXT("D"),		TEXT("d"),		TEXT("+d"),		NO_NAME,	  30,	  37,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x20,0x00,0x00,0x00}},
	
//64
	{TEXT("f"),		TEXT("F"),		TEXT("f"),		TEXT("+f"),		NO_NAME,	  30,	  46,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x21,0x00,0x00,0x00}},
	
//65
	{TEXT("g"),		TEXT("G"),		TEXT("g"),		TEXT("+g"),		NO_NAME,	  30,	  55,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x22,0x00,0x00,0x00}},
	
//66
	{TEXT("h"),		TEXT("H"),		TEXT("h"),		TEXT("+h"),		NO_NAME,	  30,	  64,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x23,0x00,0x00,0x00}},

//67
	{TEXT("j"),	TEXT("J"), TEXT("j"), TEXT("+j"),
     NO_NAME, 30,73,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x24,0x00,0x00,0x00}},

//68
	{TEXT("k"),		TEXT("K"),		TEXT("k"),		TEXT("+k"),		NO_NAME,	  30,	  82,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x25,0x00,0x00,0x00}},
	
//69
	{TEXT("l"),		TEXT("L"),		TEXT("l"),		TEXT("+l"),		NO_NAME,	  30,	  91,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x26,0x00,0x00,0x00}},
	
//70	
	{TEXT(";"), TEXT(":"), TEXT(";"), TEXT("+;"),
     NO_NAME, 30,100,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x27,0x00,0x00,0x00}},

//71
	{TEXT("'"),		TEXT("''"),		TEXT("'"),		TEXT("''"),		NO_NAME,	  30,	 109,	  8,	 8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1, {0x28,0x00,0x00,0x00}},
	
//72
//Japanese KB extra key
	{TEXT("\\"),	TEXT("|"),	TEXT("\\"),	TEXT("|"),	NO_NAME, 21, 118,  8,	8, FALSE, KNORMAL_TYPE, NOTSHOW, REDRAW, 1, {0x2B,0x00,0x00,0x00}},
	
//73	
	{TEXT("ent"),TEXT("ent"),TEXT("{enter}"),TEXT("{enter}"),	NO_NAME,  30,	 118,	  8,  18, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 2, {0x1C,0x00,0x00,0x00}},


//74
    {TEXT("4"), TEXT("4"), TEXT("4"), TEXT("4"),
     NO_NAME, 30,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4B,0x00,0x00,0x00}},

//75
    {TEXT("5"),	TEXT("5"), TEXT("5"), TEXT("5"),
     NO_NAME, 30,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4C,0x00,0x00,0x00}},

//76
    {TEXT("6"),	TEXT("6"), TEXT("6"), TEXT("6"),
     NO_NAME, 30,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4D,0x00,0x00,0x00}},


//77
	{TEXT("shft"),TEXT("shft"),	TEXT(""), TEXT(""),
     KB_LSHIFT, 39,1,8,21, TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x2A,0x00,0x00,0x00}},

//78
    {TEXT("z"), TEXT("Z"),  TEXT("z"),  TEXT("+z"),
     NO_NAME,39,23,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2C,0x00,0x00,0x00}},

//79
    {TEXT("x"),	TEXT("X"), TEXT("x"), TEXT("+x"),
     NO_NAME, 39,32,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2D,0x00,0x00,0x00}},

//80
    {TEXT("c"), TEXT("C"), TEXT("c"), TEXT("+c"),
     NO_NAME, 39,41,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2E,0x00,0x00,0x00}},

//81
    {TEXT("v"), TEXT("V"), TEXT("v"), TEXT("+v"),
     NO_NAME, 39,50,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x2F,0x00,0x00,0x00}},

//82
    {TEXT("b"),TEXT("B"),TEXT("b"),TEXT("+b"),
     NO_NAME,39,59,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x30,0x00,0x00,0x00}},

//83
    {TEXT("n"),	TEXT("N"), TEXT("n"), TEXT("+n"),
     NO_NAME,39,68,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x31,0x00,0x00,0x00}},

//84
    {TEXT("m"), TEXT("M"), TEXT("m"), TEXT("+m"),
     NO_NAME, 39,77,8,8,FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x32,0x00,0x00,0x00}},

//85
    {TEXT(","),	TEXT("<"), TEXT(","), TEXT("+<"),
     NO_NAME, 39,86,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x33,0x00,0x00,0x00}},

//86
    {TEXT("."), TEXT(">"), TEXT("."), TEXT("+>"),
     NO_NAME, 39,95,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
    {0x34,0x00,0x00,0x00}},

//87
    {TEXT("/"),	TEXT("?"), TEXT("/"), TEXT("+/"),
     NO_NAME, 39,104,8,8, FALSE, KNORMAL_TYPE, BOTH, REDRAW, 1,
     {0x35,0x00,0x00,0x00}},


//88
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY
	
//89
	{TEXT("shft"),TEXT("shft"),TEXT(""),TEXT(""),
     KB_RSHIFT,39,113,8,23,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x36,0x00,0x00,0x00}},


//90
    {TEXT("IDB_UPUPARW"),TEXT("IDB_UPDNARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP,39,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//91
	{TEXT("1"), TEXT("1"),TEXT("end"),TEXT("1"),
     NO_NAME,39,166,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x4F,0x00,0x00,0x00}},

//92
	{TEXT("2"), TEXT("2"),TEXT("2"),TEXT("2"),
     NO_NAME,39,175,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x50,0x00,0x00,0x00}},

//93
	{TEXT("3"),TEXT("3"),TEXT("pdn"),TEXT("3"),
     NO_NAME,39,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x51,0x00,0x00,0x00}},

//94
	{TEXT("ent"),TEXT("ent"),TEXT("ent"),TEXT("ent"),
     NO_NAME, 39,193,17,8,  TRUE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0xE0,0x1C,0x00,0x00}},


//95
	{TEXT("ctrl"), TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_LCTR,48,1,8,13,  TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x1D,0x00,0x00,0x00}},

//96
    {TEXT("winlogoUp"), TEXT("winlogoDn"),TEXT("I_winlogo"),TEXT("lwin"),
     ICON, 48, 15 ,8,8,TRUE, KMODIFIER_TYPE,BOTH, REDRAW},

//97
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
	 KB_LALT,48,24,8,13,TRUE, KMODIFIER_TYPE, BOTH, REDRAW, 2,
     {0x38,0x00,0x00,0x00}},

//98
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY

//99
    {TEXT(""),TEXT(""),TEXT(" "),TEXT(" "),
     KB_SPACE,48,38,8,52, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},

//100
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY

//101
//Japanese KB extra key
	{TEXT(""),TEXT(""),	TEXT(""),TEXT(""), NO_NAME,0,0,0,0,TRUE,KNORMAL_TYPE,NOTSHOW},  //DUMMY


//102
    {TEXT("alt"),TEXT("alt"),TEXT(""),TEXT(""),
     KB_RALT,48,91,8,13, TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//103
	{TEXT("winlogoUp"), TEXT("winlogoDn"), TEXT("I_winlogo"),TEXT("rwin"),
     ICON, 48,105,8,8,TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//104
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"),TEXT("App"),
     ICON, 48,114,8,8, TRUE, KMODIFIER_TYPE,LARGE, REDRAW},

//105
    {TEXT("ctrl"),TEXT("ctrl"),TEXT(""),TEXT(""),
     KB_RCTR,48,123,8,13,TRUE, KMODIFIER_TYPE, LARGE, REDRAW, 2,
     {0xE0,0x10,0x00,0x00}},


//106
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,138,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//107
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,147,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//108
	{TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP, 48,156,8,8, FALSE, KMODIFIER_TYPE, LARGE, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},


//109
    {TEXT("0"),	TEXT("0"),	TEXT("ins"),	TEXT("0"),
     NO_NAME, 48,166,8,17, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x52,0x00,0x00,0x00}},

//110
    {TEXT("."),	TEXT("."),	TEXT("del"),	TEXT("."),
     NO_NAME, 48,184,8,8, FALSE, KNORMAL_TYPE, LARGE, NREDRAW, 2,
     {0x53,0x00,0x00,0x00}},

//End of large KB

//111
	{TEXT(""), TEXT(""), TEXT(" "), TEXT(" "),
     KB_SPACE,  48,38,8,38, FALSE, KNORMAL_TYPE, SMALL, NREDRAW, 1,
     {0x39,0x00,0x00,0x00}},


//112
	{TEXT("alt"), TEXT("alt"), TEXT(""), TEXT(""),
     KB_RALT,  48,77,8,13, TRUE, KMODIFIER_TYPE, SMALL, REDRAW, 2,
     {0xE0,0x38,0x00,0x00}},

//113
	{TEXT("MenuKeyUp"), TEXT("MenuKeyDn"), TEXT("I_MenuKey"), TEXT("App"),
     ICON, 48,91,8,8, TRUE, KMODIFIER_TYPE, SMALL, REDRAW},


//114
	{TEXT("IDB_UPUPARW"),TEXT("IDB_UPUPARW"),TEXT("IDB_UP"),TEXT("{UP}"),
     BITMAP, 48,100,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x48,0x00,0x00}},

//115
	{TEXT("IDB_DNUPARW"),TEXT("IDB_DNDNARW"),TEXT("IDB_DOWN"),TEXT("{DOWN}"),
     BITMAP, 48,109,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x50,0x00,0x00}},

//116
	{TEXT("IDB_LFUPARW"),TEXT("IDB_LFDNARW"),TEXT("IDB_LEFT"),TEXT("{LEFT}"),
     BITMAP, 48,118,8,8, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4B,0x00,0x00}},

//117
    {TEXT("IDB_RHUPARW"),TEXT("IDB_RHDNARW"),TEXT("IDB_RIGHT"),TEXT("{RIGHT}"),
     BITMAP,48,127, 8,9, FALSE, KMODIFIER_TYPE, SMALL, NREDRAW, 1,
     {0xE0,0x4D,0x00,0x00}},

	};

/**************************************************************************/
// FUNCTIONS in Other FILEs
/**************************************************************************/
LRESULT WINAPI kbMainWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI kbKeyWndProc (HWND hwndKey, UINT message, WPARAM wParam, LPARAM lParam);
void SendErrorMessage(UINT id_string);

/****************************************************************************/
/* Global Vars */
/****************************************************************************/
TCHAR szKbMainClass[] = TEXT("OSKMainClass") ;
extern BOOL settingChanged;

/****************************************************************************/
/* BOOL InitProc(void) */
/****************************************************************************/
BOOL InitProc(void)
{	
	// How many keys we have.
	lenKBkey = sizeof(KBkey)/sizeof(KBkey[0]);
    return TRUE;
}

/****************************************************************************/
/* BOOL RegisterWndClass(void) */
/****************************************************************************/
BOOL RegisterWndClass(HINSTANCE hInst)
{
	WNDCLASS wndclass;

	// Keyboard frame class
	wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	wndclass.lpfnWndProc   = kbMainWndProc ;
	wndclass.cbClsExtra    = 0 ;
	wndclass.cbWndExtra    = 0 ;
	wndclass.hInstance     = hInst;
	wndclass.hIcon         = LoadIcon (hInst, TEXT("APP_OSK"));
	wndclass.hbrBackground = (HBRUSH)(COLOR_MENUHILIGHT+1);
	wndclass.lpszMenuName  = TEXT("IDR_MENU");
	wndclass.lpszClassName = szKbMainClass ;

	// Load the system hand cursor or use our own if not available

	wndclass.hCursor = LoadCursor (NULL, IDC_HAND);
	if (!wndclass.hCursor)
	{
		wndclass.hCursor = LoadCursor (hInst, MAKEINTRESOURCE(IDC_CURHAND1));
	}

	RegisterClass(&wndclass);

	return RegisterKeyClasses(hInst);
} 

BOOL RegisterKeyClasses(HINSTANCE hInst)
{
	WNDCLASS    wndclass, wndclassT;
	TCHAR		Wclass[10];
	int			i;
	COLORREF    color;

	// Key class
	wndclass.cbClsExtra    = 0 ;
	wndclass.hInstance     = hInst;
	wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
	wndclass.lpfnWndProc   = kbKeyWndProc ;
	wndclass.cbWndExtra    = sizeof (long);
    wndclass.hIcon         = NULL;
	wndclass.hbrBackground = (HBRUSH)COLOR_INACTIVECAPTION;
	wndclass.lpszMenuName  = NULL;

	// Load the system hand cursor or use our own if not available

	wndclass.hCursor = LoadCursor (NULL, IDC_HAND);
	if (!wndclass.hCursor)
	{
		wndclass.hCursor = LoadCursor (hInst, MAKEINTRESOURCE(IDC_CURHAND1));
	}

	// Register class types for each type of key.  The reason for so many classes
	// is that the background color for each key is stored in the extra class
	// memory.  This is a hack and really should be handled differently. 
	
	for (i = 1; i < lenKBkey; i++)
	{
		BOOL fSkip = FALSE;
		switch (KBkey[i].ktype)
		{
			case KNORMAL_TYPE:		 wsprintf(Wclass, TEXT("N%d"), i); color = COLOR_MENU;   break;
			case KMODIFIER_TYPE:	 wsprintf(Wclass, TEXT("M%d"), i); color = COLOR_INACTIVECAPTION; break;
			case KDEAD_TYPE:		 wsprintf(Wclass, TEXT("D%d"), i); color = COLOR_INACTIVECAPTION; break;
			case NUMLOCK_TYPE:		 wsprintf(Wclass, TEXT("NL%d"),i); color = COLOR_INACTIVECAPTION; break;
			case SCROLLOCK_TYPE:	 wsprintf(Wclass, TEXT("SL%d"),i); color = COLOR_INACTIVECAPTION; break;
			case LED_NUMLOCK_TYPE:	 wsprintf(Wclass, TEXT("LN%d"),i); color = COLOR_BTNSHADOW; break;
			case LED_CAPSLOCK_TYPE:	 wsprintf(Wclass, TEXT("LC%d"),i); color = COLOR_BTNSHADOW; break;
			case LED_SCROLLLOCK_TYPE:wsprintf(Wclass, TEXT("LS%d"),i); color = COLOR_BTNSHADOW; break;
			default: fSkip = TRUE; break;	// internal error!
		}

		// only call RegisterClass if there's one to do and it isn't already registered

		if (!fSkip && !GetClassInfo(hInst, Wclass, &wndclassT))
		{
			wndclass.hbrBackground = (HBRUSH)IntToPtr(color + 1);
			wndclass.lpszClassName = Wclass ;
			RegisterClass (&wndclass);
		}
	}

	return TRUE;
}

extern BOOL  Setting_ReadSuccess;      //read the setting file success ?

/****************************************************************************/
/*  HWND CreateMainWindow(void) */
/****************************************************************************/
HWND CreateMainWindow(BOOL re_size)
{
	int x, y, cx, cy, temp;
	TCHAR  szTitle[256]=TEXT("");
	int KB_SMALLRMARGIN= 137;

	// SmallMargin for Actual / Block layout
	if(kbPref->Actual)
		KB_SMALLRMARGIN = 137;  //Actual
	else
		KB_SMALLRMARGIN = 152;  //Block


	if(!Setting_ReadSuccess)       //if can't read the setting file
	{	
        g_margin = scrCX / KB_LARGERMARGIN;

		if(g_margin < 4)
		{
			g_margin = 4;
			smallKb = TRUE;
			cx = KB_SMALLRMARGIN * g_margin;
		}
		else
        {
			cx = KB_LARGERMARGIN * g_margin;
        }

		temp = scrCY - 5;          // 5 units from the bottom
		y = temp - (g_margin * KB_CHARBMARGIN) - captionCY; //- menuCY;
		x = 5;                     // 5 units from the left
		cy = temp - y;
    } 
    else
    {
        x  = kbPref->KB_Rect.left;
        y  = kbPref->KB_Rect.right;
        cx = kbPref->KB_Rect.right - kbPref->KB_Rect.left;
        cy = kbPref->KB_Rect.bottom - kbPref->KB_Rect.top;
    }

    //*********************************
    //Create the main window (Keyboard)
    //*********************************
	
    LoadString(hInst, IDS_TITLE1, &szTitle[0], 256);

    return CreateWindowEx(WS_EX_NOACTIVATE|WS_EX_APPWINDOW/*WS_EX_LTRREADING*/, 
						szKbMainClass, 
                        szTitle,
                        WS_CAPTION|WS_BORDER|WS_MINIMIZEBOX|WS_SYSMENU,
                        x, y, 
                        cx, cy,
                        NULL, NULL, 
                        hInst, NULL);
}

/*****************************************************************************
* void mlGetSystemParam( void)
*
* GET SYSTEM PARAMETERS
*****************************************************************************/
void mlGetSystemParam(void)
{
	scrCX 		= GetSystemMetrics(SM_CXSCREEN);       // Screen Width
	scrCY 		= GetSystemMetrics(SM_CYSCREEN);       // Screen Height
	captionCY 	= GetSystemMetrics(SM_CYCAPTION);		// Caption Bar Height
} 

/****************************************************************************/
/* BOOL SetZOrder - Place the main window always on top / non top most
/****************************************************************************/
BOOL SetZOrder(void)
{
	HWND hwnd = (PrefAlwaysontop == TRUE)?HWND_TOPMOST:HWND_NOTOPMOST;
	SetWindowPos(g_hwndOSK, hwnd, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
	return TRUE;
}

/********************************************************************
* udfDraw3Dpush(HDC hdc, RECT rect)
*
* 3d effect when pushing buttons
********************************************************************/

void udfDraw3Dpush(HDC hdc, RECT brect)
{
	POINT bPoint[3];
	HPEN oldhpen;
	LOGPEN lpPen = { PS_SOLID, 2, 2, RGB(255,0,0) };
	HPEN hPen = CreatePenIndirect(&lpPen);

	if (!hPen)
		return;	// PREFIX #113804 NULL pointer reference 

	oldhpen = SelectObject(hdc, hPen);

	bPoint[0].x = brect.right - 1 ;
	bPoint[0].y =  +2;
	bPoint[1].x = brect.right - 1;
	bPoint[1].y = brect.bottom - 1;
	bPoint[2].x =  0;
	bPoint[2].y = brect.bottom - 1;
	Polyline(hdc, bPoint,3);

	bPoint[0].x =  1 ;
	bPoint[0].y =  brect.bottom;
	bPoint[1].x = 0;
	bPoint[1].y = 0;
	bPoint[2].x =  brect.right;
	bPoint[2].y = 1;
	Polyline(hdc, bPoint,3);

	SelectObject(hdc, oldhpen);
	DeleteObject(hPen);
}

/********************************************************************
/* UpdateKey - update a key's text and background
/********************************************************************/

void UpdateKey(HWND hwndKey, HDC hdc, RECT brect, int iKey, int iKeyVal)
{
    LPTSTR     pszText;
    KBkeyRec   *pKey = KBkey + iKey;
	HFONT      hFont = NULL;
	int        iCharWidth, iCharHeight, cchText;
	int        px, py, iPrevBkMode;
    TEXTMETRIC tm;

    pszText = pKey->apszKeyStr[ GetModifierState() ];

	if (!pszText)
	{
		DBPRINTF(TEXT("UpdateKey:  key %d has null text!\r\n"), iKey);
		return;	// internal error!
	}

    // Set a font

	cchText = lstrlen(pszText);

	hFont = ReSizeFont(iKey, plf, cchText);
    if (NULL != hFont)
    {
    	oldFontHdle = SelectObject(hdc, hFont);
    }

	iPrevBkMode = SetBkMode(hdc, TRANSPARENT);

	// Set a text color

	if (iKeyVal == 4)
	{
        // color of most keys
        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT)); // always white
		iKeyVal = 0;
	}
    else if (  pKey->ktype == KMODIFIER_TYPE 
            || pKey->ktype == NUMLOCK_TYPE 
            || pKey->ktype == SCROLLOCK_TYPE
			|| pKey->ktype == KDEAD_TYPE)
	{
        // color of keys text that can be latched or are modifiers
		BOOL clr = (BOOL)GetWindowLongPtr(hwndKey, GWLP_USERDATA_TEXTCOLOR);
		SetTextColor(hdc, clr? GetSysColor(COLOR_INACTIVECAPTION) : GetSysColor(COLOR_INACTIVECAPTIONTEXT));
	}
    else
    {
        // all other keys text color
		SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    }

    // More font stuff based on the key char

	GetTextMetrics(hdc, &tm);
	iCharHeight = tm.tmHeight + tm.tmExternalLeading;
	iCharWidth = tm.tmAveCharWidth * cchText;

	px =(int) (((float)((brect.right -brect.left) - iCharWidth + 0) / 2.0) +
               ((float)(tm.tmAveCharWidth * iKeyVal)/3.0));

	py =(int) (((float)((brect.bottom -brect.top) - iCharHeight) / 1.5));

    // Special case, these letters are fatter

    switch (*pszText)
    {
        case 'W': px -= 2; break;
        case 'M': px -= 1; break;
        case 'm': px -= 1; break;
        case '%': px -= 3; break;
    }

	// put the text on the key

	TextOut(hdc, px, py, pszText, cchText);
	SetBkMode(hdc, iPrevBkMode);

    // some state that needs to be saved

	if((Prefusesound == TRUE) && (iKeyVal != 4))
    {
		if(iKeyVal != 0)
        {
			s_fLastDown = TRUE;
        }
		else if((iKeyVal == 0) && (s_fLastDown == TRUE))
        {
			s_fLastDown = FALSE;
        }
    }

	SelectObject(hdc, oldFontHdle);
	if (hFont)	// PREFIX #113808 NULL pointer reference
    {
		DeleteObject(hFont);
    }

    return;
}

/****************************************************************************/
//Redraw the num lock key.
//Toggole it stay hilite or off
/****************************************************************************/
BOOL RedrawNumLock(void)
{	
	int i;
	int bRet = FALSE;

	for(i=1; i<lenKBkey; i++)
	{	
		if(KBkey[i].ktype == NUMLOCK_TYPE)
		{
			if(LOBYTE(GetKeyState(VK_NUMLOCK)) &0x01)   //Toggled (ON)
			{
				SetWindowLong(lpkeyhwnd[i], 0, 4);	
				SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 1);
				bRet = TRUE;
			}
			else
			{	SetWindowLong(lpkeyhwnd[i], 0, 0);
                SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);	
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 0);
				bRet = FALSE;
			}
			
			InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
			
			break;
		}
	}
	return bRet;
}
/****************************************************************************/
//Redraw the scroll lock key.
//Toggole it stay hilite or off
/****************************************************************************/
BOOL RedrawScrollLock(void)
{	
	int i;
	int bRet = FALSE;

	for(i=1; i<lenKBkey; i++)
	{	if(KBkey[i].ktype == SCROLLOCK_TYPE)
		{
			if(LOBYTE(GetKeyState(VK_SCROLL)) &0x01)   //Toggled (ON)
			{
				SetWindowLong(lpkeyhwnd[i], 0, 4);	
				SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 1);
				bRet = TRUE;
			}
			else
			{	SetWindowLong(lpkeyhwnd[i], 0, 0);
                SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);	
    			SetWindowLongPtr(lpkeyhwnd[i],  GWLP_USERDATA_TEXTCOLOR, 0);
				bRet = FALSE;
			}
			
			InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
			
			break;
		}
	}
	return bRet;
}
/****************************************************************************/

HFONT	ReSizeFont(int iKey, LOGFONT *plf, int cchText)
{
	static int    FontHeight=-12;
	static float  Scale=1.0;
	static float  UpRatio=0.0, DnRatio=0.0;

    HFONT    hFont=NULL;        // Handle of the selected font
	LOGFONT  smallLF;
	float    Scale1=0.0;
	int      delta=0;
	RECT     rect;

	//use smaller font
	if(cchText >= 2 && KBkey[iKey].ktype != KMODIFIER_TYPE && iKey !=30 && iKey != 38 && iKey !=71 )
	{
		GetClientRect(g_hwndOSK, &rect);
		Scale1= (float)(rect.right - rect.left);

		if(Scale1/Scale >= UpRatio)
			delta= -2;
		else if(Scale1/Scale <= DnRatio)
			delta= +2;

		smallLF.lfHeight= FontHeight +2;       // + delta;
		smallLF.lfWidth= 0;
		smallLF.lfEscapement= 0;
		smallLF.lfOrientation= 0;
		smallLF.lfWeight= 700;
		smallLF.lfItalic= '\0';
		smallLF.lfUnderline= '\0';
		smallLF.lfStrikeOut= '\0';
		smallLF.lfCharSet= plf->lfCharSet;  // '\0'
		smallLF.lfOutPrecision= '\x01';
		smallLF.lfClipPrecision= '\x02';
		smallLF.lfQuality= '\x01';
		smallLF.lfPitchAndFamily= DEFAULT_PITCH || FF_DONTCARE;  //'"';

        lstrcpy(smallLF.lfFaceName, plf->lfFaceName);

		hFont = CreateFontIndirect(&smallLF);

		return hFont;
	}
	else if(newFont == TRUE)
	{	
        hFont = CreateFontIndirect(plf);
		return hFont;
	}
    return hFont;
}


/**********************************************************************/
/*  BOOL ChooseNewFont( HWND hWnd )*/
/**********************************************************************/
BOOL ChooseNewFont(HWND hWnd)
{
	CHOOSEFONT   chf;

	chf.hDC = NULL;
	chf.lStructSize = sizeof(CHOOSEFONT);
	chf.hwndOwner = NULL;    
	chf.lpLogFont = plf;
	chf.Flags = CF_SCREENFONTS | CF_FORCEFONTEXIST | CF_INITTOLOGFONTSTRUCT;
	chf.rgbColors = 0;
	chf.lCustData = 0;
	chf.hInstance = (HANDLE)hInst;
	chf.lpszStyle = (LPTSTR)NULL;
	chf.nFontType = SCREEN_FONTTYPE;
	chf.nSizeMin = 0;
	chf.nSizeMax = 14;
	chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)NULL;
	chf.lpTemplateName = (LPTSTR)NULL;

	if( ChooseFont(&chf) == FALSE )
    {
		return FALSE;
    }

	newFont = TRUE;

    kbPref->lf.lfHeight      = plf->lfHeight;
    kbPref->lf.lfWidth       = plf->lfWidth;
    kbPref->lf.lfEscapement  = plf->lfEscapement;
    kbPref->lf.lfOrientation = plf->lfOrientation;
    kbPref->lf.lfWeight      = plf->lfWeight;
    kbPref->lf.lfItalic      = plf->lfItalic;
    kbPref->lf.lfUnderline   = plf->lfUnderline;
    kbPref->lf.lfStrikeOut   = plf->lfStrikeOut;
    kbPref->lf.lfCharSet     = plf->lfCharSet;
    kbPref->lf.lfOutPrecision  = plf->lfOutPrecision;
    kbPref->lf.lfClipPrecision = plf->lfClipPrecision;
    kbPref->lf.lfQuality       = plf->lfQuality;
    kbPref->lf.lfPitchAndFamily= plf->lfPitchAndFamily;

#ifdef UNICODE
    wsprintfA(kbPref->lf.lfFaceName, "%ls", plf->lfFaceName);
#else
    wsprintfA(kbPref->lf.lfFaceName, "%hs", plf->lfFaceName);
#endif

	return (TRUE);
}

/**********************************************************************/
/*  BOOL RDrawIcon
/**********************************************************************/
BOOL RDrawIcon(HDC hDC, TCHAR *pIconName, RECT rect)
{
	HICON hIcon;
	BOOL iret;
    int rx, ry, Ox, Oy;

    rx = rect.right - rect.left;
    ry = rect.bottom - rect.top;

    hIcon = LoadImage(hInst, pIconName, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE|LR_SHARED);

	if(hIcon == NULL)
	{
		SendErrorMessage(IDS_CANNOT_LOAD_ICON);
		return FALSE;
	}

	SetMapMode(hDC,MM_TEXT);

    //Find out where is the top left corner to place the icon

    Ox = (int)(rx/2) - 16;
    Oy = (int)(ry/2) - 16;

    //Draw the icon (Draw in center)
    iret = DrawIconEx(hDC, Ox, Oy, hIcon, 0,0,0, NULL, DI_NORMAL);

	return iret;
}

/**********************************************************************/
/*  BOOL RDrawBitMap
/**********************************************************************/
BOOL RDrawBitMap(HDC hDC, TCHAR *pIconName, RECT rect, BOOL transform)
{
	HBITMAP hBitMap;
	BOOL iret;
    SIZE sz;
	HDC hDC1;
    int rx, ry, ix, iy;
	DWORD err;
	COLORREF clrIn, clrTx;

    ix = 0;
    iy = 0;
    rx = rect.right - rect.left;
    ry = rect.bottom - rect.top;
    if (!PrefScanning)
    {
        ix  = 2;
        iy  = 2;
        rx -= 4;
        ry -= 4;
    }
	
	SetMapMode(hDC,MM_TEXT);

	clrIn = GetSysColor(COLOR_INACTIVECAPTION);
	clrTx = GetSysColor(COLOR_INACTIVECAPTIONTEXT);

	iret = FALSE;
	hBitMap = LoadImage(hInst, pIconName, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE );
    if (hBitMap)
    {
	    if ( transform )
	    {
		    // convert the background and text to match inactive title
		    // and inactive text color

		    // Take care not to overwrite each other and also skip if you don't need any transformation.

		    if ( clrIn == RGBWHITE )
		    {
			    // Then reverse the process
			    ChangeBitmapColor (hBitMap, RGBWHITE, clrTx, NULL);
			    ChangeBitmapColor (hBitMap, RGBBACK, clrIn, NULL);
		    }
		    else
		    {
			    if ( RGBBACK != clrIn)
				    ChangeBitmapColor (hBitMap, RGBBACK, clrIn, NULL);

			    if ( RGBWHITE != clrTx)
				    ChangeBitmapColor (hBitMap, RGBWHITE, clrTx, NULL);
		    }
	    }

	    hDC1 = CreateCompatibleDC(hDC);
	    if (hDC1)	// PREFIX #113799 null pointer reference
	    {
		    HBITMAP hBitMapOld = SelectObject(hDC1, hBitMap);

		    iret = StretchBlt(hDC, ix, iy, rx, ry, hDC1, 0, 0, rx, ry, SRCCOPY);

            SelectObject(hDC1, hBitMapOld);
		    DeleteDC(hDC1);
	    }

        DeleteObject(hBitMap);
    }

	return iret;
}

/**************************************************************************/
/* void DeleteChildBackground(void)                                           */
/**************************************************************************/
void DeleteChildBackground(void)
{
	register int i;

	for (i = 1; i < lenKBkey; i++)
	{
		switch (KBkey[i].ktype)
		{
			case KNORMAL_TYPE:
				SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
				break;
			
			case NUMLOCK_TYPE:
			case KMODIFIER_TYPE:
			case SCROLLOCK_TYPE:
			case KDEAD_TYPE:
				SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);
				break;
			
			case LED_NUMLOCK_TYPE:
			case LED_CAPSLOCK_TYPE:
			case LED_SCROLLLOCK_TYPE:
				SetBackgroundColor(lpkeyhwnd[i], COLOR_BTNSHADOW);
				break;
		}
	}
}

/*****************************************************************************/
//Redraw the keys when Shift/Cap being pressed or released
/*****************************************************************************/
void RedrawKeys(void)
{
	KBkeyRec *pKey;
	int  i, nKeyState;

	// Depending on modifier key states, show one of three keyboards.

    nKeyState = GetModifierState();

	for (i = 1, pKey = KBkey+i; i < lenKBkey; i++, pKey++)
	{
		if (pKey->Caps_Redraw != REDRAW)
			continue;	// skip keys that don't redraw

		// Restore dead key type and background

		if (pKey->ktype == KDEAD_TYPE)
		{
			SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
			pKey->ktype = KNORMAL_TYPE;
		}

		// Set a new key type based on the current keyboard state

        pKey->ktype = pKey->abKeyType[ nKeyState ];


		// update dead key background

		if (pKey->ktype == KDEAD_TYPE)
		{
			SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);
		}

		// Do the redraw

        InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
    }
}

/*****************************************************************************/
//Redraw the Num Pad Keys
/*****************************************************************************/
void RedrawNumPadKeys(void)
{	
	register int i;

	for (i = 1; i < lenKBkey; i++)
	{
		if(KBkey[i].print==3)
		{
			InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
		}
	}
}

/*****************************************************************************/
//Round the coner of each key
/*****************************************************************************/
void SetKeyRegion(HWND hwnd, int w, int h)
{	
	HRGN hRgn = CreateRoundRectRgn(1, 1, w, h, 5, 2);
	SetWindowRgn(hwnd, hRgn, TRUE);
}

// Bitmap transformation
void ChangeBitmapColor(HBITMAP hbmSrc, COLORREF rgbOld, COLORREF rgbNew, HPALETTE hPal)
{
	HDC hDC;
	HDC hdcMem;
	PBITMAP bmBits;
    HBITMAP hbmOld;
	DWORD err;
	bmBits = (LPBITMAP)LocalAlloc(LMEM_FIXED, sizeof(*bmBits));

	if (hDC = GetDC(NULL))
	{
		if (hdcMem = CreateCompatibleDC(hDC))
		{
			//
			// Get the bitmap struct needed by ChangeBitmapColorDC()
			//
			GetObject(hbmSrc, sizeof(*bmBits), (LPBITMAP)bmBits);

			err = GetLastError();
			//
			// Select our bitmap into the memory DC
			//
			hbmOld = (HBITMAP) SelectObject(hdcMem, hbmSrc);

			// Select in our palette so our RGB references will come
			// out correctly

			if (hPal) 
			{
				SelectPalette(hdcMem, hPal, FALSE);
				RealizePalette(hdcMem);
			}

			ChangeBitmapColorDC(hdcMem, bmBits, rgbOld, rgbNew);

			//
			// Unselect our bitmap before deleting the DC
			//
			hbmSrc = (HBITMAP) SelectObject(hdcMem, hbmOld);

			DeleteDC(hdcMem);
		}

		ReleaseDC(NULL, hDC);
	}
	LocalFree(bmBits);
}

void ChangeBitmapColorDC (HDC hdcBM, LPBITMAP lpBM, COLORREF rgbOld, COLORREF rgbNew)
{
	HDC hdcMask;
	HBITMAP hbmMask, hbmOld;
	HBRUSH hbrOld, hbrNew;

	if (!lpBM)
		return;

	//
	// if the bitmap is mono we have nothing to do
	//

	if (lpBM->bmPlanes == 1 && lpBM->bmBitsPixel == 1)
		return;

   //
   // To perform the color switching, we need to create a monochrome
   // "mask" which is the same size as our color bitmap, but has all
   // pixels which match the old color (rgbOld) in the bitmap set to 1.
   //
   // We then use the ROP code "DSPDxax" to Blt our monochrome
   // bitmap to the color bitmap.  "D" is the Destination color
   // bitmap, "S" is the source monochrome bitmap, and "P" is the
   // selected brush (which is set to the replacement color (rgbNew)).
   // "x" and "a" represent the XOR and AND operators, respectively.
   //
   // The DSPDxax ROP code can be explained as having the following
   // effect:
   //
   // "Every place the Source bitmap is 1, we want to replace the
   // same location in our color bitmap with the new color.  All
   // other colors we leave as is."
   //
   // The truth table for DSPDxax is as follows:
   //
   //       D S P Result
   //       - - - ------
   //       0 0 0   0
   //       0 0 1   0
   //       0 1 0   0
   //       0 1 1   1
   //       1 0 0   1
   //       1 0 1   1
   //       1 1 0   0
   //       1 1 1   1
   //
   // (Even though the table is assuming monochrome D (Destination color),
   // S (Source color), & P's (Pattern color), the results apply to color
   // bitmaps also).
   //
   // By examining the table, every place that the Source is 1
   // (source bitmap contains a 1), the result is equal to the
   // Pattern at that location.  Where S is zero, the result equals
   // the Destination.
   //
   // See Section 11.2 (page 11-4) of the "Reference -- Volume 2" for more
   // information on the Termary Raster Operation codes.
   //


   // bit maps are actually 32 by 32 pixels.  The height and width here were coming from the font which does not
   // apply to a bitmap key.  The keys in question here are the arrow keys.
   lpBM->bmWidth = 32;
   lpBM->bmHeight = 32;
   
   if (hbmMask = CreateBitmap(lpBM->bmWidth, lpBM->bmHeight, 1, 1, NULL))
   {
   
      if (hdcMask = CreateCompatibleDC(hdcBM))
      {
		 //
		 // Select th mask bitmap into the mono DC
		 //
         hbmOld = (HBITMAP) SelectObject(hdcMask, hbmMask);

         //
         // Create the brush and select it into the source color DC --
         // this is our "Pattern" or "P" color in our DSPDxax ROP.
         //

         hbrNew = CreateSolidBrush(rgbNew);
         hbrOld = (HBRUSH) SelectObject(hdcBM, hbrNew);
         //
         // To create the mask, we will use a feature of BitBlt -- when
         // converting from Color to Mono bitmaps, all Pixels of the
         // background colors are set to WHITE (1), and all other pixels
         // are set to BLACK (0).  So all pixels in our bitmap that are
         // rgbOld color, we set to 1.
         //

         SetBkColor(hdcBM, rgbOld);
         BitBlt(hdcMask, 0, 0, lpBM->bmWidth, lpBM->bmHeight, hdcBM, 0, 0, SRCCOPY);

         //
         // Where the mask is 1, lay down the brush, where it is 0, leave
         // the destination.
         //

         SetBkColor(hdcBM, RGBWHITE);
         SetTextColor(hdcBM, RGBBLACK);

         BitBlt(hdcBM, 0, 0, lpBM->bmWidth, lpBM->bmHeight, hdcMask, 0, 0, DSPDxax);

         SelectObject(hdcMask, hbmOld); // select old bitmaps and brushes 
         SelectObject(hdcBM, hbrOld);   // back into device contexts.

         if (hbrNew)
             DeleteObject(hbrNew);	// PREFIX #113798 dereference NULL pointer

         DeleteDC(hdcMask);
      }

      DeleteObject(hbmMask);
   }
}

//
// New routines added to refresh key labels when the keyboard layout changes 
// for the active window rather than trying to do that on-the-fly.  The old
// way caused lots of issues with dead key processing.
//

//
// InitKeys - initialize the key label fields in the keyboard array
//
void InitKeys()
{
    int i;
	KBkeyRec *pKey;

    for (i=1, pKey = &KBkey[1];i<lenKBkey;i++, pKey++)
    {
        int j;
        for (j=0;j<3;j++)
        {
            pKey->apszKeyStr[j] = NULL;
        }
    }
}

//
// UninitKeys - reset/free the key label fields in the keyboard array
//
void UninitKeys()
{
    int i, j;
	KBkeyRec *pKey;

	for (i = 1, pKey = KBkey+i; i < lenKBkey; i++, pKey++)
    {
		// reset the dead key types and restore the background to normal

		if (pKey->ktype == KDEAD_TYPE)
		{
			SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
			pKey->ktype = KNORMAL_TYPE;
		}

        for (j=0;j<3;j++)
        {
            if (pKey->apszKeyStr[j])
            {
                free(pKey->apszKeyStr[j]);
                pKey->apszKeyStr[j] = NULL;
            }
        }
    }
}

//
// UpdateKeyLabels - Call to refresh all the key labels for normal, SHIFTED and
//                   ALTGR based on the specified hardware keyboard layout.
//
// Notes:  Just a bit kludgy, but we capture all the dead keys into abKeyType[]
//         and when the keyboard state changes we'll update the ktype member
//
void UpdateKeyLabels(HKL hkl)
{
    int i;
    KBkeyRec *pKey;
    BYTE achKbdState[256] = {0};
	LPTSTR pszDefLabel;

	g_cAltGrKeys = 0;
    for (pKey=&KBkey[1], i=1;i<lenKBkey;pKey++, i++)
    {
        int  iRv;
        UINT vk;

        if (pKey->Caps_Redraw != REDRAW)
		{
			pKey->abKeyType[KEYMOD_NORMAL]   = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_NORMAL]  = CopyDefKey(pKey->textL);

			pKey->abKeyType[KEYMOD_SHIFTED]  = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_SHIFTED] = CopyDefKey(pKey->textC);

			pKey->abKeyType[KEYMOD_CAPSLOCK]  = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_CAPSLOCK] = CopyDefKey(pKey->textC);

			pKey->abKeyType[KEYMOD_SHIFTEDCAPSLOCK]  = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_SHIFTEDCAPSLOCK] = CopyDefKey(pKey->textC);

			pKey->abKeyType[KEYMOD_ALTGR]    = (BYTE)pKey->ktype;
			pKey->apszKeyStr[KEYMOD_ALTGR]   = CopyDefKey(pKey->textL);
			continue;
		}

        // if not flagged to use default label get virtual key code

        vk = (pKey->print == 2)? 0 : MapVirtualKeyEx(pKey->scancode[0], 3, hkl);

        // Get normal state (no modifiers down)

        achKbdState[VK_CAPITAL] = 0;
        achKbdState[VK_SHIFT]   = 0;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_NORMAL] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textL, &iRv);
        if (iRv < 0)
        {
			pKey->abKeyType[KEYMOD_NORMAL] = KDEAD_TYPE;
            pKey->ktype = KDEAD_TYPE;
        }
		else
		{
			pKey->abKeyType[KEYMOD_NORMAL] = (BYTE)pKey->ktype;
		}

        // Get SHIFTED state (SHIFT down)

        achKbdState[VK_CAPITAL] = 0;
        achKbdState[VK_SHIFT]   = 0x80;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_SHIFTED] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textC, &iRv);
		pKey->abKeyType[KEYMOD_SHIFTED] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

        // Get CAPSLOCK state (CAPSLOCK active)

        achKbdState[VK_CAPITAL] = 0x01;
        achKbdState[VK_SHIFT]   = 0;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_CAPSLOCK] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textC, &iRv);
		pKey->abKeyType[KEYMOD_CAPSLOCK] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

        // Get SHIFTED-CAPSLOCK state (CAPSLOCK active, SHIFT down)

        achKbdState[VK_CAPITAL] = 0x01;
        achKbdState[VK_SHIFT]   = 0x80;
        achKbdState[VK_MENU]    = 0;
        achKbdState[VK_CONTROL] = 0;

        pKey->apszKeyStr[KEYMOD_SHIFTEDCAPSLOCK] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pKey->textC, &iRv);
		pKey->abKeyType[KEYMOD_SHIFTEDCAPSLOCK] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

        // Get ALTGR state (right ALT down same as LALT+CTRL)

        achKbdState[VK_CAPITAL] = 0;
        achKbdState[VK_SHIFT]   = 0;
        achKbdState[VK_MENU]    = 0x80;
        achKbdState[VK_CONTROL] = 0x80;

		// special-case showing the RALT key when in ALTGR keyboard state
		pszDefLabel = (pKey->name == KB_RALT)?pKey->textL:NULL;

        pKey->apszKeyStr[KEYMOD_ALTGR] = SetKeyText(vk, pKey->scancode[0], achKbdState, hkl, pszDefLabel, &iRv);
		pKey->abKeyType[KEYMOD_ALTGR] = (iRv < 0)?KDEAD_TYPE:pKey->abKeyType[KEYMOD_NORMAL];

		// count the ALTGR keys so we know whether to show this state or not

		if (iRv != 0)
		{
			g_cAltGrKeys++;
		}
    }
}

// 
// The following are called w/in this source file
//

//
// SetKeyText - set a key label for a key using the default label if GetKeyLabel doesn't set one. 
//
LPTSTR SetKeyText(UINT vk, UINT sc, LPBYTE achKbdState, HKL hkl, LPTSTR pszDefLabel, int *piType)
{
    TCHAR szBuf[30];
    LPTSTR psz;
    LPTSTR pszRet = 0;
    int iRet = GetKeyLabel(vk, sc, achKbdState, szBuf, ARRAY_SIZE(szBuf), hkl);

    if (!piType)
        return 0;

    // szBuf is set if there is text or for a dead key else if a 
    // default label was supplied use that else the key is blank

    if (iRet || iRet < 0)
    {
        psz = szBuf;
    }
    else 
    {
        if (pszDefLabel && *pszDefLabel)
        {
            psz = pszDefLabel;
        }
        else
        {
            psz = szBuf;
        }
    }

    pszRet = (LPTSTR)malloc((lstrlen(psz)+1)*sizeof(TCHAR));
    if (pszRet)
    {
        lstrcpy(pszRet, psz);
    }

    *piType = iRet;
    return pszRet;
}

//
// CopyDefKey - set a key label for a key using the default label
//              or space if there isn't one.
//
LPTSTR CopyDefKey(LPTSTR pszDefLabel)
{
    LPTSTR pszRet = 0;
	LPTSTR pszSpace = TEXT(" ");
	LPTSTR psz = pszSpace;

    if (pszDefLabel && *pszDefLabel)
    {
		psz = pszDefLabel;
    } 

    pszRet = (LPTSTR)malloc((lstrlen(psz)+1) * sizeof(TCHAR));
    if (pszRet)
    {
        lstrcpy(pszRet, psz);
    }

    return pszRet;
}

//
// GetKeyLabel - set a label for a key based on hardware keyboard layout, 
//               the virtual key code, and scan code
//
int GetKeyLabel(UINT vk, UINT sc, LPBYTE achKbdState, LPTSTR pszBuf, int cchBuf, HKL hkl)
{
    int iRet, cch;

#ifdef UNICODE

    iRet = ToUnicodeEx(vk, sc | 0x80, achKbdState, pszBuf, cchBuf, 0, hkl);
    if (iRet < 0)
    {
        // it is possible to have previous dead key, flush again.
        ToUnicodeEx(vk, sc | 0x80, achKbdState, pszBuf, cchBuf, 0, hkl);
    }

    cch = iRet;
#else
       // TODO ansi stuff but only if we had to backport to Win9x
#endif

    if (iRet <= 0 )
    {
        cch = 1;
        if (iRet == 0)
        {
            // no translation for this key at this shift state; set empty label.
            pszBuf[0] = TEXT(' ');
        }
    }

    pszBuf[cch] = TEXT('\0');
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\ms32dll.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// File: ms32dll.c
// Additions, Bug Fixes 1999 
// a-anilk and v-mjgran
//

#define STRICT

#include <windows.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <winable.h>
#include "kbmain.h"
#include "resource.h"
#include "kbus.h"
#include "keyrc.h"
#include "ms32dll.h"
#include "w95trace.h"

/***************************************************************************/
/*   functions not in this file              */
/***************************************************************************/
#include "scan.h"
#include "kbfunc.h"
#include "sdgutil.h"

#define DWELLTIMER 267
#define PAINTTIMER 101

int   paintlineNo = 0;
HWND  g_hwndLastMouseOver = NULL;      // handle to window under mouse
HWND  g_hwndDwellKey=NULL;            // a copy of Dwellwindow handle

HWND s_hwndCtrl=NULL;
HWND s_hwndAlt=NULL;
HWND s_hwndCaplock=NULL;
HWND s_hwndShift=NULL;
HWND s_hwndWinLogo=NULL;
BOOL SendSAS();

BOOL g_fWinKeyDown= FALSE;
BOOL g_fCtrlAltDel = FALSE;        // Ctr+Alt+Del down
BOOL g_fControlPressed = FALSE;    // Control is down
BOOL g_fDoingAltTab = FALSE;	   // LAlt+Tab 

// External variables
extern TOOLINFO		ti;
extern HWND	g_hToolTip;

int g_nMenu  = MENUKEY_NONE;  // holds menu key state
HWND g_hBitmapLockHwnd = NULL;		// CapLock when japaneese keyboard is bitmap type
HKL g_hklLast = 0;                  // the keyboard layout currently being worked with

// Functions
void SendExtendedKey(HWND hwndKey, UINT vk, UINT scanCode);
void SendFullKeyPress(UINT vk, UINT scanCode);
void SendHalfKeyPress(UINT vk, UINT scanCode, DWORD dwFlags);

__inline void ToggleAppearance(HWND hwnd, BOOL fForceUpdate)
{
	SetWindowLongPtr(hwnd, GWLP_USERDATA_TEXTCOLOR, 1);
    InvertColors(hwnd, fForceUpdate);
}

__inline void RestoreAppearance(HWND *phwnd, BOOL fForceUpdate)
{
	HWND hwndTmp = *phwnd;
	*phwnd = NULL;

	SetWindowLongPtr(hwndTmp, GWLP_USERDATA_TEXTCOLOR, 0);
    ReturnColors(hwndTmp, fForceUpdate);
}

/***************************************************************************/
/*     Functions Declaration      */
/***************************************************************************/

void DoButtonUp(HWND hwnd);
void SendAltCtrlDel();

/***************************************************************************
   IsModifierPressed - returns TRUE if hwndKey is toggled (down)
 ***************************************************************************/
BOOL IsModifierPressed(HWND hwndKey)
{
    if (!hwndKey)
        return FALSE;   // paranoia

    // return TRUE if the specified key is pressed (toggled)
	if (hwndKey == s_hwndCtrl  || hwndKey == s_hwndAlt || hwndKey == s_hwndCaplock)
        return TRUE;

    // Special case - both SHIFT keys are down if either one is pressed
    if (g_fShiftKeyDn)
    {
	    int iKey = GetWindowLong(hwndKey, GWL_ID);
        if (KBkey[iKey].name == KB_LSHIFT || KBkey[iKey].name == KB_RSHIFT)
            return TRUE;
    }

    return FALSE;
}

/***************************************************************************
   SetCapsLock - sets the caps lock hwnd
 ***************************************************************************/
void SetCapsLock(HWND hwnd) 
{ 
    s_hwndCaplock = hwnd; 
}

/***************************************************************************
   DoMenuKey - function to handle left and right alt keys
 ***************************************************************************/
void DoMenuKey(DWORD dwFlag, int nWhichMenu)
{
	INPUT	rgInput[1];

    switch (nWhichMenu)
    {
        // LMENU (aka LALT)
        case MENUKEY_LEFT:
        {
		    rgInput[0].type = INPUT_KEYBOARD;
		    rgInput[0].ki.dwExtraInfo = 0;
		    rgInput[0].ki.wVk = VK_MENU;
		    rgInput[0].ki.wScan = 0x38;
		    rgInput[0].ki.dwFlags = dwFlag;
		    SendInput(1, rgInput, sizeof(INPUT));
        }
        break;

        // RMENU (aka RALT)
        case MENUKEY_RIGHT:
        {
		    rgInput[0].type = INPUT_KEYBOARD;
		    rgInput[0].ki.dwExtraInfo = 0;
		    rgInput[0].ki.wVk = VK_RMENU;
		    rgInput[0].ki.wScan = 0x38;
		    rgInput[0].ki.dwFlags = dwFlag;
		    SendInput(1, rgInput, sizeof(INPUT));
       }
        break;

        default:
        // do nothing
        break;
    }
}

/**************************************************************************/
/* RedrawKeysOnLanguageChange - change the keyboard based on input language
/**************************************************************************/
void RedrawKeysOnLanguageChange()
{
	KBkeyRec *pKey;
    HKL hkl;

    hkl = GetCurrentHKL();
	if (g_hklLast != hkl)
	{       
		if (!ActivateKeyboardLayout(hkl, 0))
        {
			SendErrorMessage(IDS_CANNOT_SWITCH_LANG);
        }

		g_hklLast = hkl;

        // update the key labels for this new keyboard layout

		UninitKeys();
        UpdateKeyLabels(hkl);
        RedrawKeys();
	}
}

/**************************************************************************/
/* void MakeClick(int what)                                               */
/**************************************************************************/
void MakeClick(int what)
{	
	switch (what)
	{
		case SND_UP:
            PlaySound(MAKEINTRESOURCE(WAV_CLICKUP), hInst, SND_ASYNC|SND_RESOURCE);	
		    break;

		case SND_DOWN:
            PlaySound(MAKEINTRESOURCE(WAV_CLICKDN), hInst, SND_ASYNC|SND_RESOURCE);
		    break;
	}
	return;
}

/**************************************************************************/
/* void InvertColors(HWND hwnd)                                           */
/**************************************************************************/
void InvertColors(HWND hwnd, BOOL fForceUpdate)
{
	SetWindowLong(hwnd, 0, 4);
	SetBackgroundColor(hwnd, COLOR_HOTLIGHT);

    if (fForceUpdate)
    {
	    InvalidateRect(hwnd, NULL, TRUE);
    }
} 

/**************************************************************************/
/* void ReturnColors(HWND hwnd, BOOL fForceUpdate)                        */
// Repaint the key
/**************************************************************************/
void ReturnColors(HWND hwnd, BOOL fForceUpdate)
{
	int iKey;
	COLORREF selcolor;
	BOOL fReplaceColor=FALSE;       //Do some check before do redraw, save some time! :-)

	stopPaint = TRUE;

    if (!hwnd)
        return; // ignore if no hwnd

	iKey = GetWindowLong(hwnd, GWL_ID);  //order of the key in the array

	if (iKey < lenKBkey && iKey >= 0)
	{
        // Special case - don't redraw either SHIFT key if one is down
        if (g_fShiftKeyDn && (KBkey[iKey].name == KB_LSHIFT || KBkey[iKey].name == KB_RSHIFT))
        {
            return;
        }

		switch (KBkey[iKey].ktype)
		{
			case KNORMAL_TYPE:
				selcolor = COLOR_MENU;
				fReplaceColor= TRUE;
				SetWindowLong(hwnd, 0, 0);
			    break;

			case KMODIFIER_TYPE:

				if (hwnd!=s_hwndCtrl    && hwnd!=s_hwndAlt &&
					hwnd!=s_hwndCaplock && hwnd!=s_hwndWinLogo)
				{
					if (hwnd != g_hBitmapLockHwnd)
                    {
						SetWindowLong(hwnd, 0, 0);
                    }

					selcolor = COLOR_INACTIVECAPTION;
					fReplaceColor= TRUE;
				}
			    break;

			case KDEAD_TYPE:
				selcolor = COLOR_INACTIVECAPTION;
				fReplaceColor= TRUE;
				SetWindowLong(hwnd, 0, 0);
			    break;

			case NUMLOCK_TYPE:
				if (RedrawNumLock()==0)         //RedrawNumLock return 0 if NumLock is OFF
				{	
					selcolor = COLOR_INACTIVECAPTION;
					fReplaceColor= TRUE;
					SetWindowLong(hwnd, 0, 0);
				}
			    break;

			case SCROLLOCK_TYPE:
				if (RedrawScrollLock()==0)       //RedrawNumLock returns 0 if NumLock is OFF
				{	
                    selcolor = COLOR_INACTIVECAPTION;
					fReplaceColor= TRUE;
					SetWindowLong(hwnd, 0, 0);
				}
			    break;

		}
	}
	if (fReplaceColor)     //fReplaceColor TRUE = we are on KEYS or PREDICT KEYS , if true then redraw it!!
	{
		SetBackgroundColor(hwnd, selcolor);

		if (fForceUpdate == TRUE)
		{
			InvalidateRect(hwnd,NULL, TRUE);
			UpdateWindow(hwnd);
		}
	}
}

/*******************************************************************************/
/*void CALLBACK YourTimeIsOver(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)*/
/*******************************************************************************/
void CALLBACK YourTimeIsOver(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	static int lastF = -1;
	POINT pt;
	HWND temphwnd;
	int x=0;

	//Stop all the Dwell timers

	killtime();

	if (PrefDwellinkey != TRUE)
		return;

	SetWindowLong(g_hwndDwellKey,0, 0);

	// check if the mouse is over our dwellwindow

	GetCursorPos(&pt);                		// check if it is a dwelling window
	ScreenToClient(g_hwndOSK, &pt);
	temphwnd = ChildWindowFromPointEx(g_hwndOSK, pt, CWP_SKIPINVISIBLE);
	
	//If not the Dwell window, do nothing.

	if (g_hwndDwellKey != temphwnd)
	{
		if (g_hwndDwellKey != NULL)
        {
			InvalidateRect(g_hwndDwellKey, NULL, TRUE);
        }
		return;
	}

	// Repeated 'Function keys' (f1 - f12) clicking can make a mess in the
	// "host" program.  Then.... Don't let stay over that key.

	x = GetWindowLong(g_hwndDwellKey, GWL_ID);
	if (x < 13)
	{
		if (lastF != x)
			lastF = x;
		else
			return;
	}
	else
		lastF = -1;


	//Send out the char
	SendChar(g_hwndDwellKey);

	//Redraw the key to original color
	ReturnColors(g_hwndDwellKey, FALSE);

	//Redraw the key as button up
	DoButtonUp(g_hwndDwellKey);	
	
	g_hwndDwellKey=NULL;
}

/**************************************************************************/
/* void killtime(void)                                                 	  */
/**************************************************************************/
void killtime(void)
{
    stopPaint = TRUE;

    KillTimer(g_hwndOSK, timerK1);
    timerK1 = 0;
    KillTimer(g_hwndOSK, timerK2);

    if ((Dwellwindow!= NULL) && (Dwellwindow != g_hwndOSK))
    {
	    InvalidateRect(Dwellwindow, NULL, TRUE);
    }
}

/**************************************************************************/
/* void SetTimeControl(void)                                           	  */
/**************************************************************************/
void SetTimeControl(HWND  hwnd)
{
	if (PrefDwellinkey)
    {
        int iMSec;

	    if (!Prefhilitekey)           //if not hilite key make the key black for Dwell
        {
		    InvertColors(hwnd, TRUE);
        }

        iMSec=(int)((float)PrefDwellTime * (float)1);   //1.5

	    timerK1 = SetTimer(g_hwndOSK, DWELLTIMER, iMSec, YourTimeIsOver);
	    stopPaint = FALSE;
	    PaintBucket(hwnd);
    }
}

/**************************************************************************/
/* void CALLBACK PaintTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)*/
/**************************************************************************/
void CALLBACK PaintTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	POINT pt;
    HWND hwndMouseOver;

    GetCursorPos(&pt);
    ScreenToClient(hwnd, &pt);
    hwndMouseOver = ChildWindowFromPointEx(hwnd, pt, CWP_SKIPINVISIBLE);

	if (!hwndMouseOver || hwndMouseOver == hwnd)
	{
		killtime();
		ReturnColors(Dwellwindow, TRUE);
	}

	if (stopPaint == TRUE)
		return;

	SetWindowLong(Dwellwindow, 0, 5);
	InvalidateRect(Dwellwindow, NULL, FALSE);
}

/**************************************************************************/
/* void PaintBucket(void)                                             	  */
/**************************************************************************/
void PaintBucket(HWND  hwnd)
{	
    int iMSec;					// time between bucket's line

	paintlineNo = 0;

	iMSec = (int)((float)PrefDwellTime * (float)0.07);

	timerK2 = SetTimer(g_hwndOSK, PAINTTIMER, iMSec, PaintTimerProc);
}

/********************************************************************
* void PaintLine(HWND hwnd, HDC hdc, RECT rect, int Wline)
*
* Paint the bucket
********************************************************************/
void PaintLine(HWND hwnd, HDC hdc, RECT rect)
{
	POINT bPoint[3];
	HPEN oldhpen;
	HPEN hPenWhite;

	LOGPEN lpWhite = { PS_SOLID, 1, 1, RGB (255, 255, 255) };

	hPenWhite = CreatePenIndirect(&lpWhite);
	if (hPenWhite) // PREFIX #113796 don't use resource if call fails
	{
		oldhpen = SelectObject(hdc, hPenWhite);

		bPoint[0].x = 0;
		bPoint[0].y = rect.bottom -(1 * paintlineNo);
		bPoint[1].x = rect.right;
		bPoint[1].y = bPoint[0].y;
		bPoint[2].x = 0;
		bPoint[2].y = rect.bottom -(1 * paintlineNo);

		if (stopPaint != TRUE)
			Polyline(hdc, bPoint, 3);

		SelectObject(hdc, oldhpen);
		DeleteObject(hPenWhite);
	}

	paintlineNo++;
	paintlineNo++;
}

/**************************************************************************/
//Handle the Window Keys and App Key. Send out keystroke or key combination
//using SendInput.
/**************************************************************************/
void Extra_Key(HWND hwnd, int iKey)
{	UINT  scancode;
	UINT  vk;
	INPUT rgInput[3];
	static UINT s_vkWinKey;
	static UINT s_scWinKey;

	//Previous Window Key Down. Now user press char key, or Window key again
	if (g_fWinKeyDown)
	{
		g_fWinKeyDown = FALSE;

		// Re-Draw the window key
		RestoreAppearance(&s_hwndWinLogo, TRUE);
		
		// WinKey previously down; release it.
		// TODO Doesn't handle LWINKEY then RWINKEY properly.  Is there a difference between Left and Right WinKey?
		// if you key down on one and key up on the other is one key still down?

		vk = 0;
		if (!lstrcmp(KBkey[iKey].skCap,TEXT("lwin")))
		{	
			vk = VK_LWIN;
		}
		else if (!lstrcmp(KBkey[iKey].skCap,TEXT("rwin")))
		{	
			vk = VK_RWIN;
		}

		if (vk)
		{
			rgInput[0].type = INPUT_KEYBOARD;
            rgInput[0].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
            rgInput[0].ki.dwExtraInfo = 0;
            rgInput[0].ki.wVk = (WORD)vk;
            rgInput[0].ki.wScan = (WORD)MapVirtualKey(vk, 0);

			SendInput(1, rgInput,sizeof(INPUT));
		}
		else  // Window key conbination. Send (letter + Win key up)
		{
			vk = MapVirtualKey(KBkey[iKey].scancode[0],1);

			// key down
			rgInput[0].type = INPUT_KEYBOARD;
            rgInput[0].ki.dwFlags = 0;
            rgInput[0].ki.dwExtraInfo = 0;
            rgInput[0].ki.wVk = (WORD) vk;
            rgInput[0].ki.wScan = (WORD) KBkey[iKey].scancode[0];

			// key up
			rgInput[1].type = INPUT_KEYBOARD;
            rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
            rgInput[1].ki.dwExtraInfo = 0;
            rgInput[1].ki.wVk = (WORD) vk;
            rgInput[1].ki.wScan = (WORD) KBkey[iKey].scancode[0];

			// Win key up (the last one down)
			rgInput[2].type = INPUT_KEYBOARD;
            rgInput[2].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
            rgInput[2].ki.dwExtraInfo = 0;
            rgInput[2].ki.wVk = (WORD) s_vkWinKey;
            rgInput[2].ki.wScan = (WORD) s_scWinKey;

			SendInput(3, rgInput,sizeof(INPUT));
		}

		return;
	}

	// App Key down?

	if (lstrcmp(KBkey[iKey].textL,TEXT("MenuKeyUp"))==0)
	{
        SetWindowLong(hwnd,0,0);
		InvalidateRect(hwnd, NULL, TRUE);
		scancode = MapVirtualKey(VK_APPS, 0);

		//App key down
		rgInput[0].type = INPUT_KEYBOARD;
        rgInput[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY;
        rgInput[0].ki.dwExtraInfo = 0;
        rgInput[0].ki.wVk = VK_APPS;
        rgInput[0].ki.wScan = (WORD) scancode;

		//App key up
		rgInput[1].type = INPUT_KEYBOARD;
        rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP|KEYEVENTF_EXTENDEDKEY;
        rgInput[1].ki.dwExtraInfo = 0;
        rgInput[1].ki.wVk = VK_APPS;
        rgInput[1].ki.wScan = (WORD) scancode;

		SendInput(2, rgInput,sizeof(INPUT));
	
		if (Prefusesound)
		{
			MakeClick(SND_DOWN);
		}

		return;
	}

	// Left or Right WinKey down

	if (!lstrcmp(KBkey[iKey].skCap, TEXT("lwin")))
	{
		s_scWinKey= MapVirtualKey(VK_LWIN, 0);
		s_vkWinKey = VK_LWIN;
	}
	else
	{
		s_scWinKey= MapVirtualKey(VK_RWIN, 0);
		s_vkWinKey= VK_RWIN;
	}

	rgInput[0].type = INPUT_KEYBOARD;
    rgInput[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY;
    rgInput[0].ki.dwExtraInfo = 0;
    rgInput[0].ki.wVk = (WORD)s_vkWinKey;
    rgInput[0].ki.wScan = (WORD) s_scWinKey;

	SendInput(1, rgInput,sizeof(INPUT));

	g_fWinKeyDown = TRUE;
    s_hwndWinLogo = hwnd;
	InvertColors(s_hwndWinLogo, TRUE);	//Change the Win key appearance
	
	if (Prefusesound)
	{
		MakeClick(SND_DOWN);
	}
}

/**************************************************************************/
void NumPad(UINT sc, HWND hwnd)
{	
	BOOL fNumLockOn = (LOBYTE(GetKeyState(VK_NUMLOCK)) & 0x01)?TRUE:FALSE;
	switch (sc)
	{
		case 0x47:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD7:VK_HOME, sc);   break; // 7
		case 0x48:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD8:VK_UP, sc);     break; // 8
		case 0x49:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD9:VK_PRIOR, sc);  break; // 9
		case 0x4A:  SendFullKeyPress(VK_SUBTRACT, sc);                       break; // -
		case 0x4E:  SendFullKeyPress(VK_ADD, sc);                            break; // +
		case 0x4B:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD4:VK_LEFT, sc);   break; // 4
		case 0x4C:  if (fNumLockOn) { SendFullKeyPress(VK_NUMPAD5, sc); }    break; // 5
		case 0x4D:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD6:VK_RIGHT, sc);  break; // 6
		case 0x4F:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD1:VK_END, sc);    break; // 1
		case 0x50:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD2:VK_DOWN, sc);   break; // 2
		case 0x51:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD3:VK_NEXT, sc);   break; // 3
		case 0x52:  SendFullKeyPress((fNumLockOn)?VK_NUMPAD0:VK_INSERT, sc); break; // 0

		case 0x53:	// (decimal pt)
			if (fNumLockOn)
			{
				SendFullKeyPress(VK_DECIMAL, sc);
			}
			else
			{
				// User pressed Ctrl+Alt+Del?
				if (LCtrlKeyPressed() && LAltKeyPressed())
				{	
					//change back to its normal state (key up)
					RestoreAppearance(&s_hwndAlt, TRUE);
					
					//change back to its normal state (key up)
					RestoreAppearance(&s_hwndCtrl, TRUE);
					
					g_fCtrlAltDel = TRUE;
					
					SendSAS();
				}

				SendFullKeyPress(VK_DELETE, sc);
			}		
			break;
	}
	
	if (PrefDwellinkey)
	{
		InvalidateRect(hwnd, NULL, TRUE);
	}

	//Make click sound
	if (Prefusesound)
	{
		MakeClick(SND_UP);
	}
}

/**************************************************************************/
/* void SendChar - send out the char associated with hwndKey              */
/**************************************************************************/
void SendChar(HWND hwndKey)
{	
	UINT vk;
	int iKey;
	BOOL fIsExtendedKey=FALSE;
	KBkeyRec *pKey;

	static int s_cBalloonTips = 0;

	if (g_fCtrlAltDel)  //if previously press Ctrl+Alt+Del, release Alt and Ctrl keys
	{
		ReleaseAltCtrlKeys();
	}

	// If OSK has the focus and the user presses a key then
	// tell them up to three times they need to put focus on
	// some other window.

	if ((GetForegroundWindow() == g_hwndOSK) && s_cBalloonTips < 3)
	{
		POINT pt;
		GetCursorPos(&pt);   
		s_cBalloonTips++;

		SendMessage(g_hToolTip,TTM_TRACKACTIVATE,(WPARAM)TRUE,(LPARAM)&ti);
        SendMessage(g_hToolTip, TTM_TRACKPOSITION,0, (LPARAM)MAKELPARAM(pt.x+10, pt.y+10));

		SetTimer(g_hwndOSK, TIMER_HELPTOOLTIP, 4000, NULL);
	}
	else if (s_cBalloonTips)
	{
		s_cBalloonTips = 0;
		SendMessage(g_hToolTip,TTM_TRACKACTIVATE,(WPARAM)FALSE,(LPARAM)&ti);
	}

	// Get the key index from the window data

	iKey = GetWindowLong(hwndKey, GWL_ID);
	if (iKey < 0 || iKey > lenKBkey)
	{
		return;	// internal error; not in range of valid keys
	}
	pKey = &KBkey[iKey];

	// Extra Keys (Window Keys, App Key)

	if ((lstrcmp(pKey->textL,TEXT("winlogoUp"))==0) ||
        (lstrcmp(pKey->textL,TEXT("MenuKeyUp"))==0) || g_fWinKeyDown)
	{	
		Extra_Key(hwndKey, iKey);
		return;
	}

    // extended key
	if (pKey->scancode[0] == 0xE0)
	{
		// WinSE #9381 (Whistler #120346): Check for divide ext. key as well here
		if (((pKey->scancode[1] >= 0x47) &&
             (pKey->scancode[1] <= 0x53) ) ||
             (pKey->scancode[1] == 0x35) )
		{
			// Arrow keys/ Home/ End keys do special processing.

			switch (pKey->scancode[1])
			{
				case 0x35: vk = VK_DIVIDE;	break;  // Divide
				case 0x47: vk = VK_HOME;	break;  // Home
				case 0x48: vk = VK_UP;		break;  // UP
				case 0x49: vk = VK_PRIOR;	break;  // PGUP
				case 0x4B: vk = VK_LEFT;	break;  // LEFT
				case 0x4D: vk = VK_RIGHT;	break;  // RIGHT
				case 0x4F: vk = VK_END;		break;  // END
				case 0x50: vk = VK_DOWN;	break;  // DOWN
				case 0x51: vk = VK_NEXT;	break;  // PGDOWN
				case 0x52: vk = VK_INSERT;	break;  // INS

				case 0x53:    //DEL
					vk = VK_DELETE;
					if (LCtrlKeyPressed() && LAltKeyPressed())
					{	
						g_fCtrlAltDel = TRUE;
						SendSAS();
					}
					break;
                default: return; break; // internal error!
			}

			// Do the processing here itself
			SendExtendedKey(hwndKey, vk, pKey->scancode[1]);
			return;
		}

		vk = MapVirtualKey(pKey->scancode[1], 1);
		
		fIsExtendedKey=TRUE;
	}
	else if ((pKey->scancode[0] >= 0x47) && (pKey->scancode[0] <= 0x53))
	{
		// NumPad processing
        NumPad(pKey->scancode[0], hwndKey);
		return;
	}
	else
	{	
		// other keys
		vk = MapVirtualKey(pKey->scancode[0], 1);
	}

	switch (pKey->name)
	{
		case KB_PSC:  //Print screen
			SendFullKeyPress(VK_SNAPSHOT, 0);
			break;

		case KB_LCTR:	//case VK_CONTROL:
		case KB_RCTR:
			g_fControlPressed = !g_fControlPressed;

			if (g_fControlPressed)    // CTRL down
			{	
				// VK from MapVirtualKey doesn't return correct
				// VK for VK_RCONTROL so always use VK_CONTROL
				SendHalfKeyPress(VK_CONTROL, pKey->scancode[0], 0);
				
				//Change the ctrl color to show toggled
				s_hwndCtrl = hwndKey;
				InvertColors(hwndKey, TRUE);
			}
			else					// CTRL up
			{				
				SendHalfKeyPress(VK_CONTROL, pKey->scancode[0], KEYEVENTF_KEYUP);

				//change back to its normal state (key up)
				RestoreAppearance(&s_hwndCtrl, TRUE);
			}
			break;

		case KB_CAPLOCK:
			// Capslock state is maintained in the keyboard input handler.
			// The keyboard will be redrawn when the keyboard input
			// handler see's the caps lock key
			SendFullKeyPress(vk, pKey->scancode[0]);
			break;

		case KB_LSHIFT:
		case KB_RSHIFT:	
			// Shift state is maintained in the keyboard input handler. The keyboard
			// will be redrawn when the keyboard input handler see's the shift key.
			if (g_fShiftKeyDn)
			{	
				// Shift is currently down; send key up and restore key color
				SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], 
						KEYEVENTF_KEYUP | 
						    ( (pKey->name == KB_RSHIFT)? KEYEVENTF_EXTENDEDKEY : 0)
					);
			}
			else
			{	
				// Shift is currently up; send key down and show key toggled
				SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], 
						    ( (pKey->name == KB_RSHIFT)? KEYEVENTF_EXTENDEDKEY : 0)
						);
				// MARKWO: Remember the HWND for Shift, so we can toggle it
				// after a single normal key is pressed
				s_hwndShift = hwndKey;
			}
			break;

		case KB_LALT:
			// User hit left menu key.  If the right menu key was previously hit
			// then release it before continuing...
			if (g_nMenu == MENUKEY_RIGHT)
			{
				// send keyup on right menu and restore its color
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_RIGHT);
				g_nMenu = MENUKEY_NONE;
				RestoreAppearance(&s_hwndAlt, TRUE);
			}

			g_nMenu = (g_nMenu == MENUKEY_NONE)?MENUKEY_LEFT:MENUKEY_NONE;

			if (g_nMenu != MENUKEY_NONE)         // user pressed once
			{	
				// send the keydown and show the key toggled
				DoMenuKey(0, MENUKEY_LEFT);
				s_hwndAlt = hwndKey;
				InvertColors(hwndKey, TRUE);
			}
			else                                // user pressed again
			{	
				// send the keyup and return the key color to normal
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
				RestoreAppearance(&s_hwndAlt, TRUE);
			}
			break;

		case KB_RALT:
			// User hit right menu key.  If the left menu key was previously hit
			// then release it before continuing...
			if (g_nMenu == MENUKEY_LEFT)
			{
				// send keyup on left menu and restore its color
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
				g_nMenu = MENUKEY_NONE;
				RestoreAppearance(&s_hwndAlt, TRUE);
			}

			g_nMenu = (g_nMenu == MENUKEY_NONE)?MENUKEY_RIGHT:MENUKEY_NONE;

			// If there are ALTGR keys to show then send out RALT

			if (CanDisplayAltGr())
			{
				if (g_nMenu != MENUKEY_NONE)
				{
					// send keydown and toggle key color
					DoMenuKey(0, MENUKEY_RIGHT);
					s_hwndAlt = hwndKey;
					InvertColors(hwndKey, TRUE);
				} 
				else
				{	
					// send keyup and restore key color
					DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_RIGHT);
					RestoreAppearance(&s_hwndAlt, TRUE);
				}
			}
			else	// no ALTGR so RALT is the same as LALT key
			{	
				if (g_nMenu != MENUKEY_NONE)
				{	
					// send keydown on *left* menu and toggle key color
					DoMenuKey(0, MENUKEY_LEFT);
					s_hwndAlt = hwndKey;
					InvertColors(hwndKey, TRUE);
				}
				else 
				{	
					// send keyup on *left* menu and toggle key color
					DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
					RestoreAppearance(&s_hwndAlt, TRUE);
				}
			}

			fIsExtendedKey = FALSE;
			break;

		case KB_NUMLOCK:
			SendFullKeyPress(VK_NUMLOCK, 0x45);
			RedrawNumLock();
			break;

		case KB_SCROLL:
			SendFullKeyPress(VK_SCROLL, 0x46);
			RedrawScrollLock();
			break;

	   case BITMAP:
			// manage the CapLock japanese key
			if (!g_hBitmapLockHwnd)
			{
				SetWindowLong(lpkeyhwnd[iKey], 0, 4);
				g_hBitmapLockHwnd = hwndKey;
			}
			else
			{
				SetWindowLong(lpkeyhwnd[iKey], 0, 1);
				g_hBitmapLockHwnd = NULL;
			}

			InvalidateRect(hwndKey, NULL, TRUE);     //Redraw the key (in case it is in Dwell)

		   // Intentional fall through to send the key input...

		default:
        {
			if (fIsExtendedKey)      //extended key
			{	
				// extend key down
				SendExtendedKey(hwndKey, vk, pKey->scancode[1]);
				
				if (pKey->scancode[1] == 0x53 && LCtrlKeyPressed() && LAltKeyPressed())
				{
					g_fCtrlAltDel = TRUE;
				}
			}
			else             // a normal (non-extended) key
			{
				//APPCOMPAT: MapVirtualKey returns 0 for 'Break' key. Special case for 'Break'.
				if (!vk && pKey->scancode[0] == BREAK_SCANCODE)
				{
					if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
					{
						SendFullKeyPress(3, pKey->scancode[2]);
					}
					else
					{
						SendFullKeyPress(19, pKey->scancode[0]);
					}
				}
                else
				{
					SendFullKeyPress(vk, pKey->scancode[0]);
				}

                // restore the key appearance
				InvalidateRect(hwndKey, NULL, TRUE);

				if (Prefusesound)
				{
					MakeClick(SND_UP);	//Make click sound
				}
			}

			if (g_fShiftKeyDn)				// if SHIFT is down release it
			{	
				// If we did shift down, release it and restore key color
				// MARKWO: This is broken since pKey is not SHIFT at this point
				// SendHalfKeyPress(VK_SHIFT, pKey->scancode[0], KEYEVENTF_KEYUP);
				// This is better :	
				SendChar(s_hwndShift);
			}

            // ISSUE:  Navigating menus using LALT+menu key doesn't work when the user
            // is clicking on the soft keyboard.  When menus are being accessed the
            // keyboard processing sets the KF_MENUMODE bit in HIWORD(lParam) on the
            // KEYUP event of the key following the LALT (keyboard filters see this).  
            // However, when the user clicks the mouse on the soft keyboard to do the 
            // char following the LALT the system detects that focus is no longer on
            // the thread that started the menu processing and clears the KF_MENUMODE
            // bit.  OSK never sees the KF_MENUMODE bit and can't detect when menus 
            // are active (even in the keyboard filter proc).  Menus work in hover
            // mode or scan mode.  

			if (g_nMenu == MENUKEY_LEFT)
			{
				// If in middle of doing ALT+TAB... don't release the
				// LMENU key; the user must explicitly do the key up.
				if ((WORD) pKey->scancode[0] != TAB_SCANCODE)
				{
					DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_LEFT);
					RestoreAppearance(&s_hwndAlt, TRUE);
					g_nMenu = MENUKEY_NONE;
				}
				else
				{
					g_fDoingAltTab = TRUE;  // Flag we're in ALT+TAB... so we won't try to set the focus
				}                           // back to the last input target in the WM_SETCURSOR event
			}

			if (g_nMenu == MENUKEY_RIGHT)   // if RMENU is down, release it
			{	
				DoMenuKey(KEYEVENTF_KEYUP, MENUKEY_RIGHT);
				RestoreAppearance(&s_hwndAlt, FALSE);
				g_nMenu = MENUKEY_NONE;
			}
		
			if (g_fControlPressed)			// if CTRL is down, release it.
			{
				SendHalfKeyPress(VK_CONTROL, pKey->scancode[0], KEYEVENTF_KEYUP);
				g_fControlPressed = FALSE;
				RestoreAppearance(&s_hwndCtrl, FALSE);
			}
			break;
        }
	}  //end switch
}

/**************************************************************************/
//Send key up for Alt and Ctrl after user press Ctrl+Alt+Del
//For some reason, after user press Ctrl+Alt+Del from osk, the Alt and Ctrl
//keys still down.
/**************************************************************************/
void ReleaseAltCtrlKeys(void)
{	
	INPUT	rgInput[2];
				
	//Menu UP
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = VK_MENU;
	rgInput[0].ki.wScan = 0x38;

	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = VK_CONTROL;
	rgInput[1].ki.wScan = 0x1D;

	SendInput(2, rgInput, sizeof(INPUT));

	g_fCtrlAltDel = FALSE;
}
/**************************************************************************/

void SendExtendedKey(HWND hwndKey, UINT vk, UINT scanCode)
{
	INPUT rgInput[2];

	// extend key down
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = (WORD) vk;
	rgInput[0].ki.wScan = (WORD) scanCode;
		
	// extend key up
	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = (WORD) vk;
	rgInput[1].ki.wScan = (WORD) scanCode;

	SendInput(2, rgInput, sizeof(INPUT));

	InvalidateRect(hwndKey, NULL, TRUE);     //Redraw the key (in case it is in Dwell)

	//Make click sound
	if (Prefusesound)
	{
		MakeClick(SND_UP);
	}
}

void SendFullKeyPress(UINT vk, UINT scanCode)
{
	INPUT rgInput[2];

	// key down
	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = 0;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = (WORD) vk;
	rgInput[0].ki.wScan = (WORD) scanCode;
		
	// key up
	rgInput[1].type = INPUT_KEYBOARD;
	rgInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
	rgInput[1].ki.dwExtraInfo = 0;
	rgInput[1].ki.wVk = (WORD) vk;
	rgInput[1].ki.wScan = (WORD) scanCode;

	SendInput(2, rgInput, sizeof(INPUT));
}

void SendHalfKeyPress(UINT vk, UINT scanCode, DWORD dwFlags)
{
	INPUT rgInput[1];

	rgInput[0].type = INPUT_KEYBOARD;
	rgInput[0].ki.dwFlags = dwFlags;
	rgInput[0].ki.dwExtraInfo = 0;
	rgInput[0].ki.wVk = (WORD) vk;
	rgInput[0].ki.wScan = (WORD) scanCode;

	SendInput(1, rgInput, sizeof(INPUT));
}

// Sending SAS...

BOOL SendSAS()
{
	HWND hWnd = NULL;
	
	// SAS window will only be found on logon desktop
	hWnd = FindWindow(NULL, TEXT("SAS window"));
	if ( hWnd )
	{
		PostMessage(hWnd, WM_HOTKEY, 0, (LPARAM) 2e0003);
		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\scan.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// Updated :1999 Anil Kumar and Maria Jose
// 

#include <windows.h>
#include <mmsystem.h>
#include "kbmain.h"
#include "kbus.h"
#include "resource.h"
#include "msswch.h"
#include "w95trace.h"

#define SCANTIMER	123    //timer identifier
#define NUMOFTIME   2      //after scan this many time of each key, 
                           //back to scan row : a-anilk

#define ROW1	1
#define ROW2	12
#define ROW3	21
#define ROW4	30
#define ROW5	39
#define ROW6	48
static int aiRows[] = {-1/*dummy*/, ROW1, ROW2, ROW3, ROW4, ROW5, ROW6};

#define COL1	  1
#define COL2	  52
#define COL3	  103
#define COL4	  153
#define COL4_END  202
#define COL4S     103   //Small KB
#define COL4S_END 143   //Small KB

int count=0;

UINT_PTR TimerS1;       //Timer for scanning
int g_iCurRowYPos = 1;  //current row which is scanning
int CurKey=0;       //current key which is scanning
int LastKey=0;      //Last scanned key in Small keyboard
int ScanState=0;    //State : Row scan / Key scan
int CurCol= COL1;

extern HWND g_hBitmapLockHwnd;

__inline ChangeBGColor(HWND hwnd)
{
    SetWindowLong(hwnd, 0, 4);
    SetBackgroundColor(hwnd, COLOR_HOTLIGHT);
    InvalidateRect(hwnd, NULL, TRUE);
}

/***********************************************/
//			Functions in this file
/***********************************************/

#include "scan.h"

void ScanningSound(int what);


/***********************************************/
//			Functions in other file
/***********************************************/
#include "ms32dll.h"
extern BOOL RedrawNumLock();
extern BOOL RedrawScrollLock();

/***************************************************************/
void Scanning(int from)
{	
	count = 0;   //reset this counter of key scan

	//Play some sound
	ScanningSound(3);

	if(kbPref->Actual)
		Scanning_Actual(from);
	else
		Scanning_Block(from);
}

/***************************************************************/
// Actual layout
/***************************************************************/
void Scanning_Actual(int from)
{	
	ScanState = ScanState + from;
	
	count = 0;   //reset this counter of key scan

	switch (ScanState)
	{
		case 0:
			KillScanTimer(TRUE);
			break;
	
		case 1:		//Row scanning
			KillScanTimer(FALSE);
			CurKey = 0;  //reset to 0 anyway
			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)LineScanProc);
			break;
	
		case 2:		//key scanning
			KillScanTimer(FALSE);
			switch (kbPref->KBLayout)
			{
				case 101:
					TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Actual_101);
					break;
				case 106:
					TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Actual_106);
					break;
				case 102:
					TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Actual_102);
					break;
				default:
					break;	// internal error!
			}
			break;
	
		default:     //stop scanning and send char
			KillScanTimer(FALSE);
			swchCheckForScanChar(FALSE); // flag msswch dll to not check for scan char

			if (smallKb && (LastKey != 0))
			{
				SendChar(lpkeyhwnd[LastKey]);
			}
			else
			{
				SendChar(lpkeyhwnd[CurKey-1]);
			}
			
			ScanState = 0;
			CurKey = 0;

			//Post a message to call Scanning again to avoid recursive call
			PostMessage(g_hwndOSK, WM_USER + 1, 0L, 0L);
			break;
	}
}

/****************************************************************/
// Scan each row. Both Actual and Block
/****************************************************************/
void CALLBACK LineScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    int i, iPrevRowIndex;
    static int s_iRowIndex = 1;

    // quit scanning if we've cycled NUMOFTIME times w/no scan key

	if (count == NUMOFTIME)
	{	
		Scanning(-1);
		return;
	}

    // get the previous row to be restored and restore it

    iPrevRowIndex = s_iRowIndex - 1;
    if (iPrevRowIndex < 1)
        iPrevRowIndex = 6;

    RestoreRowColor(aiRows[iPrevRowIndex]);
    g_iCurRowYPos = aiRows[s_iRowIndex];

    // change the background of each key in the current row

    for (i=1; i < lenKBkey; i++)
    {	
        if (KBkey[i].posY == g_iCurRowYPos)
        {
            ChangeBGColor(lpkeyhwnd[i]);
        }
    }
	
	ScanningSound(1);	// play sound?
	
	s_iRowIndex++;        // update the current row index

	if (s_iRowIndex == 7) // last row, reset to first row 
	{	
        s_iRowIndex = 1;
		count++;
	}
}

/******************************************************************************/
// Scan each key in Actual 101 kb
/******************************************************************************/
void CALLBACK KeyScanProc_Actual_101(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    register int j=0;

	if(CurKey == 0)
	{	
		//move to the correct row
		while ((KBkey[j].posY != g_iCurRowYPos) && (j < lenKBkey))
			j++;
		CurKey = j;
	}

	//Skip all the dummy key
	for(CurKey;KBkey[CurKey].smallKb == NOTSHOW;CurKey++);

	//Scan each key
	if (KBkey[CurKey].posY == g_iCurRowYPos)
	{	
		//Just reach the end last time (For Small KB only)
		if(LastKey != 0)
		{	
			RestoreKeyColor(LastKey);
			
		    //	
            //if 97 (LALT) just pass the space in SMALL KB, so don't increment the counter
            //
			if(LastKey != 97)  
            {
				count++;   //else increment the counter
            }
			
			LastKey = 0;
			
			if (count == NUMOFTIME)
			{	count = 0;
				Scanning_Actual(-1);
				return;
			}
		}
		else
		{
			RestoreKeyColor(CurKey - 1);
		}

        //Change the key color to black
		ChangeBGColor(lpkeyhwnd[CurKey]);
		CurKey++;   //jump to next key

		//Reach at the VERY END in Large KB
		//Note: It should be 111, but I let it to scan one more so I don't need to write extra code to redraw the last key 
		if(!smallKb && CurKey == 112)  
		{	
			count++;		//increment the counter
			CurKey = 95;	//set it back to first key (LCTRL) in last row of the kb
		}

		//reach at the VERY END in Small KB (KB has 117 keys)
		else if(smallKb && CurKey == 118)
		{			
			CurKey = 95;  // first key (LCTRL) in last row
			LastKey = 117;
		}

		//After left Alt, jump to 111 (Space) for Small KB
		else if(smallKb && CurKey == 98)
		{	
            CurKey = 111;   //Space in small KB
			LastKey = 97;   //LALT
		}
			
		//reach at the end of each row
		else if(smallKb) 
		{	
  			// the number is one advance than the actual key 
			// because it increment one after it scan the key
			switch(CurKey)
			{
				case 14:		//f12
				CurKey = 1;
				LastKey = 13;
				break;

				case 32:		//BS
				CurKey = 17;	// ~
				LastKey = 31;	//BS
				break;

				case 53:		// |
				CurKey = 39;	//TAB
				LastKey = 52;	// |
				break;

				case 74:		//enter
				CurKey = 60;	// Cap
				LastKey = 73;	//ENTER
				break;

				case 90:		//right shift
				CurKey = 77;   //LSHIFT
				LastKey = 89;  //RSHIFT
				break;
			}
		}
	}
	//End of the row (Large KB).  Reset to beginning of the row
	else if (KBkey[CurKey].posY > g_iCurRowYPos && !smallKb)
	{	
		RestoreKeyColor(CurKey - 1);
		
		count++;   //increment the counter

		switch (g_iCurRowYPos)
		{
			case ROW1:
			CurKey = 1;  //esc
			break;

			case ROW2:
			CurKey = 17;  // ~
			break;

			case ROW3:
			CurKey = 39;  //TAB
			break;

			case ROW4:
			CurKey = 60;  // CAP
			break;

			case ROW5:
			CurKey = 77;  // LSHIFT
			break;

			case ROW6:
			CurKey = 95;  //LCRL
			break;
		}
	}

	//Play some sound
	ScanningSound(1);
	
	// We have scan NUMOFTIME for each key in this row, and 
	// the user hasn't made a choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;
		Scanning_Actual(-1);
	}
}

/******************************************************************************/
// Scan each key in Actual 102 kb
/******************************************************************************/
void CALLBACK KeyScanProc_Actual_102(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    register int j=0;

	if(CurKey == 0)
	{	//move to the correct row
		while ((KBkey[j].posY != g_iCurRowYPos) && (j < lenKBkey))
			j++;
		CurKey = j;
	}

	//Skip all the dummy key
	for(CurKey;KBkey[CurKey].smallKb == NOTSHOW;CurKey++);

	//Scan each key
	if (KBkey[CurKey].posY == g_iCurRowYPos)
	{	
		//Just reach the end last time (For Small KB only)
		if(LastKey != 0)
		{	
			RestoreKeyColor(LastKey);
			
		    //	
            //if 97 (LALT) just pass the space in SMALL KB, so don't increment the counter
            //
			if(LastKey != 97)  
            {
				count++;   //else increment the counter
            }
			
			LastKey = 0;
			
			if (count == NUMOFTIME)
			{	count = 0;
				Scanning_Actual(-1);
				return;
			}
		}
		else
		{
			RestoreKeyColor(CurKey - 1);
		}

        //Change the key color to black
		ChangeBGColor(lpkeyhwnd[CurKey]);
		CurKey++;   //jump to next key

		//Reach at the VERY END in Large KB
		//Note: It should be 111, but I let it to scan one more so I don't need to write extra code to redraw the last key 
		if(!smallKb && CurKey == 112)  
		{	
			count++;   //increment the counter
			CurKey = 95;  //set it back to first key (LCTRL) in last row of the kb
		}
		//reach at the VERY END in Small KB (KB has 117 keys)
		else if(smallKb && CurKey == 118)
		{			
			CurKey = 95;  // first key (LCTRL) in last row
			LastKey = 117;
		}
		//After left Alt, jump to 111 (Space) for Small KB
		else if(smallKb && CurKey == 98)
		{	
            CurKey = 111;   //Space in small KB
			LastKey = 97;   //LALT
		}
		//reach at the end of each row
		else if(smallKb) 
		{	
  			// the number is one advance than the actual key 
			// because it increment one after it scan the key
			switch(CurKey)
			{
				case 14:  //f12
				CurKey = 1;
				LastKey = 13;
				break;

				case 32:   //BS
				CurKey = 17;  // ~
				LastKey = 31;  //BS
				break;

				case 53:    // |
				CurKey = 39;  //TAB
				LastKey = 52;  // |
				break;

				case 74:   //enter
				CurKey = 60;    // Cap
				LastKey = 73;   //ENTER
				break;

				case 90:   //right shift
				CurKey = 77;   //LSHIFT
				LastKey = 89;  //RSHIFT
				break;
			}
		}
	}
	//End of the row (Large KB).  Reset to beginning of the row
	else if (KBkey[CurKey].posY > g_iCurRowYPos && !smallKb)
	{	
		RestoreKeyColor(CurKey - 1);
		
		count++;   //increment the counter

		switch (g_iCurRowYPos)
		{
			case ROW1:
			CurKey = 1;  //esc
			break;

			case ROW2:
			CurKey = 17;  // ~
			break;

			case ROW3:
			CurKey = 39;  //TAB
			break;

			case ROW4:
			CurKey = 60;  // CAP
			break;

			case ROW5:
			CurKey = 77;  // LSHIFT
			break;

			case ROW6:
			CurKey = 95;  //LCRL
			break;
		}
	}

	//Play some sound
	ScanningSound(1);
	
	// We have scan NUMOFTIME for each key in this row, and the 
	// user hasn't made a choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;
		Scanning_Actual(-1);
	}
}

/******************************************************************************/
// Scan each key in Actual 106 kb
/******************************************************************************/
void CALLBACK KeyScanProc_Actual_106(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
    register int j=0;

	if(CurKey == 0)
	{	//move to the correct row
		while ((KBkey[j].posY != g_iCurRowYPos) && (j < lenKBkey))
			j++;
		CurKey = j;
	}

	//Skip all the dummy key
	for(CurKey;KBkey[CurKey].smallKb == NOTSHOW;CurKey++);

	//Scan each key 
	if(KBkey[CurKey].posY == g_iCurRowYPos)
	{	
		//Just reach the end last time (For Small KB only)
		if(LastKey != 0)
		{	
			RestoreKeyColor(LastKey);
			
		    //	
            //These are the keys as exception in SMALL KB.
			//They are not reach the end of the road, 
		    //so don't increment the counter
            //
			if(LastKey != 98 && LastKey != 101 && LastKey != 111)  
            {
				count++;   //else increment the counter
            }
			
			LastKey = 0;
			
			if (count == NUMOFTIME)
			{	count = 0;
				Scanning_Actual(-1);
				return;
			}
		}
		else
		{
			RestoreKeyColor(CurKey - 1);
		}

        //Change the key color to black
		ChangeBGColor(lpkeyhwnd[CurKey]);
		CurKey++;   //jump to next key

		//Reach at the VERY END in Large KB
		//Note: It should be 111, but I let it to scan one more so I don't need to write extra code to redraw the last key 
		if(!smallKb && CurKey == 112)  
		{	
			count++;   //increment the counter
			
			CurKey = 95;  //set it back to first key (LCTRL) in last row of the kb
		}
		//reach at the VERY END in Small KB (KB has 117 keys)
		else if(smallKb && CurKey == 118)
		{			
			CurKey = 95;  // first key (LCTRL) in last row
			LastKey = 117;
		}
		//After the NO CONVERT Key, skip the Space in Large KB
		else if(smallKb && CurKey == 99)
		{	
            CurKey = 111;   //CONVERT key
			LastKey = 98;   //Japanses
		}
		//After Space jump back to CONVERT key
		else if(smallKb && CurKey == 112)
		{	
            CurKey = 100;   //CONVERT
			LastKey = 111;   // SPACE
		}
		//After THE Japanese key, jump to 102 (RALT) for Small KB
		else if(smallKb && CurKey == 102)
		{	
            CurKey = 112;   //RALT in small KB
			LastKey = 101;   //Japanese Key
		}
		//reach at the end of each row
		else if(smallKb) 
		{	
  			// the number is one advance than the actual key 
			// because it increment one after it scan the key
			switch(CurKey)
			{
				case 14:  //f12
				CurKey = 1;
				LastKey = 13;
				break;

				case 32:   //BS
				CurKey = 17;  // ~
				LastKey = 31;  //BS
				break;

				case 54:    // Enter
				CurKey = 39;  //TAB
				LastKey = 53;  // |
				break;

				case 74:   // '\'
				CurKey = 61;    // Cap
				LastKey = 73;   //ENTER
				break;

				case 90:   //right shift
				CurKey = 77;   //LSHIFT
				LastKey = 89;  //RSHIFT
				break;
			}
		}
	}
	//End of the row (Large KB).  Reset to beginning of the row
	else if (KBkey[CurKey].posY > g_iCurRowYPos && !smallKb)
	{	
		RestoreKeyColor(CurKey - 1);
		
		count++;   //increment the counter

		switch (g_iCurRowYPos)
		{
			case ROW1:
			CurKey = 1;  //esc
			break;

			case ROW2:
			CurKey = 17;  // ~
			break;

			case ROW3:
			CurKey = 39;  //TAB
			break;

			case ROW4:
			CurKey = 61;  // CAP
			break;

			case ROW5:
			CurKey = 77;  // LSHIFT
			break;

			case ROW6:
			CurKey = 95;  //LCRL
			break;
		}
	}

	//Play some sound
	ScanningSound(1);

	// We have scan NUMOFTIME for each key in this row, and the
	// user hasn't made  a choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;
		Scanning_Actual(-1);
	}
}

/******************************************************************************/
// Restore the whole row's color
/******************************************************************************/
void RestoreRowColor(int Row)
{	
    register int i;

    //Reset previous row color
    for(i=1; i < lenKBkey; i++)
    {
        if(KBkey[i].posY == Row)
        {
            RestoreKeyColor(i);
        }
	}
}

/****************************************************************************/
// Restore one key color
/****************************************************************************/
void RestoreKeyColor(int i)
{
	// index > 0
	if(i<=0)
		return;
	
	//Skip all the dummy key
	for(i; KBkey[i].smallKb == NOTSHOW; i--);

	if (lpkeyhwnd[i] != g_hBitmapLockHwnd)
	{
		// Do not change the key color if Caplock bitmap
		SetWindowLong(lpkeyhwnd[i], 0, 0);	
	}

	switch (KBkey[i].ktype)
	{
		case KNORMAL_TYPE:
		SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
	    break;

		case SCROLLOCK_TYPE:
        RedrawScrollLock();
        break;

		case NUMLOCK_TYPE:
        RedrawNumLock();
	    break;
			
		case KMODIFIER_TYPE:
		case KDEAD_TYPE:
        {
            int iColor = (IsModifierPressed(lpkeyhwnd[i]))?COLOR_HOTLIGHT:COLOR_INACTIVECAPTION;
            SetBackgroundColor(lpkeyhwnd[i], iColor);
        }
	    break;

        case LED_NUMLOCK_TYPE:
		case LED_SCROLLLOCK_TYPE:
		case LED_CAPSLOCK_TYPE:
		SetBackgroundColor(lpkeyhwnd[i], COLOR_BTNSHADOW);
	    break;	
	}

	InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
}

/****************************************************************/
// Pass FALSE - Pause
// Pass TRUE  - Reset (start scanning from row 1) 
/****************************************************************/
void KillScanTimer(BOOL reset)
{
	KillTimer(g_hwndOSK, SCANTIMER);
	RestoreRowColor(g_iCurRowYPos);

	//if calling from dialog init, reset these vars to start at the beginning 
	if (reset)
	{	
		ScanState = 0;
		CurKey = 0;
		g_iCurRowYPos = ROW1;
	}
}

/**********************************************************************/
// Scan in block kb
/**********************************************************************/
void Scanning_Block(int from)
{	

	ScanState = ScanState + from;
	
	count = 0;   //reset this counter of key scan


	switch (ScanState)
	{
		case 0:
			KillScanTimer(TRUE);
			break;
	
		case 1:   //Row scanning
			KillScanTimer(FALSE);
			CurCol = COL1;    //reset Col to COL1 for next round
			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)LineScanProc);
			break;

		case 2:
			KillScanTimer(FALSE);
			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)BlockScanProc);
			break;

		case 3:    //key scanning
			KillScanTimer(FALSE);

			//Set the coloum back 1 because in Block scan I set it 1 advance
			switch(CurCol)
			{
				case COL1: CurCol = COL4; break;
				case COL2: CurCol = COL1; break;
				case COL3: CurCol = COL2; break;
				case COL4: CurCol = COL3; break;
			}

			//Small KB doesn't has Col4, Set to Col3
			if(smallKb && (CurCol == COL4))
				CurCol = COL3;

			TimerS1 = SetTimer(g_hwndOSK, SCANTIMER, PrefScanTime, (TIMERPROC)KeyScanProc_Block);
			break;
	
		default:     //stop scanning and send char
			KillScanTimer(FALSE);

			//a special for SPACE in Large KB and Block layout
			if((!kbPref->Actual) && (!smallKb) && (CurKey == 99))
				CurKey++;

			// tell msswch dll to not check this char to see if it is the scanning char

			swchCheckForScanChar(FALSE);

			SendChar(lpkeyhwnd[CurKey-1]);
			
			//re-set some vars
			ScanState = 0;
			CurKey = 0;

			//Post a message to call Scanning again to avoid recursive call
			PostMessage(g_hwndOSK, WM_USER + 1, 0L, 0L);
			break;
	}
}

/*********************************************************************/
// Restore the whole block color in block kb
/*********************************************************************/
void RestoreBlockColor(int ColStart, int ColEnd)
{	register int i;

	//Find the first key in current row and current col
	for(i=1; i < lenKBkey; i++)
		if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == ColStart))
			break;

	while(((KBkey[i].posX < ColEnd) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))
	{
		if(KBkey[i].smallKb == NOTSHOW)
		{	
			i++;
			continue;
		}

		if (lpkeyhwnd[i] != g_hBitmapLockHwnd)
		{
			// Do no change the color key if Caplock bitmap
			SetWindowLong(lpkeyhwnd[i], 0, 0);	
		}

		switch (KBkey[i].ktype)
		{
			case KNORMAL_TYPE:
			SetBackgroundColor(lpkeyhwnd[i], COLOR_MENU);
			break;

			case SCROLLOCK_TYPE:
            RedrawScrollLock();
            break;

			case NUMLOCK_TYPE:
            RedrawNumLock();
            break;
		
			case KMODIFIER_TYPE:
			case KDEAD_TYPE:
			SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);
			break;
		
		
			case LED_NUMLOCK_TYPE:
			case LED_CAPSLOCK_TYPE:
			case LED_SCROLLLOCK_TYPE:
			SetBackgroundColor(lpkeyhwnd[i], COLOR_BTNSHADOW);
			break;
		}
		InvalidateRect(lpkeyhwnd[i], NULL, TRUE);
		i++;
	}
}


/*********************************************************************/
// Scan each block in block kb
/*********************************************************************/
void CALLBACK BlockScanProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
	register int i;

	//We have scan NUMOFTIME for each block in this row, and the user hasn't make 
	//any choice. Now go back to scan ROW
	if (count == NUMOFTIME)
	{	
		count = 0;    //reset the counter
		Scanning_Block(-1);
		return;
	}

	//Find the first key in current row and current col
	for(i=1; i < lenKBkey; i++)
		if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == CurCol))
			break;

        switch (CurCol)
		{
			case COL1:
				CurKey = i;    //set the CurKey to the beginning of this block 
				if (smallKb)	//Small KB
				{
					int j;
					RestoreBlockColor(COL3,COL4);
					for(j=113; j <= 117; j++)  //Hardcoded it!
						RestoreKeyColor(j); 
				}
				else   // Large KB
				{
					RestoreBlockColor(COL4, COL4_END);
				}

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL2) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))		
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}

					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}
				CurCol = COL2;  //Jump to next col
				break;

			case COL2:
				CurKey = i;    //set the CurKey to the beginning of this block
				RestoreBlockColor(COL1, COL2);

				//In Small KB, skip all the large kb keys
				if (smallKb)
				{
					while((KBkey[i].smallKb == LARGE) || (KBkey[i].smallKb == NOTSHOW))
						i++;
				}

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL3) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))		
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}
									
					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}
				CurCol = COL3;   //Jump to next col
				break;

			case COL3:
				//For small KB, skip all the keys only for LARGE kb
				if(smallKb)
				{
					while(KBkey[i].smallKb == LARGE || KBkey[i].smallKb == NOTSHOW)
						i++;
				}

				CurKey = i;    //set the CurKey to the beginning of this block

				//Small kb
				if (smallKb && CurKey == 111)   // CurKey == SPACE
				{
					RestoreKeyColor(111);   // SPACE
					RestoreKeyColor(112);   // RALT

					CurKey = i = 113;   //APP KEY
				}
				//Large KB
				else
				{
					RestoreBlockColor(COL2, COL3);
				}

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL4) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))		
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}
					
					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}

				if (smallKb)   //Small KB only has 3 columns
				{
					CurCol = COL1;
					count++;        // increment the counter
				}
				else    //Large KB
				{
					CurCol = COL4;  //Jump to next col
				}
				break;

			case COL4:
				CurKey = i;    //set the CurKey to the beginning of this block
				RestoreBlockColor(COL3, COL4);

				//Paint all keys within the Block
				while(((KBkey[i].posX < COL4_END) && (KBkey[i].posY == g_iCurRowYPos)) || (KBkey[i].smallKb == NOTSHOW))
				{	
					if(KBkey[i].smallKb == NOTSHOW)
					{	i++;
						continue;
					}
					
					ChangeBGColor(lpkeyhwnd[i]);	
					i++;
				}

				CurCol = COL1;   //Jump to next col
				count++;   //increment the counter
				break;
		}

	//Play some sound
	ScanningSound(1);
}

/*********************************************************************/
// Scan each key in a block in block kb
/*********************************************************************/
void CALLBACK KeyScanProc_Block(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{	
	static int last=0;	
	register int i;

	switch (CurCol)
	{
		case COL1:   //This is actually COL1
			//Scanning each key in the Block
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL2))
			{	
				if(last != 0)
				{	RestoreKeyColor(last);
					last = 0;
				}
				else if(CurKey > 1)
				{
					RestoreKeyColor(CurKey - 1);
				}
				
				ChangeBGColor(lpkeyhwnd[CurKey]);
				CurKey++;   //jump to next key
			}
				//Reach last key, reset to first key in the col
			else if(KBkey[CurKey].posX >= COL2)
			{	for(i=1; i < lenKBkey; i++)
				{
					if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL1))
					{	last = CurKey -1;   //save the last key for next restore color
						CurKey = i;
						break;
					}
				}
				count++;
			}
			break;

		case COL2:   //Actually COL2
			//In small KB, skip all the Large KB keys
			if (smallKb)
			{
				while(KBkey[CurKey].smallKb == LARGE || KBkey[CurKey].smallKb == NOTSHOW)
					CurKey++;
			}

			//Only for the last row (both Small and Large KB)
			if(KBkey[CurKey].name == KB_SPACE)
			{	
				if (smallKb)    //Small KB
					RestoreKeyColor(112);   //106

				ChangeBGColor(lpkeyhwnd[CurKey]);
				CurKey++;

				if (!smallKb)   //Large KB
				{				
					count++;

					if(count < NUMOFTIME)
						CurKey--;
				}
				else    //Small Kb
				{
					last = 111;      //SPACE (small)
				}
				break;
			}

			//Scanning each key in the Column
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL3))
			{
				if(last != 0)
				{	
					RestoreKeyColor(last);
					last = 0;
				}
				else
				{
					RestoreKeyColor(CurKey - 1);
				}

				ChangeBGColor(lpkeyhwnd[CurKey]);
			
				CurKey++;   //jump to next key
			}
			//Reach last key, reset to first key in the col
			else if(KBkey[CurKey].posX >= COL3)
			{	
				if (smallKb && CurKey == 113)    //App Key (small)
				{
					CurKey = 111;       //SPACE (small)
					last = 112;         //RALT (small)
				}
				else
				{
					for(i=1; i < lenKBkey; i++)
					{
						if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL2))
						{	
							//save the last key for next restore color
							last = CurKey - 1;
							CurKey = i;
							break;
						}
					}
				}
				count++;
			}
			break;

		case COL3:  //Actually COL3
			//Last Col for SMALL KB
			//Special case!!  Last scan reach the very end in Samll KB (118)
			if (CurKey == 118)  
			{   
				CurKey = 113;   //Reset to the first one in this col
				count++;
			}

			//Skip all Dummy key
			while(KBkey[CurKey].smallKb == NOTSHOW)
				CurKey++;

			//Scanning each key in the Block
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL4) && 
			   (CurKey <= 117))
			{
				//In small KB, skip all the Large KB keys
				if(smallKb)
				{
					while(KBkey[CurKey].smallKb == LARGE || KBkey[CurKey].smallKb == NOTSHOW)
						CurKey++;
				}

				if(last != 0)
				{	
					RestoreKeyColor(last);

					//Special case, reach the end of the small KB
					if (last == 118)    //The end in Small KB
						CurKey = 113;   //reset to first one in this col

					last = 0;
				}
				else
				{
					RestoreKeyColor(CurKey - 1);
				}

				//Set the key to black
				ChangeBGColor(lpkeyhwnd[CurKey]);
			
				CurKey++;   //jump to next key
			}
			//Reach last key, reset to first key in the col
			else if( (KBkey[CurKey].posX >= COL4 || CurKey > 109)  && (CurKey <= 117) )  
			{	
				//reach the very end

				for(i=1; i < lenKBkey; i++)
				{
					if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL3))
					{	last = CurKey - 1;   //save the last key for next restore color
						CurKey = i;
						break;
					}
				}
				count++;
			}

			//Small KB reach the last key (117)
			if (smallKb && (CurKey == 118))
				last = CurKey -1;
			break;

		case COL4:   //Actual COL4
			//Only LARGE KB has COL4
			//Scanning each key in the Block
																					   //large KB and not reach the end
			if((KBkey[CurKey].posY == g_iCurRowYPos) && (KBkey[CurKey].posX < COL4_END) && !smallKb && (CurKey <= 110))
			{
				if(last != 0)
				{	RestoreKeyColor(last);
					last = 0;
				}
				else
					RestoreKeyColor(CurKey - 1);


				ChangeBGColor(lpkeyhwnd[CurKey]);
			
				CurKey++;   //jump to next key
							
			}
			//Reach last key, reset to first key in the col
			else // if(KBkey[CurKey - 1].posX >= COL4_END)
			{	
				for(i=1; i < lenKBkey; i++)
				{
					if((KBkey[i].posY == g_iCurRowYPos) && (KBkey[i].posX == COL4))
					{	last = CurKey - 1;   //save the last key for next restore color
						CurKey = i;
						break;
					}
				}
				count++;
			}
			break;
	}

	//Play some sound
	ScanningSound(1);
		
	// We have scan NUMOFTIME for each key in this Block, and the 
	// user hasn't made a choice. Now go back to scan BLOCK
	if (count == NUMOFTIME)
	{	
		count = 0;    //reset the counter
		Scanning_Block(-1);
	}
}
/*****************************************************************************/
void ScanningSound(int what)
{	
	// don't want sound, then exit
	if(!Prefusesound)
		return;

	switch(what)
	{
		case 2:     // scanning
		PlaySound(MAKEINTRESOURCE(WAV_CLICKDN), hInst, SND_ASYNC|SND_RESOURCE);
		break;

		case 1:      //one level up
		PlaySound(MAKEINTRESOURCE(WAV_CLICKUP), hInst, SND_ASYNC|SND_RESOURCE);
		break;

		case 3:      //switch click
		PlaySound(MAKEINTRESOURCE(WAV_SWITCH_CLICK), hInst, SND_ASYNC|SND_RESOURCE);
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OSK.rc
//
#define IDS_TITLE1                      1
#define IDS_TITLE2                      2
#define IDS_TITLE3                      3
#define IDS_CANNOTCREATEDLG             4
#define IDS_REGISTRY_DAMAGE             5
#define IDS_REGISTRY_ACCESS_ERROR       6
#define IDS_MEMORY_LIMITED              7
#define IDS_SECURITY_FAILURE            8
#define IDS_CANNOT_REGISTER             9
#define chk_AlwaysOnTop                 10
#define radio_LargeKB                   11
#define IDS_CANNOT_SWITCH_LANG          11
#define radio_SmallKB                   12
#define IDS_CANNOT_CREATE_KB            12
#define chk_ClickSound                  13
#define IDS_CANNOT_CREATE_KEY           13
#define chk_Dwell                       14
#define IDS_CANNOT_LOAD_ICON            14
#define chk_Scan                        15
#define radio_Actual                    16
#define IDS_MAIL                        16
#define radio_Block                     17
#define IDS_CANNOT_OPEN_SWPORT          17
#define IDS_SETTING_DAMAGE              18
#define IDS_MOUSE_HOOK                  19
#define IDS_JOURNAL_HOOK                20
#define IDS_ABOUTBOX                    21
#define IDS_CREDITSBOX                  22
#define IDS_THANKYOU                    23
#define IDS_MOUSE_UNHOOK                24
#define IDS_JOURNAL_UNHOOK              25
#define IDS_ADDTOUM                     26
#define IDS_REMUM                       27
#define IDS_WARNING_MSG                 28
#define IDS_SPACE_KEY                   29
#define IDS_ENTER_KEY                   30
#define IDS_F2_KEY                      31
#define IDS_F3_KEY                      32
#define IDS_F4_KEY                      33
#define IDS_F5_KEY                      34
#define IDS_F6_KEY                      35
#define IDS_F7_KEY                      36
#define IDS_F8_KEY                      37
#define IDS_F9_KEY                      38
#define IDS_F12_KEY                     39
#define IDS_ENABLEWEB                   40
#define IDS_TSERROR                     41
#define IDS_TOOLTIP                     42
#define IDS_SECONDS                     43
#define IDC_CURHAND                     105
#define IDD_ABOUT                       148
#define IDC_CURHAND1                    156
#define IDD_SPLASH                      159
#define IDD_CREDITS                     166
#define WAV_CLICKDN                     179
#define WAV_CLICKUP                     180
#define WAV_SWITCH_CLICK                182
#define DLG_TYPE_MODE                   184
#define IDD_ADVANCE_SCANNING            185
#define IDB_BITMAP1                     188
#define IDB_BITMAP5                     232
#define IDD_WARNING_MSG                 266
#define chk_Click                       1005
#define IDC_TXT4                        1030
#define IDC_TXT7                        1034
#define BUT_ADVANCED                    1040
#define CHK_PORT                        1041
#define CHK_KEY                         1042
#define COMBO_KB_KEY                    1043
#define IDC_CHECK1                      1058
#define IDC_SHOW_AGAIN                  1058
#define IDC_HOVER_DESC                  1062
#define IDC_SCAN_DESC                   1063
#define IDC_WARNING_TEXT1               1064
#define IDC_ABOUTDISCLAIMER             1065
#define IDC_WARNING_TEXT2               1065
#define IDC_ABOUTWEBSITE                1066
#define IDC_ENABLEWEB2                  1067
#define IDC_CMB_DWELL                   1068
#define IDC_CMB_SCAN                    1069
#define IDC_ENABLEWEB                   1086
#define IDC_WARND3                      1087
#define IDM_Open                        4001
#define IDM_Save                        4003
#define IDM_SaveAs                      4004
#define IDM_Exit                        4005
#define IDM_SettoDefault                4015
#define IDM_Setting                     4019
#define IDM_ALWAYS_ON_TOP               4019
#define CM_HELPABOUT                    4027
#define CM_HELPTOPICS                   4028
#define IDC_WARNING_ICON                32515
#define IDM_LARGE_KB                    40001
#define IDM_SMALL_KB                    40002
#define IDM_CLICK_SOUND                 40003
#define IDM_REGULAR_LAYOUT              40004
#define IDM_BLOCK_LAYOUT                40005
#define IDM_TYPE_MODE                   40006
#define IDM_SET_FONT                    40007
#define IDM_JAPAN_LAYOUT                40008
#define IDM_101_LAYOUT                  40008
#define IDM_102_LAYOUT                  40009
#define IDM_106_LAYOUT                  40010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        267
#define _APS_NEXT_COMMAND_VALUE         40012
#define _APS_NEXT_CONTROL_VALUE         1069
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\sdgutil.c ===
/*  Screen Doors*/

#define STRICT
#include <windows.h>
#include "Init_End.h"
#include "kbmain.h"     //keyboard header file from 3keyboar

#include "resource.h"

/*************************************************************/
//Functions in this file
/*************************************************************/
#include "sdgutil.h"

/************************************************************/
//Functions in other files
/************************************************************/
#include "fileutil.h"
#include "dgsett.h"

/*************************************************************/
//Global vars
/*************************************************************/
LOGFONT   lf;
extern BOOL  Setting_ReadSuccess=FALSE;

/**************************************************************************/
/* SendInitErrorMessage  - error msg                                          */
/**************************************************************************/
void SendErrorMessage(UINT ids_string)
{
    TCHAR str[256]=TEXT("");
    TCHAR title[256]=TEXT("");

	LoadString(hInst, ids_string, &str[0], 256);
	LoadString(hInst, IDS_TITLE1, &title[0], 256);
	MessageBox(g_hwndOSK, str, title,MB_ICONHAND | MB_OK);
}

/******************************************************************************/
//initially set all the preferences (except some keyboard preference which 
// set at kbmain.c)
/******************************************************************************/
void GetPreferences(void)
{
	 // use the setting read from Registry
	 if(Setting_ReadSuccess=OpenUserSetting())
	 {
		g_margin			= kbPref->g_margin;			   	// Margin between rows and columns
		smallKb 			= kbPref->smallKb;				// TRUE when working with Small Keyboard
		PrefDeltakeysize 	= kbPref->PrefDeltakeysize;		// Preference increment in key size
		PrefshowActivekey 	= kbPref->PrefshowActivekey;	// Show cap letters in keys
		KBLayout			= kbPref->KBLayout;				// 101, 102, 106, KB layout
		Prefusesound 		= kbPref->Prefusesound;			// Use click sound
		PrefAlwaysontop     = kbPref->PrefAlwaysontop;      // windows always on top
		
		//if Scanning on, we don't want hilite key
		if(kbPref->PrefScanning)
			Prefhilitekey        = FALSE;          
		else
			Prefhilitekey = kbPref->Prefhilitekey  = TRUE;    //hilite key under cursor

		PrefDwellinkey       = kbPref->PrefDwellinkey;    // TRUE for dwelling
		PrefDwellTime        = kbPref->PrefDwellTime;     // How long to dwell

		PrefScanning         = kbPref->PrefScanning;
		PrefScanTime         = kbPref->PrefScanTime;

		g_fShowWarningAgain	= kbPref->fShowWarningAgain;   // Show initial warning message again

		// font
		plf = &lf; 				// pointer to the actual font

		plf->lfHeight	 		= kbPref->lf.lfHeight;
		plf->lfWidth 			= kbPref->lf.lfWidth;
		plf->lfEscapement 		= kbPref->lf.lfEscapement;
		plf->lfOrientation 		= kbPref->lf.lfOrientation;
		plf->lfWeight 			= kbPref->lf.lfWeight;
		plf->lfItalic 			= kbPref->lf.lfItalic ;
		plf->lfUnderline 		= kbPref->lf.lfUnderline;
		plf->lfStrikeOut 		= kbPref->lf.lfStrikeOut;
		plf->lfCharSet 			= kbPref->lf.lfCharSet;
		plf->lfOutPrecision 	= kbPref->lf.lfOutPrecision;
		plf->lfClipPrecision 	= kbPref->lf.lfClipPrecision;
		plf->lfQuality 			= kbPref->lf.lfQuality ;
		plf->lfPitchAndFamily 	= kbPref->lf.lfPitchAndFamily;

        wsprintf(plf->lfFaceName, TEXT("%hs"), kbPref->lf.lfFaceName);

//"MS SHELL DLG" is the alias to default font 
//wsprintf(plf->lfFaceName, TEXT("%hs"), "MS SHELL DLG");

		newFont = TRUE;


		//Use 101 keyboard layout   (default is 101 and Actual layout)
		if(KBLayout == 101)
		{
			//The setting say use Block layout, so switch to Block structure
			if(!kbPref->Actual)
				BlockKB();
		}

		// Use 102 keyboard layout
		else if(KBLayout == 102)
			EuropeanKB();

		//Use 106 keyboard layout
		else
			JapaneseKB();
	 }

    else
    {
        SendErrorMessage(IDS_SETTING_DAMAGE);
   		ExitProcess(0);
    }
}

/**************************************************************/
DWORD WhatPlatform(void)
{	OSVERSIONINFO	osverinfo;

	osverinfo.dwOSVersionInfoSize = (DWORD)sizeof(OSVERSIONINFO);
	GetVersionEx(&osverinfo);
	return osverinfo.dwPlatformId;

}
/**************************************************************/
// Check to see the keyboard is out of screen or not with the given
// Screen resoultion (scrCX, scrCY)
/**************************************************************/
BOOL IsOutOfScreen(int scrCX, int scrCY)
{	
	//Check left and top
	if(kbPref->KB_Rect.left < 0 || kbPref->KB_Rect.top < 0)
		return TRUE;

	//Check right and bottom
	if(kbPref->KB_Rect.right > scrCX || kbPref->KB_Rect.bottom > scrCY)
		return TRUE;

	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\kbmain.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
// KBMAIN.C 
// Additions, Bug Fixes 1999
// a-anilk, v-mjgran
//  
#define STRICT

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include <crtdbg.h>
#include "kbmain.h"
#include "Init_End.h"     // all the functions, buttons control for dialogs
#include "kbus.h"
#include "resource.h"
#include "htmlhelp.h"
#include "Msswch.h"
#include "About.h"
#include "door.h"
#include "w95trace.c"
#include "DeskSwitch.c"
#include <objbase.h>
#include "wtsapi32.h"   // for terminal services

/**************************************************************************/
// FUNCTIONS IN THIS FILE
/**************************************************************************/
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname);
static BOOL InitMyProcessDesktopAccess(VOID);
static VOID ExitMyProcessDesktopAccess(VOID);
void DoButtonUp(HWND hwndKey);

/**************************************************************************/
// FUNCTIONS CALLED FROM THIS FILE
/**************************************************************************/
#include "sdgutil.h"
#include "kbfunc.h"
#include "scan.h"
#include "ms32dll.h"
#include "fileutil.h"

/**************************************************************************/
// global initial (YUK!)
/**************************************************************************/
extern LPKBPREFINFO  lpkbPref = NULL;                    // Pointer to Preferences KB structure
extern LPKBPREFINFO  lpkbDefault = NULL;                 // ditto Default
extern HWND          *lpkeyhwnd = NULL;                  // ptr to array of HWND
extern HWND          numBasehwnd = NULL;                 // HWND to the num base window
extern HWND          g_hwndOSK = NULL;                   // HWND to the kbmain window
extern int           lenKBkey = 0;                       // How Many Keys?
extern int           scrCY = 0;                          // Screen Height
extern int           scrCX = 0;                          // Screen Width
extern int           captionCY = 0;                      // Caption Bar Height
extern int           g_margin = 0;                       // Margin between rows and columns
extern BOOL          smallKb = FALSE;                    // TRUE when working with Small Keyboard
extern BOOL          PrefAlwaysontop = TRUE;             // Always on Top control
extern int           PrefDeltakeysize = 2;               // Preference increment in key size
extern BOOL          PrefshowActivekey = TRUE;           // Show cap letters in keys
extern int           KBLayout = 101;                     // 101, 102, 106, KB layout
extern BOOL          Prefusesound = FALSE;               // Use click sound
extern BOOL          newFont = FALSE;                    // Font is changed
extern HGDIOBJ       oldFontHdle = NULL;                 // Old object handle
extern LOGFONT       *plf = NULL;                        // pointer to the actual char font
extern COLORREF      InvertTextColor = 0xFFFFFFFF;       // Font color on inversion
extern COLORREF      InvertBKGColor = 0x00000000;        // BKG color on inversion
extern BOOL          Prefhilitekey = TRUE;               // True for hilite key under cursor
// Dwelling time control variables
extern BOOL          PrefDwellinkey = FALSE;             // use dwelling system
extern UINT          PrefDwellTime = 1000;               // Dwell time preference  (ms)

extern BOOL          PrefScanning = FALSE;               // use scanning
extern UINT          PrefScanTime = 1000;                // Prefer scan time

extern BOOL          g_fShowWarningAgain = 1;            // Show initial warning dialog again

extern HWND          Dwellwindow = NULL;                 // dwelling window HANDLE
                                                         
extern int           stopPaint = FALSE;                  // stop the bucket paint on keys
                                                         
extern UINT_PTR      timerK1 = 0;                        // timer id
extern UINT_PTR      timerK2 = 0;                        // timer for bucket

BOOL                 g_fShiftKeyDn = FALSE;              // TRUE if the SHIFT key is down
BOOL                 g_fCapsLockOn = FALSE;				 // TRUE if the CAPSLOCK is on
BOOL				 g_fRAltKey    = FALSE;			     // TRUE if the right ALT key is down
BOOL				 g_fLAltKey    = FALSE;			     // TRUE if the left ALT key is down
BOOL                 g_fLCtlKey    = FALSE;              // TRUE if the left CTRL key is donw
extern HWND          g_hBitmapLockHwnd;

extern HINSTANCE     hInst = NULL;
extern KBPREFINFO    *kbPref = NULL;
extern HWND			 g_hwndDwellKey;
HANDLE               g_hMutexOSKRunning;
DWORD				 platform = 1;

// Global variable to indicate if it was started from UM
extern BOOL			g_startUM = FALSE;
UINT taskBarStart;

static HWINSTA origWinStation = NULL;
static HWINSTA userWinStation = NULL;

// For Link Window
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
DWORD GetDesktop();

BOOL OSKRunSecure()
{
	return RunSecure(GetDesktop());
}

// stuff to keep our window inactive while using the soft keyboard
void SetFocusToInputWindow();
void TrackActiveWindow();
HWND g_hwndInputFocus = NULL;   // the window we are inputting to

// stuff for the message ballontip
#define  MAX_TOOLTIP_SIZE  256
TOOLINFO ti;
HWND     g_hToolTip;

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
#endif

__inline void HighlightKey(HWND hwnd)
{
    if (Prefhilitekey)
    {
        InvertColors(hwnd, TRUE);
    }
    if (PrefDwellinkey)
    {
        killtime();
        SetTimeControl(hwnd);
    }
}


/****************************************************************************/
/* LRESULT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,     */
/*                   LPSTR lpCmdLine, int nCmdShow)                    */
/****************************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	MSG  msg;
	TCHAR szToolTipText[MAX_TOOLTIP_SIZE];
	LPTSTR lpCmdLineW = GetCommandLine();
	DWORD desktopID;  // For utilman
	TCHAR name[300];

	if (NULL != lpCmdLineW && lstrlen(lpCmdLineW))
	{
		g_startUM = (lstrcmpi(lpCmdLineW, TEXT("/UM")) == 0)?TRUE:FALSE;
	}

	SetLastError(0);

	// Allow only ONE instance of the program running.

	g_hMutexOSKRunning = CreateMutex(NULL, TRUE, TEXT("OSKRunning"));
	if ((g_hMutexOSKRunning == NULL) || (GetLastError() == ERROR_ALREADY_EXISTS))
	{
		return 0;  // Exit without starting
	}

	taskBarStart = RegisterWindowMessage(TEXT("TaskbarCreated"));

	platform = WhatPlatform();	// note the OS

	hInst = hInstance;

	GetPreferences();	// load the setting file and init setting

   //************************************************************************
   // 
   // The following two calls initialize the desktop so that, if we are on
   // the Winlogon desktop (secure desktop) our UI will display.  Do not
   // cause any windows to be created (eg. CoInitialize) prior to calling
   // these functions.  Doing so will cause them to fail and the application
   // will not appear on the Winlogon desktop.
   //
   InitMyProcessDesktopAccess();
   AssignDesktop(&desktopID, name);

   //************************************************************************

   // for the Link Window in about dialog (requires COM initialization)...
   CoInitialize(NULL);
   LinkWindow_RegisterClass();

   if (!InitProc())
      return 0;

   InitKeys();
   UpdateKeyLabels(GetCurrentHKL());

   RegisterWndClass(hInst);

   mlGetSystemParam();              // Get system parameters

   g_hwndOSK = CreateMainWindow(FALSE);

   if (g_hwndOSK == NULL)
   {
      SendErrorMessage(IDS_CANNOT_CREATE_KB);
      return 0;
   }

   SetZOrder();                     // Set the main window position (topmost/non-topmost)
 
   DeleteChildBackground();         // Init all the keys color before showing them

   // Show the window but don't activate

   ShowWindow(g_hwndOSK, SW_SHOWNOACTIVATE);
   UpdateWindow (g_hwndOSK);
   TrackActiveWindow();

   InitCommonControls();
     
   //Create the help balloon
   g_hToolTip = CreateWindowEx(
					WS_EX_TOPMOST,
					TOOLTIPS_CLASS, 
					NULL, 
					WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                    0, 0, 
					0, 0, 
					NULL, NULL, 
					hInstance, NULL);

   if (g_hToolTip)
   {
      ti.cbSize = sizeof(ti);
      ti.uFlags = TTF_TRANSPARENT | TTF_CENTERTIP | TTF_TRACK;
      ti.hwnd = g_hwndOSK;
      ti.uId = 0;
      ti.hinst = hInstance;
      
      LoadString(hInstance, IDS_TOOLTIP, szToolTipText, MAX_TOOLTIP_SIZE);
      ti.lpszText = szToolTipText;
      
      SendMessage(g_hToolTip, TTM_ADDTOOL, 0, (LPARAM) &ti );
   }

   Create_The_Rest(lpCmdLine, hInstance);

   // check if there is necessary to show the initial warning msg
   if (g_fShowWarningAgain && !OSKRunSecure())
   {
      WarningMsgDlgFunc(g_hwndOSK);
   }

    // main message loop
   while (GetMessage(&msg, 0, 0, 0))
   {
        TranslateMessage(&msg); /* Translates character keys             */
        DispatchMessage(&msg);  /* Dispatches message to window          */
   }

   ExitMyProcessDesktopAccess();   // utilman

   UninitKeys();
   CoUninitialize();

// check for leaks
#ifdef _DEBUG
   _CrtDumpMemoryLeaks();
#endif

   return((int)msg.wParam);
}

/****************************************************************************/
extern BOOL  Setting_ReadSuccess;    //read the setting file success ?

BOOL ForStartUp1=TRUE;
BOOL ForStartUp2=TRUE;

float g_KBC_length = 0;









/*****************************************************************************/
//
//  kbMainWndProc
//  Explain how Large and Small KB switching:
//  All the keys are sizing according to the size of the KB window. So change
//  from Large KB to Small KB and make the KB to (2/3) of the original but
//  same key size. We need to set the KB size to (2/3) first. But use the 
//  original KB client window length to calculate "colMargin" to get the same
//  key size.
/*****************************************************************************/
LRESULT WINAPI kbMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int  i;
	static   int  oldWidth  = 0;
	static   int  oldHeight = 0;
	TCHAR    Wclass[50]=TEXT("");
	BOOL     isvisible;
	RECT     rect, rectC;
	int      rmargin, bmargin;          //will set to smallest width and height
	LONG_PTR dwExStyle;
	HWND     hwndMouseOver;
	POINT    pt;
	static  BOOL  s_fGotMouseDown = FALSE;    // TRUE if there's been a button down on a key
	static  HWND  s_hwndLastMouseOver = NULL; // handle to last key hwnd under mouse or NULL
	static  BOOL s_fIgnoreSizeMsg=FALSE;      // avoid looping because of sizing
	//
	// rowMargin is the ratio to the smallest height(KB_CHARBMARGIN)
	// e.g. rowMargin=4 means the current KB height is 4 * KB_CHARBMARGIN
	//
    float rowMargin, colMargin; 

   switch (message)
   {
      case WM_CREATE:
         if (lpkeyhwnd==NULL)
		 {
            lpkeyhwnd = LocalAlloc(LPTR, sizeof(HWND) * lenKBkey);
		 }

         if (!lpkeyhwnd)
         {
             SendErrorMessage(IDS_MEMORY_LIMITED);
             break;
         }
         
         // set the CapsLock flag On or Off

		 g_fCapsLockOn = (LOBYTE(GetKeyState(VK_CAPITAL)) & 0x01)?TRUE:FALSE;

         // Turn off mirroring while creating the keyboard keys

         dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
         SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle & ~WS_EX_LAYOUTRTL); 

         for (i = 1; i < lenKBkey; i++)
         {
            switch (KBkey[i].ktype)
            {
                case KNORMAL_TYPE:      wsprintf(Wclass, TEXT("N%d"), i);  break;
                case KMODIFIER_TYPE:    wsprintf(Wclass, TEXT("M%d"), i);  break;
                case KDEAD_TYPE:        wsprintf(Wclass, TEXT("D%d"), i);  break;
                case NUMLOCK_TYPE:      wsprintf(Wclass, TEXT("NL%d"), i); break;
                case SCROLLOCK_TYPE:    wsprintf(Wclass, TEXT("SL%d"), i); break;
            }
            
            // Show only the keys that are supposed to show for this keyboard type

            if (((smallKb == TRUE) && (KBkey[i].smallKb == SMALL)) ||
                ((smallKb == FALSE) && (KBkey[i].smallKb == LARGE)) ||
                 (KBkey[i].smallKb == BOTH))
            {
               isvisible = TRUE;   //Show this key
            }
            else
            {
               isvisible = FALSE;  //Hide this key
            }

            lpkeyhwnd[i] = CreateWindow(
                                    Wclass, 
                                    KBkey[i].textC,
                                    WS_CHILD|(WS_VISIBLE * isvisible)|BS_PUSHBUTTON|WS_CLIPSIBLINGS|WS_BORDER,
                                    KBkey[i].posX * g_margin,
                                    KBkey[i].posY * g_margin,
                                    KBkey[i].ksizeX * g_margin + PrefDeltakeysize,
                                    KBkey[i].ksizeY * g_margin + PrefDeltakeysize,
                                    hwnd, 
                                    (HMENU)IntToPtr(i), 
                                    hInst, NULL);

            if (lpkeyhwnd[i] == NULL)
            {
               DBPRINTF(TEXT("WM_CREATE:  Error %d creating key %s\r\n"), GetLastError(), KBkey[i].apszKeyStr[0]);
               SendErrorMessage(IDS_CANNOT_CREATE_KEY);
               break;
            }
         }

         // Restore mirroring to main window
         SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle);

         // Watch for desktop switches (eg user hits Ctrl+Alt+Del).
         // Note:  even with FUS we get desktop switch notification
         // and we get the notification before we get the disconnect
         // notification from TS.

         InitWatchDeskSwitch(hwnd, WM_USER + 2);
         return 0;
         break;

      case WM_USER + 2:
         // When the desktop changes, if UtilMan is running exit.  
         // UtilMan will start us up again if necessary.
         if (IsUtilManRunning() /*&& CanLockDesktopWithoutDisconnect()*/)
         {
             BLDExitApplication(hwnd);  // this sends WM_DESTROY
         } 
         return 0;
         break;

      // This is a message from the global keyboard hook
      case WM_GLOBAL_KBDHOOK:
         KeybdInputProc(wParam, lParam);
		 return 0;
         break;


      // The WS_EX_NOACTIVATE style bit only stops us from being activated when the
      // focus belongs to a window of another thread. We have to use this message to
      // stop the OSK window from taking focus from other windows on our thread - ie.
      // the Font and Typing Mode dialogs.
      // Don't allow this window to be activated if it's a click over the client area.
      // non-Client - menus, caption bar, etc - is ok.
      case WM_MOUSEACTIVATE:
      {
         if( LOWORD( lParam ) == HTCLIENT )
             return MA_NOACTIVATE;
         else
             return MA_ACTIVATE;
      }

         
      //
	  // WM_SETCURSOR is sent whether we are activated or not.  We use it to determine
	  // if the mouse is over the keyboard (client area) of OSK.  If so, we force the
	  // the foreground window to be the target input window.  If the mouse is over
	  // the caption or menu area then we activate the OSK window so menus and dragging
	  // work.
	  //

	  case WM_SETCURSOR:
		  {
			  WORD  wHitTestValue;
			  // Get hit test and button state information

			  wHitTestValue = LOWORD(lParam);
			  s_fGotMouseDown = (HIWORD(lParam) == WM_LBUTTONDOWN);

			  // Keep track of the active window (the one we're inputting to)

			  TrackActiveWindow();

			  // If the cursor is not in the client area, reset the button colors.
              // If it's a click, activate the OSK window so that the click (which is
              // probably for the menu, caption, etc.) will work. We need to do
              // this since the window has the WS_EX_NOACTIVATE style, so we have
              // to explicitly activate the window ourselves when we need to.

			  if( ! ( wHitTestValue == HTCLIENT ) )
			  {
				  ReturnColors(s_hwndLastMouseOver, TRUE); 
                  s_hwndLastMouseOver = NULL;

                  if( s_fGotMouseDown )
                  {
                      SetForegroundWindow( hwnd );
                  }

				  return DefWindowProc(hwnd, message, wParam, lParam);
			  } 

              SetFocusToInputWindow();

			  // if the input language changes this fn changes the keyboard

			  RedrawKeysOnLanguageChange();

			  // cursor is over the main window client area; see if we are on one of the keys

			  GetCursorPos(&pt);
			  ScreenToClient(hwnd, &pt);
			  hwndMouseOver = ChildWindowFromPointEx(hwnd, pt, CWP_SKIPINVISIBLE);

              // at this point if:
              //
              // hwndMouseOver == NULL then cursor is nowhere of interest
              // hwndMouseOver == hwnd then cursor is on main window
              // hwndMouseOver != hwnd then cursor is on a key

              if (hwndMouseOver && hwndMouseOver != hwnd)
              {
                  SetCursor(LoadCursor(NULL, IDC_HAND));

				  // if the mouse button is down on a key capture the
				  // mouse so we know if it goes up w/in the same key

				  if (s_fGotMouseDown)
				  {
					  SetCapture(hwnd);
				  }

                  // if cursor is in a new key then update highlighting

			      if (s_hwndLastMouseOver != hwndMouseOver)
			      {
					  ReturnColors(s_hwndLastMouseOver, TRUE); 
				   
				      g_hwndDwellKey = Dwellwindow = hwndMouseOver;

                      HighlightKey(hwndMouseOver);		   // highlight this key based on user settings

		              s_hwndLastMouseOver = hwndMouseOver; // save this key hwnd
			      }
              } 
              else if (hwndMouseOver == hwnd)
              {
                  SetCursor(LoadCursor(NULL, IDC_ARROW));
              }
		  }
		  return 0;
		  break;

      case WM_LBUTTONUP:
		  if (s_fGotMouseDown)
		  {
			  ReleaseCapture();	         // Release the mouse if we've captured it
			  s_fGotMouseDown = FALSE;
		  }

		  pt.x = GET_X_LPARAM(lParam);   // lParam has cursor coordinates
          pt.y = GET_Y_LPARAM(lParam);   // relative to client area 

		  hwndMouseOver = ChildWindowFromPointEx(hwnd, pt, CWP_SKIPINVISIBLE);

		  // if the button down was w/in this key window send the
          // char else restore the last key to normal

		  if (hwndMouseOver && s_hwndLastMouseOver == hwndMouseOver)
		  {
              SendChar(hwndMouseOver);
              s_hwndLastMouseOver = NULL;
		  }
          else
          {
			  ReturnColors(s_hwndLastMouseOver, TRUE); 
              s_hwndLastMouseOver = hwndMouseOver;
          }
		  return 0;
		  break;

      case WM_RBUTTONDOWN:
          KillScanTimer(TRUE); // stop scanning
		  return 0;
          break;

      case WM_SIZE:

		  if (!s_fIgnoreSizeMsg)
		  {  
			 int KB_SMALLRMARGIN= 137;

			 GetClientRect(g_hwndOSK, &rectC);
			 GetWindowRect(g_hwndOSK, &rect);

			 if ((oldWidth == rect.right) && (oldHeight == rect.bottom))
				return 0;

			 bmargin  = KB_CHARBMARGIN;      //smallest height

			 // SmallMargin for Actual / Block layout
			 KB_SMALLRMARGIN = (kbPref->Actual) ? KB_LARGERMARGIN:224; // actual:block

			 rmargin = (smallKb == TRUE) ? KB_SMALLRMARGIN:KB_LARGERMARGIN;

			 if (smallKb && ForStartUp1)   //Start up with Small KB
			 {
				 //why - 10? -> The number doesnt really match the origianl size, so - 10
				 colMargin = ((float)rectC.right * 3 / 2 - 10) / (float)rmargin;
			 }
			 else if (smallKb)			   //Small KB but NOT at start up
			 {
				 colMargin = g_KBC_length / (float)rmargin;
			 }
			 else						   //Large KB
			 {
				 //rmargin is smallest width; colMargin is the ratio; see explain
				 colMargin = (float)rectC.right / (float)rmargin; 
			 }

			 //bmargin is smallest height; rowMargin is the ratio; see explain
			 rowMargin = (float)rectC.bottom  / (float)bmargin;  

			 // place to the right place on screen at STARTUP TIME

			 if (ForStartUp1 && !Setting_ReadSuccess)    
			 {
				// At StartUp and CANNOT read setting file position at lower left
				ForStartUp1= FALSE;
				s_fIgnoreSizeMsg= TRUE;

				rect.bottom = rect.bottom - (rectC.bottom - ((int)rowMargin * bmargin));
				rect.right = rect.right - (rectC.right - ((int)colMargin * rmargin));

				MoveWindow(
					g_hwndOSK, 
					rect.left, 
					scrCY-30-(rect.bottom - rect.top),
					rect.right - rect.left,
					rect.bottom - rect.top,  
					TRUE);
			 }
			 else if (ForStartUp1 && Setting_ReadSuccess)
			 {  
				// At StartUp and can read setting file position at last position
				ForStartUp1= FALSE;
				s_fIgnoreSizeMsg= TRUE;           

				// Check to see the KB is  not out of screen with the current resolution

				if (IsOutOfScreen(scrCX, scrCY))
				{
				   MoveWindow(
					   g_hwndOSK, 
					   scrCX/2 - (kbPref->KB_Rect.right - kbPref->KB_Rect.left)/2,
					   scrCY - 30 - (kbPref->KB_Rect.bottom - kbPref->KB_Rect.top),
					   kbPref->KB_Rect.right - kbPref->KB_Rect.left,
					   kbPref->KB_Rect.bottom - kbPref->KB_Rect.top, 
					   TRUE);
				}
				else
				{
				   MoveWindow(g_hwndOSK, 
					   kbPref->KB_Rect.left,
					   kbPref->KB_Rect.top,
					   kbPref->KB_Rect.right - kbPref->KB_Rect.left,
					   kbPref->KB_Rect.bottom - kbPref->KB_Rect.top,
					   TRUE);
				}
			 }

			 s_fIgnoreSizeMsg = FALSE;

			 oldWidth = rect.right;
			 oldHeight = rect.top;

			 // Turn off mirroring while positioning the buttons

			 dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
			 SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle & ~WS_EX_LAYOUTRTL); 

			 // Positon the keys
			 for (i = 1 ; i < lenKBkey ; i++)
			 {
				int w, h;   //width and height of each window key
            
				// *** show / not show the keys between small/large keyboard
				if (((smallKb == TRUE) && (KBkey[i].smallKb == SMALL)) ||
				   ((smallKb == FALSE) && (KBkey[i].smallKb == LARGE)) ||
					(KBkey[i].smallKb == BOTH))
				{
				   ShowWindow(lpkeyhwnd[i], SW_SHOW);
				}
				else
				{
				   ShowWindow(lpkeyhwnd[i], SW_HIDE);
				}

				if (ForStartUp2 && !Setting_ReadSuccess)
				{
					// At StartUp and cant read setting file move keys based on defaults
					MoveWindow(lpkeyhwnd[i],   
							KBkey[i].posX * (int)colMargin,
							KBkey[i].posY * (int)rowMargin,
							KBkey[i].ksizeX * (int)colMargin + PrefDeltakeysize,
							KBkey[i].ksizeY * (int)rowMargin + PrefDeltakeysize,
							TRUE);
				}
				else
				{  
					// At not startup / at startup and can read setting file use save position
					MoveWindow(lpkeyhwnd[i],
							(int)((float)KBkey[i].posX * colMargin),
							(int)((float)KBkey[i].posY * rowMargin),
							(int)((float)KBkey[i].ksizeX * colMargin) + PrefDeltakeysize,
							(int)((float)KBkey[i].ksizeY * rowMargin) + PrefDeltakeysize,
							TRUE);
				}

				w = (int) ((KBkey[i].ksizeX * colMargin) + PrefDeltakeysize);
				h = (int) ((KBkey[i].ksizeY * rowMargin) + PrefDeltakeysize);

				SetKeyRegion(lpkeyhwnd[i], w, h);  //set the region we want for each key

			 }   //end for each key loop

			 // restore mirroring on main window
			 SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyle); 

			 ForStartUp2= FALSE;
		  }  // s_fIgnoreSizeMsg

		  if (!IsIconic(g_hwndOSK))
		  {
			 GetWindowRect(g_hwndOSK, &kbPref->KB_Rect);
		  }

		  return 0;

      case WM_SHOWWINDOW:
         RedrawNumLock();   //Hilit the NUMLOCK key if it is on
         RedrawScrollLock();//hilite the Scroll Key if it is on
		 return 0;

      case WM_MOVE:
         if (!IsIconic(g_hwndOSK))
		 {
            GetWindowRect(g_hwndOSK, &kbPref->KB_Rect);   //Save the KB position
		 }
         return 0;

      //When user drags the keyboard or re-size
      case WM_ENTERSIZEMOVE:
         return 0;

      //When user finishes dragging or re-sizing
      case WM_EXITSIZEMOVE:
		 SetFocusToInputWindow();
         return 0;

      case WM_COMMAND:
         BLDMenuCommand(hwnd, message, wParam, lParam);
         break;

      case WM_CLOSE:
         return BLDExitApplication(hwnd);

      case WM_QUERYENDSESSION:
         return TRUE;

      case WM_ENDSESSION:
      {
          // forced to end; make osk start up again next time user logs on
          HKEY hKey;
          DWORD dwPosition;
          const TCHAR szSubKey[] =  __TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
          const TCHAR szImageName[] = __TEXT("OSK.exe");

          BLDExitApplication(hwnd);

          if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szSubKey, 0, NULL,
             REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwPosition))
          {
             RegSetValueEx(hKey, NULL, 0, REG_SZ, (CONST BYTE*)szImageName, (lstrlen(szImageName)+1)*sizeof(TCHAR) );
             RegCloseKey(hKey);
          }
      }
      return 0;
      
      case WM_TIMER:
		 KillTimer(hwnd, TIMER_HELPTOOLTIP);
		 SendMessage(g_hToolTip,TTM_TRACKACTIVATE,(WPARAM)FALSE,(LPARAM)&ti);
	     break;

      case WM_DESTROY:            /* window being destroyed                   */
         TermWatchDeskSwitch();
         FinishProcess();
         PostQuitMessage(0);
         return TRUE;

      case WM_USER + 1:
         Scanning(1);  // Start scanning again
         return TRUE;

      case WM_INITMENUPOPUP:
      {
         HMENU hMenu = (HMENU) wParam;

         CheckMenuItem(hMenu, IDM_ALWAYS_ON_TOP, (PrefAlwaysontop ? MF_CHECKED : MF_UNCHECKED));
         CheckMenuItem(hMenu, IDM_CLICK_SOUND, (Prefusesound ? MF_CHECKED : MF_UNCHECKED));

         //Small or Large KB
         if (kbPref->smallKb)
         {        
            CheckMenuRadioItem(hMenu, IDM_LARGE_KB, IDM_SMALL_KB, IDM_SMALL_KB, MF_BYCOMMAND);
         }
         else
         {
            CheckMenuRadioItem(hMenu, IDM_LARGE_KB, IDM_SMALL_KB, IDM_LARGE_KB, MF_BYCOMMAND);
         }

         //Regular or Block Layout
         if (kbPref->Actual)
         {
            CheckMenuRadioItem(hMenu, IDM_REGULAR_LAYOUT, IDM_BLOCK_LAYOUT, IDM_REGULAR_LAYOUT, MF_BYCOMMAND);

            // enable the 102, 106 menu 
            EnableMenuItem(hMenu, IDM_102_LAYOUT, MF_ENABLED);
            EnableMenuItem(hMenu, IDM_106_LAYOUT, MF_ENABLED);
         }
         else   //Block layout 
         {
            CheckMenuRadioItem(hMenu, IDM_REGULAR_LAYOUT, IDM_BLOCK_LAYOUT, IDM_BLOCK_LAYOUT, MF_BYCOMMAND);

            //Disable the 102, 106 menu
            EnableMenuItem(hMenu, IDM_102_LAYOUT, MF_GRAYED);
            EnableMenuItem(hMenu, IDM_106_LAYOUT, MF_GRAYED);
         }

         switch (kbPref->KBLayout)
         {
             case 101:
                CheckMenuRadioItem(hMenu,IDM_101_LAYOUT, IDM_106_LAYOUT, IDM_101_LAYOUT, MF_BYCOMMAND);
      
                //disable these two menus
                EnableMenuItem(hMenu, IDM_REGULAR_LAYOUT, MF_ENABLED);
                EnableMenuItem(hMenu, IDM_BLOCK_LAYOUT, MF_ENABLED);
                break;

             case 102:
                CheckMenuRadioItem(hMenu,IDM_101_LAYOUT, IDM_106_LAYOUT, IDM_102_LAYOUT, MF_BYCOMMAND);
      
                //disable these two menus
                EnableMenuItem(hMenu, IDM_REGULAR_LAYOUT, MF_GRAYED);
                EnableMenuItem(hMenu, IDM_BLOCK_LAYOUT, MF_GRAYED);
                break;

             case 106:
                CheckMenuRadioItem(hMenu,IDM_101_LAYOUT, IDM_106_LAYOUT, IDM_106_LAYOUT, MF_BYCOMMAND);
      
                //disable these two menus
                EnableMenuItem(hMenu, IDM_REGULAR_LAYOUT, MF_GRAYED);
                EnableMenuItem(hMenu, IDM_BLOCK_LAYOUT, MF_GRAYED);
                break;
         }

		 // Disable help menus on all but default desktop
		 if ( OSKRunSecure() )
		 {
              EnableMenuItem(hMenu, CM_HELPABOUT, MF_GRAYED);
              EnableMenuItem(hMenu, CM_HELPTOPICS, MF_GRAYED);
		 }
		  return 0;
      }


      case WM_HELP:
          if ( !OSKRunSecure() )
          {
              TCHAR buf[MAX_PATH]=TEXT("");
              UINT cch;

              cch = GetWindowsDirectory(buf,MAX_PATH);
              if (cch > 0 && cch < MAX_PATH)
              {
                  lstrcat(buf, TEXT("\\HELP\\OSK.CHM"));
              }
              else // bit of a hack for PREFIX
              {
                  lstrcpy(buf, TEXT("OSK.CHM"));
              }

              HtmlHelp(NULL, buf, HH_DISPLAY_TOPIC, 0);
          }
          return TRUE;

		// SW_SWITCH1DOWN is posted from msswch by swchPostSwitches()
		// when the key to start scanning is pressed
        case SW_SWITCH1DOWN:
            if (PrefScanning)
            {
                // Keep track of the active window (the one we're inputting
                // to) and redraw keys if the input language changes
                TrackActiveWindow();
                RedrawKeysOnLanguageChange();

                Scanning(1);
            }
            break;

		default:
			break;
   }
   return DefWindowProc (hwnd, message, wParam, lParam) ;
}


/*****************************************************************************/
/* LRESULT WINAPI kbKeyWndProc (HWND hwndKey, UINT message, WPARAM wParam, */
/*                       LPARAM lParam)                              */
/* BitMap Additions : a-anilk: 02-16-99                               */
/*****************************************************************************/
LRESULT WINAPI kbKeyWndProc (HWND hwndKey, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc ;
    PAINTSTRUCT ps ;
    RECT        rect;
    int         iKey, iKeyCookie;
	KBkeyRec    *pKey;

    iKey = GetWindowLong(hwndKey, GWL_ID);  //order of the key in the array
	pKey = KBkey + iKey;
    switch (message)
    {
        case WM_CREATE:
            SetWindowLong(hwndKey, 0, 0) ;       // on/off flag
            return 0 ;

        case WM_PAINT:
            hdc = BeginPaint(hwndKey, &ps);
            GetClientRect(hwndKey, &rect);
            iKeyCookie = GetWindowLong(hwndKey,0);

            switch(iKeyCookie)
            {
                case 0:           //*** Normal Button ***
                if (pKey->name == BITMAP)
                {
                    // Draw bitmaps
                    if (CapsLockIsOn() && pKey->scancode[0] == CAPLOCK_SCANCODE)
                    {
                            SetWindowLong(hwndKey, 0, 1);
                            SetClassLongPtr(hwndKey, GCLP_HBRBACKGROUND, 
                                         (LONG_PTR)CreateSolidBrush(RGB(0,0,0)));

                            InvalidateRect(hwndKey, NULL, TRUE);

                            RDrawBitMap(hdc, pKey->skLow, rect, FALSE);
                            g_hBitmapLockHwnd = hwndKey;
                    }
                    else
                    {
                        RDrawBitMap(hdc, pKey->textL, rect, TRUE);
                    }
                }

                if (pKey->name == ICON)
                {
                    RDrawIcon(hdc, pKey->textL, rect);
                }
                break;

                case 1:          //*** Button down ***
                if (pKey->name == BITMAP)
                {
                    RDrawBitMap(hdc, pKey->skLow, rect, TRUE);
                }

                if (pKey->name == ICON)
                {
                    RDrawIcon(hdc, pKey->textC, rect);
                }
                break;

                case 4:         //*** highlight key while moving around  
                if (!PrefScanning)
                {
                    udfDraw3Dpush(hdc, rect);
                }

                if (pKey->name == ICON)
                {
                    RDrawIcon(hdc, pKey->skLow, rect);
                }
                else if (pKey->name == BITMAP)
                {
                    RDrawBitMap(hdc, pKey->skLow, rect, FALSE);
                }
                break;

                case 5:          //*** Dwell (scan mode) ***
                PaintLine(hwndKey, hdc, rect);
                EndPaint(hwndKey, &ps);

                if (pKey->name != BITMAP)
                {
                    SetWindowLong(Dwellwindow, 0, 1);
                }
                else
                {
                    SetWindowLong(Dwellwindow, 0, 4);
                }

                return 0;
            }

            if (iKeyCookie != 4)
            {
                iKeyCookie = 0;
            }

            // Print the text on each button ignoring icons and bitmaps

            if(pKey->name != ICON && pKey->name != BITMAP)
            {
                UpdateKey(hwndKey, hdc, rect, iKey, iKeyCookie);
            }
            EndPaint(hwndKey, &ps);
            return 0;

        default:
            break;
    }
    return DefWindowProc (hwndKey, message, wParam, lParam) ;
}

/**************************************************************************/


// AssignDeskTop() For UM
// a-anilk. 1-12-98
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname)
{
    HDESK hdesk;
    wchar_t name[300];
    DWORD nl;
    // Beep(1000,1000);

    *desktopID = DESKTOP_ACCESSDENIED;
    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
    }
    GetUserObjectInformation(hdesk,UOI_NAME,name,300,&nl);
    if (pname)
	{
        wcscpy(pname, name);
	}

    if (!_wcsicmp(name, __TEXT("Default")))
	{
        *desktopID = DESKTOP_DEFAULT;
	}
    else if (!_wcsicmp(name, __TEXT("Winlogon")))
    {
        *desktopID = DESKTOP_WINLOGON;
    }
    else if (!_wcsicmp(name, __TEXT("screen-saver")))
	{
        *desktopID = DESKTOP_SCREENSAVER;
	}
    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
	{
        *desktopID = DESKTOP_TESTDISPLAY;
	}
    else
	{
        *desktopID = DESKTOP_OTHER;
	}

    CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
    SetThreadDesktop(hdesk);

    return TRUE;
}

// InitMyProcessDesktopAccess
// a-anilk: 1-12-98
static BOOL InitMyProcessDesktopAccess(VOID)
{
  origWinStation = GetProcessWindowStation();
  userWinStation = OpenWindowStation(__TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
  if (!userWinStation)
  {
      return FALSE;
  }

  SetProcessWindowStation(userWinStation);
  return TRUE;
}

// ExitMyProcessDesktopAccess
// a-anilk: 1-12-98
static VOID ExitMyProcessDesktopAccess(VOID)
{
  if (origWinStation)
  {
    SetProcessWindowStation(origWinStation);
  }

  if (userWinStation)
  {
    CloseWindowStation(userWinStation);
    userWinStation = NULL;
  }
}

// a-anilk added
// Returns the current desktop-ID
DWORD GetDesktop()
{
    HDESK hdesk;
    TCHAR name[300];
    DWORD value, nl, desktopID = DESKTOP_ACCESSDENIED;

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return DESKTOP_WINLOGON;
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, name, 300, &nl);
    CloseDesktop(hdesk);
    
	if (!_wcsicmp(name, __TEXT("Default")))
	{
        desktopID = DESKTOP_DEFAULT;
	}
    else if (!_wcsicmp(name, __TEXT("Winlogon")))
	{
        desktopID = DESKTOP_WINLOGON;
	}
    else if (!_wcsicmp(name, __TEXT("screen-saver")))
	{
        desktopID = DESKTOP_SCREENSAVER;
	}
    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
	{
        desktopID = DESKTOP_TESTDISPLAY;
	}
    else
	{
        desktopID = DESKTOP_OTHER;
	}
    
	return desktopID;
}

// Moves the dialog outside of the OSK screen area, Either on top if
// space permits or on the bottom edge of OSK: 
void RelocateDialog(HWND hDlg)
{
   RECT rKbMainRect, rDialogRect, Rect;
   int x, y, width, height;
   
   GetWindowRect(g_hwndOSK, &rKbMainRect);
   GetWindowRect(hDlg, &rDialogRect);
   
   width = rDialogRect.right - rDialogRect.left;
   height = rDialogRect.bottom - rDialogRect.top;
   
   GetWindowRect(GetDesktopWindow(),&Rect);
   if ((rKbMainRect.top - height) > Rect.top)
   {
      // There is enough space over OSK window, place the dialog on the top of the osk window
      y = rKbMainRect.top - height;
      x = rKbMainRect.left + (rKbMainRect.right - rKbMainRect.left)/2 - \
         (rDialogRect.right - rDialogRect.left)/2 ;
   }
   else if ((rKbMainRect.bottom + height) < Rect.bottom)
   {
      // There is enough space under OSK window, place the dialog on the bottom of the osk window
      y = rKbMainRect.bottom;
      x = rKbMainRect.left + (rKbMainRect.right - rKbMainRect.left)/2 - \
         (rDialogRect.right - rDialogRect.left)/2 ;
   }
   else
   {
      // It is not possible to see the entire dialog, dont move it.
      return;
   }
   
   MoveWindow(hDlg, x, y, width, height, 1);
}

/************************************************************************/
/* DoButtonUp
/************************************************************************/
void DoButtonUp(HWND hwndKey)
{
	// don't need to change the bitmap color. It will be change with WM_PAINT message
	if (g_hBitmapLockHwnd != hwndKey)
    {
	    SetWindowLong (hwndKey, 0, 0);

		InvalidateRect (hwndKey, NULL, TRUE);

	    if (Prefusesound == TRUE)
	    {
		    MakeClick(SND_DOWN);
	    }
    }
}

/**************************************************************************/
/* SetFocusToInputWindow - set input focus on input window
/**************************************************************************/
void SetFocusToInputWindow()
{
	if (g_hwndInputFocus)
	{
	    SetForegroundWindow(g_hwndInputFocus);
		AllowSetForegroundWindow(ASFW_ANY);
	} 
}

/************************************************************************/
/* TrackActiveWindow - keep track of the window with input focus
/************************************************************************/
void TrackActiveWindow()
{
	HWND hwndT = GetForegroundWindow();

	// When the user is doing ALT+TAB thru top-level windows then GetForegroundWindow
	// may return NULL.  We need to detect this here and set the input focus variable
	// to NULL so that when the keyup on ALT happens we won't force the input back to
	// the previous window.  However, if we aren't doing ALT+TAB then we need to ignore
	// NULL from GetForegroundWindow because when clicking quickly with the mouse
	// (where we are getting activated then forcing the target window to be activated)
	// GetForegroundWindow can return NULL between [I assume] us being deactivated
	// and the target window being activated.

	// ISSUE:  If we ALT+TAB to a CMD window then we aren't able to ALT+TAB
	//         back out.  What is it about cmd windows?  Other windows work.

	if (DoingAltTab() && !hwndT)
	{
		g_hwndInputFocus = NULL;
		return;
	}
	if (hwndT && hwndT != g_hwndOSK)
	{
		g_hwndInputFocus = hwndT;
	}

	// Detect when the window we've been working with gets destroyed

	if (g_hwndInputFocus && !IsWindow(g_hwndInputFocus))
	{
		g_hwndInputFocus = NULL;
	}
}

/************************************************************************/
/* FindKey - return index to key with specified scan code
/************************************************************************/
__inline int FindKey(UINT sc, BOOL fExt)
{
	int i;
	KBkeyRec *pKey;

	for (i=1, pKey=&KBkey[i]; i<lenKBkey; i++, pKey++)
    {
        if ((!fExt && pKey->scancode[0] == sc) || (fExt && pKey->scancode[1] == sc))
        {
            break;
        }
    }
	return (i < lenKBkey)?i:-1;
}

/************************************************************************/
/* KeybdInputProc
/*
/* Notes:  If the soft keyboard appearance needs to change based on both
/* physical and osk key presses then the logic for that needs to go in
/* KeybdInputProc because that is the only place both are detected. 
/* Otherwise, the logic can go in UpdateKey.  Don't put the logic
/* in both places or you'll end up doing everything twice.
/*
/************************************************************************/
LRESULT CALLBACK KeybdInputProc(
   WPARAM  wParam,    // virtual-key code
   LPARAM  lParam     // keystroke-message information
   )
{
    UINT sc;
    UINT vk = (UINT)wParam;
    UINT uiMsg = (lParam & 0x80000000) ? WM_KEYUP : WM_KEYDOWN;
    int i;
    #define GET_KEY_INDEX(sc, i, fext) \
    { \
	    i = FindKey(sc, fext); \
	    if (i < 0) \
		    break;	/* internal error! */ \
    }

	if (uiMsg == WM_KEYDOWN)
	{
		switch(vk)
		{
			case VK_SHIFT:
				// When using the physical keyboard we get many of these as the user presses and holds
				// the shift (before they enter the real key and release shift) so avoid all the redrawing...
				if (!g_fShiftKeyDn)
				{
					g_fShiftKeyDn = TRUE;

                    // Make both shift keys work in sync
                    GET_KEY_INDEX(LSHIFT_SCANCODE, i, FALSE);
					SetWindowLong(lpkeyhwnd[i], 0, 4);
                    SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);

                    GET_KEY_INDEX(RSHIFT_SCANCODE, i, FALSE);
					SetWindowLong(lpkeyhwnd[i], 0, 4);
                    SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);

					RedrawKeys();
				}
				break;

			case VK_MENU:
				// When using the physical keyboard we get many of these as the user presses and holds
				// the RALT (before they enter the real key and release shift) so avoid all the redrawing.
				// Only check for ALTGR if there are ALTGR keys to display.
				if (CanDisplayAltGr() && !g_fRAltKey)
				{
					g_fRAltKey = HIBYTE(GetKeyState(VK_RMENU)) & 0x01;
					if (g_fRAltKey)
					{
						RedrawKeys();
					}
				}
				if (CanDisplayAltGr() && !g_fLAltKey)
				{
                    // When LALT is pressed the system toggles (and we see) VK_CONTROL
					g_fLAltKey = HIBYTE(GetKeyState(VK_MENU)) & 0x01;
					if (g_fLAltKey && g_fLCtlKey)
					{
						RedrawKeys();
					}
				}
				break;

            case VK_CONTROL:
				// When using the physical keyboard we get many of these as the user presses and holds
				// the LCTRL (before they enter the real key and release shift) so avoid all the redrawing.
				// Only check for ALTGR if there are ALTGR keys to display.
				if (CanDisplayAltGr() && !g_fLCtlKey)
				{
                    g_fLCtlKey = HIBYTE(GetKeyState(VK_CONTROL)) & 0x01;
					if (g_fLAltKey && g_fLCtlKey)
					{
						RedrawKeys();
					}
				}
                break;
		}
	}
	else if (uiMsg == WM_KEYUP)
	{
		switch(vk)
		{
            //
            // F11 minimizes and restores the keyboard
            //
			case VK_F11:
			   if(IsIconic(g_hwndOSK)) 
			   {
				  ShowWindow(g_hwndOSK, SW_RESTORE);
			   }
			   else
			   {
				  ShowWindow(g_hwndOSK, SW_SHOWMINIMIZED);
			   }
			   break;
			
            //
            // Show CAPSLOCK toggled and change the keyboard to upper or
			// lower case.  Do this here so the keyboard changes on physical 
			// key press as well as soft keyboard key press.
            //
			case VK_CAPITAL:
				g_fCapsLockOn = (LOBYTE(GetKeyState(VK_CAPITAL)) & 0x01); //Update CapLock drawn flag

                // find the CAPSLOCK scancode to get the hwnd to modify

				GET_KEY_INDEX(CAPLOCK_SCANCODE, i, FALSE);

				if (g_fCapsLockOn)   // CapsLock On
				{	
                    SetCapsLock(lpkeyhwnd[i]);

				    //Hilite Cap key
                    SetWindowLong(lpkeyhwnd[i], 0, 4);
                    SetBackgroundColor(lpkeyhwnd[i], COLOR_HOTLIGHT);

                    if (KBkey[i].name == BITMAP)     //Updates japanese CapLock
					{
                        g_hBitmapLockHwnd = lpkeyhwnd[i];
					}
				}
				else                  // CapsLock off
				{
                    SetCapsLock(NULL);

					SetWindowLong(lpkeyhwnd[i], 0, 0);
					SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);

					if (KBkey[i].name == BITMAP)     //Updates japanese CapLock
					{
						g_hBitmapLockHwnd = NULL;
					}
				}
				RedrawKeys();
    			break;

			case VK_SHIFT:
				g_fShiftKeyDn = FALSE;

                // Make both shift keys work in sync
				GET_KEY_INDEX(LSHIFT_SCANCODE, i, FALSE);
				SetWindowLong(lpkeyhwnd[i], 0, 0);
				SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);

				GET_KEY_INDEX(RSHIFT_SCANCODE, i, FALSE);
				SetWindowLong(lpkeyhwnd[i], 0, 0);
				SetBackgroundColor(lpkeyhwnd[i], COLOR_INACTIVECAPTION);

				RedrawKeys();
				break;

			case VK_MENU:
				if (g_fRAltKey)
				{
					g_fRAltKey = FALSE;
					RedrawKeys();
				}
				if (g_fLAltKey)
				{
					g_fLAltKey = FALSE;
					RedrawKeys();
				}
				g_fDoingAltTab = FALSE;
				break;

            case VK_CONTROL:
				if (g_fLCtlKey)
				{
					g_fLCtlKey = FALSE;
				}
                // I think we always need to redraw keys on VK_CONTROL
                // because that is a special key on the JPN 106 keyboard.
				RedrawKeys();
				break;

            //
            // Redraw NUMLOCK, SCROLL, etc... based on toggle state
            //
			case VK_NUMLOCK:
				RedrawNumLock();
    			break;

			case VK_SCROLL:
				RedrawScrollLock();
			    break;

			case VK_KANA:
				RedrawKeys();   
			    break;

            default:
			    break;
		}
    }
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\event.c ===
// ----------------------------------------------------------------------------
//
// Event.c
//
//
// Author: Jost Eckhardt
// 
// This code was written for ECO Kommunikation Insight
// (c) 1997-99 ECO Kommunikation
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
// -----------------------
HANDLE BuildEvent(LPTSTR name,BOOL manualRest,BOOL initialState,BOOL inherit)
{
HANDLE ev;
LPSECURITY_ATTRIBUTES psa = NULL;
obj_sec_attr_ts sa;
  if (!name)
		return CreateEvent(NULL, manualRest, initialState, NULL);
  if (inherit)
	{
		psa = &sa.sa;
    InitSecurityAttributes(&sa);
	}
  ev = CreateEvent(psa, manualRest, initialState, name);
  if (inherit)
  	ClearSecurityAttributes(&sa);
	return ev;
}//BuildEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\desktop.c ===
// ----------------------------------------------------------------------------
//
// Desktop.c
//
//
// Author: Jost Eckhardt
// 
// This code was written for ECO Kommunikation Insight
// Copyright (c) 1997-1999 Microsoft Corporation
//
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>

#include "_UMTool.h"
#include "UtilMan.h"
#include "LmErr.h"
#include "LmAccess.h"
#include "LmApiBuf.h"

#ifndef ONLY_DSWITCH

// ----------------------------------------------------
BOOL InitDesktopAccess(desktop_access_tsp dAccess)
{
	memset(dAccess,0,sizeof(desktop_access_ts));
	dAccess->orgStation = GetProcessWindowStation();

	dAccess->userStation= OpenWindowStation(_TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
	if (!dAccess->userStation)
  		return FALSE;

	SetProcessWindowStation((HWINSTA)dAccess->userStation);
	return TRUE;
}

// ----------------------------------------------------
VOID ExitDesktopAccess(desktop_access_tsp dAccess)
{
	if (dAccess->orgStation)
	SetProcessWindowStation((HWINSTA)dAccess->orgStation);

	if (dAccess->userStation)
	CloseWindowStation((HWINSTA)dAccess->userStation);

	memset(dAccess,0,sizeof(desktop_access_ts));
}


// ----------------------------------------------------
BOOL  QueryCurrentDesktop(desktop_tsp desktop,BOOL onlyType)
{
	USER_INFO_11 *ui11;//LanManager without Administrator for own account!
	LPBYTE buf;
	HDESK hdesk;
	DWORD nl;
	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);

	if (!hdesk)
	{
		hdesk = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
		if (!hdesk)
		{
			desktop->userName[0] = 0;
			desktop->name[0] = 0;
			desktop->type = DESKTOP_ACCESSDENIED;
			desktop->user = USER_GUEST;
			return FALSE;
		}
	}

	GetUserObjectInformation(hdesk,UOI_NAME,desktop->name,NAME_LEN,&nl);
	CloseDesktop(hdesk);

	if (!_tcsicmp(desktop->name, _TEXT("Default")))
		desktop->type = DESKTOP_DEFAULT;
	else if (!_tcsicmp(desktop->name, _TEXT("Winlogon")))
		desktop->type = DESKTOP_WINLOGON;
	else if (!_tcsicmp(desktop->name, _TEXT("screen-saver")))
		desktop->type = DESKTOP_SCREENSAVER;
	else if (!_tcsicmp(desktop->name, _TEXT("Display.Cpl Desktop")))
		desktop->type = DESKTOP_TESTDISPLAY;
	else
		desktop->type = DESKTOP_OTHER;
	
	if (onlyType)
	{
		desktop->userName[0] = 0;
		desktop->user = USER_GUEST;
		return TRUE;
	}

	nl = NAME_LEN;
	GetUserName(desktop->userName, &nl);
	
	if (!_tcsicmp(desktop->userName,_TEXT("SYSTEM")))
	{
		desktop->user = USER_SUPERVISOR;
		return TRUE;
	}

	desktop->user = USER_GUEST;
	//mDEBUGOUT((1,(uchar_tp)L"%s User: %s", desktop->name,userName));
	if (NetUserGetInfo(NULL,//local computer
						desktop->userName, 11, &buf) == NERR_Success)
	{
		ui11 = (USER_INFO_11 *)buf;
		switch (ui11->usri11_priv)
		{
			case USER_PRIV_GUEST:
				desktop->user = USER_GUEST;
				break;

			case USER_PRIV_USER:
				desktop->user = USER_USER;
				break;

			case USER_PRIV_ADMIN:
			default:
				desktop->user = USER_SUPERVISOR;
		}
		//if (ui11->usri11_name)
		  //Vstrncpy(desktop->userName,ui11->usri11_name,PUBLICNAME_LEN);
		NetApiBufferFree(buf);
	}

	return TRUE;
}

#endif //ndef ONLY_DSWITCH


// ----------------------------------------------------
BOOL  SwitchToCurrentDesktop(void)
{
	HDESK hdesk;
	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
	
	if (!hdesk)
	{
		hdesk = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
		if (!hdesk)
		  return FALSE;
	}

	CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
	
	SetThreadDesktop(hdesk);
	return TRUE;
}
#ifndef ONLY_DSWITCH


// ----------------------------------------------------
VOID WaitDesktopChanged(desktop_tsp desktop)
{
	HDESK hdesk;
	DWORD i;

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
	
	for (i = 0; i < 50; i++)
	{
	  if (hdesk)
			break;
		Sleep(120);
		hdesk = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
	}

	if (hdesk)
	    CloseDesktop(hdesk);

	QueryCurrentDesktop(desktop,TRUE);
	
	SwitchToCurrentDesktop();

}
#endif //ndef ONLY_DSWITCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\osk\src\version.h ===
// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "On-Screen Keyboard\0"
#define VER_INTERNALNAME_STR        "osk\0"
#define VER_ORIGINALFILENAME_STR    "osk.exe\0"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\manageshelllinks.h ===
// StartupLinks.h: interface for the CManageShellLinks class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STARTUPLINKS_H__9F81721C_405C_4A8C_BE66_E5A6D1CDF1D5__INCLUDED_)
#define AFX_STARTUPLINKS_H__9F81721C_405C_4A8C_BE66_E5A6D1CDF1D5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STARTUP_FOLDER      TEXT("Startup")
#define STARTMENU_FOLDER    TEXT("Start Menu")
#define DESKTOP_FOLDER      TEXT("Desktop")

#include <shlobj.h>     // for IShellLink defines and prototypes
#include <oleguid.h>    // for IID_IPersistFile
#include "w95trace.h"

#ifdef __cplusplus
class CManageShellLinks  
{
public:
	CManageShellLinks(LPCTSTR pszDestFolder);
	virtual ~CManageShellLinks();
	HRESULT CreateLink(LPCTSTR pszLink, LPCTSTR pszLinkFile
                     , LPCTSTR pszStartIn, LPCTSTR pszDesc, LPCTSTR pszArgs);
	HRESULT RemoveLink(LPCTSTR pszLink);
	BOOL LinkExists(LPCTSTR pszLink);

private:
	LPTSTR CreateLinkPath(LPCTSTR pszLink);
	BOOL GetUsersFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize);
    long GetFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize);

	IShellLink *m_pIShLink;     // IShellLink interface pointer
    LPTSTR m_pszShellFolder;    // The specific shell folder 
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
// LinkExists - helper function called from C returns TRUE if pszLink exists 
BOOL LinkExists(LPCTSTR pszLink);
#ifdef __cplusplus
}
#endif

#endif // !defined(AFX_STARTUPLINKS_H__9F81721C_405C_4A8C_BE66_E5A6D1CDF1D5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\manageshelllinks.cpp ===
// StartupLinks.cpp: implementation of the CManageShellLinks class
//                   to manage Shell Folder links.
//
// Note:  Multiple calls using the same class instance don't assume any
//        information about previous calls.  The only stuff in common
//        is the IShellLink object and the specific shell folder. 
//////////////////////////////////////////////////////////////////////

#include "stdio.h"
#include "ManageShellLinks.h"
#include "_umclnt.h"

#define SHELL_FOLDERS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define LINK_EXT TEXT(".lnk")

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CManageShellLinks::CManageShellLinks(
    LPCTSTR pszDestFolder   // [in] Which shell folder to operate on
    )
    : m_pIShLink(0)
    , m_pszShellFolder(0)
{
	// Get a pointer to the IShellLink interface
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (void **)&m_pIShLink);

    if (FAILED(hr) || !m_pIShLink)
        DBPRINTF(TEXT("CManageShellLinks::CManageShellLinks:  CoCreateInstance failed 0x%x\r\n"), hr);

    m_pszShellFolder = new TCHAR[lstrlen(pszDestFolder)+1];
    if (m_pszShellFolder)
        lstrcpy(m_pszShellFolder, pszDestFolder);
}

CManageShellLinks::~CManageShellLinks()
{
	if (m_pIShLink)
	{
		m_pIShLink->Release();
		m_pIShLink = 0;
	}
    if (m_pszShellFolder)
	{
        delete [] m_pszShellFolder;
        m_pszShellFolder = 0;
	}
}

//*****************************************************************************
// GetFolderPath - returns shell folder path
//
// pszFolderPath [out]    - pointer to location for shell folder
// pulSize       [in out] - pointer to size of pszFolderPath
//
// Returns TRUE if it found the folder name else FALSE
//
long CManageShellLinks::GetFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize)
{
    *pszFolderPath = 0;

    if (!m_pszShellFolder)
        return ERROR_NOT_ENOUGH_MEMORY;

    HKEY hkeyFolders;
    HKEY hkeyUser;

    // Open current user's hive and retrieve shell folder path

    long lRv = RegOpenCurrentUser(KEY_QUERY_VALUE, &hkeyUser);

    if (lRv == ERROR_SUCCESS)
    {
        lRv = RegOpenKeyEx(
                      hkeyUser
                    , SHELL_FOLDERS
                    , 0,KEY_QUERY_VALUE
                    , &hkeyFolders);
        RegCloseKey(hkeyUser);
    }

    if (lRv == ERROR_SUCCESS)
    {
	    lRv = RegQueryValueEx( 
                      hkeyFolders
                    , m_pszShellFolder
                    , NULL, NULL
                    , (LPBYTE)pszFolderPath
                    , pulSize);

	    RegCloseKey(hkeyFolders);
    }

    return lRv;
}

//*****************************************************************************
// GetUsersFolderPath - returns the location of the current user's shell folder
//
// pszFolderPath [out]    - pointer to location for shell folder
// pulSize       [in out] - pointer to size of pszFolderPath
//
// Returns TRUE if it found the folder name else FALSE
//
BOOL CManageShellLinks::GetUsersFolderPath(LPTSTR pszFolderPath, unsigned long *pulSize)
{
    long lRv = ERROR_ACCESS_DENIED;
    unsigned long ulSize = 0;
    *pszFolderPath = 0;
    BOOL fError;

    if (m_pszShellFolder)
    {
        ulSize = *pulSize;

        // At this point, if UtilMan was started in the system context (WinKey+U),
        // HKCU points to "Default User".  We need it to point to the logged on
        // user's hive so we can get the correct path for the logged on user.
        // Note:  GetUserAccessToken() will fail if we are not started by SYSTEM
        // and in that case just get the logged on user's folder path.

        HANDLE hMyToken = GetUserAccessToken(TRUE, &fError);
        if (hMyToken)
        {
            if (ImpersonateLoggedOnUser(hMyToken))
            {
                lRv = GetFolderPath(pszFolderPath, &ulSize);
                RevertToSelf();
            }
            CloseHandle(hMyToken);
        }
        else
        {
            lRv = GetFolderPath(pszFolderPath, &ulSize);
        }
    }

    *pulSize = ulSize;
    return (lRv == ERROR_SUCCESS)?TRUE:FALSE;
}

//*****************************************************************************
// CreateLinkPath - returns the complete path and name of the link.  Caller
//                  free's the memory.
//
// pszLink [in] - the base name of the link itself
//
LPTSTR CManageShellLinks::CreateLinkPath(LPCTSTR pszLink)
{
    // allocate enough space for folder path + '\' + filename + NULL

    unsigned long ccbStartPath = MAX_PATH;
    LPTSTR pszLinkPath = new TCHAR [ccbStartPath + 1 + lstrlen(pszLink) + sizeof(LINK_EXT) + 1];
    if (!pszLinkPath)
        return NULL;

    // get the user's shell folder name

    if (!GetUsersFolderPath(pszLinkPath, &ccbStartPath) || !ccbStartPath)
    {
        delete [] pszLinkPath;
        return NULL;
    }

    // append the link name and extension

    lstrcat(pszLinkPath, TEXT("\\"));
    lstrcat(pszLinkPath, pszLink);
    lstrcat(pszLinkPath, LINK_EXT);

	return pszLinkPath;
}

//*****************************************************************************
// LinkExists - returns TRUE if pszLink exists in the shell folder else FALSE
//
// pszLink [in] - the base name of the link itself
//
BOOL CManageShellLinks::LinkExists(LPCTSTR pszLink)
{
    LPTSTR pszLinkPath = CreateLinkPath(pszLink);
    if (!pszLinkPath)
        return FALSE;

	DWORD dwAttr = GetFileAttributes(pszLinkPath);
	return (dwAttr == -1)?FALSE:TRUE;
}

//*****************************************************************************
// RemoveLink - removes a link from the user's shell folder
//
// pszLink     [in] - the base name of the link itself
//
// Returns S_OK on success or a standard HRESULT
//
HRESULT CManageShellLinks::RemoveLink(LPCTSTR pszLink)
{
	if (!m_pIShLink)
		return E_FAIL;

    LPTSTR pszLinkPath = CreateLinkPath(pszLink);
    if (!pszLinkPath)
        return E_FAIL;

	int iRemoveFailed = _wremove(pszLinkPath);

	return (iRemoveFailed)?S_FALSE:S_OK;
}

//*****************************************************************************
// CreateLink - creates a link in the user's shell folder
//
// pszLinkFile [in] - the fully qualified name of the file the link refers to
// pszLink     [in] - the base name of the link itself
// pszStartIn  [in] - working directory (may be NULL)
// pszDesc     [in] - the tooltip for the link (may be NULL)
// pszArgs     [in] - command line arguments (may be NULL)
//
// Returns S_OK on success or a standard HRESULT
//
HRESULT CManageShellLinks::CreateLink(
    LPCTSTR pszLink, 
    LPCTSTR pszLinkFile, 
    LPCTSTR pszStartIn, 
    LPCTSTR pszDesc,
    LPCTSTR pszArgs
    )
{
	if (!m_pIShLink)
    {
        DBPRINTF(TEXT("CManageShellLinks::CreateLink:  !m_pIShLink\r\n"));
		return E_FAIL;
    }

    LPTSTR pszLinkPath = CreateLinkPath(pszLink);
    if (!pszLinkPath)
    {
        DBPRINTF(TEXT("CManageShellLinks::CreateLink:  !pszLinkPath\r\n"));
		return E_FAIL;
    }

    IPersistFile *pIPersistFile;

    // Get the IPersistFile interface to save the shortcut

    HRESULT hr = m_pIShLink->QueryInterface(IID_IPersistFile, (void **)&pIPersistFile);
    if (SUCCEEDED(hr))
    {
        // Set the path to and description of the link

		// The shortcut
        if (FAILED(m_pIShLink->SetPath(pszLinkFile)))
	        DBPRINTF(TEXT("SetPath failed!\r\n"));

		// ToolTip description
        if (pszDesc && FAILED(m_pIShLink->SetDescription(pszDesc)))
	        DBPRINTF(TEXT("SetDescription failed!\r\n"));

		// Working directory
		if (pszStartIn && FAILED(m_pIShLink->SetWorkingDirectory(pszStartIn)))
			DBPRINTF(TEXT("SetWorkingDirectory failed!\r\n"));

        // Command line args
        if (pszArgs && FAILED(m_pIShLink->SetArguments(pszArgs)))
            DBPRINTF(TEXT("SetArguments failed!\r\n"));

        // Save it

        if (FAILED(pIPersistFile->Save(pszLinkPath, TRUE)))
	        DBPRINTF(TEXT("Save failed!\r\n"));

        pIPersistFile->Release();
    }

    delete [] pszLinkPath;

    return hr;
}

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// LinkExists - helper function called from C returns TRUE if pszLink exists 
//              in the shell folder else FALSE
//
// pszLink [in] - the base name of the link itself
//
BOOL LinkExists(LPCTSTR pszLink)
{
    CManageShellLinks CMngShellLinks(STARTUP_FOLDER);

    return CMngShellLinks.LinkExists(pszLink);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umanclnt.c ===
// ----------------------------------------------------------------------------
//
// UManClnt.c
//
// Utility Manager client depending code (used by UtilMan and UManDlg)
//
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//
// History: created oct-98 by JE
//          JE nov-15-98: removed any code related to key hook
//          YX may-27-99: functions to start apps under current user account
//			YX may-29-99: apps start under user account even from LogOn desktop,
//						  if possible
//			YX jun-04-99: code to report the app processes status even if they
//						  have been started outside Utilman
//			YX jun-23-99: IsAdmin function added (used in the dialog)
//			Bug Fixes and Changes Anil Kumar 1999
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
#include "w95trace.c"
#include "UtilMan.h"
#include "_UMClnt.h"
#include "ums_ctrl.h"
#include "w95trace.h"

// Handle to the utilman instance that is showing UI
HANDLE g_hUIProcess = 0;
// From Terminal services
extern BOOL GetWinStationUserToken(ULONG, PHANDLE);
// Private User function that returns user token for session 0 only
HANDLE GetCurrentUserTokenW( WCHAR WinSta[], DWORD desiredAccess);

#include <psapi.h>
#define MAX_NUMBER_OF_PROCESSES 2048

//
// RunningInMySession - returns TRUE if the specified process ID is 
// running in the same session as UtilMan.  In Whistler, with terminal
// services integrated, UtilMan is able to get information about 
// processes that are not running in the same session.  We must
// avoid impacting these processes.
//
BOOL RunningInMySession(DWORD dwProcessId)
{
    DWORD dwSessionId = -1;
    static DWORD dwMySessionId = -1;

    if (-1 == dwMySessionId)
    {
        ProcessIdToSessionId(GetCurrentProcessId(), &dwMySessionId);
    }

    ProcessIdToSessionId(dwProcessId, &dwSessionId);

    return (dwSessionId == dwMySessionId)?TRUE:FALSE;
}

// These are for compiling with irnotig.lib
// To be REMOVED once that becomes an API of advapi.lib
PVOID MIDL_user_allocate(IN size_t BufferSize)
{
    return( LocalAlloc(0, BufferSize));
}

VOID MIDL_user_free(IN PVOID Buffer)
{
    LocalFree( Buffer );
}

BOOL StartAppAsUser( LPCTSTR appPath, 
					 LPTSTR cmdLine,
					 LPSTARTUPINFO lpStartupInfo,
					 LPPROCESS_INFORMATION lpProcessInformation);

BOOL GetApplicationProcessInfo(umclient_tsp tspClient, BOOL fCloseHandle);
BOOL CloseAllWindowsByProcessID(DWORD procID);


// ---------------------------------
static BOOL ErrorOnLaunch(umclient_tsp client);

// ---------------------------------
BOOL StartClient(HWND hParent,umclient_tsp client)
{
	if (client->runCount >= client->machine.MaxRunCount)
	{
		DBPRINTF(_TEXT("StartClient run count >= max run count\r\n"));
		return FALSE;
	}

	switch (client->machine.ApplicationType)
	{
		case APPLICATION_TYPE_APPLICATION:
		{
			BOOL fStarted;
			TCHAR ApplicationPath[MAX_APPLICATION_PATH_LEN+100];

			if (!GetClientApplicationPath(
				  client->machine.ApplicationName
				, ApplicationPath
				, MAX_APPLICATION_PATH_LEN))
            {
				return FALSE;
            }
            
            fStarted = StartApplication(ApplicationPath 
                                      , UTILMAN_STARTCLIENT_ARG 
                                      ,  client->user.fCanRunSecure
                                      ,  &client->processID[client->runCount]
                                      ,  &client->hProcess[client->runCount]
                                      ,  &client->mainThreadID[client->runCount]);

			if (!fStarted)
			{
				ErrorOnLaunch(client);
				return FALSE;
			}

			client->runCount++;
			client->state = UM_CLIENT_RUNNING;
			break;
		}

		case APPLICATION_TYPE_SERVICE:
		{
			DWORD i = 0;
			SERVICE_STATUS  ssStatus;
			SC_HANDLE hService;
			TCHAR arg2[200];
			LPTSTR args[2];
			SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (!hSCM)
				return FALSE;

			hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
			CloseServiceHandle(hSCM);
			if (!hService)
			{
				ErrorOnLaunch(client);
				return FALSE;
			}
  			arg2[0] = 0;
  			args[0] = UTILMAN_STARTCLIENT_ARG;
	  		args[1] = arg2;
    		if (!StartService(hService,1,args))
			{ 
				CloseServiceHandle(hService);
				ErrorOnLaunch(client);
				return FALSE;
			} 

			Sleep(1000);
			while(QueryServiceStatus(hService, &ssStatus))
			{ 
				if (ssStatus.dwCurrentState == SERVICE_RUNNING)
			    break;

				Sleep(1000);
				i++;
				if (i >= 60)
					break;
			} 

			if (ssStatus.dwCurrentState != SERVICE_RUNNING)
			{ 
				CloseServiceHandle(hService);
				ErrorOnLaunch(client);
  				return FALSE;
			} 

			CloseServiceHandle(hService);

			client->runCount++;
			client->processID[0] = 0;
			client->mainThreadID[0] = 0;
			client->hProcess[0] = NULL;
			client->state = UM_CLIENT_RUNNING;

			break;
		}

		default:
			return FALSE;
	}
	return TRUE;
}
// ---------------------------------

// The hParent window is used to signal whether the stop is interactive
// (and thus WM_COLSE could be used) or is a reaction to the desktop
// change
BOOL StopClient(umclient_tsp client)
{
	if (!client->runCount)
		return FALSE;

	switch (client->machine.ApplicationType)
	{
		case APPLICATION_TYPE_APPLICATION:
		{
			DWORD j, runCount = client->runCount;
			for (j = 0; j < runCount; j++)
			{
                // If client was started outside UtilMan then try to get its process ID
				if (client->mainThreadID[j] == 0)
				{
					if (!GetApplicationProcessInfo(client, FALSE))
					{
					    // could not find the client, so prevent attempts to stop it
						client->hProcess[j] = NULL;
					}
				}
				if (client->hProcess[j])
				{ 
				    // Try to close the application by sending a WM_CLOSE message to 
				    // all the windows in opened by the process.  Then just kill it.

					BOOL sent = CloseAllWindowsByProcessID(client->processID[j]);
					if (!sent)
					{
						TerminateProcess(client->hProcess[j],1);
					}

					client->processID[j] = 0;
                    CloseHandle(client->hProcess[j]);
	  				client->hProcess[j] = NULL;
		  			client->mainThreadID[j] = 0;
					client->runCount--;
					if (!client->runCount)
					    client->state = UM_CLIENT_NOT_RUNNING;
				}
			}
			if (runCount != client->runCount)
			{
		        for (j = 0; j < (runCount-1); j++)
                { 
			        if (!client->hProcess[j])
                    {
					    memcpy(&client->processID[j], &client->processID[j+1],sizeof(DWORD)*(runCount-j-1));
					    memcpy(&client->hProcess[j], &client->hProcess[j+1],sizeof(HANDLE)*(runCount-j-1));
					    memcpy(&client->mainThreadID[j], &client->mainThreadID[j+1],sizeof(DWORD)*(runCount-j-1));
                    } 
				}
			}
			break;
		}

		case APPLICATION_TYPE_SERVICE:
		{
			SERVICE_STATUS  ssStatus;
			SC_HANDLE hService;
			SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (!hSCM)
				return FALSE;
			hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
			CloseServiceHandle(hSCM);
			if (!hService)
				 return FALSE;
			if (ControlService(hService, SERVICE_CONTROL_STOP, &ssStatus))
			{ 
				DWORD i = 0;
				Sleep(1000);
				while(QueryServiceStatus(hService, &ssStatus))
				{ 
					if (ssStatus.dwCurrentState == SERVICE_STOPPED)
				    break;
					Sleep(1000);
					i++;
					if (i >= 60)
					break;
				} 

				if (ssStatus.dwCurrentState != SERVICE_STOPPED)
				{ 
					CloseServiceHandle(hService);
	  				return FALSE;
				} 
			} 

			CloseServiceHandle(hService);
			client->runCount--;
 			client->processID[0] = 0;
  			client->hProcess[0] = NULL;
	  		client->mainThreadID[0] = 0;
			if (!client->runCount)
  				client->state = UM_CLIENT_NOT_RUNNING;
			break;
		}

		default:
			return FALSE;
	}

	return TRUE;
}//StopClient
// ---------------------------------
static BOOL ErrorOnLaunch(umclient_tsp client)
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	BOOL r;
	TCHAR ErrorOnLaunch[MAX_APPLICATION_PATH_LEN];

	if (!GetClientErrorOnLaunch(client->machine.ApplicationName, ErrorOnLaunch,MAX_APPLICATION_PATH_LEN))
		return FALSE;
	
	if (!ErrorOnLaunch[0])
		return FALSE;
	
	memset(&si,0,sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	memset(&pi,0,sizeof(PROCESS_INFORMATION));
	
    // Assumption:  Trusted applications that can run in secure mode won't define
    // an "ErrorOnLaunch" reg key therefore we won't create this dialog as SYSTEM.
	r =	CreateProcess(ErrorOnLaunch,NULL,NULL,NULL,FALSE,
					CREATE_DEFAULT_ERROR_MODE,//|NORMAL_PRIORITY_CLASS
					NULL,NULL,&si,&pi);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
	return r;
}//ErrorOnLaunch

// ---------------------------------
BOOL  GetClientApplicationPath(LPTSTR ApplicationName, LPTSTR ApplicationPath,DWORD len)
{
	HKEY hKey, sKey;
	DWORD ec, slen,type;

	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY,0,KEY_READ,&hKey);
	
	if (ec != ERROR_SUCCESS)
		return FALSE;
	ec = RegOpenKeyEx(hKey,ApplicationName,0,KEY_READ,&sKey);
	
	if (ec != ERROR_SUCCESS)
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	slen = sizeof(TCHAR)*len;
	ec = RegQueryValueEx(sKey,UMR_VALUE_PATH,NULL,&type,(LPBYTE)ApplicationPath,&slen);
	
	if ((ec != ERROR_SUCCESS) || (type != REG_SZ))
	{
		RegCloseKey(sKey);
		RegCloseKey(hKey);
		return FALSE;
	}
	
	RegCloseKey(sKey);
	RegCloseKey(hKey);
    return (slen)?TRUE:FALSE;
	}//GetClientApplicationPath
// ---------------------------------


BOOL  GetClientErrorOnLaunch(LPTSTR ApplicationName, LPTSTR ErrorOnLaunch,DWORD len)
{
	HKEY hKey, sKey;
	DWORD ec, slen,type;
	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY,0,KEY_READ,&hKey);
	
	if (ec != ERROR_SUCCESS)
		return FALSE;
	ec = RegOpenKeyEx(hKey,ApplicationName,0,KEY_READ,&sKey);
	
	if (ec != ERROR_SUCCESS)
	{
		RegCloseKey(hKey);
		return FALSE;
	}
	
	slen = sizeof(TCHAR)*len;
	ec = RegQueryValueEx(sKey,UMR_VALUE_EONL,NULL,&type,(LPBYTE)ErrorOnLaunch,&len);
	
	if ((ec != ERROR_SUCCESS) || (type != REG_SZ))
	{
		RegCloseKey(sKey);
		RegCloseKey(hKey);
		return FALSE;
	}
	
	RegCloseKey(sKey);
	RegCloseKey(hKey);
	return TRUE;
}

BOOL TestServiceClientRuns(umclient_tsp client,SERVICE_STATUS  *ssStatus)
{
	SC_HANDLE hService;
	SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	
	if (!hSCM)
		return FALSE;
	
	hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
	CloseServiceHandle(hSCM);
	
	if (!hService)
		return FALSE;
	
	if (!QueryServiceStatus(hService, ssStatus) ||
		 (ssStatus->dwCurrentState == SERVICE_STOPPED))
	{
		CloseServiceHandle(hService);
		return FALSE;
	}

	CloseServiceHandle(hService);
	return TRUE;
}

// 
// CheckStatus - Called from utilman's main timer and the dialog's timer 
//               to detect the state of running applications and pick up
//               any that are started outside of utilman. 
//
// Returns:  TRUE if the state of any application has changed else FALSE
//
BOOL CheckStatus(umclient_tsp c, DWORD cClients)
{
	DWORD i;
    BOOL  fAnyChanges = FALSE;

	for (i = 0; i < cClients; i++)
	{
	    // detect the client process started outside UMan
		if ( (!c[i].runCount))
		{
			if (GetApplicationProcessInfo(&c[i], TRUE))
            {
                fAnyChanges = TRUE;
            }
		}
		// detect clients not running anymore or not responding
  		switch (c[i].machine.ApplicationType)
		{
			case APPLICATION_TYPE_APPLICATION:
			{
				DWORD j, dwRunCount = c[i].runCount;
 				for (j = 0; j < dwRunCount; j++)
				{
				    // step 1: test if terminated
					if (!GetProcessVersion(c[i].processID[j]))
					{
						c[i].runCount--;
						c[i].hProcess[j] = NULL;
						c[i].processID[j] = 0;
  						c[i].mainThreadID[j] = 0;
	  					c[i].state = UM_CLIENT_NOT_RUNNING;
                        c[i].user.fRestartOnDefaultDesk = FALSE;
                        fAnyChanges = TRUE;
						continue;   // its not running anymore
					}

	  			    // step 2: test if responding (only processes started by utilman - mainThreadID != 0)
					if (c[i].mainThreadID[j] != 0)
					{
						if (!PostThreadMessage(c[i].mainThreadID[j],WM_QUERYENDSESSION,0,ENDSESSION_LOGOFF))
						{
							c[i].state = UM_CLIENT_NOT_RESPONDING;
                            fAnyChanges = TRUE;
							continue;   // its not responding
						}
					}

					if (c[i].state != UM_CLIENT_RUNNING)
					{
						fAnyChanges = TRUE;
					}
					c[i].state = UM_CLIENT_RUNNING;
				}

				if (dwRunCount != c[i].runCount)
				{
  					for (j = 0; j < (dwRunCount-1); j++)
					{
						if (!c[i].processID[j])
						{
							memcpy(&c[i].processID[j], &c[i].processID[j+1],sizeof(DWORD)*(dwRunCount-j-1));
							memcpy(&c[i].hProcess[j], &c[i].hProcess[j+1],sizeof(HANDLE)*(dwRunCount-j-1));
							memcpy(&c[i].mainThreadID[j], &c[i].mainThreadID[j+1],sizeof(DWORD)*(dwRunCount-j-1));
						}
					}
				}
				break;
			}
  			case APPLICATION_TYPE_SERVICE:
			{
				SERVICE_STATUS  ssStatus;
				if (!TestServiceClientRuns(&c[i],&ssStatus))
				{
 					c[i].runCount--;
	  				c[i].processID[0] = 0;
 		  			c[i].mainThreadID[0] = 0;
  					c[i].state = UM_CLIENT_NOT_RUNNING;
                    fAnyChanges = TRUE;
				}
	  			break;
			}
		}
	}

    return fAnyChanges;
}

__inline DWORD GetCurrentSession()
{
    static DWORD dwSessionId = -1;
    if (-1 == dwSessionId)
    {
        ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId);
    }
    return dwSessionId;
}

// GetUserAccessToken - return the logged on user's access token
//
// If fNeedImpersonationToken is true the token will be an
// impersonation token otherwise it will be a primary token.
// The returned token will be 0 if security calls fail.
//
// Notes:  Caller must call CloseHandle on the returned handle.
//

HANDLE GetUserAccessToken(BOOL fNeedImpersonationToken, BOOL *fError)
{
    HANDLE hUserToken = 0;
    HANDLE hImpersonationToken = 0;
    *fError = FALSE;

    if (!GetWinStationUserToken(GetCurrentSession(), &hImpersonationToken))
    {
		// Call private API in the case where terminal services aren't running
        
        HANDLE hPrimaryToken = 0;
        DWORD dwFlags = TOKEN_QUERY | TOKEN_DUPLICATE;
        
        dwFlags |= (fNeedImpersonationToken)? TOKEN_IMPERSONATE : TOKEN_ASSIGN_PRIMARY;
        
        hPrimaryToken = GetCurrentUserTokenW (L"WinSta0", dwFlags);
        
        // GetCurrentUserTokenW returns a primary token; turn
        // it into an impersonation token if needed
        
        if (hPrimaryToken && fNeedImpersonationToken)
        {
            if (!DuplicateToken(hPrimaryToken, SecurityImpersonation, &hUserToken))
            {
                *fError = TRUE;
                DBPRINTF(TEXT("GetUserAccessToken:  DuplicateToken returned %d\r\n"), GetLastError());
            }
            
            CloseHandle(hPrimaryToken);
            
        } else
        {
            // otherwise, give out the primary token even if NULL
            hUserToken = hPrimaryToken;
        }
    }
    else
    {
        // Terminal services are running see if we need primary token

        if (hImpersonationToken && !fNeedImpersonationToken)
        {
            if (!DuplicateTokenEx(hImpersonationToken, 0, NULL
                            , SecurityImpersonation, TokenPrimary, &hUserToken))
            {
                *fError = TRUE;
                DBPRINTF(TEXT("GetUserAccessToken:  DuplicateTokenEx returned %d\r\n"), GetLastError());
            }

            CloseHandle(hImpersonationToken);

        } else
        {
            // otherwise, give out the impersonation token even if NULL
            hUserToken = hImpersonationToken;
        }
    }

    return hUserToken;
}

// StartAppAsUser - start the app in the context of the logged on user
//
BOOL StartAppAsUser( LPCTSTR appPath, LPTSTR cmdLine,
					LPSTARTUPINFO lpStartupInfo,
					LPPROCESS_INFORMATION lpProcessInformation)
{
    HANDLE hNewToken = 0;
	BOOL fStarted = FALSE;
    BOOL fError;
	
    // Get the our process's primary token (only succeeds if we are SYSTEM)
    hNewToken = GetUserAccessToken(FALSE, &fError);
	if (hNewToken)
	{
		// running in system context so impersonate the logged on user

		fStarted = CreateProcessAsUser( hNewToken, appPath,
				                 cmdLine, 0, 0, FALSE,
								 NORMAL_PRIORITY_CLASS , 0, 0,
								 lpStartupInfo, lpProcessInformation );

		CloseHandle( hNewToken );
        DBPRINTF(TEXT("StartAppAsUser:  CreateProcessAsUser(%s, %s) returns %d\r\n"), appPath, cmdLine, fStarted);
    } 
    else if (IsInteractiveUser())
    {
        // Running in interactive user's context, just do normal create.  Since
        // we are the interactive user default security descriptors will do.
		fStarted = CreateProcess(appPath, UTILMAN_STARTCLIENT_ARG
				, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE
				, NULL, NULL, lpStartupInfo, lpProcessInformation);
        DBPRINTF(TEXT("StartAppAsUser:  CreateProcess(%s, %s) returns %d\r\n"), appPath, UTILMAN_STARTCLIENT_ARG, fStarted);
    }

    // caller is going to close handles

	return fStarted;
}

// Functions to detect running copies of Accessibility utilities

// FindProcess - Searches the running processes by application name.  If found,
//               returns the process id.  Else returns zero.  If the process
//               id is returned then phProcess is the process handle.  The
//               caller must close the process handle.
//
// pszApplicationName [in]  - application as base.ext
// phProcess          [out] - pointer to memory to receive process handle
//
// returns the process Id.
//
DWORD FindProcess(LPCTSTR pszApplicationName, HANDLE *phProcess)
{
    DWORD dwProcId = 0;
	DWORD adwProcess[MAX_NUMBER_OF_PROCESSES];  // array to receive the process identifiers
	DWORD cProcesses;
    DWORD dwThisProcess = GetCurrentProcessId();
    unsigned int i;

    *phProcess = 0;

    // Get IDs of all running processes

	if (!EnumProcesses(adwProcess, sizeof(adwProcess), &cProcesses))
		return 0;

    // cProcesses is returned as bytes; convert to number of processes

    cProcesses = cProcesses/sizeof(DWORD);
	
    // open each process and test against pszApplicationName

	for (i = 0; i < cProcesses; i++)
	{
		HANDLE hProcess;
        //
        // EnumProcesses returns process IDs across all sessions but
        // we are only interested in processes in our session
        //
        if (!RunningInMySession(adwProcess[i]))
            continue;

        // Skip this process

        if (dwThisProcess == adwProcess[i])
            continue;

        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ
                                , FALSE, adwProcess[i]);

		if (hProcess != NULL)
		{
			HMODULE hMod;
	        TCHAR szProcessName[MAX_PATH];
	        DWORD ccbProcess;

            // find the module handle of exe of this process then it's base name (name.ext)

			if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &ccbProcess) )
			{
				DWORD ctch = GetModuleBaseName(hProcess, hMod, szProcessName, MAX_PATH);
				if (ctch && _wcsicmp(szProcessName, pszApplicationName) == 0)
				{
                    *phProcess = hProcess;    // found it
                    dwProcId = adwProcess[i];
                    break;
				}
			}	
			CloseHandle(hProcess);
		}
	}
    return dwProcId;
}

// GetApplicationProcessInfo - Tries to find the process running for this application
BOOL GetApplicationProcessInfo(umclient_tsp tspClient, BOOL fCloseHandle)
{
    DWORD dwProcId;
	HANDLE hProcess;
	TCHAR ApplicationPath[MAX_PATH];
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szPath[_MAX_PATH];
	TCHAR szName[_MAX_FNAME+_MAX_EXT];
	TCHAR szExt[_MAX_EXT];

	if (GetClientApplicationPath(tspClient->machine.ApplicationName, ApplicationPath, MAX_PATH))
    {
        // ApplicationPath may include path information but we need just the base name

	    _wsplitpath(ApplicationPath, szDrive, szPath, szName, szExt);
        lstrcat(szName, szExt);

        dwProcId = FindProcess(szName, &hProcess);
        if (dwProcId)
        {
		    tspClient->processID[0] = dwProcId;
				    
		    // I do not know how to get main thread ID
		    tspClient->mainThreadID[0] = 0;
		    tspClient->runCount = 1;
		    tspClient->state = UM_CLIENT_RUNNING;
        
		    // In order to keep the HANDLE usable, we may have to keep it open.
		    // So, we do not close it here, but I consider it relatively safe,
		    // since we cannot execute this code more than once without
		    // terminating the process first (and thus closing the handle)

		    if (fCloseHandle)
		    {
			    CloseHandle(hProcess);
			    tspClient->hProcess[0] = NULL;
            } else
            {
		        tspClient->hProcess[0] = hProcess;
            }
            return TRUE;    // the application is running
	    }
    }

	return FALSE;           // the application is not running
}

// YX 06-15-99 [
// Code to finid the window by its Process ID

static BOOL SentClose;

BOOL CALLBACK FindWindowByID(HWND hWnd, LPARAM lParam)
{
	DWORD procID;
	
	if  (GetWindowThreadProcessId(hWnd, &procID) != 0) 
	{
		if (procID == (DWORD)lParam)
		{
			// The process, We are looking for 
			// Send a message to close this window
			// CAUTION: A SendMessage is Synchronous, So It will freeze UM if the
			// message doenot return so PostMessage is safer or a SendMessageTimeout()
			// PostMessage is sufficient....
			PostMessage(hWnd, WM_CLOSE, 0, 0);
			SentClose = TRUE;
		}
	}
	return TRUE;  
}


BOOL CloseAllWindowsByProcessID(DWORD procID)
{
	BOOL rc = FALSE;
	SentClose = FALSE;

	rc = EnumWindows(FindWindowByID, (LPARAM)procID);

	return SentClose;
}

// IsAdmin - Returns TRUE if our process has admin priviliges else FALSE
//
BOOL IsAdmin()
{
    BOOL fStatus = FALSE;
	BOOL fIsAdmin = FALSE;
    PSID AdministratorsSid = AdminSid(TRUE);

    if (AdministratorsSid)
    {
        fStatus = CheckTokenMembership(NULL, AdministratorsSid, &fIsAdmin);
    }
    
    return (fStatus && fIsAdmin);
}

// IsInteractiveUser - Returns TRUE if our process has an Interactive User SID
//
BOOL IsInteractiveUser()
{
    BOOL fStatus = FALSE;
	BOOL fIsInteractiveUser = FALSE;
    PSID psidInteractive = InteractiveUserSid(TRUE);

    if (psidInteractive) 
	{
        fStatus = CheckTokenMembership(NULL, psidInteractive, &fIsInteractiveUser);
    }

    return (fStatus && fIsInteractiveUser);
}

// IsSystem - Returns TRUE if our process is running as SYSTEM
//
BOOL IsSystem()
{
    BOOL fStatus = FALSE;
	BOOL fIsLocalSystem = FALSE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem = SystemSid(TRUE);

    if (psidSystem) 
	{
        fStatus = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
    }

    return (fStatus && fIsLocalSystem);
}

BOOL StartApplication(
    LPTSTR  pszPath,        // IN  path + filename of application to start
    LPTSTR  pszArg,         // IN  command line argument(s)
    BOOL    fIsTrusted,     // IN  TRUE if app can run on secure desktop
    DWORD   *pdwProcessId,  // OUT if not NULL, returned process Id
    HANDLE  *phProcess,     // OUT if not NULL, returned process handle (caller must close)
    DWORD   *pdwThreadId    // OUT if not NULL, returned thread Id
    )
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	desktop_ts desktop;
	BOOL fStarted;

	memset(&si,0,sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	memset(&pi,0,sizeof(PROCESS_INFORMATION));

	QueryCurrentDesktop(&desktop, TRUE);

    DBPRINTF(TEXT("StartApplication:  pszPath=%s pszArg=%s fIsTrusted=%d Utilman is SYSTEM=%d\r\n"), pszPath, pszArg, fIsTrusted, IsSystem());

    // If not on the winlogon desktop, first try starting the app as the interactive
    // user.  If that fails (eg. the case when OOBE runs after setup when there is
    // no interactive user) then, if its the winlogon desktop or utilman is running 
    // SYSTEM and the app is trusted then use CreateProcess (the app will be running
    // as SYSTEM).  The latter case (running SYSTEM and the app is trusted allows
    // applets to run when OOBE is running.

	fStarted = FALSE;

	if (desktop.type != DESKTOP_WINLOGON)
    {
		si.lpDesktop = desktop.name;
		fStarted = StartAppAsUser(pszPath, pszArg, &si,&pi);
    }

    if (!fStarted && (desktop.type == DESKTOP_WINLOGON || (IsSystem() && fIsTrusted)))
    {
		if (fIsTrusted)
		{
		    si.lpDesktop = 0;
            // Since we only run trusted apps we can run with default security descriptor
			fStarted = CreateProcess(pszPath, pszArg, NULL, NULL, FALSE, 
                                     CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi);
            DBPRINTF(TEXT("StartApplication:  trusted CreateProcess(%s, %s) returns %d\r\n"), pszPath, pszArg, fStarted);
        }
    }

	if (fStarted)
	{
        if (pdwProcessId)
        {
            *pdwProcessId = pi.dwProcessId;
        }
        if (phProcess)
        {
            *phProcess = pi.hProcess;
        }
        else
        {
            CloseHandle(pi.hProcess);
        }
        if (pdwThreadId)
        {
            *pdwThreadId = pi.dwThreadId;
        }
        CloseHandle(pi.hThread);
	}

    return fStarted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\utilman.h ===
// ----------------------------------------------------------------------------
//
// UtilMan.h
//
// Header for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created oct-98 by JE
//          JE nov-15 98: added "ClientControlCode"
//			YX jun-01 99: added const for localized name subkey
// ----------------------------------------------------------------------------
#ifndef _UTILMAN_H_
#define _UTILMAN_H_

#include <stdlib.h>
// ------------------------------
#define UTILMAN_STARTCLIENT_ARG  _TEXT("/UM")
// ------------------------------
#define UTILMAN_DESKTOP_CHANGED_MESSAGE   _TEXT("UtilityManagerDesktopChanged")
// wParam:
 #define DESKTOP_ACCESSDENIED 0
 #define DESKTOP_DEFAULT      1
 #define DESKTOP_SCREENSAVER  2
 #define DESKTOP_WINLOGON     3
 #define DESKTOP_TESTDISPLAY  4
 #define DESKTOP_OTHER        5
// lParam: 0
// --------------------------------------------
// registry
#define UM_HKCU_REGISTRY_KEY _TEXT("Software\\Microsoft\\Utility Manager")
#define UM_REGISTRY_KEY _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Accessibility\\Utility Manager")
#define MAX_APPLICATION_NAME_LEN 300
// --------------------------------------------
#define UMR_VALUE_DISPLAY _TEXT("Display name") // YX: Reg key to store localized names
#define UMR_VALUE_PATH _TEXT("Application path")
#define MAX_APPLICATION_PATH_LEN _MAX_PATH
 // REG_SZ
#define UMR_VALUE_TYPE _TEXT("Application type")
#define APPLICATION_TYPE_APPLICATION 1
#define APPLICATION_TYPE_SERVICE     2
 // REG_DWORD
#define UMR_VALUE_EONL _TEXT("ErrorOnLaunch")
 //MAX_APPLICATION_PATH_LEN
 // REG_SZ
 // optional (default: NULL)
#define UMR_VALUE_WRA  _TEXT("WontRespondAction")
 //MAX_APPLICATION_PATH_LEN
 // REG_SZ
 // optional (default: NULL)
#define UMR_VALUE_WRTO _TEXT("WontRespondTimeout")
 #define NO_WONTRESPONDTIMEOUT  0
 #define MAX_WONTRESPONDTIMEOUT 600
 // REG_DWORD
#define UMR_VALUE_MRC  _TEXT("MaxRunCount")
 #define MAX_APP_RUNCOUNT  255
 #define MAX_SERV_RUNCOUNT 1
  // 1 to MAX_xxx_RUNCOUNT (1 BYTE)
  // REG_BINARY 
  // optional (default = 1)
//          JE nov-15 98
#define UMR_VALUE_CCC  _TEXT("ClientControlCode")
 // REG_DWORD
 // for valid values see "UMS_Ctrl.h"
// --------------------------------------------
#define UMR_VALUE_STARTUM  _TEXT("Start with Utility Manager")
#define UMR_VALUE_STARTLOCK _TEXT("Start on locked desktop")
#define UMR_VALUE_SHOWWARNING _TEXT("ShowWarning")
 // BOOL
 // REG_DWORD
// CONSIDER cleaning up the "Start with Windows" key
#define UMR_VALUE_ATATLOGON _TEXT("Start at Logon")
 // BOOL
 // REG_DWORD
#endif //_UTILMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\memfile.c ===
// ----------------------------------------------------------------------------
//
// MemFile.c
//
// Memory handling module
//
// Build: May-12-97
//
// Author: J. Eckhardt
// This code was written for ECO Kommunikation Insight
// Copyright (c) 1997-1999 Microsoft Corporation
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"

// -------------------------------------------------------------------
// task independent memory
// -------------------------------------------------------------------
HANDLE CreateIndependentMemory(LPTSTR name, DWORD size, BOOL inherit)
{
	LPSECURITY_ATTRIBUTES psa = NULL;
	obj_sec_attr_ts sa;
	HANDLE hFileMap;

	if (inherit)
	{
		psa = &sa.sa;
		InitSecurityAttributesEx(&sa, GENERIC_ALL, GENERIC_READ|GENERIC_WRITE);
	}

	hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, psa, PAGE_READWRITE, 0, size,name);

    DBPRINTF(TEXT("CreateIndependentMemory:  CreateFileMapping(%s) returns %d\r\n"), name, GetLastError());

	if (inherit)
		ClearSecurityAttributes(&sa);

	if (hFileMap == INVALID_HANDLE_VALUE)
	{
		return NULL;
	}
	return hFileMap;
}

// ---------------------------
LPVOID AccessIndependentMemory(LPTSTR name, DWORD size, DWORD dwDesiredAccess, PDWORD_PTR accessID)
{
	HANDLE hMap;
	LPVOID n;
	*accessID = 0;

	hMap = OpenFileMapping(dwDesiredAccess, FALSE, name);
	
	if (!hMap)
	{
		return NULL;
	}

	n = MapViewOfFile(hMap, dwDesiredAccess, 0, 0, size);
	
	if (!n)
	{
		CloseHandle(hMap);
		return NULL;
	}

	*accessID = (DWORD_PTR)hMap;
	return n;
}

// ---------------------------
void UnAccessIndependentMemory(LPVOID data, DWORD_PTR accessID)
{
	if (data)
		UnmapViewOfFile(data);

	if (accessID)
		CloseHandle((HANDLE)accessID);
}

// ---------------------------
void DeleteIndependentMemory(HANDLE id)
{
	if (id)
	  CloseHandle(id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\_umclnt.h ===
// ----------------------------------------------------------------------------
//
// _UMClnt.h
//
// Client definition for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created oct-98 by JE
//          JE nov-15-98: removed any code related to key hook
//          JE nov-15-98: changed UMDialog message to be a service control message
//          JE nov-15 98: changed "umc_machine_ts" to save memory
//          JE nov-15 98: changed "umc_machine_ts" to support launch specific client
//          JE nov-15 98: changed "umclient_ts" for multiple instances support
//			YX jun-01 99: added DisplayName member to the umc_machine_ts
//			YX jun-23 99: added IsAdmin function
// ----------------------------------------------------------------------------
#ifndef __UMCLNT_H_
#define __UMCLNT_H_
#include "UtilMan.h"
// ---------------------------------
// HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\Utility Manager\[Application Name]
// ---------------------------------
#define ACC_KEY_NONE -1
typedef struct
{
	WCHAR ApplicationName[MAX_APPLICATION_NAME_LEN];
	WCHAR DisplayName[MAX_APPLICATION_NAME_LEN]; // YX: added for localization purposes
	DWORD ApplicationType;//APPLICATION_TYPE_xxx
	DWORD WontRespondTimeout;//NO_WONTRESPONDTIMEOUT or up to MAX_WONTRESPONDTIMEOUT (sec)
	DWORD MaxRunCount;// instances (only a byte in registry)
	DWORD ClientControlCode;//JE nov-15 98
	WPARAM AcceleratorKey;	// micw - the accelerator key for this applet
} umc_machine_ts,*umc_machine_tsp;
// ---------------------------------
// HKCU\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\Utility Manager\[Application Name]
typedef struct
{
    BOOL fCanRunSecure;
	BOOL fStartWithUtilityManager;
	BOOL fStartAtLogon;
    BOOL fStartOnLockDesktop;
    BOOL fRestartOnDefaultDesk;
} umc_user_ts, *umc_user_tsp;
// ---------------------------------
// internal client struct (for each instance)
#define UM_CLIENT_NOT_RUNNING     0
#define UM_CLIENT_RUNNING         1
#define UM_CLIENT_NOT_RESPONDING  2
typedef struct
{
	umc_machine_ts machine;
	umc_user_ts    user;
	DWORD          runCount;// number of instance
	DWORD          state;
	DWORD          processID[MAX_APP_RUNCOUNT];
	HANDLE         hProcess[MAX_APP_RUNCOUNT];
	DWORD          mainThreadID[MAX_APP_RUNCOUNT];
	DWORD          lastResponseTime[MAX_APP_RUNCOUNT];
} umclient_ts, *umclient_tsp;
// ---------------------------------
// header structure
#define START_BY_OTHER  0x0
#define START_BY_HOTKEY 0x1
#define START_BY_MENU   0x2

typedef struct
{
	DWORD    numberOfClients;   // number of applets being managed
    DWORD    dwStartMode;       // one of START_BY_HOTKEY, START_BY_MENU, or START_BY_OTHER
    BOOL     fShowWarningAgain; // flag for showing warning dlg when started via Start menu
} umc_header_ts, *umc_header_tsp;
// ---------------------------------
// memory mapped files
#define UMC_HEADER_FILE _TEXT("UtilityManagerClientHeaderFile")
// sizeof(umc_header_ts)
#define UMC_CLIENT_FILE _TEXT("UtilityManagerClientDataFile")
// sizeof(umclient_ts) * (umc_header_tsp)->numberOfClients
// ---------------------------------
#ifdef __cplusplus
extern "C" {
#endif
	BOOL  StartClient(HWND hParent,umclient_tsp client);
	BOOL  StopClient(umclient_tsp client);
    BOOL  StartApplication(LPTSTR pszPath, LPTSTR pszArg, BOOL fIsTrusted, 
                           DWORD *pdwProcessId, HANDLE *phProcess, DWORD *pdwThreadId);
	BOOL  GetClientApplicationPath(LPTSTR ApplicationName, LPTSTR ApplicationPath,DWORD len);
	BOOL  GetClientErrorOnLaunch(LPTSTR ApplicationName, LPTSTR ErrorOnLaunch,DWORD len);
    BOOL  CheckStatus(umclient_tsp c, DWORD cClients);
	BOOL  IsAdmin();
    BOOL  IsInteractiveUser();
    BOOL  IsSystem();
    HANDLE GetUserAccessToken(BOOL fNeedImpersonationToken, BOOL *fError);
    BOOL  TestServiceClientRuns(umclient_tsp client,SERVICE_STATUS  *ssStatus);

    // Helpers to start up the utilman instance that displays UI

    extern HANDLE g_hUIProcess;

    __inline void OpenUManDialogOutOfProc()
    {
	    TCHAR szUtilmanPath[_MAX_PATH+64] = {0};
	    if (GetModuleFileName(NULL, szUtilmanPath, _MAX_PATH+64))
	    {
			// This function is called (when there is an interactive user) to bring up
            // the utilman UI in the user's security context.  This avoids the problem
            // where a non-trusted application could send a message to utilman and cause
            // some process to start as SYSTEM.  In this context, utilman is not considered
			// trusted; it must start as the interactive user or not at all.
		    StartApplication(szUtilmanPath, TEXT("/start"), FALSE, NULL, &g_hUIProcess, NULL);
	    }
    }
    __inline HANDLE GetUIUtilman()
    {
        return g_hUIProcess;
    }
    __inline BOOL ResetUIUtilman()
    {
        // This process detected the switch and should quit on its own
        if (g_hUIProcess)
        {
			CloseHandle(g_hUIProcess);
			g_hUIProcess = 0;
            return TRUE;
        }
        return FALSE;
    }

    __inline void SetUIUtilman(HANDLE hProcess)
    {
        ResetUIUtilman();
        g_hUIProcess = hProcess;
    }

#ifdef __cplusplus
}
#endif
#endif __UMCLNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\secdescr.c ===
// ----------------------------------------------------------------------------
//
// SecDescr.c
//
//
// Author: Jost Eckhardt
// 
// This code was written for ECO Kommunikation Insight
// Copyright (c) 1997-1999 Microsoft Corporation
// ----------------------------------------------------------------------------
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"

static PSECURITY_DESCRIPTOR GetObjectSecurityDescr(
						obj_sec_descr_tsp obj, 
					    DWORD dwAccessMaskOwner, 
						DWORD dwAccessMaskLoggedOnUser);
static BOOL GetUserSidFromToken(HANDLE hToken, PSID *ppSid);
static BOOL GetGroupSidFromToken(HANDLE hToken, PSID *ppSid);

// ---------------------------
// InitSecurityAttributes - initialize the security descriptor in the
//                          obj_sec_attr_tsp struct using a null DACL.
//
// Caller must call ClearSecurityAttributes when done with the struct.
//
void InitSecurityAttributes(obj_sec_attr_tsp  psa)
{
	memset(psa,0,sizeof(obj_sec_attr_ts));
	psa->sa.nLength = sizeof(SECURITY_ATTRIBUTES);

	psa->sa.bInheritHandle = TRUE;
	psa->sa.lpSecurityDescriptor = GetObjectSecurityDescr(&psa->objsd, 0, 0);
}

// ---------------------------
// InitSecurityAttributesEx - initialize the security descriptor in the
//                            obj_sec_attr_tsp struct using a non-null DACL
//
// dwAccessMaskOwner		- If non-zero specifies the access allowed to the creator
// dwAccessMaskLoggedOnUser	- If non-zero specifies the access allowed to the current user 
//
// If dwAccessMaskOwner and dwAccessMaskLoggedOnUser are zero the security descriptor
// will have a NULL DACL.  Caller must call ClearSecurityAttributes when done 
// with the struct.
//
void InitSecurityAttributesEx(obj_sec_attr_tsp  psa, DWORD dwAccessMaskOwner, DWORD dwAccessMaskLoggedOnUser)
{
	memset(psa,0,sizeof(obj_sec_attr_ts));
	psa->sa.nLength = sizeof(SECURITY_ATTRIBUTES);

	psa->sa.bInheritHandle = TRUE;
	psa->sa.lpSecurityDescriptor = GetObjectSecurityDescr(&psa->objsd, dwAccessMaskOwner, dwAccessMaskLoggedOnUser);
}

// ---------------------------
// ClearSecurityAttributes - free memory from the security descriptor
//
void ClearSecurityAttributes(obj_sec_attr_tsp  psa)
{
	if (psa->sa.lpSecurityDescriptor)
		free(psa->sa.lpSecurityDescriptor);

	if (psa->objsd.psidUser)
		free(psa->objsd.psidUser);

	if (psa->objsd.psidGroup)
		free(psa->objsd.psidGroup);

	memset(psa,0,sizeof(obj_sec_attr_ts));
}

// ---------------------------
static PSECURITY_DESCRIPTOR GetObjectSecurityDescr(
								obj_sec_descr_tsp obj, 
								DWORD dwAccessMaskOwner, 
								DWORD dwAccessMaskLoggedOnUser)
{
	PSECURITY_DESCRIPTOR psd = NULL;
	HANDLE hToken;
	GENERIC_MAPPING gm =  {1, 2, 4, 8};
	DWORD dwDesired = 1;
	BOOL fAccess = FALSE;
	DWORD dwGranted;
	PRIVILEGE_SET ps;
	DWORD cbPriv = sizeof (ps);
    PACL  pAcl;
    ULONG cbAcl;
	PSID  psidCurUser;

    obj->psidUser = obj->psidGroup = NULL;
    
    // Get the user's SID
	
	if (!ImpersonateSelf(SecurityImpersonation))
		return NULL;
	
	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
		goto GSSD_ERROR;
	
	if (!GetUserSidFromToken(hToken, &obj->psidUser))
		goto GSSD_ERROR;
	
	// assumption:  if either access masks are given
	// then the owner access mask must be given

	if (dwAccessMaskLoggedOnUser && !dwAccessMaskOwner)
		goto GSSD_ERROR;

    // Figure the size of an access-allowed ACL (if an
    // access mask is supplied there will be one ACE)

    cbAcl = 0;
    if (dwAccessMaskOwner)
    {
        cbAcl = sizeof(ACL)
		      + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)
			  + GetLengthSid(obj->psidUser);
    }

	psidCurUser = 0;
    if (dwAccessMaskLoggedOnUser)
    {
		psidCurUser = InteractiveUserSid(TRUE);
		if (psidCurUser)
		{
			cbAcl += sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)
				  + GetLengthSid(psidCurUser);
		}
	}
	
    // Allocate space for the SD and the ACL
	
	psd = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + cbAcl);
	
	if (!psd)
		goto GSSD_ERROR;
	
    // Add ACEs to the ACL if specified
	
	pAcl = NULL;
    if (dwAccessMaskOwner)
    {
        // Point to the ACL in the security descriptor
		
		pAcl = (ACL *)((BYTE *)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);
		
		if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
			goto GSSD_ERROR;
		
        // Set access allowed for creator
		
		if (!AddAccessAllowedAce(pAcl, 
								 ACL_REVISION, 
								 dwAccessMaskOwner,
								 obj->psidUser)) 
			goto GSSD_ERROR;
		
        // Set access allowed for everyone else
		
		if (psidCurUser)
		{
			if (!AddAccessAllowedAce(pAcl, 
									 ACL_REVISION, 
									 dwAccessMaskLoggedOnUser,
									 psidCurUser)) 
				goto GSSD_ERROR;
		}
    }
	
    // Initialize the security descriptor etc...
	
	if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
		goto GSSD_ERROR;
    if (!SetSecurityDescriptorDacl(psd, TRUE, (dwAccessMaskOwner)?pAcl:NULL, FALSE))
		goto GSSD_ERROR;
    if (!SetSecurityDescriptorOwner(psd, obj->psidUser, FALSE))
		goto GSSD_ERROR;
	if (!GetGroupSidFromToken(hToken, &obj->psidGroup))
		goto GSSD_ERROR;
	if (!SetSecurityDescriptorGroup(psd, obj->psidGroup, FALSE))
		goto GSSD_ERROR;
	if (!AccessCheck(psd, hToken, dwDesired, &gm, &ps, &cbPriv,&dwGranted, &fAccess))
		goto GSSD_ERROR;
	
	RevertToSelf();
	
	return psd;
	
GSSD_ERROR:
	
	if (psd)
		free(psd);
	if (obj->psidUser)
		free(obj->psidUser);
	if (obj->psidGroup)
		free(obj->psidGroup);
	
	RevertToSelf();
	return NULL;
}

// ----------------------------------------
static BOOL GetGroupSidFromToken(HANDLE hToken, PSID *ppSid)
{
	TOKEN_PRIMARY_GROUP *pGroup = NULL;
	PSID psidGroup = NULL;
	DWORD cbSid;
	DWORD cbRequired;

	if (GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &cbRequired))
		return FALSE;

	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return FALSE;

	pGroup = malloc(cbRequired);

	if (!pGroup)
		return FALSE;

	if (!GetTokenInformation(hToken, TokenPrimaryGroup, pGroup,cbRequired, &cbRequired))
		goto GGSFT_ERROR;

	cbSid = GetLengthSid(pGroup->PrimaryGroup);
	psidGroup = malloc(cbSid);

	if (!psidGroup)
		goto GGSFT_ERROR;

	if (!CopySid(cbSid, psidGroup, pGroup->PrimaryGroup))
		goto GGSFT_ERROR;

	*ppSid = psidGroup;
	psidGroup = NULL;

	return TRUE;

GGSFT_ERROR:
	
	if (psidGroup)
		free(psidGroup);

	free(pGroup);

	return FALSE;
}

// ----------------------------------------
static BOOL GetUserSidFromToken(HANDLE hToken, PSID *ppSid)
{
	TOKEN_USER *pUser = NULL;
	PSID psidUser = NULL;
	DWORD cbSid;
	DWORD cbRequired;

	if (GetTokenInformation(hToken, TokenUser, NULL, 0, &cbRequired))
		return FALSE;

	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER )
		return FALSE;

	pUser = malloc(cbRequired);

	if (!pUser)
		return FALSE;

	if (!GetTokenInformation(hToken, TokenUser, pUser, cbRequired,&cbRequired))
		goto GUSFT_ERROR;

	cbSid = GetLengthSid(pUser->User.Sid);
	psidUser = malloc(cbSid);

	if (!psidUser)
		goto GUSFT_ERROR;
	if (!CopySid(cbSid, psidUser, pUser->User.Sid))
		goto GUSFT_ERROR;
	
	*ppSid = psidUser;
	psidUser = NULL;
	return TRUE;

GUSFT_ERROR:
	if (psidUser)
		free(psidUser);

	free(pUser);
	return FALSE;
}

PSID EveryoneSid(BOOL fFetch)
{
    static PSID psidEverybody = 0;
    SID_IDENTIFIER_AUTHORITY siaEverybody = SECURITY_WORLD_SID_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidEverybody)
		{
			FreeSid(psidEverybody);
			psidEverybody = 0;
		}
		return 0;
	}

	if (!psidEverybody)
	{
		if (!AllocateAndInitializeSid(
						&siaEverybody, 
						1,
						SECURITY_WORLD_RID,
						0, 0, 0, 0, 0, 0, 0,
						&psidEverybody
						))
		{			
			psidEverybody = 0;
		}
	}

    return psidEverybody;
}

PSID AdminSid(BOOL fFetch)
{
    static PSID psidAdmin = 0;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidAdmin)
		{
			FreeSid(psidAdmin);
			psidAdmin = 0;
		}
		return 0;
	}

	if (!psidAdmin)
	{
		if (!AllocateAndInitializeSid(&siaNtAuthority,
                                       2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0, 0, 0, 0, 0, 0,
                                       &psidAdmin))
		{			
			psidAdmin = 0;
		}
	}

    return psidAdmin;
}

PSID InteractiveUserSid(BOOL fFetch)
{
    static PSID psidInteractiveUser = 0;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidInteractiveUser)
		{
			FreeSid(psidInteractiveUser);
			psidInteractiveUser = 0;
		}
		return 0;
	}

	if (!psidInteractiveUser)
	{
		if (!AllocateAndInitializeSid(&siaLocalSystem, 
									1,
									SECURITY_INTERACTIVE_RID,
									0, 0, 0, 0, 0, 0, 0,
									&psidInteractiveUser))
		{			
			psidInteractiveUser = 0;
		}
	}

    return psidInteractiveUser;
}

PSID SystemSid(BOOL fFetch)
{
    static PSID psidSystem = 0;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
	BOOL fRv = FALSE;

	if (!fFetch)
	{
		if (psidSystem)
		{
			FreeSid(psidSystem);
			psidSystem = 0;
		}
		return 0;
	}

	if (!psidSystem)
	{
		if (!AllocateAndInitializeSid(&siaLocalSystem, 
									1,
									SECURITY_LOCAL_SYSTEM_RID,
									0, 0, 0, 0, 0, 0, 0,
									&psidSystem))
		{			
			psidSystem = 0;
		}
	}

    return psidSystem;
}

void InitWellknownSids()
{
	EveryoneSid(TRUE);
	AdminSid(TRUE);
    InteractiveUserSid(TRUE);
	SystemSid(TRUE);
}

void UninitWellknownSids()
{
	EveryoneSid(FALSE);
	AdminSid(FALSE);
    InteractiveUserSid(FALSE);
	SystemSid(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\ums_ctrl.h ===
// -------------------------------------------------------
// UMS_Ctrl.h
// definition of the UtilityManager service control codes
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created nov-15-98 by JE
// -------------------------------------------------------
#ifndef _UMS_CTRL_H_
#define _UMS_CTRL_H_
// --------------------
#define UTILMAN_SERVICE_NAME            _TEXT("UtilMan")
#define UTILMAN_START_BYHOTKEY          _TEXT("/Hotkey") 
// show the UtilityManager dialog code
 #define UM_SERVICE_CONTROL_SHOWDIALOG   128
// internal to UM:
 // UtilityManager dialog has closed code
 #define UM_SERVICE_CONTROL_DIALOGCLOSED 129
 // UtilityManager internal reserved
 #define UM_SERVICE_CONTROL_RESERVED     130
// reserved for Microsoft
 #define UM_SERVICE_CONTROL_MIN_RESERVED 131
 #define UM_SERVICE_CONTROL_MAX_RESERVED 141
// codes to launch a specific client
 #define UM_SERVICE_CONTROL_FIRSTCLIENT  142
 #define UM_SERVICE_CONTROL_LASTCLIENT   255

#endif _UMS_CTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\_umdlg.h ===
// ----------------------------------------------------------------------------
//
// _UMDlg.h
//
// Internal header for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
// ----------------------------------------------------------------------------
#ifndef __UMDLG_H_
#define __UMDLG_H_
// ----------------------------------------
#define UMANDLG_DLL _TEXT("UManDlg.dll")
#define UMANDLG_VERSION                2
// ----------------------------------------
#define UMANDLG_FCT "UManDlg"
typedef BOOL (*umandlg_f)(BOOL fShow, BOOL fWaitForDlgClose, DWORD dwVersion);
#endif __UMDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\_umrun.h ===
// ----------------------------------------------------------------------------
//
// _UMRun.h
//
// Run and watch Utility Manager clients
//
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//
// History: created oct-98 by JE
//          JE nov-15-98: changed UMDialog message to be a service control message
//          JE nov-15 98: changed to support launch specific client
// ----------------------------------------------------------------------------
#ifndef __UMANRUN_H_
#define __UMANRUN_H_

#define UTILMAN_MODULE      TEXT("UtilMan.exe")

// -----------------------
BOOL  InitUManRun(BOOL fFirstInstance, DWORD dwStartMode);
void  ExitUManRun(void);
BOOL IsDialogDisplayed();
// -----------------------
BOOL NotifyClientsBeforeDesktopChanged(DWORD dwType);
BOOL NotifyClientsOnDesktopChanged(DWORD type);
extern HANDLE g_evUtilManDeskswitch;
// -----------------------
VOID CALLBACK UMTimerProc(HWND hwnd,UINT uMsg,UINT_PTR idEvent,DWORD dwTime);
BOOL  OpenUManDialogInProc(BOOL fWaitForDlgClose);
UINT_PTR  UManRunSwitchDesktop(desktop_tsp desktop, UINT_PTR timerID);
// -----------------------
// UitlMan.c 
VOID TerminateUMService(VOID);

#endif __UMANRUN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\umabout.cpp ===
// UMAbout.cpp : implementation file
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "UManDlg.h"
#include "UMAbout.h"
#include "UtilMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HWND aboutWnd;
/////////////////////////////////////////////////////////////////////////////
// UMAbout dialog


UMAbout::UMAbout(CWnd* pParent /*=NULL*/)
	: CDialog(UMAbout::IDD, pParent)
{
	//{{AFX_DATA_INIT(UMAbout)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void UMAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(UMAbout)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(UMAbout, CDialog)
	//{{AFX_MSG_MAP(UMAbout)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// UMAbout message handlers

BOOL UMAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();
	aboutWnd = m_hWnd;	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void UMAbout::OnClose() 
{
	CDialog::OnClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\umandlg.h ===
// UMDlg.h : main header file for the UMDLG DLL
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//

#if !defined(AFX_UMDLG_H__6845733C_40A1_11D2_B602_0060977C295E__INCLUDED_)
#define AFX_UMDLG_H__6845733C_40A1_11D2_B602_0060977C295E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CUMDlgApp
// See UMDlg.cpp for the implementation of this class
//

class CUMDlgApp : public CWinApp
{
public:
	CUMDlgApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUMDlgApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CUMDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UMDLG_H__6845733C_40A1_11D2_B602_0060977C295E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UManDlg.rc
//
#define IDS_ABOUT_STRING                1
#define IDS_NAME                        2
#define IDS_STATUS                      3
#define IDS_NOT_RUNNING                 4
#define IDS_RUNNING                     5
#define IDS_NOT_RESPONDING              6
#define IDS_OPTIONS                     7
#define IDS_ERRSTART                    9
#define IDS_UM                          10
#define IDS_ERRSTOP                     11
#define IDS_SECUREMODE                  13
#define IDD_UMAN                        101
#define IDI_UM                          102
#define IDD_ABOUT                       103
#define IDI_CLIENT1                     103
#define IDI_CLIENT2                     104
#define IDI_CLIENT3                     105
#define IDI_CLIENT4                     106
#define IDI_CLIENT5                     107
#define IDI_CLIENT6                     108
#define IDI_CLIENT7                     109
#define IDI_CLIENT8                     110
#define IDI_CLIENT9                     111
#define IDD_WARNING                     131
#define IDC_NAME_STATUS                 1000
#define IDC_START                       1001
#define IDC_STOP                        1002
#define IDC_START_AT_LOGON              1003
#define IDC_START_WITH_UM               1004
#define IDC_VERSION                     1007
#define IDC_OPTIONS                     1008
#define IDC_START_ON_LOCK               1009
#define IDC_CHK_WARN                    1010
#define IDS_DISPLAY_NAME_NARRATOR       502
#define IDS_DISPLAY_NAME_MAGNIFIER      503
#define IDS_DISPLAY_NAME_OSK			504

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\umandlg.cpp ===
// UMDlg.cpp : Defines the initialization routines for the DLL.
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "UManDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CUMDlgApp

BEGIN_MESSAGE_MAP(CUMDlgApp, CWinApp)
	//{{AFX_MSG_MAP(CUMDlgApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	ON_COMMAND( ID_HELP, OnHelp ) 

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUMDlgApp construction

CUMDlgApp::CUMDlgApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CUMDlgApp object

CUMDlgApp theApp;

/*BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID pvReserved)
{
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\_umtool.h ===
// ----------------------------------------------------------------------------
//
// _UMTool.h
//
// Header for Insight.lib
//
// Author: J. Eckhardt, ECO Kommunikation
//
// This code was written for ECO Kommunikation Insight
// (c) 1997-99 ECO Kommunikation
// ----------------------------------------------------------------------------
#ifndef __UMTOOL_H_
#define __UMTOOL_H_
// --------------------------------------------
// type definitions
typedef struct
{
	HANDLE  orgStation;
	HANDLE  userStation;
} desktop_access_ts, *desktop_access_tsp;
// ------------------------------
#define NAME_LEN 300
 #define USER_GUEST       0
 #define USER_USER        1
 #define USER_SUPERVISOR  2
 #define USER_DISTRIBUTOR 3
 #define USER_VENDOR      4
// YX 06-11-99 moved from utilman.c
#define STOP_UTILMAN_SERVICE_EVENT      _TEXT("StopUtilityManagerEvent")
typedef struct
{
	TCHAR userName[NAME_LEN];
	TCHAR name[NAME_LEN];
	DWORD type;
	DWORD user;
} desktop_ts, *desktop_tsp;
 #ifdef __cplusplus
  extern "C" {
 #endif
// --------------------------------------------
// macros
#include "w95trace.h"

// --------------------------------------------
// desktop prototypes
BOOL  InitDesktopAccess(desktop_access_tsp dAccess);
VOID  ExitDesktopAccess(desktop_access_tsp dAccess);
BOOL	QueryCurrentDesktop(desktop_tsp desktop,BOOL onlyType);
BOOL  SwitchToCurrentDesktop(void);
VOID	WaitDesktopChanged(desktop_tsp desktop);
// --------------------------------------------
// event prototypes
HANDLE BuildEvent(LPTSTR name,BOOL manualRest,BOOL initialState,BOOL inherit);
// --------------------------------------------
// memory mapped files
HANDLE CreateIndependentMemory(LPTSTR name, DWORD size, BOOL inherit);
LPVOID AccessIndependentMemory(LPTSTR name, DWORD size, DWORD dwDesiredAccess, PDWORD_PTR accessID);
void UnAccessIndependentMemory(LPVOID data, DWORD_PTR accessID);
void DeleteIndependentMemory(HANDLE id);
// --------------------------------------------
// security descriptor
typedef struct
{
	PSID psidUser;
	PSID psidGroup;
} obj_sec_descr_ts,*obj_sec_descr_tsp;
typedef struct
{
	obj_sec_descr_ts objsd;
	SECURITY_ATTRIBUTES sa;
} obj_sec_attr_ts, *obj_sec_attr_tsp;
void InitSecurityAttributes(obj_sec_attr_tsp psa);
void InitSecurityAttributesEx(obj_sec_attr_tsp psa, DWORD dwAccessMaskOwner, DWORD dwAccessMaskWorld);
void ClearSecurityAttributes(obj_sec_attr_tsp psa);
PSID EveryoneSid(BOOL fFetch);
PSID AdminSid(BOOL fFetch);
PSID InteractiveUserSid(BOOL fFetch);
PSID SystemSid(BOOL fFetch);
void InitWellknownSids();
void UninitWellknownSids();
 #ifdef __cplusplus
  }
 #endif
#endif //__UMTOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\umabout.h ===
#if !defined(AFX_UMABOUT_H__6845734C_40A1_11D2_B602_0060977C295E__INCLUDED_)
#define AFX_UMABOUT_H__6845734C_40A1_11D2_B602_0060977C295E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// UMAbout.h : header file
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//

/////////////////////////////////////////////////////////////////////////////
// UMAbout dialog

class UMAbout : public CDialog
{
// Construction
public:
	UMAbout(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(UMAbout)
	enum { IDD = IDD_ABOUT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(UMAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(UMAbout)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UMABOUT_H__6845734C_40A1_11D2_B602_0060977C295E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\version.h ===
// NARRATOR.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "UManDlg DLL"
#define VER_INTERNALNAME_STR        "UManDlg"
#define VER_ORIGINALFILENAME_STR    "UManDlg.dll"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\umdialog.cpp ===
// UMDialog.cpp : implementation file
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//
// History:
//		Changes 
//      Yuri Khramov
//      01-jun-99: DisplayName key used in the Dialog (Localization)
//		11-jun-99: DlgHasClosed code changed to work with app closure
//		15-jun-99: Timer delay increased 1000ms
//
//		Bug fixes and Changes Anil Kumar 1999
//---------------------------------------------------------------------
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include "UManDlg.h"
#include "UMDialog.h"
#include "UMAbout.h"
#include "_UMDlg.h"
#include "_UMClnt.h"
#include "_UMTool.h"
#include "UMS_Ctrl.h"
#include "w95trace.h"
#include <WinSvc.h>
#include <htmlhelp.h>
#include <initguid.h>
#include <ole2.h>
#include "deskswitch.c"
#include "ManageShellLinks.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// --------------------------------------------
// constants
#define IDC_ABOUT 10
#define UPDATE_CLIENT_LIST_TIMER 1
// --------------------------------------------
// variables
static DWORD g_cClients = 0;
static umclient_tsp g_rgClients = NULL;
static DWORD s_dwStartMode = START_BY_OTHER;
static BOOL s_fShowWarningAgain = TRUE;
extern CUMDlgApp theApp;
// --------------------------------------------
// C prototypes
static BOOL InitClientData(void);
static BOOL StartClientsOnShow();
static BOOL WriteClientData(BOOL fRunningSecure);
static BOOL IsStartAuto();
static BOOL CantStopClient(umclient_tsp client);
static int GetClientNameFromAccelerator(WPARAM wVK);

extern "C" BOOL StartAppAsUser( LPCTSTR appPath,
					 LPTSTR cmdLine,
					 LPSTARTUPINFO lpStartupInfo,
					 LPPROCESS_INFORMATION lpProcessInformation);


// Help ID's for context sensitive help
DWORD g_rgHelpIds[] = {	
	IDC_NAME_STATUS, 3,
	IDC_START, 1001,
	IDC_STOP, 1002,
	IDC_START_AT_LOGON, 1003,	// TODO UE needs to update CS help
	IDC_START_WITH_UM, 1004,
    IDC_START_ON_LOCK, 1005,    // TODO UE needs to add to CS help
	IDOK, 1100,
	IDCANCEL, 1200,
	ID_HELP, 1300,
};

// ---------------------------------------------------------------
extern "C"{
//--------------------------------
HWND g_hWndDlg = NULL;
HWND aboutWnd = NULL;
static HANDLE s_hDlgThread = NULL;

static HDESK s_hdeskSave = 0;
static HDESK s_hdeskInput = 0;

// UnassignDesktop gets called after the thread has exited to
// close desktop handles opened in AssignDesktop.
inline void UnassignDesktop()
{
    if (s_hdeskInput)
	{
        CloseDesktop(s_hdeskInput); 
        s_hdeskInput = 0;
	}
}

BOOL AssignDesktop(DWORD dwThreadId)
{
    s_hdeskSave = GetThreadDesktop(dwThreadId);
    s_hdeskInput = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!s_hdeskInput)
    {
        s_hdeskInput = OpenDesktop(_TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
    }
    
    if (s_hdeskInput)
    {
        BOOL fSet = SetThreadDesktop(s_hdeskInput);
    }
    return (s_hdeskInput)?TRUE:FALSE;
}

//--------------------------------
DWORD UManDlgThread(LPVOID /* UNUSED */ in)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	UMDialog dlg;

    // assign thread to the input desktop (have to do
    // this here so it works on the winlogon desktop)

    if (AssignDesktop(GetCurrentThreadId()))
    {
        // initialize COM *after* assign to input desktop
        // because CoInitialize creates a hidden window on
        // the current desktop.

        CoInitialize(NULL);
        InitCommonControls();

        if (InitClientData())
        {
            Sleep(10);
            dlg.DoModal();
            if (g_rgClients)
            {
                VirtualFree(g_rgClients,0,MEM_RELEASE);
                g_rgClients = NULL;
            }
            g_cClients = 0;
            g_hWndDlg = NULL;	
            s_hDlgThread = NULL;
        }

        CoUninitialize();   // uninitialize COM
    }

	return 1;
}

void StopDialog()
{
    if (aboutWnd)
    {
        EndDialog(aboutWnd,0);
        aboutWnd = NULL;
        Sleep(10);
    }
    if (g_hWndDlg)
    {
        ::PostMessage(g_hWndDlg, WM_CLOSE, 0, 0);
        g_hWndDlg = NULL;
        Sleep(10);
        UnassignDesktop();
    }
    if (g_rgClients)
    {
        VirtualFree(g_rgClients,0,MEM_RELEASE);
        g_rgClients = NULL;
    }
    g_cClients = 0;
}

//--------------------------------
#if defined(_X86_)
__declspec (dllexport)
#endif
// UManDlg - Opens or closes the utilman dialog.
//
// fShowDlg         - TRUE if dialog should be shown, FALSE if dialog should be closed
// fWaitForDlgClose - TRUE if the function should not return until the dialog
//                    is closed or a desktop switch happens else FALSE.
// dwVersion        - The utilman version
//
// returns TRUE if the dialog was opened or closed
// returns FALSE if the dialog could not be opened or it wasn't open
//
BOOL UManDlg(BOOL fShowDlg, BOOL fWaitForDlgClose, DWORD dwVersion)
{
	BOOL fRv = FALSE;
	if (dwVersion != UMANDLG_VERSION)
		return FALSE;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (fShowDlg)
	{
		if (!s_hDlgThread)
		{
			s_hDlgThread = CreateThread(NULL, 0, UManDlgThread, NULL, 0, NULL);
		} 
		else
		{
			SetForegroundWindow((aboutWnd)?aboutWnd:g_hWndDlg);
		}

		if (s_hDlgThread && fWaitForDlgClose)
        {
            // This code is executed on the default desktop for the following cases:
            //
            // 1. Utilman #1 run from the start menu
            // 2. Utilman #2 run from the start menu (utilman #1 is SYSTEM)
            // 3. Utilman #2 run by utilman #1 in user's context
            //
            // Wait for either the dialog to close or a desktop switch then return.
            // This will end this instance of utilman.  If there is a utilman
            // running as SYSTEM it will bring up the dialog on the other desktop.

            HANDLE rghEvents[2];

            rghEvents[0] = s_hDlgThread;
	        rghEvents[1] = OpenEvent(SYNCHRONIZE, FALSE, __TEXT("WinSta0_DesktopSwitch"));

	        while (TRUE)
            {
                DWORD dwObj = MsgWaitForMultipleObjects(2, rghEvents, FALSE, INFINITE, QS_ALLINPUT );
        
                switch (dwObj)
                {
                    case WAIT_OBJECT_0 + 1:    // the desktop is changing; close the dialog
                        StopDialog();
                        // intentional fall thru to cleanup code

                    case WAIT_OBJECT_0:        // the thread exited; clean up and return
                        CloseHandle(s_hDlgThread);
                        s_hDlgThread = 0;
                        CloseHandle(rghEvents[1]);
                        return TRUE;
                        break;

                    default:                 // process messages
                        {
                            MSG msg;
		                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                        break;
                }
            } 
        }
	}
	else
	{
        // This code is executed when utilman is running on the secure desktop.  In
        // that case, utilman brings up the dialog as a thread from its process. 
        // When the desktop switch is detected utilman calls this function to close 
        // the dialog.  It will be restarted again on the new desktop. 

		fRv = (g_hWndDlg && s_hDlgThread);

        StopDialog();
	}
	return fRv;
}

BOOL IsDialogUp()
{
    return (g_hWndDlg && s_hDlgThread)?TRUE:FALSE;
}

}//extern "C"


/////////////////////////////////////////////////////////////////////////////
// CWarningDlg dialog


CWarningDlg::CWarningDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWarningDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWarningDlg)
	m_fDontWarnAgain = TRUE;
	//}}AFX_DATA_INIT
}


void CWarningDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWarningDlg)
	DDX_Check(pDX, IDC_CHK_WARN, m_fDontWarnAgain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWarningDlg, CDialog)
	//{{AFX_MSG_MAP(CWarningDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// UMDialog dialog
// --------------------------------------------
UMDialog::UMDialog(CWnd* pParent /*=NULL*/)
	: CDialog(UMDialog::IDD, pParent)
	, m_fRunningSecure(FALSE)
{
	m_szUMStr.LoadString(IDS_UM);

	//{{AFX_DATA_INIT(UMDialog)
	// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

UMDialog::~UMDialog()
{
	m_lbClientList.Detach();
}
// --------------------------------------------
void UMDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(UMDialog)
	// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}
// --------------------------------------------
BEGIN_MESSAGE_MAP(UMDialog, CDialog)
//{{AFX_MSG_MAP(UMDialog)
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_START, OnStart)
	ON_BN_CLICKED(IDC_STOP, OnStop)
	ON_WM_TIMER()
	ON_WM_HELPINFO()
	ON_COMMAND( ID_HELP, OnHelp )
	ON_LBN_SELCHANGE(IDC_NAME_STATUS, OnSelchangeNameStatus)
	ON_BN_CLICKED(IDC_START_AT_LOGON, OnStartAtLogon)
	ON_BN_CLICKED(IDC_START_WITH_UM, OnStartWithUm)
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_SYSCOMMAND,OnSysCommand)
	ON_BN_CLICKED(IDC_START_ON_LOCK, OnStartOnLock)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// UMDialog message handlers

BOOL UMDialog::PreTranslateMessage(MSG* pMsg) 
{
	// Override that allows use of function keys to launch applets when on
	// the logon desktop.  Only pay attention to key up to avoid dup calls.

	if (m_fRunningSecure && WM_KEYUP == pMsg->message) 
	{
		int iClient = GetClientNameFromAccelerator(pMsg->wParam);
		if (iClient >= 0)
		{
			m_lbClientList.SelectString(-1, g_rgClients[iClient].machine.DisplayName);
			OnStart();
			return TRUE;
		}
	}
	
	return CDialog::PreTranslateMessage(pMsg);
}

BOOL UMDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	// set the flag indicating if we are running in secure mode

	desktop_ts desktop;	
	QueryCurrentDesktop(&desktop, TRUE);
	m_fRunningSecure = RunSecure(desktop.type);

    if (s_fShowWarningAgain && s_dwStartMode == START_BY_MENU)
    {
        CWarningDlg dlgWarn;
        dlgWarn.m_fDontWarnAgain = !s_fShowWarningAgain;
        dlgWarn.DoModal();
        s_fShowWarningAgain = !dlgWarn.m_fDontWarnAgain;
    }

	g_hWndDlg = m_hWnd;	

	// change system menu

	CMenu *hSysMenu = GetSystemMenu(FALSE);
	if (hSysMenu)
	{
		CString str;
		hSysMenu->AppendMenu(MF_SEPARATOR);
		str.LoadString(IDS_ABOUT_STRING);
		hSysMenu->AppendMenu(MF_STRING,IDC_ABOUT,LPCTSTR(str));
	}

    // handle any "start when utility manager starts" applets

    StartClientsOnShow();

	// attach ListBox to member data and populate w/list of applications

	m_lbClientList.Attach(GetDlgItem(IDC_NAME_STATUS)->m_hWnd);
	ListClients();

	// Disable Help button if we are at WinLogon because the help 
	// dialog supports "Jump to URL..." exposing security risk.
	// The m_fRunningSecure variable is TRUE if UI shouldn't expose help.

	if (m_fRunningSecure)
	{
		EnableDlgItem(ID_HELP, FALSE, IDOK); 
	}

    // Disable "Start when UtilMan starts" unless user is an admin
    // and we are running in non-secure mode.

    if (s_dwStartMode != START_BY_MENU)
    {
        GetDlgItem(IDC_START_WITH_UM)->EnableWindow(IsAdmin() && !m_fRunningSecure);
    }

	// Bring dialog to top and center on desktop window

	RECT rectUmanDlg,rectDesktop;
	GetDesktopWindow()->GetWindowRect(&rectDesktop);
	GetWindowRect(&rectUmanDlg);

	long lDlgWidth = rectUmanDlg.right - rectUmanDlg.left;
	long lDlgHieght = rectUmanDlg.bottom - rectUmanDlg.top;
	if (!m_fRunningSecure)
	{
		rectUmanDlg.left = (rectDesktop.right - lDlgWidth)/2;
		rectUmanDlg.top = (rectDesktop.bottom - lDlgHieght)/2;
	} else
	{
		rectUmanDlg.left = rectDesktop.left + (long)(lDlgWidth/10);
		rectUmanDlg.top = rectDesktop.bottom - lDlgHieght - (long)(lDlgHieght/10);
	}

    // This looks a bit odd (SetForegroundWindow should also be activating 
    // the window) but if you don't call SetActiveWindow on the secure
    // desktop then the second, etc... WinKey+U will bring up UM hidden
    // behind the welcome "screen".

    SetActiveWindow();
    SetForegroundWindow();
	SetWindowPos(&wndTopMost,rectUmanDlg.left,rectUmanDlg.top,0,0,SWP_NOSIZE);
    
	if (!m_fRunningSecure)
    {
        // on default desktop the above SetWindowPos makes the dialog initially
        // on top and this call allows other apps to then be on top.
	    SetWindowPos(&wndNoTopMost,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);
    }

    // start checking every so often to see if we need to update our display

	SetTimer(UPDATE_CLIENT_LIST_TIMER, 3000, NULL);

	return TRUE;  // return TRUE unless you set the focus to a control
}

// -----------------------------------------------------
void UMDialog::OnSysCommand(UINT nID,LPARAM lParam)
{
	if (nID == IDC_ABOUT)
	{
		UMAbout dlg;
		dlg.DoModal();
		aboutWnd = NULL;	
	}
	else
	{
		CDialog::OnSysCommand(nID,lParam);
	}
}//UMDialog::OnSysCommand
// ------------------------------------

// --------------------------------------------
// CanStartOnLockedDesktop - returns TRUE if applets can 
// be configured to be auto-started on the secure desktop
//
inline BOOL CanStartOnLockedDesktop(int iWhichClient, BOOL fRunningSecure)
{
    // user can ask for auto start on secure desktop if they are logged on, the
    // applet is OK'd to run on the secure desktop and the machine isn't using
    // fast user switching (FUS) (w/FUS Ctrl+Alt+Del disconnects the user session
    // rather than switching desktops).

    BOOL fCanStartOnLockedDesktop = 
        (
            !fRunningSecure && 
            g_rgClients[iWhichClient].user.fCanRunSecure &&
            CanLockDesktopWithoutDisconnect()
        )?TRUE:FALSE;

    return fCanStartOnLockedDesktop;
}

// --------------------------------------------
// OnSelchangeNameStatus is called when the user navigates the list
// box items by clicking with the mouse or using up/down arrows.
//
void UMDialog::OnSelchangeNameStatus() 
{
	// Get the currently selected item and update the controls for
	// the currently selected item.

	int iSel;
	if (GetSelectedClient((int)g_cClients, iSel))
	{
		// Group box label
		CString str(g_rgClients[iSel].machine.DisplayName);
		CString optStr;
		optStr.Format(IDS_OPTIONS, str);
		GetDlgItem(IDC_OPTIONS)->SetWindowText(optStr);

        // only enable options when started via WinKey+U 

        if (s_dwStartMode != START_BY_MENU)
        {
            // Disable "start at logon" at secure desktop to avoid mischief

            if (!m_fRunningSecure)
            {
                GetDlgItem(IDC_START_AT_LOGON)->EnableWindow(TRUE);
            } else
            {
                // this may be set in an upgrade situation; clear it
                g_rgClients[iSel].user.fStartAtLogon = FALSE;
                GetDlgItem(IDC_START_AT_LOGON)->EnableWindow(FALSE);
            }

            // Enable "start on locked desktop" if at default desktop and
            // when applet can run on secure desktop

            if (CanStartOnLockedDesktop(iSel, m_fRunningSecure))
            {
                GetDlgItem(IDC_START_ON_LOCK)->EnableWindow(TRUE);
            } else
            {
                // this may be set in an upgrade situation; clear it
                g_rgClients[iSel].user.fStartOnLockDesktop = FALSE;
                GetDlgItem(IDC_START_ON_LOCK)->EnableWindow(FALSE);
            }
		    
		    // Start option checkboxes

		    CheckDlgButton(IDC_START_AT_LOGON, (g_rgClients[iSel].user.fStartAtLogon)?TRUE:FALSE);
            CheckDlgButton(IDC_START_ON_LOCK, (g_rgClients[iSel].user.fStartOnLockDesktop)?TRUE:FALSE);
		    CheckDlgButton(IDC_START_WITH_UM, (g_rgClients[iSel].user.fStartWithUtilityManager)?TRUE:FALSE);
        } else
        {
            GetDlgItem(IDC_START_AT_LOGON)->EnableWindow(FALSE);
            GetDlgItem(IDC_START_ON_LOCK)->EnableWindow(FALSE);
            GetDlgItem(IDC_START_WITH_UM)->EnableWindow(FALSE);
		    CheckDlgButton(IDC_START_AT_LOGON, FALSE);
            CheckDlgButton(IDC_START_ON_LOCK, FALSE);
		    CheckDlgButton(IDC_START_WITH_UM, FALSE);
        }

		// Start and stop buttons
		DWORD dwState = g_rgClients[iSel].state;

		if ((dwState == UM_CLIENT_RUNNING) 
			&& (g_rgClients[iSel].runCount >= g_rgClients[iSel].machine.MaxRunCount))
			EnableDlgItem(IDC_START, FALSE, IDC_NAME_STATUS);
		else
			EnableDlgItem(IDC_START, TRUE, IDC_NAME_STATUS);

		if ((dwState == UM_CLIENT_NOT_RUNNING) || CantStopClient(&g_rgClients[iSel]))
			EnableDlgItem(IDC_STOP, FALSE, IDC_NAME_STATUS);
		else
			EnableDlgItem(IDC_STOP, TRUE, IDC_NAME_STATUS);

	}// else ignore selections not in a valid range
}

// --------------------------------------------
void UMDialog::OnClose()
{
	// behave like cancel
	CDialog::OnClose();
}//UMDialog::OnClose

// --------------------------------------------
// OnStart is called when the Start button is clicked.  It starts
// the client ap then lets the timer update saved state.
//
void UMDialog::OnStart()
{
    int iSel;
    if (GetSelectedClient((int)g_cClients, iSel))
    {
        if (StartClient(m_hWnd, &g_rgClients[iSel]))
        {
            KillTimer(UPDATE_CLIENT_LIST_TIMER);
            EnableDlgItem(IDC_STOP, TRUE, IDC_NAME_STATUS);
			ListClients();
            SetTimer(UPDATE_CLIENT_LIST_TIMER, 3000, NULL);
            
            if (g_rgClients[iSel].runCount+1 >= g_rgClients[iSel].machine.MaxRunCount)
                EnableDlgItem(IDC_START, FALSE, IDC_STOP);
        }
        else if (g_rgClients[iSel].runCount < g_rgClients[iSel].machine.MaxRunCount)
        {
            // Unable to start
            CString str;	
            str.LoadString((m_fRunningSecure)?IDS_SECUREMODE:IDS_ERRSTART);
            MessageBox(str, m_szUMStr, MB_OK);	
        }
    }
}

// --------------------------------------------
// OnStop is called when the Stop button is clicked.  It stops
// the client ap then lets the timer update saved state.
//
void UMDialog::OnStop()
{
	int iSel;
	if (GetSelectedClient((int)g_cClients, iSel))
	{
		if (StopClient(&g_rgClients[iSel]))
		{
            KillTimer(UPDATE_CLIENT_LIST_TIMER);
            GetDlgItem(IDC_START)->EnableWindow(TRUE);
			ListClients();
			EnableDlgItem(IDC_STOP, FALSE, IDOK);
            SetTimer(UPDATE_CLIENT_LIST_TIMER, 3000, NULL);
		}
		else
		{
			// Unable to stop
			CString str;
			str.LoadString(IDS_ERRSTOP);
			MessageBox(str, m_szUMStr, MB_OK);	
		}
	}
}

void UMDialog::SaveCurrentState()
{
	int iSel;
	if (GetSelectedClient((int)g_cClients, iSel))
	{
		g_rgClients[iSel].user.fStartAtLogon
			= (IsDlgButtonChecked(IDC_START_AT_LOGON))?TRUE:FALSE;
		g_rgClients[iSel].user.fStartWithUtilityManager
			= (IsDlgButtonChecked(IDC_START_WITH_UM))?TRUE:FALSE;
        g_rgClients[iSel].user.fStartOnLockDesktop
            = (IsDlgButtonChecked(IDC_START_ON_LOCK))?TRUE:FALSE;
	}
}

// --------------------------------------------
// OnOK is called when the user clicks the OK button to
// dismiss the UtilMan dialog.
//
void UMDialog::OnOK()
{
	SaveCurrentState();

	WriteClientData(m_fRunningSecure);

	CDialog::OnOK();
}//UMDialog::OnOK

// ----------------------------------------------------------------------------
// OnTimer is called to check the status of client apps that are displayed
// in the UI.  This keeps the UI consistent with the running client app's.
//
void UMDialog::OnTimer(UINT nIDEvent)
{
	if (nIDEvent == UPDATE_CLIENT_LIST_TIMER)
	{
		UINT uiElapsed = 3000; 
		KillTimer(UPDATE_CLIENT_LIST_TIMER);

        // get current status and pick up new apps
		if (CheckStatus(g_rgClients, g_cClients))
        {
		    ListClients();          // something has changed - update the UI
			uiElapsed = 500;
        }

		SetTimer(UPDATE_CLIENT_LIST_TIMER, uiElapsed, NULL);
	}
	CDialog::OnTimer(nIDEvent);
}

// --------------------------------------------
// OnHelpInfo provides context sensitive help.  It only does
// this if not on the WinLogon desktop.
//
BOOL UMDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (m_fRunningSecure)	
		return FALSE;

	if ( pHelpInfo->iCtrlId == IDC_OPTIONS )
		return TRUE;

	::WinHelp((HWND)pHelpInfo->hItemHandle, __TEXT("utilmgr.hlp"), HELP_WM_HELP,
				(DWORD_PTR) (LPSTR) g_rgHelpIds);

	return TRUE;
}

// --------------------------------------------
// OnHelpInfo provides context sensitive help when the user
// right-clicks the dialog.  It only does this if not on the 
// WinLogon desktop.
//
void UMDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	if (m_fRunningSecure)	
		return;

	::WinHelp(pWnd->m_hWnd, __TEXT("utilmgr.hlp"), HELP_CONTEXTMENU
		, (DWORD_PTR) (LPSTR) g_rgHelpIds);
}

// --------------------------------------------
// OnHelp provides standard help.  It only does this if not
// on the WinLogon desktop.
//
void UMDialog::OnHelp()
{
    if (m_fRunningSecure)	
        return;
    
    ::HtmlHelp(m_hWnd , TEXT("utilmgr.chm"), HH_DISPLAY_TOPIC, 0);
}

// ----------------------------------
void UMDialog::EnableDlgItem(DWORD dwEnableMe, BOOL fEnable, DWORD dwFocusHere)
{
	// when disabling a control that currently has focs switch it to dwFocusHere
	if (!fEnable && (GetFocus() == GetDlgItem(dwEnableMe)))
        GetDlgItem(dwFocusHere)->SetFocus();

    GetDlgItem(dwEnableMe)->EnableWindow(fEnable);
}

void UMDialog::SetStateStr(int iClient)
{
	switch (g_rgClients[iClient].state)
	{
		case UM_CLIENT_NOT_RUNNING:
		m_szStateStr.Format(IDS_NOT_RUNNING, g_rgClients[iClient].machine.DisplayName);
		break;

		case UM_CLIENT_RUNNING:
		m_szStateStr.Format(IDS_RUNNING, g_rgClients[iClient].machine.DisplayName);
		break;

		case UM_CLIENT_NOT_RESPONDING:
		m_szStateStr.Format(IDS_NOT_RESPONDING, g_rgClients[iClient].machine.DisplayName);
		break;

		default:
		m_szStateStr.Empty();
		break;
	}
}

// --------------------------------------------
void UMDialog::ListClients()
{
	// Re-do the client list box with latest state info

    int iCurSel = m_lbClientList.GetCurSel();
    if (iCurSel == LB_ERR)
        iCurSel = 0;

	m_lbClientList.ResetContent();
	
	for (DWORD i = 0; i < g_cClients; i++)
	{
		SetStateStr(i);

		if (!m_szStateStr.IsEmpty())
        {
            m_lbClientList.AddString(m_szStateStr);
        }
	}
	m_lbClientList.SetCurSel(iCurSel);

	// Refresh button states in case they've changed 
	// (this happens on desktop switch)

	OnSelchangeNameStatus();
}

// --------------------------------------------
// UpdateClientState updates the client list box with the current state
// of the application (running, not running, not responding)
//
void UMDialog::UpdateClientState(int iSel)
{
	SetStateStr(iSel);
	m_lbClientList.DeleteString(iSel);
	m_lbClientList.InsertString(iSel, m_szStateStr);
	m_lbClientList.SetCurSel(iSel);

}

// --------------------------------------------
// OnStartAtLogon updates the state of the client in memory when the
// Start with Windows checkbox is checked or unchecked.
//
void UMDialog::OnStartAtLogon() 
{
	SaveCurrentState();
}

// --------------------------------------------
// OnStartWithUm updates the state of the client in memory when the
// Start with Utility Manager checkbox is checked or unchecked.
//
void UMDialog::OnStartWithUm() 
{
	SaveCurrentState();
}

// --------------------------------------------
// OnStartOnLock updates the state of the client in memory when the
// Start when I lock my desktop checkbox is checked or unchecked.
//
void UMDialog::OnStartOnLock() 
{
	SaveCurrentState();
}

// --------------------------------------------
// OnShowWindow 
// This was added for a timing problem where utilman came up running in the system context on the users desktop
// this code here makes sure that that cannot happen by cheching right when the dialog is about to appear
//
void UMDialog::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    HDESK hdesk;
    SID *desktopSID = NULL;
    
	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
	// this is expected to fail for the winlogon desktop and thats ok
	if (hdesk)     
	{
        TCHAR desktopName[NAME_LEN];
        DWORD nl, SIDLen = 0;
        
    	if (!GetUserObjectInformation(hdesk, UOI_NAME, desktopName, NAME_LEN, &nl))
    	    goto StopDialog;

    	if (!GetUserObjectInformation(hdesk, UOI_USER_SID, desktopSID, 0, &SIDLen))
    	{
        	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        	    goto StopDialog;
    	}
    	
    	if (SIDLen > 0 && !lstrcmpi(desktopName, TEXT("Default")))
    	{
    	    desktopSID = (SID*)new BYTE[SIDLen];
    	    if (!desktopSID)
    	        goto StopDialog;
    	    
        	if (!GetUserObjectInformation(hdesk, UOI_USER_SID, desktopSID, SIDLen, &SIDLen))
        	    goto StopDialog;

        	BOOL fError;
            HANDLE hUserToken = GetUserAccessToken(TRUE, &fError);
            if (fError)
                goto StopDialog;
            
            // We get a token only if there is a logged on user.  
            // If there is not then we can come up as system with no worries.
            if (!hUserToken)
                goto LetDialogComeup;

            BOOL fStatus = FALSE;
        	BOOL fIsInteractiveUser = FALSE;
            PSID psidInteractive = InteractiveUserSid(TRUE);

            if (!psidInteractive)
                goto StopDialog;

            fStatus = CheckTokenMembership(hUserToken, psidInteractive, &fIsInteractiveUser);

            //If the logged on user is the interactive user and we are running as system then it is a
            // security risk to show UI.  This can happen when rappidly switching desktops.
            if ( fStatus && fIsInteractiveUser && IsSystem()) 
                goto StopDialog;
            
        }
    	
	}

    LetDialogComeup:
        if (desktopSID)
            delete [] desktopSID;
        return;
    
	StopDialog:
        StopDialog();
        if (desktopSID)
            delete [] desktopSID;

}


/////////////////////////////////////////////////////////////////////////////
// C code
//-----------------------------------------------------------------

__inline void ReplaceDisplayName(LPTSTR szName, int iRID)
{
	TCHAR szBuf[MAX_APPLICATION_NAME_LEN];
	if (LoadString(AfxGetInstanceHandle(), iRID, szBuf, MAX_APPLICATION_NAME_LEN))
		lstrcpy(szName, szBuf);
}

void SetLocalizedDisplayName()
{
	// Make localization easier; don't require them to localize registry entries.
    // Instead, replace our copy with the localized version.  This appears to be
    // duplicate code to that in umanrun.c however, that part of the code always
    // runs as system and therefore the DisplayName is set to the default system
    // language.  This part of the code (the UI) runs as the logged on user when
    // there is one so these resources will be the user's language.  The resources
    // and associated code should be removed from utilman.exe and this code and
    // resources (from umandlg.dll) should be used.

    for (DWORD i=0;i<g_cClients;i++)
    {
	    if ( lstrcmp( g_rgClients[i].machine.ApplicationName, TEXT("Magnifier") ) == 0 )
	    {
		    ReplaceDisplayName(g_rgClients[i].machine.DisplayName, IDS_DISPLAY_NAME_MAGNIFIER);
	    }
	    else if ( lstrcmp( g_rgClients[i].machine.ApplicationName, TEXT("Narrator") ) == 0 ) 
	    {
		    ReplaceDisplayName(g_rgClients[i].machine.DisplayName, IDS_DISPLAY_NAME_NARRATOR);
	    }
	    else if ( lstrcmp( g_rgClients[i].machine.ApplicationName, TEXT("On-Screen Keyboard") ) == 0 ) 
	    {
		    ReplaceDisplayName(g_rgClients[i].machine.DisplayName, IDS_DISPLAY_NAME_OSK);
	    }
    }
}

static BOOL InitClientData(void)
{
    BOOL fRv = TRUE;

    // On initial run allocate and initialize client array
    
    if (!g_rgClients || !g_cClients)
    {
        umc_header_tsp pHdr = 0;
        umclient_tsp c = 0;
        DWORD_PTR accessID,accessID2;
        
        g_cClients = 0;
        g_rgClients = NULL;
        
        fRv = FALSE;

        pHdr = (umc_header_tsp)AccessIndependentMemory(
									UMC_HEADER_FILE, 
									sizeof(umc_header_ts), 
									FILE_MAP_READ,
									&accessID);
        if (!pHdr)
        {
            goto Cleanup;
        }
        
        s_dwStartMode = pHdr->dwStartMode;              // capture the Utilman start mode
        s_fShowWarningAgain = pHdr->fShowWarningAgain;  // and warning dialog flag
        
        if (!pHdr->numberOfClients)
        {
            goto Cleanup;
        }
        c = (umclient_tsp)AccessIndependentMemory(
								UMC_CLIENT_FILE, 
								sizeof(umclient_ts)*pHdr->numberOfClients, 
								FILE_MAP_READ,
								&accessID2);
        if (!c)
        {
            goto Cleanup;
        }
        g_rgClients = (umclient_tsp)VirtualAlloc(NULL, sizeof(umclient_ts)*pHdr->numberOfClients, MEM_RESERVE,PAGE_READWRITE);
        if (!g_rgClients)
        {
            goto Cleanup;
        }
        if (!VirtualAlloc(g_rgClients, sizeof(umclient_ts)*pHdr->numberOfClients, MEM_COMMIT, PAGE_READWRITE))
        {
            goto Cleanup;
        }

        fRv = TRUE;
        
        g_cClients = pHdr->numberOfClients;
        memcpy(g_rgClients,c,sizeof(umclient_ts)*pHdr->numberOfClients);

        SetLocalizedDisplayName();
        
Cleanup:
        if (pHdr)
        {
            UnAccessIndependentMemory(pHdr, accessID);
        }
        if (c)
        {
            UnAccessIndependentMemory(c, accessID2);
        }
        
        if (!fRv && g_rgClients)
        {
            VirtualFree(g_rgClients, 0, MEM_RELEASE);
            g_rgClients = NULL;
            g_cClients = 0;
        }

    }

    // "Start when I log on" is per-user setting so get that
    // each time the dialog is brought up

    CManageShellLinks CManageLinks(STARTUP_FOLDER);
    for (DWORD i=0;i<g_cClients;i++)
    {
        g_rgClients[i].user.fStartAtLogon 
            = CManageLinks.LinkExists(g_rgClients[i].machine.ApplicationName);
    }

	return fRv;
}

// RegSetUMDwordValue - helper function to set a DWORD string value creating it if necessary
//
BOOL RegSetUMDwordValue(HKEY hKey, LPCTSTR pszKey, LPCTSTR pszString, DWORD dwNewValue)
{
    HKEY hSubkey;
    int iRv;
    DWORD dwValue = dwNewValue;

    iRv = RegCreateKeyEx(
                  hKey
                , pszKey
                , 0, NULL
                , REG_OPTION_NON_VOLATILE
                , KEY_ALL_ACCESS
                , NULL, &hSubkey, NULL);

	if (iRv == ERROR_SUCCESS)
    {
		RegSetValueEx(
                  hSubkey
                , pszString
                , 0, REG_DWORD
                , (BYTE *)&dwValue
                , sizeof(DWORD));

		RegCloseKey(hSubkey);
    }

    return (iRv == ERROR_SUCCESS)?TRUE:FALSE;
}

void WriteUserRegData(HKEY hKeyCU, BOOL fDoAppletData)
{
    HKEY hkey;
    DWORD dwRv = RegCreateKeyEx(hKeyCU
                            , UM_HKCU_REGISTRY_KEY
                            , 0 , NULL
                            , REG_OPTION_NON_VOLATILE
                            , KEY_ALL_ACCESS, NULL
                            , &hkey, NULL);

    if (dwRv == ERROR_SUCCESS)
    {
        dwRv = RegSetValueEx(
              hkey
            , UMR_VALUE_SHOWWARNING
            , 0, REG_DWORD
            , (BYTE *)&s_fShowWarningAgain
            , sizeof(DWORD));

        if (fDoAppletData)
        {
	        for (DWORD i = 0; i < g_cClients; i++)
	        {
                RegSetUMDwordValue(
                      hkey
                    , g_rgClients[i].machine.ApplicationName
                    , UMR_VALUE_STARTLOCK
                    , g_rgClients[i].user.fStartOnLockDesktop);
	        }
        }

        RegCloseKey(hkey);
    }
}

// --------------------------------------------
static BOOL CopyClientData()
{
	umclient_tsp c;
	DWORD_PTR accessID;
	if (!g_cClients || !g_rgClients)
		return TRUE;
	c = (umclient_tsp)AccessIndependentMemory(
							UMC_CLIENT_FILE, 
							sizeof(umclient_ts)*g_cClients, 
							FILE_MAP_READ|FILE_MAP_WRITE,
							&accessID);
	if (!c)
		return FALSE;
	memcpy(c,g_rgClients,sizeof(umclient_ts)*g_cClients);
	UnAccessIndependentMemory(c, accessID);
	return TRUE;
}

static void CopyHeaderData()
{
	umc_header_tsp pHdr;
	DWORD_PTR accessID;

	pHdr = (umc_header_tsp)AccessIndependentMemory(
								UMC_HEADER_FILE, 
								sizeof(umc_header_ts), 
								FILE_MAP_READ|FILE_MAP_WRITE,
								&accessID);
	if (pHdr)
    {
        pHdr->fShowWarningAgain = s_fShowWarningAgain;
	    UnAccessIndependentMemory(pHdr, accessID);
    }
}

// ----------------------------------
// WriteClientData - save settings to the registry
//
static BOOL WriteClientData(BOOL fRunningSecure)
{
    // It only makes sense to do this if there are any applets being managed
    // (shouldn't get here) and if there is a logged on user (otherwise the
    // settings cannot be changed)

	if (!g_cClients || !g_rgClients || fRunningSecure)
		return TRUE;

	// The SYSTEM instance of utilman needs to be updated in case the user
	// changed any options.  This is so subsequent instances of the UI will
	// get the correct options without having to read the registry.

	CopyHeaderData();
	CopyClientData();

    //
    // Write utilman settings data.  Put "Start when UtilMan starts" in HKLM, 
    // "Start when I lock desktop" in HKCU, and "Start when I log on" into
    // a startup link in the logged on user's shell folder.
    //

    // "Start when UtilMan starts" settings... (only for admins)

	DWORD i;
    if (IsWindowEnabled(GetDlgItem(g_hWndDlg, IDC_START_WITH_UM)))
    {
	    HKEY hHKLM;
        DWORD dwRv = RegCreateKeyEx(HKEY_LOCAL_MACHINE
                                , UM_REGISTRY_KEY
                                , 0 , NULL
                                , REG_OPTION_NON_VOLATILE
                                , KEY_ALL_ACCESS, NULL
                                , &hHKLM, NULL);
        if (dwRv == ERROR_SUCCESS)
        {
	        for (i = 0; i < g_cClients; i++)
	        {
                RegSetUMDwordValue(
                      hHKLM
                    , g_rgClients[i].machine.ApplicationName
                    , UMR_VALUE_STARTUM
                    , g_rgClients[i].user.fStartWithUtilityManager);
	        }
	        RegCloseKey(hHKLM);
        }
    }

    //
    // "Start when I lock my desktop" settings... (any logged on user)
    // and Don't show me the warning anymore setting
    //
    WriteUserRegData(HKEY_CURRENT_USER, IsWindowEnabled(GetDlgItem(g_hWndDlg, IDC_START_ON_LOCK)));

    //
    // manage shell folder link updates (logged on user only)
    //

    if (IsWindowEnabled(GetDlgItem(g_hWndDlg, IDC_START_AT_LOGON)))
    {
        CManageShellLinks CManageLinks(STARTUP_FOLDER);

	    for (i = 0; i < g_cClients; i++)
	    {
            LPTSTR pszAppName = g_rgClients[i].machine.ApplicationName;
            BOOL fLinkExists = CManageLinks.LinkExists(pszAppName);

            // if should start at logon and there isn't a link then create one
            // and if shouldn't start at logon and there is a link then delete it

            if (g_rgClients[i].user.fStartAtLogon && !fLinkExists)
            {
                TCHAR pszAppPath[MAX_PATH];
                LPTSTR pszApp = 0;

                // Following is TRUE *only* if pszAppPath is non-null string value
                if (GetClientApplicationPath(pszAppName , pszAppPath , MAX_PATH))
                {
			        TCHAR pszFullPath[MAX_PATH*2+1]; // path + filename
				    TCHAR pszStartIn[MAX_PATH];
                    int ctch, ctchAppPath = lstrlen(pszAppPath);

				    // if pszAppPath is just base name and extension then prepend system path

				    if (wcscspn(pszAppPath, TEXT("\\")) != (size_t)ctchAppPath
                        || wcscspn(pszAppPath, TEXT(":")) != (size_t)ctchAppPath)
				    {
					    TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
					    _wsplitpath(pszAppPath, szDrive, szDir, NULL, NULL);
					    lstrcpy(pszStartIn, szDrive);
					    lstrcat(pszStartIn, szDir);

                        pszApp = pszAppPath;
				    } else
				    {
					    ctch = GetSystemDirectory(pszStartIn, MAX_PATH);

					    lstrcpy(pszFullPath, pszStartIn); // save path to build full path

					    if (ctch + ctchAppPath + 2 > MAX_PATH*2)
					    {
						    DBPRINTF(TEXT("WriteClientData:  Path is too short!\r\n"));
					    } else
					    {
						    if (*(pszFullPath + ctch - 1) != '\\')
							    lstrcat(pszFullPath, TEXT("\\"));

						    lstrcat(pszFullPath, pszAppPath);
                            pszApp = pszFullPath;
					    }
				    }

				    if (pszApp)
				    {
                        // remove ending '\' from StartIn path
                        ctch = lstrlen(pszStartIn) - 1;
				        if (*(pszStartIn + ctch) == '\\')
                            *(pszStartIn + ctch) = 0;

                        CManageLinks.CreateLink(
                                      pszAppName
                                    , pszApp
                                    , pszStartIn
                                    , g_rgClients[i].machine.DisplayName
                                    , TEXT("/UM"));
                    }
                }
            } else if (!g_rgClients[i].user.fStartAtLogon && fLinkExists)
            {
                CManageLinks.RemoveLink(pszAppName);
            }
	    }
    }

	return TRUE;
}
// --------------------------------------------
static BOOL CantStopClient(umclient_tsp client)
{
	switch (client->machine.ApplicationType)
	{
	case APPLICATION_TYPE_APPLICATION:
		break;
	case APPLICATION_TYPE_SERVICE:
		{
			SERVICE_STATUS  ssStatus;
			SC_HANDLE hService;
			SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
			if (!hSCM)
				return TRUE;
			hService = OpenService(hSCM, client->machine.ApplicationName, SERVICE_ALL_ACCESS);
			CloseServiceHandle(hSCM);
			if (!hService)
				return TRUE;
			if (!QueryServiceStatus(hService, &ssStatus) ||
				!(ssStatus.dwControlsAccepted  & SERVICE_ACCEPT_STOP))
			{
				CloseServiceHandle(hService);
				return TRUE;
			}
			CloseServiceHandle(hService);
			break;
		}
	}
	return FALSE;
}//CantStopClient

// We don't want UtilMan to startType to be Automatic
// It should only be made Automatic if it is required, When the user
// selects "Start when NT starts" through the GUI :a-anilk
static BOOL IsStartAuto()
{
#ifdef NEVER    // MICW Don't start service anymore at logon because of TS
    DWORD nClient;
	
	for(nClient = 0; nClient < g_cClients; nClient++)
	{
		if ( g_rgClients[nClient].user.fStartAtLogon == TRUE )
            return TRUE;
    }
#endif
    return FALSE;
}

static int GetClientNameFromAccelerator(WPARAM wVK)
{
	for (int i=0;i<(int)g_cClients;i++)
		if (g_rgClients[i].machine.AcceleratorKey == wVK)
			return i;
	return -1;
}

static BOOL StartClientsOnShow()
{
    BOOL fOK = TRUE;
	for (int i=0;i<(int)g_cClients;i++)
	{
		if ( g_rgClients[i].user.fStartWithUtilityManager
		  && !StartClient(g_hWndDlg, &g_rgClients[i]))
            fOK = FALSE;
	}
    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\utilman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by utilman.rc
//
#define IDI_UM                          102
#define IDS_TSERROR                     500
#define IDS_NOACCESS                    501
#define IDS_DISPLAY_NAME_NARRATOR       502
#define IDS_DISPLAY_NAME_MAGNIFIER      503
#define IDS_DISPLAY_NAME_OSK			504
#define IDS_DISPLAY_NAME_UTILMAN        505

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\utilman\version.h ===
// NARRATOR.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "UtilMan EXE"
#define VER_INTERNALNAME_STR        "UtilMan"
#define VER_ORIGINALFILENAME_STR    "UtilMan.exe"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\umandlg\umdialog.h ===
#if !defined(AFX_UMDIALOG_H__68457343_40A1_11D2_B602_0060977C295E__INCLUDED_)
#define AFX_UMDIALOG_H__68457343_40A1_11D2_B602_0060977C295E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// UMDialog.h : header file
// Author: J. Eckhardt, ECO Kommunikation
// (c) 1997-99 Microsoft
//

/////////////////////////////////////////////////////////////////////////////
// UMDialog dialog

class UMDialog : public CDialog
{
// Construction
public:
	UMDialog(CWnd* pParent = NULL);   // standard constructor
	~UMDialog();	// my destructor

// Dialog Data
	//{{AFX_DATA(UMDialog)
	enum { IDD = IDD_UMAN };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(UMDialog)
	public:
	virtual void OnSysCommand(UINT nID,LPARAM lParam);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(UMDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	afx_msg void OnStart();
	afx_msg void OnStop();
	virtual void OnOK();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnHelp();
	afx_msg void OnSelchangeNameStatus();
	afx_msg void OnStartAtLogon();
	afx_msg void OnStartWithUm();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnStartOnLock();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	inline BOOL GetSelectedClient(int cClients, int &iSel)
	{
		iSel = m_lbClientList.GetCurSel();
		return (iSel < cClients && iSel != -1)?TRUE:FALSE;
	}
	void SetStateStr(int iClient);
	void ListClients();
	void UpdateClientState(int iSel);
	void EnableDlgItem(DWORD dwEnableMe, BOOL fEnable, DWORD dwFocusHere);
	void SaveCurrentState();

	CString  m_szStateStr;
	CString  m_szUMStr;
	CListBox m_lbClientList;
	BOOL     m_fRunningSecure; // TRUE if dialog shouldn't expose help or links
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

/////////////////////////////////////////////////////////////////////////////
// CWarningDlg dialog

class CWarningDlg : public CDialog
{
// Construction
public:
	CWarningDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWarningDlg)
	enum { IDD = IDD_WARNING };
	BOOL	m_fDontWarnAgain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWarningDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UMDIALOG_H__68457343_40A1_11D2_B602_0060977C295E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\utilman\umanrun.c ===
// --------------------------------------------
// switch behaviour
// ----------------------------------------------------------------------------
//
// UManRun.c
//
// Run and watch Utility Manager clients
//
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
//
// History: created oct-98 by JE
//          JE nov-15-98: changed UMDialog message to be a service control message
//          JE nov-15 98: changed to support launch specific client
//			YX jun-01-99: client.machine.DisplayName retrieved from registry
//			YX jun-04-99: UMDlg notified after desktop change; changes in the 
//						  UTimeProc to react the process started outside the manager
//			Bug Fixes and changes Anil Kumar 1999				  
// ----------------------------------------------------------------------------
#include <windows.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
#include "_UMRun.h"
#include "_UMDlg.h"
#include "UtilMan.h"
#include "_UMClnt.h"
#include "UMS_Ctrl.h"
#include "resource.h"
#include "manageshelllinks.h"

// --------------------------------------------
// vars
static desktop_ts s_CurrentDesktop;
extern HINSTANCE hInstance;
static HANDLE    s_hFile = NULL;
static HANDLE    hClientFile = NULL;
static HINSTANCE hDll = NULL;
static umandlg_f UManDlg = NULL;
typedef BOOL (* LPFNISDIALOGUP)(void);
static LPFNISDIALOGUP IsDialogUp = NULL;
// --------------------------------------------
// prototypes
static BOOL InitClientData(umc_header_tsp header);
static BOOL UpdateClientData(umc_header_tsp header,umclient_tsp client);
static BOOL CloseUManDialog(VOID);
static VOID	CorrectClientControlCode(umclient_tsp c, DWORD i);
static VOID	CorrectAllClientControlCodes(umclient_tsp c, DWORD max);
static VOID	ChangeClientControlCode(LPTSTR ApplicationName,DWORD ClientControlCode);

DWORD FindProcess(LPCTSTR pszApplicationName, HANDLE *phProcess);

__inline BOOL IsMSClient(unsigned long ulControlCode)
{
    return (ulControlCode >= UM_SERVICE_CONTROL_MIN_RESERVED 
         && ulControlCode <= UM_SERVICE_CONTROL_MAX_RESERVED)?TRUE:FALSE;
}

// ---------------------------------
// IsTrusted does an explicit name check on Microsoft applications.
// It returns TRUE if szAppPath is a trusted Microsoft applet else FALSE. 
// Applications must be:
//
// 1. osk.exe, magnify.exe, or narrator.exe
// 2. run from %WINDIR%
//
BOOL IsTrusted(LPTSTR szAppPath)
{
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szPath[_MAX_PATH];
	TCHAR szName[_MAX_FNAME];
	TCHAR szExt[_MAX_EXT];

	_wsplitpath(szAppPath, szDrive, szPath, szName, szExt);
	if (lstrlen(szPath) && !lstrlen(szDrive))
		return FALSE;	// if there's a path specifier then require drive
						// otherwise could have sys path on non-sys drive

	if ( lstrcmpi(szName, TEXT("osk")) 
	  && lstrcmpi(szName, TEXT("magnify")) 
#ifdef DBG
      && lstrcmpi(szName, TEXT("inspect"))
      && lstrcmpi(szName, TEXT("accevent"))
#endif
	  && lstrcmpi(szName, TEXT("narrator")) )
		return FALSE;	// it isn't a trusted MS application

	if (lstrcmpi(szExt, TEXT(".exe")))
		return FALSE;	// OK name but it isn't an executable

	// if there is a path on the application it must be in system
	// directory (else it defaults to system directory)

	if (lstrlen(szDrive))
	{
		TCHAR szSysDir[_MAX_PATH];
		int ctch = GetSystemDirectory(szSysDir, _MAX_PATH);
		if (!ctch)
			return FALSE;	// should never happen

		if (_wcsnicmp(szAppPath, szSysDir, ctch))
			return FALSE;	// path isn't system path
	}

	return TRUE;
}

// --------------------------------------------
BOOL InitUManRun(BOOL fFirstInstance, DWORD dwStartMode)
{
	QueryCurrentDesktop(&s_CurrentDesktop,TRUE);
	InitWellknownSids();

	// The first instance of utilman creates and initializes the memory 
	// mapped file regardless of what context it is running in.

	if (fFirstInstance)
	{
		umc_header_tsp d;
		DWORD_PTR accessID;

		s_hFile = CreateIndependentMemory(UMC_HEADER_FILE, sizeof(umc_header_ts), TRUE);
		
		if (!s_hFile)
			return FALSE;
		
		d = (umc_header_tsp)AccessIndependentMemory(
								UMC_HEADER_FILE, 
								sizeof(umc_header_ts), 
								FILE_MAP_ALL_ACCESS, 
								&accessID);
		if (!d)
		{
			DeleteIndependentMemory(s_hFile);
			s_hFile = NULL;
			return FALSE;
		}
		memset(d, 0, sizeof(umc_header_ts));

		InitClientData(d);

		d->dwStartMode = dwStartMode;
		
		UnAccessIndependentMemory(d, accessID);
	}

	return TRUE;
}

VOID ExitUManRun(VOID)
{
	if (s_hFile)
	{
		DeleteIndependentMemory(s_hFile);
		s_hFile = NULL;
	}
	if (hClientFile)
	{
		DeleteIndependentMemory(hClientFile);
		hClientFile = NULL;
	}
	UninitWellknownSids();
}//ExitUManRun
// -----------------------

//
// NotifyClientsBeforeDesktopChanged:  
// Called when the desktop switch object is signaled.  This function captures
// information about running clients, signals and waits for them to quit then
// resets its event object.
//
#define MAX_WAIT_RETRIES 500
BOOL NotifyClientsBeforeDesktopChanged(DWORD dwDesktop)
{
    umc_header_tsp d;
    DWORD_PTR accessID;
    DWORD cClients;

    d = (umc_header_tsp)AccessIndependentMemory(
							UMC_HEADER_FILE, 
							sizeof(umc_header_ts), 
							FILE_MAP_ALL_ACCESS, 
							&accessID);

    if (!d)
    {
        DBPRINTF(TEXT("NotifyClientsBeforeDesktopChanged: Can't AccessIndependentMemory\r\n"));
        return FALSE;
    }

    cClients = d->numberOfClients;
    if (cClients)
    {
        DWORD i;
        DWORD_PTR accessID2;
        umclient_tsp c = (umclient_tsp)AccessIndependentMemory(
											UMC_CLIENT_FILE, 
											sizeof(umclient_ts)*cClients, 
											FILE_MAP_ALL_ACCESS, 
											&accessID2);
        if (c)
        {
            //
            // First capture state about running clients
            //

            if (dwDesktop == DESKTOP_DEFAULT)
            {
                // For now we only need to capture state on the default desktop
                for (i = 0; i < cClients; i++)
                {
                    // We only control restarting MS applications on the default desktop
                    if (IsMSClient(c[i].machine.ClientControlCode) && c[i].state == UM_CLIENT_RUNNING)
                    {
                        c[i].user.fRestartOnDefaultDesk = TRUE;
                    }
                }
            }

            //
            // Then wait for clients to shut down
            //

            for (i = 0; i < cClients; i++)
            {
                // We only control MS applications.  Other applications
                // shouldn't have to worry about desktop switches.
                if (IsMSClient(c[i].machine.ClientControlCode) && c[i].state == UM_CLIENT_RUNNING)
                {
			        DWORD j, dwRunCount = c[i].runCount;
			        for (j = 0; j < dwRunCount; j++)
			        {
                        // Wait for this one to quit...
                        BOOL fClientRunning;
                        int cTries = 0;
                        do
                        {
                            // This code won't work for services but there
                            // are no MS utilman clients that are services. GetExitCodeProcess
				            if (!GetProcessVersion(c[i].processID[j]))
                            {
					            c[i].processID[j] = 0;
                                if (c[i].hProcess[j])
                                {
	  				                CloseHandle(c[i].hProcess[j]);
                                    c[i].hProcess[j] = 0;
                                }
		  			            c[i].mainThreadID[j] = 0;
                                fClientRunning = FALSE;   // This one has quit
                            } else
                            {
                                fClientRunning = TRUE;    // This one hasn't quit yet
                                Sleep(100);
                            }
                            cTries++;
                        } while (fClientRunning && cTries < MAX_WAIT_RETRIES);
                    }
                    c[i].runCount = 0;
                    c[i].state = UM_CLIENT_NOT_RUNNING;
                }
            }

            UnAccessIndependentMemory(c, accessID2);
        }
    }

    UnAccessIndependentMemory(d, accessID);
    return TRUE;
}

//
// NotifyClientsOnDesktopChanged:  Called after a desktop change has occurred.
// This code restarts any clients on the new desktop.
//
BOOL NotifyClientsOnDesktopChanged(DWORD dwDesktop)
{
	umc_header_tsp d;
	DWORD_PTR accessID;

	d = (umc_header_tsp)AccessIndependentMemory(
							UMC_HEADER_FILE, 
							sizeof(umc_header_ts), 
							FILE_MAP_ALL_ACCESS, 
							&accessID);
	if (!d)
		return FALSE;

	if (d->numberOfClients)
	{
        DWORD i,j;
        DWORD_PTR accessID2;
        umclient_tsp c = (umclient_tsp)AccessIndependentMemory(
											UMC_CLIENT_FILE, 
											sizeof(umclient_ts)*d->numberOfClients, 
											FILE_MAP_ALL_ACCESS, 
											&accessID2);
        if (c)
        {
            for (i = 0; i < d->numberOfClients; i++)
            {
                //
                // New         User must configure when to start MS applets on the
                // behavior:   locked desktop.  We'll restart any applets on the
                // (08/2000)   default desktop if they said to start them when they
                //             log in regardless of it's state on secure desktop.
                //             Also restart MS applets if they were running before.
                //
                if( IsMSClient(c[i].machine.ClientControlCode))
                {
                    if ( (dwDesktop == DESKTOP_WINLOGON && c[i].user.fStartOnLockDesktop)
                      || (dwDesktop == DESKTOP_DEFAULT  && c[i].user.fStartAtLogon)
                      || (dwDesktop == DESKTOP_DEFAULT  && c[i].user.fRestartOnDefaultDesk))
                    {
                        if (!StartClient(NULL, &c[i]))
                        {
                            Sleep(500);   // Starting the client failed! Try again
                            StartClient(NULL, &c[i]);
                        }
                    }
                }
                else if (dwDesktop == DESKTOP_DEFAULT &&  c[i].user.fStartAtLogon)
                {
                    UINT mess = RegisterWindowMessage(UTILMAN_DESKTOP_CHANGED_MESSAGE);
                    for (j = 0; j < c[i].runCount; j++)	
                    {
                        // Can only post message if UtilMan started it; we don't
                        // know the process id of externally started clients.
                        if (c[i].mainThreadID[j] != 0)
                            PostThreadMessage(c[i].mainThreadID[j],mess,dwDesktop,0);
                    }
                }
            }
            UnAccessIndependentMemory(c, accessID2);
        }
	}

	UnAccessIndependentMemory(d, accessID);
	return TRUE;
}

// ----------------------------------------
BOOL OpenUManDialogInProc(BOOL fWaitForDlgClose)
{
    if (!hDll)
    {
        hDll = LoadLibrary(UMANDLG_DLL);
        if (!hDll)
            return FALSE;
    }
    if (!UManDlg)
    {
        UManDlg = (umandlg_f)GetProcAddress(hDll, UMANDLG_FCT);
        if (!UManDlg)
        {
            FreeLibrary(hDll);
            return FALSE;
        }
    }
    return UManDlg(TRUE, fWaitForDlgClose, UMANDLG_VERSION);
}
// ----------------------------------------

static BOOL CloseUManDialog(VOID)
{
    BOOL fWasOpen = FALSE;
	if (UManDlg)
	{
		fWasOpen = UManDlg(FALSE, FALSE, UMANDLG_VERSION);
		UManDlg = NULL;
	}
	Sleep(10);

    if (IsDialogUp)
        IsDialogUp = NULL;

	if (hDll)
	{
  		FreeLibrary(hDll);
		hDll = NULL;
	}
	return fWasOpen;
}

// ----------------------------------------

UINT_PTR UManRunSwitchDesktop(desktop_tsp desktop, UINT_PTR timerID)
{
    BOOL fDlgWasUp;
    KillTimer(NULL,timerID);

    if ((desktop->type != DESKTOP_ACCESSDENIED) &&
        (desktop->type != DESKTOP_SCREENSAVER)  &&
        (desktop->type != DESKTOP_TESTDISPLAY))
    {
        if (desktop->type != s_CurrentDesktop.type)
        {
            // if dialog is running in-proc ask it to close
            fDlgWasUp = CloseUManDialog();
            if (!fDlgWasUp)
            {
                // if dialog is running out-of-proc it will close itself
                fDlgWasUp = ResetUIUtilman();
            }
        }
    }

    memcpy(&s_CurrentDesktop, desktop, sizeof(desktop_ts));

    SwitchToCurrentDesktop();

    if ((desktop->type == DESKTOP_ACCESSDENIED) ||
        (desktop->type == DESKTOP_SCREENSAVER)  ||
        (desktop->type == DESKTOP_TESTDISPLAY))
    {
        return 0;
    }
    
    UpdateClientData(NULL, NULL);
    if (fDlgWasUp)
    {
        // Depending on which desktop we're on restart the dialog in-proc or out-of-proc

        if (desktop->type == DESKTOP_WINLOGON)
        {
            OpenUManDialogInProc(FALSE);
        }
        else
        {
            OpenUManDialogOutOfProc();
        }
    }
    return 0;
}
// ---------------------------------

static BOOL InitClientData(umc_header_tsp header)
{
	SERVICE_STATUS  ssStatus;
	DWORD dwRv;
	DWORD index,type,len,i, cchAppName;
	HKEY hKey, sKey;
	DWORD_PTR accessID;
	umclient_tsp c;
	WCHAR ApplicationName[MAX_APPLICATION_NAME_LEN];
	TCHAR ApplicationPath[MAX_APPLICATION_PATH_LEN];
	UINT em;
	HANDLE h;
    unsigned long ccb;

	header->numberOfClients = 0;

	// read the machine dependent data

	dwRv = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY, 0, KEY_READ, &hKey);
	if (dwRv != ERROR_SUCCESS)
	{
		dwRv = RegCreateKeyEx(HKEY_LOCAL_MACHINE,UM_REGISTRY_KEY,0,NULL,REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,NULL,&hKey,NULL);
		if (dwRv != ERROR_SUCCESS)
		{	
  			DBPRINTF(_TEXT("Can't open HKLM\r\n"));
	  		return FALSE;   // error
		}
	}

	// count client applications based on what's in the registry

    cchAppName = MAX_APPLICATION_NAME_LEN;  // RegEnumKey takes count of TCHARs
    index = 0;
	while (RegEnumKey(hKey, index, ApplicationName, cchAppName) == ERROR_SUCCESS)
	{
		index++;
		header->numberOfClients++;
	}

	if (!header->numberOfClients)
	{
		DBPRINTF(_TEXT("No clients\r\n"));
		RegCloseKey(hKey);
		return TRUE;   // no clients registered so nothing to do
	}

    // get a pointer to memory mapped file that contains applet data

    ccb = sizeof(umclient_ts)*header->numberOfClients;
	hClientFile = CreateIndependentMemory(UMC_CLIENT_FILE, ccb, TRUE);
	if (!hClientFile)
	{
		DBPRINTF(_TEXT("Can't create client data\r\n"));
		header->numberOfClients = 0;
		RegCloseKey(hKey);
		return FALSE;   // error - unable to create memory mapped file
	}
 	c = (umclient_tsp)AccessIndependentMemory(
							UMC_CLIENT_FILE, 
							ccb, 
							FILE_MAP_ALL_ACCESS, 
							&accessID);
	if (!c)
	{
		DBPRINTF(_TEXT("Can't access client data\r\n"));
		DeleteIndependentMemory(hClientFile);
		hClientFile = NULL;
		header->numberOfClients = 0;
		RegCloseKey(hKey);
		return FALSE;   // error - unable to access pointer to memory mapped file
	}
    memset(c, 0, ccb);

    // read data from the registry into memory mapped file

	index = 0;  // index for RegEnumKey
	i = 0;      // index into memory mapped file structures

	em = SetErrorMode(SEM_FAILCRITICALERRORS);
	while (RegEnumKey(hKey, index, c[i].machine.ApplicationName, cchAppName) == ERROR_SUCCESS)
	{
		index++;
		dwRv = RegOpenKeyEx(hKey, c[i].machine.ApplicationName, 0, KEY_READ, &sKey);
		if (dwRv != ERROR_SUCCESS)
			continue;

        // get path to applet and verify the file exists

		len = sizeof(TCHAR)*MAX_APPLICATION_PATH_LEN;
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_PATH, NULL, &type, (LPBYTE)ApplicationPath, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_SZ))
		{
			RegCloseKey(sKey);
			continue;
		}

        // CONSIDER This code is one reason why command line arguments aren't supported.
		h = CreateFile(ApplicationPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (h == INVALID_HANDLE_VALUE)
		{
   			DBPRINTF(_TEXT("Invalid client file\r\n"));
			RegCloseKey(sKey);
			continue;   // file doesn't exit -> skip it
		}

        // retrieve and store display name (it differs from the app name 
        // due to possible localization), if not - use app name

		len = sizeof(TCHAR)*MAX_APPLICATION_NAME_LEN;
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_DISPLAY, NULL, &type, (LPBYTE)&c[i].machine.DisplayName, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_SZ))
		{
			lstrcpy(c[i].machine.DisplayName, c[i].machine.ApplicationName);	
		}

        // get the type of applet - verify it is either executable or service

		len = sizeof(DWORD);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_TYPE,NULL, &type, (LPBYTE)&c[i].machine.ApplicationType, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_DWORD))
		{
			RegCloseKey(sKey);
			continue;
		}

		if ((c[i].machine.ApplicationType != APPLICATION_TYPE_APPLICATION) &&
			  (c[i].machine.ApplicationType != APPLICATION_TYPE_SERVICE))
		{
			RegCloseKey(sKey);
			continue;
		}

        // get timeout and runcount and validate values

		len = sizeof(DWORD);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_WRTO, NULL, &type, (LPBYTE)&c[i].machine.WontRespondTimeout, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_DWORD))
		{
			RegCloseKey(sKey);
			continue;
		}

		if (c[i].machine.WontRespondTimeout > MAX_WONTRESPONDTIMEOUT)
			c[i].machine.WontRespondTimeout = MAX_WONTRESPONDTIMEOUT;

		len = sizeof(BYTE);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_MRC, NULL, &type, (LPBYTE)&c[i].machine.MaxRunCount, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_BINARY))
			c[i].machine.MaxRunCount = 1;

		if (!c[i].machine.MaxRunCount)
			c[i].machine.MaxRunCount = 1;

		if (c[i].machine.ApplicationType == APPLICATION_TYPE_SERVICE)
		{
		  if (c[i].machine.MaxRunCount > MAX_SERV_RUNCOUNT)
			  c[i].machine.MaxRunCount = MAX_SERV_RUNCOUNT;
		}
		else
		{
		  if (c[i].machine.MaxRunCount > MAX_APP_RUNCOUNT)
			  c[i].machine.MaxRunCount = MAX_APP_RUNCOUNT;
		}

        // get applet control code and validate

		len = sizeof(DWORD);
		dwRv = RegQueryValueEx(sKey, UMR_VALUE_CCC, NULL, &type, (LPBYTE)&c[i].machine.ClientControlCode, &len);
		if ((dwRv != ERROR_SUCCESS) || (type != REG_DWORD))
			c[i].machine.ClientControlCode = 0;
		else
			CorrectClientControlCode(c, i);

		RegCloseKey(sKey);

        // update applet's running status (services get started here)

		if ((c[i].machine.ApplicationType == APPLICATION_TYPE_SERVICE) &&
		    TestServiceClientRuns(&c[i],&ssStatus))
		{
			c[i].state = UM_CLIENT_RUNNING;
			c[i].runCount = 1;
		}
		else
        {
			c[i].state = UM_CLIENT_NOT_RUNNING;
        }

        // capture whether this is a secure MS applet or not

        c[i].user.fCanRunSecure = IsTrusted(ApplicationPath);

		i++;
	}   //while 

	SetErrorMode(em);

	// set the number of clients based on what has just been read
	header->numberOfClients = i;

	// get user dependent data and correct errant control codes

	UpdateClientData(header, c);
	CorrectAllClientControlCodes(c, header->numberOfClients);
	UnAccessIndependentMemory(c, accessID);
	RegCloseKey(hKey);

	return TRUE;
}//InitClientData
// ---------------------------------

BOOL RegGetUMDwordValue(HKEY hHive, LPCTSTR pszKey, LPCTSTR pszString, DWORD *pdwValue)
{
    HKEY hKey;
	DWORD dwType = REG_BINARY;
	DWORD dwLen;

	DWORD dwRv = RegOpenKeyEx(hHive, pszKey, 0 , KEY_READ, &hKey);
    memset(pdwValue, 0, sizeof(DWORD));
	if (dwRv == ERROR_SUCCESS)
	{
		dwLen = sizeof(DWORD);
		dwRv = RegQueryValueEx(
                      hKey
                    , pszString
                    , NULL, &dwType
                    , (LPBYTE)pdwValue
                    , &dwLen);
		RegCloseKey(hKey);
    }
    return (dwRv == ERROR_SUCCESS && dwType == REG_DWORD)?TRUE:FALSE;
}

// UpdateClientData - updates the memory mapped data for each applet based on
//                    the user that is currently logged on (if any).
//
// header [in] - 
// client [in] - data for each applet managed by utilman
//
// header and client may be null in which case.
//
static BOOL UpdateClientData(umc_header_tsp header, umclient_tsp client)
{
	umc_header_tsp d = 0;
	umclient_tsp c = 0;
	DWORD_PTR accessID = 0, accessID2 = 0;
	DWORD dwRv;
	DWORD i;
	HKEY hHKLM, hHKCU;
    BOOL fRv = FALSE;
    HANDLE hImpersonateToken;
    BOOL fError;

    //
    // get valid header and client struct pointers
    //

	if (header)
    {
		d = header;
    }
	else
	{
		d = (umc_header_tsp)AccessIndependentMemory(
								UMC_HEADER_FILE, 
								sizeof(umc_header_ts), 
								FILE_MAP_ALL_ACCESS, 
								&accessID);
		if (!d)
            goto Cleanup;
	}

	if (!d->numberOfClients)
	{
        fRv = TRUE;    // no clients so nothing to do
        goto Cleanup;
	}

    // by default we warn when running in user context
    d->fShowWarningAgain = TRUE;

	if (client)
    {
		c = client;
    }
	else
	{
        c = (umclient_tsp)AccessIndependentMemory(
								UMC_CLIENT_FILE, 
								sizeof(umclient_ts)*d->numberOfClients, 
								FILE_MAP_ALL_ACCESS, 
								&accessID2);
		if (!c)
            goto Cleanup;
	}

    //
    // Read utilman settings data.  Get "Start when UtilMan starts" from HKLM 
    // and "Start when I lock desktop" from HKCU
    //

	for (i = 0; i < d->numberOfClients; i++)
    {
        c[i].user.fStartWithUtilityManager = FALSE;
        c[i].user.fStartOnLockDesktop = FALSE;
    }

    // "Start when UtilMan starts" settings...

	dwRv = RegOpenKeyEx(HKEY_LOCAL_MACHINE
                , UM_REGISTRY_KEY
                , 0, KEY_READ
                , &hHKLM);

	if (dwRv == ERROR_SUCCESS)
	{
	    for (i = 0; i < d->numberOfClients; i++)
	    {
            RegGetUMDwordValue(hHKLM
                    , c[i].machine.ApplicationName
                    , UMR_VALUE_STARTUM
                    , &c[i].user.fStartWithUtilityManager);
	    }
	    RegCloseKey(hHKLM);
    }

    // "Start when I lock my desktop" and "Start when I log on" settings...

    // At this point, if UtilMan was started before a user logged on, HKCU points
    // to HKEY_USERS\.DEFAULT.  We need it to point to the logged on user's hive so
    // we can manage the registry for the logged on user.  Impersonate the logged on user
    // then use new W2K function RegOpenCurrentUser to get us to the correct registry hive.
    // Note:  GetUserAccessToken() will fail if UtilMan was started from the command
    // line (which is supported for DEBUG only).  In that case, we *are* the user and 
    // don't have to impersonte.

    hImpersonateToken = GetUserAccessToken(TRUE, &fError);
    if (hImpersonateToken)
    {
        if (ImpersonateLoggedOnUser(hImpersonateToken))
        {
            HKEY hkeyUser;
            dwRv = RegOpenCurrentUser(KEY_READ, &hkeyUser);

            if (dwRv == ERROR_SUCCESS)
            {
	            dwRv = RegOpenKeyEx(hkeyUser
                            , UM_HKCU_REGISTRY_KEY
                            , 0, KEY_READ
                            , &hHKCU);

	            if (dwRv == ERROR_SUCCESS)
	            {
	                for (i = 0; i < d->numberOfClients; i++)
	                {
                        RegGetUMDwordValue(hHKCU
                            , c[i].machine.ApplicationName
                            , UMR_VALUE_STARTLOCK
                            , &c[i].user.fStartOnLockDesktop);
	                }
                    RegCloseKey(hHKCU);
	            }
                RegCloseKey(hkeyUser);
            }
            RevertToSelf();
        }
        CloseHandle(hImpersonateToken);

        // Set the start at logon flag based on whether the user has a startup link
        // Note:  The could be done inside the client loop above but LinkExists will
        // also try to impersonate the logged on user.
	    for (i = 0; i < d->numberOfClients; i++)
	    {
            c[i].user.fStartAtLogon = LinkExists(c[i].machine.ApplicationName);
	    }
    } 
	else if (IsInteractiveUser())
    {
	    dwRv = RegOpenKeyEx(HKEY_CURRENT_USER
                    , UM_HKCU_REGISTRY_KEY
                    , 0, KEY_READ
                    , &hHKCU);

	    if (dwRv == ERROR_SUCCESS)
	    {
            // if we're in user context then update warning flag
		    DWORD dwLen = sizeof(DWORD);
            DWORD dwType;
		    dwRv = RegQueryValueEx(
                          hHKCU
                        , UMR_VALUE_SHOWWARNING
                        , NULL, &dwType
                        , (LPBYTE)&d->fShowWarningAgain
                        , &dwLen);

            if (dwRv != ERROR_SUCCESS)
                d->fShowWarningAgain = TRUE;

	        for (i = 0; i < d->numberOfClients; i++)
	        {
                RegGetUMDwordValue(hHKCU
                    , c[i].machine.ApplicationName
                    , UMR_VALUE_STARTLOCK
                    , &c[i].user.fStartOnLockDesktop);

                c[i].user.fStartAtLogon = LinkExists(c[i].machine.ApplicationName);
	        }
            RegCloseKey(hHKCU);
	    }
    }


    fRv = TRUE;

Cleanup:
	if (!header && d)
  		UnAccessIndependentMemory(d, accessID);
 	if (!client && c)
   		UnAccessIndependentMemory(c, accessID2);

	return fRv;
}

BOOL IsDialogDisplayed()
{
    if (GetUIUtilman())
    {
        // Check if the UI dialog process is still up
        DWORD dwExitCode;
        if (GetExitCodeProcess(GetUIUtilman(), &dwExitCode))
        {
            if (dwExitCode != STILL_ACTIVE)
            {
                ResetUIUtilman();
            }
        }
    }
    
    // Check both cases since user may dismiss one UI then quickly bring up another 

    if (!GetUIUtilman())
    {
        // Check if there is a new one running that we need to pick up
        HANDLE hProcess;
        FindProcess(UTILMAN_MODULE, &hProcess);
        SetUIUtilman(hProcess);
    }

    return (GetUIUtilman())?TRUE:FALSE;
}

// ----------------------------------------------------------------------------
// UMTimerProc - Timer procedure called from utilman's timer.  The main purpose
//               of this timer is to pick up any applications the are not started
//               from utilman.  We can restart these if the user switches sessions
//               (or locks) then comes back to this session.  We also detect if an
//               instance of the utilman UI is running.
//
VOID CALLBACK UMTimerProc(HWND hwnd,UINT uMsg,UINT_PTR idEvent,DWORD dwTime)
{
	umc_header_tsp d;
	umclient_tsp c;
	DWORD_PTR accessID,accessID2;

    //
    // check the applets we control 
    //

	d = (umc_header_tsp)AccessIndependentMemory(
							UMC_HEADER_FILE, 
							sizeof(umc_header_ts), 
							FILE_MAP_ALL_ACCESS, 
							&accessID);

	if (d && d->numberOfClients)
    {
	    c = (umclient_tsp)AccessIndependentMemory(
                                UMC_CLIENT_FILE, 
                                sizeof(umclient_ts)*d->numberOfClients, 
								FILE_MAP_ALL_ACCESS, 
                                &accessID2);
	    if (c)
	    {
            CheckStatus(c, d->numberOfClients);
	        UnAccessIndependentMemory(c, accessID2);
	    }

    }

    if (d)
    {
	    UnAccessIndependentMemory(d, accessID);
    }

    // 
    // check the out-of-proc utilman that displays UI
    //

    IsDialogDisplayed();
}
// ---------------------------------

__inline void ReplaceDisplayName(LPTSTR szName, int iRID)
{
	TCHAR szBuf[MAX_APPLICATION_NAME_LEN];
	if (LoadString(hInstance, iRID, szBuf, MAX_APPLICATION_NAME_LEN))
		lstrcpy(szName, szBuf);
}

static VOID	CorrectClientControlCode(umclient_tsp c, DWORD i)
{
	DWORD j;

	// init accelerator key code to not defined
	c[i].machine.AcceleratorKey = ACC_KEY_NONE;

	if (c[i].machine.ClientControlCode < UM_SERVICE_CONTROL_MIN_RESERVED)
	{
		c[i].machine.ClientControlCode = 0;
		return;
	}

	if (IsMSClient(c[i].machine.ClientControlCode))
	{
		TCHAR szBuf[MAX_APPLICATION_NAME_LEN];

		// Microsoft Clients
		if ( lstrcmp( c[i].machine.ApplicationName, TEXT("Magnifier") ) == 0 )
		{
			// Make localization easier; don't require them to localize registry entries.
			// Non-MS applets will have to localize their entries.

			ReplaceDisplayName(c[i].machine.DisplayName, IDS_DISPLAY_NAME_MAGNIFIER);

			c[i].machine.AcceleratorKey = VK_F2;	// hard-wired accelerator keys
			return;									// only for WinLogon desktop
		}
		else if ( lstrcmp( c[i].machine.ApplicationName, TEXT("Narrator") ) == 0 ) 
		{
			// Make localization easier; don't require them to localize registry entries.
			// Non-MS applets will have to localize their entries.

			ReplaceDisplayName(c[i].machine.DisplayName, IDS_DISPLAY_NAME_NARRATOR);

			c[i].machine.AcceleratorKey = VK_F3;
			return;
		}
		else if ( lstrcmp( c[i].machine.ApplicationName, TEXT("On-Screen Keyboard") ) == 0 ) 
		{
			// Make localization easier; don't require them to localize registry entries.
			// Non-MS applets will have to localize their entries.

			ReplaceDisplayName(c[i].machine.DisplayName, IDS_DISPLAY_NAME_OSK);

			c[i].machine.AcceleratorKey = VK_F4;
			return;
		}
		// non-trusted
		else
		{
			c[i].machine.ClientControlCode = 0;
			return;
		}
	}

	if (c[i].machine.ClientControlCode > UM_SERVICE_CONTROL_LASTCLIENT)
	{
		c[i].machine.ClientControlCode = 0;
		return;
	}
	
	for (j = 0; j < i; j++)
	{
		if (c[j].machine.ClientControlCode == c[i].machine.ClientControlCode)
		{
			c[i].machine.ClientControlCode = 0;
			return;
		}
	}
}//CorrectClientControlCode
// ---------------------------------

static VOID	CorrectAllClientControlCodes(umclient_tsp c, DWORD max)
{
DWORD i, j;
DWORD ccc[UM_SERVICE_CONTROL_LASTCLIENT];
  memset(ccc,0,sizeof(DWORD)*UM_SERVICE_CONTROL_LASTCLIENT);
	for (i = 0; i < max; i++)
	{
		if (c[i].machine.ClientControlCode)
			ccc[c[i].machine.ClientControlCode] = 1;
	}
	for (i = 0; i < max; i++)
	{
		if (!c[i].machine.ClientControlCode)
		{
			for (j = UM_SERVICE_CONTROL_FIRSTCLIENT; j <= UM_SERVICE_CONTROL_LASTCLIENT; j++)
			{
				if (!ccc[j])
				{
					c[i].machine.ClientControlCode = j;
					ChangeClientControlCode(c[i].machine.ApplicationName,j);
					ccc[j] = 1;
					break;
				}
			}
		}
	}
}//CorrectAllClientControlCodes
// ---------------------------------

static VOID	ChangeClientControlCode(LPTSTR ApplicationName,DWORD ClientControlCode)
{
	HKEY hKey, sKey;
	DWORD ec, val;
	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, UM_REGISTRY_KEY,0,KEY_ALL_ACCESS,&hKey);

	if (ec != ERROR_SUCCESS)
		return;
	
	ec = RegOpenKeyEx(hKey,ApplicationName,0,KEY_ALL_ACCESS,&sKey);
	
	if (ec != ERROR_SUCCESS)
	{
		RegCloseKey(hKey);
		return;
	}
	
	val = ClientControlCode;
	RegSetValueEx(sKey,UMR_VALUE_CCC,0,REG_DWORD,(BYTE *)&val,sizeof(DWORD));
	RegCloseKey(sKey);
	RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\utilman\utilman\utilman.c ===
// ----------------------------------------------------------------------------
//
// UtilMan.c
//
// Main file for Utility Manager
//
// Author: J. Eckhardt, ECO Kommunikation
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// History: 
//          JE nov-15-98: changed UMDialog message to be a service control message
//			a-anilk: Add /Start, TS Exceptions, Errors, Fixes
// ----------------------------------------------------------------------------

// -----------------------------------------------------------------------
// Change in behavior - Whistler, with terminal server running, doesn't 
// allow running as a service.  Services can only run in session 0 and
// UtilMan needs to be able to run in any session.
// -----------------------------------------------------------------------

#define ALLOW_STOP_SERVICE

// Includes -----------------------------------
#include <windows.h>
#include <initguid.h>
#include <ole2.h>
#include <TCHAR.h>
#include <WinSvc.h>
#include "_UMTool.h"
#include "_UMRun.h"
#include "_UMClnt.h"
#include "UtilMan.h"
#include "UMS_Ctrl.h"
#include "resource.h"
#include <accctrl.h>
#include <aclapi.h>
#include "TSSessionNotify.c"   // for terminal services
#include "w95trace.h"
// --------------------------------------------
// constants
#define UTILMAN_IS_ACTIVE_EVENT         TEXT("UtilityManagerIsActiveEvent")
#define APP_TITLE                       TEXT("Utility Manager")
#define WTSNOTIFY_CLASS                 TEXT("UtilMan Notification Window")
#ifdef ALLOW_STOP_SERVICE
	#define NUM_EV 3
#else
	#define NUM_EV 2
#endif

// This is how often utilman will check for new applets started outside of utilman 
#define TIMER_INTERVAL 5000

// --------------------------------------------
// vars
static HANDLE evIsActive = NULL;
HINSTANCE hInstance = NULL;
static desktop_access_ts dAccess;

// --------------------------------------------
// prototypes
static long ExpFilter(LPEXCEPTION_POINTERS lpEP);
static BOOL CanRunUtilMan(LPTSTR cmdLine, DWORD *pdwRunCode, DWORD *pdwStartMode);
static void LoopService(DWORD dwStartMode);
LRESULT CALLBACK TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// These defines are used to construct a flag that describes
// how the current instance of utilman is being run.  The
// flag has RUNNING_, INSTANCE_ and DESKTOP_ bytes.
#define RUNNING_SYSTEM  0x1
#define RUNNING_USER    0x2
#define INSTANCE_1      0x4
#define INSTANCE_2      0x8
#define DESKTOP_SECURE  0x10
#define DESKTOP_LOGON   0x20

// Don't rely only on the command line flags; validate that if
// the flags indicate SYSTEM we are actually running system.
//
__inline BOOL RunningAsSystem(LPTSTR pszCmdLine)
{
	BOOL fIsSystem = (pszCmdLine && !_tcsicmp(pszCmdLine, TEXT("debug")))?TRUE:FALSE;
    if (fIsSystem)
    {
        fIsSystem = IsSystem();
    }
    return fIsSystem;
}

__inline BOOL RunningAsUser(LPTSTR pszCmdLine)
{
	BOOL fIsLocalUser = (!pszCmdLine || (pszCmdLine && !_tcsicmp(pszCmdLine, TEXT("start"))))?TRUE:FALSE;
	if (fIsLocalUser)
	{
		fIsLocalUser = IsInteractiveUser();
	}
    return fIsLocalUser;
}

//
// OObeRunning returns TRUE it can find the OOBE mutex.
//
__inline BOOL OObeRunning()
{
    HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT("OOBE is running"));
    BOOL fOobeRunning = (hMutex)?TRUE:FALSE;
    if (hMutex)
        CloseHandle(hMutex);

    return fOobeRunning;
}

int PASCAL WinMain(HINSTANCE hInst, 
                   HINSTANCE hPrevInst, 
                   LPSTR lpCmdLine, 
                   int nCmdShow)
{
	LPTSTR cmdLine = GetCommandLine();

	hInstance = hInst;

	__try
	{
        TCHAR  szDir[_MAX_PATH];
        DWORD  dwStartMode;
        BOOL   fKeepRunning;
        HANDLE hEvent    = OpenEvent(EVENT_MODIFY_STATE, FALSE, UTILMAN_IS_ACTIVE_EVENT);
        DWORD  dwRunCode = (hEvent)?INSTANCE_2:INSTANCE_1;

        // utilman needs to run in windows system directory 
        // so it can find MS trusted applets

        if (GetSystemDirectory(szDir, _MAX_PATH))
        {
            SetCurrentDirectory(szDir);
        }

        // assign to the correct desktop (will fail if any windows are open)

		InitDesktopAccess(&dAccess);

        CoInitialize(NULL);

        fKeepRunning = CanRunUtilMan(cmdLine, &dwRunCode, &dwStartMode);

        // initialize shared memory

	    if (!InitUManRun((dwRunCode & INSTANCE_1), dwStartMode))
	    {
            DBPRINTF(TEXT("WinMain:  InitUManRun FAILED\r\n"));
		    return 1;
	    }

        if (!hEvent)
        {
		    evIsActive = BuildEvent(UTILMAN_IS_ACTIVE_EVENT, FALSE, FALSE, TRUE);
        }

        switch(dwRunCode)
        {
            case RUNNING_SYSTEM|INSTANCE_1|DESKTOP_SECURE:
                OpenUManDialogInProc(FALSE);
                break;

            case RUNNING_SYSTEM|INSTANCE_2|DESKTOP_SECURE:
                SetEvent(hEvent);
                break;

            case RUNNING_SYSTEM|INSTANCE_1|DESKTOP_LOGON:
            case RUNNING_SYSTEM|INSTANCE_2|DESKTOP_LOGON:
                OpenUManDialogOutOfProc();
                break;

            case RUNNING_USER|INSTANCE_1|DESKTOP_LOGON:
            case RUNNING_USER|INSTANCE_2|DESKTOP_LOGON:
                OpenUManDialogInProc(TRUE);
                break;

            default:
                DBPRINTF(TEXT("WinMain:  Taking default switch path dwRunCode = 0x%x dwStartMode = %d\r\n"), dwRunCode, dwStartMode);
                break;
        }

	    if (hEvent)
	    {
		    CloseHandle(hEvent);
        }

        if (fKeepRunning)
        {
            LoopService(dwStartMode);
        }

        DBPRINTF(TEXT("WinMain:  Exiting...\r\n"));
		ExitUManRun();
		CloseHandle(evIsActive);
		ExitDesktopAccess(&dAccess);
        CoUninitialize();
	}
	__except(ExpFilter(GetExceptionInformation()))
	{
	}

	return 1;
}
// ---------------------------------

VOID TerminateUMService(VOID)
{
	HANDLE  ev = BuildEvent(STOP_UTILMAN_SERVICE_EVENT,FALSE,FALSE,TRUE);
    DBPRINTF(TEXT("TerminateUMService:  signaling STOP_UTILMAN_SERVICE_EVENT\r\n"));
	SetEvent(ev);
	CloseHandle(ev);
}

// -------------------------
static BOOL CanRunUtilMan(LPTSTR cmdLine, DWORD *pdwRunCode, DWORD *pdwStartMode)
{
	LPTSTR      pszCmdLine;
	desktop_ts  desktop;
    DWORD       dwRunCode = 0;
    DWORD       dwStartMode = START_BY_OTHER;
    BOOL        fKeepRunning = FALSE;
	TCHAR       szUMDisplayName[256];

    // Detect if there is a utilman dialog currently up.  See if we can find
    // the "Utility Manager" window.

	if (!LoadString(hInstance, IDS_DISPLAY_NAME_UTILMAN, szUMDisplayName, 256))
	{
		DBPRINTF(TEXT("IsDialogRunning:  Cannot find IDS_DISPLAY_NAME_UTILMAN resource\r\n"));
        return TRUE;    // cause a noticable error
	}

    if (FindWindowEx(NULL, NULL, TEXT("#32770"), szUMDisplayName))
	{
        goto ExitCanRunUtilman;
    }

    // Ours is the only instance of utilman running in this security context.
	// If we are running SYSTEM there may be another instance (in the user's 
	// context) but we can't detect that.  In that case, the SYSTEM instance
	// will launch an instance in the user's context and we'll detect the
	// window up then.

    dwRunCode = *pdwRunCode;

	pszCmdLine = _tcschr(cmdLine, TEXT('/'));
	if (!pszCmdLine)
    {
		pszCmdLine = _tcschr(cmdLine, TEXT('-'));
    }
	if (pszCmdLine)
    {
		pszCmdLine++;
    }

    // Determine if this instance is running as SYSTEM or the interactive user.
    // This is a kludge because of the way utilman gets started with certain
    // flags (/debug when started from winlogon and /start when started from
    // Start menu).  Better way would be to detect the SID(s) in this process's
    // token and decide from there what to do.  Consider for the next version.

	if (RunningAsSystem(pszCmdLine))
	{
		dwRunCode |= RUNNING_SYSTEM;
        dwStartMode = START_BY_HOTKEY;
	}
	if (RunningAsUser(pszCmdLine))
	{
		dwRunCode |= RUNNING_USER;
        dwStartMode = (dwRunCode & INSTANCE_1)?START_BY_MENU:START_BY_HOTKEY;
	}

    // Get the current desktop type and set the desktop flag

    QueryCurrentDesktop(&desktop, TRUE);

    // OOBE fix: Oobe runs on the interactive desktop as SYSTEM before any user
    // is logged on.  We break their accessibility if we determine how to run
    // based on which desktop we're on.  So special-case setting DESKTOP_SECURE
	// if OOBE is running.

    if (desktop.type == DESKTOP_WINLOGON || (IsSystem() && OObeRunning()))
    {
        dwRunCode |= DESKTOP_SECURE;
        dwStartMode = START_BY_HOTKEY; // paranoia
    }
    else
    {
        dwRunCode |= DESKTOP_LOGON;
    }

    // If this is the first time utilman is run for the session and it is running as
	// SYSTEM then this instance of utilman should continue running after the dialog
	// is dismissed.  This instance will handle monitoring applets and the UI instance
	// during desktop and session changes.

    fKeepRunning = ((dwRunCode & INSTANCE_1) && (dwRunCode & RUNNING_SYSTEM));

ExitCanRunUtilman:
    *pdwRunCode = dwRunCode;
    *pdwStartMode = dwStartMode;

	return fKeepRunning;
}

__inline void CloseEventHandles(HANDLE events[])
{
	CloseHandle(events[0]);
    CloseHandle(events[1]);
#ifdef ALLOW_STOP_SERVICE
	CloseHandle(events[2]);
#endif
}

// -------------------------
static void LoopService(DWORD dwStartMode)
{
    HWND hWndMessages;
	desktop_ts desktop;
	HANDLE events[NUM_EV];
	DWORD r;
	UINT_PTR  timerID = 0;

    // assign thread to the current desktop

	SwitchToCurrentDesktop();

    // set up the array of object handles for MsgWaitForMultipleObjects

	events[0] = OpenEvent(SYNCHRONIZE, FALSE, __TEXT("WinSta0_DesktopSwitch"));
    events[1] = evIsActive;
#ifdef ALLOW_STOP_SERVICE
	events[2] = BuildEvent(STOP_UTILMAN_SERVICE_EVENT,FALSE,FALSE,TRUE);
#endif

    // create a message-only window to handle terminal server 
    // session notification messages

    hWndMessages = CreateWTSNotifyWindow(hInstance, TSNotifyWndProc);

    // note the current desktop so we know where we came from 
    // and where we are going when the desktop changes

    QueryCurrentDesktop(&desktop, TRUE);

	// Change timer to 5 seconds.  This timer is helps detect client 
    // apps not started with utilman (so we can restart them if the
    // user switches away from this session) and the status of the
    // utilman process displaying UI.

    timerID = SetTimer(NULL, 1, TIMER_INTERVAL, UMTimerProc);
	for (;;)
    {
	    desktop_ts desktopT;
        // 
        // Sync the current desktop; if it has changed (eg we missed
        // a desktop switch notification) then bypass the MWFMO and
        // go into the desktop switch code.
        //
        QueryCurrentDesktop(&desktopT, TRUE);
        r = WAIT_OBJECT_0 + NUM_EV + 1; // signals we've got the current desktop

        if (desktopT.type == desktop.type)
        {
            // Nope, wait for objects...
		    r = MsgWaitForMultipleObjects(NUM_EV,events, FALSE, INFINITE, QS_ALLINPUT);
#ifdef ALLOW_STOP_SERVICE
		    if (r == (WAIT_OBJECT_0+NUM_EV-1))//stop event
			    break;
#endif
            if (r == (WAIT_OBJECT_0+1)) // Show dialog event
            {
                DBPRINTF(TEXT("LoopService:  Got UTILMAN_IS_ACTIVE_EVENT event\r\n"));
		        OpenUManDialogInProc(FALSE);
                continue;
            }
		    if (r == (WAIT_OBJECT_0+NUM_EV))
		    {
                // this message loop is just for the timer
			    MSG msg;
			    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			    {
				    TranslateMessage(&msg);
				    DispatchMessage(&msg);
			    }
			    continue;
		    }
		    if (r != WAIT_OBJECT_0)// any kind of error
			    continue;

            // When this session is being disconnected the switch is a noop.
            // Get the new desktop and compare with the old; if we haven't
            // changed then just continue to wait...

            QueryCurrentDesktop(&desktopT, TRUE);
            if (desktopT.type == desktop.type)
                continue;
        }

        // desktop switch event - kill the timer and get clients to quit this desktop

        KillTimer(NULL, timerID);

		NotifyClientsBeforeDesktopChanged(desktop.type);

		WaitDesktopChanged(&desktop);
		UManRunSwitchDesktop(&desktop, timerID);

		NotifyClientsOnDesktopChanged(desktop.type);

        // start the timer up again to monitor client aps

        timerID = SetTimer(NULL, 1, TIMER_INTERVAL, UMTimerProc);
	}
	CloseEventHandles(events);

    // Clean up the terminal server message-only window
    DestroyWTSNotifyWindow(hWndMessages);
}

// -------------------------
static long ExpFilter(LPEXCEPTION_POINTERS lpEP)
{
	TCHAR message[500];
	_stprintf(message, TEXT("Exception: Code %8.8x Flags %8.8x Address %8.8x"),
		lpEP->ExceptionRecord->ExceptionCode,
		lpEP->ExceptionRecord->ExceptionFlags,
		lpEP->ExceptionRecord->ExceptionAddress);
	MessageBox(NULL, message, APP_TITLE, MB_OK | MB_ICONSTOP);
	return EXCEPTION_EXECUTE_HANDLER;
}

// TSNotifyWndProc - callback that receives window message notifications from terminal services
//
LRESULT CALLBACK TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fNarratorRunning = FALSE;
    // Could react to WTS_CONSOLE_DISCONNECT and WTS_REMOTE_DISCONNECT too however
    // both disconnect and the connect come after the desktop switch notification.
    // For the cases where TS isn't there (server and workstation in a domain) we
    // have to handle cleanup in desk switch.  For future, it would be nice to code
    // such that the cleanup handler could be exec'd at session change or desk
    // switch but not both.
	if (uMsg == WM_WTSSESSION_CHANGE && wParam == WTS_SESSION_LOGOFF)
	{
            umc_header_tsp d;
            DWORD_PTR accessID;
            desktop_ts desktop;
            
            WaitDesktopChanged(&desktop);
            d = (umc_header_tsp)AccessIndependentMemory(UMC_HEADER_FILE, sizeof(umc_header_ts), FILE_MAP_ALL_ACCESS, &accessID);
            if (d)
            {
                DWORD cClients = d->numberOfClients;
                
                if (cClients)
                {
                    DWORD i, j;
                    DWORD_PTR accessID2;
                    umclient_tsp c = (umclient_tsp)AccessIndependentMemory(
            											UMC_CLIENT_FILE, 
            											sizeof(umclient_ts)*cClients, 
            											FILE_MAP_ALL_ACCESS, 
            											&accessID2);
                    if (c)
                    {
                        // When a user logs off they switch to the locked desktop before getting to the logged off desktop
                        // (both these desktops are WINLOGON). This means that the applets that have start me on the
                        // locked desktop will startup only to need to stopped when the user logs is finnished being
                        // logged off.  Because of a time issue this was broken.  So we need to detect the logoff and make
                        // sure the applets have shut down. If we don't they stay up and then when the user logs back
                        // in they won't  start up on the default desktop because they are still running on winlogon desktop. 
                        // the applets take a long time to come up and if we try to shut them down to fast then they miss
                        // the message and stay up.  So we will keep trying for a long enough time to make sure we get them.
                        
                        Sleep(4000);

                        for (i = 0; i < cClients; i++)
                        {
                            if (lstrcmp(c[i].machine.DisplayName, TEXT("Narrator")) == 0)
                                fNarratorRunning = TRUE;
                            else
                                StopClient(&c[i]);
                        }
                        UnAccessIndependentMemory(c, accessID2);
                    }
                }
            }
            UnAccessIndependentMemory(d, accessID);
            // Narrator does not respond to the close messages to keep utilman running to bring it back up when they login.
            if (!fNarratorRunning)
                TerminateUMService();
	}


	return DefWindowProc( hwnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\console.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    menu.c

Abstract:

        This file implements the system menu management.

Author:

    Therese Stowell (thereses) Jan-24-1992 (swiped from Win3.1)

--*/

#include "precomp.h"
#pragma hdrstop


BOOL InEM_UNDO=FALSE;

BYTE ColorArray[4];
int Index;

BOOL gbSaveToRegistry;
BOOL gbWriteToConsole;
BOOL gbStartedFromLink;
LONG gcxScreen;
LONG gcyScreen;
UINT gnCurrentPage;

PCONSOLE_STATE_INFO gpStateInfo;
BOOL g_fAutoComplete;
BOOL g_fSaveAutoCompleteState;


/*
 *  Context Help Ids.
 */
CONST DWORD gaConsoleHelpIds[] =
{
    IDD_WINDOWED,               IDH_DOS_SCREEN_USAGE_WINDOW,
    IDD_FULLSCREEN,             IDH_DOS_SCREEN_USAGE_FULL,
    IDD_DISPLAY_GROUPBOX,       -1,
    IDD_QUICKEDIT,              IDH_CONSOLE_OPTIONS_QUICK_EDIT,
    IDD_INSERT,                 IDH_CONSOLE_OPTIONS_INSERT,
    IDD_CURSOR_SMALL,           IDH_CONSOLE_OPTIONS_CURSOR,
    IDD_CURSOR_MEDIUM,          IDH_CONSOLE_OPTIONS_CURSOR,
    IDD_CURSOR_LARGE,           IDH_CONSOLE_OPTIONS_CURSOR,
    IDD_HISTORY_SIZE,           IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDD_HISTORY_SIZESCROLL,     IDH_CONSOLE_OPTIONS_BUFF_SIZE,
    IDD_HISTORY_NUM,            IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDD_HISTORY_NUMSCROLL,      IDH_CONSOLE_OPTIONS_BUFF_NUM,
    IDD_HISTORY_NODUP,          IDH_CONSOLE_OPTIONS_DISCARD_DUPS,
#if defined(FE_SB)
    IDD_LANGUAGELIST,           IDH_CONSOLE_OPTIONS_LANGUAGE,
    IDD_LANGUAGE,               IDH_CONSOLE_OPTIONS_LANGUAGE,
#endif
    IDD_STATIC,                 IDH_CONSOLE_FONT_FONT,
    IDD_FACENAME,               IDH_CONSOLE_FONT_FONT,
    IDD_BOLDFONT,               IDH_CONSOLE_FONT_BOLD_FONTS,
    IDD_PREVIEWLABEL,           IDH_DOS_FONT_WINDOW_PREVIEW,
    IDD_PREVIEWWINDOW,          IDH_DOS_FONT_WINDOW_PREVIEW,
    IDD_GROUP,                  IDH_DOS_FONT_FONT_PREVIEW,
    IDD_STATIC2,                IDH_DOS_FONT_FONT_PREVIEW,
    IDD_STATIC3,                IDH_DOS_FONT_FONT_PREVIEW,
    IDD_STATIC4,                IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTWIDTH,              IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTHEIGHT,             IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTWINDOW,             IDH_DOS_FONT_FONT_PREVIEW,
    IDD_FONTSIZE,               IDH_DOS_FONT_SIZE,
    IDD_POINTSLIST,             IDH_DOS_FONT_SIZE,
    IDD_PIXELSLIST,             IDH_DOS_FONT_SIZE,
    IDD_SCRBUF_WIDTH,           IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDD_SCRBUF_WIDTHSCROLL,     IDH_CONSOLE_SIZE_BUFF_WIDTH,
    IDD_SCRBUF_HEIGHT,          IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDD_SCRBUF_HEIGHTSCROLL,    IDH_CONSOLE_SIZE_BUFF_HEIGHT,
    IDD_WINDOW_WIDTH,           IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDD_WINDOW_WIDTHSCROLL,     IDH_CONSOLE_SIZE_WIN_WIDTH,
    IDD_WINDOW_HEIGHT,          IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDD_WINDOW_HEIGHTSCROLL,    IDH_CONSOLE_SIZE_WIN_HEIGHT,
    IDD_WINDOW_POSX,            IDH_CONSOLE_SIZE_POS_LEFT,
    IDD_WINDOW_POSXSCROLL,      IDH_CONSOLE_SIZE_POS_LEFT,
    IDD_WINDOW_POSY,            IDH_CONSOLE_SIZE_POS_TOP,
    IDD_WINDOW_POSYSCROLL,      IDH_CONSOLE_SIZE_POS_TOP,
    IDD_AUTO_POSITION,          IDH_CONSOLE_SIZE_LET_SYS,
    IDD_COLOR_SCREEN_TEXT,      IDH_CONSOLE_COLOR_SCR_TEXT,
    IDD_COLOR_SCREEN_BKGND,     IDH_CONSOLE_COLOR_SCR_BACK,
    IDD_COLOR_POPUP_TEXT,       IDH_CONSOLE_COLOR_POPUP_TEXT,
    IDD_COLOR_POPUP_BKGND,      IDH_CONSOLE_COLOR_POPUP_BACK,
    IDD_COLOR_1,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_2,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_3,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_4,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_5,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_6,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_7,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_8,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_9,                IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_10,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_11,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_12,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_13,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_14,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_15,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_16,               IDH_CONSOLE_COLOR_COLOR_BAR,
    IDD_COLOR_SCREEN_COLORS,    IDH_CONSOLE_COLOR_SCR_COLORS,
    IDD_COLOR_POPUP_COLORS,     IDH_CONSOLE_COLOR_WIN_COLORS,
    IDD_COLOR_RED,              IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_REDSCROLL,        IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_GREEN,            IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_GREENSCROLL,      IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_BLUE,             IDH_CONSOLE_COLOR_RED,
    IDD_COLOR_BLUESCROLL,       IDH_CONSOLE_COLOR_RED,
    IDD_AUTOCOMPLETE,           IDH_CONSOLE_OPTIONS_AUTOCOMPLETE,
    0,                          0
};

VOID
UpdateItem(
    HWND hDlg,
    UINT item,
    UINT nNum
    )
{
    SetDlgItemInt(hDlg, item, nNum, TRUE);
    SendDlgItemMessage(hDlg, item, EM_SETSEL, 0, (DWORD)-1);
}


BOOL
CheckNum(
    HWND hDlg,
    UINT Item)
{
    int i;
    TCHAR szNum[5];
    BOOL fSigned;

    if (Item == IDD_WINDOW_POSX || Item == IDD_WINDOW_POSY) {
        fSigned = TRUE;
    } else {
        fSigned = FALSE;
    }

    GetDlgItemText(hDlg, Item, szNum, NELEM(szNum));
    for (i = 0; szNum[i]; i++) {
        if (!iswdigit(szNum[i]) && (!fSigned || i > 0 || szNum[i] != TEXT('-')))
            return FALSE;
    }
    return TRUE;
}


INT_PTR
CommonDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (wMsg) {
    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)gaConsoleHelpIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)gaConsoleHelpIds);
        break;

    default:
        break;
    }
    return FALSE;
}


INT_PTR
WINAPI
SaveQueryDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HFONT hFont;
    HWND  hChild;
    HWND  hCreator;

    switch (wMsg) {
    case WM_INITDIALOG:
        /*
         * Save the handle of the window that created us
         */
        hCreator = (HWND)lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        /*
         * Get the font used in other controls
         */
        hChild = GetWindow(hCreator, GW_CHILD);
        hFont = GetWindowFont(hChild);

        /*
         * Now apply it to our controls
         */
        hChild = GetWindow(hDlg, GW_CHILD);
        while (hChild != NULL) {
            SetWindowFont(hChild, hFont, TRUE);
            hChild = GetWindow(hChild, GW_HWNDNEXT);
        }

        CheckRadioButton(hDlg, IDD_APPLY, IDD_SAVE, IDD_APPLY);
        gbSaveToRegistry = FALSE;
        gbWriteToConsole = FALSE;
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (IsDlgButtonChecked(hDlg, IDD_SAVE)) {
                gbSaveToRegistry = TRUE;
            }
            gbWriteToConsole = TRUE;
            EndDialog(hDlg, PSNRET_NOERROR);
            return TRUE;
        case IDCANCEL:
            EndDialog(hDlg, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }
        break;

    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
        /*
         * Let the window who created us decide what colors to use
         */
        hCreator = (HWND)GetWindowLongPtr(hDlg, GWLP_USERDATA);
        return SendMessage(hCreator, wMsg, wParam, lParam);
    }
    return FALSE;
}


UINT
ConsolePropSheetProc(
    HWND hDlg,
    UINT wMsg,
    LPARAM lParam
    )
{
    DWORD dwExStyle;

    switch (wMsg) {
    case PSCB_INITIALIZED:
        /*
         * If we're connected to the server, tell him we're starting
         */
        if (gpStateInfo->hWnd != NULL) {
            SendMessage(gpStateInfo->hWnd, CM_PROPERTIES_START, (WPARAM)hDlg, 0);
        }
        break;
    default:
        break;
    }

    return 0;
}


VOID
EndDlgPage(
    HWND hDlg
    )
{
    HWND hParent;
    HWND hTabCtrl;
    INT_PTR Result;

    /*
     * If we've already made a decision, we're done
     */
    if (gbWriteToConsole || gbSaveToRegistry) {
        SetDlgMsgResult(hDlg, PSN_APPLY, PSNRET_NOERROR);
        return;
    }

    /*
     * Get the current page number
     */
    hParent = GetParent(hDlg);
    hTabCtrl = PropSheet_GetTabControl(hParent);
    gnCurrentPage = TabCtrl_GetCurSel(hTabCtrl);

    /*
     * If we're not connected to the server, we're done
     */
    if (gpStateInfo->hWnd == NULL) {
        gbSaveToRegistry = TRUE;
        SetDlgMsgResult(hDlg, PSN_APPLY, PSNRET_NOERROR);
        return;
    }

    /*
     * Check to show the Apply/Save dialog box
     */
    if (gbStartedFromLink)
    {
        Result = DialogBoxParam(ghInstance, MAKEINTRESOURCE(DID_SAVE_QUERY_LINK),
                                GetParent(hDlg), SaveQueryDlgProc, (LPARAM)hDlg);

        SetDlgMsgResult(hDlg, PSN_APPLY, Result);
    }
    else
    {
        Result = DialogBoxParam(ghInstance, MAKEINTRESOURCE(DID_SAVE_QUERY),
                                GetParent(hDlg), SaveQueryDlgProc, (LPARAM)hDlg);

        SetDlgMsgResult(hDlg, PSN_APPLY, Result);
    }
    return;
}


LRESULT
ColorControlProc(
    HWND hColor,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Window proc for the color buttons

--*/

{
    PAINTSTRUCT ps;
    int ColorId;
    RECT rColor;
    RECT rTemp;
    HBRUSH hbr;
    HDC hdc;
    HWND hWnd;
    HWND hDlg;
    COLORREF rgbBrush;

    ColorId = GetWindowLong(hColor, GWL_ID);
    hDlg = GetParent(hColor);

    switch (wMsg) {
    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTTAB;
        break;
    case WM_SETFOCUS:
        if (ColorArray[Index] != (BYTE)(ColorId - IDD_COLOR_1)) {
            hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
            SetFocus(hWnd);
        }
        // Fall through
    case WM_KILLFOCUS:
        hdc = GetDC(hDlg);
        hWnd = GetDlgItem(hDlg, IDD_COLOR_1);
        GetWindowRect(hWnd, &rColor);
        hWnd = GetDlgItem(hDlg, IDD_COLOR_16);
        GetWindowRect(hWnd, &rTemp);
        rColor.right = rTemp.right;
        ScreenToClient(hDlg, (LPPOINT)&rColor.left);
        ScreenToClient(hDlg, (LPPOINT)&rColor.right);
        InflateRect(&rColor, 2, 2);
        DrawFocusRect(hdc, &rColor);
        ReleaseDC(hDlg, hdc);
        break;
    case WM_KEYDOWN:
        switch (wParam) {
        case VK_UP:
        case VK_LEFT:
            if (ColorId > IDD_COLOR_1) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId - 1 - IDD_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_DOWN:
        case VK_RIGHT:
            if (ColorId < IDD_COLOR_16) {
                SendMessage(hDlg, CM_SETCOLOR,
                            ColorId + 1 - IDD_COLOR_1, (LPARAM)hColor);
            }
            break;
        case VK_TAB:
            hWnd = GetDlgItem(hDlg, IDD_COLOR_1);
            hWnd = GetNextDlgTabItem(hDlg, hWnd, GetKeyState(VK_SHIFT) < 0);
            SetFocus(hWnd);
            break;
        default:
            return DefWindowProc(hColor, wMsg, wParam, lParam);
        }
        break;
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        SendMessage(hDlg, CM_SETCOLOR,
                    ColorId - IDD_COLOR_1, (LPARAM)hColor);
        break;
    case WM_PAINT:
        BeginPaint(hColor, &ps);
        GetClientRect(hColor, &rColor);
        rgbBrush = GetNearestColor(ps.hdc, AttrToRGB(ColorId-IDD_COLOR_1));
        if ((hbr = CreateSolidBrush(rgbBrush)) != NULL) {
            //
            // are we the selected color for the current object?
            //
            if (ColorArray[Index] == (BYTE)(ColorId - IDD_COLOR_1)) {

                //
                // put current values in dialog box
                //
                UpdateItem(hDlg, IDD_COLOR_RED,
                           GetRValue(AttrToRGB(ColorArray[Index])));
                UpdateItem(hDlg, IDD_COLOR_GREEN,
                           GetGValue(AttrToRGB(ColorArray[Index])));
                UpdateItem(hDlg, IDD_COLOR_BLUE,
                           GetBValue(AttrToRGB(ColorArray[Index])));

                //
                // highlight the selected color
                //
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
                InflateRect(&rColor, -1, -1);
                FrameRect(ps.hdc, &rColor, GetStockObject(BLACK_BRUSH));
            }
            InflateRect(&rColor, -1, -1);
            FillRect(ps.hdc, &rColor, hbr);
            DeleteObject(hbr);
        }
        EndPaint(hColor, &ps);
        break;
    default:
        return DefWindowProc(hColor, wMsg, wParam, lParam);
        break;
    }
    return TRUE;
}


INT_PTR
WINAPI
ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the color selection dialog box.

--*/

{
    UINT Value;
    UINT Red;
    UINT Green;
    UINT Blue;
    UINT Item;
    HWND hWnd;
    HWND hWndOld;
    BOOL bOK;

    switch (wMsg) {
    case WM_INITDIALOG:
        ColorArray[IDD_COLOR_SCREEN_TEXT - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->ScreenAttributes) & 0x0F;
        ColorArray[IDD_COLOR_SCREEN_BKGND - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->ScreenAttributes >> 4);
        ColorArray[IDD_COLOR_POPUP_TEXT - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->PopupAttributes) & 0x0F;
        ColorArray[IDD_COLOR_POPUP_BKGND - IDD_COLOR_SCREEN_TEXT] =
                LOBYTE(gpStateInfo->PopupAttributes >> 4);
        CheckRadioButton(hDlg,IDD_COLOR_SCREEN_TEXT,IDD_COLOR_POPUP_BKGND,IDD_COLOR_SCREEN_BKGND);
        Index = IDD_COLOR_SCREEN_BKGND - IDD_COLOR_SCREEN_TEXT;

        // initialize size of edit controls

        SendDlgItemMessage(hDlg, IDD_COLOR_RED, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_COLOR_GREEN, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_COLOR_BLUE, EM_LIMITTEXT, 3, 0L);

        // initialize arrow controls

        SendDlgItemMessage(hDlg, IDD_COLOR_REDSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(255, 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_REDSCROLL, UDM_SETPOS, 0,
                           MAKELONG(GetRValue(AttrToRGB(ColorArray[Index])), 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_GREENSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(255, 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_GREENSCROLL, UDM_SETPOS, 0,
                           MAKELONG(GetGValue(AttrToRGB(ColorArray[Index])), 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_BLUESCROLL, UDM_SETRANGE, 0,
                           MAKELONG(255, 0));
        SendDlgItemMessage(hDlg, IDD_COLOR_BLUESCROLL, UDM_SETPOS, 0,
                           MAKELONG(GetBValue(AttrToRGB(ColorArray[Index])), 0));

        return TRUE;

    case WM_COMMAND:
        Item = LOWORD(wParam);
        switch (Item) {
        case IDD_COLOR_SCREEN_TEXT:
        case IDD_COLOR_SCREEN_BKGND:
        case IDD_COLOR_POPUP_TEXT:
        case IDD_COLOR_POPUP_BKGND:
            hWndOld = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);

            Index = Item - IDD_COLOR_SCREEN_TEXT;

            // repaint new color
            hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
            InvalidateRect(hWnd, NULL, TRUE);

            // repaint old color
            if (hWndOld != hWnd) {
                InvalidateRect(hWndOld, NULL, TRUE);
            }

            return TRUE;

        case IDD_COLOR_RED:
        case IDD_COLOR_GREEN:
        case IDD_COLOR_BLUE:
            switch (HIWORD(wParam)) {
            case EN_UPDATE:
                if (!CheckNum (hDlg, Item)) {
                    if (!InEM_UNDO) {
                        InEM_UNDO = TRUE;
                        SendMessage((HWND)lParam, EM_UNDO, 0, 0L);
                        InEM_UNDO = FALSE;
                    }
                }
                break;
            case EN_KILLFOCUS:
                /*
                 * Update the state info structure
                 */
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK) {
                    if (Value > 255) {
                        UpdateItem(hDlg, Item, 255);
                        Value = 255;
                    }
                    if (Item == IDD_COLOR_RED) {
                        Red = Value;
                    } else {
                        Red = GetRValue(AttrToRGB(ColorArray[Index]));
                    }
                    if (Item == IDD_COLOR_GREEN) {
                        Green = Value;
                    } else {
                        Green = GetGValue(AttrToRGB(ColorArray[Index]));
                    }
                    if (Item == IDD_COLOR_BLUE) {
                        Blue = Value;
                    } else {
                        Blue = GetBValue(AttrToRGB(ColorArray[Index]));
                    }
                    UpdateStateInfo(hDlg, ColorArray[Index] + IDD_COLOR_1,
                                    RGB(Red, Green, Blue));
                }

                /*
                 * Update the preview windows with the new value
                 */
                hWnd = GetDlgItem(hDlg, IDD_COLOR_SCREEN_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, IDD_COLOR_POPUP_COLORS);
                InvalidateRect(hWnd, NULL, FALSE);
                hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
                InvalidateRect(hWnd, NULL, FALSE);
                break;
            }
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    case WM_VSCROLL:
        /*
         * Fake the dialog proc into thinking the edit control just
         * lost focus so it'll update properly
         */
        Item = GetDlgCtrlID((HWND)lParam) - 1;
        SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
        return TRUE;

    case CM_SETCOLOR:
        UpdateStateInfo(hDlg, Index + IDD_COLOR_SCREEN_TEXT, (UINT)wParam);

        hWndOld = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);

        ColorArray[Index] = (BYTE)wParam;

        /* Force the preview window to repaint */

        if (Index < (IDD_COLOR_POPUP_TEXT - IDD_COLOR_SCREEN_TEXT)) {
            hWnd = GetDlgItem(hDlg, IDD_COLOR_SCREEN_COLORS);
        } else {
            hWnd = GetDlgItem(hDlg, IDD_COLOR_POPUP_COLORS);
        }
        InvalidateRect(hWnd, NULL, TRUE);

        // repaint new color
        hWnd = GetDlgItem(hDlg, ColorArray[Index]+IDD_COLOR_1);
        InvalidateRect(hWnd, NULL, TRUE);
        SetFocus(hWnd);

        // repaint old color
        if (hWndOld != hWnd) {
            InvalidateRect(hWndOld, NULL, TRUE);
        }
        return TRUE;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


int
GetStateInfo(
    HWND hDlg,
    UINT Item,
    BOOL *bOK
    )
{
    int Value = 0;

    *bOK = TRUE;
    switch (Item) {
    case IDD_SCRBUF_WIDTH:
        Value = gpStateInfo->ScreenBufferSize.X;
        break;
    case IDD_SCRBUF_HEIGHT:
        Value = gpStateInfo->ScreenBufferSize.Y;
        break;
    case IDD_WINDOW_WIDTH:
        Value = gpStateInfo->WindowSize.X;
        break;
    case IDD_WINDOW_HEIGHT:
        Value = gpStateInfo->WindowSize.Y;
        break;
    case IDD_WINDOW_POSX:
        Value = gpStateInfo->WindowPosX;
        break;
    case IDD_WINDOW_POSY:
        Value = gpStateInfo->WindowPosY;
        break;
    default:
        *bOK = FALSE;
        break;
    }
    return Value;
}


BOOL
UpdateStateInfo(
    HWND hDlg,
    UINT Item,
    int Value
    )
{
    switch (Item) {
    case IDD_SCRBUF_WIDTH:
        gpStateInfo->ScreenBufferSize.X = (SHORT)Value;
        if (gpStateInfo->WindowSize.X > Value) {
            gpStateInfo->WindowSize.X = (SHORT)Value;
            UpdateItem(hDlg, IDD_WINDOW_WIDTH, Value);
        }
        break;
    case IDD_SCRBUF_HEIGHT:
        gpStateInfo->ScreenBufferSize.Y = (SHORT)Value;
        if (gpStateInfo->WindowSize.Y > Value) {
            gpStateInfo->WindowSize.Y = (SHORT)Value;
            UpdateItem(hDlg, IDD_WINDOW_HEIGHT, Value);
        }
        break;
    case IDD_WINDOW_WIDTH:
        gpStateInfo->WindowSize.X = (SHORT)Value;
        if (gpStateInfo->ScreenBufferSize.X < Value) {
            gpStateInfo->ScreenBufferSize.X = (SHORT)Value;
            UpdateItem(hDlg, IDD_SCRBUF_WIDTH, Value);
        }
        break;
    case IDD_WINDOW_HEIGHT:
        gpStateInfo->WindowSize.Y = (SHORT)Value;
        if (gpStateInfo->ScreenBufferSize.Y < Value) {
            gpStateInfo->ScreenBufferSize.Y = (SHORT)Value;
            UpdateItem(hDlg, IDD_SCRBUF_HEIGHT, Value);
        }
        break;
    case IDD_WINDOW_POSX:
        gpStateInfo->WindowPosX = Value;
        break;
    case IDD_WINDOW_POSY:
        gpStateInfo->WindowPosY = Value;
        break;
    case IDD_AUTO_POSITION:
        gpStateInfo->AutoPosition = Value;
        break;
    case IDD_COLOR_SCREEN_TEXT:
        gpStateInfo->ScreenAttributes =
                    (gpStateInfo->ScreenAttributes & 0xF0) |
                    (Value & 0x0F);
        break;
    case IDD_COLOR_SCREEN_BKGND:
        gpStateInfo->ScreenAttributes =
                    (gpStateInfo->ScreenAttributes & 0x0F) |
                    (Value << 4);
        break;
    case IDD_COLOR_POPUP_TEXT:
        gpStateInfo->PopupAttributes =
                    (gpStateInfo->PopupAttributes & 0xF0) |
                    (Value & 0x0F);
        break;
    case IDD_COLOR_POPUP_BKGND:
        gpStateInfo->PopupAttributes =
                    (gpStateInfo->PopupAttributes & 0x0F) |
                    (Value << 4);
        break;
    case IDD_COLOR_1:
    case IDD_COLOR_2:
    case IDD_COLOR_3:
    case IDD_COLOR_4:
    case IDD_COLOR_5:
    case IDD_COLOR_6:
    case IDD_COLOR_7:
    case IDD_COLOR_8:
    case IDD_COLOR_9:
    case IDD_COLOR_10:
    case IDD_COLOR_11:
    case IDD_COLOR_12:
    case IDD_COLOR_13:
    case IDD_COLOR_14:
    case IDD_COLOR_15:
    case IDD_COLOR_16:
        gpStateInfo->ColorTable[Item - IDD_COLOR_1] = Value;
        break;
#ifdef i386
    case IDD_FULLSCREEN:
        gpStateInfo->FullScreen = TRUE;
        break;
    case IDD_WINDOWED:
        gpStateInfo->FullScreen = FALSE;
        break;
#endif
#if defined(FE_SB)
    case IDD_LANGUAGELIST:
        /*
         * Value is a code page
         */
        gpStateInfo->CodePage = Value;
        break;
#endif
    case IDD_QUICKEDIT:
        gpStateInfo->QuickEdit = Value;
        break;
    case IDD_AUTOCOMPLETE:
        g_fAutoComplete = Value;
        g_fSaveAutoCompleteState = TRUE;
        break;
    case IDD_INSERT:
        gpStateInfo->InsertMode = Value;
        break;
    case IDD_HISTORY_SIZE:
        gpStateInfo->HistoryBufferSize = max(Value, 1);
        break;
    case IDD_HISTORY_NUM:
        gpStateInfo->NumberOfHistoryBuffers = max(Value, 1);
        break;
    case IDD_HISTORY_NODUP:
        gpStateInfo->HistoryNoDup = Value;
        break;
    case IDD_CURSOR_SMALL:
        gpStateInfo->CursorSize = 25;
        break;
    case IDD_CURSOR_MEDIUM:
        gpStateInfo->CursorSize = 50;
        break;
    case IDD_CURSOR_LARGE:
        gpStateInfo->CursorSize = 100;
        break;
    default:
        return FALSE;
    }
    return TRUE;
}


VOID
UpdateWarningMessage(
    HWND hDlg,
    BOOL fLoadString
    )
{
    static WCHAR achFormat[256];
    WCHAR achText[NELEM(achFormat)+4];
    HWND hWnd;
    UINT Value;

    /*
     * Load the format string, if requested.
     */
    if (fLoadString) {
        LoadString(ghInstance, IDS_WARNING, achFormat, NELEM(achFormat));
    }

    /*
     * Put up the warning message if we're using more than 1 Meg
     * of memory per console window, otherwise hide it.
     */
    hWnd = GetDlgItem(hDlg, IDD_WARNING);
    Value = (gpStateInfo->ScreenBufferSize.X *
             gpStateInfo->ScreenBufferSize.Y) / 0x080000;
    if (Value) {
        wsprintf(achText, achFormat, Value);
        SetWindowText(hWnd, achText);
        ShowWindow(hWnd, SW_SHOW);
    } else {
        ShowWindow(hWnd, SW_HIDE);
    }
}


INT_PTR
WINAPI
ScreenSizeDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the screen size dialog box.

--*/

{
    UINT Value;
    UINT Item;
    HWND hWnd;
    BOOL bOK;
    LONG xScreen;
    LONG yScreen;
    LONG cxScreen;
    LONG cyScreen;
    LONG cxFrame;
    LONG cyFrame;

    switch (wMsg) {
    case WM_INITDIALOG:
        // initialize size of edit controls

        SendDlgItemMessage(hDlg, IDD_SCRBUF_WIDTH, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_SCRBUF_HEIGHT, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_WIDTH, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_HEIGHT, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSX, EM_LIMITTEXT, 4, 0L);
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSY, EM_LIMITTEXT, 4, 0L);

        // Get some system parameters

        xScreen  = GetSystemMetrics(SM_XVIRTUALSCREEN);
        yScreen  = GetSystemMetrics(SM_YVIRTUALSCREEN);
        cxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        cyScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        cxFrame  = GetSystemMetrics(SM_CXFRAME);
        cyFrame  = GetSystemMetrics(SM_CYFRAME);

        // initialize arrow controls

        SendDlgItemMessage(hDlg, IDD_SCRBUF_WIDTHSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_SCRBUF_WIDTHSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->ScreenBufferSize.X, 0));
        SendDlgItemMessage(hDlg, IDD_SCRBUF_HEIGHTSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_SCRBUF_HEIGHTSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->ScreenBufferSize.Y, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_WIDTHSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_WINDOW_WIDTHSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowSize.X, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_HEIGHTSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(9999, 1));
        SendDlgItemMessage(hDlg, IDD_WINDOW_HEIGHTSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowSize.Y, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSXSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(xScreen + cxScreen - cxFrame, xScreen - cxFrame));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSXSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowPosX, 0));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSYSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(yScreen + cyScreen - cyFrame, yScreen - cyFrame));
        SendDlgItemMessage(hDlg, IDD_WINDOW_POSYSCROLL, UDM_SETPOS, 0,
                           MAKELONG(gpStateInfo->WindowPosY, 0));

        //
        // put current values in dialog box
        //

        CheckDlgButton(hDlg, IDD_AUTO_POSITION, gpStateInfo->AutoPosition);
        SendMessage(hDlg, WM_COMMAND, IDD_AUTO_POSITION, 0);

        // update the warning message

        UpdateWarningMessage(hDlg, TRUE);

        return TRUE;

    case WM_VSCROLL:
        /*
         * Fake the dialog proc into thinking the edit control just
         * lost focus so it'll update properly
         */
        Item = GetDlgCtrlID((HWND)lParam) - 1;
        SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
        return TRUE;

    case WM_COMMAND:
        Item = LOWORD(wParam);
        switch (Item) {
        case IDD_SCRBUF_WIDTH:
        case IDD_SCRBUF_HEIGHT:
        case IDD_WINDOW_WIDTH:
        case IDD_WINDOW_HEIGHT:
        case IDD_WINDOW_POSX:
        case IDD_WINDOW_POSY:
            switch (HIWORD(wParam)) {
            case EN_UPDATE:
                if (!CheckNum (hDlg, Item)) {
                    if (!InEM_UNDO) {
                        InEM_UNDO = TRUE;
                        SendMessage((HWND)lParam, EM_UNDO, 0, 0L);
                        InEM_UNDO = FALSE;
                    }
                }
                break;
            case EN_KILLFOCUS:
                /*
                 * Update the state info structure
                 */
                Value = (UINT)SendDlgItemMessage(hDlg, Item + 1, UDM_GETPOS, 0, 0);
                if (HIWORD(Value) == 0) {
                    UpdateStateInfo(hDlg, Item, (SHORT)LOWORD(Value));
                } else {
                    Value = GetStateInfo(hDlg, Item, &bOK);
                    if (bOK) {
                        UpdateItem(hDlg, Item, Value);
                    }
                }

                /*
                 * Update the warning message
                 */
                 UpdateWarningMessage(hDlg, FALSE);

                /*
                 * Update the preview window with the new value
                 */
                hWnd = GetDlgItem(hDlg, IDD_PREVIEWWINDOW);
                SendMessage(hWnd, CM_PREVIEW_UPDATE, 0, 0);
                break;
            }
            return TRUE;

        case IDD_AUTO_POSITION:
            Value = IsDlgButtonChecked(hDlg, IDD_AUTO_POSITION);
            UpdateStateInfo(hDlg, IDD_AUTO_POSITION, Value);
            for (Item = IDD_WINDOW_POSX; Item < IDD_AUTO_POSITION; Item++) {
                hWnd = GetDlgItem(hDlg, Item);
                EnableWindow(hWnd, (Value == FALSE));
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR
WINAPI
SettingsDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the settings dialog box.

--*/

{
    UINT Value;
    UINT Item;
    BOOL bOK;
    SYSTEM_INFO SystemInfo;

    switch (wMsg) {
    case WM_INITDIALOG:
        GetSystemInfo(&SystemInfo);
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
            if (gpStateInfo->FullScreen) {
                CheckRadioButton(hDlg,IDD_WINDOWED,IDD_FULLSCREEN,IDD_FULLSCREEN);
            } else {
                CheckRadioButton(hDlg,IDD_WINDOWED,IDD_FULLSCREEN,IDD_WINDOWED);
            }
        } else {
            ShowWindow(GetDlgItem(hDlg, IDD_WINDOWED), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_FULLSCREEN), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_DISPLAY_GROUPBOX), SW_HIDE);
        }

        CheckDlgButton(hDlg, IDD_HISTORY_NODUP, gpStateInfo->HistoryNoDup);
        CheckDlgButton(hDlg, IDD_QUICKEDIT, gpStateInfo->QuickEdit);
        CheckDlgButton(hDlg, IDD_INSERT, gpStateInfo->InsertMode);

        g_fSaveAutoCompleteState = FALSE;
        if (IsWindow(GetDlgItem(hDlg, IDD_AUTOCOMPLETE)))
        {
            CheckDlgButton(hDlg, IDD_AUTOCOMPLETE, g_fAutoComplete);
        }

        // initialize cursor radio buttons

        if (gpStateInfo->CursorSize <= 25) {
            Item = IDD_CURSOR_SMALL;
        } else if (gpStateInfo->CursorSize <= 50) {
            Item = IDD_CURSOR_MEDIUM;
        } else {
            Item = IDD_CURSOR_LARGE;
        }
        CheckRadioButton(hDlg, IDD_CURSOR_SMALL, IDD_CURSOR_LARGE, Item);

        SetDlgItemInt(hDlg, IDD_HISTORY_SIZE, gpStateInfo->HistoryBufferSize,
                      FALSE);
        SendDlgItemMessage(hDlg, IDD_HISTORY_SIZE, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_HISTORY_SIZESCROLL, UDM_SETRANGE, 0,
                           MAKELONG(999, 1));

        SetDlgItemInt(hDlg, IDD_HISTORY_NUM, gpStateInfo->NumberOfHistoryBuffers,
                      FALSE);
        SendDlgItemMessage(hDlg, IDD_HISTORY_NUM, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, IDD_HISTORY_NUM, EM_SETSEL, 0, (DWORD)-1);
        SendDlgItemMessage(hDlg, IDD_HISTORY_NUMSCROLL, UDM_SETRANGE, 0,
                           MAKELONG(999, 1));

        // FE_SB
        // Let users select Default CodePage.
        // Per request from PMs, this feature should be activated only for FE enabled NT.
        if (gfFESystem) {
            if (gpStateInfo->hWnd != NULL) {
                LanguageDisplay(hDlg, gpStateInfo->CodePage);
            }
            else{
                LanguageListCreate(hDlg, gpStateInfo->CodePage);
            }
        }
        else {
            // If the system is not FE enabled, just disable and hide them.
            EnableWindow(GetDlgItem(hDlg,IDD_LANGUAGELIST), FALSE);
            ShowWindow(GetDlgItem(hDlg, IDD_LANGUAGELIST), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_LANGUAGE_GROUPBOX), SW_HIDE);
        }
        // end FE_SB
        return TRUE;

    case WM_COMMAND:
        Item = LOWORD(wParam);
        switch (Item) {
#ifdef i386
        case IDD_WINDOWED:
        case IDD_FULLSCREEN:
            UpdateStateInfo(hDlg, Item, 0);
            return TRUE;
#endif
        // FE_SB
        case IDD_LANGUAGELIST:
            switch (HIWORD(wParam)) {
            case CBN_KILLFOCUS: {
                HWND hWndLanguageCombo;
                LONG lListIndex;

                hWndLanguageCombo = GetDlgItem(hDlg, IDD_LANGUAGELIST);
                lListIndex = (LONG)SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
                Value = (UINT)SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
                if (Value != -1) {
                    fChangeCodePage = (Value != gpStateInfo->CodePage);
                    UpdateStateInfo(hDlg, Item, Value);
                }
                break;
            }

            default:
                DBGFONTS(("unhandled CBN_%x from POINTSLIST\n",HIWORD(wParam)));
                break;
            }
            return TRUE;
        // end FE_SB
        case IDD_CURSOR_SMALL:
        case IDD_CURSOR_MEDIUM:
        case IDD_CURSOR_LARGE:
            UpdateStateInfo(hDlg, Item, 0);
            return TRUE;

        case IDD_HISTORY_NODUP:
        case IDD_AUTOCOMPLETE:
        case IDD_QUICKEDIT:
        case IDD_INSERT:
            Value = IsDlgButtonChecked(hDlg, Item);
            UpdateStateInfo(hDlg, Item, Value);
            return TRUE;

        case IDD_HISTORY_SIZE:
        case IDD_HISTORY_NUM:
            switch (HIWORD(wParam)) {
            case EN_UPDATE:
                if (!CheckNum(hDlg, Item)) {
                    if (!InEM_UNDO) {
                        InEM_UNDO = TRUE;
                        SendMessage((HWND)lParam, EM_UNDO, 0, 0L);
                        InEM_UNDO = FALSE;
                    }
                }
                break;

            case EN_KILLFOCUS:
                /*
                 * Update the state info structure
                 */
                Value = GetDlgItemInt(hDlg, Item, &bOK, TRUE);
                if (bOK) {
                    UpdateStateInfo(hDlg, Item, Value);
                }
                break;
            }
            return TRUE;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
            /*
             * Fake the dialog proc into thinking the edit control just
             * lost focus so it'll update properly
             */
            if (Item = GetDlgCtrlID(GetFocus())) {
                SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
            }
            return TRUE;
        }
        break;

    case WM_VSCROLL:
        /*
         * Fake the dialog proc into thinking the edit control just
         * lost focus so it'll update properly
         */
        Item = GetDlgCtrlID((HWND)lParam) - 1;
        SendMessage(hDlg, WM_COMMAND, MAKELONG(Item, EN_KILLFOCUS), 0);
        return TRUE;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR
ConsolePropertySheet(
    IN HWND hWnd
    )

/*++

    Creates the property sheet to change console settings.

--*/

{
    PROPSHEETPAGE psp[4];
    PROPSHEETHEADER psh;
    INT_PTR Result = IDCANCEL;
    WCHAR awchBuffer[MAX_PATH];

    //
    // Initialize the state information
    //

    gpStateInfo = InitStateValues((HANDLE)hWnd);
    if (gpStateInfo == NULL) {
        KdPrint(("CONSOLE: can't get state information\n"));
        return IDCANCEL;
    }

    //
    // Initialize the font cache and current font index
    //

    InitializeFonts();
    CurrentFontIndex = FindCreateFont(gpStateInfo->FontFamily,
                                      gpStateInfo->FaceName,
                                      gpStateInfo->FontSize,
                                      gpStateInfo->FontWeight,
                                      gpStateInfo->CodePage);

    //
    // Get the current page number
    //

    gnCurrentPage = GetRegistryValues(NULL);

    //
    // Initialize the property sheet structures
    //

    RtlZeroMemory(psp, sizeof(psp));

    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].hInstance   = ghInstance;
#if defined(FE_SB) // v-HirShi Nov.20.1996
    if (gpStateInfo->hWnd != NULL) {
        psp[0].pszTemplate = MAKEINTRESOURCE(DID_SETTINGS2);
    }
    else{
        psp[0].pszTemplate = MAKEINTRESOURCE(DID_SETTINGS);
    }
#else
    psp[0].pszTemplate = MAKEINTRESOURCE(DID_SETTINGS);
#endif
    psp[0].pfnDlgProc  = SettingsDlgProc;
    psp[0].lParam      = 0;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].hInstance   = ghInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(DID_FONTDLG);
    psp[1].pfnDlgProc  = FontDlgProc;
    psp[1].lParam      = 1;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].hInstance   = ghInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(DID_SCRBUFSIZE);
    psp[2].pfnDlgProc  = ScreenSizeDlgProc;
    psp[2].lParam      = 2;

    psp[3].dwSize      = sizeof(PROPSHEETPAGE);
    psp[3].hInstance   = ghInstance;
    psp[3].pszTemplate = MAKEINTRESOURCE(DID_COLOR);
    psp[3].pfnDlgProc  = ColorDlgProc;
    psp[3].lParam      = 3;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPTITLE | PSH_USEICONID | PSH_PROPSHEETPAGE |
                  PSH_NOAPPLYNOW | PSH_USECALLBACK;
    if (gpStateInfo->hWnd) {
        psh.hwndParent = gpStateInfo->hWnd;
    } else {
        psh.hwndParent = hWnd;
    }
    psh.hInstance = ghInstance;
    psh.pszIcon = MAKEINTRESOURCE(IDI_CONSOLE);
    if (gpStateInfo->ConsoleTitle[0] != TEXT('\0')) {
        wcscpy(awchBuffer, TEXT("\""));
        ExpandEnvironmentStrings(gpStateInfo->ConsoleTitle, &awchBuffer[1], NELEM(awchBuffer) - 2);
        wcscat(awchBuffer, TEXT("\""));
        gbStartedFromLink = WereWeStartedFromALnk();
    } else {
        LoadString(ghInstance, IDS_TITLE, awchBuffer, NELEM(awchBuffer));
        gbStartedFromLink = FALSE;
    }
    psh.pszCaption = awchBuffer;
    psh.nPages = NELEM(psp);
    psh.nStartPage = min(gnCurrentPage, NELEM(psp));
    psh.ppsp = psp;
    psh.pfnCallback = ConsolePropSheetProc;

    //
    // Create the property sheet
    //

    Result = PropertySheet(&psh);

    //
    // Send the state values to the console server
    //

    if (gbWriteToConsole) {
        WriteStateValues(gpStateInfo);
    }

    //
    // Save our changes to the registry
    //

    if (gbSaveToRegistry) {

        //
        // If we're looking at the default font, clear the values
        // before we save them
        //

        if ((gpStateInfo->FontFamily == DefaultFontFamily) &&
            (gpStateInfo->FontSize.X == DefaultFontSize.X) &&
            (gpStateInfo->FontSize.Y == DefaultFontSize.Y) &&
            (gpStateInfo->FontWeight == FW_NORMAL) &&
            (wcscmp(gpStateInfo->FaceName, DefaultFaceName) == 0)) {

            gpStateInfo->FontFamily = 0;
            gpStateInfo->FontSize.X = 0;
            gpStateInfo->FontSize.Y = 0;
            gpStateInfo->FontWeight = 0;
            gpStateInfo->FaceName[0] = TEXT('\0');
        }
        if (gbStartedFromLink) {

            if (!SetLinkValues( gpStateInfo )) {

                WCHAR szMessage[ MAX_PATH + 100 ];
                STARTUPINFOW si;
                HWND hwndTemp;

                // An error occured try to save the link file,
                // display a message box to that effect...

                GetStartupInfoW( &si );
                LoadStringW(ghInstance, IDS_LINKERROR, awchBuffer, NELEM(awchBuffer));
                wsprintfW( szMessage,
                           awchBuffer,
                           si.lpTitle
                          );
                LoadStringW(ghInstance, IDS_LINKERRCAP, awchBuffer, NELEM(awchBuffer));
                if (gpStateInfo->hWnd) {
                    hwndTemp = gpStateInfo->hWnd;
                } else {
                    hwndTemp = hWnd;
                }
                MessageBoxW( hwndTemp,
                             szMessage,
                             awchBuffer,
                             MB_APPLMODAL | MB_OK | MB_ICONSTOP | MB_SETFOREGROUND
                            );

            }

        } else {
            SetRegistryValues(gpStateInfo, gnCurrentPage);
        }
    } else {
        SetRegistryValues(NULL, gnCurrentPage);
    }

    //
    // Tell the console server that we're done
    //

    if (gpStateInfo->hWnd) {
        SendMessage(gpStateInfo->hWnd, CM_PROPERTIES_END, 0, 0);
    }

    //
    // Free the state information
    //

    HeapFree(RtlProcessHeap(), 0, gpStateInfo);

    //
    // Destroy the font cache
    //

    DestroyFonts();

    return Result;
}


BOOL
RegisterClasses(HANDLE hModule)
{
    WNDCLASS wc;

    wc.lpszClassName = TEXT("cpColor");
    wc.hInstance     = hModule;
    wc.lpfnWndProc   = ColorControlProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    wc.lpszClassName = TEXT("WOAWinPreview");
    wc.lpfnWndProc   = PreviewWndProc;
    wc.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    wc.style         = 0L;
    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    wc.lpszClassName = TEXT("WOAFontPreview");
    wc.lpfnWndProc   = FontPreviewWndProc;
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.style         = 0L;
    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    return TRUE;
}

void
UnregisterClasses(HANDLE hModule)
{
    UnregisterClass(TEXT("cpColor"),        hModule);
    UnregisterClass(TEXT("WOAWinPreview"),  hModule);
    UnregisterClass(TEXT("WOAFontPreview"), hModule);
}


PCONSOLE_STATE_INFO
ReadStateValues(HANDLE hMap)
{
    PCONSOLE_STATE_INFO pConsoleInfo;
    PCONSOLE_STATE_INFO pStateInfo;

    /*
     * Map the shared memory block into our address space.
     */
    pConsoleInfo = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (pConsoleInfo == NULL) {
        return NULL;
    }

    /*
     * Copy the data into a locally allocated buffer.
     */
    pStateInfo = HeapAlloc(RtlProcessHeap(), 0, pConsoleInfo->Length);
    if (pStateInfo) {
        RtlCopyMemory(pStateInfo, pConsoleInfo, pConsoleInfo->Length);
    }

    /*
     * Close any open handles.
     */
    UnmapViewOfFile(pConsoleInfo);
    CloseHandle(hMap);

    return pStateInfo;
}


BOOL
WriteStateValues(PCONSOLE_STATE_INFO pStateInfo)
{
    HANDLE hMap;
    PCONSOLE_STATE_INFO pConsoleInfo;

    /*
     * Make sure we have a console window to notify.
     */
    if (pStateInfo->hWnd == NULL) {
        return FALSE;
    }

    /*
     * Create the shared memory block which will contain the state info.
     */
    hMap = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0,
                             pStateInfo->Length, NULL);
    if (!hMap) {
        KdPrint(("CONSOLE: error %d creating file mapping\n", GetLastError()));
        return FALSE;
    }

    /*
     * Map the shared memory block into our address space and copy the
     * data into it.
     */
    pConsoleInfo = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (!pConsoleInfo) {
        KdPrint(("CONSOLE: error %d mapping view of file\n", GetLastError()));
        CloseHandle(hMap);
        return FALSE;
    }

    RtlCopyMemory(pConsoleInfo, pStateInfo, pStateInfo->Length);
    UnmapViewOfFile(pConsoleInfo);

    /*
     * Send a message to the server window telling him to read the data
     * and then close any open handles.
     */
    SendMessage(pStateInfo->hWnd, CM_PROPERTIES_UPDATE, (WPARAM)hMap, 0);

    CloseHandle(hMap);

    return TRUE;
}


PCONSOLE_STATE_INFO
InitStateValues(HANDLE hMap)
{
    PCONSOLE_STATE_INFO pStateInfo;

    /*
     * Try to open the shared memory block and read the state info
     * into our address space.
     */
    pStateInfo = ReadStateValues(hMap);
    if (pStateInfo != NULL) {
        return pStateInfo;
    }

    /*
     * Couldn't read the shared memory block so allocate and fill
     * in default values in structure.
     */
    pStateInfo = InitRegistryValues();
    if (pStateInfo == NULL) {
        return NULL;
    }

    /*
     * Now overwrite default values with values from registry
     */
    GetRegistryValues(pStateInfo);

    return pStateInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\font.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    font.h

Abstract:

    This module contains the data structures, data types,
    and procedures related to fonts.

Author:

    Therese Stowell (thereses) 15-Jan-1991

Revision History:

--*/

#ifndef FONT_H
#define FONT_H

#define INITIAL_FONTS 20
#define FONT_INCREMENT 3
#define CONSOLE_MAX_FONT_NAME_LENGTH 256

#define EF_NEW         0x0001 // a newly available face
#define EF_OLD         0x0002 // a previously available face
#define EF_ENUMERATED  0x0004 // all sizes have been enumerated
#define EF_OEMFONT     0x0008 // an OEM face
#define EF_TTFONT      0x0010 // a TT face
#define EF_DEFFACE     0x0020 // the default face
#if defined(FE_SB)
#define EF_DBCSFONT    0x0040 // the DBCS font
#endif

/*
 * FONT_INFO
 *
 * The distinction between the desired and actual font dimensions obtained
 * is important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Desired" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The SizeDesired is {0, 0} if the font is a raster font.
 */
typedef struct _FONT_INFO {
    HFONT hFont;
    COORD Size;      // font size obtained
    COORD SizeWant;  // 0;0 if Raster font
    LONG  Weight;
    LPTSTR FaceName;
    BYTE  Family;
#if defined(FE_SB)
    BYTE  tmCharSet;
#endif
} FONT_INFO, *PFONT_INFO;

typedef struct tagFACENODE {
     struct tagFACENODE *pNext;
     DWORD  dwFlag;
     TCHAR  atch[];
} FACENODE, *PFACENODE;

#define TM_IS_TT_FONT(x)     (((x) & TMPF_TRUETYPE) == TMPF_TRUETYPE)
#define IS_BOLD(w)           ((w) >= FW_SEMIBOLD)
#define SIZE_EQUAL(s1, s2)   (((s1).X == (s2).X) && ((s1).Y == (s2).Y))
#define POINTS_PER_INCH 72
#define MIN_PIXEL_HEIGHT 5
#define MAX_PIXEL_HEIGHT 72


//
// Function prototypes
//

VOID
InitializeFonts(VOID);

VOID
DestroyFonts(VOID);

NTSTATUS
EnumerateFonts(DWORD Flags);

#if !defined(FE_SB)
int
FindCreateFont(
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight);
#else
int
FindCreateFont(
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight,
    UINT CodePage);
#endif

BOOL
DoFontEnum(
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints);

#endif /* !FONT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\console.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    console.h

Abstract:

    This module contains the definitions for the console applet

Author:

    Jerry Shea (jerrysh) Feb-3-1992

Revision History:

--*/

#include "font.h"
#include "doshelp.h"


//
// Icon ID
//

#define IDI_CONSOLE                   1


//
// String table constants
//

#define IDS_NAME                      1
#define IDS_INFO                      2
#define IDS_TITLE                     3
#define IDS_RASTERFONT                4
#define IDS_FONTSIZE                  5
#define IDS_SELECTEDFONT              6
#define IDS_SAVE                      7
#define IDS_LINKERRCAP                8
#define IDS_LINKERROR                 9
#define IDS_WARNING                  10


//
// Global Variables
//

extern HINSTANCE  ghInstance;
extern PCONSOLE_STATE_INFO gpStateInfo;
extern PFONT_INFO FontInfo;
extern ULONG      NumberOfFonts;
extern ULONG      CurrentFontIndex;
extern ULONG      DefaultFontIndex;
extern TCHAR      DefaultFaceName[];
extern COORD      DefaultFontSize;
extern BYTE       DefaultFontFamily;
extern TCHAR      szPreviewText[];
extern PFACENODE  gpFaceNames;
extern BOOL       gbEnumerateFaces;
extern LONG       gcxScreen;
extern LONG       gcyScreen;

#if defined(FE_SB)
extern UINT OEMCP;
extern BOOL gfFESystem;
extern BOOL fChangeCodePage;


NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName
    );

NTSTATUS
InitializeDbcsMisc(
    VOID
    );

BYTE
CodePageToCharSet(
    UINT CodePage
    );

LPTTFONTLIST
SearchTTFont(
    LPTSTR ptszFace,
    BOOL   fCodePage,
    UINT   CodePage
    );

BOOL
IsAvailableTTFont(
    LPTSTR ptszFace
    );

BOOL
IsAvailableTTFontCP(
    LPWSTR pwszFace,
    UINT CodePage
    );

BOOL
IsDisableBoldTTFont(
    LPTSTR ptszFace
    );

LPTSTR
GetAltFaceName(
    LPTSTR ptszFace
    );

NTSTATUS
DestroyDbcsMisc(
    VOID
    );

int
LanguageListCreate(
    HWND hDlg,
    UINT CodePage
    );

int
LanguageDisplay(
    HWND hDlg,
    UINT CodePage
    ) ;

//
// registry.c
//
NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    );

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    );
#endif

//
// Function prototypes
//

INT_PTR ConsolePropertySheet(HWND hWnd);
BOOL    RegisterClasses(HANDLE hModule);
void    UnregisterClasses(HANDLE hModule);
INT_PTR FontDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
PCONSOLE_STATE_INFO InitRegistryValues(VOID);
DWORD   GetRegistryValues(PCONSOLE_STATE_INFO StateInfo);
VOID    SetRegistryValues(PCONSOLE_STATE_INFO StateInfo, DWORD dwPage);
PCONSOLE_STATE_INFO InitStateValues(HANDLE hMap);
PCONSOLE_STATE_INFO ReadStateValues(HANDLE hMap);
BOOL    WriteStateValues(PCONSOLE_STATE_INFO pStateInfo);
LRESULT ColorControlProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
LRESULT FontPreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
LRESULT PreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CommonDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
VOID    EndDlgPage(HWND hDlg);
BOOL    UpdateStateInfo(HWND hDlg, UINT Item, int Value);
BOOL    WereWeStartedFromALnk();
BOOL    SetLinkValues( PCONSOLE_STATE_INFO StateInfo );

//
// Macros
//

#define NELEM(array) (sizeof(array)/sizeof(array[0]))
#define AttrToRGB(Attr) (gpStateInfo->ColorTable[(Attr) & 0x0F])
#define ScreenTextColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->ScreenAttributes) & 0x0F))
#define ScreenBkColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->ScreenAttributes >> 4)))
#define PopupTextColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->PopupAttributes) & 0x0F))
#define PopupBkColor(pStateInfo) \
            (AttrToRGB(LOBYTE(pStateInfo->PopupAttributes >> 4)))

#ifdef DEBUG_PRINT
  #define _DBGFONTS  0x00000001
  #define _DBGFONTS2 0x00000002
  #define _DBGCHARS  0x00000004
  #define _DBGOUTPUT 0x00000008
  #define _DBGALL    0xFFFFFFFF
  extern ULONG gDebugFlag;

  #define DBGFONTS(_params_)  {if (gDebugFlag & _DBGFONTS) DbgPrint _params_ ; }
  #define DBGFONTS2(_params_) {if (gDebugFlag & _DBGFONTS2)DbgPrint _params_ ; }
  #define DBGCHARS(_params_)  {if (gDebugFlag & _DBGCHARS) DbgPrint _params_ ; }
  #define DBGOUTPUT(_params_) {if (gDebugFlag & _DBGOUTPUT)DbgPrint _params_ ; }
  #define DBGPRINT(_params_)  DbgPrint _params_
#else
  #define DBGFONTS(_params_)
  #define DBGFONTS2(_params_)
  #define DBGCHARS(_params_)
  #define DBGOUTPUT(_params_)
  #define DBGPRINT(_params_)
#endif

#ifdef FE_SB
// Macro definitions that handle codepages
//
#define CP_US       (UINT)437
#define CP_JPN      (UINT)932
#define CP_WANSUNG  (UINT)949
#define CP_TC       (UINT)950
#define CP_SC       (UINT)936

#define IsBilingualCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG)
#define IsFarEastCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG || (cp)==CP_TC || (cp)==CP_SC)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\dialogs.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dialogs.h

Abstract:

    This module contains the definitions for the console dialog boxes

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#define DID_SETTINGS                100
#define IDD_WINDOWED                101
#define IDD_FULLSCREEN              102
#define IDD_QUICKEDIT               103
#define IDD_INSERT                  104
#define IDD_CURSOR_SMALL            105
#define IDD_CURSOR_MEDIUM           106
#define IDD_CURSOR_LARGE            107
#define IDD_HISTORY_SIZE            108
#define IDD_HISTORY_SIZESCROLL      109
#define IDD_HISTORY_NUM             110
#define IDD_HISTORY_NUMSCROLL       111
#define IDD_HISTORY_NODUP           112
#if defined(FE_SB)
#define IDD_LANGUAGELIST            113
// v-HirShi Nov.2.1996
#define DID_SETTINGS2               114
#define IDD_LANGUAGE                115
#define IDD_LANGUAGE_GROUPBOX       116
#endif
#define IDD_DISPLAY_GROUPBOX        117
#define IDD_AUTOCOMPLETE            118

#define DID_FONTDLG                 200
#define IDD_STATIC                  201
#define IDD_FACENAME                202
#define IDD_BOLDFONT                203
#define IDD_STATIC2                 204
#define IDD_PREVIEWLABEL            206
#define IDD_GROUP                   207
#define IDD_STATIC3                 208
#define IDD_STATIC4                 209
#define IDD_FONTWIDTH               210
#define IDD_FONTHEIGHT              211
#define IDD_FONTSIZE                212
#define IDD_POINTSLIST              213
#define IDD_PIXELSLIST              214
#define IDD_PREVIEWWINDOW           215
#define IDD_FONTWINDOW              216

#define DID_SCRBUFSIZE              300
#define IDD_SCRBUF_WIDTH            301
#define IDD_SCRBUF_WIDTHSCROLL      302
#define IDD_SCRBUF_HEIGHT           303
#define IDD_SCRBUF_HEIGHTSCROLL     304
#define IDD_WINDOW_WIDTH            305
#define IDD_WINDOW_WIDTHSCROLL      306
#define IDD_WINDOW_HEIGHT           307
#define IDD_WINDOW_HEIGHTSCROLL     308
#define IDD_WINDOW_POSX             309
#define IDD_WINDOW_POSXSCROLL       310
#define IDD_WINDOW_POSY             311
#define IDD_WINDOW_POSYSCROLL       312
#define IDD_AUTO_POSITION           313
#define IDD_WARNING                 314

#define DID_COLOR                   400
#define IDD_COLOR_SCREEN_TEXT       401
#define IDD_COLOR_SCREEN_BKGND      402
#define IDD_COLOR_POPUP_TEXT        403
#define IDD_COLOR_POPUP_BKGND       404
#define IDD_COLOR_1                 405
#define IDD_COLOR_2                 406
#define IDD_COLOR_3                 407
#define IDD_COLOR_4                 408
#define IDD_COLOR_5                 409
#define IDD_COLOR_6                 410
#define IDD_COLOR_7                 411
#define IDD_COLOR_8                 412
#define IDD_COLOR_9                 413
#define IDD_COLOR_10                414
#define IDD_COLOR_11                415
#define IDD_COLOR_12                416
#define IDD_COLOR_13                417
#define IDD_COLOR_14                418
#define IDD_COLOR_15                419
#define IDD_COLOR_16                420
#define IDD_COLOR_SCREEN_COLORS     421
#define IDD_COLOR_POPUP_COLORS      422
#define IDD_COLOR_RED               423
#define IDD_COLOR_REDSCROLL         424
#define IDD_COLOR_GREEN             425
#define IDD_COLOR_GREENSCROLL       426
#define IDD_COLOR_BLUE              427
#define IDD_COLOR_BLUESCROLL        428

#define DID_SAVE_QUERY              500
#define DID_SAVE_QUERY_LINK         501
#define IDD_APPLY                   502
#define IDD_SAVE                    503
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\dbcs.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

    This module contains the code for console DBCS font dialog

Author:

    kazum Feb-27-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)

SINGLE_LIST_ENTRY gTTFontList;    // This list contain TTFONTLIST data.


UINT OEMCP;
BOOL gfFESystem;


WORD
ConvertStringToDec(
    LPTSTR lpch,
    LPTSTR *endptr
    )
{
    TCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != TEXT('\0'))
    {
        if (TEXT('0') <= ch && ch <= TEXT('9'))
            val = (val * 10) + (ch - TEXT('0'));
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

WORD
ConvertStringToHex(
    LPTSTR lpch,
    LPTSTR *endptr
    )
{
    TCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != TEXT('\0'))
    {
        if (TEXT('0') <= ch && ch <= TEXT('9'))
            val = (val << 4) + (ch - TEXT('0'));
        else if (TEXT('A') <= ch && ch <= TEXT('F'))
            val = (val << 4) + (ch - TEXT('A') + 10);
        else if (TEXT('a') <= ch && ch <= TEXT('f'))
            val = (val << 4) + (ch - TEXT('a') + 10);
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}


NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPTSTR AltFaceName
    )
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    COORD FontSize = FontInfo[DefaultFontIndex].Size;
    COORD FontDelta;
    BOOL  fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i=0; i < NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet) == fDbcsCharSet
           )
        {
            FontDelta.X = (SHORT)abs(FontSize.X - FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    _tcscpy(AltFaceName, FontInfo[*AltFontIndex].FaceName);
    *AltFontSize = FontInfo[*AltFontIndex].Size;
    *AltFontFamily = FontInfo[*AltFontIndex].Family;

    DBGFONTS(("MakeAltRasterFont : AltFontIndex = %ld\n", *AltFontIndex));

    return STATUS_SUCCESS;
}

NTSTATUS
InitializeDbcsMisc(
    VOID
    )
{
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    LPWSTR pwsz;

    gTTFontList.Next = NULL;

    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_TTFONT,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE));
    }
    else {
        LPTTFONTLIST pTTFontList;

        for( dwIndex = 0; ; dwIndex++) {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status )) {
                break;
            }

            pTTFontList = LocalAlloc(LPTR, sizeof(TTFONTLIST));
            if (pTTFontList == NULL) {
                break;
            }

            pTTFontList->List.Next = NULL;
            pTTFontList->CodePage = ConvertStringToDec(awchValue, NULL);
            pwsz = awchData;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            else
                pTTFontList->fDisableBold = FALSE;
            _tcscpy(pTTFontList->FaceName1, pwsz);

            pwsz += _tcslen(pwsz) + 1;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            _tcscpy(pTTFontList->FaceName2, pwsz);

            PushEntryList(&gTTFontList, &(pTTFontList->List));
        }

        NtClose(hkRegistry);
    }

    ASSERT(OEMCP != 0); // OEMCP must be initialized so far by CPL_INIT
    ASSERT(IsFarEastCP(OEMCP) == gfFESystem);

    return STATUS_SUCCESS;
}

BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo((DWORD *)IntToPtr(CodePage), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = OEM_CHARSET;

    return (BYTE)csi.ciCharset;
}

LPTTFONTLIST
SearchTTFont(
    LPTSTR ptszFace,
    BOOL   fCodePage,
    UINT   CodePage
    )
{
    PSINGLE_LIST_ENTRY pTemp = gTTFontList.Next;

    if (ptszFace) {
        while (pTemp != NULL) {
            LPTTFONTLIST pTTFontList = (LPTTFONTLIST)pTemp;

            if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(ptszFace, pTTFontList->FaceName2) == 0    ) {
                if (fCodePage)
                    if (pTTFontList->CodePage == CodePage )
                        return pTTFontList;
                    else
                        return NULL;
                else
                    return pTTFontList;
            }

            pTemp = pTemp->Next;
        }
    }

    return NULL;
}

BOOL
IsAvailableTTFont(
    LPTSTR ptszFace
    )
{
    if (SearchTTFont(ptszFace, FALSE, 0))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsAvailableTTFontCP(
    LPTSTR ptszFace,
    UINT CodePage
    )
{
    if (SearchTTFont(ptszFace, TRUE, CodePage))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsDisableBoldTTFont(
    LPTSTR ptszFace
    )
{
    LPTTFONTLIST pTTFontList;

    pTTFontList = SearchTTFont(ptszFace, FALSE, 0);
    if (pTTFontList != NULL)
        return pTTFontList->fDisableBold;
    else
        return FALSE;
}

LPTSTR
GetAltFaceName(
    LPTSTR ptszFace
    )
{
    LPTTFONTLIST pTTFontList;

    pTTFontList = SearchTTFont(ptszFace, FALSE, 0);
    if (pTTFontList != NULL) {
        if (wcscmp(ptszFace, pTTFontList->FaceName1) == 0) {
            return pTTFontList->FaceName2;
        }
        if (wcscmp(ptszFace, pTTFontList->FaceName2) == 0) {
            return pTTFontList->FaceName1;
        }
        return NULL;
    }
    else
        return NULL;
}

NTSTATUS
DestroyDbcsMisc(
    VOID
    )
{
    while (gTTFontList.Next != NULL) {
        LPTTFONTLIST pTTFontList = (LPTTFONTLIST)PopEntryList(&gTTFontList);

        if (pTTFontList != NULL)
            LocalFree(pTTFontList);
    }

    return STATUS_SUCCESS;
}

typedef struct _LC_List {
    struct _LC_List* Next;
    BOOL   FindFlag;
    TCHAR  LC_String[9];
} LC_List, *PLC_List;

static PLC_List LocaleList = NULL;

BOOL CALLBACK
EnumProc(
    LPTSTR LC_String
    )
{
    PLC_List TmpList;

    if (_tcslen(LC_String) <= (sizeof(LocaleList->LC_String)/sizeof(TCHAR))-1)
    {
        TmpList = (PLC_List)&LocaleList;

        while(TmpList->Next != NULL)
            TmpList = TmpList->Next;

        TmpList->Next = LocalAlloc(LPTR, sizeof(LC_List));
        if (TmpList->Next != NULL)
        {
            TmpList = TmpList->Next;
            _tcscpy(TmpList->LC_String, LC_String);
        }
    }
    return TRUE;
}


int
LanguageListCreate(
    HWND hDlg,
    UINT CodePage
    )

/*++

    Initializes the Language list by enumerating all Locale Information.

    Returns
--*/

{
    HWND hWndLanguageCombo;
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    PLC_List TmpList;
    WORD LangID;
    LCID Locale;
    int  cchData;
    LONG lListIndex;
    UINT cp;
    BOOL fRet;
    CPINFOEX cpinfo;

    /*
     * Enumrate system locale information
     */
    EnumSystemLocales( EnumProc, CP_INSTALLED );

    /*
     * Enumrate registory key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_NLS,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE));
    }
    else {
        for( dwIndex = 0; ; dwIndex++)
        {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status ))
            {
                break;
            }

            TmpList = (PLC_List)&LocaleList;
            while(TmpList->Next != NULL)
            {
                TmpList = TmpList->Next;
                if (_tcscmp(awchValue, TmpList->LC_String) == 0)
                {
                    TmpList->FindFlag = TRUE;
                    break;
                }
            }
        }

        NtClose(hkRegistry);

    }

    /*
     * Create ComboBox items
     */
    hWndLanguageCombo = GetDlgItem(hDlg, IDD_LANGUAGELIST);
    SendMessage(hWndLanguageCombo, CB_RESETCONTENT, 0, 0L);

    TmpList = (PLC_List)&LocaleList;
    while(TmpList->Next != NULL)
    {
        TmpList = TmpList->Next;

        if (TmpList->FindFlag)
        {
            LangID = ConvertStringToHex(TmpList->LC_String, NULL);
            Locale = MAKELCID( LangID, SORT_DEFAULT );

            cchData = GetLocaleInfo(Locale, LOCALE_IDEFAULTCODEPAGE,
                                    awchData, sizeof(awchData)/sizeof(TCHAR));
            if (cchData)
            {
                awchData[cchData] = TEXT('\0');
                cp = ConvertStringToDec(awchData, NULL);

                if ( (IS_ANY_DBCS_CHARSET(CodePageToCharSet(cp)) && GetOEMCP() == cp) ||
                     (!IS_ANY_DBCS_CHARSET(CodePageToCharSet(cp))) ) {

                    fRet = GetCPInfoEx(cp, 0, &cpinfo);
                    if (fRet) {
                        lListIndex = (LONG)SendMessage(hWndLanguageCombo, CB_ADDSTRING, 0, (LPARAM)cpinfo.CodePageName);
                        SendMessage(hWndLanguageCombo, CB_SETITEMDATA, (DWORD)lListIndex, cp);

                        if (CodePage == cp) {
                            SendMessage(hWndLanguageCombo, CB_SETCURSEL, lListIndex, 0L);
                        }
                    }
                }
            }
        }
    }

    {
        PLC_List Tmp;

        TmpList = (PLC_List)&LocaleList;
        while(TmpList->Next != NULL)
        {
            Tmp = TmpList;
            TmpList = TmpList->Next;

            if (Tmp != (PLC_List)&LocaleList)
                LocalFree(Tmp);
        }

        LocaleList = NULL;
    }


    /*
     * Get the LocaleIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = (LONG)SendMessage(hWndLanguageCombo, CB_GETCURSEL, 0, 0L);
    return (LONG)SendMessage(hWndLanguageCombo, CB_GETITEMDATA, lListIndex, 0L);
}


// v-HirShi Nov.20.1996
int
LanguageDisplay(
    HWND hDlg,
    UINT CodePage
    )

/*++

    Display the Language .

    Returns
--*/

{
    HWND hWndLanguageDisp;
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    DWORD dwIndex;
    PLC_List TmpList;
    WORD LangID;
    LCID Locale;
    int  cchData;
    LONG lListIndex;
    UINT cp;
    BOOL fRet;
    CPINFOEX cpinfo;

    /*
     * Enumrate system locale information
     */
    EnumSystemLocales( EnumProc, CP_INSTALLED );

    /*
     * Enumrate registory key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_NLS,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE));
    }
    else {
        for( dwIndex = 0; ; dwIndex++)
        {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status ))
            {
                break;
            }

            TmpList = (PLC_List)&LocaleList;
            while(TmpList->Next != NULL)
            {
                TmpList = TmpList->Next;
                if (_tcscmp(awchValue, TmpList->LC_String) == 0)
                {
                    TmpList->FindFlag = TRUE;
                    break;
                }
            }
        }

        NtClose(hkRegistry);

    }

    /*
     * Display Language
     */

    TmpList = (PLC_List)&LocaleList;
    while(TmpList->Next != NULL)
    {
        TmpList = TmpList->Next;

        if (TmpList->FindFlag)
        {
            LangID = ConvertStringToHex(TmpList->LC_String, NULL);
            Locale = MAKELCID( LangID, SORT_DEFAULT );

            cchData = GetLocaleInfo(Locale, LOCALE_IDEFAULTCODEPAGE,
                                    awchData, sizeof(awchData)/sizeof(TCHAR));
            if (cchData)
            {
                awchData[cchData] = TEXT('\0');
                cp = ConvertStringToDec(awchData, NULL);

                fRet = GetCPInfoEx(cp, 0, &cpinfo);
                if (fRet) {
                    if (CodePage == cp) {
                        hWndLanguageDisp = GetDlgItem(hDlg, IDD_LANGUAGE);
                        SetWindowText(hWndLanguageDisp, cpinfo.CodePageName);
                    }
                }
            }
        }
    }

    {
        PLC_List Tmp;

        TmpList = (PLC_List)&LocaleList;
        while(TmpList->Next != NULL)
        {
            Tmp = TmpList;
            TmpList = TmpList->Next;

            if (Tmp != (PLC_List)&LocaleList)
                LocalFree(Tmp);
        }

        LocaleList = NULL;
    }

    return TRUE;
}


#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\fontdlg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fontdlg.h

Abstract:

    This module contains the definitions for console font dialog

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#ifndef FONTDLG_H
#define FONTDLG_H

/* ----- Literals ----- */

#define MAXDIMENSTRING     40  // max text in combo box
#define DX_TTBITMAP        20
#define DY_TTBITMAP        12
#define CCH_RASTERFONTS    24
#define CCH_SELECTEDFONT   30


/* ----- Macros ----- */
/*
 *  High-level macros
 *
 *  These macros handle the SendMessages that go tofrom list boxes
 *  and combo boxes.
 *
 *  The "xxx_lcb" prefix stands for leaves CritSect & "list or combo box".
 *
 *  Basically, we're providing mnemonic names for what would otherwise
 *  look like a whole slew of confusing SendMessage's.
 *
 */
#define lcbRESETCONTENT(hWnd, bLB) \
        SendMessage(hWnd, bLB ? LB_RESETCONTENT : CB_RESETCONTENT, 0, 0L)

#define lcbGETTEXT(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_GETTEXT : CB_GETLBTEXT, w, 0L)

#define lcbFINDSTRINGEXACT(hWnd, bLB, pwsz) \
        (LONG)SendMessage(hWnd, bLB ? LB_FINDSTRINGEXACT : CB_FINDSTRINGEXACT, \
                          (WPARAM)-1, (LPARAM)pwsz)

#define lcbADDSTRING(hWnd, bLB, pwsz) \
        (LONG)SendMessage(hWnd, bLB ? LB_ADDSTRING : CB_ADDSTRING, 0, (LPARAM)pwsz)

#define lcbSETITEMDATA(hWnd, bLB, w, nFont) \
        SendMessage(hWnd, bLB ? LB_SETITEMDATA : CB_SETITEMDATA, w, nFont)

#define lcbGETITEMDATA(hWnd, bLB, w) \
        (LONG)SendMessage(hWnd, bLB ? LB_GETITEMDATA : CB_GETITEMDATA, w, 0L)

#define lcbGETCOUNT(hWnd, bLB) \
        (LONG)SendMessage(hWnd, bLB ? LB_GETCOUNT : CB_GETCOUNT, 0, 0L)

#define lcbGETCURSEL(hWnd, bLB) \
        (LONG)SendMessage(hWnd, bLB ? LB_GETCURSEL : CB_GETCURSEL, 0, 0L)

#define lcbSETCURSEL(hWnd, bLB, w) \
        SendMessage(hWnd, bLB ? LB_SETCURSEL : CB_SETCURSEL, w, 0L)

#endif /* #ifndef FONTDLG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\fontdlg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fontdlg.dlg

Abstract:

    This module contains the code for console font dialog

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "fontdlg.h"


/* ----- Prototypes ----- */

int FontListCreate(
    HWND hDlg,
    LPTSTR ptszTTFace,
    BOOL bNewFaceList
    );

BOOL PreviewUpdate(
    HWND hDlg,
    BOOL bLB
    );

int SelectCurrentSize(
    HWND hDlg,
    BOOL bLB,
    int FontIndex);

BOOL PreviewInit(
    HWND hDlg);

VOID DrawItemFontList(
    const LPDRAWITEMSTRUCT lpdis);

/* ----- Globals ----- */

const TCHAR g_szPreviewText[] = \
    TEXT("C:\\WINDOWS> dir                       \n") \
    TEXT("SYSTEM       <DIR>     10-01-99   5:00a\n") \
    TEXT("SYSTEM32     <DIR>     10-01-99   5:00a\n") \
    TEXT("README   TXT     26926 10-01-99   5:00a\n") \
    TEXT("WINDOWS  BMP     46080 10-01-99   5:00a\n") \
    TEXT("NOTEPAD  EXE    337232 10-01-99   5:00a\n") \
    TEXT("CLOCK    AVI     39594 10-01-99   5:00p\n") \
    TEXT("WIN      INI      7005 10-01-99   5:00a\n");

HBITMAP hbmTT = NULL; // handle of TT logo bitmap
BITMAP bmTT;          // attributes of TT source bitmap
int dyFacelistItem;   // height of Item in Facelist listbox

BOOL gbPointSizeError = FALSE;
BOOL gbBold = FALSE;
#if defined(FE_SB)
BOOL fChangeCodePage = FALSE;


BOOL
SelectCurrentFont(
    HWND hDlg,
    int FontIndex
    );
#endif

// Globals strings loaded from resource
TCHAR tszSelectedFont[CCH_SELECTEDFONT+1];
TCHAR tszRasterFonts[CCH_RASTERFONTS+1];


INT_PTR
APIENTRY
FontDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

    Dialog proc for the font selection dialog box.
    Returns the near offset into the far table of LOGFONT structures.

--*/

{
    HWND hWndFocus;
    HWND hWndList;
    int FontIndex;
    BOOL bLB;
    TEXTMETRIC tm;
    HDC hDC;

    switch (wMsg) {
    case WM_INITDIALOG:
        /*
         * Load the font description strings
         */
        LoadString(ghInstance, IDS_RASTERFONT,
                   tszRasterFonts, NELEM(tszRasterFonts));
        DBGPRINT(("tszRasterFonts = \"%ls\"\n", tszRasterFonts));
        ASSERT(_tcslen(tszRasterFonts) < CCH_RASTERFONTS);

        LoadString(ghInstance, IDS_SELECTEDFONT,
                   tszSelectedFont, NELEM(tszSelectedFont));
        DBGPRINT(("tszSelectedFont = \"%ls\"\n", tszSelectedFont));
        ASSERT(_tcslen(tszSelectedFont) < CCH_SELECTEDFONT);

        /* Save current font size as dialog window's user data */
#if defined(FE_SB)
        ASSERT(OEMCP != 0);
        if (gfFESystem) {
            SetWindowLongPtr(hDlg, GWLP_USERDATA,
                          MAKELONG(FontInfo[CurrentFontIndex].tmCharSet,
                                   FontInfo[CurrentFontIndex].Size.Y));
        } else {
#endif
            SetWindowLongPtr(hDlg, GWLP_USERDATA,
                          MAKELONG(FontInfo[CurrentFontIndex].Size.X,
                                   FontInfo[CurrentFontIndex].Size.Y));
#if defined(FE_SB)
        }
#endif

        /* Create the list of suitable fonts */
        gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(gpStateInfo->FontFamily);
        gbBold = IS_BOLD(gpStateInfo->FontWeight);
        CheckDlgButton(hDlg, IDD_BOLDFONT, gbBold);
        FontListCreate(hDlg, bLB ? NULL : gpStateInfo->FaceName, TRUE);

        /* Initialize the preview window - selects current face & size too */
        bLB = PreviewInit(hDlg);
        PreviewUpdate(hDlg, bLB);

        /* Make sure the list box has the focus */
        hWndList = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);
        SetFocus(hWndList);
        break;

    case WM_FONTCHANGE:
        gbEnumerateFaces = TRUE;
        bLB = !TM_IS_TT_FONT(gpStateInfo->FontFamily);
        FontListCreate(hDlg, NULL, TRUE);
        FontIndex = FindCreateFont(gpStateInfo->FontFamily,
                                   gpStateInfo->FaceName,
                                   gpStateInfo->FontSize,
                                   gpStateInfo->FontWeight,
                                   gpStateInfo->CodePage);
        SelectCurrentSize(hDlg, bLB, FontIndex);
        return TRUE;

#if defined(FE_SB)
    case WM_PAINT:
        if (fChangeCodePage)
        {
            fChangeCodePage = FALSE;

            /* Create the list of suitable fonts */
            bLB = !TM_IS_TT_FONT(gpStateInfo->FontFamily);
            FontIndex = FontListCreate(hDlg, !bLB ? NULL : gpStateInfo->FaceName, TRUE);
            FontIndex = FontListCreate(hDlg, bLB ? NULL : gpStateInfo->FaceName, TRUE);
            CurrentFontIndex = FontIndex;

            FontIndex = SelectCurrentSize(hDlg, bLB, FontIndex);
            SelectCurrentFont(hDlg, FontIndex);

            PreviewUpdate(hDlg, bLB);
        }
        break;
#endif

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_BOLDFONT:
            DBGPRINT(("WM_COMMAND to Bold Font checkbox %x\n", HIWORD(wParam)));
            gbBold = IsDlgButtonChecked(hDlg, IDD_BOLDFONT);
            goto RedoFontListAndPreview;

        case IDD_FACENAME:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
RedoFontListAndPreview:
                {
                    TCHAR atchNewFace[LF_FACESIZE];
                    LONG l;

                    DBGFONTS(("LBN_SELCHANGE from FACENAME\n"));
                    l = (LONG)SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETCURSEL, 0, 0L);
                    bLB = (BOOL)SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETITEMDATA, l, 0L);
                    if (!bLB) {
                        SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETTEXT, l, (LPARAM)atchNewFace);
                        DBGFONTS(("LBN_EDITUPDATE, got TT face \"%ls\"\n", atchNewFace));
                    }
                    FontIndex = FontListCreate(hDlg, bLB ? NULL : atchNewFace, FALSE);
                    FontIndex = SelectCurrentSize(hDlg, bLB, FontIndex);
                    PreviewUpdate(hDlg, bLB);
                    return TRUE;
                }
            }
            break;

        case IDD_POINTSLIST:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                DBGFONTS(("CBN_SELCHANGE from POINTSLIST\n"));
                PreviewUpdate(hDlg, FALSE);
                return TRUE;

            case CBN_KILLFOCUS:
                DBGFONTS(("CBN_KILLFOCUS from POINTSLIST\n"));
                if (!gbPointSizeError) {
                    hWndFocus = GetFocus();
                    if (hWndFocus != NULL && IsChild(hDlg, hWndFocus) &&
                        hWndFocus != GetDlgItem(hDlg, IDCANCEL)) {
                        PreviewUpdate(hDlg, FALSE);
                    }
                }
                return TRUE;

            default:
                DBGFONTS(("unhandled CBN_%x from POINTSLIST\n",HIWORD(wParam)));
                break;
            }
            break;

        case IDD_PIXELSLIST:
            switch (HIWORD(wParam)) {
            case LBN_SELCHANGE:
                DBGFONTS(("LBN_SELCHANGE from PIXELSLIST\n"));
                PreviewUpdate(hDlg, TRUE);
                return TRUE;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_KILLACTIVE:
            //
            // If the TT combo box is visible, update selection
            //
            hWndList = GetDlgItem(hDlg, IDD_POINTSLIST);
            if (hWndList != NULL && IsWindowVisible(hWndList)) {
                if (!PreviewUpdate(hDlg, FALSE)) {
                    SetDlgMsgResult(hDlg, PSN_KILLACTIVE, TRUE);
                    return TRUE;
                }
                SetDlgMsgResult(hDlg, PSN_KILLACTIVE, FALSE);
            }

            FontIndex = CurrentFontIndex;

            if (FontInfo[FontIndex].SizeWant.Y == 0) {
                // Raster Font, so save actual size
                gpStateInfo->FontSize = FontInfo[FontIndex].Size;
            } else {
                // TT Font, so save desired size
                gpStateInfo->FontSize = FontInfo[FontIndex].SizeWant;
            }

            gpStateInfo->FontWeight = FontInfo[FontIndex].Weight;
            gpStateInfo->FontFamily = FontInfo[FontIndex].Family;
            wcscpy(gpStateInfo->FaceName, FontInfo[FontIndex].FaceName);

            return TRUE;

        case PSN_APPLY:
            /*
             * Write out the state values and exit.
             */
            EndDlgPage(hDlg);
            return TRUE;
        }
        break;

    /*
     *  For WM_MEASUREITEM and WM_DRAWITEM, since there is only one
     *  owner-draw item (combobox) in the entire dialog box, we don't have
     *  to do a GetDlgItem to figure out who he is.
     */
    case WM_MEASUREITEM:
        /*
         * Load the TrueType logo bitmap
         */
        if (hbmTT == NULL) {
            hbmTT = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_TRUETYPE));
            GetObject(hbmTT, sizeof(BITMAP), &bmTT);
        }

        /*
         * Compute the height of face name listbox entries
         */
        if (dyFacelistItem == 0) {
            HFONT hFont;
            hDC = GetDC(hDlg);
            hFont = GetWindowFont(hDlg);
            if (hFont) {
                hFont = SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont) {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(hDlg, hDC);
            dyFacelistItem = max(tm.tmHeight, bmTT.bmHeight);
        }
        ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = dyFacelistItem;
        return TRUE;

    case WM_DRAWITEM:
        DrawItemFontList((LPDRAWITEMSTRUCT)lParam);
        return TRUE;

    case WM_DESTROY:
        /*
         * Delete the TrueType logo bitmap
         */
        if (hbmTT != NULL) {
            DeleteObject(hbmTT);
            hbmTT = NULL;
        }
        return TRUE;

    default:
        break;
    }
    return CommonDlgProc(hDlg, wMsg, wParam, lParam);
}


int
FontListCreate(
    HWND hDlg,
    LPTSTR ptszTTFace,
    BOOL bNewFaceList
    )

/*++

    Initializes the font list by enumerating all fonts and picking the
    proper ones for our list.

    Returns
        FontIndex of selected font (LB_ERR if none)
--*/

{
    TCHAR tszText[80];
    LONG lListIndex;
    ULONG i;
    HWND hWndShow;      // List or Combo box
    HWND hWndHide;    // Combo or List box
    HWND hWndFaceCombo;
    HANDLE hStockFont;
    BOOL bLB;
    int LastShowX = 0;
    int LastShowY = 0;
    int nSameSize = 0;
    UINT  CodePage = gpStateInfo->CodePage;
    BOOL  fDbcsCharSet = IS_ANY_DBCS_CHARSET( CodePageToCharSet( CodePage ) );
    BOOL  fFindTTFont = FALSE;
    LPTSTR ptszAltTTFace = NULL;
    LONG_PTR dwExStyle = 0L;

    ASSERT(OEMCP != 0); // must be initialized

    bLB = ((ptszTTFace == NULL) || (ptszTTFace[0] == TEXT('\0')));
    if (! bLB) {
        if (IsAvailableTTFont(ptszTTFace)) {
            ptszAltTTFace = GetAltFaceName(ptszTTFace);
        }
        else {
            ptszAltTTFace = ptszTTFace;
        }
    }
    DBGFONTS(("FontListCreate %lx, %s, %s new FaceList\n", hDlg,
            bLB ? "Raster" : "TrueType",
            bNewFaceList ? "Make" : "No" ));

    /*
     * This only enumerates face names if necessary, and
     * it only enumerates font sizes if necessary
     */

    EnumerateFonts(bLB ? EF_OEMFONT : EF_TTFONT);

    /* init the TTFaceNames */

    DBGFONTS(("  Create %s fonts\n", bLB ? "Raster" : "TrueType"));

    if (bNewFaceList) {
        PFACENODE panFace;
        hWndFaceCombo = GetDlgItem(hDlg, IDD_FACENAME);

        SendMessage(hWndFaceCombo, LB_RESETCONTENT, 0, 0);

        lListIndex = (LONG)SendMessage(hWndFaceCombo, LB_ADDSTRING, 0, (LPARAM)tszRasterFonts);
        SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, TRUE);
        DBGFONTS(("Added \"%ls\", set Item Data %d = TRUE\n", tszRasterFonts, lListIndex));
        for (panFace = gpFaceNames; panFace; panFace = panFace->pNext) {
            if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                continue;
            }
            if (!fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                continue;
            }

            if ((fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, CodePage)) ||
                (!fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, 0)))
            {

                if ( !bLB &&
                     (_tcscmp(ptszTTFace, panFace->atch) == 0 ||
                      _tcscmp(ptszAltTTFace, panFace->atch) == 0)
                   ) {
                    fFindTTFont = TRUE;
                }
                lListIndex = (LONG)SendMessage(hWndFaceCombo, LB_ADDSTRING, 0,
                                         (LPARAM)panFace->atch);
                SendMessage(hWndFaceCombo, LB_SETITEMDATA, lListIndex, FALSE);
                DBGFONTS(("Added \"%ls\", set Item Data %d = FALSE\n",
                          panFace->atch, lListIndex));
            }
        }
        if (!bLB && !fFindTTFont) {

            for (panFace = gpFaceNames; panFace; panFace = panFace->pNext) {

                if ((panFace->dwFlag & (EF_TTFONT|EF_NEW)) != (EF_TTFONT|EF_NEW)) {
                    continue;
                }
                if (!fDbcsCharSet && (panFace->dwFlag & EF_DBCSFONT)) {
                    continue;
                }

                if (( fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, CodePage)) ||
                    (!fDbcsCharSet && IsAvailableTTFontCP(panFace->atch, 0)))
                {

                    if (_tcscmp(ptszTTFace, panFace->atch) != 0) {
                        _tcscpy(ptszTTFace, panFace->atch);
                        break;
                    }
                }
            }
        }
    } // if(bNewFaceList)

    hWndShow = GetDlgItem(hDlg, IDD_BOLDFONT);
#if defined(FE_SB)
    /*
     * For JAPAN, We uses "MS Gothic" TT font.
     * So, Bold of this font is not 1:2 width between SBCS:DBCS.
     */
    if (fDbcsCharSet && IsDisableBoldTTFont(ptszTTFace)) {
        EnableWindow(hWndShow, FALSE);
        gbBold = FALSE;
        CheckDlgButton(hDlg, IDD_BOLDFONT, FALSE);
    } else {
#endif
        CheckDlgButton(hDlg, IDD_BOLDFONT, (bLB || !gbBold) ? FALSE : TRUE);
        EnableWindow(hWndShow, bLB ? FALSE : TRUE);
#if defined(FE_SB)
    }
#endif

    hWndHide = GetDlgItem(hDlg, bLB ? IDD_POINTSLIST : IDD_PIXELSLIST);
    ShowWindow(hWndHide, SW_HIDE);
    EnableWindow(hWndHide, FALSE);

    hWndShow = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);
//    hStockFont = GetStockObject(SYSTEM_FIXED_FONT);
//    SendMessage(hWndShow, WM_SETFONT, (DWORD)hStockFont, FALSE);
    ShowWindow(hWndShow, SW_SHOW);
    EnableWindow(hWndShow, TRUE);

#if defined(FE_SB)
    if (bNewFaceList) {
        lcbRESETCONTENT(hWndShow, bLB);
    }
#endif

    dwExStyle = GetWindowLongPtr(hWndShow, GWL_EXSTYLE);
    if((dwExStyle & WS_EX_LAYOUTRTL) && !(dwExStyle & WS_EX_RTLREADING))
    {
        // if mirrored RTL Reading means LTR !!
        SetWindowLongPtr(hWndShow, GWL_EXSTYLE, dwExStyle | WS_EX_RTLREADING);
    }

    /* Initialize hWndShow list/combo box */

    for (i=0;i<NumberOfFonts;i++) {
        int ShowX, ShowY;

        if (!bLB == !TM_IS_TT_FONT(FontInfo[i].Family)) {
            DBGFONTS(("  Font %x not right type\n", i));
            continue;
        }
#if defined(FE_SB)
        if (fDbcsCharSet) {
            if (!IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet)) {
                DBGFONTS(("  Font %x not right type for DBCS character set\n", i));
                continue;
            }
        }
        else {
            if (IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet)) {
                DBGFONTS(("  Font %x not right type for SBCS character set\n", i));
                continue;
            }
        }
#endif

        if (!bLB) {
            if (_tcscmp(FontInfo[i].FaceName, ptszTTFace) != 0 &&
                _tcscmp(FontInfo[i].FaceName, ptszAltTTFace) != 0
               ) {
                /*
                 * A TrueType font, but not the one we're interested in,
                 * so don't add it to the list of point sizes.
                 */
                DBGFONTS(("  Font %x is TT, but not %ls\n", i, ptszTTFace));
                continue;
            }
            if (gbBold != IS_BOLD(FontInfo[i].Weight)) {
                DBGFONTS(("  Font %x has weight %d, but we wanted %sbold\n",
                        i, FontInfo[i].Weight, gbBold ? "" : "not "));
                continue;
            }
        }

        if (FontInfo[i].SizeWant.X > 0) {
            ShowX = FontInfo[i].SizeWant.X;
        } else {
            ShowX = FontInfo[i].Size.X;
        }
        if (FontInfo[i].SizeWant.Y > 0) {
            ShowY = FontInfo[i].SizeWant.Y;
        } else {
            ShowY = FontInfo[i].Size.Y;
        }
        /*
         * Add the size description string to the end of the right list
         */
        if (TM_IS_TT_FONT(FontInfo[i].Family)) {
            // point size
            wsprintf(tszText, TEXT("%2d"), FontInfo[i].SizeWant.Y);
        } else {
            // pixel size
            if ((LastShowX == ShowX) && (LastShowY == ShowY)) {
                nSameSize++;
            } else {
                LastShowX = ShowX;
                LastShowY = ShowY;
                nSameSize = 0;
            }
            /*
             * The number nSameSize is appended to the string to distinguish
             * between Raster fonts of the same size.  It is not intended to
             * be visible and exists off the edge of the list
             */
            if(((dwExStyle & WS_EX_RIGHT) && !(dwExStyle & WS_EX_LAYOUTRTL))
                || (!(dwExStyle & WS_EX_RIGHT) && (dwExStyle & WS_EX_LAYOUTRTL))) {
                // flip  it so that the hidden part be at the far left
                wsprintf(tszText, TEXT("#%d                %2d x %2d"),
                         nSameSize, ShowX, ShowY);
            } else {
                wsprintf(tszText, TEXT("%2d x %2d                #%d"),
                         ShowX, ShowY, nSameSize);
            }
        }
        lListIndex = lcbFINDSTRINGEXACT(hWndShow, bLB, tszText);
        if (lListIndex == LB_ERR) {
            lListIndex = lcbADDSTRING(hWndShow, bLB, tszText);
        }
        DBGFONTS(("  added %ls to %sSLIST(%lx) index %lx\n",
                tszText,
                bLB ? "PIXEL" : "POINT",
                hWndShow, lListIndex));
        lcbSETITEMDATA(hWndShow, bLB, (DWORD)lListIndex, i);
    }

    /*
     * Get the FontIndex from the currently selected item.
     * (i will be LB_ERR if no currently selected item).
     */
    lListIndex = lcbGETCURSEL(hWndShow, bLB);
    i = lcbGETITEMDATA(hWndShow, bLB, lListIndex);

    DBGFONTS(("FontListCreate returns 0x%x\n", i));
    return i;
}


/** DrawItemFontList
 *
 *  Answer the WM_DRAWITEM message sent from the font list box or
 *  facename list box.
 *
 *  Entry:
 *      lpdis     -> DRAWITEMSTRUCT describing object to be drawn
 *
 *  Returns:
 *      None.
 *
 *      The object is drawn.
 */
VOID WINAPI
DrawItemFontList(const LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC, hdcMem;
    DWORD   rgbBack, rgbText, rgbFill;
    TCHAR   tszFace[LF_FACESIZE];
    HBITMAP hOld;
    int     dy;
    HBRUSH  hbrFill;
    HWND    hWndItem;
    BOOL    bLB;
    int     dxttbmp;

    if ((int)lpdis->itemID < 0)
        return;

    hDC = lpdis->hDC;

    if (lpdis->itemAction & ODA_FOCUS) {
        if (lpdis->itemState & ODS_SELECTED) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    } else {
        if (lpdis->itemState & ODS_SELECTED) {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_HIGHLIGHT));
        } else {
            rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            rgbBack = SetBkColor(hDC, rgbFill = GetSysColor(COLOR_WINDOW));
        }
        // draw selection background
        hbrFill = CreateSolidBrush(rgbFill);
        if (hbrFill) {
            FillRect(hDC, &lpdis->rcItem, hbrFill);
            DeleteObject(hbrFill);
        }

        // get the string
        if (IsWindow(hWndItem = lpdis->hwndItem) == FALSE) {
            return;
        }
        SendMessage(hWndItem, LB_GETTEXT, lpdis->itemID, (LPARAM)tszFace);
        bLB = (BOOL)SendMessage(hWndItem, LB_GETITEMDATA, lpdis->itemID, 0L);
        dxttbmp = bLB ? 0 : bmTT.bmWidth;

        DBGFONTS(("DrawItemFontList must redraw \"%ls\" %s\n", tszFace,
                bLB ? "Raster" : "TrueType"));

        // draw the text
        TabbedTextOut(hDC, lpdis->rcItem.left + dxttbmp,
                      lpdis->rcItem.top, tszFace,
                      _tcslen(tszFace), 0, NULL, dxttbmp);

        // and the TT bitmap if needed
        if (!bLB) {
            hdcMem = CreateCompatibleDC(hDC);
            if (hdcMem) {
                hOld = SelectObject(hdcMem, hbmTT);

                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - bmTT.bmHeight) / 2;

                BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy,
                       dxttbmp, dyFacelistItem, hdcMem,
                       0, 0, SRCINVERT);

                if (hOld)
                    SelectObject(hdcMem, hOld);
                DeleteDC(hdcMem);
            }
        }

        SetTextColor(hDC, rgbText);
        SetBkColor(hDC, rgbBack);

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    }
}


UINT
GetPointSizeInRange(
   HWND hDlg,
   INT Min,
   INT Max)
/*++

Routine Description:

   Get a size from the Point Size ComboBox edit field

Return Value:

   Point Size - of the edit field limited by Min/Max size
   0 - if the field is empty or invalid

--*/

{
    TCHAR szBuf[90];
    int nTmp = 0;
    BOOL bOK;

    if (GetDlgItemText(hDlg, IDD_POINTSLIST, szBuf, NELEM(szBuf))) {
        nTmp = GetDlgItemInt(hDlg, IDD_POINTSLIST, &bOK, TRUE);
        if (bOK && nTmp >= Min && nTmp <= Max) {
            return nTmp;
        }
    }

    return 0;
}


/* ----- Preview routines ----- */

LRESULT
FontPreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*  FontPreviewWndProc
 *      Handles the font preview window
 */

{
    PAINTSTRUCT ps;
    RECT rect;
    HFONT hfontOld;
    HBRUSH hbrNew;
    HBRUSH hbrOld;
    COLORREF rgbText;
    COLORREF rgbBk;

    switch (wMessage) {
    case WM_ERASEBKGND:
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);

        /* Draw the font sample */
        if (GetWindowLong(hWnd, GWL_ID) == IDD_COLOR_POPUP_COLORS) {
            rgbText = GetNearestColor(ps.hdc, PopupTextColor(gpStateInfo));
            rgbBk = GetNearestColor(ps.hdc, PopupBkColor(gpStateInfo));
        } else {
            rgbText = GetNearestColor(ps.hdc, ScreenTextColor(gpStateInfo));
            rgbBk = GetNearestColor(ps.hdc, ScreenBkColor(gpStateInfo));
        }
        SetTextColor(ps.hdc, rgbText);
        SetBkColor(ps.hdc, rgbBk);
        GetClientRect(hWnd, &rect);
        hfontOld = SelectObject(ps.hdc, FontInfo[CurrentFontIndex].hFont);
        hbrNew = CreateSolidBrush(rgbBk);
        hbrOld = SelectObject(ps.hdc, hbrNew);
        PatBlt(ps.hdc, rect.left, rect.top,
                rect.right - rect.left, rect.bottom - rect.top,
                PATCOPY);
        InflateRect(&rect, -2, -2);
        DrawText(ps.hdc, g_szPreviewText, -1, &rect, 0);
        SelectObject(ps.hdc, hbrOld);
        DeleteObject(hbrNew);
        SelectObject(ps.hdc, hfontOld);

        EndPaint(hWnd, &ps);
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}


/*
 * Get the font index for a new font
 * If necessary, attempt to create the font.
 * Always return a valid FontIndex (even if not correct)
 * Family:   Find/Create a font with of this Family
 *           0    - don't care
 * ptszFace: Find/Create a font with this face name.
 *           NULL or TEXT("")  - use DefaultFaceName
 * Size:     Must match SizeWant or actual Size.
 */
int
FindCreateFont(
    DWORD Family,
    LPTSTR ptszFace,
    COORD Size,
    LONG Weight,
    UINT CodePage)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    int i;
    int FontIndex = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    TCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    LPTSTR ptszAltFace = NULL;

    BYTE CharSet = CodePageToCharSet(CodePage);

    ASSERT(OEMCP != 0);

    DBGFONTS(("FindCreateFont Family=%x %ls (%d,%d) %d %d %x\n",
            Family, ptszFace, Size.X, Size.Y, Weight, CodePage, CharSet));

    if (gfFESystem) {
        if (IS_ANY_DBCS_CHARSET(CharSet)) {
            if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
                ptszFace = DefaultFaceName;
            }
            if (Size.Y == 0) {
                Size = DefaultFontSize;
            }
        }
        else {
            MakeAltRasterFont(CodePage, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

            if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
                ptszFace = AltFaceName;
            }
            if (Size.Y == 0) {
                Size.X = AltFontSize.X;
                Size.Y = AltFontSize.Y;
            }
        }
    }
    else {
        if (ptszFace == NULL || *ptszFace == TEXT('\0')) {
            ptszFace = DefaultFaceName;
        }
        if (Size.Y == 0) {
            Size = DefaultFontSize;
        }
    }


    if (IsAvailableTTFont(ptszFace)) {
        ptszAltFace = GetAltFaceName(ptszFace);
    }
    else {
        ptszAltFace = ptszFace;
    }

    /*
     * Try to find the exact font
     */
TryFindExactFont:
    for (i=0; i < (int)NumberOfFonts; i++) {
        /*
         * If looking for a particular Family, skip non-matches
         */
        if ((Family != 0) &&
                ((BYTE)Family != FontInfo[i].Family)) {
            continue;
        }

        /*
         * Skip non-matching sizes
         */
        if ((!SIZE_EQUAL(FontInfo[i].SizeWant, Size) &&
             !SIZE_EQUAL(FontInfo[i].Size, Size))) {
            continue;
        }

        /*
         * Skip non-matching weights
         */
        if ((Weight != 0) && (Weight != FontInfo[i].Weight)) {
            continue;
        }

#if defined(FE_SB)
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                FontInfo[i].tmCharSet != CharSet) {
            continue;
        }
#endif

        /*
         * Size (and maybe Family) match.
         *  If we don't care about the name, or if it matches, use this font.
         *  Else if name doesn't match and it is a raster font, consider it.
         */
        if ((ptszFace == NULL) || (ptszFace[0] == TEXT('\0')) ||
                (_tcscmp(FontInfo[i].FaceName, ptszFace) == 0) ||
                (_tcscmp(FontInfo[i].FaceName, ptszAltFace) == 0)
           ) {
            FontIndex = i;
            goto FoundFont;
        } else if (!TM_IS_TT_FONT(FontInfo[i].Family)) {
            FontIndex = i;
        }
    }

    if (FontIndex == NOT_CREATED_NOR_FOUND) {
        /*
         * Didn't find the exact font, so try to create it
         */
        ULONG ulOldEnumFilter;
        ulOldEnumFilter = SetFontEnumeration(0);
        SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);
        if (Size.Y < 0) {
            Size.Y = -Size.Y;
        }
        bFontOK = DoFontEnum(NULL, ptszFace, &Size.Y, 1);
        SetFontEnumeration(ulOldEnumFilter);
        if (bFontOK) {
            DBGFONTS(("FindCreateFont created font!\n"));
            FontIndex = CREATED_BUT_NOT_FOUND;
            goto TryFindExactFont;
        } else {
            DBGFONTS(("FindCreateFont failed to create font!\n"));
        }
    } else if (FontIndex >= 0) {
        // a close Raster Font fit - only the name doesn't match.
        goto FoundFont;
    }

    /*
     * Failed to find exact match, even after enumeration, so now try
     * to find a font of same family and same size or bigger
     */
    for (i=0; i < (int)NumberOfFonts; i++) {
#if defined(FE_SB)
        if (gfFESystem) {
            if ((Family != 0) &&
                    ((BYTE)Family != FontInfo[i].Family)) {
                continue;
            }

            if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                FontInfo[i].tmCharSet != CharSet) {
                continue;
            }
        }
        else {
#endif
        if ((BYTE)Family != FontInfo[i].Family) {
            continue;
        }
#if defined(FE_SB)
        }
#endif

        if (FontInfo[i].Size.Y >= Size.Y &&
                FontInfo[i].Size.X >= Size.X) {
            // Same family, size >= desired.
            FontIndex = i;
            break;
        }
    }

    if (FontIndex < 0) {
        DBGFONTS(("FindCreateFont defaults!\n"));
#if defined(FE_SB)
        if (gfFESystem) {
            if (CodePage == OEMCP) {
                FontIndex = DefaultFontIndex;
            }
            else {
                FontIndex = AltFontIndex;
            }
        }
        else {
#endif
        FontIndex = DefaultFontIndex;
#if defined(FE_SB)
        }
#endif
    }

FoundFont:
    DBGFONTS(("FindCreateFont returns %x : %ls (%d,%d)\n", FontIndex,
            FontInfo[FontIndex].FaceName,
            FontInfo[FontIndex].Size.X, FontInfo[FontIndex].Size.Y));
    return FontIndex;

#undef NOT_CREATED_NOR_FOUND
#undef CREATED_BUT_NOT_FOUND
}


/*
 * SelectCurrentSize - Select the right line of the Size listbox/combobox.
 *   bLB       : Size controls is a listbox (TRUE for RasterFonts)
 *   FontIndex : Index into FontInfo[] cache
 *               If < 0 then choose a good font.
 * Returns
 *   FontIndex : Index into FontInfo[] cache
 */
int
SelectCurrentSize(HWND hDlg, BOOL bLB, int FontIndex)
{
    int iCB;
    HWND hWndList;

    DBGFONTS(("SelectCurrentSize %lx %s %x\n",
            hDlg, bLB ? "Raster" : "TrueType", FontIndex));

    hWndList = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);
    iCB = lcbGETCOUNT(hWndList, bLB);
    DBGFONTS(("  Count of items in %lx = %lx\n", hWndList, iCB));

    if (FontIndex >= 0) {
        /*
         * look for FontIndex
         */
        while (iCB > 0) {
            iCB--;
            if (lcbGETITEMDATA(hWndList, bLB, iCB) == FontIndex) {
                lcbSETCURSEL(hWndList, bLB, iCB);
                break;
            }
        }
    } else {
        /*
         * look for a reasonable default size: looking backwards, find
         * the first one same height or smaller.
         */
        DWORD Size;
        Size = GetWindowLong(hDlg, GWLP_USERDATA);
#if defined(FE_SB)
        ASSERT(OEMCP != 0);
        if (gfFESystem && bLB
            && (FontInfo[CurrentFontIndex].tmCharSet != LOBYTE(LOWORD(Size)))
           )
        {
            TCHAR AltFaceName[LF_FACESIZE];
            COORD AltFontSize;
            BYTE  AltFontFamily;
            ULONG AltFontIndex = 0;

            MakeAltRasterFont(gpStateInfo->CodePage, &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

            while (iCB > 0) {
                iCB--;
                if (lcbGETITEMDATA(hWndList, bLB, iCB) == (int)AltFontIndex) {
                    lcbSETCURSEL(hWndList, bLB, iCB);
                    break;
                }
            }
        }
        else
#endif
        while (iCB > 0) {
            iCB--;
            FontIndex = lcbGETITEMDATA(hWndList, bLB, iCB);
            if (FontInfo[FontIndex].Size.Y <= HIWORD(Size)) {
                lcbSETCURSEL(hWndList, bLB, iCB);
                break;
            }
        }
    }
    DBGFONTS(("SelectCurrentSize returns %x\n", FontIndex));
    return FontIndex;
}


BOOL
SelectCurrentFont(HWND hDlg, int FontIndex)
{
    BOOL bLB;

    DBGFONTS(("SelectCurrentFont hDlg=%lx, FontIndex=%x\n", hDlg, FontIndex));

    bLB = !TM_IS_TT_FONT(FontInfo[FontIndex].Family);

    SendDlgItemMessage(hDlg, IDD_FACENAME, LB_SELECTSTRING, (WPARAM)-1,
            bLB ? (LPARAM)tszRasterFonts : (LPARAM)FontInfo[FontIndex].FaceName);

    SelectCurrentSize(hDlg, bLB, FontIndex);
    return bLB;
}


BOOL
PreviewInit(
    HWND hDlg
    )

/*  PreviewInit
 *      Prepares the preview code, sizing the window and the dialog to
 *      make an attractive preview.
 *  Returns TRUE if Raster Fonts, FALSE if TT Font
 */

{
    int nFont;

    DBGFONTS(("PreviewInit hDlg=%lx\n", hDlg));

    /*
     * Set the current font
     */
    nFont = FindCreateFont(gpStateInfo->FontFamily,
                           gpStateInfo->FaceName,
                           gpStateInfo->FontSize,
                           gpStateInfo->FontWeight,
                           gpStateInfo->CodePage);

    DBGPRINT(("Changing Font Number from %d to %d\n",
              CurrentFontIndex, nFont));
    CurrentFontIndex = nFont;

    return SelectCurrentFont(hDlg, nFont);
}


BOOL
PreviewUpdate(
    HWND hDlg,
    BOOL bLB
    )

/*++

    Does the preview of the selected font.

--*/

{
    PFONT_INFO lpFont;
    int FontIndex;
    LONG lIndex;
    HWND hWnd;
    TCHAR tszText[60];
    TCHAR tszFace[LF_FACESIZE + CCH_SELECTEDFONT];
    HWND hWndList;

    DBGFONTS(("PreviewUpdate hDlg=%lx, %s\n", hDlg,
            bLB ? "Raster" : "TrueType"));

    hWndList = GetDlgItem(hDlg, bLB ? IDD_PIXELSLIST : IDD_POINTSLIST);

    /* When we select a font, we do the font preview by setting it into
     *  the appropriate list box
     */
    lIndex = lcbGETCURSEL(hWndList, bLB);
    DBGFONTS(("PreviewUpdate GETCURSEL gets %x\n", lIndex));
    if ((lIndex < 0) && !bLB) {
        COORD NewSize;

        lIndex = (LONG)SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETCURSEL, 0, 0L);
        SendDlgItemMessage(hDlg, IDD_FACENAME, LB_GETTEXT, lIndex, (LPARAM)tszFace);
        NewSize.X = 0;
        NewSize.Y = (SHORT)GetPointSizeInRange(hDlg, MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);

        if (NewSize.Y == 0) {
            TCHAR tszBuf[60];
            /*
             * Use tszText, tszBuf to put up an error msg for bad point size
             */
            gbPointSizeError = TRUE;
            LoadString(ghInstance, IDS_FONTSIZE, tszBuf, NELEM(tszBuf));
            wsprintf(tszText, tszBuf, MIN_PIXEL_HEIGHT, MAX_PIXEL_HEIGHT);

            GetWindowText(hDlg, tszBuf, NELEM(tszBuf));
            MessageBoxEx(hDlg, tszText, tszBuf, MB_OK|MB_ICONINFORMATION, 0L);
            SetFocus(hWndList);
            gbPointSizeError = FALSE;
            return FALSE;
        }
        FontIndex = FindCreateFont(FF_MODERN|TMPF_VECTOR|TMPF_TRUETYPE,
                                   tszFace, NewSize, 0,
                                   gpStateInfo->CodePage);
    } else {
        FontIndex = lcbGETITEMDATA(hWndList, bLB, lIndex);
    }

    if (FontIndex < 0) {
        FontIndex = DefaultFontIndex;
    }

    /*
     * If we've selected a new font, tell the property sheet we've changed
     */
    if (CurrentFontIndex != (ULONG)FontIndex) {
        CurrentFontIndex = FontIndex;
    }

    lpFont = &FontInfo[FontIndex];

    /* Display the new font */

    _tcscpy(tszFace, tszSelectedFont);
    _tcscat(tszFace, lpFont->FaceName);
    SetDlgItemText(hDlg, IDD_GROUP, tszFace);

    /* Put the font size in the static boxes */
    wsprintf(tszText, TEXT("%u"), lpFont->Size.X);
    hWnd = GetDlgItem(hDlg, IDD_FONTWIDTH);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);
    wsprintf(tszText, TEXT("%u"), lpFont->Size.Y);
    hWnd = GetDlgItem(hDlg, IDD_FONTHEIGHT);
    SetWindowText(hWnd, tszText);
    InvalidateRect(hWnd, NULL, TRUE);

    /* Force the preview windows to repaint */
    hWnd = GetDlgItem(hDlg, IDD_PREVIEWWINDOW);
    SendMessage(hWnd, CM_PREVIEW_UPDATE, 0, 0);
    hWnd = GetDlgItem(hDlg, IDD_FONTWINDOW);
    InvalidateRect(hWnd, NULL, TRUE);

    DBGFONTS(("Font %x, (%d,%d) %ls\n", FontIndex,
            FontInfo[FontIndex].Size.X,
            FontInfo[FontIndex].Size.Y,
            FontInfo[FontIndex].FaceName));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\init.c ===
/*************************************************************\
 *  File name:    INIT.C
 *
 *  Description:  Initialization code for Console control panel
 *                applet
 *
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1994
 *  All rights reserved
 *
\*************************************************************/
#include "precomp.h"
#include <cpl.h>


HINSTANCE ghInstance;


/*************************************************************\
 *
 *  DllInitialize()
 *
 *  Purpose:    Main entry point
 *
 *
 *  Parameters: HINSTANCE hInstDLL    - Instance handle of DLL
 *              DWORD     dwReason    - Reason DLL was called
 *              LPVOID    lpvReserved - NULL
 *
 *
 *  Return:     BOOL
 *
\*************************************************************/

BOOL DllInitialize(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    ghInstance = hInstDLL;

    DisableThreadLibraryCalls(hInstDLL);

    return TRUE;
}


/*************************************************************\
 *
 *  CPlApplet()
 *
 *  Purpose:    Control Panel entry point
 *
 *
 *  Parameters: HWND hwnd      - Window handle
 *              WORD wMsg      - Control Panel message
 *              LPARAM lParam1 - Long parameter
 *              LPARAM lParam2 - Long parameter
 *
 *
 *  Return:     LONG
 *
\*************************************************************/

LONG CPlApplet( HWND hwnd, WORD wMsg, LPARAM lParam1, LPARAM lParam2)
{
    LPCPLINFO lpOldCPlInfo;
    LPNEWCPLINFO lpCPlInfo;
    INITCOMMONCONTROLSEX iccex;

    switch (wMsg) {

    case CPL_INIT:

        iccex.dwSize = sizeof(iccex);
        iccex.dwICC  = ICC_WIN95_CLASSES;
        InitCommonControlsEx( &iccex );
        //InitCommonControls();

        if (!RegisterClasses(ghInstance)) {
            return FALSE;
        }
        OEMCP = GetOEMCP();
        gfFESystem = IsFarEastCP(OEMCP);
        if (!NT_SUCCESS(InitializeDbcsMisc())) {
            return FALSE;
        }
        return TRUE;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:

        lpOldCPlInfo = (LPCPLINFO)lParam2;

        lpOldCPlInfo->idIcon = IDI_CONSOLE;
        lpOldCPlInfo->idName = IDS_NAME;
        lpOldCPlInfo->idInfo = IDS_INFO;
        lpOldCPlInfo->lData  = 0;
        return TRUE;

    case CPL_NEWINQUIRE:

        lpCPlInfo = (LPNEWCPLINFO)lParam2;

        lpCPlInfo->hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_CONSOLE));

        if (!LoadString(ghInstance, IDS_NAME, lpCPlInfo->szName,
                        NELEM(lpCPlInfo->szName))) {
            lpCPlInfo->szName[0] = TEXT('\0');
        }

        if (!LoadString(ghInstance, IDS_INFO, lpCPlInfo->szInfo,
                        NELEM(lpCPlInfo->szInfo))) {
            lpCPlInfo->szInfo[0] = TEXT('\0');
        }

        lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
        lpCPlInfo->dwHelpContext = 0;
        lpCPlInfo->szHelpFile[0] = TEXT('\0');

        return (LONG)TRUE;

    case CPL_DBLCLK:
        ConsolePropertySheet(hwnd);
        break;

    case CPL_EXIT:
        DestroyDbcsMisc();
        UnregisterClasses(ghInstance);
        break;
    }
    return (LONG)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\link.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    link.c

Abstract:

        This file implements the code to save to a link file.

Author:

    Rick Turner (RickTu) Sep-12-1995

--*/

#include "precomp.h"
#pragma hdrstop

#include "shlobj.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "shlobjp.h"
#include "initguid.h"
#include "oleguid.h"
#include "shlguid.h"
#include "shlguidp.h"



BOOL PathIsLink(LPCTSTR szFile)
{
    BOOL fRet;

    LPCTSTR pszExt = PathFindExtension(szFile);

    if (pszExt)
    {
        fRet = (lstrcmpi(TEXT(".lnk"), pszExt) == 0);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}


BOOL
WereWeStartedFromALnk()
{
    STARTUPINFO si;

    GetStartupInfo( &si );

    // Check to make sure we were started from a link
    if (si.dwFlags & STARTF_TITLEISLINKNAME)
    {
        if (PathIsLink(si.lpTitle))
            return TRUE;
    }

    return FALSE;
}



BOOL
SetLinkValues(
    PCONSOLE_STATE_INFO pStateInfo
    )

/*++

Routine Description:

    This routine writes values to the link file that spawned this console
    window.  The link file name is still in the startinfo structure.

Arguments:

    pStateInfo - pointer to structure containing information

Return Value:

    none

--*/

{

    STARTUPINFO si;
    IShellLink * psl;
    IPersistFile * ppf;
    IShellLinkDataList * psldl;
    NT_CONSOLE_PROPS props;
#if defined(FE_SB)
    NT_FE_CONSOLE_PROPS fe_props;
#endif
    BOOL bRet;

    GetStartupInfo( &si );

    // Check to make sure we were started from a link
    if (!(si.dwFlags & STARTF_TITLEISLINKNAME) )
        return FALSE;

    // Make sure we are dealing w/a link file
    if (!PathIsLink(si.lpTitle))
        return FALSE;

    // Ok, load the link so we can modify it...
    if (FAILED(SHCoCreateInstance( NULL, &CLSID_ShellLink, NULL, &IID_IShellLink, &psl )))
        return FALSE;

    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
    {
        WCHAR wszPath[ MAX_PATH ];

        StrToOleStr(wszPath, si.lpTitle );
        if (FAILED(ppf->lpVtbl->Load(ppf, wszPath, 0)))
        {
            ppf->lpVtbl->Release(ppf);
            psl->lpVtbl->Release(psl);
            return FALSE;
        }
    }

    // Now the link is loaded, generate new console settings section to replace
    // the one in the link.

    ((LPDBLIST)&props)->cbSize      = sizeof(props);
    ((LPDBLIST)&props)->dwSignature = NT_CONSOLE_PROPS_SIG;
    props.wFillAttribute            = pStateInfo->ScreenAttributes;
    props.wPopupFillAttribute       = pStateInfo->PopupAttributes;
    props.dwScreenBufferSize        = pStateInfo->ScreenBufferSize;
    props.dwWindowSize              = pStateInfo->WindowSize;
    props.dwWindowOrigin.X          = (SHORT)pStateInfo->WindowPosX;
    props.dwWindowOrigin.Y          = (SHORT)pStateInfo->WindowPosY;
    props.nFont                     = 0;
    props.nInputBufferSize          = 0;
    props.dwFontSize                = pStateInfo->FontSize;
    props.uFontFamily               = pStateInfo->FontFamily;
    props.uFontWeight               = pStateInfo->FontWeight;
    CopyMemory( props.FaceName, pStateInfo->FaceName, sizeof(props.FaceName) );
    props.uCursorSize               = pStateInfo->CursorSize;
    props.bFullScreen               = pStateInfo->FullScreen;
    props.bQuickEdit                = pStateInfo->QuickEdit;
    props.bInsertMode               = pStateInfo->InsertMode;
    props.bAutoPosition             = pStateInfo->AutoPosition;
    props.uHistoryBufferSize        = pStateInfo->HistoryBufferSize;
    props.uNumberOfHistoryBuffers   = pStateInfo->NumberOfHistoryBuffers;
    props.bHistoryNoDup             = pStateInfo->HistoryNoDup;
    CopyMemory( props.ColorTable, pStateInfo->ColorTable, sizeof(props.ColorTable) );

#if defined(FE_SB)
    ((LPDBLIST)&fe_props)->cbSize      = sizeof(fe_props);
    ((LPDBLIST)&fe_props)->dwSignature = NT_FE_CONSOLE_PROPS_SIG;
    fe_props.uCodePage                 = pStateInfo->CodePage;
#endif

    if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, &psldl)))
    {
        //
        // Store the changes back into the link...
        //
        psldl->lpVtbl->RemoveDataBlock( psldl, NT_CONSOLE_PROPS_SIG );
        psldl->lpVtbl->AddDataBlock( psldl, (LPVOID)&props );

#if defined(FE_SB)
        if (gfFESystem) {
            psldl->lpVtbl->RemoveDataBlock( psldl, NT_FE_CONSOLE_PROPS_SIG );
            psldl->lpVtbl->AddDataBlock( psldl, (LPVOID)&fe_props );
        }
#endif

        psldl->lpVtbl->Release( psldl );
    }



    bRet = SUCCEEDED(ppf->lpVtbl->Save( ppf, NULL, TRUE ));
    ppf->lpVtbl->Release(ppf);
    psl->lpVtbl->Release(psl);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\menu.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    menu.h

Abstract:

    This module contains the definitions for console system menu

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

/*
 * DIALOG IDs
 *
 */

#define CM_SETCOLOR       (WM_USER+1)
#define CM_PREVIEW_UPDATE (WM_USER+2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <tchar.h>
#include <winuserp.h>
#include <winbasep.h>
#include <winconp.h>
#include <wingdip.h>
#include <commctrl.h>
#include "menu.h"
#include "dialogs.h"
#include "console.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\preview.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    preview.c

Abstract:

    This module contains the code for console preview window

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


/* ----- Equates ----- */
#define PREVIEW_HSCROLL  0x01
#define PREVIEW_VSCROLL  0x02


/* ----- Prototypes ----- */

void AspectPoint(
    RECT* rectPreview,
    POINT* pt);

LONG AspectScale(
    LONG n1,
    LONG n2,
    LONG m);


/* ----- Globals ----- */

POINT NonClientSize;
RECT WindowRect;
DWORD PreviewFlags;


VOID
UpdatePreviewRect(VOID)

/*++

    Update the global window size and dimensions

--*/

{
    POINT MinSize;
    POINT MaxSize;
    POINT WindowSize;
    PFONT_INFO lpFont;
    HMONITOR hMonitor;
    MONITORINFO mi;

    /*
     * Get the font pointer
     */
    lpFont = &FontInfo[CurrentFontIndex];

    /*
     * Get the window size
     */
    MinSize.x = (GetSystemMetrics(SM_CXMIN)-NonClientSize.x) / lpFont->Size.X;
    MinSize.y = (GetSystemMetrics(SM_CYMIN)-NonClientSize.y) / lpFont->Size.Y;
    MaxSize.x = GetSystemMetrics(SM_CXFULLSCREEN) / lpFont->Size.X;
    MaxSize.y = GetSystemMetrics(SM_CYFULLSCREEN) / lpFont->Size.Y;
    WindowSize.x = max(MinSize.x, min(MaxSize.x, gpStateInfo->WindowSize.X));
    WindowSize.y = max(MinSize.y, min(MaxSize.y, gpStateInfo->WindowSize.Y));

    /*
     * Get the window rectangle, making sure it's at least twice the
     * size of the non-client area.
     */
    WindowRect.left = gpStateInfo->WindowPosX;
    WindowRect.top = gpStateInfo->WindowPosY;
    WindowRect.right = WindowSize.x * lpFont->Size.X + NonClientSize.x;
    if (WindowRect.right < NonClientSize.x * 2) {
        WindowRect.right = NonClientSize.x * 2;
    }
    WindowRect.right += WindowRect.left;
    WindowRect.bottom = WindowSize.y * lpFont->Size.Y + NonClientSize.y;
    if (WindowRect.bottom < NonClientSize.y * 2) {
        WindowRect.bottom = NonClientSize.y * 2;
    }
    WindowRect.bottom += WindowRect.top;

    /*
     * Get information about the monitor we're on
     */
    hMonitor = MonitorFromRect(&WindowRect, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    gcxScreen = mi.rcWork.right - mi.rcWork.left;
    gcyScreen = mi.rcWork.bottom - mi.rcWork.top;

    /*
     * Convert window rectangle to monitor relative coordinates
     */
    WindowRect.right  -= WindowRect.left;
    WindowRect.left   -= mi.rcWork.left;
    WindowRect.bottom -= WindowRect.top;
    WindowRect.top    -= mi.rcWork.top;

    /*
     * Update the display flags
     */
    if (WindowSize.x < gpStateInfo->ScreenBufferSize.X) {
        PreviewFlags |= PREVIEW_HSCROLL;
    } else {
        PreviewFlags &= ~PREVIEW_HSCROLL;
    }
    if (WindowSize.y < gpStateInfo->ScreenBufferSize.Y) {
        PreviewFlags |= PREVIEW_VSCROLL;
    } else {
        PreviewFlags &= ~PREVIEW_VSCROLL;
    }
}


VOID
InvalidatePreviewRect(HWND hWnd)

/*++

    Invalidate the area covered by the preview "window"

--*/

{
    RECT rectWin;
    RECT rectPreview;

    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin.left   = WindowRect.left;
    rectWin.top    = WindowRect.top;
    rectWin.right  = WindowRect.left + WindowRect.right;
    rectWin.bottom = WindowRect.top + WindowRect.bottom;
    AspectPoint(&rectPreview, (POINT*)&rectWin.left);
    AspectPoint(&rectPreview, (POINT*)&rectWin.right);

    /*
     * Invalidate the area covered by the preview "window"
     */
    InvalidateRect(hWnd, &rectWin, FALSE);
}


VOID
PreviewPaint(
    PAINTSTRUCT* pPS,
    HWND hWnd
    )

/*++

    Paints the font preview.  This is called inside the paint message
    handler for the preview window

--*/

{
    RECT rectWin;
    RECT rectPreview;
    HBRUSH hbrFrame;
    HBRUSH hbrTitle;
    HBRUSH hbrOld;
    HBRUSH hbrClient;
    HBRUSH hbrBorder;
    HBRUSH hbrButton;
    HBRUSH hbrScroll;
    HBRUSH hbrDesktop;
    POINT ptButton;
    POINT ptScroll;
    HDC hDC;
    HBITMAP hBitmap;
    HBITMAP hBitmapOld;
    COLORREF rgbClient;

    /*
     * Get the size of the preview "screen"
     */
    GetClientRect(hWnd, &rectPreview);

    /*
     * Get the dimensions of the preview "window" and scale it to the
     * preview "screen"
     */
    rectWin = WindowRect;
    AspectPoint(&rectPreview, (POINT*)&rectWin.left);
    AspectPoint(&rectPreview, (POINT*)&rectWin.right);

    /*
     * Compute the dimensions of some other window components
     */
    ptButton.x = GetSystemMetrics(SM_CXSIZE);
    ptButton.y = GetSystemMetrics(SM_CYSIZE);
    AspectPoint(&rectPreview, &ptButton);
    ptButton.y *= 2;       /* Double the computed size for "looks" */
    ptScroll.x = GetSystemMetrics(SM_CXVSCROLL);
    ptScroll.y = GetSystemMetrics(SM_CYHSCROLL);
    AspectPoint(&rectPreview, &ptScroll);

    /*
     * Create the memory device context
     */
    hDC = CreateCompatibleDC(pPS->hdc);
    hBitmap = CreateCompatibleBitmap(pPS->hdc,
                                     rectPreview.right,
                                     rectPreview.bottom);
    hBitmapOld = SelectObject(hDC, hBitmap);

    /*
     * Create the brushes
     */
    hbrBorder  = CreateSolidBrush(GetSysColor(COLOR_ACTIVEBORDER));
    hbrTitle   = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
    hbrFrame   = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME));
    hbrButton  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    hbrScroll  = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR));
    hbrDesktop = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    rgbClient  = GetNearestColor(hDC, ScreenBkColor(gpStateInfo));
    hbrClient  = CreateSolidBrush(rgbClient);

    /*
     * Erase the clipping area
     */
    FillRect(hDC, &(pPS->rcPaint), hbrDesktop);

    /*
     * Fill in the whole window with the client brush
     */
    hbrOld = SelectObject(hDC, hbrClient);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, rectWin.bottom - 1, PATCOPY);

    /*
     * Fill in the caption bar
     */
    SelectObject(hDC, hbrTitle);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           rectWin.right - 7, ptButton.y - 2, PATCOPY);

    /*
     * Draw the "buttons"
     */
    SelectObject(hDC, hbrButton);
    PatBlt(hDC, rectWin.left + 3, rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 1,
           rectWin.top + 3,
           ptButton.x, ptButton.y - 2, PATCOPY);
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 3 + ptButton.x, rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptButton.x - 1,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4 - 2 * ptButton.x - 2,
           rectWin.top + 3,
           1, ptButton.y - 2, PATCOPY);

    /*
     * Draw the scrollbars
     */
    SelectObject(hDC, hbrScroll);
    if (PreviewFlags & PREVIEW_HSCROLL) {
        PatBlt(hDC, rectWin.left + 3,
               rectWin.top + rectWin.bottom - 4 - ptScroll.y,
               rectWin.right - 7, ptScroll.y, PATCOPY);
    }
    if (PreviewFlags & PREVIEW_VSCROLL) {
        PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
               rectWin.top + 1 + ptButton.y + 1,
               ptScroll.x, rectWin.bottom - 6 - ptButton.y, PATCOPY);
        if (PreviewFlags & PREVIEW_HSCROLL) {
            SelectObject(hDC, hbrFrame);
            PatBlt(hDC, rectWin.left + rectWin.right - 5 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 4 - ptScroll.y,
                   1, ptScroll.y, PATCOPY);
            PatBlt(hDC, rectWin.left + rectWin.right - 4 - ptScroll.x,
                   rectWin.top + rectWin.bottom - 5 - ptScroll.y,
                   ptScroll.x, 1, PATCOPY);
        }
    }

    /*
     * Draw the interior window frame and caption frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 2,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + rectWin.bottom - 4,
           rectWin.right - 5, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 4, rectWin.top + 2,
           1, rectWin.bottom - 5, PATCOPY);
    PatBlt(hDC, rectWin.left + 2, rectWin.top + 1 + ptButton.y,
           rectWin.right - 5, 1, PATCOPY);

    /*
     * Draw the border
     */
    SelectObject(hDC, hbrBorder);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + 1,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + 1, rectWin.top + rectWin.bottom - 3,
           rectWin.right - 3, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 3, rectWin.top + 1,
           1, rectWin.bottom - 3, PATCOPY);

    /*
     * Draw the exterior window frame
     */
    SelectObject(hDC, hbrFrame);
    PatBlt(hDC, rectWin.left, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left, rectWin.top + rectWin.bottom - 2,
           rectWin.right - 1, 1, PATCOPY);
    PatBlt(hDC, rectWin.left + rectWin.right - 2, rectWin.top,
           1, rectWin.bottom - 1, PATCOPY);

    /*
     * Copy the memory device context to the screen device context
     */
    BitBlt(pPS->hdc, 0, 0, rectPreview.right, rectPreview.bottom,
           hDC, 0, 0, SRCCOPY);

    /*
     * Clean up everything
     */
    SelectObject(hDC, hbrOld);
    SelectObject(hDC, hBitmapOld);
    DeleteObject(hbrBorder);
    DeleteObject(hbrFrame);
    DeleteObject(hbrTitle);
    DeleteObject(hbrClient);
    DeleteObject(hbrButton);
    DeleteObject(hbrScroll);
    DeleteObject(hbrDesktop);
    DeleteObject(hBitmap);
    DeleteDC(hDC);
}


LRESULT
PreviewWndProc(
    HWND hWnd,
    UINT wMessage,
    WPARAM wParam,
    LPARAM lParam
    )

/*
 * PreviewWndProc
 *      Handles the preview window
 */

{
    PAINTSTRUCT ps;
    LPCREATESTRUCT lpcs;
    RECT rcWindow;
    int cx;
    int cy;

    switch (wMessage) {
    case WM_CREATE:
        /*
         * Figure out space used by non-client area
         */
        SetRect(&rcWindow, 0, 0, 50, 50);
        AdjustWindowRect(&rcWindow, WS_OVERLAPPEDWINDOW, FALSE);
        NonClientSize.x = rcWindow.right - rcWindow.left - 50;
        NonClientSize.y = rcWindow.bottom - rcWindow.top - 50;

        /*
         * Compute the size of the preview "window"
         */
        UpdatePreviewRect();

        /*
         * Scale the window so it has the same aspect ratio as the screen
         */
        lpcs = (LPCREATESTRUCT)lParam;
        cx = lpcs->cx;
        cy = AspectScale(gcyScreen, gcxScreen, cx);
        if (cy > lpcs->cy) {
            cy = lpcs->cy;
            cx = AspectScale(gcxScreen, gcyScreen, cy);
        }
        MoveWindow(hWnd, lpcs->x, lpcs->y, cx, cy, TRUE);
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        PreviewPaint(&ps, hWnd);
        EndPaint(hWnd, &ps);
        break;

    case CM_PREVIEW_UPDATE:
        InvalidatePreviewRect(hWnd);
        UpdatePreviewRect();

        /*
         * Make sure the preview "screen" has the correct aspect ratio
         */
        GetWindowRect(hWnd, &rcWindow);
        cx = rcWindow.right - rcWindow.left;
        cy = AspectScale(gcyScreen, gcxScreen, cx);
        if (cy != rcWindow.bottom - rcWindow.top) {
            SetWindowPos(hWnd, NULL, 0, 0, cx, cy, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
    
        InvalidatePreviewRect(hWnd);
        break;

    default:
        return DefWindowProc(hWnd, wMessage, wParam, lParam);
    }
    return 0L;
}


/*  AspectScale
 *      Performs the following calculation in LONG arithmetic to avoid
 *      overflow:
 *          return = n1 * m / n2
 *      This can be used to make an aspect ration calculation where n1/n2
 *      is the aspect ratio and m is a known value.  The return value will
 *      be the value that corresponds to m with the correct apsect ratio.
 */

LONG AspectScale(
    LONG n1,
    LONG n2,
    LONG m)
{
    LONG Temp;

    Temp = n1 * m + (n2 >> 1);
    return Temp / n2;
}

/*  AspectPoint
 *      Scales a point to be preview-sized instead of screen-sized.
 */

void AspectPoint(
    RECT* rectPreview,
    POINT* pt)
{
    pt->x = AspectScale(rectPreview->right, gcxScreen, pt->x);
    pt->y = AspectScale(rectPreview->bottom, gcyScreen, pt->y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\misc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    misc.c

Abstract:

        This file implements the NT console server font routines.

Author:

    Therese Stowell (thereses) 22-Jan-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG_PRINT
ULONG gDebugFlag = 0 ;
// ULONG gDebugFlag = _DBGOUTPUT | _DBGCHARS | _DBGFONTS | _DBGFONTS2 ;
#endif

PFONT_INFO FontInfo = NULL;
ULONG FontInfoLength;
ULONG NumberOfFonts;
BOOL gbEnumerateFaces = FALSE;


#define FE_ABANDONFONT 0
#define FE_SKIPFONT    1
#define FE_FONTOK      2

/*
 * Initial default fonts and face names
 */
PFACENODE gpFaceNames = NULL;

/*
 * TTPoints -- Initial font pixel heights for TT fonts
 */
SHORT TTPoints[] = {
    5, 6, 7, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};
#if defined(FE_SB)
/*
 * TTPointsDbcs -- Initial font pixel heights for TT fonts of DBCS.
 * So, This list except odd point size because font width is (SBCS:DBCS != 1:2).
 */
SHORT TTPointsDbcs[] = {
    6, 8, 10, 12, 14, 16, 18, 20, 24, 28, 36, 72
};
#endif


typedef struct _FONTENUMDATA {
    HDC hDC;
    BOOL bFindFaces;
    ULONG ulFE;
    PSHORT pTTPoints;
    UINT nTTPoints;
} FONTENUMDATA, *PFONTENUMDATA;


PFACENODE
AddFaceNode(PFACENODE *ppStart, LPTSTR ptsz) {
    PFACENODE pNew;
    PFACENODE *ppTmp;
    int cb;

    /*
     * Is it already here?
     */
    for (ppTmp = ppStart; *ppTmp; ppTmp = &((*ppTmp)->pNext)) {
        if (_tcscmp(((*ppTmp)->atch), ptsz) == 0) {
            // already there !
            return *ppTmp;
        }
    }

    cb = (_tcslen(ptsz) + 1) * sizeof(TCHAR);
    pNew = (PFACENODE)HeapAlloc(RtlProcessHeap(),0,sizeof(FACENODE) + cb);
    if (pNew == NULL) {
        return NULL;
    }

    pNew->pNext = NULL;
    pNew->dwFlag = 0;
    _tcscpy(pNew->atch, ptsz);
    *ppTmp = pNew;
    return pNew;
}


VOID
DestroyFaceNodes( VOID ) {
    PFACENODE pNext;
    PFACENODE pTmp;

    pTmp = gpFaceNames;
    while (pTmp != NULL) {
        pNext = pTmp->pNext;
        HeapFree(RtlProcessHeap(), 0, pTmp);
        pTmp = pNext;
    }
    gpFaceNames = NULL;
}


int
AddFont(
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    HDC hDC,
    PFACENODE pFN
    )

/*++

    Add the font desribed by the LOGFONT structure to the font table if
    it's not already there.

--*/

{
    HFONT hFont;
    TEXTMETRIC tm;
    LONG nFont;
    COORD SizeToShow;
    COORD SizeActual;
    COORD SizeWant;
    BYTE tmFamily;
    SIZE Size;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;

    /* get font info */
    SizeWant.X = (SHORT)pelf->elfLogFont.lfWidth;
    SizeWant.Y = (SHORT)pelf->elfLogFont.lfHeight;

CreateBoldFont:
    pelf->elfLogFont.lfQuality = DEFAULT_QUALITY;
    hFont = CreateFontIndirect(&pelf->elfLogFont);
    if (!hFont) {
        DBGFONTS(("    REJECT  font (can't create)\n"));
        return FE_SKIPFONT;  // same font in other sizes may still be suitable
    }

    DBGFONTS2(("    hFont = %lx\n", hFont));

    //
    // BUGBUG
    // For reasons unbeknownst to me, removing this code causes GDI
    // to yack, claiming that the font is owned by another process.
    //

    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, &tm);

    GetTextExtentPoint32(hDC, TEXT("0"), 1, &Size);
    SizeActual.X = (SHORT)Size.cx;
    SizeActual.Y = (SHORT)(tm.tmHeight + tm.tmExternalLeading);
    DBGFONTS2(("    actual size %d,%d\n", SizeActual.X, SizeActual.Y));
    tmFamily = tm.tmPitchAndFamily;
    if (TM_IS_TT_FONT(tmFamily) && (SizeWant.Y >= 0)) {
        SizeToShow = SizeWant;
        if (SizeWant.X == 0) {
            // Asking for zero width height gets a default aspect-ratio width.
            // It's better to show that width rather than 0.
            SizeToShow.X = SizeActual.X;
        }
    } else {
        SizeToShow = SizeActual;
    }

    //
    // The size shouldn't be zero. This is to help catch Windows Bug #332453.
    //
    ASSERT(SizeActual.X != 0 && SizeActual.Y != 0 && "If you hit this please e-mail jasonsch");

    DBGFONTS2(("    SizeToShow = (%d,%d), SizeActual = (%d,%d)\n",
            SizeToShow.X, SizeToShow.Y, SizeActual.X, SizeActual.Y));

    //
    // BUGBUG
    // There's a GDI bug - this assert fails occasionally.
    //ASSERT (tm.tmMaxCharWidth == pntm->tmMaxCharWidth);

    /*
     * NOW, determine whether this font entry has already been cached
     * LATER : it may be possible to do this before creating the font, if
     * we can trust the dimensions & other info from pntm.
     * Sort by size:
     *  1) By pixelheight (negative Y values)
     *  2) By height (as shown)
     *  3) By width (as shown)
     */
    for (nFont = 0; nFont < (LONG)NumberOfFonts; ++nFont) {
        COORD SizeShown;

        if (FontInfo[nFont].hFont == NULL) {
            DBGFONTS(("!   Font %x has a NULL hFont\n", nFont));
            continue;
        }

        if (FontInfo[nFont].SizeWant.X > 0) {
            SizeShown.X = FontInfo[nFont].SizeWant.X;
        } else {
            SizeShown.X = FontInfo[nFont].Size.X;
        }

        if (FontInfo[nFont].SizeWant.Y > 0) {
            // This is a font specified by cell height.
            SizeShown.Y = FontInfo[nFont].SizeWant.Y;
        } else {
            SizeShown.Y = FontInfo[nFont].Size.Y;
            if (FontInfo[nFont].SizeWant.Y < 0) {
                // This is a TT font specified by character height.
                if (SizeWant.Y < 0 && SizeWant.Y > FontInfo[nFont].SizeWant.Y) {
                    // Requested pixelheight is smaller than this one.
                    DBGFONTS(("INSERT %d pt at %x, before %d pt\n",
                            -SizeWant.Y, nFont, -FontInfo[nFont].SizeWant.Y));
                    break;
                }
            }
        }

        // DBGFONTS(("    SizeShown(%x) = (%d,%d)\n",nFont,SizeShown.X,SizeShown.Y));

        if (SIZE_EQUAL(SizeShown, SizeToShow) &&
                FontInfo[nFont].Family == tmFamily &&
                FontInfo[nFont].Weight == tm.tmWeight &&
                _tcscmp(FontInfo[nFont].FaceName, ptszFace) == 0) {
            /*
             * Already have this font
             */
            DBGFONTS2(("    Already have the font\n"));
            DeleteObject(hFont);
            return FE_FONTOK;
        }


        if ((SizeToShow.Y < SizeShown.Y) ||
                (SizeToShow.Y == SizeShown.Y && SizeToShow.X < SizeShown.X)) {
            /*
             * This new font is smaller than nFont
             */
            DBGFONTS(("INSERT at %x, SizeToShow = (%d,%d)\n", nFont,
                    SizeToShow.X,SizeToShow.Y));
            break;
        }
    }

    /*
     * If we have to grow our font table, do it
     */
    if (NumberOfFonts == FontInfoLength) {
        PFONT_INFO Temp;

        FontInfoLength += FONT_INCREMENT;
        Temp = (PFONT_INFO)HeapReAlloc(RtlProcessHeap(), 0, FontInfo,
                                       sizeof(FONT_INFO) * FontInfoLength);
        if (Temp == NULL) {
            FontInfoLength -= FONT_INCREMENT;
            return FE_ABANDONFONT;  // no point enumerating more - no memory!
        }
        FontInfo = Temp;
    }

    /*
     * The font we are adding should be inserted into the list,
     * if it is smaller than the last one.
     */
    if (nFont < (LONG)NumberOfFonts) {
        RtlMoveMemory(&FontInfo[nFont+1],
                      &FontInfo[nFont],
                      sizeof(FONT_INFO) * (NumberOfFonts - nFont));
    }

    /*
     * Store the font info
     */
    FontInfo[nFont].hFont = hFont;
    FontInfo[nFont].Family = tmFamily;
    FontInfo[nFont].Size = SizeActual;
    if (TM_IS_TT_FONT(tmFamily)) {
        FontInfo[nFont].SizeWant = SizeWant;
    } else {
        FontInfo[nFont].SizeWant.X = 0;
        FontInfo[nFont].SizeWant.Y = 0;
    }
    FontInfo[nFont].Weight = tm.tmWeight;
    FontInfo[nFont].FaceName = pFN->atch;
#if defined(FE_SB)
    FontInfo[nFont].tmCharSet = tm.tmCharSet;
#endif

    ++NumberOfFonts;

    /*
     * If this is a true type font, create a bold version too.
     */
    if (nFontType == TRUETYPE_FONTTYPE && !IS_BOLD(FontInfo[nFont].Weight)) {
          pelf->elfLogFont.lfWeight = FW_BOLD;
          goto CreateBoldFont;
    }

    return FE_FONTOK;  // and continue enumeration
}


VOID
InitializeFonts( VOID )
{
    EnumerateFonts(EF_DEFFACE);  // Just the Default font
}


VOID
DestroyFonts( VOID )
{
    ULONG FontIndex;

    if (FontInfo != NULL) {
        for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
            DeleteObject(FontInfo[FontIndex].hFont);
        }
        HeapFree(RtlProcessHeap(), 0, FontInfo);
        FontInfo = NULL;
        NumberOfFonts = 0;
    }

    DestroyFaceNodes();
}


/*
 * Returns bit combination
 *  FE_ABANDONFONT  - do not continue enumerating this font
 *  FE_SKIPFONT     - skip this font but keep enumerating
 *  FE_FONTOK       - font was created and added to cache or already there
 */
int
FontEnum(
    ENUMLOGFONT *pelf,
    NEWTEXTMETRIC *pntm,
    int nFontType,
    PFONTENUMDATA pfed
    )

/*++

    Is called exactly once by GDI for each font in the system.  This
    routine is used to store the FONT_INFO structure.

--*/

{
    UINT i;
    LPTSTR ptszFace = pelf->elfLogFont.lfFaceName;
    PFACENODE pFN;

    DBGFONTS(("  FontEnum \"%ls\" (%d,%d) weight 0x%lx(%d) %x -- %s\n",
            ptszFace,
            pelf->elfLogFont.lfWidth, pelf->elfLogFont.lfHeight,
            pelf->elfLogFont.lfWeight, pelf->elfLogFont.lfWeight,
            pelf->elfLogFont.lfCharSet,
            pfed->bFindFaces ? "Finding Faces" : "Creating Fonts"));

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //


    if
    (
      !(pelf->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
      (pelf->elfLogFont.lfItalic)                        ||
      !(pntm->ntmFlags & NTM_NONNEGATIVE_AC)
    )
    {
        if (! IsAvailableTTFont(ptszFace)) {
            DBGFONTS(("    REJECT  face (dbcs, variable pitch, italic, or neg a&c)\n"));
            return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
        }
    }

    /*
     * reject TT fonts for whoom family is not modern, that is do not use
     * FF_DONTCARE    // may be surprised unpleasantly
     * FF_DECORATIVE  // likely to be symbol fonts
     * FF_SCRIPT      // cursive, inappropriate for console
     * FF_SWISS OR FF_ROMAN // variable pitch
     */

    if ((nFontType == TRUETYPE_FONTTYPE) &&
            ((pelf->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN)) {
        DBGFONTS(("    REJECT  face (TT but not FF_MODERN)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that aren't OEM
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
#if defined(FE_SB)
            (!gfFESystem || !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet)) &&
#endif
            (pelf->elfLogFont.lfCharSet != OEM_CHARSET)) {
        DBGFONTS(("    REJECT  face (not TT nor OEM)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that are virtical font
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
            (ptszFace[0] == TEXT('@'))) {
        DBGFONTS(("    REJECT  face (not TT and TATEGAKI)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject non-TT fonts that aren't Terminal
     */
    if (gfFESystem && (nFontType != TRUETYPE_FONTTYPE) &&
            (_tcscmp(ptszFace, TEXT("Terminal")) != 0)) {
        DBGFONTS(("    REJECT  face (not TT nor Terminal)\n"));
        return pfed->bFindFaces ? FE_SKIPFONT : FE_ABANDONFONT;
    }

    /*
     * reject Far East TT fonts that aren't Far East charset.
     */
    if (IsAvailableTTFont(ptszFace) &&
        !IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet) &&
        !IsAvailableTTFontCP(ptszFace,0)
       ) {
        DBGFONTS(("    REJECT  face (Far East TT and not Far East charset)\n"));
        return FE_SKIPFONT;    // should be enumerate next charset.
    }

    /*
     * Add or find the facename
     */
    pFN = AddFaceNode(&gpFaceNames, ptszFace);
    if (pFN == NULL) {
        return FE_ABANDONFONT;
    }

    if (pfed->bFindFaces) {
        DWORD dwFontType;
        if (nFontType == TRUETYPE_FONTTYPE) {
            DBGFONTS(("NEW TT FACE %ls\n", ptszFace));
            dwFontType = EF_TTFONT;
        } else if (nFontType == RASTER_FONTTYPE) {
            DBGFONTS(("NEW OEM FACE %ls\n",ptszFace));
            dwFontType = EF_OEMFONT;
        }
        pFN->dwFlag |= dwFontType | EF_NEW;
#if defined(FE_SB)
        if (IS_ANY_DBCS_CHARSET(pelf->elfLogFont.lfCharSet))
            pFN->dwFlag |= EF_DBCSFONT;
#endif
        return FE_SKIPFONT;
    }


    if (IS_BOLD(pelf->elfLogFont.lfWeight)) {
        DBGFONTS2(("    A bold font (weight %d)\n", pelf->elfLogFont.lfWeight));
        // return FE_SKIPFONT;
    }

    /*
     * Add the font to the table. If this is a true type font, add the
     * sizes from the array. Otherwise, just add the size we got.
     */
    if (nFontType & TRUETYPE_FONTTYPE) {
        for (i = 0; i < pfed->nTTPoints; i++) {
            pelf->elfLogFont.lfHeight = pfed->pTTPoints[i];
            pelf->elfLogFont.lfWidth  = 0;
            pelf->elfLogFont.lfWeight = 400;
            pfed->ulFE |= AddFont(pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
        }
    } else {
            pfed->ulFE |= AddFont(pelf, pntm, nFontType, pfed->hDC, pFN);
            if (pfed->ulFE & FE_ABANDONFONT) {
                return FE_ABANDONFONT;
            }
    }

    return FE_FONTOK;  // and continue enumeration
}

BOOL
DoFontEnum(
    HDC hDC,
    LPTSTR ptszFace,
    PSHORT pTTPoints,
    UINT nTTPoints)
{
    BOOL bDeleteDC = FALSE;
    FONTENUMDATA fed;
    LOGFONT LogFont;

    DBGFONTS(("DoFontEnum \"%ls\"\n", ptszFace));
    if (hDC == NULL) {
        hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        bDeleteDC = TRUE;
    }

    fed.hDC = hDC;
    fed.bFindFaces = (ptszFace == NULL);
    fed.ulFE = 0;
    fed.pTTPoints = pTTPoints;
    fed.nTTPoints = nTTPoints;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (ptszFace)
        _tcscpy(LogFont.lfFaceName, ptszFace);
    /*
     * EnumFontFamiliesEx function enumerates one font in every face in every character set. 
     */
    EnumFontFamiliesEx(hDC, &LogFont, (FONTENUMPROC)FontEnum, (LPARAM)&fed, 0);
    if (bDeleteDC) {
        DeleteDC(hDC);
    }
    return (fed.ulFE & FE_FONTOK) != 0;
}


VOID
RemoveFace(LPTSTR ptszFace)
{
    DWORD i;
    int nToRemove = 0;

    DBGFONTS(("RemoveFace %ls\n", ptszFace));
    //
    // Delete & Remove fonts with Face Name == ptszFace
    //
    for (i = 0; i < NumberOfFonts; i++) {
        if (_tcscmp(FontInfo[i].FaceName, ptszFace) == 0) {
            BOOL bDeleted = DeleteObject(FontInfo[i].hFont);
            DBGPRINT(("RemoveFace: hFont %lx was %sdeleted\n",
                    FontInfo[i].hFont, bDeleted ? "" : "NOT "));
            FontInfo[i].hFont = NULL;
            nToRemove++;
        } else if (nToRemove > 0) {
            /*
             * Shuffle from FontInfo[i] down nToRemove slots.
             */
            RtlMoveMemory(&FontInfo[i - nToRemove],
                    &FontInfo[i],
                    sizeof(FONT_INFO)*(NumberOfFonts - i));
            NumberOfFonts -= nToRemove;
            i -= nToRemove;
            nToRemove = 0;
        }
    }
    NumberOfFonts -= nToRemove;
}

TCHAR DefaultFaceName[LF_FACESIZE];
COORD DefaultFontSize;
BYTE  DefaultFontFamily;
ULONG DefaultFontIndex = 0;
ULONG CurrentFontIndex = 0;

NTSTATUS
EnumerateFonts(
    DWORD Flags)
{
    TEXTMETRIC tm;
    HDC hDC;
    PFACENODE pFN;
    ULONG ulOldEnumFilter;
    BOOL  bEnumOEMFace = TRUE;
    DWORD FontIndex;
    DWORD dwFontType = 0;

    DBGFONTS(("EnumerateFonts %lx\n", Flags));

    dwFontType = (EF_TTFONT|EF_OEMFONT|EF_DEFFACE) & Flags;

    if (FontInfo == NULL) {
        //
        // allocate memory for the font array
        //
        NumberOfFonts = 0;

        FontInfo = (PFONT_INFO)HeapAlloc(RtlProcessHeap(),0,sizeof(FONT_INFO) * INITIAL_FONTS);
        if (FontInfo == NULL)
            return STATUS_NO_MEMORY;
        FontInfoLength = INITIAL_FONTS;
    }

    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);

    // Before enumeration, turn off font enumeration filters.
    ulOldEnumFilter = SetFontEnumeration(0);
    SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);

    if (Flags & EF_DEFFACE) {
        SelectObject(hDC, GetStockObject(OEM_FIXED_FONT));
        GetTextMetrics(hDC, &tm);
        GetTextFace(hDC, LF_FACESIZE, DefaultFaceName);

        DefaultFontSize.X = (SHORT)(tm.tmMaxCharWidth);
        DefaultFontSize.Y = (SHORT)(tm.tmHeight+tm.tmExternalLeading);
        DefaultFontFamily = tm.tmPitchAndFamily;
#if !defined(FE_SB)
        DBGFONTS(("Default (OEM) Font %ls (%d,%d)\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y));
#else
        if (IS_ANY_DBCS_CHARSET(tm.tmCharSet))
            DefaultFontSize.X /= 2;
        DBGFONTS(("Default (OEM) Font %ls (%d,%d) CharSet 0x%02X\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y,
                tm.tmCharSet));
#endif

        // Make sure we are going to enumerate the OEM face.
        pFN = AddFaceNode(&gpFaceNames, DefaultFaceName);
        if (pFN)
            pFN->dwFlag |= EF_DEFFACE | EF_OEMFONT;
    }

    if (gbEnumerateFaces) {
        /*
         * Set the EF_OLD bit and clear the EF_NEW bit
         * for all previously available faces
         */
        for (pFN = gpFaceNames; pFN; pFN = pFN->pNext) {
            pFN->dwFlag |= EF_OLD;
            pFN->dwFlag &= ~EF_NEW;
        }

        //
        // Use DoFontEnum to get the names of all the suitable Faces
        // All facenames found will be put in gpFaceNames with
        // the EF_NEW bit set.
        //
        DoFontEnum(hDC, NULL, TTPoints, 1);
        gbEnumerateFaces = FALSE;
    }

    // Use DoFontEnum to get all fonts from the system.  Our FontEnum
    // proc puts just the ones we want into an array
    //
    for (pFN = gpFaceNames; pFN; pFN = pFN->pNext) {
        DBGFONTS(("\"%ls\" is %s%s%s%s%s%s\n", pFN->atch,
            pFN->dwFlag & EF_NEW        ? "NEW "        : " ",
            pFN->dwFlag & EF_OLD        ? "OLD "        : " ",
            pFN->dwFlag & EF_ENUMERATED ? "ENUMERATED " : " ",
            pFN->dwFlag & EF_OEMFONT    ? "OEMFONT "    : " ",
            pFN->dwFlag & EF_TTFONT     ? "TTFONT "     : " ",
            pFN->dwFlag & EF_DEFFACE    ? "DEFFACE "    : " "));

        if ((pFN->dwFlag & (EF_OLD|EF_NEW)) == EF_OLD) {
            // The face is no longer available
            RemoveFace(pFN->atch);
            pFN->dwFlag &= ~EF_ENUMERATED;
            continue;
        }
        if ((pFN->dwFlag & dwFontType) == 0) {
            // not the kind of face we want
            continue;
        }
        if (pFN->dwFlag & EF_ENUMERATED) {
            // we already enumerated this face
            continue;
        }

        if (pFN->dwFlag & EF_TTFONT) {
#if defined(FE_SB)
            if (gfFESystem && !IsAvailableTTFontCP(pFN->atch,0))
                DoFontEnum(hDC, pFN->atch, TTPointsDbcs, NELEM(TTPointsDbcs));
            else
#endif
                DoFontEnum(hDC, pFN->atch, TTPoints, NELEM(TTPoints));
        } else {
            DoFontEnum(hDC, pFN->atch, NULL, 0);

            // If we find that the face just enumerated is the same as OEM,
            // reset flag so we don't try to enumerate it again.

            if (!_tcsncmp(pFN->atch, DefaultFaceName, LF_FACESIZE)) {
                bEnumOEMFace = FALSE;
            }
        }
        pFN->dwFlag |= EF_ENUMERATED;
    }


    // After enumerating fonts, restore the font enumeration filter.
    SetFontEnumeration(ulOldEnumFilter);

    DeleteDC(hDC);

#if defined(FE_SB)
    if (gfFESystem )
    {
        for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
            if (FontInfo[FontIndex].Size.X == DefaultFontSize.X &&
                FontInfo[FontIndex].Size.Y == DefaultFontSize.Y &&
                IS_ANY_DBCS_CHARSET(FontInfo[FontIndex].tmCharSet) &&
                FontInfo[FontIndex].Family == DefaultFontFamily) {
                break;
            }
        }
    }
    else
    {
#endif
    for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
        if (FontInfo[FontIndex].Size.X == DefaultFontSize.X &&
            FontInfo[FontIndex].Size.Y == DefaultFontSize.Y &&
            FontInfo[FontIndex].Family == DefaultFontFamily) {
            break;
        }
    }
#if defined(FE_SB)
    }
#endif
    ASSERT(FontIndex < NumberOfFonts);
    if (FontIndex < NumberOfFonts) {
        DefaultFontIndex = FontIndex;
    } else {
        DefaultFontIndex = 0;
    }
    DBGFONTS(("EnumerateFonts : DefaultFontIndex = %ld\n", DefaultFontIndex));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\console\registry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This file contains functions to read and _rite values
    to the registry.

Author:

    Jerry Shea (JerrySh) 30-Sep-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <shlwapi.h>

#define CONSOLE_REGISTRY_CURRENTPAGE  (L"CurrentPage")
extern BOOL	g_fAutoComplete;
extern BOOL	g_fSaveAutoCompleteState;


NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegDeleteKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey
    )
{
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Delete the subkey
    //

    return NtDeleteValueKey(
              hKey,
              &SubKey
              );
}

NTSTATUS
MyRegCreateKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtCreateKey(
                    phResult,
                    KEY_READ | KEY_WRITE,
                    &Obja,
                    0,
                    NULL,
                    0,
                    NULL
                    );
}

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwValueLength;
    KeyValueInformation = HeapAlloc(RtlProcessHeap(),0,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlCopyMemory(lpData,
            KeyValueInformation->Data,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwValueLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    HeapFree(RtlProcessHeap(),0,KeyValueInformation);
    return Status;
}


#if defined(FE_SB)
NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    )
{
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + dwDataLength;
    KeyValueInformation = LocalAlloc(LPTR,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtEnumerateValueKey(
                hKey,
                dwIndex,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->NameLength <= dwValueLength);
        RtlMoveMemory(lpValueName,
                      KeyValueInformation->Name,
                      KeyValueInformation->NameLength);
        lpValueName[ KeyValueInformation->NameLength >> 1 ] = UNICODE_NULL;


        ASSERT(KeyValueInformation->DataLength <= dwDataLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ ||
            KeyValueInformation->Type ==REG_MULTI_SZ
           ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwDataLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    LocalFree(KeyValueInformation);
    return Status;
}
#endif

LPWSTR
TranslateConsoleTitle(
    LPWSTR ConsoleTitle
    )
/*++

    this routine translates path characters into '_' characters because
    the NT registry apis do not allow the creation of keys with
    names that contain path characters.  it allocates a buffer that
    must be freed.

--*/
{
    int ConsoleTitleLength, i;
    LPWSTR TranslatedTitle;

    ConsoleTitleLength = lstrlenW(ConsoleTitle) + 1;
    TranslatedTitle = HeapAlloc(RtlProcessHeap(), 0,
                                ConsoleTitleLength * sizeof(WCHAR));
    if (TranslatedTitle == NULL) {
        return NULL;
    }
    for (i = 0; i < ConsoleTitleLength; i++) {
        if (ConsoleTitle[i] == '\\') {
            TranslatedTitle[i] = (WCHAR)'_';
        } else {
            TranslatedTitle[i] = ConsoleTitle[i];
        }
    }
    return TranslatedTitle;
}


NTSTATUS
MyRegSetValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwType,
    IN LPVOID lpData,
    IN DWORD cbData
    )
{
    UNICODE_STRING ValueName;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    return NtSetValueKey(
                    hKey,
                    &ValueName,
                    0,
                    dwType,
                    lpData,
                    cbData
                    );
}


NTSTATUS
MyRegUpdateValue(
    IN HANDLE hConsoleKey,
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwType,
    IN LPVOID lpData,
    IN DWORD cbData
    )
{
    NTSTATUS Status;
    BYTE Data[MAX_PATH];

    //
    // If this is not the main console key but the value is the same,
    // delete it. Otherwise, set it.
    //

    if (hConsoleKey != hKey) {
        Status = MyRegQueryValue(hConsoleKey, lpValueName, sizeof(Data), Data);
        if (NT_SUCCESS(Status)) {
            if (RtlCompareMemory(lpData, Data, cbData) == cbData) {
                return MyRegDeleteKey(hKey, lpValueName);
            }
        }
    }

    return MyRegSetValue(hKey, lpValueName, dwType, lpData, cbData);
}


PCONSOLE_STATE_INFO
InitRegistryValues(VOID)

/*++

Routine Description:

    This routine allocates a state info structure and fill it in with
    default values.

Arguments:

    none

Return Value:

    pStateInfo - pointer to structure to receive information

--*/

{
    PCONSOLE_STATE_INFO pStateInfo;

    pStateInfo = HeapAlloc(RtlProcessHeap(), 0, sizeof(CONSOLE_STATE_INFO));
    if (pStateInfo == NULL) {
        return NULL;
    }

    pStateInfo->Length = sizeof(CONSOLE_STATE_INFO);
    pStateInfo->ScreenAttributes = 0x07;            // white on black
    pStateInfo->PopupAttributes = 0xf5;             // purple on white
    pStateInfo->InsertMode = FALSE;
    pStateInfo->QuickEdit = FALSE;
    pStateInfo->FullScreen = FALSE;
    pStateInfo->ScreenBufferSize.X = 80;
    pStateInfo->ScreenBufferSize.Y = 25;
    pStateInfo->WindowSize.X = 80;
    pStateInfo->WindowSize.Y = 25;
    pStateInfo->WindowPosX = 0;
    pStateInfo->WindowPosY = 0;
    pStateInfo->AutoPosition = TRUE;
    pStateInfo->FontSize.X = 0;
    pStateInfo->FontSize.Y = 0;
    pStateInfo->FontFamily = 0;
    pStateInfo->FontWeight = 0;
    pStateInfo->FaceName[0] = TEXT('\0');
    pStateInfo->CursorSize = 25;
    pStateInfo->HistoryBufferSize = 25;
    pStateInfo->NumberOfHistoryBuffers = 4;
    pStateInfo->HistoryNoDup = 0;
    pStateInfo->ColorTable[ 0] = RGB(0,   0,   0   );
    pStateInfo->ColorTable[ 1] = RGB(0,   0,   0x80);
    pStateInfo->ColorTable[ 2] = RGB(0,   0x80,0   );
    pStateInfo->ColorTable[ 3] = RGB(0,   0x80,0x80);
    pStateInfo->ColorTable[ 4] = RGB(0x80,0,   0   );
    pStateInfo->ColorTable[ 5] = RGB(0x80,0,   0x80);
    pStateInfo->ColorTable[ 6] = RGB(0x80,0x80,0   );
    pStateInfo->ColorTable[ 7] = RGB(0xC0,0xC0,0xC0);
    pStateInfo->ColorTable[ 8] = RGB(0x80,0x80,0x80);
    pStateInfo->ColorTable[ 9] = RGB(0,   0,   0xFF);
    pStateInfo->ColorTable[10] = RGB(0,   0xFF,0   );
    pStateInfo->ColorTable[11] = RGB(0,   0xFF,0xFF);
    pStateInfo->ColorTable[12] = RGB(0xFF,0,   0   );
    pStateInfo->ColorTable[13] = RGB(0xFF,0,   0xFF);
    pStateInfo->ColorTable[14] = RGB(0xFF,0xFF,0   );
    pStateInfo->ColorTable[15] = RGB(0xFF,0xFF,0xFF);
#if defined(FE_SB)
    pStateInfo->CodePage = OEMCP; // scotthsu
#endif
    pStateInfo->hWnd = NULL;
    pStateInfo->ConsoleTitle[0] = TEXT('\0');

    g_fAutoComplete = TRUE;

    return pStateInfo;
}




#define SZ_REGKEY_CMDAUTOCOMPLETE           TEXT("Software\\Microsoft\\Command Processor")
#define SZ_REGVALUE_CMDAUTOCOMPLETE         TEXT("CompletionChar")
#define DWORD_CMD_TAB_AUTOCOMPLETE_ON       0x00000009          // 9 is tab
#define DWORD_CMD_TAB_AUTOCOMPLETE_OFF      0x00000020          // 20 is space which turns it off.

BOOL
IsAutoCompleteOn(
    void
    )
{
    DWORD dwType;
    DWORD dwValue = DWORD_CMD_TAB_AUTOCOMPLETE_ON;
    DWORD cbSize = sizeof(dwValue);

    if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_CMDAUTOCOMPLETE, SZ_REGVALUE_CMDAUTOCOMPLETE, &dwType, (LPBYTE)&dwValue, &cbSize)) ||
        (REG_DWORD != dwType))
    {
        dwValue = DWORD_CMD_TAB_AUTOCOMPLETE_ON;    // Fall back to the default value.
    }

    return (DWORD_CMD_TAB_AUTOCOMPLETE_ON == dwValue);
}


void
SaveAutoCompleteSetting(
    IN BOOL fAutoComplete
    )
{
    // Only over write the registry value if someone has changed the value.
    if (g_fSaveAutoCompleteState)
    {
        DWORD dwValue = (fAutoComplete ? DWORD_CMD_TAB_AUTOCOMPLETE_ON : DWORD_CMD_TAB_AUTOCOMPLETE_OFF);

        SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CMDAUTOCOMPLETE, SZ_REGVALUE_CMDAUTOCOMPLETE, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
    }
}


DWORD
GetRegistryValues(
    PCONSOLE_STATE_INFO pStateInfo
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    pStateInfo - optional pointer to structure to receive information

Return Value:

    current page number

--*/

{
    HANDLE hCurrentUserKey;
    HANDLE hConsoleKey;
    HANDLE hTitleKey;
    NTSTATUS Status;
    LPWSTR TranslatedTitle;
    DWORD dwValue;
    DWORD dwRet = 0;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the current user registry key
    //

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    //
    // Open the console registry key
    //

    Status = MyRegOpenKey(hCurrentUserKey,
                          CONSOLE_REGISTRY_STRING,
                          &hConsoleKey);
    if (!NT_SUCCESS(Status)) {
        NtClose(hCurrentUserKey);
        return 0;
    }

    //
    // If there is no structure to fill out, just get the current
    // page and bail out.
    //

    if (pStateInfo == NULL) {
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                       CONSOLE_REGISTRY_CURRENTPAGE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
            dwRet = dwValue;
        }
        goto CloseKeys;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pStateInfo->ConsoleTitle[0] != TEXT('\0')) {
        TranslatedTitle = TranslateConsoleTitle(pStateInfo->ConsoleTitle);
        if (TranslatedTitle == NULL) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return 0;
        }
        Status = MyRegOpenKey(hConsoleKey,
                              TranslatedTitle,
                              &hTitleKey);
        HeapFree(RtlProcessHeap(),0,TranslatedTitle);
        if (!NT_SUCCESS(Status)) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return 0;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    //
    // Initial screen fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FILLATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->ScreenAttributes = (WORD)dwValue;
    }

    //
    // Initial popup fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_POPUPATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->PopupAttributes = (WORD)dwValue;
    }

    //
    // Initial color table
    //

    for (i = 0; i < 16; i++) {
        wsprintf(awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        if (NT_SUCCESS(MyRegQueryValue(hTitleKey, awchBuffer,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
            pStateInfo->ColorTable[i] = dwValue;
        }
    }

    //
    // Initial insert mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_INSERTMODE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->InsertMode = !!dwValue;
    }

    //
    // Initial quick edit mode
    //
    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_QUICKEDIT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->QuickEdit = !!dwValue;
    }

    //
    // Initial autocomplete mode
    //
    g_fAutoComplete = IsAutoCompleteOn();

#ifdef i386
    //
    // Initial full screen mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FULLSCR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FullScreen = !!dwValue;
    }
#endif
#if defined(FE_SB) // scotthsu
    //
    // Initial code page
    //

    ASSERT(OEMCP != 0);
    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CODEPAGE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        if (IsValidCodePage(dwValue)) {
            pStateInfo->CodePage = (UINT) dwValue;
        }
    }
#endif

    //
    // Initial screen buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_BUFFERSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->ScreenBufferSize.X = LOWORD(dwValue);
        pStateInfo->ScreenBufferSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->WindowSize.X = LOWORD(dwValue);
        pStateInfo->WindowSize.Y = HIWORD(dwValue);
    }

    //
    // Initial window position
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWPOS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->WindowPosX = (SHORT)LOWORD(dwValue);
        pStateInfo->WindowPosY = (SHORT)HIWORD(dwValue);
        pStateInfo->AutoPosition = FALSE;
    }

    //
    // Initial font size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FontSize.X = LOWORD(dwValue);
        pStateInfo->FontSize.Y = HIWORD(dwValue);
    }

    //
    // Initial font family
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTFAMILY,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FontFamily = dwValue;
    }

    //
    // Initial font weight
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTWEIGHT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->FontWeight = dwValue;
    }

    //
    // Initial font face name
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FACENAME,
                       sizeof(awchBuffer), (PBYTE)awchBuffer))) {
        RtlCopyMemory(pStateInfo->FaceName, awchBuffer, sizeof(awchBuffer));
    }

    //
    // Initial cursor size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CURSORSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->CursorSize = dwValue;
    }

    //
    // Initial history buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->HistoryBufferSize = dwValue;
    }

    //
    // Initial number of history buffers
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYBUFS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->NumberOfHistoryBuffers = dwValue;
    }

    //
    // Initial history duplication mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYNODUP,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        pStateInfo->HistoryNoDup = dwValue;
    }

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        NtClose(hTitleKey);
    }

CloseKeys:
    NtClose(hConsoleKey);
    NtClose(hCurrentUserKey);

    return dwRet;
}


VOID
SetRegistryValues(
    PCONSOLE_STATE_INFO pStateInfo,
    DWORD dwPage
    )

/*++

Routine Description:

    This routine writes values to the registry from the supplied
    structure.

Arguments:

    pStateInfo - optional pointer to structure containing information
    dwPage     - current page number

Return Value:

    none

--*/

{
    HANDLE hCurrentUserKey;
    HANDLE hConsoleKey;
    HANDLE hTitleKey;
    NTSTATUS Status;
    LPWSTR TranslatedTitle;
    DWORD dwValue;
    DWORD i;
    WCHAR awchBuffer[LF_FACESIZE];

    //
    // Open the current user registry key
    //

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    //
    // Open the console registry key
    //

    Status = MyRegCreateKey(hCurrentUserKey,
                            CONSOLE_REGISTRY_STRING,
                            &hConsoleKey);
    if (!NT_SUCCESS(Status)) {
        NtClose(hCurrentUserKey);
        return;
    }

    //
    // Save the current page
    //

    MyRegSetValue(hConsoleKey,
                  CONSOLE_REGISTRY_CURRENTPAGE,
                  REG_DWORD, &dwPage, sizeof(dwPage));

    //
    // If we only want to save the current page, bail out
    //

    if (pStateInfo == NULL) {
        goto CloseKeys;
    }

    //
    // Open the console title subkey, if there is one
    //

    if (pStateInfo->ConsoleTitle[0] != TEXT('\0')) {
        TranslatedTitle = TranslateConsoleTitle(pStateInfo->ConsoleTitle);
        if (TranslatedTitle == NULL) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return;
        }
        Status = MyRegCreateKey(hConsoleKey,
                                TranslatedTitle,
                                &hTitleKey);
        HeapFree(RtlProcessHeap(),0,TranslatedTitle);
        if (!NT_SUCCESS(Status)) {
            NtClose(hConsoleKey);
            NtClose(hCurrentUserKey);
            return;
        }
    } else {
        hTitleKey = hConsoleKey;
    }

    //
    // Save screen and popup colors and color table
    //

    dwValue = pStateInfo->ScreenAttributes;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FILLATTR,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->PopupAttributes;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_POPUPATTR,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    for (i = 0; i < 16; i++) {
        dwValue = pStateInfo->ColorTable[i];
        wsprintf(awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        MyRegUpdateValue(hConsoleKey, hTitleKey, awchBuffer,
                         REG_DWORD, &dwValue, sizeof(dwValue));
    }

    //
    // Save insert, quickedit, and fullscreen mode settings
    //

    dwValue = pStateInfo->InsertMode;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_INSERTMODE,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->QuickEdit;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_QUICKEDIT,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    SaveAutoCompleteSetting(g_fAutoComplete);

#ifdef i386
    dwValue = pStateInfo->FullScreen;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FULLSCR,
                     REG_DWORD, &dwValue, sizeof(dwValue));
#endif
#if defined(FE_SB) // scotthsu

    ASSERT(OEMCP != 0);
    if (gfFESystem) {
        dwValue = (DWORD) pStateInfo->CodePage;
        MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_CODEPAGE,
                         REG_DWORD, &dwValue, sizeof(dwValue));
    }
#endif

    //
    // Save screen buffer size
    //

    dwValue = MAKELONG(pStateInfo->ScreenBufferSize.X,
                       pStateInfo->ScreenBufferSize.Y);
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_BUFFERSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Save window size
    //

    dwValue = MAKELONG(pStateInfo->WindowSize.X,
                       pStateInfo->WindowSize.Y);
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_WINDOWSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Save window position
    //

    if (pStateInfo->AutoPosition) {
        MyRegDeleteKey(hTitleKey, CONSOLE_REGISTRY_WINDOWPOS);
    } else {
        dwValue = MAKELONG(pStateInfo->WindowPosX,
                           pStateInfo->WindowPosY);
        MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_WINDOWPOS,
                         REG_DWORD, &dwValue, sizeof(dwValue));
    }

    //
    // Save font size, family, weight, and face name
    //

    dwValue = MAKELONG(pStateInfo->FontSize.X,
                       pStateInfo->FontSize.Y);
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FONTSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->FontFamily;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FONTFAMILY,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->FontWeight;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FONTWEIGHT,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_FACENAME,
                     REG_SZ, pStateInfo->FaceName,
                      (_tcslen(pStateInfo->FaceName) + 1) * sizeof(TCHAR));

    //
    // Save cursor size
    //

    dwValue = pStateInfo->CursorSize;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_CURSORSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Save history buffer size and number
    //

    dwValue = pStateInfo->HistoryBufferSize;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_HISTORYSIZE,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->NumberOfHistoryBuffers;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_HISTORYBUFS,
                     REG_DWORD, &dwValue, sizeof(dwValue));
    dwValue = pStateInfo->HistoryNoDup;
    MyRegUpdateValue(hConsoleKey, hTitleKey, CONSOLE_REGISTRY_HISTORYNODUP,
                     REG_DWORD, &dwValue, sizeof(dwValue));

    //
    // Close the registry keys
    //

    if (hTitleKey != hConsoleKey) {
        NtClose(hTitleKey);
    }

CloseKeys:
    NtClose(hConsoleKey);
    NtClose(hCurrentUserKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\add.c ===
/*  ADD.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for removing
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  This file deals with the case where an OEM driver being installed.
**
**  History:
**
**      Thu Nov 1 1991 -by- Sanjaya
**      Created. Originally part of drivers.c
*/

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include <string.h>
#include <cpl.h>

#include "drivers.h"
#include <cphelp.h>
#include "sulib.h"
extern PINF       pinfOldDefault;
extern BOOL       bBadOemSetup;
char *szFilter[] = {"Inf Files(*.inf)", "*.inf", "Drv Files(*.drv)", "*.drv", ""};

BOOL GetDir          (HWND);
void BrowseDlg           (HWND, int);

/*  AddDriversDlg
 *
 * Returns 2 if dialog needs to be redrawn
 * Returns 1 if the oem file has been succesfully located
 * Returns 0 if Cancel has been pressed
 */

int AddDriversDlg(HWND hDlg, UINT message, UINT wParam, LONG lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:

            SetDlgItemText(hDlg, ID_TEXT, (LPSTR)szUnlisted);
            SetDlgItemText(hDlg, ID_EDIT, (LPSTR)szDirOfSrc);
            return(TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if (GetDir(hDlg))
                    {
                        DialogBox(myInstance, MAKEINTRESOURCE(DLG_UPDATE),
                        GetParent(hDlg), AddUnlistedDlg);
                        break;
                    } else {
                        EndDialog(hDlg, 2);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    return(TRUE);

                case IDS_BROWSE:
                    lstrcpy(szDrv, szOemInf);
                    BrowseDlg(hDlg, 1);
                    break;

                case IDH_DLG_INSERT_DISK:
                    goto DoHelp;
            }
            break;

        default:
            if (message == wHelpMessage) {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_INSERT_DISK);
                return TRUE;
            } else
                return FALSE;

    }
    return (FALSE);                         /* Didn't process a message    */
}


BOOL GetDir(HWND hDlg)
{
    PSTR    pstr;
    OFSTRUCT of;

    wsStartWait();

   /*
    * Test the edit box for a proper path
    * and look for the oemsetup.inf
    * file.  If we don't find it , highlight the
    * text in the edit box and bring up a dialog box
    */

    GetDlgItemText( hDlg, ID_EDIT, szDirOfSrc, MAX_PATH);
    RemoveSpaces(szFullPath, szDirOfSrc);
    lstrcpy(szDirOfSrc, szFullPath);
    for (pstr = szFullPath;*pstr;pstr++);
        if (*(pstr-1) != '\\')
            *pstr++ = '\\';

    *pstr = '\0';

    lstrcpy(szDiskPath, szFullPath);

   /*
    * Look for an oemsetup.inf
    * If you can't find it return false
    *
    */

    lstrcpy(pstr, szOemInf);

    if (OpenFile(szFullPath, &of, OF_EXIST) == -1)
    {
       SendDlgItemMessage(hDlg, ID_EDIT, EM_SETSEL, 0, -1L);
       wsEndWait();
       return (FALSE);
    }

   /*
    * Change the default inf to this new oemsetup.inf
    * Discard the value of the previous .inf, since it might
    * just be another set of oem drivers.
    */

    if (bBadOemSetup)
       infSetDefault(infOpen(of.szPathName));
    else
       pinfOldDefault = infSetDefault(infOpen(of.szPathName));
    EndDialog(hDlg, 1);
    wsEndWait();
    return(TRUE);
}


/*
 * Hooks into common dialog to show only directories
 */

BOOL CALLBACK AddFileHookProc(HWND hDlg, UINT iMessage,
                              DWORD wParam, LONG lParam)
{
  char szTemp[200];
  HWND hTemp;

    switch (iMessage)
    {
        case WM_INITDIALOG:

            GetDlgItemText(((LPOPENFILENAME)lParam)->hwndOwner, ID_TEXT,
                  szTemp, sizeof(szTemp));
            SetDlgItemText(hDlg, ctlLast+1, szTemp);

            goto PostMyMessage;

        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                case lst2:
                case cmb2:
                case IDOK:

  PostMyMessage:
                  PostMessage(hDlg, WM_COMMAND, ctlLast+2, 0L);
                  break;

                case IDH_DLG_BROWSE:
                  goto DoHelp;

                case ctlLast+2:
                   if (bFindOEM)
                   {
                     if (SendMessage(hTemp=GetDlgItem(hDlg, lst1), LB_GETCOUNT,
                       0, 0L))
                       {
                         SendMessage(hTemp, LB_SETCURSEL, 0, 0L);
                         SendMessage(hDlg, WM_COMMAND, MAKELONG(lst1, LBN_SELCHANGE),
                                     (LONG)hTemp);
                         break;
                       }
                   }
                   SetDlgItemText(hDlg, edt1, szDrv);
                   break;
            }
            break;

        default:

            if (iMessage == wHelpMessage)
            {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_BROWSE);
                return(TRUE);
            }
    }

    return FALSE;  // commdlg, do your thing
}


/*
 * Function : BrowseDlg
 *
 *     Call the GetOpenFileName dialog to open a file
 *
 * Parameters :
 *
 *     hDlg : Parent Dialog box
 *
 *     iIndex : Index into szFilter to determine which filter(s) to use
 */


void BrowseDlg(HWND hDlg, int iIndex)
{
    OPENFILENAME OpenFileName;
    char szPath[MAX_PATH];
    char szFile[MAX_PATH];

    *szPath = '\0';
    *szFile = '\0';
    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hDlg;
    OpenFileName.hInstance = myInstance;
    OpenFileName.lpstrFilter = szFilter[0];
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = iIndex;
    OpenFileName.lpstrFile = (LPSTR)szPath;
    OpenFileName.nMaxFile = sizeof(szPath);
    OpenFileName.lpstrFileTitle = szFile;
    OpenFileName.nMaxFileTitle = sizeof(szFile);
    OpenFileName.lpstrInitialDir = NULL;
    OpenFileName.lpstrTitle = NULL;
    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK |
      /*  OFN_FILEMUSTEXIST | */ OFN_ENABLETEMPLATE | OFN_NOCHANGEDIR |
            OFN_SHOWHELP;
    OpenFileName.lCustData = (LONG)hDlg;
    OpenFileName.lpfnHook = (LPOFNHOOKPROC)AddFileHookProc;

    OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(DLG_BROWSE);
    OpenFileName.nFileOffset = 0;
    OpenFileName.nFileExtension = 0;
    OpenFileName.lpstrDefExt = NULL;
    if (GetOpenFileName(&OpenFileName))
    {
        UpdateWindow(hDlg); // force buttons to repaint
        szPath[OpenFileName.nFileOffset] = '\0';
        SetDlgItemText(hDlg, ID_EDIT, szPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\copy.c ===
/*
 *  copy.c - Copy routine for WinDosSetup
 *  Todd Laney
 *
 *  Modification History:
 *
 *  6/03/91 Vlads        Change copy process to incorporate new Install API
 *
 *  3/24/89  Toddla      Wrote it
 *
 *
 *  notes:
 *   we now use the LZCopy stuff for compression
 *   we now set the crit error handler ourselves so CHECKFLOPPY is
 *   NOT defined
 */

#include <windows.h>

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <mmsystem.h>

#include "drivers.h"
#include "sulib.h"
//#include <ver.h>


#define MAX_COPY_ATTEMPTS  15

/*
 *  Maximum number of install disks we support
 */

#define MAX_DISKS 100

/*
 *  Flags for VerInstallFile
 */

#define FORCEABLE_FLAGS  (VIF_MISMATCH + VIF_SRCOLD + VIF_DIFFLANG + VIF_DIFFTYPE + VIF_DIFFCODEPG )

/**********************************************************************
 *
 * Local function prototypes.
 *
 **********************************************************************/

 // Retrieve disk path for logical disk

 BOOL GetDiskPath(LPSTR Disk, LPSTR szPath);

 // Convert VIF_... to ERROR... return codes

 UINT ConvertFlagToValue(DWORD dwFlags);

 // Do the work of trying to copy a file

 LONG TryCopy(LPSTR    szSrc,     // Full source file path
              LPSTR    szLogSrc,  // Logical source name
              LPSTR    szDestPath,// Destination path
              FPFNCOPY fpfnCopy); // Callback routine

 #ifdef CHECK_FLOPPY
 BOOL NEAR IsDiskInDrive(int iDisk);
 #endif

 // GLOBAL VARIABLES

 //  directory where windows will be setup to

 char szSetupPath[MAX_PATH];

 // directory where the root of the setup disks are!

 char szDiskPath[MAX_PATH];

 // Name of driver being copied (or oemsetup.inf)

 char szDrv[120];

/*
 *  global vars used by DosCopy
 */
 static LPSTR    lpBuf = NULL;   // copy buffer
 static int      iBuf = 0;       // usage count
 static UINT     nBufSize;
 BOOL     bRetry = FALSE;
 BOOL     bQueryExist;


 BOOL DefCopyCallback(int msg, DWORD n, LPSTR szFile)
 {
     return FC_IGNORE;
 }



/*  UINT FileCopy (szSource, szDir, fpfnCopy, UINT fCopy)
 *
 *  This function will copy a group of files to a single destination
 *
 *  ENTRY:
 *
 *  szSourc      : pointer to a SETUP.INF section
 *  szDir        : pointer to a string containing the target DIR
 *  fpfnCopy     : callback function used to notify called of copy status
 *  fCopy        : flags
 *
 *      FC_SECTION            - szSource is a section name
 *      FC_LIST               - szSource is a pointer to a char **foo;
 *      FC_LISTTYPE           - szSource is a pointer to a char *foo[];
 *      FC_FILE               - szSource is a file name.
 *      FC_QUALIFIED          - szSource is a fully qualified file name.
 *      FC_DEST_QUALIFIED     - szDir is fully qualified. Don't expand this.
 *      FC_CALLBACK_WITH_VER  - call back if file exists and report version information.
 *
 *  NOTES:
 *      if szSource points to a string of the form '#name' the section
 *      named by 'name' will be used as the source files
 *
 *      the first field of each line in the secion is used as the name of the
 *      source file.  A file name has the following form:
 *
 *          #:name
 *
 *          #       - Disk number containing file 1-9,A-Z
 *          name    - name of the file, may be a wild card expression
 *
 *  Format for copy status function
 *
 *  BOOL FAR PASCAL CopyStatus(int msg, int n, LPSTR szFile)
 *
 *      msg:
 *          COPY_ERROR          error occured while copying file(s)
 *                              n      is the DOS error number
 *                              szFile is the file that got the error
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_STATUS         Called each time a new file is copied
 *                              n      is the percent done
 *                              szFile is the file being copied
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_INSERTDISK     Please tell the user to insert a disk
 *                              n      is the disk needed ('1' - '9')
 *                              return: TRUE try again, FALSE abort copy
 *
 *          COPY_QUERYCOPY      Should this file be copied?
 *                              n      line index in SETUP.INF section (0 based)
 *                              szFile is the line from section
 *                              return: TRUE copy it, FALSE dont copy
 *
 *          COPY_START          Sent before any files are copied
 *
 *          COPY_END            Sent after all files have been copied
 *                              n   is dos error if copy failed
 *
 *          COPY_EXISTS         Sent if the FC_CALL_ON_EXIST bit was set
 *                              and the file exists at the destination
 *                              given for the filecopy.
 *
 *
 *  EXIT: returns TRUE if successful, FALSE if failure.
 *
 */

UINT FileCopy (LPSTR szSource, LPSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy)
{
   int   err = ERROR_SUCCESS;     // Return code from this routine

   char  szPath[MAX_PATH];
   char  szLogSrc[MAX_PATH];
   char  szSrc[MAX_PATH];

   LPSTR pFileBegin;              // First file

   LPSTR * List;                  // Handle lists of files
   LPSTR * ListHead;

   int   nDisk;                   // The disk we're on

   int   cntFiles = 0;            // How many files we've got to do

   if (fpfnCopy == NULL) {
      fpfnCopy = DefCopyCallback;
   }

   if (!szSource || !*szSource || !szDir || !*szDir) {
      return ERROR_FILE_NOT_FOUND;
   }


  /*
   *  fix up the drive in the destination
   */

   if ( fCopy & FC_DEST_QUALIFIED ) {
      lstrcpy(szPath, szDir);
      fCopy &= ~FC_DEST_QUALIFIED;
   } else {
      ExpandFileName(szDir, szPath);
   }

   if (szSource[0] == '#' && fCopy == FC_FILE) {
       fCopy = FC_SECTION;
       ++szSource;
   }

   switch (fCopy) {
       case FC_SECTION:
       {
           szSource = infFindSection(NULL,szSource);

          /*
           * We are called even when the section doesn't exist
           */

           if (szSource == NULL) {
               return ERROR_SUCCESS;
           }

           fCopy = FC_LIST;
       }
       // fall through to FC_LIST

       case FC_LIST:
          pFileBegin = szSource;
          cntFiles = infLineCount(szSource);
          break;

       case FC_LISTTYPE:
          ListHead = List = (LPSTR far *)szSource;
          pFileBegin = *ListHead;
          while ( *List++ )           // Count files to be copied.
             ++cntFiles;
          break;

       case FC_FILE:
       case FC_QUALIFIED:
       default:
          pFileBegin = szSource;
          cntFiles = 1;
    }

  /*
   *  walk all files in the list and call TryCopy ....
   *
   *  NOTES:
   *      we must walk file list sorted by disk number.
   *      we should use the disk that is currently inserted.
   *      we should do a find first/find next on the files????
   *      we need to check for errors.
   *      we need to ask the user to insert disk in drive.
   *
   */

   (*fpfnCopy)(COPY_START,0,NULL);

  /*
   *  Go through all possible disks: 1 to 100 and A to Z (26)
   */

   for (nDisk = 1;
        err == ERROR_SUCCESS && (cntFiles > 0) &&
            (nDisk <= MAX_DISKS + 'Z' - 'A' + 1);
        nDisk++)
   {
      char Disk[10];              // Maximum string is "100:"
      LPSTR pFile;
      int FileNumber;             // Which file in the list we're on
                                  // (to pass to callback)

      pFile      = pFileBegin;    // Start at first file
      List       = ListHead;      // Handled chained lists
      FileNumber = 0;             // Informational for callback - gives
                                  // which file in list we're on
     /*
      *  Work out the string representing our disk letter
      */

      if (nDisk > MAX_DISKS) {
          Disk[0] = 'A' + nDisk - MAX_DISKS - 1;
          Disk[1] = '\0';
      } else {
          _itoa(nDisk, Disk, 10);
      }

      strcat(Disk, ":");

      for (;
           err == ERROR_SUCCESS && pFile;
           FileNumber++,
           pFile = fCopy == FC_LISTTYPE ? *(++List) :
                   fCopy == FC_LIST ? infNextLine(pFile) :
                   NULL)
      {
        /*
         *  We have to reset high bit of first byte because it could be set
         *  by translating service in OEM setup to show that file name was
         *  mapped
         */

         *pFile = toascii(*pFile);


        /*
         *  should we copy this file?
         *  copy the files in disk order.
         */

         if (_strnicmp(pFile, Disk, strlen(Disk)) == 0 || // File has disk
                                                         // number and we're
                                                         // on that disk
             RemoveDiskId(pFile) == pFile &&
                nDisk == 1 && *pFile ||                  // First disk and
                                                         // no disk number

             fCopy == FC_QUALIFIED) {                    // Fully qualified


            /*
             * done with a file. decrement count.
             */

             cntFiles--;

             lstrcpy(szDrv, RemoveDiskId(pFile));

             switch ((*fpfnCopy)(COPY_QUERYCOPY, FileNumber, pFile))
             {
                 case CopyCurrent:                // Skip

                         continue;

                 case CopyNeither:

                         err = ERROR_FILE_EXISTS; // File already exists

                 case CopyNew:
                         break;

                 default:
                         break;

             }

            /*
             *  Pick up bad return code from switch
             */

             if (err != ERROR_SUCCESS) {
                 break;
             }

            /*
             *  now we convert logical dest into a physical
             *    (unless FC_QUALIFIED)
             */

             infParseField(pFile, 1, szLogSrc);    // logical source

             if ( fCopy != FC_QUALIFIED ) {
                ExpandFileName(szLogSrc, szSrc); // full physical source
             } else {
                lstrcpy(szSrc,szLogSrc);
             }


            /*
             *  Attempt copy
             */

             err = TryCopy(szSrc,      // Qualified Source file
                           szLogSrc,   // Logical source file name (with disk #)
                           szPath,     // Path for directory to install in
                           fpfnCopy);  // Copy callback function

            /*
             *  If failed to find file try the windows directory
             */

             if (err != ERROR_SUCCESS) {
                 break;
             }

         } /* End if dor if DoCopy */
      }
   }

   (*fpfnCopy)(COPY_END,err,NULL);

   return err;
}

/**********************************************************************
 *
 *  TryCopy
 *
 *  Copy a single file from source to destination using the VerInstallFile
 *  API - interpreting the return code as :
 *
 *    ERROR_SUCCESS  - OK
 *    Other          - failure type
 *
 **********************************************************************/

LONG TryCopy(LPSTR    szSrc,      // Full expanded source file path
             LPSTR    szLogSrc,   // Logical source name
             LPSTR    szDestPath, // Destination path
             FPFNCOPY fpfnCopy)   // Callback routine

{
    DWORD wTmpLen;
    DWORD dwRetFlags;
    char  szTempFile[MAX_PATH];
    char  szErrFile[MAX_PATH];
    char  DriversPath[MAX_PATH];
    BOOL  bRetVal;               // Return code from callback
    LPSTR szFile;
    char  szSrcPath[MAX_PATH];
    int   iAttemptCount;
    WORD  wVerFlags;
    LONG  err;

   /*
    *  Fix up destination if file is a kernel driver
    */

    if (IsFileKernelDriver(szSrc)) {
        strcpy(DriversPath, szDestPath);
        strcat(DriversPath, "\\drivers");
        szDestPath = DriversPath;
    }

   /*
    *  Create file name from current string
    */

    szFile = FileName(szSrc);
    lstrcpy(szSrcPath, szSrc);
    StripPathName(szSrcPath);

    for(iAttemptCount = 0, wVerFlags = 0 ;
        iAttemptCount <= MAX_COPY_ATTEMPTS;
        iAttemptCount++) {

        HCURSOR  hcurPrev;             // Saved cursor state

        // Central operation - attempt to install file szFile in directory
        // pointed by szPath from directory pointed by szSrc
        // If operation will fail but with possibility to force install
        // in last parameter buffer we will have temporary file name ==>
        // therefore we can avoid excessive copying.
        // NOTE: now szFile consists of only file name and other buffers
        // only path names.

        wTmpLen = MAX_PATH;

        hcurPrev = SetCursor(LoadCursor(NULL,IDC_WAIT));
        dwRetFlags = VerInstallFile(wVerFlags,
                                    (LPSTR) szFile,
                                    (LPSTR) szFile,
                                    (LPSTR) szSrcPath,
                                    (LPSTR) szDestPath,
                                    (LPSTR) szDestPath,
                                    (LPSTR) szTempFile,
                                    (LPDWORD) &wTmpLen);
        SetCursor(hcurPrev);

       /*
        *  Operation failed if at least one bit of return flags is non-zero
        *  That is unusual but defined so in Version API.
        */

        if ( !dwRetFlags )
            return ERROR_SUCCESS;    // If no errors - goto next file


       /*
        *  If flag MISMATCH is set - install can be forced and we have
        *  temporary file in destination subdirectory
        */

        if ( dwRetFlags  &  VIF_MISMATCH ) {

            if ( dwRetFlags & VIF_SRCOLD ) {

              /*
               *  If we need not call back with question - automatically
               *  force install with same parameters.
               *  michaele, *only* if src file is *newer* than dst file
               */

               DeleteFile(szTempFile);

               return ERROR_SUCCESS;
            }

           /*
            *  If we need not call back with question - automatically
            *  force install with same parameters.
            */

            wVerFlags |= VIFF_FORCEINSTALL;
            iAttemptCount--;             // Make sure we get another go.
            continue;

        }   /* End if MISMATCH */

       /*
        *  If real error occured - call back with error file info
        *  In all dialogs we use our error codes - so I will convert
        *  flags returned from Ver API to ours.
        */

        err = ConvertFlagToValue(dwRetFlags);


       /*
        *  If source path or file is nor readable - try to change disk
        */

        if ( dwRetFlags & VIF_CANNOTREADSRC )
        {
          /*
           *  Now new path in szSrc so I deleted logic for creating it
           */

           if (RemoveDiskId(szLogSrc) == szLogSrc)

             /*
              *  if disk # not provided, default to 1
              */

              bRetVal = (*fpfnCopy)(COPY_INSERTDISK, (DWORD)"1", szSrcPath);
           else
              bRetVal = (*fpfnCopy)(COPY_INSERTDISK, (DWORD)szLogSrc, szSrcPath);


           switch (bRetVal)
              {
              case FC_RETRY:
                  continue;              // and try again...

              case FC_ABORT:
                  return ERROR_FILE_NOT_FOUND;

              case FC_IGNORE:
                  break;
              }
        }

        ExpandFileName(szLogSrc, szErrFile);

#if WINDOWSDIR

        if (!*bWindowsDir  &&
            err != FC_ERROR_LOADED_DRIVER &&
            err != ERROR_DISK_FULL)
        {
            GetWindowsDirectory(szPath, MAX_PATH);
            *bWindowsDir = TRUE;
            continue;
        }

#endif // WINDOWSDIR

        switch ((*fpfnCopy)(COPY_ERROR, err, szErrFile)) {

            case FC_IGNORE:
                return ERROR_SUCCESS;

            case FC_RETRY:
                break;

            case FC_ABORT:
                return ERROR_FILE_NOT_FOUND;
        }
    } // End of attempts

    return err;
}

/*  BOOL GetDiskPath(Disk, szPath)
 *
 *  This function will retrive the full path name for a logical disk
 *
 *  The code reads the [disks] section of SETUP.INF and looks for
 *  n = path where n is the disk char.  NOTE the disk '0' defaults to
 *  the root windows directory.
 *
 *  ENTRY:
 *
 *  cDisk        : what disk to find 0-9,A-Z
 *  szPath       : buffer to hold disk path
 *
 *  Returns :
 *     TRUE if a disk path was found
 *     FALSE if there was no disk specified (ie no ':'
 *
 */

BOOL GetDiskPath(LPSTR Disk, LPSTR szPath)
{
   char    ach[MAX_PATH];
   char    szBuf[MAX_PATH];
   int i;


  /*
   *  Check to see if there is actually a disk id.
   *  If not return FALSE
   */

   if (RemoveDiskId(Disk) == Disk) {
       return FALSE;
   }

  /*
   *  Create our copy of the disk id
   */

   for (i = 0; Disk[i] != ':'; i++) {
       ach[i] = Disk[i];
   }
   ach[i] = '\0';


  /*
   *  Zero disk letter means windows setup directory
   */

   if (_stricmp(ach, "0") == 0) {

      /*
       * return the windows setup directory
       */

       lstrcpy(szPath,szSetupPath);
       return TRUE;
   }

  /*
   *  now look in the [disks] section for a full path name
   *
   *  This is a pretty bogus concept and is not supported
   *  in win 32 style disks section [Source Media Descriptions]
   */

   if ( !infGetProfileString(NULL,DISK_SECT,ach,szPath) &&
        !infGetProfileString(NULL,OEMDISK_SECT,ach,szPath)) {

       lstrcpy(szPath, szDiskPath);
   } else {
       infParseField(szPath,1,szPath);

      /*
       *  is the path relative? is so prepend the szDiskPath
       */

       if (szPath[0] == '.' || szPath[0] == '\0') {
           lstrcpy(szBuf,szDiskPath);
           catpath(szBuf,szPath);
           lstrcpy(szPath,szBuf);
       }

   }

   return TRUE;
}


/*  BOOL FAR PASCAL ExpandFileName(LPSTR szFile, LPSTR szPath)
 *
 *  This function will retrive the full path name for a file
 *  it will expand, logical disk letters to pyshical ones
 *  will use current disk and directory if non specifed.
 *
 *  if the drive specifed is 0-9, it will expand the drive into a
 *  full pathname using GetDiskPath()
 *
 *  IE  0:system ==>  c:windows\system
 *      1:foo.txt     a:\foo.txt
 *
 *  ENTRY:
 *
 *  szFile       : File name to expand
 *  szPath       : buffer to hold full file name
 *
 */
BOOL ExpandFileName(LPSTR szFile, LPSTR szPath)
{
   char    szBuf[MAX_PATH*2];

   if (GetDiskPath(szFile, szBuf)) {
       lstrcpy(szPath,szBuf);
       if (szFile[2])
          catpath(szPath,szFile + 2);
   } else {
       lstrcpy(szPath,szFile);
   }
   return TRUE;
}




void catpath(LPSTR path, LPSTR sz)
{
   //
   // Remove any drive letters from the directory to append
   //
   sz = RemoveDiskId(sz);

   //
   // Remove any current directories ".\" from directory to append
   //
   while (sz[0] == '.' && SLASH(sz[1]))
      sz += 2;

   //
   // Dont append a NULL string or a single "."
   //
   if (*sz && ! (sz[0] == '.' && sz[1] == 0))
   {
      // Add a slash separator if necessary.
      if ((! SLASH(path[lstrlen(path) - 1])) &&    // slash at end of path
          ((path[lstrlen(path) - 1]) != ':') &&    // colon at end of path
          (! SLASH(sz[0])))                        // slash at beginning of file
         lstrcat(path, CHSEPSTR);

      lstrcat(path, sz);
   }
}

/*
 *  Return a pointer to the file name part of a string
 */

LPSTR FileName(LPSTR szPath)
{
   LPSTR   sz;

   for (sz=szPath; *sz; sz++)
      ;

   for (; sz>=szPath && !SLASH(*sz) && *sz!=':'; sz--)
      ;

   return ++sz;
}

/*
 *  Return the portion of a file name following the disk (ie anything
 *  before the colon).
 *  If there is no colon just return a pointer to the original string
 */

LPSTR RemoveDiskId(LPSTR szPath)
{
   LPSTR sz;

   for (sz = szPath; *sz; sz++) {
       if (*sz == ':') {
           return sz + 1;
       }
   }

   return szPath;
}

LPSTR StripPathName(LPSTR szPath)
{
    LPSTR   sz;

    sz = FileName(szPath);

    if (sz > szPath+1 && SLASH(sz[-1]) && sz[-2] != ':')
       sz--;

    *sz = 0;
    return szPath;
}

/*
 *  See if a file is a kernel driver.  Unfortunately the VersionInfo APIs
 *  don't seem coded up to take care of this at the moment so we just check
 *  to see if the file extension is ".SYS"
 */

 BOOL IsFileKernelDriver(LPSTR szPath)
 {
     char drive[MAX_PATH];
     char dir[MAX_PATH];
     char fname[MAX_PATH];
     char ext[MAX_PATH];

     _splitpath(szPath, drive, dir, fname, ext);
     return !_stricmp(ext, ".sys");
 }


/**************************************************************************
 *
 * This function converts returned flags from Ver API to the numerical
 * error codes used in SETUP.
 *
 ***************************************************************************/

UINT ConvertFlagToValue(DWORD dwFlags)
{
    if ( ! dwFlags  )
       return(NO_ERROR);
    if ( dwFlags & VIF_CANNOTREADSRC )
       return(ERROR_FILE_NOT_FOUND);
    if ( dwFlags & VIF_OUTOFMEMORY )
       return(ERROR_OUTOFMEMORY);
    if ( dwFlags & VIF_ACCESSVIOLATION )
       return(ERROR_ACCESS_DENIED);
    if ( dwFlags & VIF_SHARINGVIOLATION )
       return(ERROR_SHARING_VIOLATION);
    if ( dwFlags & VIF_FILEINUSE)
       return(FC_ERROR_LOADED_DRIVER);

    return(ERROR_CANNOT_COPY);    // General error
}



#ifdef CHECK_FLOPPY
/*--------------------------------------------------------------------------

  IsValidDiskette() -

--------------------------------------------------------------------------*/

#define CBSECTORSIZE   512
#define INT13_READ   2

BOOL IsValidDiskette(int iDrive)
{
   char       buf[CBSECTORSIZE];

   iDrive |= 0x0020;   // make lower case

   iDrive -= 'a';   // A = 0, B = 1, etc. for BIOS stuff

   return MyReadWriteSector(buf, INT13_READ, iDrive, 0, 0, 1);
}



/*  BOOL IsDiskInDrive(char cDisk)
 *
 *  Is the specifed disk in the drive
 *
 *  ENTRY:
 *
 *  cDisk        : what disk required to be in the drive (logical)
 *
 *  return TRUE if the specifed disk is in the drive
 *         FALSE if the wrong disk is in the drive or disk error
 *
 */
BOOL IsDiskInDrive(int iDisk)
{

   if ((iDisk  >= 'A' && iDisk <= 'Z') ||
      (iDisk  >= 'a' && iDisk <= 'z'))
      {
      if (DosRemoveable(iDisk))
         {
         if (!IsValidDiskette(iDisk))
            return FALSE;
         }
      return TRUE;
      }
   return TRUE;   // for non drive letters assume a path
                  // and thus always in.
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\drivers.h ===
/*  DRIVERS.H
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**
**  Multimedia Control Panel Drivers Applet.
**
**  Display a list of all installed drivers, allow user to configure
**  existing or install new ones.
**
*/
#include "dlgs.h"
#include "commdlg.h"
#include <multimed.h>

#define SECTION         512                   // Maximum size of section
#define DLG_BROWSE      38
#define MAXSTR          256
#define UNLIST_LINE     1
#define NO_UNLIST_LINE  0
#define WEC_RESTART     0x42
#define DESC_SYS        3
#define DESC_INF        2
#define DESC_EXE        1
#define DESC_NOFILE     0

typedef struct _IDRIVER
{
    WCHAR   wszSection[MAXSTR];
    WCHAR   wszAlias[MAXSTR];
    WCHAR   wszFile[MAX_PATH];
    char    szSection[MAXSTR];
    char    szAlias[MAXSTR];
    char    szFile[MAX_PATH];
    char    szDesc[MAXSTR];
    struct  _IDRIVER *related;
    BOOL    bRelated;
    char    szRelated[MAXSTR];
    char    szRemove[MAXSTR];
    int     fQueryable;     // 0 -> can't, 1 -> can, -1 -> need to check
    BOOL    bInstall;       // 0 -> no,    1 -> yes
    BOOL    KernelDriver;   // If TRUE this is a kernel driver, not an
                            // 'installable' driver so it can't be opened,
                            // process messages etc.
#ifdef INFFILE
    BOOL    infFileProcessing;
#endif // INFFILE
} IDRIVER, *PIDRIVER;

extern HANDLE         myInstance;
extern char           szNULL[];
extern char           szDrivers[];
extern char           szBoot[];
extern char           szDriversHlp[];
extern char           szAppName[];
extern char           szUnlisted[];
extern char           szFullPath[];
extern char           szOemInf[];
extern char           szDirOfSrc[];
extern char           szUserDrivers[];
extern char           szControlIni[];
extern char           szDriversDesc[];
extern char           szSetupInf[];
extern char           szSysIni[];
extern char           szMCI[];
extern char           szRestartDrv[];
extern char           szRelated[];
extern char           szNULL[];
extern char           szBackslash[];
extern char           szOutOfRemoveSpace[];
extern char           szKnown[];
extern char           szRelatedDesc[];
extern char           szDrv[];
extern char           szRemove[];
extern char           szSystem[];
extern char           szSystemDrivers[];
extern int            iRestartMessage;
extern UINT           wHelpMessage;
extern DWORD          dwContext;
extern BOOL           bCopyVxD;
extern BOOL           bVxd;
extern BOOL           bInstallBootLine;
extern BOOL           bFindOEM;
extern BOOL           bRestart;
extern BOOL           bCopyingRelated;
extern BOOL           bRelated;
extern HWND           hlistbox;

//------------------------------------------------------------------------
//
// Public routines
//
//------------------------------------------------------------------------
extern void RemoveDriverEntry   (PSTR, PSTR, PSTR, BOOL);
extern int  FileNameCmp         (char *, char *);
extern void OpenDriverError     (HWND, LPSTR, LPSTR);
extern void RemoveSpaces        (LPSTR, LPSTR);
extern BOOL RestartDlg          (HWND, unsigned, UINT, LONG);
extern int  AddDriversDlg       (HWND, unsigned, UINT, LONG);
extern BOOL AddUnlistedDlg      (HWND, unsigned, UINT, LONG);
extern BOOL mmAddNewDriver      (LPSTR, LPSTR, PIDRIVER);
extern LONG PostRemove          (HWND, PIDRIVER, BOOL, int);
extern BOOL RemoveService       (LPSTR);
extern BOOL IsOnlyInstance      (HWND, PIDRIVER);
extern BOOL CopyToSysDir        (void);
extern BOOL InstallDrivers      (HWND, HWND, PSTR);
extern void InitDrvConfigInfo   (LPDRVCONFIGINFO, PIDRIVER);
extern int  AddIDriver          (HWND, PIDRIVER);
extern BOOL IsConfigurable      (PIDRIVER, HWND);
extern void BrowseDlg           (HWND, int);
extern int  LoadDesc            (PIDRIVER, PSTR, PSTR);
extern BOOL wsInfParseInit      (void);
extern void wsStartWait         (void);
extern void wsEndWait           (void);
extern UINT wsCopySingleStatus  (int, DWORD, LPSTR);


/* Resource IDs */

#define IDOK                1
#define IDCANCEL            2
#define ID_IGNORE           3
#define ID_CURRENT          4
#define ID_RETRY            5
#define ID_NEW              6

#define ID_DISK             101
#define ID_ADD              102
#define ID_CONFIGURE        103
#define ID_REMOVE           104
#define ID_EDIT             105
#define ID_TEXT             106

#define ID_FILE             201
#define ID_DIR              202
#define ID_FILE_LIST        203
#define ID_DIR_LIST         204
#define ID_TYPE             205

#define LB_AVAILABLE        301
#define ID_DRV              302
#define ID_LIST             303
#define ID_DRVSTRING        304
#define LB_INSTALLED        305
#define LB_UNLISTED         306

#define DLG_INSTALLED       1001
#define DLG_UPDATE          1002
#define DLG_KNOWN           1003
#define DLG_RESTART         1004
#define DLG_EXISTS          1005
#define DLG_INSERTDISK      1006

#define DLG_COPYERR         1007
#define ID_STATUS2          1008

#define IDS_NOINF                       2003
#define IDS_DEFDRIVE                    2004
#define IDS_OUTOFDISK                   2005
#define IDS_DISKS                       2006
#define IDS_INSTALLDRIVERS              2007
#define IDS_INSTALLDRIVERS32            2066
#define IDS_DRIVERDESC                  2008
#define IDS_OUT_OF_REMOVE_SPACE         2009
#define IDS_AVAILABLE_DRIVERS_DEFAULT   2010
#define IDS_ERROR                       2011
#define IDS_INSTALLING_DRIVERS          2012
#define IDS_NO_DESCRIPTION              2013
#define IDS_ERRORBOX                    2014
#define IDS_RESTARTTEXT                 2015
#define IDS_CONFIGURE_DRIVER            2016
#define IDS_TOO_MANY_DRIVERS            2017
#define IDS_CANNOT_FIND                 2018
#define IDS_APPNAME                     2019
#define IDS_DRIVERS                     2020
#define IDS_SETUPINF                    2021
#define IDS_CONTROLINI                  2022
#define IDS_SYSINI                      2023
#define IDS_MCI                         2024
#define IDS_CONTROL_INI                 2025
#define IDS_WIN                         2027
#define IDS_DOS                         2028
#define IDS_BROWSE                      2029
#define IDS_UPDATED                     2031
#define IDS_CLOSE                       2032
#define IDS_REMOVEORNOT                 2033
#define IDS_UNLISTED                    2034
#define IDS_KNOWN                       2035
#define IDS_REMOVE                      2036
#define IDS_REMOVEORNOTSTRICT           2037
#define IDS_USERINSTALLDRIVERS          2038
#define IDS_OEMSETUP                    2044
#define IDS_SYSTEM                      2045
#define IDS_FILE_ERROR                  2046
#define IDS_VALID_DRIVER_TYPES          2047
#define IDS_UNABLE_TOINSTALL            2049
#define IDS_BOOT                        2050
#define IDS_RESTART_ADD                 2051
#define IDS_RESTART_REM                 2052
#define IDS_FILEINUSEADD                2053
#define IDS_OEMDISKS                    2054
#define IDS_FILEINUSEREM                2055
#define IDS_LASTQUERY                   2056
#define IDS_RELATEDDESC                 2057
#define IDS_DRIVER_EXISTS               2058
#define IDS_SYSTEM_DRIVERS              2060
#define IDS_INSUFFICIENT_PRIVILEGE      2061
#define IDS_CANNOT_RESTART_PRIVILEGE    2062
#define IDS_CANNOT_RESTART_UNKNOWN      2063
#define IDS_DRIVER_CONFIG_ERROR         2064
#define IDS_CANTADD                     2065

#define DRIVERS_ICON                    ID_ICON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\infparse.c ===
/*
 * Infparse.c - Setup.inf parsing code.
 * Clark Cyr, Mike Colee, Todd Laney
 * Copyright (C) Microsoft, 1989
 * March 15, 1989
 *
 *  Modification History:
 *
 *  3/15/89  CC  Clark wrote this code for control Panel. This is windows
 *               code.
 *
 *  3/20/89  MC  Decided this code would work for Dos and windows portion
 *               of setup. take out windows specifc stuff like local alloc's
 *               and dialog stuff. Replace it with standard C run time calls.
 *
 *  3/24/89  Toddla TOTAL rewrite! nothing is the same any more.
 *
 *  6/29/89  MC fixed getprofilestring func to not strip quotes if more
 *              than one field exists.
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

/*** hack.  to avoid realloc problems we make READ_BUFSIZE
            as big as the inf file, thus avoiding any reallocs */

#define READ_BUFSIZE    27000   /* size of inf buffer */
#define TMP_BUFSIZE     1024    /* size of temp reads */

#define EOF        0x1A
#define ISEOL(c)     ((c) == '\n' || (c) == '\r' || (c) == '\0' || (c) == EOF)
#define ISSEP(c)   ((c) == '='  || (c) == ',')
#define ISWHITE(c) ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISNOISE(c) ((c) == '"')

#define QUOTE   '"'
#define EQUAL   '='

PINF   pinfDefault = NULL;

static PSTR    pBuf;
static PINF    pInf;
static UINT    iBuf;
static UINT    iInf;

/* Globaly used pointers to non-translatable text strings. */

extern char *pszPATH;

/* Local prototypes */

BOOL multifields(PINF);


static char GETC(int fh)
{
    register UINT n;

    if (!pBuf)
        return EOF;

    n = iBuf % TMP_BUFSIZE;

    if (n == 0)
    {
       _lread(fh,pBuf,TMP_BUFSIZE);
    }
    iBuf++;
    return pBuf[n];
}

static void PUTC(char c)
{
    if (!pInf)
        return;

    pInf[iInf++] = c;
}

static void MODIFYC(char c)
{
    if (!pInf)
        return;

    pInf[iInf++ - 1] = c;
}

static char LASTC(void) {
    if (!pInf) return ' ';

    if (iInf == 0) {
        return ' ';
    }
    return pInf[iInf - 1];
}

/* int infLoadFile()      Load a entire INF file into memory
 *                        comments are removed, each line is terminated
 *                        by a \0 each section is terminated by a \0\0
 *                        ONLY spaces inside of " " are preserved
 *                        the end of file is marked with a ^Z
 *
 *   RETURNS:  A pointer to a block of memory containg file, NULL if failure
 *
 */
PINF infLoadFile(int fh)
{
    UINT    len;
    char    c;
    BOOL    fQuote = FALSE;
    BOOL    inSectionName = FALSE;

    if (fh == -1)
      return NULL;

    len = (UINT)_llseek(fh,0L,SEEK_END);

    _llseek(fh,0L,SEEK_SET);

    iBuf = 0;
    iInf = 0;
    pBuf = ALLOC(TMP_BUFSIZE);          // temp buffer
    if (!pBuf)
        return NULL;
    pInf = FALLOC(len);                 // destination, at least as big as file
    if (!pInf) {
        FREE((HANDLE)pBuf);
        return NULL;
    }

    while (iBuf < len)
    {
        c = GETC(fh);
loop:
        if (iBuf >= len)
            break;

        switch (c)
        {
            case '[':
                inSectionName = TRUE;
                PUTC(c);
                break;

            case ']':
                if (inSectionName) {
                    if (LASTC() == ' ') {
                        MODIFYC(c);
                    } else {
                        PUTC(c);
                    }
                    inSectionName = FALSE;
                } else {
                    PUTC(c);
                }
                break;

            case '\r':      /* ignore '\r' */
                break;

            case '\n':
                for (; ISWHITE(c); c = GETC(fh))
                    ;
                if (c != ';')
                    PUTC(0);    /* all lines end in a \0 */

                if (c == '[') {
                    PUTC(0);    /* all sections end with \0\0 */
                }

                fQuote = FALSE;
                goto loop;
                break;

            case '\t':
            case ' ':
                if (inSectionName) {
                    if (LASTC() != ' ' && LASTC() != ']')
                        PUTC(' ');
                } else {
                    if (fQuote)
                        PUTC(c);
                }
                break;

            case '"':
                fQuote = !fQuote;
                PUTC(c);
                break;

            case ';':
                for (; !ISEOL(c); c = GETC(fh))
                    ;
                goto loop;
                break;

            default:
                PUTC(c);
                break;
        }
    }

    PUTC(0);
    PUTC(0);
    PUTC(EOF);
    FREE((HANDLE)pBuf);

    // try to shrink this block


    // just leave pInf it's original size.  don't bother shrinking it

    return pInf;
}

/* PINF FAR PASCAL infOpen()
 *   PARAMETERS
 *           szInf - path to inf file to open and load
 *
 *   RETURNS:  A pointer to the parsed inf file if successful,
 *             Null pointer in the case of failure.
 *
 *   ENTER:
 *   EXIT:   To caller
 */

PINF infOpen(LPSTR szInf)
{
    char    szBuf[MAX_PATH];
    int     fh;
    PINF    pinf;

    fh = -1;

    if (szInf == NULL)
        szInf = szSetupInf;

    /*
     * Next try to open passed parameter as is. For Dos half.
     */
    if (fh == -1)
    {
        fh = _lopen(szInf, OF_READ);
    }
    /*
     * Next try destination path\system32. for win half.
     */
    if (fh == -1) {
        lstrcpy(szBuf, szSetupPath);
      catpath(szBuf, "system32");
      catpath(szBuf, szInf);
      fh = _lopen(szBuf, OF_READ);
    }
    /*
     * Next try destination path. for initial setup.
     */
    if (fh == -1) {
        lstrcpy(szBuf, szSetupPath);
      catpath(szBuf, szInf);
      fh = _lopen(szBuf, OF_READ);
    }
    if (fh != -1)
    {
        pinf = infLoadFile(fh);
        _lclose(fh);

        if (pinf && !pinfDefault)
            pinfDefault = pinf;

        return pinf;
    }
    return NULL;
}

/* void FAR PASCAL infClose(PINF pinf)
 *
 *   ENTER:
 *   EXIT:   To caller
 */
void infClose(PINF pinf)
{
    if (pinf == NULL)
        pinf = pinfDefault;

    if (pinf != NULL)
    {
        FFREE(pinf);

        if (pinf == pinfDefault)
            pinfDefault = NULL;
    }
}


/* FindSection  locates a section in Setup.Inf.  Sections are
 *               assumed to be delimited by a '[' as the first
 *               character on a line.
 *
 * Arguments:   pInf     Pointer to SETUP.INF buffer
 *              pszSect  LPSTR to section name
 *
 * Return:      UINT file position of the first line in the section
 *               0 if section not found
 */

UINT FindSection(PINF pInf, LPSTR pszSect)
{
    BOOL        fFound = FALSE;
    int         nLen = lstrlen(pszSect);
    PINF        pch;

    if (!pInf)
        return 0;

    pch = pInf;
    while (!fFound && *pch != EOF)
    {
        if (*pch++ == '[')
        {
            fFound = !strnicmp(pszSect, pch, nLen) && pch[nLen] == ']';
        }

        /*
         * go to the next line, dont forget to skip over \0 and \0\0
         */
        while (*pch != EOF && *pch != '\0')
            pch++;

        while (*pch == 0)
            pch++;
    }
    return((fFound && *pch != '[' && *pch != EOF) ? pch - pInf : 0);
}

/* char* fnGetDataString(npszData,szDataStr)
 *
 * Called by functions that read sections of information from setup.inf
 * to obtain strings that are set equal to keywords. Example:
 *
 * welcome=("Hello There")
 *
 * This function will return a pointer to the null terminated string
 * "Hello There".
 *
 * ENTRY:
 *
 * npszData    : pointer to entire section taken from setup.inf
 * npszDataStr : pointer to key word to look for (welcome in example above.)
 *
 * EXIT: returns pointer to string if successful, NULL if failure.
 *
 */
BOOL fnGetDataString(PINF npszData, LPSTR szDataStr, LPSTR szBuf)
{
    int len = lstrlen(szDataStr);

    while (npszData)
    {
            if (!strnicmp(npszData,szDataStr,len))  // looking for correct prof.
            {
               npszData += len;            // found !, look past prof str.
               while (ISWHITE(*npszData))  // pull out the stuff.
                       npszData++;
          if (*npszData == EQUAL)     // Now we have what were looking for !
               {
                       npszData++;

             if (!multifields(npszData) )
             {
                while (ISWHITE(*npszData) || ISNOISE(*npszData))
                             npszData++;

                          while (*npszData)
                             *szBuf++ = *npszData++;

                       /*
                        * remove trailing spaces, and those pesky ()'s
                           */

                while (ISWHITE(szBuf[-1]) || ISNOISE(szBuf[-1]))
                             szBuf--;

                          *szBuf = 0;
                          return TRUE;
             }
             else
             {
                while (*npszData)
                   *szBuf++ = *npszData++;
                *szBuf = '\0';
                return TRUE;
             }
               }
       }
       npszData = infNextLine(npszData);
    }
    *szBuf = 0;
    return FALSE;
}

/*  PINF FAR PASCAL infSetDefault(pinf)
 *
 *  Sets the default INF file
 *
 * ENTRY:
 *      pinf            : inf file to be new default
 *
 * EXIT: returns old default
 *
 */
PINF infSetDefault(PINF pinf)
{
    PINF pinfT;

    pinfT = pinfDefault;
    pinfDefault = pinf;
    return pinfT;
}

/*  PINF FAR PASCAL infFindSection(pinf,szSection)
 *
 *  Reads a entire section into memory and returns a pointer to it
 *
 * ENTRY:
 *      pinf            : inf file to search for section
 *      szSection       : section name to read
 *
 * EXIT: returns pointer to section, NULL if error
 *
 */
PINF infFindSection(PINF pinf, LPSTR szSection)
{
    UINT   pos;

    if (pinf == NULL)
        pinf = pinfDefault;

    pos = FindSection(pinf, szSection);
    return pos ? pinf + pos : NULL;
}

/*  BOOL FAR PASCAL infGetProfileString(szSection,szItem,szBuf)
 *
 *  Reads a single string from a section in SETUP.INF
 *
 *  [section]
 *      item = string
 *
 * ENTRY:
 *      szSection       : pointer to section name to read.
 *      szItem          : pointer to item name to read
 *      szBuf           : pointer to a buffer to hold result
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 */
BOOL infGetProfileString(PINF pinf, LPSTR szSection,LPSTR szItem,LPSTR szBuf)
{
    PINF    pSection;

    pSection = infFindSection(pinf,szSection);
    if (pSection )
        return fnGetDataString(pSection,szItem,szBuf);
    else
        *szBuf = 0;
    return FALSE;
}

/* BOOL FAR PASCAL infParseField(szData,n,szBuf)
 *
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. ( 1 based )
 *             0 is field before a '=' sign
 * szBuf     : pointer to buffer to hold extracted field
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 */
BOOL infParseField(PINF szData, int n, LPSTR szBuf)
{
    BOOL    fQuote = FALSE;
    PINF    pch;
    LPSTR   ptr;

    if (!szData || !szBuf)
        return FALSE;

    /*
     * find the first separator
     */
    for (pch=szData; *pch && !ISSEP(*pch); pch++) {
      if ( *pch == QUOTE )
         fQuote = !fQuote;
    }

    if (n == 0 && *pch != '=')
        return FALSE;

    if (n > 0 && *pch == '=' && !fQuote)
        szData = ++pch;

    /*
     *  locate the nth comma, that is not inside of quotes
     */
    fQuote = FALSE;
    while (n > 1)
    {
            while (*szData)
            {
          if (!fQuote && ISSEP(*szData))
                   break;

          if (*szData == QUOTE)
                   fQuote = !fQuote;

               szData++;
            }

            if (!*szData) {
               szBuf[0] = 0;            // make szBuf empty
               return FALSE;
            }

            szData++;
            n--;
    }
    /*
     * now copy the field to szBuf
     */
    while (ISWHITE(*szData))
            szData++;

    fQuote = FALSE;
    ptr = szBuf;                // fill output buffer with this
    while (*szData)
    {
       if (*szData == QUOTE)
               fQuote = !fQuote;
       else if (!fQuote && ISSEP(*szData))
               break;
            else
               *ptr++ = *szData;
            szData++;
    }
    /*
     * remove trailing spaces, and those pesky ()'s
     */
    while ((ptr > szBuf) && (ISWHITE(ptr[-1]) || ISNOISE(ptr[-1])))
            ptr--;

    *ptr = 0;
    return TRUE;
}

/* BOOL multifields(LPSTR npszData);
 *
 * Given a line line from mmdriver.inf that was after a profile
 * string this function will determine if that line has more than one
 * field. ie. Fields are seperated by commas that are NOT contained between
 * quotes.
 *
 * ENYRY:
 *
 * npszData : a line from setup.inf Example "xyz adapter",1:foobar.drv
 *
 * EXIT: This function will return TRUE if the line containes more than
 *       one field, ie the function would return TRUE for the example line
 *       shown above.
 *
 */
BOOL multifields(PINF npszData)
{
   BOOL    fQuote = FALSE;

        while (*npszData)
        {
      if (!fQuote && ISSEP(*npszData))
                   return TRUE;

      if (*npszData == QUOTE)
                   fQuote = !fQuote;

           npszData++;
        }
   return FALSE;
}

/* LPSTR FAR PASCAL infNextLine(sz)
 *
 * Given a line from SETUP.INF, advance to the next line.  will skip past the
 * ending NULL character checking for end of buffer \0\0
 *
 * ENTRY:
 *
 * sz        : pointer to line from a SETUP.INF section
 *
 * EXIT: returns pointer to next line if successful, NULL if failure.
 *
 */
PINF infNextLine(PINF pinf)
{
    if (!pinf)
        return NULL;

    while (*pinf != 0 || *(pinf + 1) == ' ')
        pinf++;

    return *++pinf ? pinf : NULL;
}

/* int FAR PASCAL infLineCount(pinf)
 *
 * Given a section from SETUP.INF, returns the number of lines in the section
 *
 * ENTRY:
 *
 * pinf      : pointer to a section from SETUP.INF
 *
 * EXIT: returns line count
 *
 */
int infLineCount(PINF pinf)
{
    int n = 0;

    for (n=0; pinf; pinf = infNextLine(pinf))
        n++;

    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\drivers.c ===
/*  DRIVERS.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for installing/configuring installable
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  History:
**
**      Tue Jul 31 1990 -by- MichaelE
**          Created.
**
**      Thu Oct 25 1990 -by- MichaelE
**          Added restart, horz. scroll, added SKIPDESC reading desc. strings.
**
**      Sat Oct 27 1990 -by- MichaelE
**          Added FileCopy.  Uses SULIB.LIB and LZCOPY.LIB. Finished stuff
**          for case of installing a driver with more than one type.
**
**      May 1991 -by- JohnYG
**          Added and replaced too many things to list.  Better management
**          of removed drivers, correct usage of DRV_INSTALL/DRV_REMOVE,
**          installing VxD's, replaced "Unknown" dialog with an OEMSETUP.INF
**          method, proper "Cancel" method, fixed many potential UAE's.
*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <cpl.h>
#include <cphelp.h>

#include "drivers.h"
#include "sulib.h"

typedef struct
{
        int idIcon;
        int idName;
        int idInfo;
        BOOL bEnabled;
        DWORD dwContext;
        PSTR pszHelp;
} APPLET_INFO;

#define NUM_APPLETS     1
#define OBJECT_SIZE     1024

APPLET_INFO near applets[NUM_APPLETS];
BOOL     bBadOemSetup;
BOOL     bRestart = FALSE;
int      iRestartMessage = 0;
BOOL     bInstallBootLine = FALSE;
BOOL     bCopyVxD;
BOOL     bFindOEM = FALSE;
BOOL     bRelated = FALSE;
BOOL     bDriversAppInUse;
BOOL     bCopyingRelated;
BOOL     bDescFileValid;
HANDLE   myInstance;
HWND     hlistbox;
UINT     wHelpMessage;
DWORD    dwContext;
PINF     pinfOldDefault;
char     szDriversHlp[24];
char     szLastQuery[20];
char     szSetupInf[18];
char     szKnown[250];
char     szRestartDrv[80];
char     szUnlisted[150];
char     szRelatedDesc[30];
char     szAppName[26];
char     szDrivers[12];
char     szRemove[12];
char     szControlIni[20];
char     szSysIni[20];
char     szMCI[6];
char     szOutOfRemoveSpace[54];
char     szDriversDesc[38];
char     szUserDrivers[38];

// Where the source of files to copy is - user updates

char     szDirOfSrc[MAX_PATH];
char     szAddDriver[36];
char     szNoDesc[36];
char     szError[20];
char     szRemoveOrNot[250];
char     szRemoveOrNotStrict[250];
char     szStringBuf[128];
char     szMDrivers[38];
char     szMDrivers32[38];
char     szFullPath[MAXFILESPECLEN];
char     szSystem[MAX_PATH];
char     szOemInf[MAX_PATH];
char     aszClose[16];
char     szFileError[50];

static   HANDLE   hIList;
static   HANDLE   hWndMain;

/*
 *  Global flag telling us if we're allowed to write to ini files
 */

 BOOL IniFileWriteAllowed;

DWORD GetFileDateTime     (LPSTR);
PSTR  GetProfile          (PSTR,PSTR, PSTR, PSTR, int);
int   AddIDriver          (HWND, PIDRIVER);
void  AddIDrivers         (HWND, PSTR, PSTR);
BOOL  InitInstalled       (HWND, PSTR);
BOOL  InitAvailable       (HWND, int);
void  CloseDrivers        (HWND);
void  RemoveAvailable     (HWND);
BOOL  UserInstalled       (PSTR);
BOOL  RestartDlg          (HWND, unsigned, UINT, LONG);
BOOL  AddUnlistedDlg      (HWND, unsigned, UINT, LONG);
int   AvailableDriversDlg (HWND, unsigned, UINT, LONG);
BOOL  ListInstalledDlg    (HWND, unsigned, UINT, LONG);
LONG  CPlApplet           (HWND, unsigned, UINT, LONG);
void  ReBoot              (HWND);

/*
 *  CheckSectionAccess()
 *
 *  See if we can read/write to a given section
 */


 BOOL CheckSectionAccess(char *szIniFile, char *SectionName)
 {
     static char TestKey[] = "TestKey!!!";
     static char TestData[] = "TestData";
     static char ReturnData[50];

    /*
     *   Check we can write, read back and delete our key
     */

     return WritePrivateProfileString(SectionName,
                                      TestKey,
                                      TestData,
                                      szIniFile) &&

            GetPrivateProfileString(SectionName,
                                    TestKey,
                                    "",
                                    ReturnData,
                                    sizeof(ReturnData),
                                    szIniFile) == (DWORD)strlen(TestData) &&

            WritePrivateProfileString(SectionName,
                                      TestKey,
                                      NULL,
                                      szIniFile);
 }


/*
 *  CheckIniAccess()
 *
 *  Checks access to our 2 .ini file sections - DRIVERS_SECTION and
 *  MCI_SECTION by just writing and reading some junk
 *
 *  Basically if we don't have access to these sections we're not
 *  going to allow Add and Remove.  The individual MCI drivers must
 *  take care not to put their data into non-writeable storage although
 *  this completely messes up the default parameters thing so we're going
 *  to put these into a well-known key in the win.ini file (ie per user).
 *
 */

 BOOL CheckIniAccess(void)
 {
     return CheckSectionAccess(szSysIni, szDrivers) &&
            CheckSectionAccess(szSysIni, szMCI) &&
            CheckSectionAccess(szControlIni, szUserDrivers) &&
            CheckSectionAccess(szControlIni, szDriversDesc) &&
            CheckSectionAccess(szControlIni, szRelatedDesc);
 }

/*
 *  QueryRemoveDrivers()
 *
 *  Ask the user if they're sure.  If the Driver is one required by the
 *  system (ie not listed in [Userinstallable.drivers] in control.ini)
 *  warn the user of that too.
 */

 BOOL NEAR PASCAL QueryRemoveDrivers(HWND hDlg, PSTR szKey, PSTR szDesc)
 {
     char bufout[MAXSTR];

     if (UserInstalled(szKey))
          wsprintf(bufout, szRemoveOrNot, (LPSTR)szDesc);
     else
          wsprintf(bufout, szRemoveOrNotStrict, (LPSTR)szDesc);

     return (MessageBox(hDlg, bufout, szRemove,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDYES );
 }

/*
 *  GetProfile()
 *
 *  Get private profile strings.
 */

 PSTR GetProfile(PSTR pstrAppName, PSTR pstrKeyName, PSTR pstrIniFile,
                 PSTR pstrRet, int iSize)
 {
     char szNULL[2];

     szNULL[0] = '\0';
     GetPrivateProfileString(pstrAppName, (pstrKeyName==NULL) ? NULL :
         (LPSTR)pstrKeyName, szNULL, pstrRet, iSize, pstrIniFile);
     return(pstrRet);
 }

/*********************************************************************
 *
 *  AddIDriver()
 *
 *  Add the passed driver to the Installed drivers list box, return
 *  the list box index.
 *
 *********************************************************************/

int AddIDriver(HWND hWnd, PIDRIVER pIDriver)
{
    int     iIndex;
    PIDRIVER pIDriverlocal;

    iIndex = (int)SendMessage(hWnd, LB_GETCOUNT, 0, 0L);
    while ( iIndex-- > 0)
    if ( (int)(pIDriverlocal = (PIDRIVER)SendMessage(hWnd, LB_GETITEMDATA, iIndex, 0L)) != LB_ERR)
        if (!FileNameCmp(pIDriverlocal->szFile, pIDriver->szFile))
           return(0);

    //
    // create the list box item
    //
    if ((iIndex = (int)SendMessage(hWnd, LB_ADDSTRING, 0,
        (LONG)(LPSTR)pIDriver->szDesc)) != LB_ERR)
        SendMessage(hWnd, LB_SETITEMDATA, iIndex, (LONG)pIDriver);

    return(iIndex);
}

/*********************************************************************
 *
 *  AddIDrivers()
 *
 *  Add drivers in the passed key strings list to the Installed Drivers box.
 *
 *********************************************************************/

void AddIDrivers(HWND hWnd, PSTR pstrKeys, PSTR pstrSection)
{
    PIDRIVER    pIDriver;
    HWND        hWndInstalled;
    PSTR        pstrKey;
    PSTR        pstrDesc;

    hWndInstalled = GetDlgItem(hWnd, LB_INSTALLED);
    pstrKey = pstrKeys;
    pstrDesc = (PSTR)LocalAlloc(LPTR, MAXSTR);

   /*
    *  parse key strings for profile, and make IDRIVER structs
    */

    while ( *pstrKey )
    {
        pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER));
        if ( pIDriver )
        {
            PSTR        pstr;

            if (*GetProfile(pstrSection, pstrKey, szSysIni, pIDriver->szFile,
                sizeof(pIDriver->szFile)) == '\0')
            {
                LocalFree((HANDLE)pIDriver);
                goto nextkey;
            }

            for ( pstr=pIDriver->szFile; *pstr && (*pstr!=COMMA) &&
                (*pstr!=SPACE); pstr++ )
                    ;
            *pstr = '\0';

#ifdef TRASHDRIVERDESC
            if (bDescFileValid)
#endif
              /*
               *  try to load the cached description
               */

               GetProfile(szDriversDesc,
                          pIDriver->szFile,
                          szControlIni,
                          pIDriver->szDesc,
                          sizeof(pIDriver->szDesc));

           /*
            *  if we failed, then try to get the information from
            *  mmdriver.inf or the exehdr
            */

            if (pIDriver->szDesc[0] == '\0')
            {
               if (LoadDesc(pIDriver, pstrKey, pstrDesc) != DESC_NOFILE)
               {
                   if (!*pstrDesc)
                   {
                       /*
                        *  failed to load a description.
                        *  The file isn't in setup.inf
                        *  and doesn't have exehdr information
                        */

                        lstrcpy(pIDriver->szDesc, pIDriver->szFile);
                        lstrcat(pIDriver->szDesc, szNoDesc);
                   }
                   else
                        lstrcpy(pIDriver->szDesc, pstrDesc);

                   WritePrivateProfileString(szDriversDesc, pIDriver->szFile,
                               pIDriver->szDesc, szControlIni);
               } else {
                    LocalFree((HANDLE)pIDriver);
                    goto nextkey;
               }
            }

            strncpy(pIDriver->szAlias, pstrKey, sizeof(pIDriver->szAlias));
            pIDriver->szAlias[sizeof(pIDriver->szAlias) - 1] = 0;
            mbstowcs(pIDriver->wszAlias, pIDriver->szAlias, MAX_PATH);

            strncpy(pIDriver->szSection, pstrSection,sizeof(pIDriver->szSection));
            pIDriver->szSection[sizeof(pIDriver->szSection) - 1] = 0;
            mbstowcs(pIDriver->wszSection, pIDriver->szSection, MAX_PATH);

            pIDriver->KernelDriver = IsFileKernelDriver(pIDriver->szFile);
            pIDriver->fQueryable = pIDriver->KernelDriver ? 0 : -1;

            if (AddIDriver(hWndInstalled, pIDriver) < LB_OKAY)
                LocalFree((HANDLE)pIDriver);
        }
        else
           break;  //ERROR Low Memory

nextkey: while (*pstrKey++);
    }
    LocalFree((HANDLE)pstrDesc);
}


/*********************************************************************
 *
 *  FindInstallableDriversSection()
 *
 *********************************************************************/

PINF FindInstallableDriversSection(PINF pinf)
{
    PINF pinfFound;

    pinfFound = infFindSection(pinf, szMDrivers32);

    if (pinfFound == NULL) {
        pinfFound = infFindSection(pinf, szMDrivers);
    }

    return pinfFound;
}


/*********************************************************************
 *
 *  InitInstalled()
 *
 *  Add the drivers installed in [DRIVERS] and [MCI] to the Installed
 *  Drivers list box.
 *
 *********************************************************************/

BOOL InitInstalled(HWND hWnd, PSTR pstrSection)
{
    BOOL    bSuccess=FALSE;
    PSTR    pstr;

#ifdef TRASHDRIVERDESC
    UINT    wTime;
    BOOL    fForce;
    char    szOut[10];

    wTime = LOWORD(GetFileDateTime(szControlIni)) >> 1;
    if (fForce = (GetPrivateProfileInt((LPSTR)szUserDrivers,
                   (LPSTR)szLastQuery,  0, (LPSTR)szControlIni) != wTime))
    {
        wsprintf(szOut, "%d", wTime);
        WritePrivateProfileString((LPSTR)szUserDrivers, (LPSTR)szLastQuery,
                                        szOut, (LPSTR)szControlIni);
        WritePrivateProfileString((LPSTR)szDriversDesc, NULL, NULL,
                                                (LPSTR)szControlIni);
        bDescFileValid = FALSE;
    }
    else
        bDescFileValid = TRUE;
#endif


    pstr = (PSTR)LocalAlloc(LPTR, SECTION);
    if ( pstr )
    {
        if (*GetProfile(pstrSection, NULL, szSysIni, pstr, SECTION ))
        {
            AddIDrivers(hWnd,pstr,pstrSection);
            bSuccess = TRUE;
        }

        LocalFree((HANDLE)pstr);
    }
    return(bSuccess);
}

static VOID CancelToClose(HWND hwnd)
{
    char    aszText[sizeof(aszClose)];

    GetDlgItemText(hwnd, IDCANCEL, aszText, sizeof(aszText));
    if (lstrcmp(aszText, aszClose))
        SetDlgItemText(hwnd, IDCANCEL, aszClose);
}

static BOOL fRemove=FALSE;

/********************************************************************
 *
 *  ListInstalledDlg()
 *
 *  Display list of installed installable drivers.  Return TRUE/FALSE
 *  indicating if should restart windows.
 *
 ********************************************************************/

BOOL ListInstalledDlg(HWND hDlg, UINT uMsg, UINT wParam, LONG lParam)
{
    DRVCONFIGINFO   DrvConfigInfo;
    HANDLE          hWndI, hWnd;
    PIDRIVER        pIDriver;
    int             iIndex;

    switch ( uMsg )
    {
        case WM_INITDIALOG:

            wsStartWait();

//   Window is redrawn twice at startup but showwindow does not fix it
//          ShowWindow(hDlg, TRUE);

            hWndI = GetDlgItem(hDlg, LB_INSTALLED);
            SendMessage(hWndI,WM_SETREDRAW, FALSE, 0L);

           /*
            *  Handle the fact that we may not be able to update our .ini
            *  sections
            *
            */

            IniFileWriteAllowed = CheckIniAccess();

            if (!IniFileWriteAllowed) {
                EnableWindow(GetDlgItem(hDlg, ID_ADD),FALSE);
                {
                    char szCantAdd[120];
                    LoadString(myInstance, IDS_CANTADD, szCantAdd,
                                                        sizeof(szCantAdd));
                    MessageBox(hDlg, szCantAdd, szError,
                                    MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
                }
            }


            if (!(InitInstalled(hDlg, szDrivers) | InitInstalled(hDlg, szMCI)))
            {
                EnableWindow(GetDlgItem(hDlg, ID_CONFIGURE),FALSE);
                EnableWindow(GetDlgItem(hDlg, ID_REMOVE),FALSE);
            }


            SendMessage(hWndI, LB_SETCURSEL, 0, 0L );

            PostMessage(hDlg, WM_COMMAND, MAKELONG(LB_INSTALLED, LBN_SELCHANGE),
                        (LONG)hWndI);
            SendMessage(hWndI,WM_SETREDRAW, TRUE, 0L);
            wsEndWait();

            break;

        case WM_COMMAND:
            hlistbox = hWndI = GetDlgItem(hDlg, LB_INSTALLED);
            hWndMain = hDlg;

            iIndex = (int)SendMessage(hWndI, LB_GETCURSEL, 0, 0L);

            pIDriver =  (PIDRIVER)SendMessage(hWndI, LB_GETITEMDATA, iIndex, 0L);

            switch ( LOWORD(wParam ))
            {
                case  IDH_CHILD_DRIVERS:
                  goto DoHelp;

                case LB_INSTALLED:
                    switch ( HIWORD(wParam) )
                    {
                        case LBN_SELCHANGE:
                        case LBN_SETFOCUS:
                        {
                            BOOL fConfigurable;

                            fConfigurable = ((iIndex >= LB_OKAY) && IsConfigurable(pIDriver, hDlg));
                            EnableWindow(GetDlgItem(hDlg, ID_CONFIGURE),
                                         fConfigurable);
                            // Only enable the button if we are not in the
                            // process of removing a driver.  Otherwise a
                            // button click can get stacked up, the line
                            // in the list box can get removed, perhaps as a
                            // related driver, and bad things start to happen.
                            EnableWindow(GetDlgItem(hDlg, ID_REMOVE),
                                         IniFileWriteAllowed && !fRemove &&
                                            iIndex != LB_ERR);
                            break;
                        }
                        case LBN_DBLCLK:
                            if ( IsWindowEnabled(hWnd = GetDlgItem(hDlg, ID_CONFIGURE)) )
                                PostMessage(hDlg, WM_COMMAND, MAKELONG(ID_CONFIGURE, BN_CLICKED),(LONG)hWnd);
                            break;
                    }
                    break;

                case ID_ADD:
                    DialogBox(myInstance, MAKEINTRESOURCE(DLG_KNOWN), hDlg,
                        AvailableDriversDlg);
                    CancelToClose(hDlg);
                    break;

                case ID_CONFIGURE:
                    {
                        HANDLE hDriver;

                        hDriver = OpenDriver(pIDriver->wszAlias,
                                             pIDriver->wszSection,
                                             0L);

                        if (hDriver)
                        {
                            InitDrvConfigInfo(&DrvConfigInfo, pIDriver);
                            if ((SendDriverMessage(
                                     hDriver,
                                     DRV_CONFIGURE,
                                     (LONG)hDlg,
                                     (LONG)(LPDRVCONFIGINFO)&DrvConfigInfo) ==
                                DRVCNF_RESTART))
                            {
                               iRestartMessage= 0;
                               DialogBox(myInstance,
                                  MAKEINTRESOURCE(DLG_RESTART), hDlg, RestartDlg);
                            }
                            CloseDriver(hDriver, 0L, 0L);
                            CancelToClose(hDlg);
                        }
                        else
                            OpenDriverError(hDlg, pIDriver->szDesc, pIDriver->szFile);
                    }
                    break;

                case ID_REMOVE:
                    // Prevent any more REMOVE button presses
                    // Otherwise one can get stacked up and cause trouble,
                    // particularly if it is assocated with a driver that
                    // is automatically removed.  We have to use a static
                    // as any focus changes cause the button to change state.
                    fRemove = TRUE;
                    EnableWindow(GetDlgItem(hDlg, ID_REMOVE),FALSE);
                    if (QueryRemoveDrivers(hDlg, pIDriver->szAlias, pIDriver->szDesc))
                    {
                       LONG Status;
                       Status = PostRemove(hWndI, pIDriver, TRUE, iIndex);
                       if (Status != DRVCNF_CANCEL)
                       {
                          // As we have removed a driver we need to reset
                          // the current selection
                          PostMessage(hWndI, LB_SETCURSEL, 0, 0L );
                          iRestartMessage= IDS_RESTART_REM;
                          if (Status == DRVCNF_RESTART) {
                              DialogBox(myInstance,
                                  MAKEINTRESOURCE(DLG_RESTART), hDlg, RestartDlg);
                          }
                       }
                    }
                    /* Reenable the Config/Remove buttons */
                    fRemove = FALSE;     // Remove can be activated again

                    // Force the button state to be updated
                    PostMessage(hWndMain, WM_COMMAND,
                                MAKELONG(LB_INSTALLED, LBN_SELCHANGE),
                                (LONG)hWndI);
                    CancelToClose(hDlg);
                    break;

                case IDCANCEL:
                    wsStartWait();

                   /*
                    *  free the driver structs added as DATAITEM
                    */

                    CloseDrivers(hWndI);
                    wsEndWait();
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        case WM_DESTROY:

            return(FALSE);

        default:
            if (uMsg == wHelpMessage)
            {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_CHILD_DRIVERS);
                return TRUE;
            }
            else
                return FALSE;
         break;
    }
    return(TRUE);
}




/*--------------------------------------------------------------------------*
 *                                                                          *
 *                                                                          *
 *  LB_AVAILABLE Dialog Routines                                            *
 *                                                                          *
 *                                                                          *
 *--------------------------------------------------------------------------*/

/*
 *  DLG: LB_AVAILABLE
 *
 *  InitAvailable()
 *
 *  Add the available drivers from mmdriver.inf to the passed list box.
 *  The format of [Installable.drivers] in setup.inf is:
 *  profile=disk#:driverfile,"type1,type2","Installable driver Description","vxd1.386,vxd2.386","opt1,2,3"
 *
 *  for example:
 *
 *  driver1=6:sndblst.drv,"midi,wave","SoundBlaster MIDI and Waveform drivers","vdmad.386,vadmad.386","3,260"
 */

BOOL InitAvailable(HWND hWnd, int iLine)
{
    PINF    pinf;
    BOOL    bInitd=FALSE;
    PSTR    pstrKey;
    int     iIndex;
    char    szDesc[MAX_INF_LINE_LEN];

    SendMessage(hWnd,WM_SETREDRAW, FALSE, 0L);

   /*
    *  Parse the list of keywords and load their strings
    */

    for (pinf = FindInstallableDriversSection(NULL); pinf; pinf = infNextLine(pinf))
    {
        //
        // found at least one keyname!
        //
        bInitd = TRUE;
        if ( (pstrKey = (PSTR)LocalAlloc(LPTR, MAX_SYS_INF_LEN)) != NULL )
                infParseField(pinf, 0, pstrKey);
        else
            break;
       /*
        *  add the installable driver's description to listbox, and filename as data
        */

        infParseField(pinf, 3, szDesc);

        if ( (iIndex = (int)SendMessage(hWnd, LB_ADDSTRING, 0, (LONG)(LPSTR)szDesc)) != LB_ERR )

            SendMessage(hWnd, LB_SETITEMDATA, iIndex, (LONG)pstrKey);

    }

    if (iLine == UNLIST_LINE)
    {
        //
        // Add the "Install unlisted..." choice to the top of the list
        // box.
        LoadString(myInstance, IDS_UPDATED, szDesc, sizeof(szDesc));
        if ((iIndex = (int)(LONG)SendMessage(hWnd, LB_INSERTSTRING, 0, (LPARAM)(LPSTR)szDesc)) != LB_ERR)
            SendMessage(hWnd, LB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)0);
     }
     if (bInitd)

         SendMessage(hWnd, LB_SETCURSEL, 0, 0L );


     SendMessage(hWnd,WM_SETREDRAW, TRUE, 0L);
     return(bInitd);
}


/*
 *  DLG: LB_AVAILABLE
 *
 *  RemoveAvailable()
 *
 *  Remove all drivers from the listbox and free all storage associated with
 *  the keyname
 */

void RemoveAvailable(HWND hWnd)
{
    int iIndex;
    HWND hWndA;
    PSTR pstrKey;

    hWndA = GetDlgItem(hWnd, LB_AVAILABLE);
    iIndex = (int)SendMessage(hWndA, LB_GETCOUNT, 0, 0L);
    while ( iIndex-- > 0)
    {
        if (( (int)(pstrKey = (PSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex,
            0L)) != LB_ERR ) && pstrKey)
            LocalFree((HLOCAL)pstrKey);
    }
}


/*
 *  DLG: LB_AVAILABLE
 *
 *  AvailableDriversDlg()
 *
 *  List the available installable drivers or return FALSE if there are none.
 */

int AvailableDriversDlg(HWND hWnd, UINT uMsg, UINT wParam, LONG lParam)
{
    PSTR    pstrKey;    //-jyg- added

    HWND    hWndA, hWndI;
    int     iIndex;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            ShowWindow(hWnd, TRUE);
            wsStartWait();
            if (pinfOldDefault)
            {
                infSetDefault(pinfOldDefault);
                pinfOldDefault = NULL;
            }

            if ( !InitAvailable(hWndA = GetDlgItem(hWnd, LB_AVAILABLE), UNLIST_LINE))
            {
               /*
                *  We weren't able to find the [installable.drivers] section
                *  of the
                *  mmdriver.inf OR it was corrupt.  Go ahead and query the
                *  user to find an oemsetup.inf to make our default.  This
                *  is a bad state.
                */
                EndDialog(hWnd, FALSE);
                bFindOEM = TRUE;
                strcpy(szDrv, szOemInf);
                if (DialogBox(myInstance, MAKEINTRESOURCE(DLG_INSERTDISK),
                        hWnd,  AddDriversDlg) == TRUE)
                    PostMessage(hWnd, WM_INITDIALOG, 0, 0L);
                else
                    pinfOldDefault = infSetDefault(pinfOldDefault);

                bFindOEM = FALSE;
            }
            wsEndWait();
            break;

        case WM_COMMAND:

            switch ( LOWORD(wParam ))
            {
                case  IDH_DLG_ADD_DRIVERS:
                  goto DoHelp;


                case LB_AVAILABLE:

                    // Hm... We've picked it.

                    if ( HIWORD(wParam) == LBN_DBLCLK )
                        SendMessage(hWnd, WM_COMMAND, IDOK, 0L);
                    break;

                case IDOK:

                   /*
                    *  We've made our selection
                    */

                    hWndA = GetDlgItem(hWnd, LB_AVAILABLE);

                    if ( (iIndex = (int)SendMessage(hWndA, LB_GETCURSEL, 0, 0L)) != LB_ERR)
                    {
                        if (!iIndex)
                        {
                           /*
                            *  The first entry is for OEMs
                            */

                            int iFound;
                            bBadOemSetup = FALSE;

                            bFindOEM = TRUE;
                            hMesgBoxParent = hWnd;
                            while ((iFound = DialogBox(myInstance,
                                    MAKEINTRESOURCE(DLG_INSERTDISK), hWnd,
                                            AddDriversDlg)) == 2);
                            if (iFound == 1)
                            {
                                    RemoveAvailable(hWnd);
                                    SendDlgItemMessage(hWnd, LB_AVAILABLE,
                                            LB_RESETCONTENT, 0, 0L);
                                    PostMessage(hWnd, WM_INITDIALOG, 0, 0L);
                            }
                            bFindOEM = FALSE;
                        }
                        else
                        {
                           /*
                            *  The user selected an entry from our .inf
                            */

                            wsStartWait();

                           /*
                            *  The  data associated with the list item is
                            *  the driver key name (field 0 in the inf file).
                            */

                            pstrKey = (PSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex, 0L);
                            bCopyingRelated = FALSE;
                            bQueryExist = TRUE;

                            if (InstallDrivers(hWndMain, hWnd, pstrKey))
                            {
                               hWndI = GetDlgItem(hWndMain, LB_INSTALLED);
                               PostMessage(hWndI, LB_SETCURSEL, 0, 0L );
                               PostMessage(hWndMain, WM_COMMAND,
                                           MAKELONG(LB_INSTALLED, LBN_SELCHANGE),
                                           (LONG)hWndI);
                               wsEndWait();

                              /*
                               *  If bRestart is true then the system must
                               *  be restarted to activate these changes
                               */

                               if (bRestart)
                               {
                                  iRestartMessage= IDS_RESTART_ADD;
                                  DialogBox(myInstance,
                                          MAKEINTRESOURCE(DLG_RESTART), hWnd,
                                              RestartDlg);
                               }
                            }
                            else
                               wsEndWait();

                            bRestart = FALSE;
                            bRelated = FALSE;
                        }
                    }
                    EndDialog(hWnd, FALSE);
                    break;

                case IDCANCEL:
                    EndDialog(hWnd, FALSE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        case WM_DESTROY:
            //
            // free the strings added as DATAITEM to the avail list

            RemoveAvailable(hWnd);
            return(FALSE);

        default:
            if (uMsg == wHelpMessage)
            {
DoHelp:
                WinHelp(hWnd, szDriversHlp, HELP_CONTEXT, IDH_DLG_ADD_DRIVERS);
                return TRUE;
            }
            else
                return FALSE;
         break;
    }
    return(TRUE);
}

/* Main CPL proc.  This is for communication with CPL.EXE
*/

LONG CPlApplet(HWND hCPlWnd, UINT uMsg, UINT lParam1, LONG lParam2)
{
    int i;
    LPNEWCPLINFO   lpCPlInfo;
    char strOldDir[MAX_PATH], strSysDir[MAX_PATH];


    switch( uMsg )
    {
        case CPL_INIT:
            wHelpMessage = RegisterWindowMessage("ShellHelp");
            return(TRUE);

        case CPL_GETCOUNT:
            return(1);

        case CPL_NEWINQUIRE:
            i = 0;
            lpCPlInfo = (LPNEWCPLINFO)lParam2;
            lpCPlInfo->hIcon = LoadIcon(myInstance,
                                          MAKEINTRESOURCE(applets[i].idIcon));

            if(!LoadString(myInstance, applets[i].idName, lpCPlInfo->szName,
                                          sizeof(lpCPlInfo->szName)))
                lpCPlInfo->szName[0] = 0;

            if(!LoadString(myInstance, applets[i].idInfo, lpCPlInfo->szInfo,
                                          sizeof(lpCPlInfo->szInfo)))
                lpCPlInfo->szInfo[0] = 0;

            lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpCPlInfo->lData = (LONG)i;
            lpCPlInfo->dwHelpContext = applets[i].dwContext;
            lstrcpy(lpCPlInfo->szHelpFile, applets[i].pszHelp);
            break;

        case CPL_DBLCLK:
            if (bDriversAppInUse)
            {
               MessageBeep(0);
               return (FALSE);
            }

            bDriversAppInUse = TRUE;
            pinfOldDefault = NULL;

            GetSystemDirectory(strSysDir, MAX_PATH);
            GetCurrentDirectory(MAX_PATH, strOldDir);

           /*
            *  Switch to the system directory for our work
            */

            SetCurrentDirectory(strSysDir);

           /*
            *  Call initialization routine
            */

            wsInfParseInit();

            if (DialogBox(myInstance,
                          MAKEINTRESOURCE(DLG_INSTALLED),
                          hCPlWnd,
                          ListInstalledDlg)) {
               /*
                *  they changed configuration of a driver and said 'yes, restart'
                */

                ReBoot(hCPlWnd);
            }
            infClose(NULL);

           /*
            *  Restore current directory setting
            */

            SetCurrentDirectory(strOldDir);

            //SetActiveWindow(hCPlWnd);
            bDriversAppInUse = FALSE;
            return (TRUE);
            break;

        case CPL_EXIT:
            break;
    }
    return(0L);
}

BOOL DllInitialize( IN PVOID hInstance
                  , IN DWORD ulReason
                  , IN PCONTEXT pctx OPTIONAL
                  )
{
    if (ulReason != DLL_PROCESS_ATTACH)
        return TRUE;

    myInstance = hInstance;
    LoadString(myInstance, IDS_CLOSE,  aszClose, sizeof(aszClose));
    LoadString(myInstance, IDS_DRIVERDESC, szDriversDesc, sizeof(szDriversDesc));
    LoadString(myInstance, IDS_FILE_ERROR, szFileError, sizeof(szFileError));
    LoadString(myInstance, IDS_INSTALLDRIVERS, szMDrivers, sizeof(szMDrivers));
    LoadString(myInstance, IDS_INSTALLDRIVERS32, szMDrivers32, sizeof(szMDrivers));
    LoadString(myInstance, IDS_RELATEDDESC, szRelatedDesc, sizeof(szRelatedDesc));
    LoadString(myInstance, IDS_USERINSTALLDRIVERS, szUserDrivers, sizeof(szUserDrivers));
    LoadString(myInstance, IDS_UNLISTED, (LPSTR)szUnlisted, sizeof(szUnlisted));
    LoadString(myInstance, IDS_KNOWN, szKnown, sizeof(szKnown));
    LoadString(myInstance, IDS_OEMSETUP, szOemInf, sizeof(szOemInf));
    LoadString(myInstance, IDS_SYSTEM, szSystem, sizeof(szSystem));
    LoadString(myInstance, IDS_OUT_OF_REMOVE_SPACE, szOutOfRemoveSpace, sizeof(szOutOfRemoveSpace));
    LoadString(myInstance, IDS_NO_DESCRIPTION, szNoDesc, sizeof(szNoDesc));
    LoadString(myInstance, IDS_ERRORBOX, szError, sizeof(szError));
    LoadString(myInstance, IDS_REMOVEORNOT, szRemoveOrNot, sizeof(szRemoveOrNot));
    LoadString(myInstance, IDS_REMOVEORNOTSTRICT, szRemoveOrNotStrict, sizeof(szRemoveOrNotStrict));
    LoadString(myInstance, IDS_SETUPINF, szSetupInf, sizeof(szSetupInf));
    LoadString(myInstance, IDS_APPNAME, szAppName, sizeof(szAppName));

    LoadString(myInstance, IDS_DRIVERS, szDrivers, sizeof(szDrivers));
    LoadString(myInstance, IDS_REMOVE, szRemove, sizeof(szRemove));
    LoadString(myInstance, IDS_CONTROLINI, szControlIni, sizeof(szControlIni));
    LoadString(myInstance, IDS_SYSINI, szSysIni, sizeof(szSysIni));
    LoadString(myInstance, IDS_MCI, szMCI, sizeof(szMCI));
    LoadString(myInstance, IDS_DEFDRIVE, szDirOfSrc, sizeof(szDirOfSrc));
    LoadString(myInstance, IDS_CONTROL_HLP, szDriversHlp, sizeof(szDriversHlp));
    LoadString(myInstance, IDS_LASTQUERY, szLastQuery, sizeof(szLastQuery));


    applets[0].idIcon = DRIVERS_ICON;
    applets[0].idName = IDS_NAME;
    applets[0].idInfo = IDS_INFO;
    applets[0].bEnabled = TRUE;
    applets[0].dwContext = IDH_CHILD_DRIVERS;
    applets[0].pszHelp = szDriversHlp;
    return TRUE;
}

void DeleteCPLCache(void)
{
    HKEY hKeyCache;

    if (ERROR_SUCCESS ==
        RegOpenKey(HKEY_CURRENT_USER,
                   TEXT("Control Panel\\Cache\\multimed.cpl"),
                   &hKeyCache)) {
        for ( ; ; ) {
            TCHAR Name[50];

            if (ERROR_SUCCESS ==
                RegEnumKey(hKeyCache,
                           0,
                           Name,
                           sizeof(Name) / sizeof(Name[0]))) {
                HKEY hSubKey;

                RegDeleteKey(hKeyCache, Name);
            } else {
                break;    // leave loop
            }
        }

        RegDeleteKey(hKeyCache, NULL);
        RegCloseKey(hKeyCache);
    }
}


/*
** RestartDlg()
**
** Offer user the choice to (not) restart windows.
*/
BOOL RestartDlg(HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam)
{
    switch (uiMessage)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
               case IDCANCEL:
                    //
                    // don't restart windows
                    //
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    //
                    // do restart windows, *dont* dismiss dialog incase
                    // the user canceled it.
                    //
                    ReBoot(hDlg);
                    SetActiveWindow(hDlg);
                    //EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_INITDIALOG:
              /*
              **  Delete the control panel's cache so it will get it
              **  right!
              */

              DeleteCPLCache();


              if (iRestartMessage)
              {
                char szMesg1[300];
                char szMesg2[300];

                LoadString(myInstance, iRestartMessage, szMesg1, sizeof(szMesg1));
                wsprintf(szMesg2, szMesg1, (LPSTR)szRestartDrv);
                SetDlgItemText(hDlg, IDS_RESTARTTEXT, (LPSTR)szMesg2);
              }
              return TRUE;

        case WM_KEYUP:
            if (wParam == VK_F3)
                //
                // don't restart windows
                //
                EndDialog(hDlg, FALSE);
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * UserInstalled()
 *
 *
 */

BOOL UserInstalled(PSTR szKey)
{
        char buf[MAXSTR];

        if (*GetProfile(szUserDrivers, (LPSTR)szKey, szControlIni, buf, MAXSTR) != '\0')
            return(TRUE);
        else
            return(FALSE);
}

/*
 *   AddUnlistedDlg()
 *
 *   The following function processes requests by the user to install unlisted
 *   or updated drivers.
 *
 *   PARAMETERS:  The normal Dialog box parameters
 *   RETURN VALUE:  The usual Dialog box return value
 */

BOOL AddUnlistedDlg(HWND hDlg, unsigned nMsg, UINT wParam, LONG lParam)
{
  switch (nMsg)
  {
      case WM_INITDIALOG:
      {
          HWND hListDrivers;
          BOOL bFoundDrivers;

          wsStartWait();
          hListDrivers = GetDlgItem(hDlg, LB_UNLISTED);

          /* Search for drivers */
          bFoundDrivers = InitAvailable(hListDrivers, NO_UNLIST_LINE);
          if (!bFoundDrivers)
          {
                //
                // We weren't able to find the MMDRIVERS section of the
                // setup.inf OR it was corrupt.  Go ahead and query the
                // user to find an oemsetup.inf to make our default.  This
                // is a bad state.
                //

                int iFound;

                bFindOEM = TRUE;
                bBadOemSetup = TRUE;
                while ((iFound = DialogBox(myInstance,
                        MAKEINTRESOURCE(DLG_INSERTDISK), hMesgBoxParent,
                                AddDriversDlg)) == 2);
                bFindOEM = FALSE;
                if (iFound == 1)
                {
                        SendDlgItemMessage(hDlg, LB_AVAILABLE,
                                LB_RESETCONTENT, 0, 0L);
                        PostMessage(hDlg, WM_INITDIALOG, 0, 0L);
                }
                EndDialog(hDlg, FALSE);
          }
          SendMessage(hListDrivers, LB_SETCURSEL, 0, 0L);
          wsEndWait();

          break;
        }

      case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDH_DLG_ADD_UNKNOWN:
              goto DoHelp;

            case LB_UNLISTED:
              if (HIWORD(wParam) != LBN_DBLCLK)
                  break;

              // else Fall through here
            case IDOK:
            {
             HWND hWndI, hWndA;
             int iIndex;
             PSTR pstrKey;

             hWndA = GetDlgItem(hDlg, LB_UNLISTED);
             if ( (iIndex = (int)SendMessage(hWndA, LB_GETCURSEL, 0, 0L))
                                                             != LB_ERR)
             {
                wsStartWait();
                pstrKey = (PSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex, 0L);
                bCopyingRelated = FALSE;
                bQueryExist = TRUE;
                if (InstallDrivers(hWndMain, hDlg, pstrKey))
                {
                   hWndI = GetDlgItem(hWndMain, LB_INSTALLED);
                   PostMessage(hWndI, LB_SETCURSEL, 0, 0L );
                   PostMessage(hWndMain, WM_COMMAND,
                               MAKELONG(LB_INSTALLED, LBN_SELCHANGE),
                               (LONG)hWndI);

                   wsEndWait();
                   if (bRestart)
                   {
                      iRestartMessage= IDS_RESTART_ADD;
                      DialogBox(myInstance,   MAKEINTRESOURCE(DLG_RESTART),
                                                      hDlg, RestartDlg);
                   }
                 }
                 else
                   wsEndWait();
                 bRelated = FALSE;
                 bRestart = FALSE;
              }
              EndDialog(hDlg, FALSE);
            }
            break;

            case IDCANCEL:
              EndDialog(hDlg, wParam);
              break;

            default:
              return FALSE;
          }

      default:
        if (nMsg == wHelpMessage)
        {
DoHelp:
            WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_ADD_UNKNOWN);
            break;
        }
        else
            return FALSE;
   }
   return TRUE;
}
/*
 *  ReBoot()
 *
 *  Restart the system.  If this fails we put up a message box
 */

 void ReBoot(HWND hDlg)
 {
     DWORD Error;
     BOOLEAN WasEnabled;

    /*
     *  We must adjust our privilege level to be allowed to restart the
     *  system
     */

     RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                         TRUE,
                         FALSE,
                         &WasEnabled
                       );
    /*
     *  Try to reboot the system
     */

     if (!ExitWindowsEx(EWX_REBOOT, 0xFFFFFFFF)) {

         Error = GetLastError();

        /*
         *  Put up a message box if we failed
         */

         if (Error != NO_ERROR) {
            char szCantRestart[80];
            LoadString(myInstance,
                       Error == ERROR_PRIVILEGE_NOT_HELD  ||
                       Error == ERROR_NOT_ALL_ASSIGNED  ||
                       Error == ERROR_ACCESS_DENIED ?
                           IDS_CANNOT_RESTART_PRIVILEGE :
                           IDS_CANNOT_RESTART_UNKNOWN,
                       szCantRestart,
                       sizeof(szCantRestart));

            MessageBox(hDlg, szCantRestart, szError,
                       MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
         }
     }
 }

/*
 *  CloseDrivers()
 *
 *  Make free memory for drivers.
 */
void CloseDrivers(HWND hWnd)
{
    PIDRIVER    pIDriver;
    int         iIndex;

   /*
    *  Go through the drivers remaining in the Installed list
    */
    iIndex = (int)SendMessage(hWnd, LB_GETCOUNT, 0, 0L);
    while ( iIndex-- > 0 )
        if ( (int)(pIDriver = (PIDRIVER)SendMessage(hWnd, LB_GETITEMDATA,
                                                   iIndex, 0L)) != LB_ERR)
        {
            LocalFree((HLOCAL)pIDriver);
        }

}



void OpenDriverError(HWND hDlg, LPSTR szDriver, LPSTR szFile)
{
        char szMesg[MAXSTR];
        char szMesg2[MAXSTR];

        LoadString(myInstance, IDS_INSTALLING_DRIVERS, szMesg, sizeof(szMesg));
        wsprintf(szMesg2, szMesg, szDriver, szFile);
        MessageBox(hDlg, szMesg2, szError, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\filecopy.c ===
/**************************************************************************
 *
 *  FILECOPY.C
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Control Panel Applet for installing installable driver.
 *
 *  This file contains hooks to SULIB, COMPRESS libraries, and the dialogs
 *  from the display applet to prompt for insert disk, error action...
 *
 *  Note SULIB.LIB, COMPRESS.LIB, SULIB.H come from the display applet
 *  and are updated here if/when updated there.
 *
 *  History:
 *
 *      Sat Oct 27 1990 -by- MichaelE
 *          Munged from display applet's DLG.C.
 *
 **************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include "drivers.h"
#include "sulib.h"
#include <cphelp.h>

// Hidden parameter between wsSingleCopyStatus and wExistDlg

static char     szErrMsg[MAXSTR];

// Hidden parameters passed from wsInsertDisk to wDiskDlg

static char     CurrentDisk[MAX_PATH];
static LPSTR    szEdit;

// Function prototypes

BOOL wsInfParseInit    (void);
int  fDialog           (int, HWND, DLGPROC);
UINT wsCopyError       (int, LPSTR);
UINT wsInsertDisk      (LPSTR, LPSTR);
BOOL wsDiskDlg         (HWND, UINT, WPARAM, LPARAM);
BOOL wsExistDlg        (HWND, UINT, WPARAM, LPARAM);

/*
 *  Load the description from the inf file or the driver file.
 *
 *  The type of file is also returned in the driver structure.
 *
 *  Parameters :
 *       pIDriver - Pointer to driver data - in particular the driver file name
 *       pstrKey  - The ini file key under which the driver should be found
 *       pstrDesc - Where to return the description
 */

 int LoadDesc(PIDRIVER pIDriver, PSTR pstrKey, PSTR pstrDesc)
 {
     PINF        pinf;
     CHAR        szFileName[MAX_INF_LINE_LEN];
     PSTR        pstrFile = pIDriver->szFile;
     CHAR        ExpandedName[MAX_PATH];
     PSTR        FilePart;

    /*
     *  See if the file can be found
     */


     if (SearchPath(NULL, pstrFile, NULL, MAX_PATH, ExpandedName, &FilePart)
         == 0) {
         return(DESC_NOFILE);
     }

    /*
     * -jyg- Let's look in the mmdriver.inf first!
     */

     for (pinf = FindInstallableDriversSection(NULL);
          pinf;
          pinf = infNextLine(pinf))
     {
         infParseField(pinf, 1, szFileName); // compare filename

        /*
         *  FileName strips of drive and path
         */

         if (lstrcmpi(FileName(pstrFile), FileName(szFileName)) == 0)
         {
             infParseField(pinf, 3, pstrDesc); // get Description Field

             return DESC_INF;
         }
     }

    /*
     *  If that failed try to get the description from the file
     */

     if (!GetFileTitle(ExpandedName, pstrDesc, MAXSTR)) {
         return DESC_EXE;
     } else {
         return DESC_NOFILE;
     }
 }

/*
 *  Find the install path from the registry if there is one there
 */

 BOOL GetInstallPath(LPSTR szDirOfSrc)
 {
     HKEY RegHandle;
     DWORD Type;
     DWORD Length = MAX_PATH - 1;
     BOOL Found = FALSE;

     if (MMSYSERR_NOERROR ==
         RegOpenKey(HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                    &RegHandle)) {

         if (MMSYSERR_NOERROR ==
             RegQueryValueEx(RegHandle,
                             TEXT("SourcePath"),
                             NULL,
                             &Type,
                             szDirOfSrc,
                             &Length) &&
             Type == REG_SZ) {

             Found = TRUE;
         }

         RegCloseKey(RegHandle);

     }

     return Found;
 }

/*
 *  Initialize the SULIB library stuff which loads the mmdriver.inf file
 *  into RAM and parses it all over the place.
 */

 BOOL wsInfParseInit(void)
 {
     OFSTRUCT    os;
     PINF        pinf;
     char        szNoInf[MAXSTR];
     int         iDrive;
     static BOOL bChkCDROM = FALSE;

    /*
     *  put up an hour glass here
     */

     wsStartWait();

     if (OpenFile(szSetupInf, &os, OF_EXIST) == -1) {

         wsEndWait();
         LoadString(myInstance, IDS_NOINF, szNoInf, sizeof(szNoInf));
         MessageBox(hMesgBoxParent, szNoInf, szDrivers, MB_OK | MB_ICONEXCLAMATION);
         return FALSE;
     }

     pinf = infOpen(os.szPathName);

     wsEndWait();

     GetWindowsDirectory(szSetupPath, sizeof(szSetupPath));

     if (bChkCDROM == FALSE) {

         /*
          *  Use the setup path from the registry if there is one
          */

          if (!GetInstallPath(szDirOfSrc))
          {
             /*
              *  use the CD ROM drive as the default drive (if there is one)
              */

              for ( iDrive='A'; iDrive <= 'Z'; iDrive++ ) {
                  szDirOfSrc[0] = iDrive;

                  if ( GetDriveType(szDirOfSrc) == DRIVE_CDROM)
                  {
                          break;
                  }
                 /*
                  *  If we didn't find a CD ROM default to the A drive
                  */

                  if (iDrive == 'Z') {
                      szDirOfSrc[0] = 'A';
                  }
              }
          }

          bChkCDROM = TRUE;
     }

     lstrcpy(szDiskPath, szDirOfSrc);

     return TRUE;
 }


/*----------------------------------------------------------------------------*\
|   wsStartWait()                                                              |
|                                                                              |
|   Turn the WinSetup cursor to a hour glass                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/
void wsStartWait()
{
    SetCursor(LoadCursor(NULL,IDC_WAIT));
}

/*----------------------------------------------------------------------------*\
|   wsEndWait()                                                                |
|                                                                              |
|   Turn the WinSetup cursor back to what it was                               |
|                                                                              |
\*----------------------------------------------------------------------------*/
void wsEndWait()
{
    SetCursor(LoadCursor(NULL,IDC_ARROW));
}


/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function displays a dialog box and returns the exit code.         |
|                                                                              |
|   Arguments:                                                                 |
|       id              resource id of dialog to display                       |
|       hwnd            parent window of dialog                                |
|       fpfn            dialog message function                                |
|                                                                              |
|   Returns:                                                                   |
|       exit code of dialog (what was passed to EndDialog)                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
int fDialog(int id, HWND hwnd, DLGPROC fpfn)
{
    return ( (int)DialogBox(myInstance, MAKEINTRESOURCE(id), hwnd, fpfn) );
}


/****************************************************************************
 *                                                                             |
 *wsCopyError()                                                                |
 *                                                                             |
 *  Handles errors, as the result of copying files.                            |
 *                                                                             |
 *  This may include net contention errors, in which case the user must        |
 *  retry the operation.                                                       |
 *                                                                             |
 *  Parameters :
 *
 *     n      - Copy error number
 *
 *     szFile - the fully qualified name of the file we are copying
 *
 *  Returns
 *
 *     Always returns FC_ABORT
 *
 ****************************************************************************/
 UINT wsCopyError(int n, LPSTR szFile)
 {
     char strBuf[MAXSTR];
     int i = 0;

    /*
     *  We do not want to report any errors that occur while installing
     *  related drivers to the user
     */

     if (bCopyingRelated)
          return(FC_ABORT);

    /*
     *  check for out of disk space
     */

     if (n == ERROR_DISK_FULL) {

        LoadString(myInstance, IDS_OUTOFDISK, strBuf, MAXSTR);

     } else {

       /*
        *  Check to see if a copy has been done on a file that is currently
        *  loaded by the system.
        *
        *  n is the return code from VerInstallFile after translating
        *  by ConvertFlagToValue
        */

        if (n == FC_ERROR_LOADED_DRIVER)
        {
            int iIndex;
            BOOL bFound = FALSE;
            PIDRIVER pIDriver;

            iIndex = (int)SendMessage(hlistbox, LB_GETCOUNT, 0, 0L);


           /*
            *  The driver is in use :
            *
            *  Search the list of curently installed drivers to see
            *  if this file is one of them.  If so tell the user to
            *  de-install and re-start.
            */

            while ( iIndex-- > 0  && !bFound) {

                if ( (int)(pIDriver = (PIDRIVER)SendMessage(hlistbox,
                                                            LB_GETITEMDATA,
                                                            iIndex,
                                                            0L)) != LB_ERR)
                {
                   if (!lstrcmpi(pIDriver->szFile, FileName(szFile)))
                   {
                        char sztemp[MAXSTR];

                       /*
                        *  Found the driver description.
                        *
                        *  Tell the user to un-install it and restart
                        *  windows so that it's not loaded.
                        */

                        LoadString(myInstance,
                                   IDS_FILEINUSEREM,
                                   sztemp,
                                   sizeof(sztemp));

                        wsprintf(strBuf, sztemp, (LPSTR)pIDriver->szDesc);
                        bFound = TRUE;
                   }
                }
            } // while ( iIndex-- > 0 && !bFound)


           /*
            *  If the driver is not currently installed then tell
            *  the user to re-start in the hope that it will then
            *  not be loaded (and so in use)
            *
            *  Note that there is another case not catered for that
            *  this is just a file in the driver's copy list which
            *  failed to copy because it was 'in use'.
            */

            if (!bFound)
            {
                iRestartMessage = IDS_FILEINUSEADD;
                DialogBox(myInstance,
                          MAKEINTRESOURCE(DLG_RESTART),
                          hMesgBoxParent,
                          RestartDlg);

                return(FC_ABORT);
            }

        } else {

           /*
            *  Tell the user there is a problem which we don't
            *  understand here.
            */

            LoadString(myInstance,
                       IDS_UNABLE_TOINSTALL,
                       strBuf,
                       MAXSTR);
        }
     }

    /*
     *  Put up the message box we have selected.
     */

     MessageBox(hMesgBoxParent,
                strBuf,
                szFileError,
                MB_OK | MB_ICONEXCLAMATION  | MB_TASKMODAL);

     return (FC_ABORT);

 }


/*----------------------------------------------------------------------------*\
|                                                                              |
| wsInsertDisk()                                                               |
|                                                                              |
|   Handles errors, as the result of copying files.                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
UINT wsInsertDisk(LPSTR Disk, LPSTR szSrcPath)
{
    UINT temp;
    int i;

   /*
    *  Create the real disk letter
    */
    for (i = 0; Disk[i] != '\0' && Disk[i] != ':'; i++) {
        CurrentDisk[i] = Disk[i];
    }
    CurrentDisk[i] = '\0'; // Null terminate

    szEdit = szSrcPath;

    bFindOEM = TRUE;
    temp =  (UINT)fDialog(DLG_INSERTDISK, GetActiveWindow(), wsDiskDlg);
    bFindOEM = FALSE;
    return(temp);
}


/*----------------------------------------------------------------------------*
|   wsDiskDlg( hDlg, uiMessage, wParam, lParam )                               |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL wsDiskDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam)
{

    switch (uiMessage)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDH_DLG_INSERT_DISK:
                   goto DoHelp;

                case IDS_BROWSE:

                  /*
                   *  Call the browse dialog to open drivers
                   */

                   BrowseDlg(hDlg,
                             3);    // index 3 points to no filter
                                    // - see szFilter
                   break;

                case IDOK:

                   /*
                    *  szEdit points to the path that will be retried
                    *  if the copy fails
                    */

                    GetDlgItemText(hDlg, ID_EDIT, szEdit, MAX_PATH);
                    RemoveSpaces(szDiskPath, szEdit);
                    lstrcpy(szEdit, szDiskPath);
                    EndDialog(hDlg, FC_RETRY);
                    UpdateWindow(hMesgBoxParent);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FC_ABORT);
                    break;
            }
            return TRUE;

        case WM_INITDIALOG:
            {

            char DisksSection[MAXSTR];

           /*
            *  now look in the [disks] section for the disk name
            *  the disk name is the second field.
            */

            char buf[MAXSTR];
            char buf2[MAXSTR];
            char bufout[MAXSTR];

            *buf = '\0';

           /*
            *  See what the name of the section should be
            */

            LoadString(myInstance,
                       IDS_DISKS,
                       DisksSection,
                       sizeof(DisksSection));

            infGetProfileString(NULL, DisksSection, CurrentDisk, (LPSTR)buf);

            if (*buf) {

               /*
                * Position of description in Windows NT
                */

               infParseField(buf, 1, buf2);
            } else {

               /*
                *  Didn't find the section we were looking for so try
                *  the old names
                */

               infGetProfileString(NULL, "disks", CurrentDisk, (LPSTR)buf);
               if (!*buf)
                 infGetProfileString(NULL, "oemdisks", CurrentDisk, (LPSTR)buf);

               if (!*buf) {
                   return FALSE;
               }

               infParseField(buf, 2, buf2);
            }

            wsprintf(bufout, szKnown, (LPSTR)buf2, (LPSTR)szDrv);
            SetDlgItemText(hDlg,ID_TEXT,bufout);
            SetDlgItemText(hDlg,ID_EDIT,szEdit);

            return TRUE;
            }
        default:
            if (uiMessage == wHelpMessage) {
DoHelp:
               WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_INSERT_DISK);
               return TRUE;
            }
            else
                return FALSE;
         break;
    }
}

/*--------------------------------------------------------------------------
 *
 * Function : wsCopySingleStatus
 *     File copying callback routine
 *
 * Parameters :
 *     msg - Which callback function
 *     n   - various
 *     szFile - which file
 *
 * this call back only copies it's file if it does not exist in the
 * path.
 *
 *--------------------------------------------------------------------------*/

 UINT wsCopySingleStatus(int msg, DWORD n, LPSTR szFile)
 {
    OFSTRUCT ofs;
    char szFullPath[MAX_PATH];
    char szDriverExists[MAXSTR];

    switch (msg)
     {
         case COPY_INSERTDISK:
             return wsInsertDisk((LPSTR)n, szFile);

         case COPY_ERROR:
             return wsCopyError((int)n, szFile);


         case COPY_QUERYCOPY:

            /*
             *  See if the file already exists in the windows system
             *  directory
             */

             GetSystemDirectory(szFullPath, MAX_PATH);

             if (IsFileKernelDriver(szFile)) {
                 lstrcat(szFullPath, "\\drivers");
             }

             lstrcat(szFullPath, "\\");

             lstrcat(szFullPath, RemoveDiskId(szFile));

             if (OpenFile(szFullPath, &ofs, OF_EXIST|OF_SHARE_DENY_NONE) >= 0)
             {
                /*
                 *  DriverCopy remembers whether to copy from
                 *  current or new after we have queried the user
                 *  once
                 */

                 static int DriverCopy;

                 if (bQueryExist)
                 {
                     bQueryExist = FALSE;

                     LoadString(myInstance,
                                IDS_DRIVER_EXISTS,
                                szDriverExists,
                                sizeof(szDriverExists));

                     wsprintf(szErrMsg, szDriverExists, FileName(szFile));

                    /*
                     *  Ask the user whether to copy or not ?
                     */

                     DriverCopy = DialogBox(myInstance,
                                            MAKEINTRESOURCE(DLG_EXISTS),
                                            hMesgBoxParent,
                                            wsExistDlg);
                 }

                 return DriverCopy;
             } else {

                 return CopyNew;
             }

         case COPY_START:
         case COPY_END:
             SetErrorMode(msg == COPY_START);    // don't crit error on us
             break;
     }
     return FC_IGNORE;
 }

/*
 *  Function : wsExistDlg - 'File exists' dialog
 */

 BOOL wsExistDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam)
 {
     switch (uiMessage)
     {
         case WM_COMMAND:
             switch (LOWORD(wParam))
             {
                 case ID_CURRENT:

                     EndDialog(hDlg, CopyCurrent);
                     break;

                 case ID_NEW:

                    /*
                     *  User selected to copy the new files over the
                     *  existing ones
                     */

                     EndDialog(hDlg, CopyNew);
                     break;

                 case IDCANCEL:
                     EndDialog(hDlg, CopyNeither);  // Cancel
                     break;
             }
             return TRUE;

         case WM_INITDIALOG:
             SetDlgItemText(hDlg, ID_STATUS2, szErrMsg);
             return TRUE;

         default:
          break;
     }
     return FALSE;
 }

/*
 *  Function : RemoveSpaces
 *     Copies a string removing leading and trailing spaces but allowing
 *     for long file names with internal spaces.
 *
 *  Parameters :
 *     szPath - The output result
 *     szEdit - The input path
 */

 VOID RemoveSpaces(LPTSTR szPath, LPTSTR szEdit)
 {
     LPTSTR szLastSpaceList;

     while (*szEdit == ' ') {
         szEdit = CharNext(szEdit);
     }

     lstrcpy(szPath, szEdit);

     for (szLastSpaceList = NULL;
          *szPath != TEXT('\0');
          szPath = CharNext(szPath)) {

        if (*szPath == ' ') {
            if (szLastSpaceList == NULL) {
                szLastSpaceList = szPath;
            }
        } else {
            szLastSpaceList = NULL;
        }

     }

     if (szLastSpaceList != NULL) {
         *szLastSpaceList = TEXT('\0');
     }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\mmdriver.c ===
/*----------------------------------------------------------------------------
 | mmdriver.c - Install Multimedia Drivers
 |
 | Copyright (C) Microsoft, 1989, 1990.  All Rights Reserved
 |
 |  History:
 |      09/11/90    davidle     created
 |          Install Multimedia Drivers
 |
 |      Tue Jan 29 1991 -by- MichaelE
 |          Redesigned installing installable drivers so additional drivers
 |        can be installed by adding them to setup.inf's [installable.drivers]
 |
 |      Wed Mar 20 1991 -by- MichaelE
 |          Changed mmAddInstallableDriver to accept multiple VxDs.
 |          Changed and WriteNextPrivateProfileString to check if the profile
 |          being concatenated is already there.
 |
 |      Sun Apr 14 1991 -by- MichaelE
 |          WriteNextPrivateProfileString -> Next386EnhDevice.
 |
 |      Sun Apr 14 1991 -by- JohnYG
 |          Taken from setup for drivers applet.
 |
 |      Wed Jun 05 1991 -by- MichaelE
 |          Added FileCopy of associated file list to windows system dir.
 |
 *----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <winsvc.h>
#include <string.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

/*
 *  Local functions
 */

 static BOOL mmAddInstallableDriver         (PINF, LPSTR, LPSTR, PIDRIVER );
 static void GetDrivers                     (PINF, PSTR, PSTR);

/**************************************************************************
 *
 *  AccessServiceController()
 *
 *  Check we will be able to access the service controller to install
 *  a driver
 *
 *  returns FALSE if we can't get access - otherwise TRUE
 *
 **************************************************************************/
 BOOL AccessServiceController(void)
 {

     SC_HANDLE SCManagerHandle;

     SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
     if (SCManagerHandle == NULL) {
         return FALSE;
     }

     CloseServiceHandle(SCManagerHandle);

     return TRUE;
 }


/**************************************************************************
 *
 *  mmAddNewDriver() - only exported function in this file.
 *
 *  This function installs (copies) a driver
 *
 *  returns FALSE if no drivers could be installed.
 *          TRUE if at least one driver installation was sucessful.
 *          All added types in lpszNewTypes buffer.
 *
 **************************************************************************/

 BOOL mmAddNewDriver( LPSTR lpstrDriver, LPSTR lpstrNewTypes, PIDRIVER pIDriver )
 {
     PINF pinf;

     if ((pinf = FindInstallableDriversSection(NULL)) == NULL)
         return FALSE;

     return mmAddInstallableDriver(pinf, lpstrDriver, lpstrNewTypes, pIDriver);
 }


/**************************************************************************
 * mmAddInstallableDriver() - Do the dirty work looking for VxD's copying them
 *     looking for drivers, copying them, and returning the best type names.
 *
 *
 **************************************************************************/

BOOL mmAddInstallableDriver( PINF pInfIDrivers,
                             LPSTR pstrDriver,
                             LPSTR lpstrNewTypes,
                             PIDRIVER pIDriver)
{
    PSTR pstr, pstrSection;
    static char szTemp[10];
    PINF pInfSection= pInfIDrivers;
    int  i;
    char szBuffer[MAX_INF_LINE_LEN],
         szFilename[MAXSTR],
         szType[MAX_SECT_NAME_LEN];

   /*
    *  format of a line in [installable.drivers] of setup.inf:
    *  driver profile =                            [0]
    *                   filename,                  [1]
    *                   "type(s)",                 [2]
    *                   "description",             [3]
    *                   "VxD and .sys filename(s)",[4]
    *                   "default config params"    [5]
    *                   "Related drivers"          [6]
    *
    *  find the driver profile line in szMDrivers we are installing
    */

    while ( TRUE )
    {
        infParseField( pInfIDrivers, 0, szBuffer );
        if ( lstrcmpi( szBuffer, pstrDriver ) == 0 )
            break;
        else if ( ! (pInfIDrivers = infNextLine( pInfIDrivers )) )
            return FALSE;
    }

   /*
    *  copy the driver file and add driver type(s) to the installable
    *  driver section
    */

    if ( !infParseField( pInfIDrivers, 1, szFilename ))
        return FALSE;


   /*
    *  Ignore the disk number
    */

    strcpy(szDrv, RemoveDiskId(szFilename));

   /*
    *  Cache whether it's a kernel driver
    */

    pIDriver->KernelDriver = IsFileKernelDriver(szFilename);

   /*
    *  Can't install kernel drivers if don't have privilege
    */

    if (pIDriver->KernelDriver && !AccessServiceController()) {

        char szMesg[MAXSTR];
        char szMesg2[MAXSTR];
        char szTitle[50];

        LoadString(myInstance, IDS_INSUFFICIENT_PRIVILEGE, szMesg, sizeof(szMesg));
        LoadString(myInstance, IDS_CONFIGURE_DRIVER, szTitle, sizeof(szTitle));
        wsprintf(szMesg2, szMesg, szDrv);
        MessageBox(hMesgBoxParent, szMesg2, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

        return FALSE;
    }

   /*
    *  Do the file copying
    */

    if (FileCopy( szFilename,
                  szSystem,
                  (FPFNCOPY)wsCopySingleStatus,
                  FC_FILE ) != NO_ERROR) {
        return FALSE;
    }

   /*
    *  Add options
    */

    if (infParseField (pInfIDrivers,5,szBuffer+1))
    {
       szBuffer[0]=' ';
       lstrcat(szFilename,szBuffer);
    }

   /*
    *  copy filename and options
    */

    strncpy(pIDriver->szFile, FileName(szFilename), sizeof(pIDriver->szFile));
    pIDriver->szFile[sizeof(pIDriver->szFile) - 1] = 0;

   /*
    *  copy description
    */

    infParseField( pInfIDrivers, 3, pIDriver->szDesc );

   /*
    *  determine the section from the description.  A kernel driver
    *  will appear as a driver of type 'KERNEL' in system.ini
    *
    *  If the description contains [MCI] then it's MCI.
    */

    if (strstr(pIDriver->szDesc, TEXT("MCI")))
        pstrSection = szMCI;
    else
        pstrSection = szDrivers;

   /*
    *  Copy name plus parameters to our driver data
    */

    strncpy(pIDriver->szSection, pstrSection, sizeof(pIDriver->szSection));
    pIDriver->szSection[sizeof(pIDriver->szSection) - 1] = 0;
    mbstowcs(pIDriver->wszSection, pIDriver->szSection, MAX_PATH);

   /*
    *  We return all types in a parseable, contcatentated string
    */

    for ( i = 1, infParseField( pInfIDrivers, 2, szBuffer );
          infParseField( szBuffer, i, szType );
          i++ )
    {
        pstr = &(szType[lstrlen(szType)]);
        *pstr++ = ',';
        *pstr = 0;
        lstrcat(lpstrNewTypes, szType );
    }

    if (!*lpstrNewTypes)

      /*
       *  We weren't able to return any types.
       */
       return FALSE;

   /*
    *  copy an associated file list (if it exists) to windows system dir
    */

    if (FileCopy(pstrDriver,
                 szSystem,
                 (FPFNCOPY)wsCopySingleStatus,
                 FC_SECTION) != ERROR_SUCCESS)

        return(FALSE);


   /*
    *  if there are system driver files copy them to the system
    *  drivers directory.
    *
    *  NOTE that it is assumed here that any installation and
    *  configuration for these drivers is performed by the main
    *  (.drv) driver being installed.
    *
    */

    if (infParseField( pInfIDrivers, 4, szBuffer ) && szBuffer[0])
    {
        for ( i = 1; infParseField( szBuffer, i, szFilename ); i++ )
        {
            strcpy(szDrv, RemoveDiskId(szFilename));

           /*
            *  FileCopy will adjust the 'system' directory to
            *  system\drivers.  It's done this way because FileCopy
            *  must anyway look for old files in the same directory.
            */

            if (FileCopy(szFilename,
                         szSystem,
                         (FPFNCOPY)wsCopySingleStatus,
                         FC_FILE )
                != ERROR_SUCCESS)
            {
                return FALSE;
            }
        }
    }

#ifdef DOBOOT // Don't do boot section on NT

    infParseField(pInfIDrivers, 7, szTemp);

    if (!_strcmpi(szTemp, szBoot))
        bInstallBootLine = TRUE;

#endif // DOBOOT


   /*
    *  Read the related drivers list (drivers which must/can also be
    *  be installed).
    */

    if (bRelated == FALSE)
    {
       infParseField(pInfIDrivers, 6, pIDriver->szRelated);
       if (strlen(pIDriver->szRelated))
       {
          GetDrivers(pInfSection, pIDriver->szRelated, pIDriver->szRemove);
          pIDriver->bRelated = TRUE;
          bRelated = TRUE;
       }
    }
    return TRUE;
}

/*
 *  Used to get the list of the related driver filenames
 *
 *  pInfIDrivers - Pointer to the [installable.drivers] section or equivalent
 *  szAliasList  - List of driver aliases (ie key values - eg msalib).
 *  szDriverList - List of drivers file names found
 */

void GetDrivers(PINF pInfIDrivers, PSTR szAliasList, PSTR szDriverList)
{
    char szBuffer[50];
    char szAlias[50];
    char szFileName[50];
    PINF pInfILocal;
    BOOL bEnd;
    int i;

    for ( i = 1; infParseField(szAliasList, i, szAlias); i++ )
    {
        pInfILocal = pInfIDrivers;
        bEnd = FALSE;
        while (!bEnd)
        {
            infParseField( pInfILocal, 0, szBuffer);
            if (lstrcmpi( szBuffer, szAlias) == 0 )
            {
                if (infParseField(pInfILocal, 1, szFileName))
                {
                    lstrcat(szDriverList, RemoveDiskId(szFileName));
                    lstrcat(szDriverList, ",");
                }
                break;
            }
            else
                if ( ! (pInfILocal = infNextLine( pInfILocal )) )
                    bEnd = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\install.c ===
/*************************************************************************
 *
 *  INSTALL.C
 *
 *  Copyright (C) Microsoft, 1991, All Rights Reserved.
 *
 *  History:
 *
 *      Thu Oct 17 1991 -by- Sanjaya
 *      Created. Culled out of drivers.c
 *
 *************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <winsvc.h>
#include <memory.h>
#include <string.h>
#include <cpl.h>
#include <cphelp.h>
#include <stdlib.h>
#include "drivers.h"
#include "sulib.h"

BOOL     GetValidAlias           (HWND, PSTR, PSTR);
BOOL     SelectInstalled         (HWND, PIDRIVER, LPSTR);
void     InitDrvConfigInfo       (LPDRVCONFIGINFO, PIDRIVER );
BOOL     InstallDrivers          (HWND, HWND, PSTR);
void     RemoveAlreadyInstalled  (PSTR, PSTR);
void     CheckIniDrivers         (PSTR, PSTR);
void     RemoveDriverParams      (LPSTR, LPSTR);



/**************************************************************************
 *
 *  InstallDrivers()
 *
 *  Install a driver and set of driver types.
 *
 *  Parameters :
 *      hwnd      - Window handle of the main drivers.cpl windows
 *      hwndAvail - Handle of the 'available drivers' dialog window
 *      pstrKey   - Key name of the inf section item we are installing
 *
 *  This routine calls itself recursively to install related drivers
 *  (as listed in the .inf file).
 *
 **************************************************************************/

BOOL InstallDrivers(HWND hWnd, HWND hWndAvail, PSTR pstrKey)
{
    IDRIVER     IDTemplate; // temporary for installing, removing, etc.
    PIDRIVER    pIDriver=NULL;
    int         n,iIndex;
    HWND        hWndI;
    char        szTypes[MAXSTR];
    char        szType[MAXSTR];
    char        szParams[MAXSTR];

    szTypes[0] = '\0';

    hMesgBoxParent = hWndAvail;

    /*
     * mmAddNewDriver needs a buffer for all types we've actually installed
     * User critical errors will pop up a task modal
     */

    IDTemplate.bRelated = FALSE;
    IDTemplate.szRemove[0] = TEXT('\0');

   /*
    *  Do the copying and extract the list of types (WAVE, MIDI, ...)
    *  and the other driver data
    */

    if (!mmAddNewDriver(pstrKey, szTypes, &IDTemplate))
        return FALSE;

    szTypes[lstrlen(szTypes)-1] = '\0';         // Remove space left at end

    RemoveAlreadyInstalled(IDTemplate.szFile, IDTemplate.szSection);

   /*
    *  At this point we assume the drivers were actually copied.
    *  Now we need to add them to the installed list.
    *  For each driver type we create an IDRIVER and add to the listbox
    */

    hWndI = GetDlgItem(hWnd, LB_INSTALLED);

    for (n = 1; infParseField(szTypes, n, szType); n++)
    {
       /*
        *  Find a valid alias for this device (eg Wave2).  This is
        *  used as the key in the [MCI] or [drivers] section.
        */

        if (GetValidAlias(hWndI, szType, IDTemplate.szSection) == FALSE)
        {
           /*
            *  Exceeded the maximum, tell the user
            */

            PSTR pstrMessage;
            char szApp[MAXSTR];
            char szMessage[MAXSTR];

            LoadString(myInstance,
                       IDS_CONFIGURE_DRIVER,
                       szApp,
                       sizeof(szApp));

            LoadString(myInstance,
                       IDS_TOO_MANY_DRIVERS,
                       szMessage,
                       sizeof(szMessage));

            if (NULL !=
                (pstrMessage =
                    (PSTR)LocalAlloc(LPTR,
                                     sizeof(szMessage) + lstrlen(szType))))
            {
                wsprintf(pstrMessage, szMessage, (LPSTR)szType);

                MessageBox(hWndAvail,
                           pstrMessage,
                           szApp,
                           MB_OK | MB_ICONEXCLAMATION|MB_TASKMODAL);

                LocalFree((HANDLE)pstrMessage);
            }
            continue;
        }

        if ( (pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER))) != NULL)
        {
            /*
             *  Copy all fields
             */

            memcpy(pIDriver, &IDTemplate, sizeof(IDRIVER));
            strncpy(pIDriver->szAlias, szType, sizeof(pIDriver->szAlias));
            pIDriver->szAlias[sizeof(pIDriver->szAlias) - 1] = '\0';
            mbstowcs(pIDriver->wszAlias, pIDriver->szAlias, MAX_PATH);


            /*
             *  Want only one instance of each driver to show up in the list
             *  of installed drivers. Thus for the remaining drivers just
             *  place an entry in the drivers section of system.ini
             */


            if ( n > 1) {


                 if (strlen(szParams) != 0 && !pIDriver->KernelDriver) {
                    /*
                     *  Write their parameters to a section bearing their
                     *  file name with an alias reflecting their alias
                     */

                     WriteProfileString(pIDriver->szFile,
                                        pIDriver->szAlias,
                                        szParams);
                 }

                 WritePrivateProfileString(pIDriver->szSection,
                                           pIDriver->szAlias,
                                           pIDriver->szFile,
                                           szSysIni);
            } else {

               /*
                *  Add the driver description to our listbox
                */

                iIndex = (int)SendMessage(hWndI,
                                          LB_ADDSTRING,
                                          0,
                                          (LONG)pIDriver->szDesc);

                if (iIndex >= LB_OKAY) {


                   /*
                    *  Our PIDRIVER data is our listbox item
                    */

                    SendMessage(hWndI, LB_SETITEMDATA, iIndex, (LONG)pIDriver);

                   /*
                    *  Reduce to just the driver name
                    */

                    RemoveDriverParams(pIDriver->szFile, szParams);

                    mbstowcs(pIDriver->wszFile, pIDriver->szFile, MAX_PATH);

                    if (strlen(szParams) != 0 && !pIDriver->KernelDriver) {
                       /*
                        *  Write their parameters to a section bearing their
                        *  file name with an alias reflecting their alias
                        */

                        WriteProfileString(pIDriver->szFile,
                                           pIDriver->szAlias,
                                           szParams);
                    }

                    WritePrivateProfileString(pIDriver->szSection,
                                              pIDriver->szAlias,
                                              pIDriver->szFile,
                                              szSysIni);

                   /*
                    *  Call the driver to see if it can be configured
                    *  and configure it if it can be
                    */

                    if (!SelectInstalled(hWndAvail, pIDriver, szParams))
                    {

                        /*
                         *  Error talking to driver
                         */

                         WritePrivateProfileString(pIDriver->szSection,
                                                   pIDriver->szAlias,
                                                   NULL,
                                                   szSysIni);

                         WriteProfileString(pIDriver->szFile,
                                            pIDriver->szAlias,
                                            NULL);

                         SendMessage(hWndI, LB_DELETESTRING, iIndex, 0L);
                         return FALSE;
                    }

                   /*
                    *  for displaying the driver desc. in the restart mesg
                    */

                    if (!bRelated || pIDriver->bRelated) {
                       strcpy(szRestartDrv, pIDriver->szDesc);
                    }

                   /*
                    *  We need to write out the driver description to the
                    *  control.ini section [Userinstallable.drivers]
                    *  so we can differentiate between user and system drivers
                    *
                    *  This is tested by the function UserInstalled when
                    *  the user tries to remove a driver and merely
                    *  affects which message the user gets when being
                    *  asked to confirm removal (non user-installed drivers
                    *  are described as being necessary to the system).
                    */

                    WritePrivateProfileString(szUserDrivers,
                                              pIDriver->szAlias,
                                              pIDriver->szFile,
                                              szControlIni);


                   /*
                    *  Update [related.desc] section of control.ini :
                    *
                    *  ALIAS=driver name list
                    *
                    *  When the driver whose alias is ALIAS is removed
                    *  the drivers in the name list will also be removed.
                    *  These were the drivers in the related drivers list
                    *  when the driver is installed.
                    */

                    WritePrivateProfileString(szRelatedDesc,
                                              pIDriver->szAlias,
                                              pIDriver->szRemove,
                                              szControlIni);


                   /*
                    * Cache the description string in control.ini in the
                    * drivers description section.
                    *
                    * The key is the driver file name + extension.
                    */

                    WritePrivateProfileString(szDriversDesc,
                                              pIDriver->szFile,
                                              pIDriver->szDesc,
                                              szControlIni);

#ifdef DOBOOT // We don't do the boot section on NT

                    if (bInstallBootLine) {
                        szTemp[MAXSTR];

                        GetPrivateProfileString(szBoot,
                                                szDrivers,
                                                szTemp,
                                                szTemp,
                                                sizeof(szTemp),
                                                szSysIni);
                        strcat(szTemp, " ");
                        strcat(szTemp, pIDriver->szAlias);
                        WritePrivateProfileString(szBoot,
                                                  szDrivers,
                                                  szTemp,
                                                  szSysIni);
                        bInstallBootLine = FALSE;
                    }
#endif // DOBOOT

                } else {
                   /*
                    * Problem getting an alias or adding a driver to the listbox
                    */

                    LocalFree((HANDLE)pIDriver);
                    pIDriver = NULL;
                    return FALSE;               //ERROR
                }
           }
        }
        else
            return FALSE;                       //ERROR
    }


   /*
    *  If no types were added then fail
    */

    if (pIDriver == NULL) {
        return FALSE;
    }

   /*
    *  If there are related drivers listed in the .inf section to install
    *  then install them now by calling ourselves.  Use IDTemplate which
    *  is where mmAddNewDriver put the data.
    */

    if (IDTemplate.bRelated == TRUE) {

        int i;
        char szTemp[MAXSTR];

       /*
        *  Tell file copying to abort rather than put up errors
        */

        bCopyingRelated = TRUE;

        for (i = 1; infParseField(IDTemplate.szRelated, i, szTemp);i++) {

            InstallDrivers(hWnd, hWndAvail, szTemp);
        }
    }
    return TRUE;
}


/************************************************************************
 *
 *  SelectInstalled()
 *
 *  Check if the driver can be configured and configure it if it can be.
 *
 *  hwnd     - Our window - parent for driver to make its config window
 *  pIDriver - info about the driver
 *  params   - the drivers parameters from the .inf file.
 *
 *  Returns FALSE if an error occurred, otherwise TRUE
 *
 ************************************************************************/

BOOL SelectInstalled(HWND hwnd, PIDRIVER pIDriver, LPSTR pszParams)
{
    DRVCONFIGINFO DrvConfigInfo;
    HANDLE hDriver;
    BOOL Success = FALSE;
    DWORD dwTagId;

    wsStartWait();

   /*
    *  If it's a kernel driver call the services controller to
    *  install the driver
    */

    if (pIDriver->KernelDriver) {

        SC_HANDLE SCManagerHandle;
        SC_HANDLE ServiceHandle;
        char ServiceName[MAX_PATH];
        char BinaryPath[MAX_PATH];

       /*
        *  These drivers are not configurable
        */

        pIDriver->fQueryable = 0;

       /*
        *  The services controller will create the registry node to
        *  which we can add the device parameters value
        */

        strcpy(BinaryPath, "\\SystemRoot\\system32\\drivers\\");
        strcat(BinaryPath, pIDriver->szFile);

       /*
        *  First try and obtain a handle to the service controller
        */

        SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (SCManagerHandle != NULL) {

            SC_LOCK ServicesDatabaseLock;

           /*
            *  Lock the service controller database to avoid deadlocks
            *  we have to loop because we can't wait
            */


            for (ServicesDatabaseLock = NULL;
                 (ServicesDatabaseLock =
                      LockServiceDatabase(SCManagerHandle))
                    == NULL;
                 Sleep(100)) {
            }

            {
                char drive[MAX_PATH], directory[MAX_PATH], ext[MAX_PATH];
                _splitpath(pIDriver->szFile, drive, directory, ServiceName, ext);
            }


            ServiceHandle = CreateService(SCManagerHandle,
                                          ServiceName,
                                          NULL,
                                          SERVICE_ALL_ACCESS,
                                          SERVICE_KERNEL_DRIVER,
                                          SERVICE_DEMAND_START,
                                          SERVICE_ERROR_NORMAL,
                                          BinaryPath,
                                          "Base",
                                          &dwTagId,
                                          "\0",
                                          NULL,
                                          NULL);

            UnlockServiceDatabase(ServicesDatabaseLock);

            if (ServiceHandle != NULL) {
               /*
                *  Try to write the parameters to the registry if there
                *  are any
                */

                if (strlen(pszParams)) {

                    HKEY ParmsKey;
                    char RegPath[MAX_PATH];
                    strcpy(RegPath, "\\SYSTEM\\CurrentControlSet\\Services\\");
                    strcat(RegPath, ServiceName);
                    strcat(RegPath, "\\Parameters");

                    Success = RegCreateKey(HKEY_LOCAL_MACHINE,
                                           RegPath,
                                           &ParmsKey) == ERROR_SUCCESS &&
                              RegSetValue(ParmsKey,
                                          "",
                                          REG_SZ,
                                          pszParams,
                                          strlen(pszParams)) == ERROR_SUCCESS &&
                              RegCloseKey(ParmsKey) == ERROR_SUCCESS;
                } else {
                    Success = TRUE;
                }

               /*
                *  Service created so try and start it
                */

                if (Success) {
                   /*
                    *  We tell them to restart just in case
                    */

                    bRestart = TRUE;

                   /*
                    *  Load the kernel driver by starting the service.
                    *  If this is successful it should be safe to let
                    *  the system load the driver at system start so
                    *  we change the start type.
                    */

                    Success =
                        StartService(ServiceHandle, 0, NULL) &&
                        ChangeServiceConfig(ServiceHandle,
                                            SERVICE_NO_CHANGE,
                                            SERVICE_SYSTEM_START,
                                            SERVICE_NO_CHANGE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                    if (!Success) {
                        char szMesg[MAXSTR];
                        char szMesg2[MAXSTR];
                        char szTitle[50];

                       /*
                        *  Uninstall driver if we couldn't load it
                        */

                       for (ServicesDatabaseLock = NULL;
                            (ServicesDatabaseLock =
                                 LockServiceDatabase(SCManagerHandle))
                               == NULL;
                            Sleep(100)) {
                        }

                        DeleteService(ServiceHandle);

                        UnlockServiceDatabase(ServicesDatabaseLock);

                       /*
                        *  Tell the user there was a configuration error
                        *  (our best guess).
                        */


                        LoadString(myInstance, IDS_DRIVER_CONFIG_ERROR, szMesg, sizeof(szMesg));
                        LoadString(myInstance, IDS_CONFIGURE_DRIVER, szTitle, sizeof(szTitle));
                        wsprintf(szMesg2, szMesg, FileName(pIDriver->szFile));
                        MessageBox(hMesgBoxParent, szMesg2, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
                    }
                }

                CloseServiceHandle(ServiceHandle);
            }

            CloseServiceHandle(SCManagerHandle);
        }
    } else {

       /*
        *  Put up a message if the driver can't be loaded or doesn't
        *  respond favourably to the DRV_INSTALL message.
        */

        BOOL bPutUpMessage;

        bPutUpMessage = FALSE;

       /*
        *  See if we can open the driver
        */

        hDriver = OpenDriver(pIDriver->wszFile, NULL, 0L);

        if (hDriver)
        {
            Success = TRUE;

            InitDrvConfigInfo(&DrvConfigInfo, pIDriver);

           /*
            *  See if activating the driver will require restarting the
            *  system.
            *
            *  Also check the driver wants to install (it may not
            *  have the right privilege level).
            */

            switch (SendDriverMessage(hDriver,
                                  DRV_INSTALL,
                                  0L,
                                  (LONG)(LPDRVCONFIGINFO)&DrvConfigInfo))

            {

            case DRVCNF_RESTART:

                bRestart = TRUE;
                break;

            case DRVCNF_CANCEL:

               /*
                *  The driver did not want to install
                */

                bPutUpMessage = TRUE;
                Success = FALSE;
                break;

            }

           /*
            *  Remember whether the driver is configurable
            */

            pIDriver->fQueryable =
                (int)SendDriverMessage(hDriver,
                                       DRV_QUERYCONFIGURE,
                                       0L,
                                       0L);

           /*
            *  If the driver is configurable then configure it.
            *  Configuring the driver may result in a need to restart
            *  the system.  The user may also cancel install.
            */

            if (pIDriver->fQueryable) {

                switch (SendDriverMessage(
                            hDriver,
                            DRV_CONFIGURE,
                            (LONG)hwnd,
                            (LONG)(LPDRVCONFIGINFO)&DrvConfigInfo)) {

                case DRVCNF_RESTART:
                    bRestart = TRUE;
                    break;

                case DRVCNF_CANCEL:

                   /*
                    *  Don't put up the error box if the user cancelled
                    */

                    Success = FALSE;
                    break;
                }
            }
            CloseDriver(hDriver, 0L, 0L);
        } else {
            bPutUpMessage = TRUE;
            Success = FALSE;
        }

        if (bPutUpMessage) {

           /*
            *  If dealing with the driver resulted in error then put
            *  up a message
            */

            OpenDriverError(hwnd, pIDriver->szDesc, pIDriver->szFile);
        }
    }
    wsEndWait();
    return Success;
}


/***********************************************************************
 *
 *  InitDrvConfigInfo()
 *
 *  Initialize Driver Configuration Information.
 *
 ***********************************************************************/

void InitDrvConfigInfo( LPDRVCONFIGINFO lpDrvConfigInfo, PIDRIVER pIDriver )
{
    lpDrvConfigInfo->dwDCISize          = sizeof(DRVCONFIGINFO);
    lpDrvConfigInfo->lpszDCISectionName = pIDriver->wszSection;
    lpDrvConfigInfo->lpszDCIAliasName   = pIDriver->wszAlias;
}

/***********************************************************************
 *
 *  GetValidAlias()
 *
 *  hwnd         - Window handle - not used
 *  pstrType     - Input  - the type
 *                 Output - New alias for that type
 *
 *  pstrSection  - The system.ini section we're dealing with
 *
 *  Create a valid alias name for a type.  Searches the system.ini file
 *  in the drivers section for aliases of the type already defined and
 *  returns a new alias (eg WAVE1).
 *
 ***********************************************************************/

BOOL GetValidAlias(HWND hwnd, PSTR pstrType, PSTR pstrSection)
{
    #define MAXDRVTYPES 10

    char *keystr;
    char allkeystr[MAXSTR];
    BOOL found = FALSE;
    int val, maxval = 0, typelen;

    typelen = strlen(pstrType);
    GetPrivateProfileString(pstrSection, NULL, NULL, allkeystr,
                                        sizeof(allkeystr), szSysIni);
    keystr = allkeystr;

   /*
    *  See if we have driver if this type already installed by searching
    *  our the [drivers] section.
    */

    while (*keystr != '\0')
    {
       if (!_strnicmp(keystr, pstrType, typelen) && ((keystr[typelen] > '0' &&
                                                    keystr[typelen] <= '9') ||
                                                    keystr[typelen] == TEXT('\0') ))
       {
          found = TRUE;
          val = atoi(&keystr[typelen]);
          if (val > maxval)
             maxval = val;
       }
       keystr = &keystr[strlen(keystr) + 1];
    }

    if (found)
    {
        if (maxval == MAXDRVTYPES)
            return FALSE; // too many of my type!

        pstrType[typelen] = (char)(maxval + '1');
        pstrType[typelen+1] = '\0';
    }

    return TRUE;
}


/*******************************************************************
 *
 *  IsConfigurable
 *
 *  Find if a driver supports configuration
 *
 *******************************************************************/

BOOL IsConfigurable(PIDRIVER pIDriver, HWND hwnd)
{
    HANDLE hDriver;

    wsStartWait();

    /*
     *  have we ever checked if this driver is queryable?
     */

    if ( pIDriver->fQueryable == -1 )
    {

       /*
        *  Check it's not a kernel driver
        */

        if (pIDriver->KernelDriver) {
            pIDriver->fQueryable = 0;
        } else {

           /*
            *  Open the driver and ask it if it is configurable
            */

            hDriver = OpenDriver(pIDriver->wszAlias, pIDriver->wszSection, 0L);

            if (hDriver)
            {
                pIDriver->fQueryable =
                    (int)SendDriverMessage(hDriver,
                                           DRV_QUERYCONFIGURE,
                                           0L,
                                           0L);

                CloseDriver(hDriver, 0L, 0L);
            }
            else
            {
                 pIDriver->fQueryable = 0;
                 OpenDriverError(hwnd, pIDriver->szDesc, pIDriver->szFile);
                 wsEndWait();
                 return(FALSE);
            }
        }
    }
    wsEndWait();
    return((BOOL)pIDriver->fQueryable);
}

/******************************************************************
 *
 *  Find any driver with the same name currently installed and
 *  remove it
 *
 *  szFile     - File name of driver
 *  szSection  - system.ini section ([MCI] or [drivers]).
 *
 ******************************************************************/

void RemoveAlreadyInstalled(PSTR szFile, PSTR szSection)
{
    int iIndex;
    PIDRIVER pIDriver;

    iIndex = (int)SendMessage(hlistbox, LB_GETCOUNT, 0, 0L);

    while ( iIndex-- > 0) {

        pIDriver = (PIDRIVER)SendMessage(hlistbox, LB_GETITEMDATA, iIndex, 0L);

        if ( (int)pIDriver != LB_ERR) {

            if (!FileNameCmp(pIDriver->szFile, szFile)) {
                PostRemove(hlistbox, pIDriver, FALSE, iIndex);
                return;
            }
        }
    }

    CheckIniDrivers(szFile, szSection);
}

/******************************************************************
 *
 *  Remove system.ini file entries for our driver
 *
 *  szFile    - driver file name
 *  szSection - [drivers] or [MCI]
 *
 ******************************************************************/

void CheckIniDrivers(PSTR szFile, PSTR szSection)
{
    char allkeystr[MAXSTR * 2];
    char szRemovefile[20];
    char *keystr;

    GetPrivateProfileString(szSection,
                            NULL,
                            NULL,
                            allkeystr,
                            sizeof(allkeystr),
                            szSysIni);

    keystr = allkeystr;
    while (strlen(keystr) > 0)
    {

         GetPrivateProfileString(szSection,
                                 keystr,
                                 NULL,
                                 szRemovefile,
                                 sizeof(szRemovefile),
                                 szSysIni);

         if (!FileNameCmp(szFile, szRemovefile))
               RemoveDriverEntry(keystr, szFile, szSection, FALSE);

         keystr = &keystr[strlen(keystr) + 1];
    }
}

/******************************************************************
 *
 *   RemoveDriverParams
 *
 *   Remove anything after the next token
 *
 ******************************************************************/

void RemoveDriverParams(LPSTR szFile, LPSTR Params)
{
   for(;*szFile == ' '; szFile++);
   for(;*szFile != ' ' && *szFile != '\0'; szFile++);
   if (*szFile == ' ') {
      *szFile = '\0';
      for (;*++szFile == ' ';);
      strcpy(Params, szFile);
   } else {
       *Params = '\0';
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\h\cphelp.h ===
//
//  NOTE:  The NetUI group is responsible for a number of applets
//         that are shipped with the base system.  This includes the
//         Network Control Panel Applet (NCPA.CPL), the Server Manager
//         and Services Applets (SRVMGR.CPL), and the UPS Applet (UPS.CPL).
//
//         To prevent help context conflicts between the NetUI applets
//         and the "standard" system applets, the NetUI group hereby
//         reserves the help contexts in the range 40000 - 59999.  This
//         will provide plenty of breathing room for future NetUI applets.
//

#define IDH_NETUI_FIRST 40000
#define IDH_NETUI_LAST  59999

#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_DLG_FONT2   (IDH_HELPFIRST + 2002)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)
#define IDH_SCRNSAVE    (IDH_HELPFIRST + 4000)


#define IDH_SPOOLER_OFFSET 5000
#define IDH_DISPLAY_OFFSET 6000

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_COLOR     (IDH_HELPFIRST + CHILD_COLOR)
#define IDH_CHILD_PRINTER   (IDH_HELPFIRST + CHILD_PRINTER)
#define IDH_CHILD_FONT      (IDH_HELPFIRST + CHILD_FONT )
#define IDH_CHILD_INTL      (IDH_HELPFIRST + CHILD_INTL )
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + CHILD_PORTS)
#define IDH_CHILD_KEYBOARD  (IDH_HELPFIRST + CHILD_KEYBOARD )
#define IDH_CHILD_MOUSE     (IDH_HELPFIRST + CHILD_MOUSE)
#define IDH_CHILD_DATETIME  (IDH_HELPFIRST + CHILD_DATETIME )
#define IDH_CHILD_DESKTOP   (IDH_HELPFIRST + CHILD_DESKTOP)
#define IDH_CHILD_SOUND     (IDH_HELPFIRST + CHILD_SOUND)
#define IDH_CHILD_NETWORK   (IDH_HELPFIRST + CHILD_NETWORK)
#define IDH_CHILD_SYSTEM    (IDH_HELPFIRST + CHILD_SYSTEM)
#define IDH_CHILD_MIDI      (IDH_HELPFIRST + 122)           // MM midi
#define IDH_CHILD_SND       (IDH_HELPFIRST + 121)           // MM sound
#define IDH_CHILD_DRIVERS   (IDH_HELPFIRST + 120)           // MM drivers
#define IDH_CHILD_CURSORS   (IDH_HELPFIRST + 119)
#define IDH_DLG_CURBROWSE   (IDH_HELPFIRST + 118)

#define IDH_DLG_CONFLICT    (IDH_DLGFIRST + DLG_CONFLICT)
#define IDH_DLG_ADDFILE     (IDH_DLGFIRST + DLG_ADDFILE)
#define IDH_DLG_INTLDATE    (IDH_DLGFIRST + DLG_INTLDATE)
#define IDH_DLG_INTLTIME    (IDH_DLGFIRST + DLG_INTLTIME)
#define IDH_DLG_INTLNUM     (IDH_DLGFIRST + DLG_INTLNUM)
#define IDH_DLG_INTLCUR     (IDH_DLGFIRST + DLG_INTLCUR)
#define IDH_DLG_NETPRINT    (IDH_DLGFIRST + DLG_NETPRN)

#define IDH_DLG_PATTERN     (IDH_DLGFIRST + DLG_PATTERN)
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)
#define IDH_DLG_MOUSE       (IDH_DLGFIRST + DLG_MOUSE)

#define IDH_DLG_COLORSAVE   (IDH_DLGFIRST + DLG_COLORSAVE)
#define IDH_DLG_COLORDEFINE (IDH_DLGFIRST + DLG_COLORDEFINE)
#define IDH_DLG_CONFIGURE   (IDH_DLGFIRST + DLG_CONFIGURE)
#define IDH_DLG_INSTALL     (IDH_DLGFIRST + DLG_INSTALL)
#define IDH_DLG_UNLIST      (IDH_DLGFIRST + DLG_UNLIST)
#define IDH_DLG_REMOVEFONT  (IDH_DLGFIRST + DLG_REMOVEFONT)
#define IDH_DLG_TRUETYPE    (IDH_DLGFIRST + DLG_TRUETYPE)
#define IDH_DLG_BROWSE      (IDH_DLGFIRST + DLG_BROWSE)

#define IDH_DLG_INSTALL_PS     (IDH_DLGFIRST + DLG_INSTALL_PS)
#define IDH_DLG_REMOVEFONT_PS  (IDH_DLGFIRST + DLG_REMOVEFONT_PS)


#define IDH_DLG_SYSTEM      (IDH_DLGFIRST + DLG_SYSTEM)
#define IDH_DLG_ADDOS       (IDH_DLGFIRST + DLG_ADDOS)

#define IDH_DLG_VIRTUALMEM  (IDH_DLGFIRST + DLG_VIRTUALMEM)

#define IDH_DLG_PREVIOUSCON (IDH_DLGFIRST + DLG_PREVIOUSCON)
#define IDH_DLG_TASKING     (IDH_DLGFIRST + DLG_TASKING)

#define IDH_DLG_COREDUMP    (IDH_DLGFIRST + DLG_COREDUMP)

// pen win help constants

#define IDH_DLG_ROT              (IDH_DLGFIRST + 200)
#define IDH_DLG_CAL              (IDH_DLGFIRST + 201)
#define IDH_DLG_CAL_ACCEPT       (IDH_DLGFIRST + 202)


// MM midi  dialogs
#define IDH_DLG_MIDI_SETUPEDIT  (IDH_DLGFIRST + 404)
#define IDH_DLG_MIDI_PATCHEDIT  (IDH_DLGFIRST + 504)
#define IDH_DLG_MIDI_KEYEDIT    (IDH_DLGFIRST + 604)
#define IDH_DLG_MIDI_SETUPNEW   (IDH_DLGFIRST + 704)
#define IDH_DLG_MIDI_PATCHNEW   (IDH_DLGFIRST + 804)
#define IDH_DLG_MIDI_KEYNEW     (IDH_DLGFIRST + 904)

// MM sound dialogs
#define IDH_DLG_NEWSND          (IDH_DLGFIRST + 503)

// MM drivers dialogs
#define IDH_DLG_ADD_DRIVERS     (IDH_DLGFIRST + 403)
#define IDH_DLG_INSERT_DISK     (IDH_DLGFIRST + 703)
#define IDH_DLG_ADD_UNKNOWN     (IDH_DLGFIRST + 803)
#define IDH_DLG_FILE_ERROR      (IDH_DLGFIRST + 903)

// Screen Saver dialogs
#define IDH_DLG_CHANGEPASS      (IDH_SCRNSAVE)
#define IDH_DLG_MARQUE          (IDH_SCRNSAVE + 1)
#define IDH_DLG_MYSTIFY         (IDH_SCRNSAVE + 2)
#define IDH_DLG_STARSIM         (IDH_SCRNSAVE + 3)
#define IDH_DLG_MARQUEE_FONT    (IDH_SCRNSAVE + 4)
#define IDH_DLG_FLYWIN          (IDH_SCRNSAVE + 5)
#define IDH_DLG_BEZIER          (IDH_SCRNSAVE + 6)

#define IDH_DLG_PRINTER         (IDH_DLGFIRST + DLG_PRINTER)

// We need to change the help stuff when called by the spooler.
#define IDH_PRINTER               (IDH_DLG_PRINTER + IDH_SPOOLER_OFFSET)
#define IDH_DLG_CONNECT           (IDH_DLG_CONFIGURE + IDH_SPOOLER_OFFSET)
#define IDH_DLG_NETCONNECT        (IDH_DLG_NETPRINT + IDH_SPOOLER_OFFSET)
#define IDH_DLG_PREVCON           (IDH_DLG_PREVIOUSCON + IDH_SPOOLER_OFFSET)
#define IDH_DLG_UNLISTED_PRINTER  (IDH_DLG_UNLIST + IDH_SPOOLER_OFFSET)
// #define IDH_DLG_INSTALL_PRINTER   (IDH_DLG_INSTALL + IDH_SPOOLER_OFFSET)
#define IDH_DLG_COM_SET           (IDH_DLG_PORTS2 + IDH_SPOOLER_OFFSET)
#define IDH_DLG_ADVANCED_COMSET   (IDH_DLG_PORTS3 + IDH_SPOOLER_OFFSET)
#define IDH_DLG_PRINTER_BROWSE    (IDH_DLG_BROWSE + IDH_SPOOLER_OFFSET)
#define IDH_DLG_INS_PRINTER_DISK  (IDH_DLG_INSERT_DISK + IDH_SPOOLER_OFFSET)



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\remove.c ===
/*  REMOVE.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for removing
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  History:
**
**      Thu Oct 17 1991 -by- Sanjaya
**      Created. Originally part of drivers.c
*/

#include <windows.h>
#include <mmsystem.h>
#include <winsvc.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <cpl.h>
#include <cphelp.h>

#include "drivers.h"
#include "sulib.h"

BOOL     SetValidAlias      (PSTR, PSTR);

#ifdef DOBOOT
BOOL     FindBootDriver     (char *);
PSTR     strstri            (PSTR, PSTR);
#endif // DOBOOT

/*
 *  RemoveService(szFile)
 *
 *  Remove the service corresponding to the file szFile
 *
 *  returns TRUE if successful, FALSE otherwise
 */

 BOOL RemoveService(LPSTR szFile)
 {
     SC_HANDLE SCManagerHandle;
     SC_HANDLE ServiceHandle;
     char ServiceName[MAX_PATH];
     BOOL Status = FALSE;

    /*
     *  Extract the service name from the file name
     */

     {
         char drive[MAX_PATH], directory[MAX_PATH], ext[MAX_PATH];
         _splitpath(szFile, drive, directory, ServiceName, ext);
     }

    /*
     *  First try and obtain a handle to the service controller
     */

     SCManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
     if (SCManagerHandle == NULL) {

         char szMesg[MAXSTR];
         char szMesg2[MAXSTR];

         LoadString(myInstance, IDS_INSUFFICIENT_PRIVILEGE, szMesg, sizeof(szMesg));
         wsprintf(szMesg2, szMesg, szFile);
         MessageBox(hMesgBoxParent, szMesg2, szRemove, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
         return FALSE;
     }


     ServiceHandle = OpenService(SCManagerHandle,
                                 ServiceName,
                                 SERVICE_ALL_ACCESS);
     if (ServiceHandle != NULL) {
         SERVICE_STATUS ServiceStatus;
         SC_LOCK ServicesDatabaseLock;

        /*
         *  Stop the service if possible.
         */

         ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

        /*
         *  Delete the service.
         *  We aren't detecting if we can just carry on.
         */

        /*
         *  Lock the service controller database to avoid deadlocks
         *  we have to loop because we can't wait
         */


         for (ServicesDatabaseLock = NULL;
              (ServicesDatabaseLock =
                   LockServiceDatabase(SCManagerHandle))
                 == NULL;
              Sleep(100)) {
         }

         Status = DeleteService(ServiceHandle);

         UnlockServiceDatabase(ServicesDatabaseLock);

         CloseServiceHandle(ServiceHandle);
     } else {

        /*
         *  It's possible there was no services entry so the driver
         *  wasn't really installed after all.
         */

         LONG Error = GetLastError();

         if (Error == ERROR_FILE_NOT_FOUND ||
             Error == ERROR_PATH_NOT_FOUND ||
             Error == ERROR_SERVICE_DOES_NOT_EXIST) {
              Status = TRUE;
         }
     }

     CloseServiceHandle(SCManagerHandle);

     return Status;
 }

/*
**  PostRemove()
**
**  Mark an installed driver for removal later AND remove the driver's entry
**  in SYSTEM.INI to avoid conflicts when we add or remove later.
*/
LONG PostRemove(HWND hWnd, PIDRIVER pIDriver, BOOL bLookAtRelated,
                int iIndexMain)
{

    char *keystr;
    char allkeystr[MAXSTR];
    char szfile[MAX_PATH];
    HANDLE hDriver;
    LONG Status = DRVCNF_CANCEL;
    PSTR pstr;


    GetPrivateProfileString(pIDriver->szSection,
                            pIDriver->szAlias,
                            pIDriver->szFile,
                            pIDriver->szFile,
                            MAX_PATH,
                            szSysIni);


   /*
    *  Remove parameters from file name
    */


    for ( pstr=pIDriver->szFile; *pstr && (*pstr!=COMMA) &&
        (*pstr!=SPACE); pstr++ )
            ;
    *pstr = '\0';

    if (bLookAtRelated && (!bRelated || pIDriver->bRelated))
        strcpy(szRestartDrv,  pIDriver->szDesc);

   /*
    *  If it's a kernel driver remove it from the config registry
    *  and services controller
    */

    if (pIDriver->KernelDriver) {

        Status = RemoveService(pIDriver->szFile) ? DRVCNF_RESTART : DRVCNF_CANCEL;

        if (Status == DRVCNF_CANCEL) {
            return DRVCNF_CANCEL;
        }

    } else {

        hDriver = OpenDriver(pIDriver->wszAlias, pIDriver->wszSection, 0L);

        if (hDriver)
        {

           /*
            *  Removal can fail so don't mark as deleted in this case
            */

            Status = SendDriverMessage(hDriver, DRV_REMOVE, 0L, 0L);
            CloseDriver(hDriver, 0L, 0L);

            if (Status == DRVCNF_CANCEL) {
                return DRVCNF_CANCEL;
            }
        }
    }

    SendMessage(hWnd, LB_DELETESTRING, iIndexMain, 0L);
    if (bLookAtRelated)
    {
        char allkeystr[MAXSTR];


        if (GetPrivateProfileString(szRelatedDesc, pIDriver->szAlias,
              allkeystr, allkeystr, sizeof(allkeystr), szControlIni))
        {
            int i, iIndex;
            BOOL bFound;
            PIDRIVER pIDriver;
            char szTemp[MAXSTR];

            for (i = 1; infParseField(allkeystr, i, szTemp);i++)
            {
                bFound = FALSE;

                iIndex = (int)SendMessage(hWnd, LB_GETCOUNT, 0, 0L);
                while ( iIndex-- > 0  && !bFound)
                  if ( (int)(pIDriver = (PIDRIVER)SendMessage(hWnd, LB_GETITEMDATA, iIndex, 0L)) != LB_ERR) {
                      if (!FileNameCmp(pIDriver->szFile, szTemp))
                      {
                          if (PostRemove(hWnd, pIDriver, FALSE, iIndex)
                                 == DRVCNF_RESTART) {
                                 Status = DRVCNF_RESTART;
                             }
                          bFound = TRUE;
                      }

                  }
            }
        }
    }

    // Remove the driver entry from SYSTEM.INI so you don't
    // conflict with other drivers.

    GetPrivateProfileString(pIDriver->szSection, NULL, NULL,
                            allkeystr, sizeof(allkeystr), szSysIni);
    keystr = allkeystr;
    while (strlen(keystr) > 0)
    {
         GetPrivateProfileString(pIDriver->szSection, keystr, NULL, szfile, sizeof(szfile), szSysIni);
         if (!FileNameCmp(pIDriver->szFile, szfile))
               RemoveDriverEntry(keystr, pIDriver->szFile, pIDriver->szSection, bLookAtRelated);
         keystr = &keystr[strlen(keystr) + 1];
    }
    return Status;
}



void RemoveDriverEntry (PSTR szKey, PSTR szFile, PSTR szSection, BOOL bLookAtRelated)
{

   /*
    *  Remove entry for loading driver
    */

    WritePrivateProfileString(szSection, szKey, NULL, szSysIni);

   /*
    *  Delete entry for parameters for this driver
    */

    WriteProfileString(szFile, szKey, NULL);

   /*
    *  Remove entry which says this is a user driver (as opposed to
    *  a pre-installed one).
    */

    WritePrivateProfileString(szUserDrivers, szKey, NULL, szControlIni);

   /*
    *  Remove description
    */

    WritePrivateProfileString(szDriversDesc, szFile, NULL, szControlIni);

   /*
    *  Remove links to related drivers
    */

    WritePrivateProfileString(szRelatedDesc, szKey, NULL, szControlIni);

#ifdef DOBOOT
    FindBootDriver(szKey);
#endif // DOBOOT

    if (bLookAtRelated)
       SetValidAlias(szKey, szSection);
}


/*
 *  SetValidAlias()
 *
 * Check to see if the alias removed would create a hole in the device
 * numbering scheme. If so switch the last device number with the deleted one.
 */
 BOOL SetValidAlias(PSTR pstrType, PSTR pstrSection)
 {
     char *keystr;
     static char allkeystr[MAXSTR];
     static char szExKey[MAXSTR], szExFile[MAXSTR], szExDesc[MAXSTR];
     BOOL bfound = FALSE, bExchange = FALSE;
     int val, maxval = 0, typelen, len;

    /*
     *  Getting length of alias
     */

     len = typelen = strlen(pstrType);

     // If the last char on the type is a number don't consider it

     if (pstrType[typelen -1] > '0' && pstrType[typelen - 1] <= '9')
        typelen--;

     // Get all the aliases in the drivers section

     GetPrivateProfileString(pstrSection, NULL, NULL, allkeystr,
                    sizeof(allkeystr), szSysIni);
     keystr = allkeystr;
     while (*keystr != TEXT('\0'))
     {
        // Compare the root of the aliases
        if (!_strnicmp(keystr, pstrType, typelen) && ((keystr[typelen] <= '9' && keystr[typelen] > '0') || keystr[typelen] == TEXT('\0')))
        {

           //We found a common alias
      bfound = TRUE;
           val = atoi(&keystr[typelen]);
           if (val > maxval)
      {
         maxval = val;
         strcpy(szExKey, keystr);
           }
        }
        //Pointer to next alias
        keystr = &keystr[strlen(keystr) + 1];
     }
     //If we found one
     if (bfound)
     {
    if (len == typelen)
        bExchange = TRUE;
         else
             if (atoi(&pstrType[typelen]) < maxval)
            bExchange = TRUE;

        // We need to exchange it with the one we found
        if (bExchange)
        {
            //Exchanging the one in the drivers section in system.ini
           GetPrivateProfileString(pstrSection, szExKey, NULL, szExFile,
                                    sizeof(szExFile), szSysIni);
            WritePrivateProfileString(pstrSection, szExKey, NULL, szSysIni);
            WritePrivateProfileString(pstrSection, pstrType, szExFile, szSysIni);

 #ifdef TRASHDRIVERDESC
       //Exchanging the one in the drivers description section of control.ini
        GetPrivateProfileString(szDriversDesc, szExKey, NULL, szExDesc, sizeof(szExFile), szControlIni);
        WritePrivateProfileString(szDriversDesc, szExKey, NULL, szControlIni);
        WritePrivateProfileString(szDriversDesc, pstrType, szExDesc, szControlIni);
 #endif

            //If any related drivers were present under old alias switch them
            GetPrivateProfileString(szRelatedDesc, szExKey, NULL, szExDesc, sizeof(szExFile), szControlIni);

            if (strlen(szExDesc))
            {
               WritePrivateProfileString(szRelatedDesc, szExKey, NULL, szControlIni);
               WritePrivateProfileString(szRelatedDesc, pstrType, szExDesc, szControlIni);
            }

            //If user installed driver under old alias switch them
           GetPrivateProfileString(szUserDrivers, szExKey, NULL, szExDesc, sizeof(szExFile), szControlIni);

           if (strlen(szExDesc))
           {
              WritePrivateProfileString(szUserDrivers, szExKey, NULL, szControlIni);
              WritePrivateProfileString(szUserDrivers, pstrType, szExDesc, szControlIni);
            }

 #ifdef DOBOOT
            if (FindBootDriver(szExKey))
           {
              static char szTemp[MAXSTR];

               GetPrivateProfileString(szBoot, szDrivers, szTemp, szTemp,
                                 sizeof(szTemp), szSysIni);
               strcat(szTemp, " ");
              strcat(szTemp, pstrType);
               WritePrivateProfileString(szBoot, szDrivers, szTemp, szSysIni);
            }
 #endif // DOBOOT

        }
     }
     return(bExchange);
 }

#if 0 // Dead code !

/*
 *  IsOnlyInstance()
 *
 *  Check to see if this is the only occurance of an open driver, so we can
 *  tell if a DRV_INSTALL message has been sent to the driver yet OR
 *  if it is the last instance of the driver so we can send a
 *  DRV_REMOVE message.
 */

 BOOL IsOnlyInstance( HWND hwndLB, PIDRIVER pIDriver )
 {
     int iEntries;
     PIDRIVER    pIDTest;

     if (pIDriver == NULL)
         return FALSE;

    /*
     *  Check Installed ListBox
     */

     if ((iEntries = (int)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L)) == LB_ERR)
         iEntries = 0;
     else
         while (iEntries-- > 0)
         {
             pIDTest = (PIDRIVER)SendMessage(hwndLB,
                                             LB_GETITEMDATA,
                                             iEntries,
                                             0L);
             if (pIDTest == NULL)
                 continue;

             if (pIDriver == pIDTest)
                 continue;

             if (FileNameCmp(pIDTest->szFile,pIDriver->szFile) == 0)
             {
                 return FALSE;
             }
         }

     return TRUE;
 }
#endif

int FileNameCmp(char far *pch1, char far *pch2)
{
    LPSTR pchEOS;

    while (*pch1 == ' ') pch1++; // eat spaces
    while (*pch2 == ' ') pch2++; // eat spaces

    for (pchEOS = pch1; *pchEOS && *pchEOS != ' '; pchEOS++);

    return _strnicmp(pch1, pch2, pchEOS - pch1);
}

#ifdef DOBOOT

PSTR strstri(PSTR pszStr, PSTR pszKey)
{
     while (pszStr)
        if (!_strnicmp(pszStr, pszKey, lstrlen(pszKey)))
         return(pszStr);
        else
             pszStr++;
     return(NULL);
}

/*
 *   FindBootDriver()
 *  Checks to see if the driver alias is on the drivers line of the
 *  boot section. If so the alias is removed from the line.
 */

BOOL FindBootDriver(char *szKey)
{
    char *ptr;
    int wKeyLen = (int)strlen(szKey);
    char *endkey;
    static char szDriverline[MAXSTR];

    GetPrivateProfileString("boot", "drivers", szDriverline, szDriverline,
                    MAX_PATH, szSysIni);
    ptr = strstri(szDriverline, szKey);
    if (ptr)
    {

    if ((((ptr != szDriverline) && (*(ptr - 1) == ' ' )) ||
          (ptr == szDriverline)) &&
        (*(ptr + wKeyLen) == ' ' || *(ptr + wKeyLen) == NULL))
    {
        endkey = ptr + wKeyLen;
        while (*endkey)
          *ptr++ = *endkey++;
        *ptr = NULL;
        WritePrivateProfileString("boot", "drivers", szDriverline,
                            szSysIni);
        return(TRUE);
    }
    }
    return(FALSE);
}

#endif // DOBOOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\h\cplib.h ===
/** FILE: cplib.h ********** Module Header ********************************
 *
 *  Control panel utility library routines for use by control panel applets.
 *  Common definitions, resource ids, typedefs, external declarations and
 *  library routine function prototypes.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-    Steve Cathcart   [stevecat]
 *       Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992	-by-	Steve Cathcart   [stevecat]
 *	    Updated code to latest Win 3.1 sources
 *
 *  Copyright (C) 1990-1992 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                        Typedefs and Definitions
//==========================================================================
// NOTE: The following lines are used by applets to define items in their
//               resource files.  These are necessary to be compatible with some of
//               library routines.
//
// Resource String ids for Applets
#define INITS           16
#define CLASS           36
#define COPY            (CLASS + 4)

#define UTILS           64
#define INSTALLIT  196

#define FOO -1                  // for useless control ids

#define IDD_HELP        200             // Help control id

#define CP_ACCEL        100             // Keyboard Accelerator table

// End resource file definitions

#define PATHMAX         133         // path length max

#define MYNUL     (LPSTR) szNull

#define COLOR_SAVE        711

#define  NOSELECT -1        // indices for int Selected
#define  HOUR     0             // index into rDateTime, wDateTime, wRange
#define  MINUTE   1
#define  SECOND   2
#define  MONTH    3
#define  DAY      4
#define  YEAR     5
#define  WEEKDAY  6
#if 0
#define  UPTIME   6
#define  DOWNTIME 7
#define  UPDATE   8
#define  DOWNDATE 9
#endif

typedef BOOL (APIENTRY *BWNDPROC)(HWND, UINT, DWORD, LONG);

#ifndef NOARROWS
typedef struct
  {
    short lineup;             /* lineup/down, pageup/down are relative */
    short linedown;           /* changes.  top/bottom and the thumb    */
    short pageup;             /* elements are absolute locations, with */
    short pagedown;           /* top & bottom used as limits.          */
    short top;
    short bottom;
    short thumbpos;
    short thumbtrack;
    BYTE  flags;              /* flags set on return                   */
  } ARROWVSCROLL;
typedef ARROWVSCROLL NEAR     *NPARROWVSCROLL;
typedef ARROWVSCROLL FAR      *LPARROWVSCROLL;

#define UNKNOWNCOMMAND 1
#define OVERFLOW       2
#define UNDERFLOW      4

#endif

#define COPY_CANCEL        0
#define COPY_SELF         -1
#define COPY_NOCREATE     -2
#define COPY_DRIVEOPEN    -3
#define COPY_NODISKSPACE  -4
#define COPY_NOMEMORY     -5

//  AddStringToObject defines
#define ASO_GLOBAL  0x0001
#define ASO_FIXED   0x0002
#define ASO_EXACT   0x0004
#define ASO_COMPACT 0x0008

/* Help defines */
#define IDH_HELPFIRST                   5000
#define IDH_DLGFIRST      (IDH_HELPFIRST + 3000)
#define IDH_DLG_CONFLICT  (IDH_DLGFIRST + DLG_CONFLICT)
#define IDH_DLG_ADDFILE   (IDH_DLGFIRST + DLG_ADDFILE)

#define MENU_INDHELP     40

//==========================================================================
//                              Macros
//==========================================================================
#define GSM(SM) GetSystemMetrics(SM)
#define GDC(dc, index) GetDeviceCaps(dc, index)

#define LPMIS LPMEASUREITEMSTRUCT
#define LPDIS LPDRAWITEMSTRUCT
#define LPCIS LPCOMPAREITEMSTRUCT

#define LONG2POINT(l, pt)   (pt.y = (int) HIWORD(l),  pt.x = (int) LOWORD(l))

//==========================================================================
//                         External Declarations
//==========================================================================
/* exported from applets  */
extern HANDLE hModule;


/* exported from cplib  */
/* initapp.c  */
extern char szOnString[];               // separator printer/port in listboxes
extern char szSeparator[];              // separator filename printer desc
extern char szDefNullPort[];            // default null port name
									
extern char szCtlPanel[];
extern char szErrMem[];

extern char szBasePath[];               /* Path to WIN.INI directory */
extern char szWinIni[];                 /* Path to WIN.INI */
extern char szWinCom[];                 /* Path to WIN.COM directory */
extern char szSystemIniPath[];          /* Path to SYSTEM.INI */
extern char szCtlIni[];                 /* Path to CONTROL.INI */
extern char szControlHlp[];
extern char szSetupInfPath[];
extern char szSetupDir[];
extern char szSharedDir[];

extern char pszSysDir[];
extern char pszWinDir[];
extern char pszClose[];
extern char pszContinue[];

extern char szSYSTEMINI[];
extern char szSETUPINF[];
extern char szCONTROLINF[];

extern char BackSlash[];
extern char szFOT[];
extern char szDot[];

extern unsigned wMerge;                 /* MERGE SPEC FOR STRINGS */

/* utiltext.c */
extern char szGenErr[];
extern char szNull[];
extern char szComma[];
extern char szSpace[];

extern short wDateTime[];                   // values for first 7 date/time items
extern short wModulos[];                    // highest value for hour, minute, second
extern short wPrevDateTime[];               // only repaint fields if nec

/* Help stuff */
extern DWORD dwContext;
extern WORD  wHelpMessage;
extern WORD  wBrowseMessage;
extern WORD  wBrowseDoneMessage;


// Originally from cpprn.c
extern short nDisk;
extern char szDrv[];
extern char szDirOfSrc[];               	// Directory for File copy
extern WORD nConfID;                    	// For conflict dialog


//==========================================================================
//                          Function Prototypes
//==========================================================================
/* utiltext.c */

void GetDate (void);
void GetTime (void);
void SetDate (void);
void SetTime (void);

void SetDateTime (void);                // [stevecat] - new functions
void GetDateTime (void);

DWORD  AddStringToObject(DWORD dwStringObject, LPSTR lpszSrc, WORD wFlags);
LPSTR  BackslashTerm (LPSTR pszPath);
void   ErrMemDlg(HWND hParent);
HANDLE FindRHSIni (LPSTR pFile, LPSTR pSection, LPSTR pRHS);
int    GetSection (LPSTR lpFile, LPSTR lpSection, LPHANDLE hSection);
short  myatoi(LPSTR pszInt);
HANDLE StringToLocalHandle (LPSTR lpStr);

#ifdef LATER
void   ErrWinDlg(HWND hParent);
short  Copy(HWND hParent, char *szSrcFile, char *szDestFile);
#endif  //  LATER

/* util.c */

int    DoDialogBoxParam(int nDlg, HWND hParent, WNDPROC lpProc,
                                        DWORD dwHelpContext, DWORD dwParam);
void   HourGlass (BOOL bOn);
int    MyMessageBox(HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ...);
void   SendWinIniChange(LPSTR szSection);
int    strpos(LPSTR,char);
char   *strscan(char *, char *);
void   StripBlanks( char * );

/* arrow.c */
short ArrowVScrollProc(short wScroll, short nCurrent, LPARROWVSCROLL lpAVS);
BOOL  OddArrowWindow(HWND);

// initapp.c (new)       (Originally from control.c)
BOOL AppletInit();

// addfile.c (new)   (Originally from cpprn.c)
BOOL AddFileDlg (HWND hDlg, UINT message, DWORD wParam, LONG lParam);

// conflict.c (new)   (Originally from cpprn.c)
BOOL ConflictDlg(HWND hDlg, UINT message, DWORD wParam, LONG lParam);

#if DBG
void  DbgPrint( char *, ... );
void  DbgBreakPoint( void );
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\joycpl.c ===
//****************************************************************************
//
//  File:       joycpl.c
//  Content:    Joystick configuration and testing
//  History:
//   Date	By	Reason
//   ====	==	======
//   03-oct-94	craige	initial implementation
//   05-nov-94	craige	generalized 4 axis joysticks and other improvements
//   11-nov-94	craige	allow multiple copies of tab to run
//   22-nov-94	craige	tweaks to calibration code
//   29-nov-94	craige	small bugs
//   08-dec-94	craige	generalized second joystick
//   11-dec-94	craige	split into component parts
//   15-dec-94	craige	allow N joysticks
//   18-dec-94	craige	process UV
//   05-jan-95	craige	external rudder bug
//   05-mar-95	craige	Bug 9998: pass id -1 to get base dev caps
//			Bug 15334: allow reset of user values for compatiblity
//   06-mar-95	craige	Bug 7608: deleting VxD name if joystick not present
//				  caused unplugged joystick to never come back
//   06-may-96	richj	ported to NT
//
//  Copyright (c) Microsoft Corporation 1994
//
//****************************************************************************


#include "joycpl.h"

extern HINSTANCE hInstance;	// main.c

#define cchLENGTH(_sz)       (sizeof(_sz)/sizeof(_sz[0]))
#define GetString(_sz,_ids)  LoadString (hInstance, _ids, _sz, cchLENGTH(_sz))


#ifdef DEBUG
void cdecl MBOX(LPSTR szFormat, ...)
{
    char ach[256];

    wvsprintf( ach,szFormat,(LPSTR)(&szFormat+1));
    MessageBox( NULL, ach, "JOYCPL", MB_OK | MB_SYSTEMMODAL );
                                                        
}
#endif

/***************************************************************************
 
 
  MEMORY MANAGEMENT ROUTINES FOLLOW
 
 
 ***************************************************************************/

#ifdef DEBUG
DWORD	allocCount;
#endif

/*
 * DoAlloc - allocate memory
 */
LPVOID DoAlloc( DWORD size )
{
    LPVOID	res;

    res = LocalAlloc( LPTR, size );
    #ifdef DEBUG
    	allocCount++;
    #endif
    return res;

} /* DoAlloc */

/*
 * DoFree - free allocated memory
 */
void DoFree( LPVOID ptr )
{
    if( ptr != NULL ) {
	LocalFree( ptr );
    #ifdef DEBUG
    	allocCount--;
	if( allocCount < 0 ) {
	    DPF( "JOYCPL:  Too many frees, allocCount=%d\r\n", allocCount );
	}
    #endif
    }

} /* DoFree */


/***************************************************************************
 
 
  REGISTRY RELATED ROUTINES FOLLOW
 
 
 ***************************************************************************/

/*
 * getDevCaps - get the joystick device caps
 */
static void getDevCaps( LPGLOBALVARS pgv )
{
    JOYCAPS	jc;

    if( joyGetDevCaps( pgv->iJoyId, &jc, sizeof( jc ) ) == JOYERR_NOERROR ) {
	pgv->joyRange.jpMin.dwX = jc.wXmin;
	pgv->joyRange.jpMax.dwX = jc.wXmax;
	pgv->joyRange.jpMin.dwY = jc.wYmin;
	pgv->joyRange.jpMax.dwY = jc.wYmax;
	pgv->joyRange.jpMin.dwZ = jc.wZmin;
	pgv->joyRange.jpMax.dwZ = jc.wZmax;
	pgv->joyRange.jpMin.dwR = jc.wRmin;
	pgv->joyRange.jpMax.dwR = jc.wRmax;
	pgv->joyRange.jpMin.dwU = jc.wUmin;
	pgv->joyRange.jpMax.dwU = jc.wUmax;
	pgv->joyRange.jpMin.dwV = jc.wVmin;
	pgv->joyRange.jpMax.dwV = jc.wVmax;
	pgv->dwMaxAxes = (DWORD) jc.wMaxAxes;
    }

} /* getDevCaps */

extern MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );

/*
 * RegistryUpdated - notify the driver that the registry is updated
 */
void RegistryUpdated( LPGLOBALVARS pgv )
{
    joyConfigChanged( 0 );
    if( pgv != NULL ) {
	getDevCaps( pgv );		// devcaps could change
    }

} /* RegistryUpdated */

/*
 * createSettingsKeyFromCurr - create a settings key for a specific joystick
 */
static void createSettingsKeyFromCurr( LPGLOBALVARS pgv, LPSTR str )
{
    char	tmp[MAX_STR];
    int		type;
    LPJOYDATA	pjd;

    pjd = pgv->pjd;

    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM ) {
	type = pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY;
	if( type < 0 || type >= pjd->oemCount ) {
	    tmp[0] = 0;
	} else {
	    strcpy( tmp, pjd->oemList[type].keyname );
	}
    } else {
	wsprintf( tmp, "predef%d", pgv->joyHWCurr.dwType );
    }
    wsprintf( str, "%s\\%s", pjd->regSettingsCfgKey, tmp );

} /* createSettingsKeyFromCurr */

/*
 * regSaveSpecificJoyHW - save specific joystick hardware config. to the registry
 */
static void regSaveSpecificJoyHW( LPGLOBALVARS pgv )
{
    char	str[MAX_STR];
    HKEY	hkey;
    char	jcfg[MAX_STR];

    if( pgv->joyHWCurr.dwType == JOY_HW_NONE ) {
	return;
    }
    if( !(pgv->joyActiveFlags & HASJOY) ) {
	return;
    }

    createSettingsKeyFromCurr( pgv, str );
    if( !RegCreateKey( HKEY_LOCAL_MACHINE, str, &hkey ) ) {
	GETKEYNAME( pgv, jcfg, REGSTR_VAL_JOYNCONFIG );
	RegSetValueEx( hkey, jcfg, 0, REG_BINARY,
	    (CONST LPBYTE)&pgv->joyHWCurr, sizeof( pgv->joyHWCurr ));
	RegCloseKey( hkey );
    }

} /* regSaveSpecificJoyHW */

/*
 * regCreateCurrKey - create the current joystick settings key
 */
static HKEY regCreateCurrKey( LPGLOBALVARS pgv )
{
    HKEY	hkey;

    if( !RegCreateKey( HKEY_LOCAL_MACHINE, pgv->pjd->regCurrCfgKey, &hkey ) ) {
	return hkey;
    } else {
	return NULL;
    }

} /* regCreateCurrKey */

/*
 * RegSaveCurrentJoyHW - save the joystick info to the current entry in
 * 		      the registry
 */
void RegSaveCurrentJoyHW( LPGLOBALVARS pgv )
{
    HKEY	hkey;
    LPSTR	sptr;
    char	vname[MAX_STR];
    char	oname[MAX_STR];
    char	coname[MAX_STR];
    int		type;
    LPJOYDATA	pjd;

    if( pgv->joyHWCurr.dwType == JOY_HW_NONE ) {
	return;
    }
    if( !(pgv->joyActiveFlags & HASJOY) ) {
	return;
    }

    hkey = regCreateCurrKey( pgv );
    if( hkey == NULL ) {
	DPF( "Could not save current joystick settings!\r\n" );
	return;
    }
    pjd = pgv->pjd;
    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM ) {
	sptr = pjd->oemList[ pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY ].keyname;
    }
    GETKEYNAME( pgv, vname, REGSTR_VAL_JOYNCONFIG );
    GETKEYNAME( pgv, oname, REGSTR_VAL_JOYNOEMNAME );
    GETKEYNAME( pgv, coname, REGSTR_VAL_JOYNOEMCALLOUT );

    RegSetValueEx( hkey, vname, 0, REG_BINARY,
		(CONST LPBYTE)&pgv->joyHWCurr, sizeof( pgv->joyHWCurr ) );
    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM ) {
	RegSetValueEx( hkey, oname, 0, REG_SZ, sptr, strlen( sptr ) + 1 );

	/*
	 * set up VxD name for this joystick
	 */
	type = pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY;
	if( (pjd->oemList[type].vxd_name[0] != 0) ) {
	    RegSetValueEx( hkey, coname, 0, REG_SZ, pjd->oemList[type].vxd_name,
				strlen( pjd->oemList[type].vxd_name )+1 );
	} else {
	    RegDeleteValue( hkey, coname );
	}
    } else {
	RegDeleteValue( hkey, oname );
	RegDeleteValue( hkey, coname );
    }

    RegCloseKey( hkey );

} /* RegSaveCurrentJoyHW */

/*
 * regPermSaveAllInfo - save joystick data to the registry for good
 */
static void regPermSaveAllInfo( LPGLOBALVARS pgv )
{
    // save specific hardware settings to the registry
    regSaveSpecificJoyHW( pgv );

    // save current current hardware to the registry
    RegSaveCurrentJoyHW( pgv );

    RegistryUpdated( pgv );

} /* regPermSaveAllInfo */

/*
 * setHWCurrType - set the current hardware type (check for OEM type)
 */
static BOOL setHWCurrType( LPGLOBALVARS pgv, HKEY hkey, LPJOYREGHWCONFIG pcfg )
{
    char	str[MAX_STR];
    char	pname[MAX_STR];
    int		i;
    DWORD	regtype;
    DWORD	cb;
    LPJOYDATA	pjd;

    if( !(pcfg->dwUsageSettings & JOY_US_ISOEM) ) {
	return TRUE;
    }
    GETKEYNAME( pgv, pname, REGSTR_VAL_JOYNOEMNAME );
    cb = sizeof( str );
    if( RegQueryValueEx( hkey, pname, NULL, &regtype, (CONST LPBYTE)str, &cb)) {
	return FALSE;
    }
    if( regtype != REG_SZ ) {
	return FALSE;
    }
    pjd = pgv->pjd;
    for( i=0;i<pjd->oemCount;i++ ) {
	if( !_stricmp( str, pjd->oemList[i].keyname ) ) {
	    pcfg->dwType = i + JOY_HW_LASTENTRY;
	    return TRUE;
	}
    }
    return FALSE;

} /* setHWCurrType */

/*
 * regGetCurrHW - get the information about the current configuration
 *		from the registry
 */
static void regGetCurrHW( LPGLOBALVARS pgv )
{
    DWORD   regtype;
    DWORD   cb;
    JOYREGHWCONFIG   config;
    HKEY    hkey;
    char    str[MAX_STR];
    JOYCAPS jc;

    pgv->joyHWCurr = pgv->pjd->joyHWDefaults[ JOY_HW_NONE ];

    // Give the joystick driver a chance to write its current settings,
    // if there are none.
    //
    joyGetDevCaps( pgv->iJoyId, &jc, sizeof( jc ) );

    // Read those current settings (if they exist), and use them to determine
    // what type of joystick we've got
    //
    if ((hkey = regCreateCurrKey (pgv)) != NULL)
    {
        cb = sizeof( config );
        GETKEYNAME( pgv, str, REGSTR_VAL_JOYNCONFIG );
        if( !RegQueryValueEx( hkey, str, NULL,
                              &regtype, (CONST LPBYTE)&config, &cb)) {
            if( regtype == REG_BINARY && cb == sizeof( config ) ) {
                if( setHWCurrType( pgv, hkey, &config ) ) {
                    pgv->joyHWCurr = config;
                }
            }
        }
        RegCloseKey(  hkey );
    }

    // Does this joystick match a known type?
    //
    if (pgv->joyHWCurr.hws.dwNumButtons != 0)
    {
        int ii;
        for ( ii=0;ii<pgv->pjd->oemCount;ii++ )
        {
            if ( (pgv->pjd->oemList[ii].hws.dwFlags ==
                    pgv->joyHWCurr.hws.dwFlags) &&
                 (pgv->pjd->oemList[ii].hws.dwNumButtons ==
                    pgv->joyHWCurr.hws.dwNumButtons) )
            {
                pgv->joyHWCurr.dwType = ii + JOY_HW_LASTENTRY;
                break;
            }
        }

        if (pgv->joyHWCurr.dwType == JOY_HW_NONE)
        {
            pgv->joyHWCurr.dwType = JOY_HW_CUSTOM;
        }
    }
} /* regGetCurrHW */

/*
 * regGetOEMStr - get an OEM string
 */
static BOOL regGetOEMStr( HKEY hkey, LPSTR keyname, LPSTR buff, int size,
			LPSTR *res )
{
    DWORD	cb;
    DWORD	type;
    LPSTR	str;
    int		slen;

    cb = size;
    slen = 1;
    if( !RegQueryValueEx( hkey, keyname, NULL, &type, (CONST LPBYTE)buff, &cb ) ) {
	if( type == REG_SZ ) {
	    slen = strlen( buff ) + 1;
	}
    }
    str = DoAlloc( slen );
    if( str != NULL ) {
	if( slen == 1 ) {
	    str[0] = 0;
	} else {
	    strcpy( str, buff );
	}
    }
    *res = str;
    if( str == NULL ) {
	return TRUE;
    }
    return FALSE;

} /* regGetOEMStr */

/*
 * checkNonStandardUserVals
 */
static BOOL checkNonStandardUserVals( LPJOYREGUSERVALUES puv )
{
    if( (puv->jrvRanges.jpMin.dwX != RANGE_MIN) ||
	(puv->jrvRanges.jpMin.dwY != RANGE_MIN) ||
	(puv->jrvRanges.jpMin.dwZ != RANGE_MIN) ||
	(puv->jrvRanges.jpMin.dwR != RANGE_MIN) ||
	(puv->jrvRanges.jpMin.dwU != RANGE_MIN) ||
	(puv->jrvRanges.jpMin.dwV != RANGE_MIN) ||
	(puv->jrvRanges.jpMax.dwX != RANGE_MAX) ||
	(puv->jrvRanges.jpMax.dwY != RANGE_MAX) ||
	(puv->jrvRanges.jpMax.dwZ != RANGE_MAX) ||
	(puv->jrvRanges.jpMax.dwR != RANGE_MAX) ||
	(puv->jrvRanges.jpMax.dwU != RANGE_MAX) ||
	(puv->jrvRanges.jpMax.dwV != RANGE_MAX) ||
	(puv->dwTimeOut != 0x1000) ||
	(puv->jpDeadZone.dwX != 0) ||
	(puv->jpDeadZone.dwY != 0) ) {
	return TRUE;
    }
    return FALSE;

} /* checkNonStandardUserVals */

/*
 * regSetUserVals - set user values to our defaults
 */
static void regSetUserVals( LPJOYDATA pjd, BOOL retest )
{
    JOYREGUSERVALUES	uv;
    JOYREGUSERVALUES	ouv;
    HKEY		hkey;
    DWORD		regtype;
    DWORD		cb;

    if( !RegOpenKey( HKEY_LOCAL_MACHINE, pjd->regCfgKey, &hkey ) ) {
	/*
	 * build the default settings
	 */
	memset( &uv, 0, sizeof( uv ) );
	uv.dwTimeOut = 0x1000;
	uv.jpDeadZone.dwX = 0;
	uv.jpDeadZone.dwY = 0;
	uv.jrvRanges.jpMin.dwX = RANGE_MIN;
	uv.jrvRanges.jpMin.dwY = RANGE_MIN;
	uv.jrvRanges.jpMin.dwZ = RANGE_MIN;
	uv.jrvRanges.jpMin.dwR = RANGE_MIN;
	uv.jrvRanges.jpMin.dwU = RANGE_MIN;
	uv.jrvRanges.jpMin.dwV = RANGE_MIN;
	uv.jrvRanges.jpMax.dwX = RANGE_MAX;
	uv.jrvRanges.jpMax.dwY = RANGE_MAX;
	uv.jrvRanges.jpMax.dwZ = RANGE_MAX;
	uv.jrvRanges.jpMax.dwR = RANGE_MAX;
	uv.jrvRanges.jpMax.dwU = RANGE_MAX;
	uv.jrvRanges.jpMax.dwV = RANGE_MAX;

	if( retest ) {
	    /*
	     * see if the values have changed since we last set them:
	     * if yes, then we need to reset our remembered values
	     */
	    DPF( "Looking for USER entries\r\n" );
	    cb = sizeof( ouv );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, NULL,
				    &regtype, (CONST LPBYTE)&ouv, &cb)) {
		DPF( "found REGSTR_VAL_JOYUSERVALUES\r\n" );
		if( regtype == REG_BINARY && cb == sizeof( ouv ) ) {
		    if( memcmp( &uv, &ouv, sizeof( uv ) ) ) {
			DPF( "USER entries changed!\r\n" );
			pjd->bHasUserVals = TRUE;
			pjd->bDeleteUserVals = FALSE;
			pjd->userVals = ouv;
		    }
		}
	    } else {
		if( pjd->bHasUserVals ) {
		    DPF( "USER entries changed, no longer exist!\r\n" );
		    pjd->bHasUserVals = FALSE;
		    pjd->bDeleteUserVals = TRUE;
		}
	    }
	}

	/*
	 * set our new values
	 */
	RegSetValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, 0, REG_BINARY,
	    (CONST LPBYTE)&uv, sizeof( uv ) );
	RegCloseKey( hkey );
    }

} /* regSetUserVals */

/*
 * regUserValsInit - save old user values, and init to ones we like
 */
static void regUserValsInit( LPJOYDATA pjd )
{
    HKEY		hkey;
    DWORD		regtype;
    DWORD		cb;

    pjd->bHasUserVals = FALSE;
    pjd->bDeleteUserVals = FALSE;
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, pjd->regCfgKey, &hkey ) ) {
	cb = sizeof( pjd->userVals );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, NULL,
				&regtype, (CONST LPBYTE)&pjd->userVals, &cb)) {
	    if( regtype == REG_BINARY && cb == sizeof( pjd->userVals ) ) {
		pjd->bHasUserVals = TRUE;
		DPF( "USER entries exist!\r\n" );
	    }
	    pjd->bHasNonStandardUserVals = checkNonStandardUserVals( &pjd->userVals );
	} else {
	    pjd->bDeleteUserVals = TRUE;
	    pjd->bHasNonStandardUserVals = FALSE;
	    DPF( "USER entries don't exist!\r\n" );
	}
	RegCloseKey( hkey );
    }
    regSetUserVals( pjd, FALSE );

} /* regUserValsInit */

/*
 * regUserValsFini - restore old user values
 */
static void regUserValsFini( LPJOYDATA pjd )
{
    HKEY	hkey;
    if( pjd->bResetUserVals ) {
	RegDeleteValue( hkey, REGSTR_VAL_JOYUSERVALUES );
	RegistryUpdated( NULL );
    } else if( pjd->bHasUserVals || pjd->bDeleteUserVals ) {
	if( !RegOpenKey( HKEY_LOCAL_MACHINE, pjd->regCfgKey, &hkey ) ) {
	    if( pjd->bHasUserVals ) {
		DPF( "resetting USER entries!\r\n" );
		RegSetValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, 0, REG_BINARY,
		    (CONST LPBYTE)&pjd->userVals, sizeof( pjd->userVals ) );
	    } else {
		DPF( "deleting USER entries!\r\n" );
		RegDeleteValue( hkey, REGSTR_VAL_JOYUSERVALUES );
	    }
	    RegistryUpdated( NULL );
	}
	pjd->bHasUserVals = FALSE;
	pjd->bDeleteUserVals = FALSE;
    }

} /* regUserValsFini */


/***************************************************************************
 
 
  CUSTOM JOYSTICK SELECTION FUNCTIONS FOLLOW
 
 
 ***************************************************************************/


/*
 * custom joystick variables
 */
typedef struct {
    LPGLOBALVARS	pgv;
    BOOL 		bHasZ;
    BOOL 		bHasR;
    BOOL 		bHasPOV;
    BOOL 		bIsYoke;
    BOOL 		bIsGamePad;
    BOOL 		bIsCarCtrl;
    BOOL 		bHas2Buttons;
} cust_vars, *LPCUSTVARS;


/*
 * enableCustomSpecial - enable the special section of the custom dialog box
 */
static void enableCustomSpecial( HWND hwnd, BOOL on )
{
    EnableWindow( GetDlgItem( hwnd, IDC_JOYISYOKE ), on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYISGAMEPAD ), on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYISCARCTRL ), on );
    CheckDlgButton( hwnd, IDC_JOYUSESPECIAL, on );
    if( !on ) {
	CheckDlgButton( hwnd, IDC_JOYISYOKE, FALSE );
	CheckDlgButton( hwnd, IDC_JOYISGAMEPAD, FALSE );
	CheckDlgButton( hwnd, IDC_JOYISCARCTRL, FALSE );
    }

} /* enableCustomSpecial */

/*
 * context help for the custom settings dialog
 */
    const static DWORD aCustomHelpIDs[] = {  // Context Help IDs
        IDC_GROUPBOX,       IDH_JOYSTICK_CUSTOM_AXES,
        IDC_GROUPBOX_2,     IDH_JOYSTICK_CUSTOM_BUTTONS,
        IDC_GROUPBOX_3,     IDH_JOYSTICK_GROUPBOX,
        IDC_JOY2AXIS,       IDH_JOYSTICK_CUSTOM_AXES,
        IDC_JOY3AXIS,       IDH_JOYSTICK_CUSTOM_AXES,
        IDC_JOY4AXIS,       IDH_JOYSTICK_CUSTOM_AXES,
        IDC_JOY2BUTTON,     IDH_JOYSTICK_CUSTOM_BUTTONS,
        IDC_JOY4BUTTON,     IDH_JOYSTICK_CUSTOM_BUTTONS,
        IDC_JOYHASPOV,      IDH_JOYSTICK_CUSTOM_POV_HAT,
        IDC_JOYISYOKE,      IDH_JOYSTICK_CUSTOM_FLIGHT_YOKE,
        IDC_JOYISGAMEPAD,   IDH_JOYSTICK_CUSTOM_GAME_PAD,
        IDC_JOYISCARCTRL,   IDH_JOYSTICK_CUSTOM_CAR_CONTROL,
        IDC_JOYUSESPECIAL,  IDH_JOYSTICK_CUSTOM_CUSTOM_FEATURES,

        0, 0
    };

/*
 * CustomProc - callback procedure for custom joystick setup
 */
BOOL CALLBACK CustomProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    int			id;
    LPGLOBALVARS	pgv;
    LPCUSTVARS		pcv;

    switch( umsg ) {
    case WM_DESTROY:
    	/*
	 * don't free the dialog's variables here, they are returned to the
	 * creator; the creator will free them
	 */
	break;
    case WM_INITDIALOG:
    	/*
	 * create variables for the custom dialog
	 */
    	pcv = DoAlloc( sizeof( cust_vars ) );
	SetWindowLong( hwnd, DWL_USER, (LONG) pcv );
	if( pcv == NULL ) {
	    EndDialog( hwnd, 0 );
	    return FALSE;
	}
    	pgv = (LPGLOBALVARS) lParam;
	pcv->pgv = pgv;

	/*
	 * set up initial dialog state
	 */
	pcv->bHasZ = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASZ);
	pcv->bHasR = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASR);
	pcv->bHas2Buttons = (pgv->joyHWCurr.hws.dwNumButtons == 2);
	pcv->bHasPOV = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASPOV);
	pcv->bIsYoke = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_ISYOKE);
	pcv->bIsGamePad = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_ISGAMEPAD);
	pcv->bIsCarCtrl = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_ISCARCTRL);
	if( pcv->bHasZ && pcv->bHasR ) {
	    CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, IDC_JOY4AXIS );
	} else if( pcv->bHasZ ) {
	    CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, IDC_JOY3AXIS );
	} else {
	    CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, IDC_JOY2AXIS );
	}
	if( pcv->bHas2Buttons ) {
	    CheckRadioButton( hwnd, IDC_JOY2BUTTON, IDC_JOY4BUTTON, IDC_JOY2BUTTON );
	} else {
	    CheckRadioButton( hwnd, IDC_JOY2BUTTON, IDC_JOY4BUTTON, IDC_JOY4BUTTON );
	}
	CheckDlgButton( hwnd, IDC_JOYHASPOV, pcv->bHasPOV );
	id = -1;
	if( pcv->bIsYoke ) {
	    id = IDC_JOYISYOKE;
	} else if( pcv->bIsGamePad ) {
	    id = IDC_JOYISGAMEPAD;
	} else if( pcv->bIsCarCtrl ) {
	    id = IDC_JOYISCARCTRL;
	}
	if( id != -1 ) {
	    enableCustomSpecial( hwnd, TRUE );
	    CheckRadioButton( hwnd, IDC_JOYISYOKE, IDC_JOYISCARCTRL, id );
	} else {
	    enableCustomSpecial( hwnd, FALSE );
	}
	return FALSE;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, cszHelpFile,
            HELP_WM_HELP, (DWORD)(LPSTR) aCustomHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, cszHelpFile, HELP_CONTEXTMENU,
            (DWORD)(LPVOID) aCustomHelpIDs);
        return TRUE;

    case WM_COMMAND:
	pcv = (LPCUSTVARS) GetWindowLong( hwnd, DWL_USER );
	id = GET_WM_COMMAND_ID(wParam, lParam);
	switch( id ) {
	case IDC_JOY2AXIS:
	case IDC_JOY3AXIS:
	case IDC_JOY4AXIS:
	    CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, id );
	    pcv->bHasZ = FALSE;
	    pcv->bHasR = FALSE;
	    if( id == IDC_JOY3AXIS ) {
		pcv->bHasZ = TRUE;
	    } else if( id == IDC_JOY4AXIS ) {
		pcv->bHasZ = TRUE;
		pcv->bHasR = TRUE;
	    }
	    break;
	case IDC_JOY2BUTTON:
	case IDC_JOY4BUTTON:
	    CheckRadioButton( hwnd, IDC_JOY2BUTTON, IDC_JOY4BUTTON, id );
	    pcv->bHas2Buttons = (id == IDC_JOY2BUTTON);
	    break;
	case IDC_JOYUSESPECIAL:
	    enableCustomSpecial( hwnd, IsDlgButtonChecked( hwnd, IDC_JOYUSESPECIAL ) );
	    pcv->bIsYoke = FALSE;
	    pcv->bIsGamePad = FALSE;
	    pcv->bIsCarCtrl = FALSE;
	    break;
	case IDC_JOYHASPOV:
	    pcv->bHasPOV = !pcv->bHasPOV;
	    break;
	case IDC_JOYISYOKE:
	case IDC_JOYISGAMEPAD:
	case IDC_JOYISCARCTRL:
	    pcv->bIsYoke = (id == IDC_JOYISYOKE);
	    pcv->bIsGamePad = (id == IDC_JOYISGAMEPAD);
	    pcv->bIsCarCtrl = (id == IDC_JOYISCARCTRL);
	    CheckRadioButton( hwnd, IDC_JOYISYOKE, IDC_JOYISCARCTRL, id );
	    break;
	case IDCANCEL:
	    pcv = (LPCUSTVARS) GetWindowLong( hwnd, DWL_USER );
	    DoFree( pcv );
	    EndDialog( hwnd, 0 );
	    break;
	case IDOK:
	    pcv = (LPCUSTVARS) GetWindowLong( hwnd, DWL_USER );
	    EndDialog(hwnd, (int) pcv );
	    break;
	}
	break;
    default:
	break;
    }
    return FALSE;

} /* CustomProc */


/***************************************************************************
 
 
  MAIN DIALOG FUNCTIONS FOLLOW
 
 
 ***************************************************************************/


/*
 * variables used by joystick tab dialog
 */
typedef struct {
    LPGLOBALVARS	pgv;
} JTVARS, *LPJTVARS;

/*
 * numJoyAxes - get number of axes on a joystick
 */
static int numJoyAxes( LPGLOBALVARS pgv )
{
    DWORD	flags;
    int		axis_count;

    flags = pgv->joyHWCurr.hws.dwFlags;
    axis_count = 2;
    if( flags & JOY_HWS_HASZ ) {
	axis_count++;
    }
    if( flags & JOY_HWS_HASR ) {
	axis_count++;
    }
    if( (flags & JOY_HWS_HASPOV) && (flags & JOY_HWS_POVISPOLL) ) {
	axis_count++;
    }
    return axis_count;

} /* numJoyAxes */

/*
 * saveHWSettings - save the current hardware settings
 */
static void saveHWSettings( LPGLOBALVARS pgv )
{
    pgv->joyHWOrig = pgv->joyHWCurr;

} /* saveHWSettings */

/*
 * restoreHWSettings - restore current hw settings to saved values
 */
static void restoreHWSettings( LPGLOBALVARS pgv )
{
    pgv->joyHWCurr = pgv->joyHWOrig;
    RegSaveCurrentJoyHW( pgv );

} /* restoreHWSettings */

/*
 * getActiveFlags - poll and test which joysticks are currently plugged in
 */
static unsigned getActiveFlags( LPGLOBALVARS pgv )
{
    JOYINFOEX	ji;
    MMRESULT	rc;
    unsigned	val;

    /*
     * check for presense of joystick 1 and joystick 2
     */
    val = 0;
    ji.dwSize = sizeof( ji );
    ji.dwFlags = JOY_RETURNX|JOY_RETURNY|JOY_CAL_READXYONLY|JOY_CAL_READALWAYS;
    rc = joyGetPosEx( pgv->iJoyId, &ji );
    DPF( "joyGetPosEx = %d\r\n", rc );
    if( rc == JOYERR_NOERROR ) {
	val = HASJOY;
    }

    /*
     * check if either could have a rudder attached.
     */
    ji.dwFlags = JOY_RETURNR | JOY_CAL_READRONLY;
    if( (numJoyAxes( pgv ) < 4) &&
    		!(pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASR ) ) {
	rc = joyGetPosEx( pgv->iJoyId, &ji );
	if( rc ==JOYERR_NOERROR ) {
	    val |= HASRUDDERMAYBE;
	}
    }
    return val;

} /* getActiveFlags */

/*
 * enableTestCal - enable/disable test and calibrate buttons
 */
static void enableTestCal( HWND hwnd, int hw_type )
{
    BOOL	enable;

    enable = (hw_type != JOY_HW_NONE);

    EnableWindow( GetDlgItem( hwnd, IDC_JOYCALIBRATE ), enable );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYTEST ), enable );

} /* enableTestCal */

/*
 * cleanUpJoyDlg - clean up allocated stuff
 */
static void cleanUpJoyDlg( HWND hwnd )
{
    LPGLOBALVARS	pgv;

    pgv = (LPGLOBALVARS) GetWindowLong( hwnd, DWL_USER );
    if( pgv == NULL ) {
	return;
    }

    /*
     * ditch timer
     */
    if( pgv->pjd->bHasTimer ) {
	KillTimer( hwnd, TIMER_ID );
	pgv->pjd->bHasTimer = FALSE;
    }

    /*
     * done with our variables
     */
    #if defined( WANT_SHEETS )
	DoFree( pgv );
    #endif

} /* cleanUpJoyDlg */

/*
 * enableJoyWindows - enable controls for a joystick
 */
static void  enableJoyWindows( LPGLOBALVARS pgv, HWND hwnd, BOOL enable )
{
//    EnableWindow( GetDlgItem(hwnd,IDC_JOYSELECT), enable );
//    EnableWindow( GetDlgItem(hwnd,IDC_JOYSELECTMSG), enable );
//    EnableWindow( GetDlgItem(hwnd,IDC_JOYSTICK1_FRAME), enable );
    EnableWindow( GetDlgItem(hwnd,IDC_JOYCALIBRATE), enable );
    EnableWindow( GetDlgItem(hwnd,IDC_JOYTEST), enable );

} /* enableJoyWindows */

/*
 * enableActiveJoystick - enable dialog controls based on presence of joysticks
 */
static void enableActiveJoystick( LPGLOBALVARS pgv, HWND hwnd )
{
    BOOL		allowj;
    HINSTANCE		hinst;
    char		str[MAX_STR];
    unsigned		joys;
    LPSTR		text;

    /*
     * check what joysticks are active; if it hasn't changed, just return
     */
    joys = getActiveFlags( pgv );
    if( pgv->joyActiveFlags == joys ) {
	return;
    }
    pgv->joyActiveFlags = joys;

    /*
     * turn off the rudder if it is gone
     */
    if( !(joys & HASRUDDERMAYBE) ) {
	pgv->joyHWCurr.dwUsageSettings &= ~JOY_US_HASRUDDER;
	CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, FALSE );
    }

    /*
     * enable the appropriate windows
     */
    allowj = ((joys & HASJOY) != 0);
    enableJoyWindows( pgv, hwnd, allowj );
    EnableWindow( GetDlgItem( hwnd, IDC_JOY1HASRUDDER ), allowj && (joys & HASRUDDERMAYBE) );

    /*
     * set message for the user if there is no joystick plugged in, or if
     * there is no joystick driver present
     */
    if( allowj ) {
	text = "";
    } else {
	str[0] = 0;
	text = str;
	hinst = GetWindowInstance( hwnd );
	if( joyGetNumDevs() ) {
	    LoadString( hinst , IDS_JOYUNPLUGGED, str, sizeof( str ) );
	} else {
	    LoadString( hinst , IDS_JOYNOTPRESENT, str, sizeof( str ) );
	}
    }
    SetWindowText( GetDlgItem( hwnd, IDC_JOYMSG ), text );

    if( allowj ) {
	enableTestCal( hwnd, pgv->joyHWCurr.dwType );
    }

    if( allowj ) {
	pgv->joyHWCurr.dwUsageSettings |= JOY_US_PRESENT;
    } else {
	pgv->joyHWCurr.dwUsageSettings &= ~JOY_US_PRESENT;
    }

    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

} /* enableActiveJoystick */

/*
 * getNewJoyInfo - get information from the registry about a new joystick.
 *		   If no info, default to joyHWDefault settings
 */
static void getNewJoyInfo( LPGLOBALVARS pgv, HWND hwnd )
{
    UINT                index;
    DWORD		hw_type;
    HKEY		hkey;
    char		str[MAX_STR];
    char		jcfg[MAX_STR];
    DWORD		regtype;
    JOYREGHWCONFIG	config;
    DWORD		cb;
    BOOL		same;
    int			rc;

    GETKEYNAME( pgv, jcfg, REGSTR_VAL_JOYNCONFIG );

    /*
     * get the hardware type
     */
    index = SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_GETCURSEL, 0, 0L );
    hw_type = SendDlgItemMessage( hwnd,IDC_JOYSELECT,CB_GETITEMDATA,index,0L );
    same = (hw_type == pgv->joyHWCurr.dwType);

    /*
     * read the info from the registry if a new hardware type selected
     */
    if( !same ) {
	pgv->joyHWCurr = pgv->pjd->joyHWDefaults[ hw_type ];
	createSettingsKeyFromCurr( pgv, str );
	if( !RegOpenKey( HKEY_LOCAL_MACHINE, str, &hkey ) ) {
	    cb = sizeof( pgv->joyHWCurr );
	    if( !RegQueryValueEx( hkey, jcfg, NULL, &regtype,
			    (CONST LPBYTE)&config, &cb) ) {
		if( regtype == REG_BINARY && cb == sizeof( config ) ) {
		    pgv->joyHWCurr.hws = config.hws;
		    pgv->joyHWCurr.hwv = config.hwv;
		    pgv->joyHWCurr.dwUsageSettings = config.dwUsageSettings;
		}
	    }
	    RegCloseKey( hkey );
	}

	/*
	 * set up the rudder bit
	 */
	if( pgv->joyHWCurr.dwUsageSettings & JOY_US_HASRUDDER ) {
	    CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, TRUE );
	} else {
	    if( IsDlgButtonChecked( hwnd, IDC_JOY1HASRUDDER ) ) {
		pgv->joyHWCurr.dwUsageSettings |= JOY_US_HASRUDDER;
	    } else {
		pgv->joyHWCurr.dwUsageSettings &= ~JOY_US_HASRUDDER;
	    }
	}
    }

    /*
     * disable test/calibrate buttons based on hardware picked
     */
    enableTestCal( hwnd, hw_type );

    /*
     * if custom selected, go get the data from the user
     */
    if( hw_type == JOY_HW_CUSTOM ) {
    	rc = DialogBoxParam((HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE),
		    MAKEINTRESOURCE(IDD_JOYCUSTOM), hwnd,
		    CustomProc, (LONG) pgv );
	if( rc ) {
	    LPCUSTVARS	pcv;

	    pcv = (LPCUSTVARS) rc;
	    pgv->joyHWCurr.dwUsageSettings |= JOY_US_PRESENT;
	    pgv->joyHWCurr.hws.dwFlags &= ~(JOY_HWS_HASR|JOY_HWS_HASZ|
			JOY_HWS_HASU| JOY_HWS_HASV|
	    		JOY_HWS_HASPOV|JOY_HWS_ISYOKE| JOY_HWS_ISGAMEPAD|
			JOY_HWS_ISCARCTRL| JOY_HWS_POVISPOLL|
			JOY_HWS_POVISBUTTONCOMBOS );
	    /*
	     * NOTE: for a custom joystick, we always assume that Z is
	     * implemented on J2 Y.
	     */
	    if( pcv->bHasZ ) {
		pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_HASZ;
	    }
	    /*
	     * NOTE: for a custom joystick, we always assume that R is
	     * implemented on J2 X.
	     */
	    if( pcv->bHasR ) {
		pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_HASR;
	    }
	    if( pcv->bHasPOV ) {
		pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_HASPOV;
	    }
	    if( pcv->bIsYoke ) {
		pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_ISYOKE;
	    }
	    if( pcv->bIsGamePad ) {
		pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_ISGAMEPAD;
	    }
	    if( pcv->bIsCarCtrl ) {
		pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_ISCARCTRL;
	    }
	    if( pcv->bHas2Buttons ) {
		pgv->joyHWCurr.hws.dwNumButtons = 2;
	    } else {
		pgv->joyHWCurr.hws.dwNumButtons = 4;
	    }
	    DoFree( pcv );
	    same = FALSE;
	}
    }

    /*
     * update the registry with the new current joystick
     */
    if( !same ) {
	RegSaveCurrentJoyHW( pgv );
	RegistryUpdated( pgv );
	PropSheet_Changed( GetParent(hwnd), hwnd );
	pgv->joyActiveFlags = (unsigned) -1;
	enableActiveJoystick( pgv, hwnd );
    }

} /* getNewJoyInfo */

/*
 * initCurrentHW - set up the current hardware for the first  time
 */
static void initCurrentHW( LPGLOBALVARS pgv )
{
    regGetCurrHW( pgv );
    pgv->joyActiveFlags = (unsigned) -1;
    saveHWSettings( pgv );

} /* initCurrentHW */

/*
 * newJoyId - set up for a new joystick id
 */
static LPGLOBALVARS newJoyId( LPGLOBALVARS pgv, HWND hwnd, int joyid )
{
    UINT  index;
    UINT  indexMax;

    if( joyid == pgv->iJoyId ) {
	return pgv;
    }
    #if !defined( WANT_SHEETS )
    	pgv = &pgv->pjd->pgvlist[ joyid ];
    #endif
    pgv->iJoyId = joyid;

    /*
     * save the pointer to the variables
     */
    SetWindowLong( hwnd, DWL_USER, (LONG) pgv );

    #if defined( WANT_SHEETS )
	/*
	 * set up current joystick hardware
	 */
	initCurrentHW( pgv );
    #endif

    /*
     * set up windows
     */
    pgv->joyActiveFlags = (unsigned) -1;
    enableActiveJoystick( pgv, hwnd );
    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_HASRUDDER ) {
	CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, TRUE );
    } else {
	CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, FALSE );
    }

    /*
     * select the current info
     */
   indexMax = SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_GETCOUNT, 0, 0 );

   for (index = 0; index < indexMax; index++)
   {
       DWORD type;
       type = SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_GETITEMDATA,
                                  index, 0 );
       if (type == pgv->joyHWCurr.dwType)
           break;
   }

   if (index == indexMax)
      index = 1;	// custom

   SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_SETCURSEL, index, 0L );
    #if !defined( WANT_SHEETS )
	SendDlgItemMessage( hwnd, IDC_JOYCURRENTID, CB_SETCURSEL, pgv->iJoyId, 0L );
    #endif
    return pgv;


} /* newJoyId */

/*
 * showResetInfo
 */
static void showResetInfo( HWND hwnd, BOOL show )
{
    EnableWindow( GetDlgItem( hwnd, IDC_JOYTROUBLESHOOT_FRAME ), show );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYTROUBLESHOOT_TEXT ), show );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYRESET ), show );

} /* showResetInfo */

/*
 * doJoyDlgInitDialog - process initialization for joystick tabbed dialog
 */
static BOOL doJoyDlgInitDialog( HWND hwnd, LPARAM lParam )
{
    HINSTANCE		hinst;
    LPPROPSHEETPAGE	ppsp;
    int			i;
    char		str[MAX_STR];
    LPGLOBALVARS	pgv;
    LPJOYDATA		pjd;
    LPJOYDATAPTR	pjdp;
    HKEY		hkey;

    /*
     * pointer to data
     */
    ppsp = (LPPROPSHEETPAGE) lParam;
    pjdp = (LPJOYDATAPTR) ppsp->lParam;
    pjd = pjdp->pjd;

    /*
     * create global variables.   These will be used by all dialogs
     */
    #if defined( WANT_SHEETS )
	pgv = DoAlloc( sizeof( GLOBALVARS ) );
	if( pgv == NULL ) {
	    return FALSE;
	}

	/*
	 * get joystick id that this sheet is for
	 */
	pgv->iJoyId = pjdp->iJoyId;
	pgv->pjd = pjd;
	DPF( "Tab for joystick %d started\r\n", pgv->iJoyId );
    #else
    	pgv = &pjd->pgvlist[ pjdp->iJoyId ];
    #endif

    /*
     * get device caps
     */
    getDevCaps( pgv );

    /*
     * how many predefined joystick types should we display?
     */
    pgv->cJoystickTypes = 2;	// display None and Custom only
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYSTICK, &hkey ) ) {
	DWORD type;
	DWORD val = 0;
	DWORD cb = sizeof(val);
        if( !RegQueryValueEx( hkey, REGSTR_VAL_JOYTYPES, NULL,
            &type, (CONST LPBYTE)&val, &cb) ) {
	    pgv->cJoystickTypes += val;
	}
        RegCloseKey( hkey );
    }
    pgv->cJoystickTypes = max( pgv->cJoystickTypes,  2 ); // Must have none/cust
    pgv->cJoystickTypes = min( pgv->cJoystickTypes, 12 );

    /*
     * callback timer for checking if joysticks are plugged/unplugged
     */
     if( !pjd->bHasTimer ) {
	pjd->bHasTimer = SetTimer( hwnd, TIMER_ID, JOYCHECKTIME, NULL );
	pjd->bUseTimer = TRUE;
     }

    /*
     * set up pre-defined joystick list
     */
    hinst = GetWindowInstance( hwnd );
    for( i=IDS_JOYHW0; i<(IDS_JOYHW0 + pgv->cJoystickTypes); i++ ) {
	if( LoadString( hinst , i, str, sizeof( str ) ) ) {
	    UINT dwItem;
	    dwItem = SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_ADDSTRING, 0,
				(LONG) (LPSTR) str );
	    SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_SETITEMDATA, dwItem,
				i -IDS_JOYHW0 + JOY_HW_NONE );
	}
    }

    /*
     * set up OEM joystick list
     */
    for( i=0;i<pjd->oemCount;i++ ) {
	UINT dwItem;
	dwItem = SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_ADDSTRING, 0,
			    (LONG) (LPSTR) pjd->oemList[i].ident_string );
	SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_SETITEMDATA,
			     dwItem, i +JOY_HW_LASTENTRY);
    }

    /*
     * set up joystick choices list
     */
    #if !defined(WANT_SHEETS)
    {
	int	numdevs;
	char	strid[MAX_STR];
	if( LoadString( hinst, IDS_JOY, str, sizeof( str ) ) ) {
	    numdevs = joyGetNumDevs();
	    for( i=0;i<numdevs;i++ ) {
		wsprintf( strid, "%s %d", str, i+1 );
		SendDlgItemMessage( hwnd, IDC_JOYCURRENTID, CB_ADDSTRING, 0,
				    (LONG) (LPSTR) strid );
	    }
	}
    }
    #endif

    pgv->iJoyId = -1;
    newJoyId( pgv, hwnd, pjdp->iJoyId );

    /*
     * enable/disable our Reset button
     */
    showResetInfo( hwnd, pjd->bHasNonStandardUserVals );

    return TRUE;

} /* doJoyDlgInitDialog */

/*
 * doJoyDlgCommand - process WM_COMMAND message for main joystick tabbed dialog
 */
static void doJoyDlgCommand( HWND hwnd, int id, HWND hctl, UINT code )
{
    LPGLOBALVARS	pgv;

    pgv = (LPGLOBALVARS) GetWindowLong( hwnd, DWL_USER );

    switch( id ) {
    /*
     * new joystick has been picked
     */
    case IDC_JOYSELECT:
    	if( code == CBN_SELCHANGE ) {
	    getNewJoyInfo( pgv, hwnd );
	}
	break;

    #if !defined( WANT_SHEET )
    /*
     * new joystick id has been picked
     */
    case IDC_JOYCURRENTID:
    	if( code == CBN_SELCHANGE ) {
	    int	joyid;
	    joyid = SendDlgItemMessage( hwnd, IDC_JOYCURRENTID, CB_GETCURSEL, 0, 0L );
	    pgv = newJoyId( pgv, hwnd, joyid );
	    regSetUserVals( pgv->pjd, TRUE );
	    RegSaveCurrentJoyHW( pgv );
	    RegistryUpdated( pgv );
	}
	break;
    #endif

    /*
     * calibrate current joystick
     */
    case IDC_JOYCALIBRATE:
	pgv->pjd->bUseTimer = FALSE;
	DoCalibrate( pgv, hwnd );
	pgv->pjd->bUseTimer = TRUE;
	break;

    /*
     * test either joystick 1 or joystick 2
     */
    case IDC_JOYTEST:
	pgv->pjd->bUseTimer = FALSE;
	DoTest( pgv, hwnd, NULL, pgv );
	pgv->pjd->bUseTimer = TRUE;
	break;

    /*
     * reset to user values
     */
    case IDC_JOYRESET:
    	pgv->pjd->bResetUserVals = TRUE;
	PropSheet_Changed( GetParent(hwnd), hwnd );
    	break;

    /*
     * rudder selected/unselected
     */
    case IDC_JOY1HASRUDDER:
    {
	LPJOYREGHWCONFIG 	pcfg;
	/*
	 * rudder status changed, force recalibration (leave POV alone if
	 * it was button based)
	 */
	pcfg = &pgv->joyHWCurr;

	if( (pcfg->hws.dwFlags & JOY_HWS_HASPOV) &&
			(pcfg->hws.dwFlags & JOY_HWS_POVISBUTTONCOMBOS) ) {
	    pcfg->hwv.dwCalFlags &= JOY_ISCAL_POV;
	} else {
	    pcfg->hwv.dwCalFlags = 0;
	}

	if( IsDlgButtonChecked( hwnd, id ) ) {
	    pcfg->dwUsageSettings |= JOY_US_HASRUDDER;
	} else {
	    pcfg->dwUsageSettings &= ~JOY_US_HASRUDDER;
	}
	pgv->joyActiveFlags = (unsigned) -1;
	enableActiveJoystick( pgv, hwnd );
	PropSheet_Changed( GetParent(hwnd), hwnd );
	break;
    }
	
    case ID_APPLY:
    {
    	DPF( "ID_APPLY\r\n" );

	#if !defined( WANT_SHEETS )
	{
	    int	i;
	    int	numjoys;

	    numjoys = joyGetNumDevs();
	    for( i=0;i<numjoys;i++ ) {
		regPermSaveAllInfo( &pgv->pjd->pgvlist[i] );
		saveHWSettings( &pgv->pjd->pgvlist[i] );
	    }
	}
	#else
	    regPermSaveAllInfo( pgv );
	    saveHWSettings( pgv );
	#endif
    	if( pgv->pjd->bResetUserVals ) {
	    regUserValsFini( pgv->pjd );
	    regUserValsInit( pgv->pjd );
	    pgv->pjd->bResetUserVals = FALSE;
	}
	showResetInfo( hwnd, pgv->pjd->bHasNonStandardUserVals );
	break;
    }
    case ID_INIT:
    	DPF( "ID_INIT\r\n" );
    	/*
	 * we've been re-activated, reset the current joystick settings
	 */
	regSetUserVals( pgv->pjd, TRUE );
	RegSaveCurrentJoyHW( pgv );
	RegistryUpdated( pgv );
	break;
    case IDOK:
    	DPF( "IDOK\r\n" );
	EndDialog(hwnd, TRUE );
	break;
    case IDCANCEL:
    	DPF( "IDCANCEL\r\n" );
    	pgv->pjd->bResetUserVals = FALSE;
	#if !defined( WANT_SHEETS )
	{
	    int	i;
	    int	numjoys;

	    numjoys = joyGetNumDevs();
	    for( i=0;i<numjoys;i++ ) {
		restoreHWSettings( &pgv->pjd->pgvlist[i] );
	    }
	}
	#else
	    restoreHWSettings( pgv );
	#endif
	RegistryUpdated( pgv );
	EndDialog(hwnd, FALSE );
	break;
	
    default:
	break;
    }

} /* doJoyDlgCommand */

/*
 * context help for the main dialog
 */
    const static DWORD aJoystickHelpIDs[] = {  // Context Help IDs
        IDC_JOYCURRENTIDMSG,        IDH_JOYSTICK_CURRENT,
        IDC_JOYCURRENTID,           IDH_JOYSTICK_CURRENT,
        IDC_JOYSELECTMSG,           IDH_JOYSTICK_SELECT,
        IDC_JOYSELECT,              IDH_JOYSTICK_SELECT,
        IDC_JOY1HASRUDDER,          IDH_JOYSTICK_RUDDER,
        IDC_JOYCALIBRATE,           IDH_JOYSTICK_CALIBRATE,
        IDC_JOYTEST,                IDH_JOYSTICK_TEST,
        IDC_JOYSTICK1_FRAME,        IDH_JOYSTICK_GROUPBOX,
        IDC_JOYMSG,                 NO_HELP,
        IDC_ICON_1,                 NO_HELP,
        IDC_ICON_2,                 NO_HELP,
        IDC_JOYTROUBLESHOOT_FRAME,  IDH_JOYSTICK_RESET,
        IDC_JOYRESET,               IDH_JOYSTICK_RESET,
        IDC_JOYTROUBLESHOOT_TEXT,   NO_HELP,

        0, 0
    };

/*
 * JoystickDlg - dialog procedure for joystick tabbed dialog
 */
BOOL CALLBACK JoystickDlg( HWND	hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    BOOL	rc;

    switch( umsg ) {
    case WM_INITDIALOG:
	rc = doJoyDlgInitDialog( hwnd, lParam );
	if( !rc ) {
	    EndDialog( hwnd, 0 );
	}
	return FALSE;
	
    case WM_COMMAND:
	HANDLE_WM_COMMAND( hwnd, wParam, lParam, doJoyDlgCommand );
	break;

    case WM_ACTIVATE:
    	/*
	 * we've been activated, pretend we were re-selected
	 */
    	if( LOWORD( wParam ) != WA_INACTIVE ) {
	    FORWARD_WM_COMMAND( hwnd, ID_INIT, 0, 0, SendMessage );
	}
	break;

    case WM_DESTROY:
	cleanUpJoyDlg( hwnd );
	break;

    case WM_TIMER:
    {
	LPGLOBALVARS	pgv;
    	pgv = (LPGLOBALVARS) GetWindowLong( hwnd, DWL_USER );
    	if( pgv->pjd->bUseTimer ) {
	    pgv->pjd->bUseTimer = FALSE;
	    enableActiveJoystick( pgv, hwnd );
	    pgv->pjd->bUseTimer = TRUE;
	}
	break;
    }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, cszHelpFile,
            HELP_WM_HELP, (DWORD)(LPSTR) aJoystickHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, cszHelpFile, HELP_CONTEXTMENU,
            (DWORD)(LPVOID) aJoystickHelpIDs);
        return TRUE;

    case WM_NOTIFY:
    {
	NMHDR FAR * lpnm = (NMHDR FAR *)lParam;
	switch(lpnm->code) {
	case PSN_KILLACTIVE:
	    FORWARD_WM_COMMAND( hwnd, IDOK, 0, 0, SendMessage );
	    return TRUE;		    

	case PSN_APPLY:
	    FORWARD_WM_COMMAND( hwnd, ID_APPLY, 0, 0, SendMessage );
	    return TRUE;

	case PSN_SETACTIVE:
	    FORWARD_WM_COMMAND( hwnd, ID_INIT, 0, 0, SendMessage );
	    return TRUE;
	    
	case PSN_RESET:
	    FORWARD_WM_COMMAND( hwnd, IDCANCEL, 0, 0, SendMessage );
	    return  TRUE;
	}
	break;
    }
    default:
	break;
    }
    return FALSE;

} /* JoystickDlg */


/***************************************************************************
 
 
  GLOBAL JOYSTICK DATA FUNCTIONS FOLLOW
 
 
 ***************************************************************************/

/*
 * default joysticks
 */
#define TYPE00	0
#define TYPE01	0
#define TYPE02	0
#define TYPE03	0
#define TYPE04	JOY_HWS_ISGAMEPAD
#define TYPE05	JOY_HWS_ISYOKE
#define TYPE06	JOY_HWS_HASZ | JOY_HWS_ISYOKE
#define TYPE07	JOY_HWS_HASZ
#define TYPE08	JOY_HWS_HASZ
#define TYPE09	JOY_HWS_ISGAMEPAD
#define TYPE10	JOY_HWS_ISYOKE
#define TYPE11	JOY_HWS_HASZ | JOY_HWS_ISYOKE

static JOYREGHWCONFIG _joyHWDefaults[] =
{
    { {TYPE00,0},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_NONE},
    { {TYPE01,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_CUSTOM},
    { {TYPE02,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2A_2B_GENERIC},
    { {TYPE03,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2A_4B_GENERIC},
    { {TYPE04,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2B_GAMEPAD},
    { {TYPE05,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2B_FLIGHTYOKE},
    { {TYPE06,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2B_FLIGHTYOKETHROTTLE},
    { {TYPE07,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_3A_2B_GENERIC},
    { {TYPE08,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_3A_4B_GENERIC},
    { {TYPE09,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_4B_GAMEPAD},
    { {TYPE10,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_4B_FLIGHTYOKE},
    { {TYPE11,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_4B_FLIGHTYOKETHROTTLE},
};

/*
 * registry strings for calibration messages
 */
static LPSTR _oemCalRegStrs[] =
{
    REGSTR_VAL_JOYOEMCAL1,
    REGSTR_VAL_JOYOEMCAL2,
    REGSTR_VAL_JOYOEMCAL3,
    REGSTR_VAL_JOYOEMCAL4,
    REGSTR_VAL_JOYOEMCAL5,
    REGSTR_VAL_JOYOEMCAL6,
    REGSTR_VAL_JOYOEMCAL7,
    REGSTR_VAL_JOYOEMCAL8,
    REGSTR_VAL_JOYOEMCAL9,
    REGSTR_VAL_JOYOEMCAL10,
    REGSTR_VAL_JOYOEMCAL11,
    REGSTR_VAL_JOYOEMCAL12,
};

/*
 * base registry keys
 */
static char	szCfgKey[] = REGSTR_PATH_JOYCONFIG;
static char	szCurrCfgKey[] = REGSTR_KEY_JOYCURR;
static char	szSettingsCfgKey[] = REGSTR_KEY_JOYSETTINGS;


/*
 * freeOEMListItem - free a list of oem data
 */
static void freeOEMListItem( LPJOYDATA pjd, int i )
{
    int	j;

    DoFree( pjd->oemList[i].keyname );
    DoFree( pjd->oemList[i].ident_string );
    DoFree( pjd->oemList[i].vxd_name );
    DoFree( pjd->oemList[i].xy_label );
    DoFree( pjd->oemList[i].z_label );
    DoFree( pjd->oemList[i].r_label );
    DoFree( pjd->oemList[i].u_label );
    DoFree( pjd->oemList[i].v_label );
    DoFree( pjd->oemList[i].pov_label );
    DoFree( pjd->oemList[i].testmove_desc );
    DoFree( pjd->oemList[i].testbutton_desc );
    DoFree( pjd->oemList[i].testmove_cap );
    DoFree( pjd->oemList[i].testbutton_cap );
    DoFree( pjd->oemList[i].testwin_cap );
    DoFree( pjd->oemList[i].cal_cap );
    DoFree( pjd->oemList[i].calwin_cap );
    for( j=0;j<NUM_CAL_STRS;j++ ) {
	DoFree( pjd->oemList[i].cal_strs[j] );
    }

} /* freeOEMListItem */

/*
 * initHWDefaults - initialize the hardware list: use defaults + OEM types
 * 		    defined in the registry
 */
static void initHWDefaults( LPJOYDATA pjd )
{
    int			list_size;
    int			def_size;
    DWORD		isubkey;
    DWORD		keyidx;
    HKEY		hkey;
    HKEY		hsubkey;
    char		str[MAX_STR];
    DWORD		clsize;
    DWORD		num_subkeys;
    DWORD		dont_care;
    DWORD		longest_key;
    FILETIME		ftime;
    LPSTR		keyname;
    JOYREGHWSETTINGS	hws;
    DWORD		longest_val;
    DWORD		type;
    DWORD		cb;
    int			i;
    int			j;
    int			ctype;
    LPSTR		tmpstr;
    int			fail;

    def_size = sizeof( _joyHWDefaults )/sizeof( _joyHWDefaults[0] );
    list_size = def_size;
    pjd->oemCount = 0;
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYOEM, &hkey ) ) {
	clsize = sizeof( str );
	if( !RegQueryInfoKey ( hkey, str, &clsize, NULL, &num_subkeys,
		    &longest_key, &dont_care, &dont_care, &dont_care,
		    &dont_care,	// address of buffer for longest value data length
		    &dont_care, &ftime ) ) {
	    pjd->oemList = DoAlloc( num_subkeys * sizeof( OEMLIST ));
	    if( pjd->oemList != NULL ) {
		pjd->oemCount = num_subkeys;
		list_size += num_subkeys;
	    }
	    longest_key++;
	}
    }

    pjd->joyHWDefaults = DoAlloc( list_size * sizeof( JOYREGHWCONFIG ) );
    if( pjd->joyHWDefaults == NULL ) {
	pjd->joyHWDefaults = _joyHWDefaults;
    } else {
	memcpy( pjd->joyHWDefaults, _joyHWDefaults, def_size * sizeof( JOYREGHWCONFIG ) );
	/*
	 * if we have keys in the registry, go fetch them
	 */
	if( list_size > def_size ) {
	    isubkey = 0;
	    keyidx = 0;
	    keyname = DoAlloc( longest_key );
	    if( keyname == NULL ) {
		keyname = str;
		longest_key = sizeof( str );
	    }
	    /*
	     * run through all keys, getting the info on them
	     */
	    while( !RegEnumKey( hkey, keyidx, keyname, longest_key ) ) {
		if( !RegOpenKey( hkey, keyname, &hsubkey ) ) {
		    if( !RegQueryInfoKey ( hsubkey, str, &clsize, NULL,
				&dont_care, &dont_care, &dont_care, &dont_care,
				&dont_care, &longest_val, &dont_care, &ftime ) ) {
		    	pjd->oemList[isubkey].keyname = DoAlloc( strlen( keyname ) +1 );
			tmpstr = DoAlloc( longest_val+1 );
			if( pjd->oemList[isubkey].keyname != NULL && tmpstr != NULL ) {
			    strcpy( pjd->oemList[isubkey].keyname, keyname );
			    cb = sizeof( hws );
			    if( !RegQueryValueEx( hsubkey, REGSTR_VAL_JOYOEMDATA, NULL,
					&type, (CONST LPBYTE)&hws, &cb) ) {
				if( type == REG_BINARY && cb == sizeof( hws ) ) {
				    pjd->oemList[isubkey].hws = hws;
				}
			    }
			    fail = 0;
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMCALLOUT,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].vxd_name );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMNAME,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].ident_string );
			    for( j=0;j<NUM_CAL_STRS;j++ ) {
				fail |= regGetOEMStr( hsubkey, _oemCalRegStrs[j],
					    tmpstr, longest_val,
					    &pjd->oemList[isubkey].cal_strs[j] );
			    }
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMXYLABEL,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].xy_label );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMZLABEL,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].z_label );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMRLABEL,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].r_label );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMULABEL,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].u_label );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMVLABEL,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].v_label );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMPOVLABEL,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].pov_label );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTMOVEDESC,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].testmove_desc );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTBUTTONDESC,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].testbutton_desc );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTMOVECAP,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].testmove_cap );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTBUTTONCAP,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].testbutton_cap );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTWINCAP,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].testwin_cap );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMCALCAP,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].cal_cap );
			    fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMCALWINCAP,
			    		tmpstr, longest_val,
					&pjd->oemList[isubkey].calwin_cap );
			    if( fail ) {
				freeOEMListItem( pjd, isubkey );
			    } else {
				isubkey++;
			    }
			} else {
			    DoFree( pjd->oemList[isubkey].keyname );
			}
			DoFree( tmpstr );
			RegCloseKey( hsubkey );
		    }
		}
		keyidx++;
	    }
	    pjd->oemCount = isubkey;

	    /*
	     * sort the list, and then fill in the joyHWDefault array
	     */
	    if( pjd->oemCount > 0 ) {
		for( i=0;i<pjd->oemCount;i++ ) {
		    for( j=i;j<pjd->oemCount;j++ ) {
			OEMLIST	ol;
			if( strcmp( pjd->oemList[i].ident_string,
				pjd->oemList[j].ident_string ) > 0 ) {
			    ol = pjd->oemList[i];
			    pjd->oemList[i] = pjd->oemList[j];
			    pjd->oemList[j] = ol;
			}
		    }
		}
		for( i=0;i<pjd->oemCount;i++ ) {
		    ctype = i+JOY_HW_LASTENTRY;
		    memset( &pjd->joyHWDefaults[ctype], 0,
		    			sizeof( pjd->joyHWDefaults[ctype] ) );
		    pjd->joyHWDefaults[ctype].hws = pjd->oemList[i].hws;
		    pjd->joyHWDefaults[ctype].dwUsageSettings = JOY_US_ISOEM|JOY_US_PRESENT;
		    pjd->joyHWDefaults[ctype].dwType = ctype;
		}
	    }
	    if( keyname != str ) {
		DoFree( keyname );
	    }
	}
    }

} /* initHWDefaults */

/*
 * finiHWList - finished with the hardware list, free it
 */
static void finiHWList( LPJOYDATA pjd )
{
    int	i;

    if( pjd->joyHWDefaults != NULL ) {
	if( pjd->joyHWDefaults != _joyHWDefaults ) {
	    DoFree( pjd->joyHWDefaults );
	}
	pjd->joyHWDefaults = NULL;
    }
    if( pjd->oemList != NULL ) {
	for( i=0;i<pjd->oemCount;i++ ) {
	    freeOEMListItem( pjd, i );
	}
	DoFree( pjd->oemList );
	pjd->oemList = NULL;
	pjd->oemCount = 0;
    }

} /* finiHWList */

/*
 * getRegKeys - get the registry keys we need
 */
static void getRegKeys( LPJOYDATA pjd )
{
    int		len;
    JOYCAPS jc;

    if (joyGetDevCaps (0, &jc, sizeof(jc)) != JOYERR_NOERROR)
       lstrcpy (jc.szRegKey, TEXT("joystick.dll<0000>"));

    /*
     * set up registry keys
     */
    pjd->regCfgKey = NULL;
    pjd->regCurrCfgKey = NULL;
    pjd->regSettingsCfgKey = NULL;

    len = sizeof( szCfgKey );
    pjd->regCfgKey = DoAlloc( len );
    if( pjd->regCfgKey != NULL ) {
	strcpy( pjd->regCfgKey, szCfgKey );
	pjd->regCurrCfgKey = DoAlloc( len +1 +1 +lstrlen(jc.szRegKey) +sizeof( szCurrCfgKey ) );
	if( pjd->regCurrCfgKey != NULL ) {
	    strcpy( pjd->regCurrCfgKey, pjd->regCfgKey );
	    strcat( pjd->regCurrCfgKey, "\\" );
	    strcat( pjd->regCurrCfgKey, jc.szRegKey );
	    strcat( pjd->regCurrCfgKey, "\\" );
	    strcat( pjd->regCurrCfgKey, szCurrCfgKey );
	}
	pjd->regSettingsCfgKey = DoAlloc( len +1 +1 +lstrlen(jc.szRegKey) +sizeof( szSettingsCfgKey ) );
	if( pjd->regSettingsCfgKey != NULL ) {
	    strcpy( pjd->regSettingsCfgKey, pjd->regCfgKey );
	    strcat( pjd->regSettingsCfgKey, "\\" );
	    strcat( pjd->regSettingsCfgKey, jc.szRegKey );
	    strcat( pjd->regSettingsCfgKey, "\\" );
	    strcat( pjd->regSettingsCfgKey, szSettingsCfgKey );
	}
    }

} /* getRegKeys */

/*
 * JoystickDataInit
 */
LPJOYDATA JoystickDataInit( void )
{
    LPJOYDATA	pjd;

    pjd = DoAlloc( sizeof( JOYDATA ) );
    if( pjd == NULL ) {
	return NULL;
    }

    /*
     * go set up all our defaults + oem lists
     */
    initHWDefaults( pjd );

    /*
     * get registry keys used by everyone
     */
    getRegKeys( pjd );

    /*
     * brushes for use by button display and bar display (z & r info)
     */
    pjd->hbUp = CreateSolidBrush( ACTIVE_COLOR );
    pjd->hbDown = CreateSolidBrush( INACTIVE_COLOR );

    /*
     * set up user values we like
     */
    regUserValsInit( pjd );


    #if !defined( WANT_SHEETS )
    {
	/*
	 * set up array of "global" vars (global to a joystick id)
	 */

	int		numjoys;
	int		i;

	numjoys = joyGetNumDevs();
	if( numjoys == 0 ) {
	    return NULL;
	}
    
	pjd->pgvlist = DoAlloc( sizeof( GLOBALVARS ) * numjoys );
	if( pjd->pgvlist == NULL ) {
	    return NULL;
	}
	for( i=0;i<numjoys;i++ ) {
	    pjd->pgvlist[i].iJoyId = i;
	    pjd->pgvlist[i].pjd = pjd;
	    initCurrentHW( &pjd->pgvlist[i] );
	}
    }
    #endif
    return pjd;

} /* JoystickDataInit */

/*
 * JoystickDataFini - finished with DLL wide joystick data data
 */
void JoystickDataFini( LPJOYDATA pjd )
{
    /*
     * ditch brushes
     */
    if( pjd->hbUp != NULL ) {
	DeleteObject( pjd->hbUp );
    }
    if( pjd->hbDown != NULL ) {
	DeleteObject( pjd->hbDown );
    }

    /*
     * done with hardware list
     */
    finiHWList( pjd );

    /*
     * restore user values in registry
     */
    regUserValsFini( pjd );

    /*
     * done with registry keys
     */
    DoFree( pjd->regCfgKey );
    DoFree( pjd->regCurrCfgKey );
    DoFree( pjd->regSettingsCfgKey );

    #if !defined( WANT_SHEETS )
    	DoFree( pjd->pgvlist );
    #endif

    /*
     * free up the joystick data
     */
    DoFree( pjd );
    #ifdef DEBUG
	if( allocCount != 0 ) {
	    MBOX( "Memory left unfreed: %d allocations", allocCount );
	}
    #endif

} /* JoystickDataFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\drivers\sulib.h ===
/*
 * SULIB.H - Windows/DOS Setup common code
 *
 *  Modification History:
 *
 *
 *  3/23/89  Toddla   combined common.h and prototypes into this file
 *  1/28/91  MichaelE Added AUDIO_CARDS_SECT for different audio card choices.
 *  4/17/91  Removed some DOS.ASM routines not used anywhere.
 *  5/29/91  JKLin added prototype for IsCDROMDrive function
 *
 */

#define FALLOC(n)                ((VOID *)GlobalAlloc(GPTR, n))
#define FFREE(n)                 GlobalFree(n)

#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR,n)
#define FREE(p)                  LocalFree(p)
#define REALLOC(p,n)             LocalRealloc(p,n,LMEM_MOVEABLE)


/* flags for _llseek */

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define MAXFILESPECLEN       MAX_PATH /* drive: + path length max + Null Byte */
#define MAX_INF_LINE_LEN     256      /* Maximum length of any .inf line */
#define MAX_SYS_INF_LEN      256      /* ##: + 8.3 + NULL */
#define MAX_SECT_NAME_LEN    40       /* Max length of a section Name. */
#define MAX_FILE_SPEC        MAX_PATH // 8.3 + X: + NULL.

#define DISK_SECT              "disks"
#define OEMDISK_SECT           "oemdisks"



/* Return codes from 'file exists' dialog */

enum {
    CopyNeither,            // User wants to cancel if file exists
    CopyCurrent,            // User wants to use current file
    CopyNew                 // User wants to copy new file
};

#define SLASH(c)     ((c) == '/' || (c) == '\\')
#define CHSEPSTR                "\\"
#define COMMA   ','
#define SPACE   ' '

/* Globals and routines for .inf file parsing */

typedef LPSTR    PINF;

extern PINF infOpen(LPSTR szInf);
extern void infClose(PINF pinf);
extern PINF infSetDefault(PINF pinf);
extern PINF infFindSection(PINF pinf, LPSTR szSection);
extern BOOL infGetProfileString(PINF pinf, LPSTR szSection, LPSTR szItem,LPSTR szBuf);
extern BOOL infParseField(PINF szData, int n, LPSTR szBuf);
extern PINF infNextLine(PINF pinf);
extern int  infLineCount(PINF pinf);
extern BOOL infLookup(LPSTR szInf, LPSTR szBuf);
extern PINF FindInstallableDriversSection(PINF pinf);

/* Message types for FileCopy callback function */

typedef BOOL (*FPFNCOPY) (int,DWORD,LPSTR);
#define COPY_ERROR          0x0001
#define COPY_INSERTDISK     0x0003
#define COPY_QUERYCOPY      0x0004
#define COPY_START          0x0005
#define COPY_END            0x0006
#define COPY_EXISTS         0x0007

extern UINT FileCopy (LPSTR szSource, LPSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy);

/* Option Flag values for FileCopy */

#define FC_FILE              0x0000
#define FC_LIST              0x0001
#define FC_SECTION           0x0002
#define FC_QUALIFIED         0x0008
#define FC_DEST_QUALIFIED    0x0010
#define FC_LISTTYPE          0x0020
#define FC_CALLBACK_WITH_VER 0x0040

#define FC_ABORT    0
#define FC_IGNORE   1
#define FC_RETRY    2
#define FC_ERROR_LOADED_DRIVER  0x80

/* External functions from copy.c */

extern BOOL ExpandFileName(LPSTR szFile, LPSTR szPath);
extern void catpath(LPSTR path, LPSTR sz);
extern BOOL fnFindFile(char *);
extern LPSTR FileName(LPSTR szPath);
extern LPSTR RemoveDiskId(LPSTR szPath);
extern LPSTR StripPathName(LPSTR szPath);
extern BOOL IsFileKernelDriver(LPSTR szPath);


/*******************************************************************
 *
 * Global Variables
 *
 *******************************************************************/

 // Path to the directory where we found the .inf file

 extern char szSetupPath[MAX_PATH];

 // Path to the user's disk(s)

 extern char szDiskPath[MAX_PATH];   // Path to the default drive -
                                     //
 extern BOOL bRetry;

 // Name of the driver being installed

 extern char szDrv[120];

 //

 extern char szFileError[50];

 // Parent window for file copy dialogues

 HWND hMesgBoxParent;

 // TRUE on copying first file to prompt user if file already exists
 // FALSE for subsequent copies

 extern BOOL bQueryExist;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\joyhelp.h ===
#ifndef RC_INVOKED
#ifndef NO_HELP
#define NO_HELP					((DWORD) -1) // Disables Help for a control
#endif

#define IDH_JOYSTICK_GROUPBOX			28548  // Copied from help.h

extern LPCTSTR cszHelpFile;
#endif

#define IDH_JOYSTICK_SELECT			2480
#define IDH_JOYSTICK_TEST			2481
#define IDH_JOYSTICK_CALIBRATE			2482
#define IDH_JOYSTICK_RUDDER			2483
#define IDH_JOYSTICK_TEST_POV			2484
#define IDH_JOYSTICK_TEST_RUDDER		2485
#define IDH_JOYSTICK_TEST_THROTTLE		2486
#define IDH_JOYSTICK_TEST_RANGE			2487
#define IDH_JOYSTICK_TEST_BUTTONS		2488
#define IDH_JOYSTICK_CUSTOM_AXES		2489
#define IDH_JOYSTICK_CUSTOM_BUTTONS		2490
#define IDH_JOYSTICK_CUSTOM_POV_HAT		2491
#define IDH_JOYSTICK_CUSTOM_FLIGHT_YOKE		2492
#define IDH_JOYSTICK_CUSTOM_GAME_PAD		2493
#define IDH_JOYSTICK_CUSTOM_CAR_CONTROL		2494
#define IDH_JOYSTICK_CUSTOM_CUSTOM_FEATURES	2495
#define IDH_JOYSTICK_CURRENT			2496
#define IDH_JOYSTICK_RESET			2497
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\joycal.c ===
//****************************************************************************
//
//  File:       joycal.c
//  Content:    Joystick calibration dialog
//  History:
//   Date	By	Reason
//   ====	==	======
//   11-dec-94	craige	split out of joycpl.c; some tweaks
//   15-dec-94	craige	allow N joysticks
//   17-dec-94	craige	new UI as requested by ChrisB
//   18-dec-94	craige	process UV
//   05-jan-95	craige	new centering confirmation messages
//   04-mar-95	craige	bug 10761 - separate strings for pluralization
//			bug 12036 - now works when "Back" clicked off of
//				    custom 4-axis with POV hat
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************

#include "joycpl.h"

/*
 * This has the look and feel of a wizard, but isn't   This leads to the
 * obvious...
 *
 * Q: Why isn't this a "real" wizard?
 *
 * A: - it doesn't have multiple pages, it has a single page.  the user
 *	sees different joystick items activate and de-activate on the dialog
 *	as he/she calibrates each axis. fussing with multiple sheets for each
 *	axis would be confusing and unnecessary.
 */

/*
 * calibration states
 */
typedef enum {
    JCS_INIT=-1,
    JCS_XY_CENTER1,
    JCS_XY_MOVE,
    JCS_XY_CENTER2,
    JCS_Z_MOVE,
    JCS_Z_PLACEHOLDER,
    JCS_R_MOVE,
    JCS_R_PLACEHOLDER,
    JCS_U_MOVE,
    JCS_U_PLACEHOLDER,
    JCS_V_MOVE,
    JCS_V_PLACEHOLDER,
    JCS_POV_MOVEUP,
    JCS_POV_MOVERIGHT,
    JCS_POV_MOVEDOWN,
    JCS_POV_MOVELEFT,
    JCS_FINI
} cal_states;

typedef enum {
    JC_XY=0,
    JC_Z,
    JC_POV_UP,
    JC_POV_RIGHT,
    JC_POV_DOWN,
    JC_POV_LEFT,
    JC_R,
    JC_U,
    JC_V,
    JC_FINI
} cal_wins;

/*
 * variables used in calibration
 */
typedef struct {
    LPGLOBALVARS	pgv;
    cal_states		cState;
    BOOL		bHasTimer;
    BOOL		bUseTimer;
    HINSTANCE		hinst;
    JOYINFOEX		ji;
    JOYRANGE		jr;
    DWORD		pov[JOY_POV_NUMDIRS];
    int			iAxisCount;
    BOOL		bPOVdone;
} CALVARS, *LPCALVARS;

#define JOY_CALIB_FLAGS	JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
			JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
			JOY_RETURNBUTTONS | JOY_RETURNRAWDATA

/*
 * setDefaultButton - make a button the default window
 */
static void setDefaultButton( HWND hwnd, HWND hwdb )
{
    DWORD	style;
    int		i;
    HWND	hwb;
    int		idList[] = { IDC_JOYCALBACK,
			     IDC_JOYCALNEXT,
			     IDC_JOYPICKPOV,
			     IDC_JOYCALDONE,
			     IDC_JOYTEST };
    /*
     * turn off the current default push button
     */
    for( i=0;i<sizeof( idList )/sizeof( idList[0] );i++ ) {
	hwb = GetDlgItem( hwnd, idList[i] );
	style = GetWindowLong( hwb, GWL_STYLE );
	if( style & BS_DEFPUSHBUTTON ) {
	    style &= ~BS_DEFPUSHBUTTON;
	    style |= BS_PUSHBUTTON;
	    SetWindowLong( hwb, GWL_STYLE, style );
	}
    }

    /*
     * make the specified button the default
     */
    style = GetWindowLong( hwdb, GWL_STYLE );
    style &= ~(BS_PUSHBUTTON|BS_DEFPUSHBUTTON);
    style |= BS_DEFPUSHBUTTON;
    SetWindowLong( hwdb, GWL_STYLE, style );

} /* setDefaultButton */

/*
 * setLabel
 *
 * set the label for an axis based on current calibration state
 */
static void setLabel(
		LPGLOBALVARS pgv,
		HWND hwnd,
		UINT id,
		LPJOYREGHWCONFIG pcfg,
		DWORD bit  )
{
    char	str[MAX_STR];
    char	calstr[MAX_STR];
    int		type;
    HINSTANCE	hinst;
    HWND	hwtext;

    hinst = GetWindowInstance( hwnd );

    /*
     * get text for this axis label...
     */
    if( pcfg->dwUsageSettings & JOY_US_ISOEM ) {
	type = pcfg->dwType - JOY_HW_LASTENTRY;
	if( type < 0 || type >= pgv->pjd->oemCount ) {
	    type = -1;
	}
    } else {
	type = -1;
    }
    switch( id ) {
    case IDC_JOYLIST1_LABEL:
    	if( (type == -1) || (pgv->pjd->oemList[type].xy_label[0] == 0) ) {
	    if( !LoadString( hinst, IDS_XYAXIS_LABEL, str, sizeof( str ) ) ) {
		return;
	    }
	} else {
	    strcpy( str, pgv->pjd->oemList[type].xy_label );
	}
    	break;
    case IDC_JOYLIST2_LABEL:
    	if( (type == -1) || (pgv->pjd->oemList[type].z_label[0] == 0 ) ) {
	    if( !LoadString( hinst, IDS_ZAXIS_LABEL, str, sizeof( str ) ) ) {
		return;
	    }
	} else {
	    strcpy( str, pgv->pjd->oemList[type].z_label );
	}
    	break;
    case IDC_JOYLIST3_LABEL:
    	if( (type == -1) || (pgv->pjd->oemList[type].r_label[0] == 0) ) {
	    if( !LoadString( hinst, IDS_RAXIS_LABEL, str, sizeof( str ) ) ) {
		return;
	    }
	} else {
	    strcpy( str, pgv->pjd->oemList[type].r_label );
	}
    	break;
    case IDC_JOYLIST4_LABEL:
    	if( (type == -1) || (pgv->pjd->oemList[type].u_label[0] == 0) ) {
	    if( !LoadString( hinst, IDS_UAXIS_LABEL, str, sizeof( str ) ) ) {
		return;
	    }
	} else {
	    strcpy( str, pgv->pjd->oemList[type].u_label );
	}
    	break;
    case IDC_JOYLIST5_LABEL:
    	if( (type == -1) || (pgv->pjd->oemList[type].v_label[0] == 0) ) {
	    if( !LoadString( hinst, IDS_VAXIS_LABEL, str, sizeof( str ) ) ) {
		return;
	    }
	} else {
	    strcpy( str, pgv->pjd->oemList[type].v_label );
	}
    	break;
    case IDC_JOYPOV_LABEL:
    	if( (type == -1) || (pgv->pjd->oemList[type].pov_label[0] == 0) ) {
	    if( !LoadString( hinst, IDS_POVAXIS_LABEL, str, sizeof( str ) ) ) {
		return;
	    }
	} else {
	    strcpy( str, pgv->pjd->oemList[type].pov_label );
	}
    	break;
    }

    /*
     * tack on the calibration indicator if needed
     */
    if( pcfg->hwv.dwCalFlags & bit ) {
	if( !LoadString( hinst, IDS_JOYCALINDICATOR,
		    calstr, sizeof( calstr ) ) ) {
	    return;
	}
	if( strlen( str ) + strlen( calstr ) + 1 >= sizeof( str ) ) {
	    return;
	}
	strcat( str, " " );
	strcat( str, calstr );
    }
    hwtext = GetDlgItem( hwnd, id );
    if( hwtext != NULL ) {
	SetWindowText( hwtext, str );
    }

} /* setLabel */

/*
 * enableCalWindows - enable or disable specific calibration windows
 */
static void enableCalWindows(
		LPGLOBALVARS pgv,
		LPJOYREGHWCONFIG pcfg,
		HWND hwnd,
		cal_wins id )
{
    BOOL		on;
    HWND		hwlb;
    HWND		hwb;
//    HWND		hwcb;
    int			iid;

    /*
     * set up the buttons
     */
    hwb = GetDlgItem( hwnd,IDC_JOYCALDONE );
    if( id == JC_FINI ) {
	ShowWindow( GetDlgItem( hwnd, IDC_JOYCALNEXT ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYTEST ), SW_NORMAL );
	EnableWindow( hwb, TRUE );
	ShowWindow( hwb, SW_NORMAL );
	SetFocus( hwb );
	setDefaultButton( hwnd, hwb );
    } else {
	ShowWindow( GetDlgItem( hwnd, IDC_JOYCALNEXT ), SW_NORMAL );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYTEST ), SW_HIDE );
	EnableWindow( hwb, FALSE );
	ShowWindow( hwb, SW_HIDE );
    }

    /*
     * set up the labels with the (done) after it...
     */
    setLabel( pgv, hwnd, IDC_JOYLIST1_LABEL, pcfg, JOY_ISCAL_XY );

    if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	setLabel( pgv, hwnd, IDC_JOYLIST2_LABEL, pcfg, JOY_ISCAL_Z );
    }

    if( (pcfg->hws.dwFlags & JOY_HWS_HASR) || (pcfg->dwUsageSettings & JOY_US_HASRUDDER)) {
	setLabel( pgv, hwnd, IDC_JOYLIST3_LABEL, pcfg, JOY_ISCAL_R );
    }

    if( pcfg->hws.dwFlags & JOY_HWS_HASPOV ) {
	setLabel( pgv, hwnd, IDC_JOYPOV_LABEL, pcfg, JOY_ISCAL_POV );
    }

    if( pcfg->hws.dwFlags & JOY_HWS_HASU ) {
	setLabel( pgv, hwnd, IDC_JOYLIST4_LABEL, pcfg, JOY_ISCAL_U );
    }

    if( pcfg->hws.dwFlags & JOY_HWS_HASV ) {
	setLabel( pgv, hwnd, IDC_JOYLIST5_LABEL, pcfg, JOY_ISCAL_V );
    }


    /*
     * set up the XY window
     */
    on = FALSE;
    if( id == JC_XY ) {
	on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST1 );
    if( !on ) {
	InvalidateRect( hwlb, NULL, TRUE );
    }
    EnableWindow( hwlb, on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST1_LABEL ), on );

    /*
     * set up the Z window
     */
    on = FALSE;
    if( id == JC_Z ) {
	on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST2 );
    if( !on ) {
	InvalidateRect( hwlb, NULL, TRUE );
    }
    EnableWindow( hwlb, on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST2_LABEL ), on );

    /*
     * set up the R window
     */
    on = FALSE;
    if( id == JC_R ) {
	on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST3 );
    if( !on ) {
	InvalidateRect( hwlb, NULL, TRUE );
    }
    EnableWindow( hwlb, on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST3_LABEL ), on );

    /*
     * set up the U window
     */
    on = FALSE;
    if( id == JC_U ) {
	on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST4 );
    if( hwlb != NULL ) {
	if( !on ) {
	    InvalidateRect( hwlb, NULL, TRUE );
	}
	EnableWindow( hwlb, on );
	EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST4_LABEL ), on );
    }

    /*
     * set up the V window
     */
    on = FALSE;
    if( id == JC_V ) {
	on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST5 );
    if( hwlb != NULL ) {
	if( !on ) {
	    InvalidateRect( hwlb, NULL, TRUE );
	}
	EnableWindow( hwlb, on );
	EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST5_LABEL ), on );
    }

    /*
     * set up the POV icon
     */
    on = FALSE;
    if( id >= JC_POV_UP && id <= JC_POV_LEFT ) {
	on = TRUE;
    }
    EnableWindow( GetDlgItem( hwnd, IDC_JOYPOV_LABEL ), on );
    hwb = GetDlgItem( hwnd, IDC_JOYPICKPOV );
    EnableWindow( hwb, on );
    if( on ) {
	ShowWindow( hwb, SW_NORMAL );
	SetFocus( hwb );
	setDefaultButton( hwnd, hwb );
	switch( id ) {
	case JC_POV_UP:
	    iid = IDI_JOYPOV_UP;
	    break;
	case JC_POV_RIGHT:
	    iid = IDI_JOYPOV_RIGHT;
	    break;
	case JC_POV_LEFT:
	    iid = IDI_JOYPOV_LEFT;
	    break;
	case JC_POV_DOWN:
	    iid = IDI_JOYPOV_DOWN;
	    break;
	}
    } else {
	ShowWindow( hwb, SW_HIDE );
	UpdateWindow( hwb );
	iid = IDI_JOYPOV_GRAYED;
    }
    ChangeIcon( hwnd, iid, IDC_JOYPOV );

} /* enableCalWindows */


/*
 * getJoyName - get the name of a joystick
 */
static int getJoyName( LPJOYREGHWCONFIG pcfg, BOOL plural )
{
    int	str2id;

    if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE ) {
	if( plural ) {
	    str2id = IDS_JOYCAL_YOKES;
	} else {
	    str2id = IDS_JOYCAL_YOKE;
	}
    } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL ) {
	if( plural ) {
	    str2id = IDS_JOYCAL_CARS;
	} else {
	    str2id = IDS_JOYCAL_CAR;
	}
    } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD ) {
	if( plural ) {
	    str2id = IDS_JOYCAL_GAMEPADS;
	} else {
	    str2id = IDS_JOYCAL_GAMEPAD;
	}
    } else {
	if( plural ) {
	    str2id = IDS_JOY2S;
	} else {
	    str2id = IDS_JOY2;
	}
    }
    return str2id;

} /* getJoyName */

/*
 * joyCalStateChange - calibration state change
 */
static BOOL joyCalStateChange( LPCALVARS pcv, HWND hwnd, BOOL back )
{
    HINSTANCE		hinst;
    HWND		hwtext;
    int			strid;
    int			stridx;
    int			str2id;
    int			str3id;
    int			str4id;
    char		str[2*MAX_STR];
    char		buff[2*MAX_STR];
    char		str2[64];
    char		str3[64];
    char		str4[64];
    BOOL		done;
    LPJOYREGHWCONFIG	pcfg;
    BOOL		rc;
    int			type;
    LPGLOBALVARS	pgv;
    BOOL		isdone;

    /*
     * move to the next state: get the appropriate string
     * to display, and enable the correct controls
     */
    pgv = pcv->pgv;
    rc = TRUE;
    done = FALSE;
    pcfg = &pgv->joyHWCurr;
    str2id = -1;
    str3id = -1;
    str4id = -1;
    pcv->cState++;
    EnableWindow( GetDlgItem( hwnd, IDC_JOYCALBACK ), back );
    while( !done ) {
	done = TRUE;
	switch( pcv->cState ) {
	case JCS_XY_CENTER1:
	    /*
	     * init. range variables
	     */
	    pcv->jr.jpMin.dwX = (DWORD) -1;
	    pcv->jr.jpMin.dwY = (DWORD) -1;
	    pcv->jr.jpMin.dwZ = (DWORD) -1;
	    pcv->jr.jpMin.dwR = (DWORD) -1;
	    pcv->jr.jpMin.dwU = (DWORD) -1;
	    pcv->jr.jpMin.dwV = (DWORD) -1;
	    pcv->jr.jpMax.dwX = 0;
	    pcv->jr.jpMax.dwY = 0;
	    pcv->jr.jpMax.dwZ = 0;
	    pcv->jr.jpMax.dwR = 0;
	    pcv->jr.jpMax.dwU = 0;
	    pcv->jr.jpMax.dwV = 0;
    
	    /*
	     * set strings to display
	     */
	    stridx = CALSTR1;
	    if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE ) {
		strid = IDS_JOYCALXY_CENTERYOKE;
	    } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL ) {
		strid = IDS_JOYCALXY_CENTERCAR;
	    } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD ) {
		strid = IDS_JOYCALXY_CENTERGAMEPAD;
	    } else {
		strid = IDS_JOYCALXY_CENTER;
	    }
	    enableCalWindows( pgv, pcfg, hwnd, JC_XY );
	    break;
	case JCS_XY_MOVE:
	    stridx = CALSTR2;
	    if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE ) {
		strid = IDS_JOYCALXY_MOVEYOKE;
	    } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL ) {
		strid = IDS_JOYCALXY_MOVECAR;
	    } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD ) {
		strid = IDS_JOYCALXY_MOVEGAMEPAD;
	    } else {
		strid = IDS_JOYCALXY_MOVE;
	    }
	    break;
	case JCS_XY_CENTER2:
	    stridx = CALSTR3;
	    if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE ) {
		strid = IDS_JOYCALXY_CENTERYOKE2;
	    } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL ) {
		strid = IDS_JOYCALXY_CENTERCAR2;
	    } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD ) {
		strid = IDS_JOYCALXY_CENTERGAMEPAD2;
	    } else {
		strid = IDS_JOYCALXY_CENTER2;
	    }
	    break;
	case JCS_Z_MOVE:
	    stridx = CALSTR4;
	    if( !(pcfg->hws.dwFlags & JOY_HWS_HASZ) ) {
		pcv->cState = JCS_R_MOVE;
		done = FALSE;
	    } else {
		enableCalWindows( pgv, pcfg, hwnd, JC_Z );
		strid = IDS_JOYCALZ_MOVE;
		str2id = getJoyName( pcfg, TRUE );
	    }
	    break;
	case JCS_Z_PLACEHOLDER:
	    pcv->cState = JCS_R_MOVE;
	    done = FALSE;
	    break;
	case JCS_R_MOVE:
	    stridx = CALSTR5;
	    if( !(pcfg->hws.dwFlags & JOY_HWS_HASR) && !(pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
		pcv->cState = JCS_U_MOVE;
		done = FALSE;
	    } else {
		enableCalWindows( pgv, pcfg, hwnd, JC_R );
		strid = IDS_JOYCALRUDDER_MOVE;
		str2id = getJoyName( pcfg, TRUE );
	    }
	    break;
	case JCS_R_PLACEHOLDER:
	    pcv->cState = JCS_U_MOVE;
	    done = FALSE;
	    break;
	case JCS_U_MOVE:
	    stridx = CALSTR6;
	    if( !(pcfg->hws.dwFlags & JOY_HWS_HASU) ) {
		pcv->cState = JCS_V_MOVE;
		done = FALSE;
	    } else {
		enableCalWindows( pgv, pcfg, hwnd, JC_U );
		strid = IDS_JOYCALU_MOVE;
		str2id = getJoyName( pcfg, TRUE );
	    }
	    break;
	case JCS_U_PLACEHOLDER:
	    pcv->cState = JCS_V_MOVE;
	    done = FALSE;
	    break;
	case JCS_V_MOVE:
	    stridx = CALSTR7;
	    if( !(pcfg->hws.dwFlags & JOY_HWS_HASV) ) {
		pcv->cState = JCS_POV_MOVEUP;
		done = FALSE;
	    } else {
		enableCalWindows( pgv, pcfg, hwnd, JC_V );
		strid = IDS_JOYCALV_MOVE;
		str2id = getJoyName( pcfg, TRUE );
	    }
	    break;
	case JCS_V_PLACEHOLDER:
	    pcv->cState = JCS_POV_MOVEUP;
	    done = FALSE;
	    break;
	case JCS_POV_MOVEUP:
	    stridx = CALSTR8;
	    if( !(pcfg->hws.dwFlags & JOY_HWS_HASPOV)) {
		pcv->cState = JCS_FINI;
		done = FALSE;
	    } else {
		enableCalWindows( pgv, pcfg, hwnd, JC_POV_UP );
		strid = IDS_JOYCALPOV_MOVE;
		str2id = IDS_JOYCAL_UP;
		str3id = getJoyName( pcfg, TRUE );
		str4id = IDS_JOYCAL_UP;
	    }
	    break;
	case JCS_POV_MOVERIGHT:
	    stridx = CALSTR9;
	    enableCalWindows( pgv, pcfg, hwnd, JC_POV_RIGHT );
	    strid = IDS_JOYCALPOV_MOVE;
	    str2id = IDS_JOYCAL_RIGHT;
	    str3id = getJoyName( pcfg, TRUE );
	    str4id = IDS_JOYCAL_RIGHT;
	    break;
	case JCS_POV_MOVEDOWN:
	    stridx = CALSTR10;
	    enableCalWindows( pgv, pcfg, hwnd, JC_POV_DOWN );
	    strid = IDS_JOYCALPOV_MOVE;
	    str2id = IDS_JOYCAL_DOWN;
	    str3id = getJoyName( pcfg, TRUE );
	    str4id = IDS_JOYCAL_DOWN;
	    break;
	case JCS_POV_MOVELEFT:
	    stridx = CALSTR11;
	    enableCalWindows( pgv, pcfg, hwnd, JC_POV_LEFT );
	    strid = IDS_JOYCALPOV_MOVE;
	    str2id = IDS_JOYCAL_LEFT;
	    str3id = getJoyName( pcfg, TRUE );
	    str4id = IDS_JOYCAL_LEFT;
	    break;
	case JCS_FINI:
	    /*
	     * see if everything that needs to be calibrated
	     * was actually calibrated
	     */
	    if( !(pcfg->hwv.dwCalFlags & JOY_ISCAL_XY) ) {
		isdone = FALSE;
	    } else if( (pcfg->hws.dwFlags & JOY_HWS_HASZ) &&
			!(pcfg->hwv.dwCalFlags & JOY_ISCAL_Z) ) {
		isdone = FALSE;
	    } else if( ((pcfg->hws.dwFlags & JOY_HWS_HASR) ||
	    		(pcfg->dwUsageSettings & JOY_US_HASRUDDER)) &&
    			!(pcfg->hwv.dwCalFlags & JOY_ISCAL_R) ) {
		isdone = FALSE;
	    } else if( (pcfg->hws.dwFlags & JOY_HWS_HASPOV) &&
    			!(pcfg->hwv.dwCalFlags & JOY_ISCAL_POV) )  {
		isdone = FALSE;
	    } else if( (pcfg->hws.dwFlags & JOY_HWS_HASU) &&
    			!(pcfg->hwv.dwCalFlags & JOY_ISCAL_U) )  {
		isdone = FALSE;
	    } else if( (pcfg->hws.dwFlags & JOY_HWS_HASV) &&
    			!(pcfg->hwv.dwCalFlags & JOY_ISCAL_V) )  {
		isdone = FALSE;
	    } else {
		isdone = TRUE;
	    }
	    if( isdone ) {
		strid = IDS_JOYCAL_DONE;
	    } else {
		strid = IDS_JOYCAL_NOTDONE;
	    }
	    str2id = getJoyName( pcfg, FALSE );
	    str3id = getJoyName( pcfg, TRUE );
	    stridx = CALSTR12;
	    enableCalWindows( pgv, pcfg, hwnd, JC_FINI );
	    rc = FALSE;
	    break;
	}
    }

    /*
     * see if there is any OEM text specified
     */
    hinst = GetWindowInstance( hwnd );
    hwtext = GetDlgItem( hwnd, IDC_JOYCALMSG );
    if( pcfg->dwUsageSettings & JOY_US_ISOEM ) {
	LPJOYDATA	pjd;
	pjd = pgv->pjd;
	type = pcfg->dwType - JOY_HW_LASTENTRY;
	if( pjd->oemList[type].cal_strs[ stridx ][0] != 0 ) {
	    SetWindowText( hwtext, pjd->oemList[type].cal_strs[ stridx] );
	    return rc;
	}
    }

    /*
     * no OEM text, use the defaults
     */
    if( LoadString( hinst, strid, str, sizeof( str ) ) ) {
	if( str2id != -1 ) {
	    if( LoadString( hinst, str2id, str2, sizeof( str2 ) ) ) {
		if( str3id != -1 ) {
		    if( LoadString( hinst, str3id, str3, sizeof( str3 ) ) ) {
			if( str4id != -1 ) {
			    if( LoadString( hinst, str4id, str4, sizeof( str4 ) ) ) {
				// wsprintf( buff, str, str2, str3, str4 );
				LPSTR lpargs[] = {str2, str3, str4};
				
				FormatMessage(FORMAT_MESSAGE_FROM_STRING |
					      FORMAT_MESSAGE_ARGUMENT_ARRAY,
					      (LPSTR) str,
					      0, 0,
					      buff,
					      sizeof(buff),
					      (va_list *)lpargs);
				SetWindowText( hwtext, buff );
			    }
			} else {
			    wsprintf( buff, str, str2, str3 );
			    SetWindowText( hwtext, buff );
			}
		    }
		} else {
		    wsprintf( buff, str, str2, str2 );
		    SetWindowText( hwtext, buff );
		}
	    }
	} else {
	    SetWindowText( hwtext, str );
	}
    }

    return rc;

} /* joyCalStateChange */

/*
 * joyCalStateSkip - skip the current state, move to the next one
 */
static void joyCalStateSkip( LPCALVARS pcv, HWND hwnd )
{

    /*
     * if we're calibrating XY, skip to Z
     */
    if( pcv->cState <= JCS_XY_CENTER2 ) {
	pcv->cState = JCS_XY_CENTER2;
    /*
     * if we're calibrating Z, skip to R
     */
    } else if( pcv->cState < JCS_Z_PLACEHOLDER ) {
	pcv->cState = JCS_Z_PLACEHOLDER;
    /*
     * if we're calibrating R, skip to U
     */
    } else if( pcv->cState < JCS_R_PLACEHOLDER ) {
	pcv->cState = JCS_R_PLACEHOLDER;
    /*
     * if we're calibrating U, skip to V
     */
    } else if( pcv->cState < JCS_U_PLACEHOLDER ) {
	pcv->cState = JCS_U_PLACEHOLDER;
    /*
     * if we're calibrating V, skip to POV
     */
    } else if( pcv->cState < JCS_V_PLACEHOLDER ) {
	pcv->cState = JCS_V_PLACEHOLDER;
    /*
     * we must be calibration POV, skip to the end
     */
    } else  {
	pcv->cState = JCS_POV_MOVELEFT;
    }

    /*
     * state changed, reset to the new one
     */
    CauseRedraw( &pcv->ji, FALSE );
    joyCalStateChange( pcv, hwnd, TRUE );

} /* joyCalStateSkip */

/*
 * resetCustomPOVFlags - set POV flags based on original values for custom joystick
 */
static void resetCustomPOVFlags( LPGLOBALVARS pgv, LPJOYREGHWCONFIG pcfg )
{
    if( pcfg->dwType == JOY_HW_CUSTOM ) {
	pcfg->hws.dwFlags &= ~(JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS);
	if( pgv->bOrigPOVIsPoll ) {
	    pcfg->hws.dwFlags |= JOY_HWS_POVISPOLL;
	}
	if( pgv->bOrigPOVIsButtonCombos ) {
	    pcfg->hws.dwFlags |= JOY_HWS_POVISBUTTONCOMBOS;
	}
    }

} /* resetCustomPOVFlags */


/*
 * joyCalStateBack - move back to start the previous state
 */
static void joyCalStateBack( LPCALVARS pcv, HWND hwnd )
{
    BOOL		back;
    LPJOYREGHWCONFIG	pcfg;
    LPGLOBALVARS	pgv;

    pgv = pcv->pgv;
    back = TRUE;
    pcfg = &pgv->joyHWCurr;
    /*
     * at the end, backup
     */
    if( pcv->cState == JCS_FINI ) {
	/*
	 * if there is POV, back up to it
	 */
	if( pcfg->hws.dwFlags & JOY_HWS_HASPOV ) {
	    pcv->cState = JCS_V_PLACEHOLDER;
	    resetCustomPOVFlags( pgv, pcfg );
	/*
	 * if there is V, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASV ) {
	    pcv->cState = JCS_U_PLACEHOLDER;
	/*
	 * if there is U, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASU ) {
	    pcv->cState = JCS_R_PLACEHOLDER;
	/*
	 * if there is R, back up to it
	 */
	} else if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
	    (pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
	    pcv->cState = JCS_Z_PLACEHOLDER;
	/*
	 * if there is Z, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	    pcv->cState = JCS_XY_CENTER2;
	/*
	 * no where else to go, back up to XY
	 */
	} else {
	    pcv->cState = JCS_INIT;
	    back = FALSE;
	}
    /*
     * doing POV, so restart it
     */
    } else if( pcv->cState > JCS_POV_MOVEUP ) {
	pcv->cState = JCS_V_PLACEHOLDER;
//	pcfg->hws.dwFlags &= ~(JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS);
	resetCustomPOVFlags( pgv, pcfg );
    /*
     * just starting POV, back up
     */
    } else if( pcv->cState == JCS_POV_MOVEUP ) {
	/*
	 * if there is V, back up to it
	 */
	if( pcfg->hws.dwFlags & JOY_HWS_HASV ) {
	    pcv->cState = JCS_U_PLACEHOLDER;
	/*
	 * if there is U, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASU ) {
	    pcv->cState = JCS_R_PLACEHOLDER;
	/*
	 * if there is R, back up to it
	 */
	} else if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
	    (pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
	    pcv->cState = JCS_Z_PLACEHOLDER;
	/*
	 * if there is Z, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	    pcv->cState = JCS_XY_CENTER2;
	/*
	 * no where else to go, back up to XY
	 */
	} else {
	    pcv->cState = JCS_INIT;
	    back = FALSE;
	}
    /*
     * doing V, backup
     */
    } else if( pcv->cState == JCS_V_MOVE ) {
	/*
	 * if there is U, back up to it
	 */
	if( pcfg->hws.dwFlags & JOY_HWS_HASU ) {
	    pcv->cState = JCS_R_PLACEHOLDER;
	/*
	 * if there is R, back up to it
	 */
	} else if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
	    (pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
	    pcv->cState = JCS_Z_PLACEHOLDER;
	/*
	 * if there is Z, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	    pcv->cState = JCS_XY_CENTER2;
	/*
	 * no where else to go, back up to XY
	 */
	} else {
	    pcv->cState = JCS_INIT;
	    back = FALSE;
	}
    /*
     * doing U, backup
     */
    } else if( pcv->cState == JCS_U_MOVE ) {
	/*
	 * if there is R, back up to it
	 */
	if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
	    (pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
	    pcv->cState = JCS_Z_PLACEHOLDER;
	/*
	 * if there is Z, back up to it
	 */
	} else if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	    pcv->cState = JCS_XY_CENTER2;
	/*
	 * no where else to go, back up to XY
	 */
	} else {
	    pcv->cState = JCS_INIT;
	    back = FALSE;
	}
    /*
     * doing R, backup
     */
    } else if( pcv->cState == JCS_R_MOVE ) {
	/*
	 * if there is Z, back up to it
	 */
	if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	    pcv->cState = JCS_XY_CENTER2;
	/*
	 * no where else to go, back up to XY
	 */
	} else {
	    pcv->cState = JCS_INIT;
	    back = FALSE;
	}
    /*
     * if we're doing Z or in the middle of XY, backup to XY
     */
    } else {
	pcv->cState = JCS_INIT;
	back = FALSE;
    }

    /*
     * state changed, reset to the new one
     */
    CauseRedraw( &pcv->ji, FALSE );
    joyCalStateChange( pcv, hwnd, back );

} /* joyCalStateBack */

/*
 * macro to get new max/min data for an axis
 */
#define NEWMINMAX( a ) \
    if( pji->dw##a##pos > pcv->jr.jpMax.dw##a ) { \
	pcv->jr.jpMax.dw##a = pji->dw##a##pos; \
    } \
    if( pji->dw##a##pos < pcv->jr.jpMin.dw##a ) { \
	pcv->jr.jpMin.dw##a = pji->dw##a##pos; \
    } \

/*
 * macro to do continuous calibration--changes jpi->dw*pos based on current
 * position and latest minimum/maximum values
 */
#define CAL_MIN  50   // Pretend it's centered unless HW range is >= CAL_MIN

#define SIMULATECALIBRATION(_pcv,_pji,_AXIS_) \
    { \
        NEWMINMAX(_AXIS_); \
        _pji->dw##_AXIS_##pos -= _pcv->jr.jpMin.dw##_AXIS_; \
        if (_pcv->jr.jpMax.dw##_AXIS_ - _pcv->jr.jpMin.dw##_AXIS_ < CAL_MIN) { \
            _pji->dw##_AXIS_##pos = (RANGE_MAX -RANGE_MIN)/2; \
        } else if ( RANGE_MAX == RANGE_MIN ) { \
            _pji->dw##_AXIS_##pos = (RANGE_MAX -RANGE_MIN)/2; \
        } else { \
            _pji->dw##_AXIS_##pos *= (RANGE_MAX-RANGE_MIN); \
            _pji->dw##_AXIS_##pos /= ( _pcv->jr.jpMax.dw##_AXIS_ - \
                                       _pcv->jr.jpMin.dw##_AXIS_ ); \
        } \
        _pji->dw##_AXIS_##pos += RANGE_MIN; \
    }

/*
 * joyCollectCalInfo - record calibration info 
 */
static BOOL joyCollectCalInfo( LPCALVARS pcv, HWND hwnd, LPJOYINFOEX pji )
{
    LPGLOBALVARS	pgv;
    LPJOYREGHWCONFIG	pcfg;

    pgv = pcv->pgv;
    switch( pcv->cState ) {
    /*
     * remember XY center
     */
    case JCS_XY_CENTER1:
    case JCS_XY_CENTER2:
    {
	JOYINFOEX jiex = *pji;
	SIMULATECALIBRATION( pcv, pji, X );
	SIMULATECALIBRATION( pcv, pji, Y );
	DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWXY );
	*pji = jiex;
	break;
    }

    /*
     * remember max/min XY values
     */
    case JCS_XY_MOVE:
    {
	JOYINFOEX jiex = *pji;
	SIMULATECALIBRATION( pcv, pji, X );
	SIMULATECALIBRATION( pcv, pji, Y );
	DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWXY );
	*pji = jiex;
    	break;
    }

    /*
     * remember max/min Z value
     */
    case JCS_Z_MOVE:
    {
	JOYINFOEX jiex = *pji;
	SIMULATECALIBRATION( pcv, pji, Z );
	DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWZ );
	*pji = jiex;
    	break;
    }

    /*
     * remember max/min R value
     */
    case JCS_R_MOVE:
    {
	JOYINFOEX jiex = *pji;
	SIMULATECALIBRATION( pcv, pji, R );
	DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWR );
	*pji = jiex;
    	break;
    }

    /*
     * remember max/min U value
     */
    case JCS_U_MOVE:
    {
	JOYINFOEX jiex = *pji;
	SIMULATECALIBRATION( pcv, pji, U );
	DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWU );
	*pji = jiex;
    	break;
    }

    /*
     * remember max/min V value
     */
    case JCS_V_MOVE:
    {
	JOYINFOEX jiex = *pji;
	SIMULATECALIBRATION( pcv, pji, V );
	DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWV );
	*pji = jiex;
    	break;
    }
    }

    /*
     * if a button was pressed, move to the next state
     */
    if( ((pcv->ji.dwButtons & ALL_BUTTONS) != (pji->dwButtons & ALL_BUTTONS)) &&
    	((pji->dwButtons & JOY_BUTTON1) ||
    	 (pji->dwButtons & JOY_BUTTON2) ||
    	 (pji->dwButtons & JOY_BUTTON3) ||
    	 (pji->dwButtons & JOY_BUTTON4) ) ) {
	/*
	 * check and see if we are leaving one calibration to the next;
	 * if yes, take time to stop and remember what the user just did
	 */
	pcfg = &pgv->joyHWCurr;
	switch( pcv->cState ) {
	case JCS_XY_CENTER1:
	    pcv->jr.jpCenter.dwX = pji->dwXpos;
	    pcv->jr.jpCenter.dwY = pji->dwYpos;
	    DPF( "Center 1: %d,%d\r\n", pji->dwXpos, pji->dwYpos );
	    break;

	case JCS_XY_CENTER2:
	    DPF( "Center 2: %d,%d\r\n", pji->dwXpos, pji->dwYpos );
	    pcv->jr.jpCenter.dwX += pji->dwXpos;
	    pcv->jr.jpCenter.dwY += pji->dwYpos;
	    pcv->jr.jpCenter.dwX /= 2;
	    pcv->jr.jpCenter.dwY /= 2;
	    DPF( "Center Avg: %d,%d\r\n", pcv->jr.jpCenter.dwX, pcv->jr.jpCenter.dwY );
	    pcfg->hwv.jrvHardware.jpMin.dwX = pcv->jr.jpMin.dwX;
	    pcfg->hwv.jrvHardware.jpMin.dwY = pcv->jr.jpMin.dwY;
	    pcfg->hwv.jrvHardware.jpMax.dwX = pcv->jr.jpMax.dwX;
	    pcfg->hwv.jrvHardware.jpMax.dwY = pcv->jr.jpMax.dwY;
	    pcfg->hwv.jrvHardware.jpCenter.dwX = pcv->jr.jpCenter.dwX;
	    pcfg->hwv.jrvHardware.jpCenter.dwY = pcv->jr.jpCenter.dwY;
	    pcfg->hwv.dwCalFlags |= JOY_ISCAL_XY;
	    break;
	case JCS_Z_MOVE:
	    pcfg->hwv.jrvHardware.jpMin.dwZ = pcv->jr.jpMin.dwZ;
	    pcfg->hwv.jrvHardware.jpMax.dwZ = pcv->jr.jpMax.dwZ;
	    pcfg->hwv.dwCalFlags |= JOY_ISCAL_Z;
	    break;
	case JCS_R_MOVE:
	    pcfg->hwv.jrvHardware.jpMin.dwR = pcv->jr.jpMin.dwR;
	    pcfg->hwv.jrvHardware.jpMax.dwR = pcv->jr.jpMax.dwR;
	    pcfg->hwv.dwCalFlags |= JOY_ISCAL_R;
	    break;
	case JCS_U_MOVE:
	    pcfg->hwv.jrvHardware.jpMin.dwU = pcv->jr.jpMin.dwU;
	    pcfg->hwv.jrvHardware.jpMax.dwU = pcv->jr.jpMax.dwU;
	    pcfg->hwv.dwCalFlags |= JOY_ISCAL_U;
	    break;
	case JCS_V_MOVE:
	    pcfg->hwv.jrvHardware.jpMin.dwV = pcv->jr.jpMin.dwV;
	    pcfg->hwv.jrvHardware.jpMax.dwV = pcv->jr.jpMax.dwV;
	    pcfg->hwv.dwCalFlags |= JOY_ISCAL_V;
	    break;
	}
	pcv->ji.dwButtons = pji->dwButtons;
	return joyCalStateChange( pcv, hwnd, TRUE );
    }
    pcv->ji.dwButtons = pji->dwButtons;
    return TRUE;

} /* joyCollectCalInfo */

/*
 * joyCalibrateInitDialog - init the calibration dialog
 */
static BOOL joyCalibrateInitDialog( HWND hwnd, LPARAM lParam )
{
    LPJOYREGHWCONFIG	pcfg;
    LPCALVARS		pcv;
    LPGLOBALVARS	pgv;

    /*
     * set up calibration variables
     */
    pcv = DoAlloc( sizeof( CALVARS ) );
    SetWindowLong( hwnd, DWL_USER, (LONG) pcv );
    if( pcv == NULL ) {
	return FALSE;
    }
    pgv = (LPGLOBALVARS) lParam;
    pcv->pgv = pgv;

    /*
     * init state info
     */
    pcv->cState = JCS_INIT;

    /*
     * set dialog text based on OEM strings
     */
    SetOEMText( pgv, hwnd, FALSE );

    /*
     * customize dialog based on Z axis, R axis, and POV hat
     */
    pcfg = &pgv->joyHWCurr;
    pcv->iAxisCount = 2;
    if( pcfg->hws.dwFlags & JOY_HWS_HASZ ) {
	pcv->iAxisCount++;
    }
    if( (pcfg->hws.dwFlags & JOY_HWS_HASR) || (pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
	pcv->iAxisCount++;
    }
    if( (pcfg->hws.dwFlags & JOY_HWS_HASPOV) &&
    	(pcfg->hws.dwFlags & JOY_HWS_POVISPOLL) ) {
	pcv->iAxisCount++;
    }
    if( pcfg->hws.dwFlags & JOY_HWS_HASU ) {
	pcv->iAxisCount++;
    }
    if( pcfg->hws.dwFlags & JOY_HWS_HASV ) {
	pcv->iAxisCount++;
    }
    ShowControls( pcfg, hwnd );

    /*
     * if all axes are used and we have POV then it MUST be buttons
     */
    if( pcfg->hws.dwFlags & JOY_HWS_HASPOV ) {
	if( pgv->dwMaxAxes == 4 && pcv->iAxisCount == 4 ) {
	    pcfg->hws.dwFlags |= JOY_HWS_POVISBUTTONCOMBOS;
	}
    }

    /*
     * other misc setup
     */
    pcv->bPOVdone = FALSE;
    pcv->bHasTimer = SetTimer( hwnd, TIMER_ID, JOYPOLLTIME, NULL );
    pcv->bUseTimer = TRUE;
    if( !pcv->bHasTimer ) {
	DPF( "No timer for joystick calibration!\r\n" );
	return FALSE;
    }
    if( !joyCalStateChange( pcv, hwnd, FALSE ) ) {
	DPF( "Could not initialize joystick calibration\r\n" );
	return FALSE;
    }
    
    return TRUE;

} /* joyCalibrateInitDialog */

/*
 * setJIFlagsForPOV - get joyinfo flags to allow a raw POV poll
 */
static void setJIFlagsForPOV( LPCALVARS pcv, LPJOYREGHWCONFIG pcfg, DWORD *pflags )
{
    /*
     * for polled POV, we need to specifiy JOY_CAL_READ(3|4) to make
     * the driver give us position values back instead of trying to
     * give us a POV value back
     */
    if( pcfg->hws.dwFlags & JOY_HWS_HASPOV ) {
	if( pcfg->hws.dwFlags & JOY_HWS_POVISPOLL ) {
	    if( pcv->iAxisCount == 6 ) {
		(*pflags) |= JOY_CAL_READ6;
	    } else if( pcv->iAxisCount == 5 ) {
		(*pflags) |= JOY_CAL_READ5;
	    } else if( pcv->iAxisCount == 4 ) {
		(*pflags) |= JOY_CAL_READ4;
	    } else if( pcv->iAxisCount == 3 ) {
		(*pflags) |= JOY_CAL_READ3;
	    }
	/*
	 * if we don't have a 3rd or 4th axis on this joystick, try reading
	 * another axis anyway to see if the POV hat is on it
	 */
	} else if( !(pcfg->hws.dwFlags & (JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS)) ) {
	    if( pcv->iAxisCount == 5 ) {
		(*pflags) |= JOY_CAL_READ6;
	    } else if( pcv->iAxisCount == 4 ) {
		(*pflags) |= JOY_CAL_READ5;
	    } else if( pcv->iAxisCount == 3 ) {
		(*pflags) |= JOY_CAL_READ4;
	    } else if( pcv->iAxisCount == 2 ) {
		(*pflags) |= JOY_CAL_READ3;
	    }
	}
    }

} /* setJIFlagsForPOV */

/*
 * tryPOV - try for a POV access
 */
static BOOL tryPOV( LPCALVARS pcv, HWND hwnd )
{
    int			rc;
    BOOL		ispoll;
    BOOL		isb;
    BOOL		nowaypoll;
    JOYINFOEX		ji;
    DWORD		val;
    LPJOYREGHWCONFIG	pcfg;
    LPGLOBALVARS	pgv;
    int			i;

    pgv = pcv->pgv;

    /*
     * reject call if not in a POV state
     */
    if( !(pcv->cState == JCS_POV_MOVEUP ||
	pcv->cState == JCS_POV_MOVEDOWN ||
	pcv->cState == JCS_POV_MOVELEFT ||
	pcv->cState == JCS_POV_MOVERIGHT) ) {
	return FALSE;
    }

    /*
     * take a snapshot of the current joystick state
     */
    pcfg = &pgv->joyHWCurr;
    nowaypoll = FALSE;
    ji.dwSize = sizeof( ji );
    while( 1 ) {
	/*
	 * get joystick info
	 */
	ji.dwFlags = JOY_CALIB_FLAGS;
	setJIFlagsForPOV( pcv, pcfg, &ji.dwFlags );
	rc = joyGetPosEx( pgv->iJoyId, &ji );
	if( rc == JOYERR_NOERROR ) {
	    break;
	}
	if( !(pcfg->hws.dwFlags & JOY_HWS_POVISPOLL) &&
		(ji.dwFlags & (JOY_CAL_READ3|JOY_CAL_READ4|JOY_CAL_READ5|JOY_CAL_READ6)) ) {
	    /*
	     * try again, but don't ask for extra axis
	     */
	    ji.dwFlags &= ~(JOY_CAL_READ6 | JOY_CAL_READ5 | JOY_CAL_READ4 | JOY_CAL_READ3);
	    rc = joyGetPosEx( pgv->iJoyId, &ji );
	    if( rc == JOYERR_NOERROR ) {
		nowaypoll = TRUE;	// pov can't possibly be polled
		break;
	    } else {
		if( !JoyError( hwnd ) ) {
		    return FALSE;
		}
		return TRUE;	// have to wait for next "Select POV" to retry
	    }
	} else {
	    if( !JoyError( hwnd ) ) {
		return FALSE;
	    }
	    return TRUE;	// have to wait for next "Select POV" to retry
	}
    }

    /*
     * here is where we determine if POV is polled or is button combos.
     *
     * See if we already know the answer (bits in joyHWCurr):
     *     if yes:
     *	       we're done.
     *     if no:
     *         We see if there are currently multiple buttons down.
     *         if yes:
     *             POV is assumed to be button combos.
     *         if no:
     *             POV is assumed to be done with polling
     */
    ispoll = FALSE;
    isb = FALSE;
    if( pcfg->hws.dwFlags & JOY_HWS_POVISPOLL ) {
	ispoll = TRUE;
    }  else if( pcfg->hws.dwFlags & JOY_HWS_POVISBUTTONCOMBOS ) {
	isb = TRUE;
    }
    if( !isb && !ispoll ) {
	/*
	 * the type is indeterminate, so we identify it 
	 */
	if( nowaypoll ||
	    ((ji.dwButtons != 0) && (ji.dwButtons != JOY_BUTTON1) &&
	    (ji.dwButtons != JOY_BUTTON2) && (ji.dwButtons != JOY_BUTTON3) &&
	    (ji.dwButtons != JOY_BUTTON4)) ) {
	    isb = TRUE;
	    pcfg->hws.dwFlags |= JOY_HWS_POVISBUTTONCOMBOS;
	} else {
	    /*
	     * we always assume J2 Y for a polling POV if unspecified
	     */
	    ispoll = TRUE;
	    pcfg->hws.dwFlags |= JOY_HWS_POVISPOLL;
	}
	/*
	 * the driver needs to notified that we've made this decision
	 */
	RegSaveCurrentJoyHW( pgv );
	RegistryUpdated( pgv );
    }

    /*
     * record the data value for this POV reading
     */
    if( isb ) {
	val = ji.dwButtons;
    } else {
	if( !(pcfg->hws.dwFlags & JOY_HWS_HASZ) ) {
	    val = ji.dwZpos;
	} else {
	    val = ji.dwRpos;
	}
    }
    switch( pcv->cState ) {
    case JCS_POV_MOVEUP:
	pcv->pov[JOY_POVVAL_FORWARD] = val;
	break;
    case JCS_POV_MOVERIGHT:
	pcv->pov[JOY_POVVAL_RIGHT] = val;
	break;
    case JCS_POV_MOVEDOWN:
	pcv->pov[JOY_POVVAL_BACKWARD] = val;
	break;
    case JCS_POV_MOVELEFT:
	pcv->pov[JOY_POVVAL_LEFT] = val;
	/*
	 * since this was the last POV thing to calibrate, we need
	 * to save the calibration info
	 */
	for( i=0;i<JOY_POV_NUMDIRS;i++ ) {
	    pcfg->hwv.dwPOVValues[i] = pcv->pov[i];
	}
	pcfg->hwv.dwCalFlags |= JOY_ISCAL_POV;
	pcv->bPOVdone = TRUE;
	break;
    }
    return joyCalStateChange( pcv, hwnd, TRUE );

} /* tryPOV */

/*
 * FixCustomPOVType - fix custom POV type info if POV wasn't calibrated;
 *		      called by test dlg to update config
 */
void FixCustomPOVType( LPCALVARS pcv )
{
    if( !pcv->bPOVdone ) {
	resetCustomPOVFlags( pcv->pgv, &pcv->pgv->joyHWCurr );
    }

} /* FixCustomPOVType */

/*
 * CalibrateProc - calibrate a joystick
 */
BOOL CALLBACK CalibrateProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    BOOL		rc;

    switch( umsg ) {
    case WM_TIMER:
    {
	LPCALVARS		pcv;

	pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
    	if( pcv->bUseTimer ) {
	    JOYINFOEX		ji;
	    MMRESULT		rc;
	    LPJOYREGHWCONFIG	pcfg;
	    LPGLOBALVARS	pgv;

	    pgv = pcv->pgv;
	    pcv->bUseTimer = FALSE;
	    ji.dwSize = sizeof( ji );
	    while( 1 ) {
		/*
		 * get current joystick info
		 */
		ji.dwFlags = JOY_CALIB_FLAGS;
		pcfg = &pgv->joyHWCurr;
		setJIFlagsForPOV( pcv, pcfg, &ji.dwFlags );
		rc = joyGetPosEx( pgv->iJoyId, &ji );
		if( rc == JOYERR_NOERROR ) {
		    break;
		}

		/*
		 * didn't work, try without extra POV axis
		 */
		if( !(pcfg->hws.dwFlags & JOY_HWS_POVISPOLL) &&
			(ji.dwFlags & (JOY_CAL_READ3|JOY_CAL_READ4|JOY_CAL_READ5|JOY_CAL_READ6)) ) {
		    ji.dwFlags &= ~(JOY_CAL_READ6 | JOY_CAL_READ5 | JOY_CAL_READ4 | JOY_CAL_READ3);
		    rc = joyGetPosEx( pgv->iJoyId, &ji );
		    if( rc == JOYERR_NOERROR ) {
			break;
		    }
		}
		if( !JoyError( hwnd ) ) {
		    /*
		     * return now if cancel selected; don't turn back
		     * on the timer
		     */
		    return FALSE;	
		}
		continue;
	    }
	    if( rc == JOYERR_NOERROR ) {
		joyCollectCalInfo( pcv, hwnd, &ji );
	    }
	    /*
	     * If we've started POV calibration, we need to look at the
	     * keyboard and ignore joystick, so don't turn the timer
	     * back on if we've started the POV calibration
	     */
	    if( pcv->cState < JCS_POV_MOVEUP ) {
		pcv->bUseTimer = TRUE;
	    }
	}
	break;
    }
	
    case WM_DESTROY:
    {
	LPCALVARS	pcv;
	pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
	DoFree( pcv );
	break;
    }
	
    case WM_INITDIALOG:
    {
	LPCALVARS	pcv;

	rc = joyCalibrateInitDialog( hwnd, lParam );
	if( !rc ) {
	    pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
	    if( pcv != NULL && pcv->bHasTimer ) {
		KillTimer( hwnd, TIMER_ID );
		pcv->bHasTimer = FALSE;
	    }
	    EndDialog( hwnd, 0 );
	}
	return FALSE;
    }

    case WM_PAINT:
    {
	LPCALVARS	pcv;
	pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
    	CauseRedraw( &pcv->ji, FALSE );
	return FALSE;
    }

    case WM_COMMAND:
    {
	int 		id;
	LPCALVARS	pcv;

	pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
	id = GET_WM_COMMAND_ID(wParam, lParam);
	switch( id ) {
	case IDC_JOYTEST:
	{
	    BOOL		timeon;

	    timeon = pcv->bUseTimer;
	    pcv->bUseTimer = FALSE;
	    DoTest( pcv->pgv, hwnd, FixCustomPOVType, pcv );
	    pcv->bUseTimer = timeon;
	    break;
	}
	case IDCANCEL:
	    // fall through
	case IDC_JOYCALDONE:
	    if( pcv->bHasTimer ) {
		KillTimer( hwnd, TIMER_ID );
		pcv->bHasTimer = FALSE;
	    }
	    {
		LPJOYREGHWCONFIG	pcfg;
		pcfg = &pcv->pgv->joyHWCurr;
	    }
	    EndDialog( hwnd, (id == IDC_JOYCALDONE) );
	    break;
	case IDC_JOYPICKPOV:
	    if( !tryPOV( pcv, hwnd ) ) {
		HWND	hwb;
		hwb = GetDlgItem( hwnd, IDC_JOYPICKPOV );
		ShowWindow( hwb, SW_HIDE );
		EnableWindow( hwb, FALSE );
	    }
	    break;

	case IDC_JOYCALNEXT:
	    pcv->bUseTimer = TRUE;
	    joyCalStateSkip( pcv, hwnd );
	    break;

	case IDC_JOYCALBACK:
	    pcv->bUseTimer = TRUE;
	    joyCalStateBack( pcv, hwnd );
	    break;
	    
	default:
	    break;
	}
	break;
    }
    default:
	break;
    }
    return FALSE;

} /* CalibrateProc */

/*
 * DoCalibrate - do the calibration dialog
 */
void DoCalibrate( LPGLOBALVARS pgv, HWND hwnd )
{
    JOYREGHWCONFIG	save_joycfg;
    int			rc;
    int			id;

    /*
     * save the current config, and then add the rudder if it is present
     */
    save_joycfg = pgv->joyHWCurr;

    /*
     * if this is a custom joystick, then don't assume anything
     * about how the POV is set up
     */
    if( pgv->joyHWCurr.dwType == JOY_HW_CUSTOM ) {
	pgv->bOrigPOVIsPoll = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_POVISPOLL);
	pgv->bOrigPOVIsButtonCombos = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_POVISBUTTONCOMBOS);
	pgv->joyHWCurr.hws.dwFlags &= ~(JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS);
    }

    /*
     * update the registry with our new joystick info
     */
    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

    if( pgv->joyHWCurr.hws.dwFlags & (JOY_HWS_HASU|JOY_HWS_HASV) ) {
	id = IDD_JOYCALIBRATE1;
    } else {
	id = IDD_JOYCALIBRATE;
    }
    rc = DialogBoxParam((HINSTANCE)GetWindowLong( hwnd, GWL_HINSTANCE ),
		    MAKEINTRESOURCE( id ), hwnd, CalibrateProc, (LONG) pgv );

    /*
     * update the registry with the new info or the old info
     */
    if( rc ) {
	PropSheet_Changed( GetParent(hwnd), hwnd );
    } else {
	pgv->joyHWCurr = save_joycfg;
    }
    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

} /* DoCalibrate */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\joycpl.h ===
//****************************************************************************
//
//  File:       joycpl.h
//  Content:    Joystick cpl header file
//  History:
//   Date	By	Reason
//   ====	==	======
//   29-nov-94	craige	initial implementation
//   15-dec-94	craige	allow N joysticks
//
//  Copyright (c) Microsoft Corporation 1994, 1995
//
//****************************************************************************
#ifndef __JOYCPL_INCLUDED__
#define __JOYCPL_INCLUDED__

#include <windows.h>
#include <windowsx.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <stdlib.h>
#include <regstr.h>
#include <cpl.h>
#include "rcids.h"                      

//#define WANT_SHEETS

#ifdef DEBUG
    void cdecl dprintf( LPSTR szFormat, ... );
    #define DPF	dprintf
#else
    #define DPF 1 ? (void)0 : (void)
#endif

/*
 * misc. defines
 */
#define HASJOY 		0x01
#define HASRUDDERMAYBE	0x02

#define ACTIVE_COLOR	RGB( 255, 0, 0 )
#define INACTIVE_COLOR	RGB( 128, 0, 0 )

#define TIMER_ID	1

#define JOYPOLLTIME	25		// time between polls in milliseconds
#define JOYCHECKTIME	2500		// time between hw check in milliseconds
#define MAX_STR		256		// max size for string resources
#define ALL_BUTTONS	(JOY_BUTTON1|JOY_BUTTON2|JOY_BUTTON3|JOY_BUTTON4)

#define GETKEYNAME( pgv, str, keystr ) wsprintf( str, keystr, pgv->iJoyId+1 )

#define JOYMOVE_DRAWXY	0x00000001
#define JOYMOVE_DRAWR	0x00000002
#define JOYMOVE_DRAWZ	0x00000004
#define JOYMOVE_DRAWU	0x00000008
#define JOYMOVE_DRAWV	0x00000010
#define JOYMOVE_DRAWALL	JOYMOVE_DRAWXY | JOYMOVE_DRAWR | JOYMOVE_DRAWZ | \
			JOYMOVE_DRAWU | JOYMOVE_DRAWV

#define RANGE_MIN	0
#define RANGE_MAX	65535

#define REGSTR_PATH_JOYSTICK         REGSTR_PATH_PRIVATEPROPERTIES "\\Joystick"
#define REGSTR_VAL_JOYTYPES          "Show Predefined Types"

/*
 * calibration strings defined by an OEM in the registry
 */
enum {
    CALSTR1=0,
    CALSTR2,
    CALSTR3,
    CALSTR4,
    CALSTR5,
    CALSTR6,
    CALSTR7,
    CALSTR8,
    CALSTR9,
    CALSTR10,
    CALSTR11,
    CALSTR12,
    CALSTR_END
};
#define NUM_CAL_STRS	CALSTR_END

/*
 * structure for holding all OEM data in the registry
 */
typedef struct {
    LPSTR		keyname;
    LPSTR		ident_string;
    LPSTR		vxd_name;
    LPSTR		xy_label;
    LPSTR		z_label;
    LPSTR		r_label;
    LPSTR		u_label;
    LPSTR		v_label;
    LPSTR		pov_label;
    LPSTR		testmove_desc;
    LPSTR		testbutton_desc;
    LPSTR		testmove_cap;
    LPSTR		testbutton_cap;
    LPSTR		testwin_cap;
    LPSTR		cal_cap;
    LPSTR		calwin_cap;
    LPSTR		cal_strs[NUM_CAL_STRS];
    JOYREGHWSETTINGS	hws;
} OEMLIST;

/*
 * generic joystick data
 */
typedef struct {
    LPJOYREGHWCONFIG	joyHWDefaults;
    OEMLIST		*oemList;
    int			oemCount;
    BOOL		bHasUserVals;
    BOOL		bDeleteUserVals;
    JOYREGUSERVALUES	userVals;
    LPSTR		regCfgKey;
    LPSTR		regCurrCfgKey;
    LPSTR		regSettingsCfgKey;
    HBRUSH		hbUp;
    HBRUSH		hbDown;
    BOOL		bHasTimer;
    BOOL		bUseTimer;
    #if !defined( WANT_SHEETS )
	struct _GLOBALVARS *pgvlist;
    #endif
    BOOL		bResetUserVals;
    BOOL		bHasNonStandardUserVals;
} JOYDATA, *LPJOYDATA;

/*
 * structure passed to each sheet
 */
typedef struct {
    LPJOYDATA	pjd;
    int		iJoyId;
} JOYDATAPTR, *LPJOYDATAPTR;

/*
 * structure defining all variables used globally by a tab
 */
typedef struct _GLOBALVARS {
    LPJOYDATA		pjd;
    JOYREGHWCONFIG	joyHWCurr;
    JOYREGHWCONFIG	joyHWOrig;
    JOYRANGE		joyRange;
    BOOL		bOrigPOVIsPoll;
    BOOL		bOrigPOVIsButtonCombos;
    DWORD		dwMaxAxes;
    int			iJoyId;
    int                 cJoystickTypes;
    /* these vars only used by the sheet */
    unsigned 		joyActiveFlags;
} GLOBALVARS, *LPGLOBALVARS;

/*
 * function prototypes
 */
/* joycal.c */
void DoCalibrate( LPGLOBALVARS pgv, HWND hwnd );

/* joycpl.c */
BOOL CALLBACK JoystickDlg( HWND	hwnd, UINT umsg, WPARAM wParam, LPARAM lParam);
LPVOID DoAlloc( DWORD size );
void DoFree( LPVOID ptr );
void RegistryUpdated( LPGLOBALVARS pgv );
void GetDevCaps( LPGLOBALVARS pgv );
void RegSaveCurrentJoyHW( LPGLOBALVARS pgv );
LPJOYDATA JoystickDataInit( void );
void JoystickDataFini( LPJOYDATA pjd );
#ifdef DEBUG
void cdecl MBOX(LPSTR szFormat, ...);
#endif

/* joymisc.c */
BOOL JoyError( HWND hwnd );
void ChangeIcon( HWND hwnd, int idi, int idc );
void CauseRedraw( LPJOYINFOEX pji, BOOL do_buttons );
void SetOEMText( LPGLOBALVARS pgv, HWND hwnd, BOOL istest );
void ShowControls( LPJOYREGHWCONFIG pcfg, HWND hwnd );
void DoJoyMove( LPGLOBALVARS pgv, HWND hwnd, LPJOYINFOEX pji, LPJOYINFOEX poji, DWORD drawflags );

/* joytest.c */
typedef void (*LPUPDCFGFN)( LPVOID parm );
void DoTest( LPGLOBALVARS pgv, HWND hwnd, LPUPDCFGFN pupdcfgfn, LPVOID pparm );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\joytest.c ===
//****************************************************************************
//
//  File:       joytest.c
//  Content:    Joystick test dialog
//  History:
//   Date	By	Reason
//   ====	==	======
//   11-dec-94	craige	split out of joycpl.c; some tweaks
//   15-dec-94	craige	allow N joysticks
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************

#include "joycpl.h"

/*
 * variables used by test process
 */
typedef struct {
    LPGLOBALVARS	pgv;
    MMRESULT		mmr_capture;
    HWND		hwnd;
    BOOL		bHasTimer;
    BOOL		bUseTimer;
    int			iButtonShift;
    JOYINFOEX		ji;
} test_vars, *LPTESTVARS;

/*
 * fillButton - light up a specific button
 */
static void fillButton( LPGLOBALVARS pgv, HWND hwnd, int id, BOOL isup )
{
    HWND	hwb;
    RECT	r;
    HDC		hdc;

    hwb = GetDlgItem( hwnd, id );
    if( hwb == NULL ) {
	return;
    }
    hdc = GetDC( hwb );
    if( hdc == NULL ) {
	return;
    }
    GetClientRect( hwb, &r );
    if( isup ) {
	FillRect( hdc, &r, pgv->pjd->hbUp );
    } else {
	FillRect( hdc, &r, pgv->pjd->hbDown );
    }
    ReleaseDC( hwb, hdc );

} /* fillButton */

/*
 * doTestButton - try to light the relevant buttons
 */
static void doTestButton( LPTESTVARS ptv, HWND hwnd, LPJOYINFOEX pji )
{

    if( (ptv->ji.dwButtons & JOY_BUTTON1) != (pji->dwButtons & JOY_BUTTON1) ) {
	fillButton( ptv->pgv, hwnd, IDC_JOYB1+ptv->iButtonShift,
				pji->dwButtons & JOY_BUTTON1 );
    }
    if( (ptv->ji.dwButtons & JOY_BUTTON2) != (pji->dwButtons & JOY_BUTTON2) ) {
	fillButton( ptv->pgv, hwnd, IDC_JOYB2+ptv->iButtonShift,
				pji->dwButtons & JOY_BUTTON2 );
    }
    if( ptv->iButtonShift == 0 ) {
	if( (ptv->ji.dwButtons & JOY_BUTTON3) != (pji->dwButtons & JOY_BUTTON3) ) {
	    fillButton( ptv->pgv, hwnd, IDC_JOYB3, pji->dwButtons & JOY_BUTTON3 );
	}
	if( (ptv->ji.dwButtons & JOY_BUTTON4) != (pji->dwButtons & JOY_BUTTON4) ) {
	    fillButton( ptv->pgv, hwnd, IDC_JOYB4, pji->dwButtons & JOY_BUTTON4 );
	}
    }
    ptv->ji.dwButtons = pji->dwButtons;

} /* doTestButton */

/*
 * doTestPOV - try to light the POV indicators
 */
static void doTestPOV( LPTESTVARS ptv, HWND hwnd, LPJOYINFOEX pji )
{
    int		idi;

    if( ptv->ji.dwPOV != pji->dwPOV ) {
	idi = IDI_JOYPOV_NONE;
	if( pji->dwPOV == JOY_POVFORWARD ) {
	    idi = IDI_JOYPOV_UP;
	} else if( pji->dwPOV == JOY_POVBACKWARD ) {
	    idi = IDI_JOYPOV_DOWN;
	} else if( pji->dwPOV == JOY_POVLEFT ) {
	    idi = IDI_JOYPOV_LEFT;
	} else if( pji->dwPOV == JOY_POVRIGHT ) {
	    idi = IDI_JOYPOV_RIGHT;
	}
    	ChangeIcon( hwnd, idi, IDC_JOYPOV );
    }
    ptv->ji.dwPOV = pji->dwPOV;

} /* doTestPOV */

/*
 * joyTestInitDialog - init the testing dialog
 */
static BOOL joyTestInitDialog( HWND hwnd, LPARAM lParam)
{
    HINSTANCE		hinst;
    char		str[MAX_STR];
    LPJOYREGHWCONFIG	pcfg;
    LPTESTVARS		ptv;
    LPGLOBALVARS	pgv;

    /*
     * create test vars
     */
    ptv = DoAlloc( sizeof( test_vars ) );
    SetWindowLong( hwnd, DWL_USER, (LONG) ptv );
    if( ptv == NULL ) {
	return FALSE;
    }
    pgv = (LPGLOBALVARS) lParam;
    ptv->pgv = pgv;
    ptv->hwnd = hwnd;

    /*
     * set dialog text based on OEM strings
     */
    SetOEMText( pgv, hwnd, TRUE );

    /*
     * customize test dialog's button display
     */
    pcfg = &pgv->joyHWCurr;
    if( pcfg->hws.dwNumButtons <= 2 ) {
	ptv->iButtonShift = 1;
	ShowWindow( GetDlgItem( hwnd, IDC_JOYB1 ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYB4 ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYB1_LABEL ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYB4_LABEL ), SW_HIDE );
	hinst = GetWindowInstance( hwnd );
	if( LoadString( hinst, IDS_JOYBUTTON1, str, sizeof( str ) ) ) {
	    SetWindowText( GetDlgItem( hwnd, IDC_JOYB2_LABEL ), str );
	}
	if( LoadString( hinst, IDS_JOYBUTTON2, str, sizeof( str ) ) ) {
	    SetWindowText( GetDlgItem( hwnd, IDC_JOYB3_LABEL ), str );
	}
    } else {
	ptv->iButtonShift = 0;
    }

    ShowControls( pcfg, hwnd );
    
    /*
     * other misc setup
     */
    ptv->bHasTimer = SetTimer( hwnd, TIMER_ID, JOYPOLLTIME, NULL );
    ptv->bUseTimer = TRUE;
    if( !ptv->bHasTimer ) {
	DPF( "No timer for joystick test!\r\n" );
	return FALSE;
    }
    
    return TRUE;

} /* joyTestInitDialog */

/*
 * context help for the test dialog
 */
    const static DWORD aTestHelpIDs[] = {  // Context Help IDs
        IDC_GROUPBOX,         IDH_JOYSTICK_GROUPBOX,
        IDC_JOYLIST1_LABEL,   IDH_JOYSTICK_TEST_RANGE,
        IDC_JOYLIST1,         IDH_JOYSTICK_TEST_RANGE,
        IDC_JOYLIST2_LABEL,   IDH_JOYSTICK_TEST_THROTTLE,
        IDC_JOYLIST2,         IDH_JOYSTICK_TEST_THROTTLE,
        IDC_JOYLIST3_LABEL,   IDH_JOYSTICK_TEST_RUDDER,
        IDC_JOYLIST3,         IDH_JOYSTICK_TEST_RUDDER,
        IDC_JOYPOV_LABEL,     IDH_JOYSTICK_TEST_POV,
        IDC_JOYPOV,           IDH_JOYSTICK_TEST_POV,
        IDC_TEXT_1,           NO_HELP,
        IDC_TEXT_2,           NO_HELP,
        IDC_ICON_1,           NO_HELP,
        IDC_GROUPBOX_2,       IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB1_LABEL,      IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB2_LABEL,      IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB3_LABEL,      IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB4_LABEL,      IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB1,            IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB2,            IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB3,            IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYB4,            IDH_JOYSTICK_TEST_BUTTONS,
        IDC_JOYLIST4_LABEL,   IDH_JOYSTICK_TEST_THROTTLE,
        IDC_JOYLIST4,         IDH_JOYSTICK_TEST_THROTTLE,
        IDC_JOYLIST5_LABEL,   NO_HELP,
        IDC_JOYLIST5,         NO_HELP,
        0, 0
    };

/*
 * TestProc - callback procedure for joystick test dialog
 */
BOOL CALLBACK TestProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    BOOL	rc;
    switch( umsg ) {
    case WM_TIMER:
    {
	LPTESTVARS	ptv;
	ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );

    	if( ptv->bUseTimer ) {
	    JOYINFOEX	ji;
	    MMRESULT	rc;
	    ptv->bUseTimer = FALSE;
	    ji.dwSize = sizeof( ji );
//	    ji.dwFlags = JOY_RETURNALL | JOY_USEDEADZONE | JOY_RETURNCENTERED;
	    ji.dwFlags = JOY_RETURNALL | JOY_RETURNCENTERED;
	    rc = joyGetPosEx( ptv->pgv->iJoyId, &ji );
	    if( rc == JOYERR_NOERROR ) {
		DoJoyMove( ptv->pgv, hwnd, &ji, &ptv->ji, JOYMOVE_DRAWALL );
		doTestButton( ptv, hwnd, &ji );
		doTestPOV( ptv, hwnd, &ji );
		ptv->bUseTimer = TRUE;
	    } else {
		if( JoyError( hwnd ) ) {
		    ptv->bUseTimer = TRUE;
		}
	    }
	}
	break;
    }
	
    case WM_DESTROY:
    {
	LPTESTVARS	ptv;
	ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
	DoFree( ptv );
	break;
    }
	
    case WM_INITDIALOG:
	rc = joyTestInitDialog( hwnd, lParam );
	if( !rc ) {
	    EndDialog( hwnd, 0 );
	}
	return FALSE;

    case WM_PAINT:
    {
	LPTESTVARS	ptv;
	ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
    	CauseRedraw( &ptv->ji, TRUE );
	return FALSE;
    }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, cszHelpFile,
            HELP_WM_HELP, (DWORD)(LPSTR) aTestHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, cszHelpFile, HELP_CONTEXTMENU,
            (DWORD)(LPVOID) aTestHelpIDs);
        return TRUE;

    case WM_COMMAND:
    {
	int 		id;
	LPTESTVARS	ptv;

	ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
	id = GET_WM_COMMAND_ID(wParam, lParam);
	switch( id ) {
	case IDCANCEL:
	case IDOK:
	    if( ptv->bHasTimer ) {
		KillTimer( hwnd, TIMER_ID );
	    }
	    EndDialog(hwnd, (id == IDOK));
	    break;
	    
	default:
	    break;
	}
	break;
    }
    default:
	break;
    }
    return FALSE;

} /* TestProc */

/*
 * DoTest - do the test dialog
 */
void DoTest( LPGLOBALVARS pgv, HWND hwnd, LPUPDCFGFN pupdcfgfn, LPVOID pparm )
{
    JOYREGHWCONFIG	save_joycfg;
    int			id;

    /*
     * save the current config, and then update config if required
     */
    save_joycfg = pgv->joyHWCurr;
    if( pupdcfgfn != NULL ) {
	pupdcfgfn( pparm );
    }

    /*
     * update the registry with our new joystick info
     */
    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

    /*
     * process the test dialog
     */
    if( pgv->joyHWCurr.hws.dwFlags & (JOY_HWS_HASU|JOY_HWS_HASV) ) {
	id = IDD_JOYTEST1;
    } else {
	id = IDD_JOYTEST;
    }
    DialogBoxParam( (HINSTANCE)GetWindowLong( hwnd, GWL_HINSTANCE ),
		MAKEINTRESOURCE( id ), hwnd, TestProc, (LONG) pgv );

    /*
     * restore the old registry info
     */
    pgv->joyHWCurr = save_joycfg;
    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

} /* DoTest */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\main.c ===
//****************************************************************************
//
//  File:       main.c
//  Content:    main cpl control code
//  History:
//   Date	By	Reason
//   ====	==	======
//   29-nov-94	craige	initial implementation
//   11-dec-94	craige	added ShowJoyCPL
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************
#include "joycpl.h"

HINSTANCE hInstance = NULL;
LPCTSTR cszHelpFile = TEXT("joy.hlp");

#define JOYSTICK_CPL	0
#define MAX_PAGES	16	/* maximum number of joysticks supported */

#ifdef DEBUG
void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char str[256];

    wsprintf( str, "JOYCPL: " );
    wvsprintf( str+lstrlen( str ), szFormat, (LPVOID)(&szFormat+1) );

    OutputDebugString( str );
}
#endif

/*
 * LibMain - main entry point for DLL
 */
BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
    	hInstance = hDll;
    	DPF( "DLL_PROCESS_ATTACH: hInstance = %08lx\r\n" );
    	break;
    case DLL_PROCESS_DETACH:
    	DPF( "DLL_PROCESS_DETACH: hInstance = %08lx\r\n" );
    	break;
    case DLL_THREAD_DETACH:
    	DPF( "DLL_THREAD_DETACH: hInstance = %08lx\r\n" );
        break;
    case DLL_THREAD_ATTACH:
    	DPF( "DLL_THREAD_DETACH: hInstance = %08lx\r\n" );
    	break;
    default:
    	break;
    }

    return TRUE;

} /* LibMain */

/*
 * startJoyCPL - start the joystick CPL
 */
static void startJoyCPL( HWND hwnd )
{
    PROPSHEETHEADER	psh;
    char		title[MAX_STR];
    PROPSHEETPAGE	psp;
    LPJOYDATA		pjd;
    #if defined( WANT_SHEETS )
	JOYDATAPTR	jdp[MAX_PAGES];
	HPROPSHEETPAGE	hpsp[MAX_PAGES];
	int		numsheets;
	int		i;
	char		str[MAX_STR];
    #else
	JOYDATAPTR	jdp;
	HPROPSHEETPAGE	hpsp[1];
    #endif

    #if defined(WANT_SHEETS)
	numsheets = joyGetNumDevs();
	if( numsheets == 0 ) {
	    return;
	}
    #endif

    InitCommonControls();
    LoadString( hInstance, IDS_JOY, title, sizeof(title));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hwndParent = hwnd;
    psh.hInstance = hInstance;
    psh.pszCaption = (LPSTR) MAKEINTRESOURCE( IDS_JOY );
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = hpsp;

    psp.dwSize = sizeof( PROPSHEETPAGE );
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = hInstance;
    psp.pszTemplate = MAKEINTRESOURCE( IDD_JOYSTICK );
    psp.pszIcon = NULL;
    psp.pfnDlgProc = JoystickDlg;
    psp.pfnCallback = NULL;
    psp.pcRefParent = NULL;
    pjd = JoystickDataInit();
    #if defined(WANT_SHEETS)
	for( i=0;i<numsheets;i++ ) {
	    wsprintf( str, "%s %d", title, i+1 );
	    psp.pszTitle = str;
	    jdp[i].pjd = pjd;
	    jdp[i].iJoyId = i;
	    psp.lParam = (LPARAM) &jdp[i];
	    if( psh.phpage[ psh.nPages ] = CreatePropertySheetPage( &psp ) ) {
		psh.nPages++;
		DPF( "PropertySheetPage()\r\n" );
	    }
	}
    #else
	psp.pszTitle = title;
	jdp.pjd = pjd;
	jdp.iJoyId = JOYSTICKID1;
	psp.lParam = (LPARAM) &jdp;
	if( psh.phpage[ psh.nPages ] = CreatePropertySheetPage( &psp ) ) {
	    psh.nPages++;
	    DPF( "PropertySheetPage()\r\n" );
	}
    #endif
    if( psh.nPages ) {
	PropertySheet( &psh );
	DPF( "PropertySheet()\r\n" );
    }
    JoystickDataFini( pjd );

} /* startJoyCPL */

/*
 * ShowJoyCPL - exported function to allow apps to show the joystick CPL
 */
void WINAPI ShowJoyCPL( HWND hwnd )
{
    HWND    hwnd_parent;

    hwnd_parent = hwnd;
    if( hwnd != NULL ) {
	if( GetWindowLong( hwnd, GWL_EXSTYLE ) & WS_EX_TOPMOST ) {
	    hwnd_parent = NULL;
	}
    }
    startJoyCPL( hwnd_parent );

} /* ShowJoyCPL */

/*
 * CPlApplet - applet manager
 */
LONG WINAPI CPlApplet(HWND hwnd, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    LPCPLINFO		pcplinfo;
    LPNEWCPLINFO	pnewcplinfo;

    switch( uMsg ) {
    case CPL_INIT:
    	DPF( "CPL_INIT:\r\n" );
        // return TRUE; // (fall through to CPL_GETCOUNT--fail if no joysticks)
    
    case CPL_GETCOUNT:
        /*
	 * number  of applets in this DLL - 1 per device
	 * no joystick devices installed (i.e., no CPL's to display)
	 */
	if( joyGetNumDevs() ) {
	    DPF( "CPL_GETCOUNT = 1\r\n" );
	    return 1;
	} else {
	    DPF( "CPL_GETCOUNT = 0\r\n" );
	    return 0;
	}

    case CPL_INQUIRE:
        /*
	 * Fill the CPLINFO with the pertinent information for each applet
	 */
    	DPF( "CPL_INQUIRE:\r\n" );
	pcplinfo = (LPCPLINFO) lParam2;
        switch( lParam1 ) {
        case JOYSTICK_CPL:
            pcplinfo->idIcon = CPL_DYNAMIC_RES;
            pcplinfo->idName = CPL_DYNAMIC_RES;
            pcplinfo->idInfo = CPL_DYNAMIC_RES;
            break;
        }
        pcplinfo->lData = 0L;
        return TRUE;

    case CPL_NEWINQUIRE:
    	DPF( "CPL_NEWINQUIRE\r\n" );
    	pnewcplinfo = (LPNEWCPLINFO) lParam2;
    	switch( lParam1 ) {
	case JOYSTICK_CPL:
	    pnewcplinfo->hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_JOYSTICK));
	    LoadString(hInstance, IDS_JOY, pnewcplinfo->szName,
	    			sizeof(pnewcplinfo->szName));
	    LoadString( hInstance, IDS_JOYINFO, pnewcplinfo->szInfo,
	    			sizeof(pnewcplinfo->szInfo) );
	    DPF( "hIcon = %04x\r\n", pnewcplinfo->hIcon );
	    DPF( "szName = \"%s\"\r\n", pnewcplinfo->szName );
	    DPF( "szInfo = \"%s\"\r\n", pnewcplinfo->szInfo );
	    break;
	}
        pnewcplinfo->dwHelpContext = 0;
        pnewcplinfo->dwSize = sizeof( NEWCPLINFO );
        pnewcplinfo->lData = 0L;
        pnewcplinfo->szHelpFile[0] = 0;
        return TRUE;

    case CPL_DBLCLK:
    	DPF( "CPL_DBLCLK\r\n" );
        switch( lParam1 ) {
        case JOYSTICK_CPL:
	    startJoyCPL( hwnd );
            break;
        }
        break;      

    case CPL_EXIT:
    	DPF( "CPL_EXIT\r\n" );
        break;
            
    default:
        return 0L;
    }

    return 1L;

} /* CPlApplet */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\cparrow.c ===
/* Revision history:
   March 92 Ported to 16/32 common code by Laurie Griffiths (LaurieGr)
*/
/*--------------------------------------------------------------------------*/

#include <windows.h>
#include <port1632.h>
#include "hack.h"

/*--------------------------------------------------------------------------*/

#define SZCODE  char _based(_segname("_CODE"))
#define TIMER_ID        1
#define MS_SCROLLTIME   150

/*--------------------------------------------------------------------------*/

static  HWND    hwndParent;
static  RECT    rcUp;
static  RECT    rcDown;
static  SZCODE  szArrowClass[] = "cpArrow";

static  UINT    uScroll;             /* gee, thanks for the helpful comment.  Laurie. */
static  UINT    uTimer;
static  BOOL    fKeyDown;

/*
 * fDownButton
 *
 * TRUE if we are dealing with the 'down arrow'.  FALSE if we are dealing
 * with the 'up arrow'.
 */
typedef enum tagArrowDirection {
        enumArrowUp,
        enumArrowDown
}       ARROWDIRECTION;
static  ARROWDIRECTION  ArrowType;

/*
 * fButton
 *
 * TRUE if the user pressed the left button down on the arrow window,
 * as long as cursor is still over that window and the left button
 * remains down.
 */
static  BOOL    fButton;

/*
 * fRealButton
 *
 * TRUE if the user pressed the left button down on the arrow window,
 * regardless of whether or not the cursor is still over the window, as
 * long as the left button remains down.
 */
static  BOOL    fRealButton;

/*--------------------------------------------------------------------------*/

static  void PASCAL NEAR KeyDown(
        HWND    hwnd,
        UINT    uKey)
{
        DWORD   dCoordinates;

        if (!fKeyDown && ((uKey == VK_DOWN) || (uKey == VK_UP))) {
                fKeyDown = TRUE;
                hwndParent = GetParent(hwnd);
                GetClientRect(hwnd, &rcUp);
                rcUp.bottom = (rcUp.top + rcUp.bottom) / 2 - 1;
                rcDown.top = rcUp.bottom + 1;
                if (uKey == VK_DOWN)
                        dCoordinates = MAKELONG(0, rcDown.top);
                else
                        dCoordinates = MAKELONG(0, rcUp.top);
                SendMessage(hwnd, WM_LBUTTONDOWN, (WPARAM)0, (LPARAM)dCoordinates);
        }
}

/*--------------------------------------------------------------------------*/

static  void PASCAL NEAR KeyUp(
        HWND    hwnd,
        UINT    uKey)
{
        if (fKeyDown && ((uKey == VK_DOWN) || (uKey == VK_UP))) {
                fKeyDown = FALSE;
                SendMessage(hwnd, WM_LBUTTONUP, (WPARAM)0, (LPARAM)0);
        }
}

/*--------------------------------------------------------------------------*/

static  void PASCAL NEAR LButtonDown(
        HWND    hwnd,
        int     iCoord)
{
        if (!fRealButton) {
                fButton = TRUE;
                fRealButton = TRUE;
                SetCapture(hwnd);
                hwndParent = GetParent(hwnd);
                GetClientRect(hwnd, &rcUp);
                CopyRect(&rcDown, &rcUp);
                rcUp.bottom = (rcUp.top + rcUp.bottom) / 2 - 1;
                rcDown.top = rcUp.bottom + 1;
                uScroll = (iCoord >= rcDown.top) ? SB_LINEDOWN : SB_LINEUP;
                ArrowType = (uScroll == SB_LINEDOWN) ? enumArrowDown : enumArrowUp;
#if defined(WIN16)
                SendMessage(hwndParent, WM_VSCROLL, (WPARAM)uScroll, MAKELPARAM(GetWindowWord(hwnd, GWW_ID), hwnd));
#else

                /* The NT version of WM_VSCROLL wants the scroll position.
                   (Actually the book is vague, maybe it only wants it for
                   SB_THUMBPOSITION and SB_THUMBTRACK)
                   However we may be able to fudge it anyway.
                   So long as the message is sent to a WNDPROC ported from
                   DOS it will not be looking for the scroll position in
                   other cases.  Neither book (DOS or NT) mentions stuffing
                   the ID in,  but the line above does so.
                   Fortunately, nobody looks at it!
                   Whenever it stuffs something into the LOWORD(lParam)
                   on DOS we use HIWORD(wParam) on NT
                */
                SendMessage( hwndParent
                           , WM_VSCROLL
                           , (WPARAM)uScroll
                           , (LPARAM)hwnd
                           );
#endif //WIN16
                uTimer = (UINT)SetTimer(hwnd, TIMER_ID, MS_SCROLLTIME, NULL);
                if (ArrowType == enumArrowDown)
                        InvalidateRect(hwnd, &rcDown, TRUE);
                else
                        InvalidateRect(hwnd, &rcUp, TRUE);
        }
}

/*--------------------------------------------------------------------------*/

static  void PASCAL NEAR MouseMove(
        HWND    hwnd,
        POINT   pt)
{
        // if they didn't left button down on us originally, ignore it;
        if (fRealButton) {
                BOOL    fGray;

                fGray = (((ArrowType == enumArrowDown) && PtInRect(&rcDown, pt)) || ((ArrowType == enumArrowUp) && PtInRect(&rcUp, pt)));
                // either not over the arrow window anymore, just came on top of window;
                if ((fButton && !fGray) || (!fButton && fGray)) {
                        fButton = !fButton;
                        InvalidateRect(hwnd, (ArrowType == enumArrowDown) ? &rcDown : &rcUp, TRUE);
                }
        }
}

/*--------------------------------------------------------------------------*/

static  void PASCAL NEAR LButtonUp(
        HWND    hwnd)
{
        if (fButton) {
                ReleaseCapture();
#if defined(WIN16)
                SendMessage(hwndParent, WM_VSCROLL, (WPARAM)SB_ENDSCROLL, MAKELPARAM(GetWindowWord(hwnd, GWW_ID), hwnd));
#else
                /* See comments about WM_VSCROLL earlier in file */
                SendMessage( hwndParent
                           , WM_VSCROLL
                           , (WPARAM)SB_ENDSCROLL
                           , (LPARAM)hwnd
                           );
#endif //WIN16
                fButton = FALSE;
                if (ArrowType == enumArrowDown)
                        InvalidateRect(hwnd, &rcDown, TRUE);
                else
                        InvalidateRect(hwnd, &rcUp, TRUE);
        }
        fRealButton = FALSE;
        if (uTimer) {
                KillTimer(hwnd, uTimer);
                uTimer = 0;
                ReleaseCapture();
        }
}

/*--------------------------------------------------------------------------*/

static  void PASCAL NEAR Paint(
        HWND    hwnd)
{
        PAINTSTRUCT     ps;

        BeginPaint(hwnd, &ps);
        if (IsWindowVisible(hwnd)) {
                RECT    rcArrow;
                RECT    rcHalf;
                UINT    uMiddle;
                HBRUSH  hbrOld;
                int     iLoop;
                BOOL    fCurrentButtonDown;
                HPEN    hpenOld;

                GetClientRect(hwnd, &rcArrow);
                FrameRect(ps.hdc, &rcArrow, (HBRUSH)GetStockObject(BLACK_BRUSH));
                InflateRect(&rcArrow, -1, -1);
                // Create the barrier between the two buttons...;
                uMiddle = rcArrow.top + (rcArrow.bottom - rcArrow.top) / 2 + 1;
                hbrOld = (HBRUSH)SelectObject(ps.hdc, (HGDIOBJ)CreateSolidBrush(COLOR_WINDOWFRAME));
                PatBlt(ps.hdc, 0, rcArrow.bottom / 2 - 1, rcArrow.right, 2, PATCOPY);
                DeleteObject(SelectObject(ps.hdc, (HGDIOBJ)hbrOld));
                // Draw the shadows and the face of the button...;
                for (iLoop = enumArrowUp; iLoop <= enumArrowDown; iLoop++) {
                        POINT   ptArrow[3];
                        DWORD   dwColor;

                        fCurrentButtonDown = (fButton && (iLoop == ArrowType));
                        // get the rectangle for the button half we're dealing with;
                        rcHalf.top = (iLoop == enumArrowDown) ? uMiddle : rcArrow.top;
                        rcHalf.bottom = (iLoop == enumArrowDown) ? rcArrow.bottom : uMiddle - 2;
                        rcHalf.right = rcArrow.right;
                        rcHalf.left = rcArrow.left;
                        // draw the highlight lines;
                        if (fCurrentButtonDown)
                                dwColor = GetSysColor(COLOR_BTNSHADOW);
                        else
                                dwColor = RGB(255, 255, 255);
                        hpenOld = SelectObject(ps.hdc, (HGDIOBJ)CreatePen(PS_SOLID, 1, dwColor));
                        MMoveTo(ps.hdc, rcHalf.right - 1, rcHalf.top);
                        LineTo(ps.hdc, rcHalf.left, rcHalf.top);
                        LineTo(ps.hdc, rcHalf.left, rcHalf.bottom - 1 + fCurrentButtonDown);
                        DeleteObject(SelectObject(ps.hdc, (HGDIOBJ)hpenOld));
                        if (!fCurrentButtonDown) {
                                // draw the shadow lines;
                                hpenOld = SelectObject(ps.hdc, (HGDIOBJ)CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
                                MMoveTo(ps.hdc, rcHalf.right - 1, rcHalf.top);
                                LineTo(ps.hdc, rcHalf.right - 1, rcHalf.bottom - 1);
                                LineTo(ps.hdc, rcHalf.left - 1, rcHalf.bottom - 1);
                                MMoveTo(ps.hdc, rcHalf.right - 2, rcHalf.top + 1);
                                LineTo(ps.hdc, rcHalf.right - 2, rcHalf.bottom - 2);
                                LineTo(ps.hdc, rcHalf.left, rcHalf.bottom - 2);
                                DeleteObject(SelectObject(ps.hdc, hpenOld));
                        }
                        // calculate the arrow triangle coordinates;
                        ptArrow[0].x = rcHalf.left + (rcHalf.right - rcHalf.left) / 2 + fCurrentButtonDown;
                        ptArrow[0].y = rcHalf.top + 2 + fCurrentButtonDown;
                        ptArrow[1].y = ptArrow[2].y = rcHalf.bottom - 4 + fCurrentButtonDown;
                        if (ptArrow[0].y > ptArrow[1].y)
                                ptArrow[1].y = ptArrow[2].y = ptArrow[0].y;
                        ptArrow[1].x = ptArrow[0].x - (ptArrow[1].y - ptArrow[0].y);
                        ptArrow[2].x = ptArrow[0].x + (ptArrow[1].y - ptArrow[0].y);
                        // flip over if we're drawing bottom button;
                        if (iLoop == enumArrowDown) {
                                ptArrow[2].y = ptArrow[0].y;
                                ptArrow[0].y = ptArrow[1].y;
                                ptArrow[1].y = ptArrow[2].y;
                        }
                        if (IsWindowEnabled(hwnd))
                                dwColor = GetSysColor(COLOR_BTNTEXT);
                        else
                                dwColor = GetSysColor(COLOR_GRAYTEXT);
                        // draw the triangle;
                        hbrOld = SelectObject(ps.hdc, (HGDIOBJ)CreateSolidBrush(dwColor));
                        hpenOld = SelectObject(ps.hdc, CreatePen(PS_SOLID, 1, dwColor));
                        Polygon(ps.hdc, ptArrow, 3);
                        DeleteObject(SelectObject(ps.hdc, (HGDIOBJ)hbrOld));
                        DeleteObject(SelectObject(ps.hdc, (HGDIOBJ)hpenOld));
                }
        }
        EndPaint(hwnd, &ps);
}

/*--------------------------------------------------------------------------*/

LRESULT PASCAL FAR _loadds ArrowControlProc(
        HWND    hwndArrow,
        UINT    wMsg,
        WPARAM  wParam,
        LPARAM  lParam)
{
        switch (wMsg) {
        case WM_SETFOCUS:
        case WM_KILLFOCUS:
        case WM_ENABLE:
        case WM_SYSCOLORCHANGE:
                InvalidateRect(hwndArrow, NULL, TRUE);
                UpdateWindow(hwndArrow);
                break;
        case WM_GETDLGCODE:
                return (LRESULT)DLGC_WANTARROWS; // | DLGC_UNDEFPUSHBUTTON;
        case WM_KEYDOWN:
                KeyDown(hwndArrow, (UINT)wParam);
                break;
        case WM_KEYUP:
                KeyUp(hwndArrow, (UINT)wParam);
                break;
        case WM_LBUTTONDOWN:
                LButtonDown(hwndArrow, HIWORD(lParam));   // y coord
                break;
        case WM_MOUSEMOVE:
                {    POINT pt;
                     LONG2POINT(lParam,pt);
                     MouseMove(hwndArrow, pt);
                }
                break;
        case WM_LBUTTONUP:
                LButtonUp(hwndArrow);
                break;
        case WM_TIMER:
                if (fButton)
#if defined(WIN16)
                        SendMessage(hwndParent, WM_VSCROLL, (WPARAM)uScroll, MAKELPARAM(GetWindowWord(hwndArrow, GWW_ID), hwndArrow));
#else
                        /* See comments about WM_VSCROLL earlier in file */
                        SendMessage( hwndParent
                                   , WM_VSCROLL
                                   , (WPARAM)uScroll
                                   , (LPARAM)hwndArrow
                                   );
#endif //WIN16
                break;
        case WM_PAINT:
                Paint(hwndArrow);
                break;
        default:
                return DefWindowProc(hwndArrow, wMsg, wParam, lParam);
        }
        return (LRESULT)0;
}

/*--------------------------------------------------------------------------*/

BOOL    PASCAL FAR RegisterArrowClass(
        HINSTANCE       hInstance)
{
        WNDCLASS        wcArrow;

        wcArrow.lpszClassName = szArrowClass;
        wcArrow.hInstance = hInstance;
        wcArrow.lpfnWndProc = ArrowControlProc;
        wcArrow.hCursor = LoadCursor(NULL, IDC_ARROW);
        wcArrow.hIcon = NULL;
        wcArrow.lpszMenuName = NULL;
        wcArrow.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wcArrow.style = CS_HREDRAW | CS_VREDRAW;
        wcArrow.cbClsExtra = 0;
        wcArrow.cbWndExtra = 0;
        return RegisterClass((LPWNDCLASS)&wcArrow);
}

/*--------------------------------------------------------------------------*/

void    PASCAL FAR UnregisterArrowClass(
        HINSTANCE       hInstance)
{
        UnregisterClass(szArrowClass, hInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\rcids.h ===
//****************************************************************************
//
//  File:	rcids.h
//  Content:	resource constants
//  History:
//   Date	By	Reason
//   ====	==	======
//   29-nov-94	craige	split from mmse
//   15-dec-94	craige	allow N joysticks
//   05-jan-95	craige	new centering confirmation messages
//   04-mar-95	craige	bug 10761 - separate strings for pluralization
//
//  Copyright (c) Microsoft Corporation 1994, 1995
//
//****************************************************************************
#ifndef __RCIDS_INCLUDED__
#define __RCIDS_INCLUDED__

#include "joyhelp.h"

#define ID_GENERIC_START		0x1000

/*
 * Icons
 */
#define IDI_JOYSTICK			100
#define IDI_JOYBTN			101
#define IDI_JOYPOV_NONE			102
#define IDI_JOYPOV_UP			103
#define IDI_JOYPOV_DOWN			104
#define IDI_JOYPOV_LEFT			105
#define IDI_JOYPOV_RIGHT		106
#define IDI_JOYPOV_GRAYED		107

/*
 * strings
 */
#define IDS_GENERIC_START		(ID_GENERIC_START)
#define IDS_GENERIC_STRINGS		(IDS_GENERIC_START)

#define IDS_JOYINFO			(IDS_GENERIC_STRINGS + 0x0001)
#define IDS_JOY				(IDS_GENERIC_STRINGS + 0x0002)
#define IDS_JOY2			(IDS_GENERIC_STRINGS + 0x0003)
#define IDS_JOY2S			(IDS_GENERIC_STRINGS + 0x0004)

#define IDS_JOYSTICK_STRINGS		(IDS_GENERIC_START+0x0100)
#define IDS_JOYCALXY_CENTER		(IDS_JOYSTICK_STRINGS+0x0001)
#define IDS_JOYCALXY_MOVE		(IDS_JOYSTICK_STRINGS+0x0002)
#define IDS_JOYCALZ_MOVE		(IDS_JOYSTICK_STRINGS+0x0003)
#define IDS_JOYCALPOV_MOVE		(IDS_JOYSTICK_STRINGS+0x0004)
#define IDS_JOYCAL_UP			(IDS_JOYSTICK_STRINGS+0x0005)
#define IDS_JOYCAL_DOWN			(IDS_JOYSTICK_STRINGS+0x0006)
#define IDS_JOYCAL_LEFT			(IDS_JOYSTICK_STRINGS+0x0007)
#define IDS_JOYCAL_RIGHT		(IDS_JOYSTICK_STRINGS+0x0008)
#define IDS_JOYTESTCAPN			(IDS_JOYSTICK_STRINGS+0x0009)
/* 0x000a unused */
#define IDS_JOYBUTTON1			(IDS_JOYSTICK_STRINGS+0x000b)
#define IDS_JOYBUTTON2			(IDS_JOYSTICK_STRINGS+0x000c)
#define IDS_JOYCALCAPN			(IDS_JOYSTICK_STRINGS+0x000d)
/* 0x000e unused */
#define IDS_JOYUNPLUGGED		(IDS_JOYSTICK_STRINGS+0x000f)
#define IDS_JOYCALXY_MOVEYOKE		(IDS_JOYSTICK_STRINGS+0x0010)
#define IDS_JOYCAL_DONE			(IDS_JOYSTICK_STRINGS+0x0011)
#define IDS_JOYCALXY_MOVEGAMEPAD	(IDS_JOYSTICK_STRINGS+0x0012)
#define IDS_JOYCALXY_CENTERGAMEPAD	(IDS_JOYSTICK_STRINGS+0x0013)
#define IDS_JOYCALXY_CENTERYOKE		(IDS_JOYSTICK_STRINGS+0x0014)
#define IDS_JOYREADERROR		(IDS_JOYSTICK_STRINGS+0x0015)
#define IDS_JOYCALRUDDER_MOVE		(IDS_JOYSTICK_STRINGS+0x0016)
#define IDS_JOYCALXY_MOVECAR		(IDS_JOYSTICK_STRINGS+0x0017)
#define IDS_JOYCALXY_CENTERCAR		(IDS_JOYSTICK_STRINGS+0x0018)
#define IDS_JOYCALXY_CENTER2		(IDS_JOYSTICK_STRINGS+0x0019)
#define IDS_JOYCAL_YOKE			(IDS_JOYSTICK_STRINGS+0x001a)
#define IDS_JOYCAL_CAR			(IDS_JOYSTICK_STRINGS+0x001b)
#define IDS_JOYCAL_GAMEPAD		(IDS_JOYSTICK_STRINGS+0x001c)
#define IDS_JOYNOTPRESENT		(IDS_JOYSTICK_STRINGS+0x001d)
#define IDS_JOYCAL_NOTDONE		(IDS_JOYSTICK_STRINGS+0x001e)
#define IDS_JOYCALU_MOVE		(IDS_JOYSTICK_STRINGS+0x001f)
#define IDS_JOYCALV_MOVE		(IDS_JOYSTICK_STRINGS+0x0020)
#define IDS_JOYRESTARTMSG1		(IDS_JOYSTICK_STRINGS+0x0021)
#define IDS_JOYRESTARTMSG2		(IDS_JOYSTICK_STRINGS+0x0022)
#define IDS_JOYCALXY_CENTERGAMEPAD2	(IDS_JOYSTICK_STRINGS+0x0023)
#define IDS_JOYCALXY_CENTERYOKE2	(IDS_JOYSTICK_STRINGS+0x0024)
#define IDS_JOYCALXY_CENTERCAR2		(IDS_JOYSTICK_STRINGS+0x0025)
#define IDS_JOYCAL_YOKES		(IDS_JOYSTICK_STRINGS+0x0026)
#define IDS_JOYCAL_CARS			(IDS_JOYSTICK_STRINGS+0x0027)
#define IDS_JOYCAL_GAMEPADS		(IDS_JOYSTICK_STRINGS+0x0028)
#define IDS_JOYCALINDICATOR		(IDS_JOYSTICK_STRINGS+0x0029)
#define IDS_VAXIS_LABEL			(IDS_JOYSTICK_STRINGS+0x002a)
#define IDS_UAXIS_LABEL			(IDS_JOYSTICK_STRINGS+0x002b)
#define IDS_POVAXIS_LABEL		(IDS_JOYSTICK_STRINGS+0x002c)
#define IDS_ZAXIS_LABEL			(IDS_JOYSTICK_STRINGS+0x002d)
#define IDS_XYAXIS_LABEL		(IDS_JOYSTICK_STRINGS+0x002e)
#define IDS_RAXIS_LABEL 		(IDS_JOYSTICK_STRINGS+0x002f)    

#define IDS_JOYHW0			(IDS_JOYSTICK_STRINGS+0x0040)
#define IDS_JOYHW1			(IDS_JOYSTICK_STRINGS+0x0041)
#define IDS_JOYHW2			(IDS_JOYSTICK_STRINGS+0x0042)
#define IDS_JOYHW3			(IDS_JOYSTICK_STRINGS+0x0043)
#define IDS_JOYHW4			(IDS_JOYSTICK_STRINGS+0x0044)
#define IDS_JOYHW5			(IDS_JOYSTICK_STRINGS+0x0045)
#define IDS_JOYHW6			(IDS_JOYSTICK_STRINGS+0x0046)
#define IDS_JOYHW7			(IDS_JOYSTICK_STRINGS+0x0047)
#define IDS_JOYHW8			(IDS_JOYSTICK_STRINGS+0x0048)
#define IDS_JOYHW9			(IDS_JOYSTICK_STRINGS+0x0049)
#define IDS_JOYHW10			(IDS_JOYSTICK_STRINGS+0x004a)
#define IDS_JOYHW11			(IDS_JOYSTICK_STRINGS+0x004b)

/*
 * dialog ids
 */
#define IDD_JOYSTICK			0x1000
#define IDD_JOYCALIBRATE		0x1001
#define IDD_JOYTEST			0x1002
#define IDD_JOYCUSTOM			0x1003
#define IDD_JOYTEST1			0x1004
#define IDD_JOYCALIBRATE1		0x1005

/*
 * dialog constants
 */
#define IDC_STATIC			-1

#define ID_START			(ID_GENERIC_START+0x1000)
#define ID_APPLY			(ID_START + 0x0001)
#define ID_INIT				(ID_START + 0x0002)
#define IDC_ICON_1			(ID_START + 0x0003)
#define IDC_ICON_2			(ID_START + 0x0004)
#define IDC_TEXT_1			(ID_START + 0x0005)
#define IDC_TEXT_2			(ID_START + 0x0006)
#define IDC_GROUPBOX			(ID_START + 0x0007)
#define IDC_GROUPBOX_2			(ID_START + 0x0008)
#define IDC_GROUPBOX_3			(ID_START + 0x0009)

#define ID_JOYSTICK_START		(ID_GENERIC_START+0x2000)
#define IDC_JOYSTICK1_FRAME		(ID_JOYSTICK_START+0x0001)
#define IDC_JOYSTICK2_FRAME		(ID_JOYSTICK_START+0x0002)
#define IDC_JOYCALIBRATE		(ID_JOYSTICK_START+0x0003)
#define IDC_JOYTEST			(ID_JOYSTICK_START+0x0004)
#define IDC_JOYLIST1			(ID_JOYSTICK_START+0x0005)
#define IDC_JOYCALSTEP			(ID_JOYSTICK_START+0x0006)
#define IDC_JOYCALICON			(ID_JOYSTICK_START+0x0007)
#define IDC_JOYTESTBTN			(ID_JOYSTICK_START+0x0008)	   
#define IDC_JOYSELECT			(ID_JOYSTICK_START+0x0009)
#define IDC_JOYSELECT2			(ID_JOYSTICK_START+0x000a)
#define IDC_JOYSELECTMSG		(ID_JOYSTICK_START+0x000b)
#define IDC_JOYSELECTMSG2		(ID_JOYSTICK_START+0x000c)
#define IDC_JOYXYPOS			(ID_JOYSTICK_START+0x000d)
#define IDC_JOYB1			(ID_JOYSTICK_START+0x000e)
#define IDC_JOYB2			(ID_JOYSTICK_START+0x000f)
#define IDC_JOYB3			(ID_JOYSTICK_START+0x0010)
#define IDC_JOYB4			(ID_JOYSTICK_START+0x0011)
#define IDC_JOYB3TXT			(ID_JOYSTICK_START+0x0012)
#define IDC_JOYB4TXT			(ID_JOYSTICK_START+0x0013)
#define IDC_JOYLIST2			(ID_JOYSTICK_START+0x0014)
#define IDC_JOYPOV			(ID_JOYSTICK_START+0x0015)
#define IDC_JOYB1_LABEL			(ID_JOYSTICK_START+0x0016)
#define IDC_JOYB2_LABEL			(ID_JOYSTICK_START+0x0017)
#define IDC_JOYB3_LABEL			(ID_JOYSTICK_START+0x0018)
#define IDC_JOYB4_LABEL			(ID_JOYSTICK_START+0x0019)
#define IDC_JOYLIST1_LABEL		(ID_JOYSTICK_START+0x001a)
#define IDC_JOYLIST2_LABEL		(ID_JOYSTICK_START+0x001b)
#define IDC_JOYPOV_LABEL		(ID_JOYSTICK_START+0x001c)
#define IDC_JOYCALIBRATE2		(ID_JOYSTICK_START+0x001d)
#define IDC_JOYTEST2			(ID_JOYSTICK_START+0x001e)
#define IDC_JOYMSG			(ID_JOYSTICK_START+0x001f)
#define IDC_JOYCALMSG			(ID_JOYSTICK_START+0x0020)
#define IDC_JOYCALDONE			(ID_JOYSTICK_START+0x0021)
#define IDC_JOYHASPOV			(ID_JOYSTICK_START+0x0022)
#define IDC_JOYISYOKE			(ID_JOYSTICK_START+0x0023)
#define IDC_JOYISGAMEPAD		(ID_JOYSTICK_START+0x0024)
#define IDC_JOYISCARCTRL		(ID_JOYSTICK_START+0x0025)
#define IDC_JOY2BUTTON			(ID_JOYSTICK_START+0x0026)
#define IDC_JOY4BUTTON			(ID_JOYSTICK_START+0x0027)
#define IDC_JOYPICKPOV			(ID_JOYSTICK_START+0x0028)
#define IDC_JOYCALBACK			(ID_JOYSTICK_START+0x0029)
#define IDC_JOYCALNEXT			(ID_JOYSTICK_START+0x002a)
#define IDC_JOYSPECIALBOX		(ID_JOYSTICK_START+0x002b)
#define IDC_JOYUSESPECIAL		(ID_JOYSTICK_START+0x002c)
#define IDC_JOY1HASRUDDER		(ID_JOYSTICK_START+0x002d)
#define IDC_JOYLIST3			(ID_JOYSTICK_START+0x002e)
#define IDC_JOYLIST3_LABEL		(ID_JOYSTICK_START+0x002f)
#define IDC_JOY2AXIS			(ID_JOYSTICK_START+0x0030)
#define IDC_JOY3AXIS			(ID_JOYSTICK_START+0x0031)
#define IDC_JOY4AXIS			(ID_JOYSTICK_START+0x0032)
#define IDC_JOY_UNCAL1			(ID_JOYSTICK_START+0x0033)
#define IDC_JOY_UNCAL2			(ID_JOYSTICK_START+0x0034)
#define IDC_JOY_UNCAL3			(ID_JOYSTICK_START+0x0035)
#define IDC_JOY_UNCAL4			(ID_JOYSTICK_START+0x0036)
#define IDC_JOY_UNCAL5			(ID_JOYSTICK_START+0x0037)
#define IDC_JOY_UNCAL6			(ID_JOYSTICK_START+0x0038)
#define IDC_JOYCURRENTID		(ID_JOYSTICK_START+0x0039)
#define IDC_JOYCURRENTIDMSG		(ID_JOYSTICK_START+0x003a)
#define IDC_JOYLIST4			(ID_JOYSTICK_START+0x003b)
#define IDC_JOYLIST4_LABEL		(ID_JOYSTICK_START+0x003c)
#define IDC_JOYLIST5			(ID_JOYSTICK_START+0x003d)
#define IDC_JOYLIST5_LABEL		(ID_JOYSTICK_START+0x003e)
#define IDC_JOYRESET			(ID_JOYSTICK_START+0x003f)
#define IDC_JOYTROUBLESHOOT_FRAME	(ID_JOYSTICK_START+0x0040)
#define IDC_JOYTROUBLESHOOT_TEXT	(ID_JOYSTICK_START+0x0041)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\extern.h ===
/*
 * EXTERN.H
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * External variables for the midi control panel.
 */

extern HINSTANCE        hLibInst;       // Instance handle of library
HGLOBAL         hKeyMap;                // Handle to keymap (for key edit)
extern HFONT    hFont;                  // Handle to neato dialog box font
extern HWND     hWnd,                   // 'Current' window handle
                hEdit,                  // Edit control handle
                hArrow;                 // Arrow control handle
extern RECT     rcBox;                  // Clipping/scroll rectangle
extern int      rgxPos [8],             // horizontal positions of vertical lines
                yBox,                   // rows of data y extent
                xClient,                // Window client area x pixels
                yClient,                // Window client area y pixels
                iCurPos,                // Current position on screen
                iVertPos,               // Current vertical scroll position
                iVertMax,               // Maximum veritcal scroll position
                nLines,                 // Number of lines of data
                yChar,                  // Height of character in font
                xChar,                  // Width of average character in font
                iMap;                   // Flag for GetMBData
extern char     szCurrent [],           // Name of current map
                szCurDesc [],           // Description of current map
                szMidiCtl [],           // "MIDI Control Panel"
                szNone [],              // text string '[ None ]'
                aszSourceKey[],
                aszSourceKeyName[],
                aszPatchNumber[],
                aszSourcePatch[],
                aszSourcePatchName[],
                aszSourceMnumonic[],
                aszSourceChannel[],
                aszActive[],
                szMidiHlp[];
extern BOOL     fModified,              // Has map been modified?
                fNew,                   // Is this a new map?
                fHidden;                // Is the active edit line hidden?

extern BOOL     fReadOnly;              // Are we in READ ONLY mode?

#ifdef ALLOW_SIZING

extern BOOL     fSizeChange;            // Has the size of the box changed?

#endif // ALLOW_SIZING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\joy\joymisc.c ===
//****************************************************************************
//
//  File:       joymisc.c
//  Content:    Misc routines used by calibration and testing dialogs
//  History:
//   Date	By	Reason
//   ====	==	======
//   11-dec-94	craige	split out of joycpl.c
//   15-dec-94	craige	allow N joysticks
//   18-dec-94	craige	process U&V
//   04-mar-95	craige	bug 13147: crosshair should erase background color
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************

#include "joycpl.h"

/*
 * ADJ_VAL is used to convert a joystick position into a value in
 * a new range
 */
#define ADJ_VAL( a, pos, range ) (((pos-(pgv->joyRange.jpMin.dw##a))*range)/ \
			(pgv->joyRange.jpMax.dw##a-pgv->joyRange.jpMin.dw##a+1))


/*
 * setOEMWindowText - set window text with an OEM string
 */
static void setOEMWindowText( HWND hwnd, int id, LPSTR str )
{
    HWND	hwndctl;
    if( str[0] != 0 ) {
	hwndctl = GetDlgItem( hwnd, id );
	if( hwndctl != NULL ) {
	    SetWindowText( hwndctl, str );
	}
    }

} /* setOEMWindowText */

/*
 * SetOEMText - set OEM defined text in the dialogs
 */
void SetOEMText( LPGLOBALVARS pgv, HWND hwnd, BOOL istest )
{
    DWORD	type;
    char	str[MAX_STR];
    char	res[MAX_STR];
    HINSTANCE	hinst;
    int		id;
    LPSTR	pwincap;
    LPJOYDATA	pjd;

    pjd = pgv->pjd;

    /*
     * get the default window caption.   this will be replaced by
     * an OEM string if it is avaliable.
     */
    hinst = GetWindowInstance( hwnd );
    if( istest ) {
	id = IDS_JOYTESTCAPN;
    } else {
	id = IDS_JOYCALCAPN;
    }
    if( !LoadString( hinst, id, str, sizeof( str ) ) ) {
	res[0] = 0;
    } else {
	wsprintf( res, str, pgv->iJoyId+1 );
    }
    pwincap = res;

    /*
     * if this is an OEM joystick, use any strings that they may have defined
     */
    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM ) {
	type = pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY;
	/*
	 * set up labels under each of the controls
	 */
	setOEMWindowText( hwnd, IDC_JOYLIST1_LABEL, pjd->oemList[type].xy_label );
	setOEMWindowText( hwnd, IDC_JOYLIST2_LABEL, pjd->oemList[type].z_label );
	setOEMWindowText( hwnd, IDC_JOYLIST3_LABEL, pjd->oemList[type].r_label );
	setOEMWindowText( hwnd, IDC_JOYLIST4_LABEL, pjd->oemList[type].u_label );
	setOEMWindowText( hwnd, IDC_JOYLIST5_LABEL, pjd->oemList[type].v_label );
	setOEMWindowText( hwnd, IDC_JOYPOV_LABEL, pjd->oemList[type].pov_label );
	if( istest ) {
	    /*
	     * set the various caption and description fields in the test dlg
	     */
	    setOEMWindowText( hwnd, IDC_TEXT_1, pjd->oemList[type].testmove_desc );
	    setOEMWindowText( hwnd, IDC_TEXT_2, pjd->oemList[type].testbutton_desc );
	    setOEMWindowText( hwnd, IDC_GROUPBOX, pjd->oemList[type].testmove_cap );
	    setOEMWindowText( hwnd, IDC_GROUPBOX_2, pjd->oemList[type].testbutton_cap );
	    if( pjd->oemList[type].testwin_cap[0] != 0 ) {
		pwincap = pjd->oemList[type].testwin_cap;
	    }
	} else {
	    /*
	     * set the various caption and description fields in the
	     * calibration dialog
	     */
	    setOEMWindowText( hwnd, IDC_GROUPBOX, pjd->oemList[type].cal_cap );
	    if( pjd->oemList[type].calwin_cap[0] != 0 ) {
		pwincap = pjd->oemList[type].calwin_cap;
	    }
	}
    }

    /*
     * set the window caption
     */
    if( pwincap[0] != 0 ) {
	SetWindowText( hwnd, pwincap );
    }

} /* SetOEMText */

/*
 * ShowControls - show Z and R controls, based on configuration info
 */
void ShowControls( LPJOYREGHWCONFIG pcfg, HWND hwnd )
{
    HWND	hwndctl;
    /*
     * hide Z indicatior if there is no Z axis
     */
    if( !(pcfg->hws.dwFlags & JOY_HWS_HASZ) ) {
	ShowWindow( GetDlgItem( hwnd, IDC_JOYLIST2 ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYLIST2_LABEL ), SW_HIDE );
    }

    /*
     * hide R indicatior if there is no R axis or rudder
     */
    if( !(pcfg->hws.dwFlags & JOY_HWS_HASR) && !(pcfg->dwUsageSettings & JOY_US_HASRUDDER) ) {
	ShowWindow( GetDlgItem( hwnd, IDC_JOYLIST3 ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYLIST3_LABEL ), SW_HIDE );
    }

    /*
     * hide POV indicatior if there is no POV
     */
    if( !(pcfg->hws.dwFlags & JOY_HWS_HASPOV) ) {
	ShowWindow( GetDlgItem( hwnd, IDC_JOYPOV ), SW_HIDE );
	ShowWindow( GetDlgItem( hwnd, IDC_JOYPOV_LABEL ), SW_HIDE );
    }

    /*
     * hide U indicatior if there is no U axis
     */
    if( !(pcfg->hws.dwFlags & JOY_HWS_HASU) ) {
	hwndctl = GetDlgItem( hwnd, IDC_JOYLIST4 );
	if( hwndctl != NULL ) {
	    ShowWindow( hwndctl, SW_HIDE );
	    ShowWindow( GetDlgItem( hwnd, IDC_JOYLIST4_LABEL ), SW_HIDE );
	}
    }

    /*
     * hide V indicatior if there is no V axis
     */
    if( !(pcfg->hws.dwFlags & JOY_HWS_HASV) ) {
	hwndctl = GetDlgItem( hwnd, IDC_JOYLIST5 );
	if( hwndctl != NULL ) {
	    ShowWindow( hwndctl, SW_HIDE );
	    ShowWindow( GetDlgItem( hwnd, IDC_JOYLIST5_LABEL ), SW_HIDE );
	}
    }

} /* ShowControls */

/*
 * JoyError - error reading the joystick
 */
BOOL JoyError( HWND hwnd )
{
    char	str1[MAX_STR];
    char	str2[MAX_STR];
    int		rc;
    HINSTANCE	hinst;

    hinst = GetWindowInstance( hwnd );
    rc = IDCANCEL;
    if( LoadString( hinst, IDS_JOYREADERROR, str1, sizeof( str1 ) ) ) {
	if( LoadString( hinst, IDS_JOYUNPLUGGED, str2, sizeof( str2 ) ) ) {
	    rc = MessageBox( hwnd, str2, str1,
	    		MB_RETRYCANCEL | MB_ICONERROR | MB_TASKMODAL );
	}
    }
    if( rc == IDCANCEL ) {
	/*
	 * terminate the dialog if we give up
	 */
	PostMessage( hwnd, WM_COMMAND, IDCANCEL, 0 );
	return FALSE;
    }
    return TRUE;

} /* JoyError */

/*
 * ChangeIcon - change the icon of a static control
 */
void ChangeIcon( HWND hwnd, int idi, int idc )
{

    HINSTANCE	hinst;
    HICON	hicon;
    HICON	holdicon;

    hinst = GetWindowInstance( hwnd );
    hicon = LoadIcon( hinst, MAKEINTRESOURCE(idi) );
    if( hicon != NULL ) {
	holdicon = Static_SetIcon( GetDlgItem(hwnd,idc), hicon );
	if( holdicon != NULL ) {
	    DestroyIcon( holdicon );
	}
    }

} /* ChangeIcon */

/*
 * CauseRedraw - cause test or calibrate dialogs to redraw their controls
 */
void CauseRedraw( LPJOYINFOEX pji, BOOL do_buttons )
{
    pji->dwXpos = (DWORD) -1;
    pji->dwYpos = (DWORD) -1;
    pji->dwZpos = (DWORD) -1;
    pji->dwRpos = (DWORD) -1;
    pji->dwPOV = JOY_POVCENTERED;
    if( do_buttons ) {
	pji->dwButtons = ALL_BUTTONS;
    }

} /* CauseRedraw */

/*
 * fillBar - fill the bar for indicating Z or R info
 */
static void fillBar( LPGLOBALVARS pgv, HWND hwnd, DWORD pos, int id )
{
    HWND	hwlb;
    RECT	r;
    HDC		hdc;
    int		height;
    LPJOYDATA	pjd;

    pjd = pgv->pjd;

    /*
     * scale the height to be inside the bar window
     */
    hwlb = GetDlgItem( hwnd, id );
    if( hwlb == NULL ) {
	return;
    }
    hdc = GetDC( hwlb );
    if( hdc == NULL ) {
	return;
    }
    GetClientRect( hwlb, &r );

    switch( id ) {
    case IDC_JOYLIST2:
	height = ADJ_VAL( Z, pos, r.bottom );
	break;
    case IDC_JOYLIST3:
	height = ADJ_VAL( R, pos, r.bottom );
	break;
    case IDC_JOYLIST4:
	height = ADJ_VAL( U, pos, r.bottom );
	break;
    case IDC_JOYLIST5:
	height = ADJ_VAL( V, pos, r.bottom );
	break;
    }

    /*
     * fill in the inactive area
     */
    r.top = height;
    FillRect( hdc, &r, pjd->hbUp );

    /*
     * fill in the active area
     */
    r.top = 0;
    r.bottom = height;
    FillRect( hdc, &r, pjd->hbDown );

    ReleaseDC( hwlb, hdc );

} /* fillBar */

#define DELTA	5
/*
 * drawCross - draw a cross in the position box
 */
static void drawCross( HWND hwnd, int x, int y, int obj )
{
    HDC		hdc;
    HPEN	hpen;
    HPEN	holdpen;

    hdc = GetDC( hwnd );
    if( hdc == NULL ) {
	return;
    }
    if( obj == -1 ) {
	COLORREF	cr;
	cr = GetSysColor( COLOR_WINDOW );
	hpen = CreatePen( PS_SOLID, 0, cr );
    } else {
	hpen = GetStockObject( obj );
    }
    if( hpen == NULL ) {
	ReleaseDC( hwnd, hdc );
	return;
    }
    holdpen = SelectObject( hdc, hpen );
    MoveToEx( hdc, x-(DELTA-1), y, NULL );
    LineTo( hdc, x+DELTA, y );
    MoveToEx( hdc, x, y-(DELTA-1), NULL );
    LineTo( hdc, x, y+DELTA );
    SelectObject( hdc, holdpen );
    if( obj == -1 ) {
	DeleteObject( hpen );
    }
    ReleaseDC( hwnd, hdc );

} /* drawCross */

#define FILLBAR( a, id ) \
    /* \
     * make sure we aren't out of alleged range \
     */ \
    if( pji->dw##a##pos > pgv->joyRange.jpMax.dw##a ) { \
	pji->dw##a##pos = pgv->joyRange.jpMax.dw##a; \
    } else if( pji->dw##a##pos < pgv->joyRange.jpMin.dw##a ) { \
	pji->dw##a##pos = pgv->joyRange.jpMin.dw##a; \
    } \
 \
    /* \
     * fill the bar if we haven't moved since last time \
     */ \
    if( pji->dw##a##pos != poji->dw##a##pos ) { \
	fillBar( pgv, hwnd, pji->dw##a##pos, id ); \
	poji->dw##a##pos = pji->dw##a##pos; \
    }

/*
 * DoJoyMove - process movement for the joystick 
 */
void DoJoyMove( LPGLOBALVARS pgv, HWND hwnd, LPJOYINFOEX pji,
		       LPJOYINFOEX poji, DWORD drawflags )
{
    HWND	hwlb;
    RECT	rc;
    int		width;
    int		height;
    DWORD	x,y;

    /*
     * draw the cross in the XY box if needed
     */
    if( drawflags & JOYMOVE_DRAWXY ) {
	/*
	 * make sure we aren't out of alleged range
	 */
	if( pji->dwXpos > pgv->joyRange.jpMax.dwX ) {
	    pji->dwXpos = pgv->joyRange.jpMax.dwX;
	} else if( pji->dwXpos < pgv->joyRange.jpMin.dwX ) {
	    pji->dwXpos = pgv->joyRange.jpMin.dwX;
	}
	if( pji->dwYpos > pgv->joyRange.jpMax.dwY ) {
	    pji->dwYpos = pgv->joyRange.jpMax.dwY;
	} else if( pji->dwYpos < pgv->joyRange.jpMin.dwY ) {
	    pji->dwYpos = pgv->joyRange.jpMin.dwY;
	}

	/*
	 * convert info to (x,y) position in window
	 */
	hwlb = GetDlgItem( hwnd, IDC_JOYLIST1 );
	GetClientRect( hwlb, &rc );
	height = rc.bottom - rc.top-2*DELTA;
	width = rc.right - rc.left-2*DELTA;
	x = ADJ_VAL( X, pji->dwXpos, width ) + DELTA;
	y = ADJ_VAL( Y, pji->dwYpos, height ) + DELTA;

	/*
	 * only draw the cross if it has moved since last time
	 */
	if( x != (DWORD) poji->dwXpos || y != (DWORD) poji->dwYpos ) {
	    if( poji->dwXpos != (DWORD) -1 ) {
//		drawCross( hwlb, (int) poji->dwXpos, (int) poji->dwYpos, WHITE_PEN );
		drawCross( hwlb, (int) poji->dwXpos, (int) poji->dwYpos, -1 );
	    }
	    drawCross( hwlb, (int) x, (int) y, BLACK_PEN );
	    poji->dwXpos = x;
	    poji->dwYpos = y;
	}
    }

    /*
     * draw Z bar if needed
     */
    if( drawflags & JOYMOVE_DRAWZ ) {
	FILLBAR( Z, IDC_JOYLIST2 );
    }

    /*
     * draw R bar if needed
     */
    if( drawflags & JOYMOVE_DRAWR ) {
	FILLBAR( R, IDC_JOYLIST3 );
    }

    /*
     * draw U bar if needed
     */
    if( drawflags & JOYMOVE_DRAWU ) {
	FILLBAR( U, IDC_JOYLIST4 );
    }

    /*
     * draw V bar if needed
     */
    if( drawflags & JOYMOVE_DRAWV ) {
	FILLBAR( V, IDC_JOYLIST5 );
    }

} /* DoJoyMove */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\cparrow.h ===
/*--------------------------------------------------------------------------*/

BOOL    PASCAL FAR RegisterArrowClass(
    HINSTANCE   hInstance);
VOID    PASCAL FAR UnregisterArrowClass(
    HINSTANCE   hInstance);

/*--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\hack.h ===
#if defined(WIN32)

#define _based(x)

#define huge

#define _loadds

#define _fmemset memset
#define _fmemcpy memcpy
#define DosDelete(fn) DeleteFile(fn)

#endif //WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\map.c ===
/*****************************************************************************
    map.c


    midi mapper run-time

    Copyright (c) Microsoft Corporation 1990-1991. All rights reserved

*****************************************************************************/

#include <windows.h>
#include <string.h>
#include <mmsystem.h>
#if defined(WIN32)
#include <port1632.h>
#endif
#include "hack.h"
#include <mmddk.h>
#include "midimap.h"
#include "midi.h"
#include "extern.h"
#include "mmreg.h"

#define ISSTATUS(bData)     ((bData) & 0x80)
#define FILTERCHANNEL(bStatus)  ((BYTE)((bStatus) & 0xf0))
#define FILTERSTATUS(bStatus)   ((BYTE)((bStatus) & 0x0f))

#define STATUS_NOTEOFF      0x80
#define STATUS_NOTEON       0x90
#define STATUS_POLYPHONICKEY    0xa0
#define STATUS_CONTROLCHANGE    0xb0
#define STATUS_PROGRAMCHANGE    0xc0
#define STATUS_CHANNELPRESSURE  0xd0
#define STATUS_PITCHBEND    0xe0

#define STATUS_SYS      0xf0
#define STATUS_SYSEX        0xf0
#define STATUS_QFRAME       0xf1
#define STATUS_SONGPOINTER  0xf2
#define STATUS_SONGSELECT   0xf3
#define STATUS_F4       0xf4
#define STATUS_F5       0xf5
#define STATUS_TUNEREQUEST  0xf6
#define STATUS_EOX      0xf7
#define STATUS_TIMINGCLOCK  0xf8
#define STATUS_F9       0xf9
#define STATUS_START        0xfa
#define STATUS_CONTINUE     0xfb
#define STATUS_STOP     0xfc
#define STATUS_FD       0xfd
#define STATUS_ACTIVESENSING    0xfe
#define STATUS_SYSTEMRESET  0xff

#define CONTROL_VOLUME      0x07

#define MIDIDATABUFFER      512

#define STATE_MAPNAILED     0x0001
#define STATE_DATANAILED    0x0002
#define STATE_CODENAILED    0x0004

/*****************************************************************************

    local structures

*****************************************************************************/

typedef unsigned char huge *     HPBYTE;

#define DEV_PREPARED    0x0001

typedef struct mididev_tag {
    WORD    wDeviceID;
    WORD    wChannel;
    WORD    fwFlags;
    HMIDIOUT   hMidi;
} MIDIDEV;
typedef MIDIDEV *PMIDIDEV;

/*****************************************************************************

    local data

*****************************************************************************/

/*
 * critical section used to protect the open so that there is no
 * window in which two threads could open simultaneously - otherwise
 * with all these statics there would be a major accident
 */
CRITICAL_SECTION MapperCritSec;




static HGLOBAL        hCurMap;         // handle of current midi map
static WORD           wChannelMask;    // which channels are on
static UINT           uPatchMask;      // which channels have patch maps
static MIDIDEV        mapdevs[16];     // contains device info. for each midi device in the current map.
static MIDIDEV        chnldevs[16];    // map channels to midi devices.
static LPMIDIPATCHMAP lpPMap;          // current patch map
static LPMIDIKEYMAP   lpKMap;          // current key map
static BYTE           curpatch[16];    // what is the currently selected patch for each channel
static BYTE           status;          // virtual running status
static BYTE           bCurrentStatus;  // Current message type
static BYTE           fActiveChannel;  // Channel message to active channel
static BYTE           bCurrentLen;     // Current message length, if any

static DWORD_PTR      OpenCallback;    // Open Callback parameter
static DWORD_PTR      OpenInstance;    // Open Instance parameter
static DWORD          OpenFlags;       // Open Param2
static HMIDIOUT       hmidiMapper;     // Handle of current mapper device
static LPMIDIHDR      pmidihdrMapper;  // Buffer used for mapped devices
static UINT           ufStateFlags;    // State flags for device
extern BYTE FAR       bMidiLengths[];  // Lengths in lengths.c
extern BYTE FAR       bSysLengths[];   // Lengths in lengths.c

#define MIDILENGTH(bStatus) (bMidiLengths[((bStatus) & 0x70) >> 4])
#define SYSLENGTH(bStatus)  (bSysLengths[(bStatus) & 0x07])

#define lpCurMap ((LPMIDIMAP)hCurMap)  // pointer to current midi map

UINT mapLockCount;

UINT FAR PASCAL modGetDevCaps(LPMIDIOUTCAPSW lpCaps, UINT uSize);
UINT FAR PASCAL modCachePatches(UINT msg, UINT uBank, LPPATCHARRAY lpPatchArray, UINT uFlags);
static UINT FAR PASCAL midiReadCurrentSetup(LPMIDIOPENDESC lpOpen, DWORD dwParam2);

LRESULT FAR PASCAL DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);

static void NEAR PASCAL modShortData(LPBYTE pbData);
static void NEAR PASCAL modLongData(HPBYTE pbData, DWORD dDataLength);
static void NEAR PASCAL modTranslateEvent(LPBYTE pbData, BYTE bStart, BYTE bLength);

DWORD FAR PASCAL _loadds modMessage(UINT id, UINT msg, DWORD dwUser, DWORD dwParam1, DWORD dwParam2);
static void PASCAL FAR CallbackNotification(UINT message, DWORD dwParam);
static void NEAR PASCAL modSendLongData(UINT uMessageLength, BOOL fBroadcast, BOOL force);
static  BOOL NEAR PASCAL modHeaderDone(void);


static  void PASCAL NEAR ReleaseResources(void);

static UINT PASCAL NEAR TranslateError(MMAPERR mmaperr)
{
    switch (mmaperr) {
    case MMAPERR_INVALIDPORT:
	    return MIDIERR_NODEVICE;
    case MMAPERR_MEMORY:
	return MMSYSERR_NOMEM;
    case MMAPERR_INVALIDSETUP:
	return MIDIERR_INVALIDSETUP;
    }
    return MIDIERR_NOMAP;
}

#if defined(WIN16)

static  BOOL NEAR PASCAL GlobalNail(
    HGLOBAL hSegment,
    UINT    uFlag)
{
    if (GlobalWire(hSegment)) {
	if (GlobalPageLock(hSegment)) {
	    ufStateFlags |= uFlag;
	    return TRUE;
	}
	GlobalUnWire(hSegment);
    }
    return FALSE;
}

static  void NEAR PASCAL GlobalUnNail(
    HGLOBAL hSegment,
    UINT    uFlag)
{
    if (ufStateFlags & uFlag) {
	GlobalPageUnlock(hSegment);
	GlobalUnWire(hSegment);
	ufStateFlags &= ~uFlag;
    }
}
#endif //WIN16

static  void PASCAL NEAR ReleaseResources(void)
{
    WORD    wDevice;

#ifdef WIN16
    GlobalUnNail((HGLOBAL)HIWORD((DWORD)(LPVOID)&hCurMap), STATE_DATANAILED);
    GlobalUnNail(hCurMap, STATE_MAPNAILED);
    GlobalUnNail((HGLOBAL)HIWORD(DriverProc), STATE_CODENAILED);
#endif // WIN16

    for (wDevice = 0; (wDevice < 16) && (mapdevs[wDevice].wDeviceID != (WORD)(-1)); wDevice++) {
	if (mapdevs[wDevice].hMidi) {
	    midiOutReset(mapdevs[wDevice].hMidi);
	    if (mapdevs[wDevice].fwFlags & DEV_PREPARED) {
		midiOutUnprepareHeader(mapdevs[wDevice].hMidi, pmidihdrMapper, sizeof(MIDIHDR));
		mapdevs[wDevice].fwFlags &= ~DEV_PREPARED;
	    }
	    midiOutClose(mapdevs[wDevice].hMidi);
	    mapdevs[wDevice].hMidi = NULL;
	    mapdevs[wDevice].wDeviceID = (WORD)(-1);
	}
    }
    if (hCurMap) {
	GlobalFree(hCurMap);
	hCurMap = NULL;
    }
    if (pmidihdrMapper) {
	HGLOBAL hmem = GlobalHandle( pmidihdrMapper );
	GlobalUnlock( hmem );
	GlobalFree( hmem );
	pmidihdrMapper = NULL;
    }
}

static  UINT PASCAL FAR CloseMidiDevice(
    void)
{
    ReleaseResources();
    CallbackNotification(MOM_CLOSE, 0);
    return 0;
}

static  void PASCAL FAR CallbackNotification(
    UINT    message,
    DWORD   dwParam)
{
    if (OpenCallback)
	DriverCallback( OpenCallback
		      , HIWORD(OpenFlags) | DCB_NOSWITCH
		      , (HANDLE)hmidiMapper
		      , message
		      , OpenInstance
		      , dwParam
		      , 0
		      );
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @api LRESULT | DriverProc | The entry point for an installable driver.
 *
 * @parm DWORD | dwDriverId | For most messages, <p dwDriverId> is the DWORD
 *     value that the driver returns in response to a <m DRV_OPEN> message.
 *     Each time that the driver is opened, through the <f DrvOpen> API,
 *     the driver receives a <m DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <p dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm HDRVR  | hDriver | This is the handle returned to the
 *     application by the driver interface.
 *
 * @parm UINT | wMessage | The requested action to be performed. Message
 *     values below <m DRV_RESERVED> are used for globally defined messages.
 *     Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
 *     defined driver protocols. Messages above <m DRV_USER> are used
 *     for driver specific messages.
 *
 * @parm LPARAM | lParam1 | Data for this message.  Defined separately for
 *     each message
 *
 * @parm LPARAM | lParam2 | Data for this message.  Defined separately for
 *     each message
 *
 * @rdesc Defined separately for each message.
 ***************************************************************************/

LRESULT FAR PASCAL DriverProc(DWORD dwDriverID, HDRVR hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2)
{
    //
    //  NOTE DS is not valid here.
    //
    switch (wMessage) {

	case DRV_LOAD:
	    InitializeCriticalSection(&MapperCritSec);
	    return (LRESULT)TRUE;

	case DRV_FREE:
	    DeleteCriticalSection(&MapperCritSec);
	    return (LRESULT)TRUE;

	case DRV_OPEN:
	case DRV_CLOSE:
	    return (LRESULT)TRUE;
	case DRV_INSTALL:
	case DRV_REMOVE:
	    return (LRESULT)DRVCNF_RESTART;

	default:
	    return DefDriverProc(dwDriverID, hDriver, wMessage,lParam1,lParam2);
	}
}

DWORD FAR PASCAL _loadds modMessage(UINT id, UINT msg, DWORD dwUser, DWORD dwParam1, DWORD dwParam2)
{
int         i;
DWORD       dResult;

    // this driver only supports one device
    if (id != 0)
	return MMSYSERR_BADDEVICEID;

    switch (msg) {

       case MODM_GETNUMDEVS:
	    return 1;

	case MODM_GETDEVCAPS:
	    return modGetDevCaps((LPMIDIOUTCAPSW)dwParam1, LOWORD(dwParam2));

	case MODM_OPEN:
	    EnterCriticalSection(&MapperCritSec);
	    if( hCurMap || mapLockCount ) {
		dResult = MMSYSERR_ALLOCATED;
	    } else {
		dResult =  midiReadCurrentSetup((LPMIDIOPENDESC)dwParam1, dwParam2);
	    }
	    LeaveCriticalSection(&MapperCritSec);
	    return dResult;

	case MODM_CLOSE:
	    EnterCriticalSection(&MapperCritSec);
	    dResult = CloseMidiDevice();
	    LeaveCriticalSection(&MapperCritSec);
	    return dResult;

	case MODM_CACHEPATCHES:
	case MODM_CACHEDRUMPATCHES:
	    return modCachePatches(msg, HIWORD(dwParam2), (LPPATCHARRAY)dwParam1, LOWORD(dwParam2));

///////////////////////////////////////////////////////////////////////////
//
//  INTERRUPT TIME CODE
//
//  MODM_LONGDATA, MODM_DATA, and MODM_RESET are callable at interupt time!
//
///////////////////////////////////////////////////////////////////////////

	case MODM_DATA:
	    modShortData((LPBYTE)&dwParam1);
	    return 0;

	case MODM_LONGDATA:
	    modLongData( (HPBYTE)((LPMIDIHDR)dwParam1)->lpData
		       , ((LPMIDIHDR)dwParam1)->dwBufferLength
		       );
	    ((LPMIDIHDR)dwParam1)->dwFlags |= MHDR_DONE;
	    CallbackNotification(MOM_DONE, dwParam1);
	    return 0;

///////////////////////////////////////////////////////////////////////////

	case MODM_PREPARE:
	case MODM_UNPREPARE:
	    return MMSYSERR_NOTSUPPORTED;

	//case MODM_RESET:
	//case MODM_GETVOLUME:
	//case MODM_SETVOLUME:

	default:
	    //
	    //  !!!this is in trouble if a map goes to multiple physical devices
	    //  we return the *last* dResult, this is
	    //  totally random for some messages (like MODM_GETVOLUME).

	    // pass the message on un-translated to all mapped physical
	    // devices.
	    //
	    for (dResult = 0, i = 0; i < 16 && mapdevs[i].hMidi; i++)
		switch (msg) {
		//
		// Avoid nasty overlaps with open devices
		//
		case MODM_GETVOLUME:
		    dResult = midiOutGetVolume((HMIDIOUT)(mapdevs[i].wDeviceID), (LPDWORD)dwParam1);
		    break;

		case MODM_SETVOLUME:
		    dResult = midiOutSetVolume((HMIDIOUT)(mapdevs[i].wDeviceID), dwParam1);
		    break;

		default:
		    dResult = midiOutMessage(mapdevs[i].hMidi, msg, dwParam1, dwParam2);
		    break;
		}

	    return dResult;
    }
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | modGetDevCaps | This function returns the mappers device caps
 *
 * @parm LPMIDIOUTCAPS | lpCaps | Specifies a far pointer to a <t MIDIOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 ****************************************************************************/
UINT FAR PASCAL modGetDevCaps(LPMIDIOUTCAPSW lpCaps, UINT uSize)
{
MIDIOUTCAPSW mc;
int i;

    if (uSize != 0) {

	i=LoadStringW( hLibInst,
		       IDS_MIDIMAPPER,
		       mc.szPname,
		       sizeof(lpCaps->szPname) / sizeof(WCHAR) );

	mc.wMid = MM_MICROSOFT;
	mc.wPid = MM_MIDI_MAPPER;
	mc.vDriverVersion = 0x0100;
	mc.wTechnology = MOD_MAPPER;
	mc.wVoices = 0;
	mc.wNotes = 0;
	mc.wChannelMask = wChannelMask;  // 0 if mapper not opened yet
	mc.dwSupport = MIDICAPS_CACHE;

	_fmemcpy((LPSTR)lpCaps, (LPSTR)&mc, min(uSize, sizeof(mc)));
    }

return 0;
}

static void PASCAL NEAR TranslatePatchArray(
	LPPATCHARRAY    lpSource,
	LPPATCHARRAY    lpDest,
	BOOL    fToMaps)
{
	int     i;

	_fmemset(lpDest, 0, sizeof(PATCHARRAY));
	for (i = 0; i < 16; i++) {
		UINT    curmask;
		int     j;

		curmask = 1 << i;
		if (uPatchMask & curmask) {
			lpPMap = (LPMIDIPATCHMAP)((LPSTR)lpCurMap + lpCurMap->chMap[i].oPMap);
			if (fToMaps)
				for (j = 0; j < MIDIPATCHSIZE; j++)
					lpDest[LOBYTE(lpPMap->wPMap[j])] |= (lpSource[j] & curmask) ? curmask : 0;
			else
				for (j = 0; j < MIDIPATCHSIZE; j++)
					lpDest[j] |= (lpSource[LOBYTE(lpPMap->wPMap[j])] & curmask) ? curmask : 0;
		} else
			for (j = 0; j < MIDIPATCHSIZE; j++)
				lpDest[j] |= (lpSource[j] & curmask) ? curmask : 0;
	}
}

UINT FAR PASCAL modCachePatches(UINT msg, UINT uBank, LPPATCHARRAY lpPatchArray, UINT uFlags)
{
int         i;
PATCHARRAY  patchlist;
PATCHARRAY  retpatchlist;
UINT        uResult = 0;

    TranslatePatchArray(lpPatchArray, patchlist, TRUE);

    // send to drivers
    _fmemset(retpatchlist, 0, sizeof(PATCHARRAY));

    for( i = 0; ((i < 16) && (mapdevs[i].wDeviceID != (WORD)(-1))); i++ ) {
	PATCHARRAY  curpatchlist;
	int     j;

	for (j = 0; j < MIDIPATCHSIZE; j++ )
	    curpatchlist[j] = patchlist[j] & mapdevs[i].wChannel;


	uResult = ( (msg == MODM_CACHEPATCHES)
		  ?  midiOutCachePatches( mapdevs[i].hMidi
					, uBank
					, curpatchlist
					, uFlags
					)
		  : midiOutCacheDrumPatches( mapdevs[i].hMidi
					   , uBank
					   , curpatchlist
					   , uFlags
					   )
		  );

	// combine the returned info
	for (j = 0; j < MIDIPATCHSIZE; j++ )
	    retpatchlist[j] |= (curpatchlist[j] & mapdevs[i].wChannel);
    }

    TranslatePatchArray(retpatchlist, lpPatchArray, FALSE);

    return uResult;
}



///////////////////////////////////////////////////////////////////////////
//
//  INTERRUPT TIME CODE
//
//  MODM_LONGDATA, and MODM_DATA are callable at interupt time!
//
///////////////////////////////////////////////////////////////////////////

static  BOOL NEAR PASCAL modHeaderDone(
    void)
{
    if (pmidihdrMapper->dwFlags & MHDR_DONE)
	return TRUE;
    else
	return FALSE;
}



static  void NEAR PASCAL modSendLongData(
    UINT    uMessageLength,
    BOOL    fBroadcast,
    BOOL    fForce)             // Used on final invocation
{

static BYTE LongBuffer[200];           // Cache the stuff for performance
static DWORD nLongData;                // How much we've got
static BOOL LastBroadcast;             // What we were asked to do last time
static BYTE LastStatus;                // Last status we had

    if (nLongData &&
	(fForce ||
	 FILTERSTATUS(status) != FILTERSTATUS(LastStatus) ||
	 uMessageLength + nLongData > sizeof(LongBuffer) ||
	 LastBroadcast != fBroadcast)) {

	LPBYTE lpSave = pmidihdrMapper->lpData;
	pmidihdrMapper->lpData = LongBuffer;

	pmidihdrMapper->dwBufferLength = nLongData;
	if (LastBroadcast) {
	    WORD    wDevice;

	    for (wDevice = 0; (wDevice < 16) && (mapdevs[wDevice].wDeviceID != (WORD)(-1)); wDevice++) {
		pmidihdrMapper->dwFlags &= ~MHDR_DONE;
		if (MMSYSERR_NOERROR ==
		    midiOutLongMsg(mapdevs[wDevice].hMidi,
				   pmidihdrMapper,
				   sizeof(MIDIHDR))) {
		    while (!modHeaderDone())
			Sleep(1);
		}
	    }
	} else {
	    pmidihdrMapper->dwFlags &= ~MHDR_DONE;
	    if (MMSYSERR_NOERROR ==
		midiOutLongMsg(chnldevs[FILTERSTATUS(LastStatus)].hMidi,
			       pmidihdrMapper,
			       sizeof(MIDIHDR))) {
		while (!modHeaderDone())
		    Sleep(1);
	    }
	}

	pmidihdrMapper->lpData = lpSave;
	nLongData = 0;
    }

    //
    // Pull in our new data
    //
    LastStatus = status;
    LastBroadcast = fBroadcast;
    if (fBroadcast || fActiveChannel) {
	memcpy(LongBuffer + nLongData, pmidihdrMapper->lpData, uMessageLength);
	nLongData += uMessageLength;
    }
}

static void NEAR PASCAL modTranslateEvent(
    LPBYTE  pbData,
    BYTE    bStart,
    BYTE    bLength)
{
    static BYTE fControlVol;

    if (wChannelMask & (1 << FILTERSTATUS(status))) {
	fActiveChannel = TRUE;
	bCurrentStatus = FILTERCHANNEL(status) + (BYTE)lpCurMap->chMap[FILTERSTATUS(status)].wChannel;
	if (!bStart) {
	    *(pbData++) = bCurrentStatus;
	    bStart++;
	    bLength--;
	    if (!bLength)
		return;
	}
	if (uPatchMask & (1 << FILTERSTATUS(status))) {
	    lpPMap = (LPMIDIPATCHMAP)((LPSTR)lpCurMap + lpCurMap->chMap[FILTERSTATUS(status)].oPMap);
	    switch (FILTERCHANNEL(status)) {
	    case STATUS_NOTEOFF:
	    case STATUS_NOTEON:
	    case STATUS_POLYPHONICKEY:
		if ((bStart > 1) || !lpPMap->okMaps[curpatch[FILTERSTATUS(status)]])
		    break;
		lpKMap = (LPMIDIKEYMAP)((LPSTR)lpPMap + lpPMap->okMaps[curpatch[FILTERSTATUS(status)]]);
		*pbData = lpKMap->bKMap[*pbData];
		break;
	    case STATUS_CONTROLCHANGE:
		if (bStart == 1) {
		    if (*pbData != CONTROL_VOLUME)
			break;
		    pbData++;
		    bStart++;
		    bLength--;
		    fControlVol = TRUE;
		    if (!bLength)
			return;
		}
		*pbData = (BYTE)((DWORD)*pbData * (DWORD)HIBYTE(lpPMap->wPMap[curpatch[FILTERSTATUS(status)]]) / lpPMap->bVMax);
		fControlVol = FALSE;
		break;
	    case STATUS_PROGRAMCHANGE:
		curpatch[FILTERSTATUS(status)] = *pbData;
		*pbData = (BYTE)lpPMap->wPMap[*pbData];
		break;
	    }
	}
    } else
	fActiveChannel = FALSE;
}

static  void NEAR PASCAL modShortData( LPBYTE  pbData)
{
    BOOL    fBroadcast;
    BYTE    bStart = 0;
    BYTE    bLength = 0;

    if (*pbData >= STATUS_TIMINGCLOCK)
	fBroadcast = TRUE;
    else {
	bCurrentLen = 0;
	if (ISSTATUS(*pbData)) {
	    bCurrentStatus = *pbData;
	    if (bCurrentStatus >= STATUS_SYSEX) {
		status = 0;
		fBroadcast = TRUE;
	    } else {
		status = bCurrentStatus;
		bLength = MIDILENGTH(bCurrentStatus);
		fBroadcast = FALSE;
		bStart = 0;
	    }
	} else if (!status)
	    return;
	else {
	    fBroadcast = FALSE;
	    bLength = (BYTE)(MIDILENGTH(status) - 1);
	    bStart = 1;
	}
    }
    if (fBroadcast) {
	WORD    wDevice;

	for (wDevice = 0; (wDevice < 16) && (mapdevs[wDevice].wDeviceID != (WORD)(-1)); wDevice++)
	    midiOutShortMsg(mapdevs[wDevice].hMidi, *(LPDWORD)pbData);
    } else {
	modTranslateEvent(pbData, bStart, bLength);
	if (fActiveChannel)
	    midiOutShortMsg(chnldevs[FILTERSTATUS(status)].hMidi, *(LPDWORD)pbData);
    }
}

static void NEAR PASCAL modLongData(
    HPBYTE  pbData,
    DWORD   dDataLength)
{
    static BYTE bStart;
    UINT    uMessageLength;
    LPBYTE  pbHdrData;

    pbHdrData = pmidihdrMapper->lpData;
    uMessageLength = 0;
    for (; dDataLength;) {
	if (ISSTATUS(*pbData)) {
	    if (bCurrentStatus == STATUS_SYSEX) {
		bCurrentStatus = *pbData;
		if ((bCurrentStatus == STATUS_EOX) || (bCurrentStatus == STATUS_SYSEX) || (bCurrentStatus >= STATUS_TIMINGCLOCK)) {
		    *(pbHdrData++) = bCurrentStatus;
		    dDataLength--;
		    if (bCurrentStatus >= STATUS_TIMINGCLOCK)
			bCurrentStatus = STATUS_SYSEX;
		} else
		    uMessageLength--;
	    } else {
		if (bCurrentLen) {
		    if (status) {
			BYTE    bMessageLength;

			bMessageLength = (BYTE)(MIDILENGTH(status) - bCurrentLen - bStart);
			modTranslateEvent(pmidihdrMapper->lpData - bMessageLength, bStart, bMessageLength);
		    }
		    modSendLongData(uMessageLength, !status, FALSE);
		    pbHdrData = pmidihdrMapper->lpData;
		    uMessageLength = 0;
		}
		*pbHdrData = *(pbData++);
		dDataLength--;
		if (*pbHdrData >= STATUS_TIMINGCLOCK) {
		    modSendLongData(1, TRUE, FALSE);
		    continue;
		}
		bCurrentStatus = *(pbHdrData++);
		if (bCurrentStatus >= STATUS_SYSEX) {
		    status = 0;
		    bCurrentLen = (BYTE)(SYSLENGTH(bCurrentStatus) - 1);
		} else {
		    status = bCurrentStatus;
		    bCurrentLen = (BYTE)(MIDILENGTH(bCurrentStatus) - 1);
		    bStart = 0;
		}
	    }
	} else {
	    *(pbHdrData++) = *(pbData++);
	    dDataLength--;
	    if (bCurrentLen)
		bCurrentLen--;
	    else if (status) {
		bStart = 1;
		bCurrentLen = (BYTE)(MIDILENGTH(status) - 2);
	    }

	}
	uMessageLength++;
	if (!bCurrentLen && ((bCurrentStatus != STATUS_SYSEX) || (uMessageLength == MIDIDATABUFFER))) {
	    if (status) {
		BYTE    bMessageLength;

		bMessageLength = (BYTE)(MIDILENGTH(status) - bStart);
		modTranslateEvent(pmidihdrMapper->lpData - bStart, bStart, bMessageLength);
	    }
	    modSendLongData(uMessageLength, !status, FALSE);
	    pbHdrData = pmidihdrMapper->lpData;
	    uMessageLength = 0;
	}
    }
    if (uMessageLength) {
	if (status) {
	    BYTE    bMessageLength;

	    bMessageLength = (BYTE)(MIDILENGTH(status) - bCurrentLen - bStart);
	    modTranslateEvent(pmidihdrMapper->lpData - bStart, bStart, bMessageLength);
	    bStart += bMessageLength;
	}
	modSendLongData(uMessageLength, !status, FALSE);
    }

    modSendLongData(0, 0, TRUE);
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api BOOL | mapLock | This function prevents anyone from opening the
 *   mapper.
 *
 * @rdesc Returns TRUE if successful and FALSE otherwise (i.e. the mapper is
 *   already open.
 *
 * @comm This is a private function for the control panel applet to call
 *   while a setup is being edited.  There is a lock count kept - you must
 *   call mapUnlock once for each call to mapLock.
 ****************************************************************************/
BOOL FAR PASCAL mapLock(VOID)
{
    // if someone has the mapper open, return FALSE
    if( hCurMap )
	return FALSE;

    mapLockCount++;
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api VOID | mapUnlock | This function unlocks the mapper if it's locked.
 *
 * @rdesc There is no return value.
 *
 * @comm This is a private function for the control panel applet to call
 *   while a setup is being edited.  There is a lock count kept but
 *   underflow will not generate an error, and lock count will remain 0.
 ****************************************************************************/
VOID FAR PASCAL mapUnlock(VOID)
{
    if( mapLockCount )
	mapLockCount--;
    return;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api UINT | midiReadCurrentSetup | This function reads in the current setup.
 *
 * @parm DWORD | dwParam1 | The first DWORD from the <f midiOutOpen> call.
 *
 * @parm DWORD | dwParam2 | The second DWORD from the <f midiOutOpen> call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.
 ****************************************************************************/
static UINT FAR PASCAL midiReadCurrentSetup(LPMIDIOPENDESC lpOpen, DWORD dwParam2)
{
int      i,j;
WORD     devid;
MMAPERR  mmaperr;
DWORD    dwSize;
UINT     uResult;
char     szCurSetup[MMAP_MAXNAME];
WORD     wChan;

    // get current setup
    mmaperr = mapGetCurrentSetup(szCurSetup, MMAP_MAXNAME);
    if (mmaperr != MMAPERR_SUCCESS)
	return TranslateError(mmaperr);

    dwSize = mapGetSize(MMAP_SETUP, szCurSetup);
    if (dwSize < (DWORD)MMAPERR_MAXERROR)
	return TranslateError((UINT)dwSize);

    // allocate memory
    hCurMap = GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if( !hCurMap )
	return MMSYSERR_NOMEM;

    hCurMap = (HGLOBAL)GlobalLock(hCurMap);

    mmaperr = mapRead (MMAP_SETUP, szCurSetup, lpCurMap);
    if( mmaperr != MMAPERR_SUCCESS ) {
	ReleaseResources();
	return TranslateError(mmaperr);
    }

    // initialize channel and patch masks
    wChannelMask = 0;
    uPatchMask = 0;

    // initialize device list
    for (i = 0; i < 16; i++) {
	mapdevs[i].wDeviceID = (WORD)(-1);
	mapdevs[i].hMidi = NULL;
	mapdevs[i].fwFlags = 0;
    }

    // go through each source channel
    for( wChan = 0; wChan < 16; wChan++ ) {
	if( ((lpCurMap->chMap[wChan]).dwFlags) & MMAP_ACTIVE ) {

	    // set channel mask
	    wChannelMask |= (1 << wChan);

	    // set patch mask
	    if( ((lpCurMap->chMap[wChan]).dwFlags) & MMAP_PATCHMAP )
		uPatchMask |= (1 << wChan);

	    // map device id
	    devid = lpCurMap->chMap[wChan].wDeviceID;

	    // save driver and device ids for channel messages
	    chnldevs[wChan].wDeviceID = devid;

	    // algorithm for device list
	    // wChannel will have the channel mask for the device
	    for( j = 0; j < 16; j++ ) {
		if( mapdevs[j].wDeviceID == devid ) {
		    mapdevs[j].wChannel |= 0x0001 << wChan;
		    break;     // from for loop
		}
		if( mapdevs[j].wDeviceID == (WORD)(-1) ) {
		    mapdevs[j].wDeviceID = devid;
		    mapdevs[j].wChannel = (WORD)(1 << wChan);  // first channel
		    break;
		}
	    }
	}
    }

    // create a long message buffer for translation of long messages.
    {  HANDLE hMem;
       hMem = GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT
			 , (LONG)(sizeof(MIDIHDR) + MIDIDATABUFFER)
			 );
       if (hMem)
       pmidihdrMapper = ( hMem ? (LPMIDIHDR)GlobalLock(hMem) : NULL);
    }
    if (!pmidihdrMapper) {
	ReleaseResources();
	return MMSYSERR_NOMEM;
    }
    pmidihdrMapper->lpData = (LPSTR)(pmidihdrMapper + 1);
    pmidihdrMapper->dwBufferLength = MIDIDATABUFFER;

    // open all devices in new map
    for( i = 0; ((i < 16) && (mapdevs[i].wDeviceID != (WORD)(-1)) ); i++ ) {
	uResult = midiOutOpen(&mapdevs[i].hMidi,
			       mapdevs[i].wDeviceID,
			       0,
			       0,
			       dwParam2 & ~CALLBACK_TYPEMASK);

	if(uResult != 0 ){  // if any opens fail, return now
	    ReleaseResources();
	    return uResult;
	}

    uResult = midiOutPrepareHeader(mapdevs[i].hMidi, pmidihdrMapper, sizeof(MIDIHDR));
    if (uResult) {
	    ReleaseResources();
	    return uResult;
	}
	mapdevs[i].fwFlags |= DEV_PREPARED;

	for( j = 0; j < 16; j++ ) {
	    if( mapdevs[i].wDeviceID == chnldevs[j].wDeviceID )
	       chnldevs[j].hMidi = mapdevs[i].hMidi;
	}
    }

    OpenCallback = lpOpen->dwCallback;
    OpenInstance = lpOpen->dwInstance;
    OpenFlags = dwParam2;
    hmidiMapper = (HMIDIOUT)lpOpen->hMidi;
    status = 0;
    bCurrentLen = 0;
    bCurrentStatus = 0;

#if defined(WIN16)
    if (  GlobalNail((HGLOBAL)HIWORD(DriverProc), STATE_CODENAILED)
       && GlobalNail(hCurMap, STATE_MAPNAILED)
       && GlobalNail((HGLOBAL)HIWORD((DWORD)(LPVOID)&hCurMap), STATE_DATANAILED)
       )
    {
#endif //WIN16
       CallbackNotification(MOM_OPEN, 0);
       return MMSYSERR_NOERROR;
#if defined(WIN16)
    }
    ReleaseResources();
    return MMSYSERR_NOMEM;
#endif //WIN16
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\midi.h ===
/*
 * MIDI.H
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * Include file for MIDI control panel.
 */

#include <multimed.h>
#define SZCODE  char _based(_segname("_CODE"))

/* we let an intern code the mapper */
#define STUPID

#if DBG
#if defined(WIN16)
extern VOID FAR PASCAL OutputDebugStr(LPSTR szString); // in COMM.ASM
#endif //WIN16
#define MDOUT(x) (OutputDebugStr("MIDI.CPL: "), OutputDebugStr(x), OutputDebugStr("\r\n"), 0)
#define MDOUTX(x) (OutputDebugStr(x), 0)
#else
#define MDOUT(x)     0
#define MDOUTX(x)    0
#endif

/********************************************************
 *                                                      *
 *      D A T A   T Y P E S                             *
 *                                                      *
 ********************************************************/

typedef struct tag_midiboxdata {
        DLGPROC lpfnBox;                // Dialog box function.
        int     idBox;                  // Resource ID of dialog box.
} MBDATA, FAR *LPMBDATA;

/********************************************************
 *                                                      *
 *      P R O T O T Y P E S                             *
 *                                                      *
 ********************************************************/

BOOL    FAR PASCAL _loadds      EnumFunc (LPSTR, LPSTR, UINT, HWND, LPSTR);
BOOL    FAR PASCAL              InvalidPortMsgBox (HWND);
INT_PTR FAR PASCAL _loadds      KeyBox (HWND, UINT, WPARAM, LPARAM);
VOID    FAR PASCAL              Modify (BOOL);
INT_PTR FAR PASCAL _loadds      PatchBox (HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL _loadds      PropBox (HWND, UINT, WPARAM, LPARAM);
int     FAR PASCAL              QuerySave (VOID);
INT_PTR FAR PASCAL _loadds      SetupBox (HWND, UINT, WPARAM, LPARAM);

#ifdef STUPID
//int     FAR PASCAL DosDelete(LPSTR);
BOOL    FAR PASCAL DupMapCfg(LPSTR,LPSTR);
BOOL    FAR PASCAL UpdateMapCfg(LPSTR,LPSTR);
#define ISSPACE(x)      ((x)==' '||(x)=='\t')
int FAR PASCAL          ComboLookup(HWND, LPSTR);
#define MAXPATHLEN      157             // 144 + "\12345678.123"

#endif

#ifdef ALLOW_SIZING
VOID    FAR PASCAL      SizeBox (VOID);
VOID    FAR PASCAL      WriteBoxRect (VOID);
#endif // ALLOW_SIZING

/********************************************************
 *                                                      *
 *      C O M M O N   D E F I N I T I O N S             *
 *                                                      *
 ********************************************************/

#define VERTMARGIN              4               // dialog units
#define HORZMARGIN              6

#define SEL_SETUP               0               // rgSelect array indices
#define SEL_PATCH               1
#define SEL_KEY                 2

#define ID_MAINBOX              700             // dialog box id's
#define ID_KEYBOX               701
#define ID_PROPBOX              702
#define DLG_SETUPEDIT           800
#define DLG_PATCHEDIT           801
#define DLG_KEYEDIT             802
#define IDH_DLG_MIDI_NEW        803
#define ID_MAINSETUPCOMBO       100             // main dialog box ctrl id's
#define ID_MAINPATCHCOMBO       101
#define ID_MAINKEYCOMBO         102
#define ID_MAINCOMBO            103
#define ID_MAINSETUP            104
#define ID_MAINPATCH            105
#define ID_MAINKEY              106
#define ID_MAINDELETE           107
#define ID_MAINEDIT             108
#define ID_MAINNEW              109
#define ID_MAINDESC             110
#define ID_MAINNAME             111

#define ID_MAINFIRSTRADIO       ID_MAINSETUP
#define ID_MAINLASTRADIO        ID_MAINKEY

#define ID_PROPNAME             100             // propbox ctrl id's
#define ID_PROPDESC             101

#define EN_ACTIVATE             0x1000          // custom messages
#define CBN_ACTIVATE            0x1000

#define WM_MY_INITDIALOG        0x1000
#define WM_MY_ENDDIALOG         0x1001
#define WM_MY_FREEDATA          0x1002

/********************************************************
 *                                                      *
 *      S E T U P   D E F I N I T I O N S               *
 *                                                      *
 ********************************************************/

#define NUM_CHANNELS            16

#define ID_SETUPGHOSTEDITFIRST  108     // ghost ctrl: first ctrl with tabstop
#define ID_SETUPGHOSTEDITLAST   109     // ghost ctrl: last ctrl with tabstop
#define ID_SETUPPORTLIST        110     // listbox for invalid port names
#define ID_SETUPEDIT            111     // channel number edit control id
#define ID_SETUPARROW           112     // channel number edit control id
#define ID_SETUPPORTCOMBO       113     // port name combo box control id
#define ID_SETUPPATCHCOMBO      114     // patch name combo box control id
#define ID_SETUPDESTMNEM        115
#define ID_SETUPPORTMNEM        116
#define ID_SETUPPATCHMNEM       117
#define ID_SETUPCHECK           118     // first 3-state btn (there are 16)
// don't define anything after this //

/********************************************************
 *                                                      *
 *      P A T C H M A P   D E F I N I T I O N S         *
 *                                                      *
 ********************************************************/

#define ID_PATCHGHOSTEDITFIRST  108     // ghost ctrl: first ctrl with tabstop
#define ID_PATCHGHOSTEDITLAST   109     // ghost ctrl: last ctrl with tabstop
#define ID_PATCHNUMARROW        110     // patch number arrow control id
#define ID_PATCHNUMEDIT         111     // patch number edit control id
#define ID_PATCHVOLARROW        112     // volume percent arrow control id
#define ID_PATCHVOLEDIT         113     // volume percent edit control id
#define ID_PATCHCOMBO           114     // keymap combo box control id
#define ID_PATCHSCROLL          115     // scroll bar control id
#define ID_PATCHBASED           116
#define ID_PATCHDESTMNEM        117
#define ID_PATCHVOLMNEM         118
#define ID_PATCHKEYMNEM         119

/********************************************************
 *                                                      *
 *      K E Y M A P   D E F I N I T I O N S             *
 *                                                      *
 ********************************************************/

#define ID_KEYGHOSTEDITFIRST    108     // ghost ctrl: first ctrl with tabstop
#define ID_KEYGHOSTEDITLAST     109     // ghost ctrl: last ctrl with tabstop
#define ID_KEYEDIT              110     // key number edit control id
#define ID_KEYARROW             111     // key number arrow control id
#define ID_KEYSCROLL            112     // scroll bar control id
#define ID_KEYDESTMNEM          113

/********************************************************
 *                                                      *
 *      S T R I N G   D E F I N I T I O N S             *
 *                                                      *
 ********************************************************/

#define IDS_MIDIMAPPER          500
#define IDS_VANILLANAME         502
#define IDS_VANILLADESC         503

#define IDS_SETUPS              1
#define IDS_PATCHES             2
#define IDS_KEYS                3

#define IDS_TITLE               102

/*      The first three of these are singular.  The next three are plural.
**      These values must retain their relative values.
*/

#define IDS_SETUP               103
#define IDS_PATCH               104
#define IDS_KEY                 105
#define IDS_SETUPPLURAL         106
#define IDS_PATCHPLURAL         107
#define IDS_KEYPLURAL           108

#define IDS_NEW                 109
#define IDS_SAVE                110
#define IDS_DELETE              111
#define IDS_CLOSE               112
#define IDS_NONE                113
#define IDS_ERROR               114
#define IDS_MIDIMAPCFG          115
#define IDS_HELPFILE            IDS_CONTROL_HLP
#define IDS_NOENTRIES           117
#define IDS_CAPTION             118

#define IDS_PORTNAME            120
#define IDS_PATCHNAME           121
#define IDS_SOURCE              122
#define IDS_DEST                123
#define IDS_CHANNEL             124
#define IDS_ACTIVE              125
#define IDS_CREATE_QUESTION     126
#define IDS_NEW_QUESTION        127
#define IDS_CHANGE_QUESTION     128
#define IDS_SAVE_CHANGES        129
#define IDS_RESERVED            130
#define IDS_SOURCEKEY           131
#define IDS_SOURCEKEYNAME       132
#define IDS_PATCHNUMBER         133
#define IDS_SOURCEPATCH         134
#define IDS_SOURCEPATCHNAME     135
#define IDS_INVALIDDESTINATION  136
#define IDS_USERERROR           137
#define IDS_SOURCEMNUMONIC      138
#define IDS_SOURCECHANNEL       139

//#define       IDS_NOCHANGEINUSE       140
//#define       IDS_NOEDITINUSE         141
#define IDS_NODELISCURRENT      142
#define IDS_NODELISREFERENCED   143
#define IDS_VERIFYDELETE        144
#define IDS_INVALIDPORT         145
#define IDS_DUPLICATE           146
#define IDS_READONLYMODE        147
#define IDS_ACTIVETITLE         148
#define IDS_NEW_KEY             149
#define IDS_NEW_SETUP           150
#define IDS_NEW_PATCH           151

#define IDS_PATCHMAP_BASE       152     // there can be 128 patches

#define IDS_KEYMAP_BASE         300     // there can be 128 keys

// This is coding just designed to make debugging harder.
//
// Errors are in the .rc file with names like IDS_MMAPERR_INVALIDSETUP
// Grepping on that id to see where it's used gives zilch.
// It's defined here as 1004.  Grepping on 1004 gives zilch.
//
// Instead there's a new name like MMAPERR_INVALIDSETUP defined in midimap.h as 4.
// (Grepping on 4 of course gives HUNDREDS of spurious hits)
// and a routine in midi.c called VShow_Error which adds IDS_MMAPERR_BASE
// (i.e. 1000) to the error code (4) and puts out the text for that number.
// Really clever stuff heh?

#define IDS_MMAPERR_BASE                1000    // With about a dozen of them.

#define IDS_MMAPERR_SUCCESS             1000
//#define       IDS_MMAPERR_FILENOTFOUND        1001
//#define       IDS_MMAPERR_INVALIDFLAG         1002
//#define       IDS_MMAPERR_INVALIDPORT         1003
#define IDS_MMAPERR_INVALIDSETUP        1004
#define IDS_MMAPERR_INVALIDPATCH        1005
#define IDS_MMAPERR_INVALIDKEY          1006
#define IDS_MMAPERR_MEMORY              1007
#define IDS_MMAPERR_READ                1008
#define IDS_MMAPERR_WRITE               1009
#define IDS_MMAPERR_OPEN                1010
#define IDS_MMAPERR_OPEN_READONLY       1011
#define IDS_MMAPERR_CREATE              1012
//#define       IDS_MMAPERR_UNDEFINED           1013
#define IDS_MMAPERR_FULL                1014

#define IDS_FCERR_ERROR                 1015
#define IDS_FCERR_WARN                  1016
#define IDS_FCERR_SUCCESS               1017
#define IDS_FCERR_NOSRC                 1018
#define IDS_FCERR_NODEST                1019
#define IDS_FCERR_DISKFULL              1020
#define IDS_FCERR_LOMEM                 1021
#define IDS_FCERR_WRITE                 1022
#define IDS_FCERR_DISK                  1023
#define IDS_FCERR_READONLY              1024

VOID FAR PASCAL VShowError(
        HWND    hwnd,
        MMAPERR mmaperr);

extern UINT NEAR uHelpMessage;
extern DWORD NEAR dwContext;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\lengths.c ===
#include <windows.h>
#include "hack.h"

BYTE _based(_segname("_CODE")) bMidiLengths[] = {
    3,  // STATUS_NOTEOFF
    3,  // STATUS_NOTEON
    3,  // STATUS_POLYPHONICKEY
    3,  // STATUS_CONTROLCHANGE
    2,  // STATUS_PROGRAMCHANGE
    2,  // STATUS_CHANNELPRESSURE
    3,  // STATUS_PITCHBEND
};

BYTE _based(_segname("_CODE")) bSysLengths[] = {
    1,  // STATUS_SYSEX
    2,  // STATUS_QFRAME
    3,  // STATUS_SONGPOINTER
    2,  // STATUS_SONGSELECT
    1,  // STATUS_F4
    1,  // STATUS_F5
    1,  // STATUS_TUNEREQUEST
    1,  // STATUS_EOX
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\mapcopy.c ===
/* (C) Microsoft Corp., 1991. All rights reserved. */

/* mapcopy.c - duplicates the MIDIMAP.CFG file because of poor design
 * !!!!!!!!!!!! THIS IS NEEDLESS GRATUITIOUS CODE !!!!!!!!!!!!!!!!!!!
 * The MIDIMAP and applet were badly implemented and because of design
 * flaws needed this gratuitous file copy to back up the configuration
 * file.
 */

#include<windows.h>
#include <mmsystem.h>
#if defined(WIN32)
#include <port1632.h>
#endif
#include "hack.h"
#include"midimap.h"
#include "extern.h"
#include "midi.h"

#define MAXBUF  (10 * 1024)     // size of default copy buffer
#define FOPEN(sz)           (_lopen(sz,OF_READ|OF_SHARE_DENY_NONE))
#define FCREATE(sz)         (_lcreat(sz,0))
#define FCLOSE(fh)          (_lclose(fh))
#define FREAD(fh,buf,len)   (_lread(fh,buf,len))
#define FWRITE(fh,buf,len)  (_lwrite(fh,buf,len))
#define FALLOC(n)           (LPVOID)GlobalLock(GlobalAlloc(GMEM_MOVEABLE, (DWORD)(n)))
#define FFREE(n)            (GlobalUnlock((HGLOBAL)HIWORD((DWORD)(n))),GlobalFree((HGLOBAL)HIWORD((DWORD)(n))))
#define SLASH(c)            ((c) == '/' || (c) == '\\')


static int FileCopy(LPSTR szSrc, LPSTR szDst);

#if defined(WIN16)

static BOOL FileCopy(LPSTR,LPSTR);
static UINT GetFileAttributes(LPSTR);
static DWORD DosDiskFree ( BYTE bDrive );

static int DosCWDrive (VOID);

/*
 * Get DOS file attributes
 */
static UINT GetFileAttributes(LPSTR lpszPath)
{
    _asm {
        push    ds                  ; Preserve DS
        lds     dx,lpszPath         ; DS:DI = lpszPath
        mov     ax,4300h            ; Get File Attributes
        int     21h
        jc      GFAErr
        mov     ax,cx               ; AX = attribute
        jmp     GFAExit             ; Return attribute
GFAErr: mov     ah,80h              ; Return negative error code
GFAExit:
        pop     ds                  ; Restore DS
    }
}

int FAR PASCAL DosDelete(LPSTR szFile)
{
    _asm {
        push    ds                  ; Preserve DS
        lds     dx,szFile
        mov     ah,41h
        int     21h
        jc      dexit
        xor     ax,ax
dexit:
        pop     ds                  ; Restore DS
    }
}

static DWORD DosDiskFree ( BYTE bDrive )
{
    WORD wSectors,wBytes,wClusters;

    _asm {
         mov    dl,bDrive
         mov    ah,36h
         int    21h
         mov    wSectors,ax
         mov    wClusters,bx
         mov    wBytes,cx
    }

    if (wSectors == 0xffff)
        return -1;
    else
        return ((DWORD)wClusters*(DWORD)wSectors*(DWORD)wBytes);
}

static int DosCWDrive ()
{
    _asm {
        mov     ah,19h              ; Get Current Drive
        int     21h
        sub     ah,ah               ; Zero out AH
    }
}
#endif //WIN16

/*
 * Create a duplicate map file for editing
 */

BOOL FAR PASCAL DupMapCfg(LPSTR lpstrCfgPath, LPSTR lpstrBakPath)
{
    extern BOOL fReadOnly;
    UINT uAttr;
    OFSTRUCT of;
    int err;
    char szFunc[50],szMessage[256];

    if (OpenFile(lpstrCfgPath,&of,OF_EXIST|OF_SHARE_DENY_NONE) == HFILE_ERROR)
    {
        // We need to let the mapper create a new one.
        return FALSE;
    }

    uAttr = GetFileAttributes(lpstrCfgPath);
    if (uAttr != (UINT)(-1))
    {
        if (uAttr & FILE_ATTRIBUTE_READONLY)
        {

                LoadString(hLibInst, IDS_FCERR_WARN, szFunc, sizeof(szFunc));
                LoadString(hLibInst, IDS_FCERR_READONLY, szMessage, sizeof(szMessage));
                MessageBox(NULL, szMessage, szFunc,
                        MB_ICONEXCLAMATION | MB_OK);

                fReadOnly = TRUE;  // Stay Read Only for the remainder
                return FALSE;
        }
    }
    else
            return FALSE;

    err = FileCopy(lpstrCfgPath,lpstrBakPath);
    if (err != IDS_FCERR_SUCCESS)
    {
            LoadString(hLibInst, IDS_FCERR_ERROR, szFunc, sizeof(szFunc));
            LoadString(hLibInst, err, szMessage, sizeof(szMessage));
            MessageBox(NULL, szMessage, szFunc, MB_ICONHAND | MB_TASKMODAL
                    | MB_OK);

            fReadOnly = TRUE; // Read Only if there is some kind of disk problem
            return FALSE;
    }
    return TRUE;
}

/*
 * Copy the duplicate map file over the original map file
 */
BOOL FAR PASCAL UpdateMapCfg(LPSTR lpstrCfgPath, LPSTR lpstrBakPath)
{
    int err;
    char szFunc[50],szMessage[256];

    if ((err = FileCopy(lpstrBakPath,lpstrCfgPath)) != IDS_FCERR_SUCCESS)
    {
            LoadString(hLibInst, IDS_FCERR_ERROR, szFunc, sizeof(szFunc));
            LoadString(hLibInst, err, szMessage, sizeof(szMessage));
            MessageBox(NULL, szMessage, szFunc, MB_ICONHAND | MB_TASKMODAL
                    | MB_OK);
    }

    return err;
}


#if defined(WIN16)

/* So who was too lazy to write a comment? */
static int FileCopy(LPSTR szSrc,LPSTR szDst)
{
    HFILE fhSrc,fhDst;
    WORD size;
    BOOL fComplete = TRUE;
    OFSTRUCT of;
    LPSTR lpbBuf;
    DWORD dwSrcSize,dwDestFree;
    BYTE bDrive;
    int err;

    if (OpenFile(szSrc,&of,OF_EXIST|OF_SHARE_DENY_NONE) == HFILE_ERROR)
    {
        err = IDS_FCERR_NOSRC;
        goto exit; //ERROR:File Not Found
    }

    fhSrc = FOPEN(szSrc);

    if (fhSrc == HFILE_ERROR)
    {
        err = IDS_FCERR_NOSRC;
        return FALSE; //ERROR:File inaccessible
    }

    dwSrcSize = _llseek(fhSrc,0,2); //file size
    _llseek(fhSrc,0,0);

    if (*(szDst+1) == ':')
    {
            bDrive = (BYTE)(*(szDst) - 'A' + 1);
    }
    else
            bDrive = (BYTE)(DosCWDrive() + 1);


    if ((LONG)(dwDestFree = DosDiskFree(bDrive)) != -1)
    {
            if (dwSrcSize > dwDestFree)
            {
                    err = IDS_FCERR_DISKFULL;
                    goto errclose1;
            }
    }
/*      This failed on a wierd 386 machine for no good reason, so removed.
        MM Bug 6277.
    else
    {
            err = IDS_FCERR_DISK;
            goto errclose1;
    }
*/

    lpbBuf = FALLOC(MAXBUF);

    if (lpbBuf == NULL)
    {
        err = IDS_FCERR_LOMEM;
        goto errclose1; //ERROR:Low Memory
    }

    fhDst = FCREATE(szDst);

    if (fhDst == HFILE_ERROR)
    {
        err = IDS_FCERR_NODEST;
        goto errfree; //ERROR:Couldn't create Destination
    }

    while (size = FREAD(fhSrc,lpbBuf,MAXBUF))
    {
        if (FWRITE(fhDst,lpbBuf,size) != size)
        {
            err = IDS_FCERR_WRITE;
            goto errclose; //ERROR:Write Error
        }
    }
    err = IDS_FCERR_SUCCESS;

errclose:   // Close the Destination File
    FCLOSE(fhDst);
errfree:    // Free the buffer
    FFREE(lpbBuf);
errclose1:  // Close the Source File
    FCLOSE(fhSrc);
exit:
    return err;
}

#else

/* Copy the file szSrc to the file szDst, overwriting it if it already exists */
static int FileCopy(LPSTR szSrc, LPSTR szDst)
{
  if (CopyFile(szSrc, szDst, FALSE)) {
     return IDS_FCERR_SUCCESS;
  } else {
      switch (GetLastError()) {
          // ??? This is throwing away valuable error information!
          default:
              return IDS_FCERR_NOSRC;
      }
  }

} /* FileCopy */
#endif //WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\key.c ===
/*
 * KEY.C
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * Edit keymaps dialog box and support functinos.
 */

/* Revision history:
   March 92 Ported to 16/32 common code by Laurie Griffiths (LaurieGr)
*/




/*-=-=-=-=- Include Files       -=-=-=-=-*/

#include "preclude.h"
#include <windows.h>
#include <mmsystem.h>
#include <port1632.h>
#include "hack.h"
#include "cphelp.h"

#include "midimap.h"
#include "midi.h"
#include "extern.h"

/*-=-=-=-=- Prototypes          -=-=-=-=-*/

static MMAPERR PASCAL   MmaperrKeyInit(VOID);
static MMAPERR PASCAL   MmaperrKeyInitNew(VOID);
static VOID PASCAL      KeySize(BOOL);
static VOID PASCAL      KeyPaint(VOID);
static VOID PASCAL      KeyArrowScroll(UINT);
static VOID PASCAL      KeyWindowScroll(UINT, int);
static VOID PASCAL      KeyEditMsg(WORD NotifCode);
static VOID PASCAL      KeyButtonDown(LONG);
static VOID PASCAL      KeySetFocus(UINT, int);
static VOID PASCAL      KeyActiveLine(UINT, UINT);
static int PASCAL       KeySave(HWND, BOOL);

/*-=-=-=-=- Global Definitions  -=-=-=-=-*/

#define PAL_SHOW                0       // Show active line.
#define PAL_HIDE                1       // Hide active line.

#define PSF_REDRAW              0x0001  // Redraw where line used to be.
#define PSF_SHOWIFHIDDEN        0x0002  // Show line if hidden.

#define DEF_KEY_ROWS            16      // number of default key rows

/*-=-=-=-=- Global Variables    -=-=-=-=-*/

static HWND     hScroll;                // scroll bar control handle
static char     * _based(_segname("_CODE")) szNotes [] = {              // Note descriptions
        "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
};
static  SZCODE aszMidiSection[] = "midicpl";
static  SZCODE aszMidiKey[] = "keyview";
static  SZCODE aszKeyNumFormat[] = "%3d";
static  SZCODE aszNoteOctaveFormat[] = "     %s %d";
static BOOL     fKeyView;
static int      xArrowOffset;           // key arrow ctrl positional offset

/*-=-=-=-=- Functions           -=-=-=-=-*/

/*
 * KEYBOX
 */
BOOL FAR PASCAL _loadds KeyBox( HWND    hDlg,
                        UINT    uMessage,
                        WPARAM  wParam,
                        LPARAM  lParam  )
{
        int     iRet = FALSE;
        MMAPERR mmaperr;

        switch (uMessage) {

        case WM_INITDIALOG :
                hWnd = hDlg;
                SetFocus(GetDlgItem(hDlg, ID_KEYEDIT));
                if ((mmaperr = MmaperrKeyInit()) != MMAPERR_SUCCESS) {
                        VShowError(hDlg, mmaperr);
                        EndDialog(hDlg, FALSE);
                }
                SetScrollRange(hScroll, SB_CTL, 0, iVertMax, FALSE);
                SetScrollPos(hScroll, SB_CTL, iVertPos, TRUE);
		PlaceWindow(hWnd);
                return FALSE;
        case WM_COMMAND :
            {   WORD id = LOWORD(wParam);
#if defined(WIN16)
                WORD NotifCode = HIWORD(lParam);
                HWND hwnd = LOWORD(lParam);
#else
                WORD NotifCode = HIWORD(wParam);
                HWND hwnd = (HWND)lParam;
#endif //WIN16

                switch (id) {
                case  IDH_DLG_MIDI_KEYEDIT:
                  goto DoHelp;

                case ID_KEYGHOSTEDITFIRST:

                        /* assume the user back-tabbed before the first
                         * control on the current row, so jump to the
                         * previous row (if iCurPos > 0) or the last row
                         * (if iCurPos == 0)
                         */

                        if (fHidden)    //we shouldn't get these messages
                                break;  //when we're hidden -jyg

                        if (NotifCode != EN_SETFOCUS)
                                break;
                        if (iCurPos < 0)
                                /* do nothing */ ;
                        else if (iCurPos > 0)
                                iCurPos--;
                        else
                        {
                                if (iVertPos != 0)
                                {
                                        /* at top -- scroll up one line */
                                        KeyWindowScroll(SB_LINEUP, 0);
                                        iCurPos = 0;
                                }
                                else
                                {
                                        /* wrap to bottom cell */
                                        KeyWindowScroll(SB_THUMBPOSITION, iVertMax);
                                        iCurPos = nLines - 1;

                                        KeySetFocus(PSF_REDRAW|PSF_SHOWIFHIDDEN, 0);
                                        KeyActiveLine(PAL_SHOW, SWP_SHOWWINDOW);
                                }
                        }
                        KeySetFocus(PSF_REDRAW, 1);

                        break;

                case ID_KEYGHOSTEDITLAST:

                        /* assume the user forward-tabbed beyond the last
                         * control on the current row, so jump to the
                         * next row (if iCurPos < nLines - 1) or the first row
                         * (if iCurPos == nLines - 1)
                         */
                        if (fHidden)    //we shouldn't get these messages
                                break;  //when we're hidden -jyg

                        if (NotifCode != EN_SETFOCUS)
                                break;
                        if (iCurPos < 0)
                                /* do nothing */ ;
                        else
                        if (iCurPos < nLines - 1)
                                iCurPos++;
                        else
                        {
                                if (iVertPos != iVertMax)
                                {
                                        /* at bottom -- scroll down one line */
                                        KeyWindowScroll(SB_LINEDOWN, 0);
                                        iCurPos = nLines - 1;
                                }
                                else
                                {
                                        /* wrap to top cell */
                                                                                /* wrap to the top cell */
                                        KeyWindowScroll(SB_THUMBPOSITION,-iVertMax);
                                        iCurPos = 0;

                                        KeySetFocus(PSF_REDRAW|PSF_SHOWIFHIDDEN, 0);
                                        KeyActiveLine(PAL_SHOW, SWP_SHOWWINDOW);
                                }
                        }
                        KeySetFocus(PSF_REDRAW, 1);
                        break;

                case IDOK :
                case IDCANCEL :
                        if (NotifCode != BN_CLICKED)
                                break;
                        if (!fReadOnly && (id == IDOK) && (fModified)) {
                                iRet = KeySave(hDlg, TRUE);
                                if (iRet == IDCANCEL)
                                        break;
                                iRet = (iRet == IDYES);
                        } else
                                iRet = FALSE;
                        GlobalFree(hKeyMap);
                        EndDialog(hDlg, iRet);
                        break;

                case ID_KEYEDIT :
                        KeyEditMsg(NotifCode);
                        break;

                default :
                        return FALSE;
                }
                break;
            } /* end of WM_COMMAND */
        case WM_PAINT :
                KeyPaint();
                break;

        case WM_LBUTTONDOWN :
                KeyButtonDown((LONG)lParam);
                break;

        case WM_VSCROLL :
#if defined(WIN16)
                if ((HWND)HIWORD(lParam) == hScroll)
                        KeyWindowScroll(LOWORD(wParam), (int)LOWORD(lParam));
#else
                if ((HWND)lParam == hScroll)
                        KeyWindowScroll(LOWORD(wParam), (int)HIWORD(wParam));
#endif //WIN16

                else KeyArrowScroll(LOWORD(wParam));
                break;

        case WM_CLOSE :
                PostMessage(hDlg, WM_COMMAND, (WPARAM)IDOK, (LPARAM)0);
                break;

        default:
                if (uMessage == uHelpMessage) {
DoHelp:
                        WinHelp(hWnd, szMidiHlp, HELP_CONTEXT,
                                                IDH_DLG_MIDI_KEYEDIT);
                        return TRUE;
                }
                else
                        return FALSE;
                break;
        }

        return TRUE;
} /* KeyBox */

/*
 * MmaperrKeyInit
 */
static  MMAPERR PASCAL MmaperrKeyInit(
        VOID)
{
        LPMIDIKEYMAP lpKey;
        LONG    lDBU;
        MMAPERR mmaperr;
        UINT    xBU,
                yBU,
                xWidth, // width of current column
                xArrow, // width of arrow control
                xEdit,  // width of edit controls
                yEdit;  // height of edit/arrow controls
        int     i;
        char    szCaption[80];
        char    szCaptionFormat[80];

        fHidden = FALSE;
        iVertPos = 35;
        iCurPos = 0;
        nLines = 0; // necessary?

        hEdit = GetDlgItem(hWnd, ID_KEYEDIT);
        hArrow = GetDlgItem(hWnd, ID_KEYARROW);
        hScroll = GetDlgItem(hWnd, ID_KEYSCROLL);

        if (fReadOnly)
        {
                EnableWindow(GetDlgItem(hWnd,IDOK),FALSE);
                SendMessage(hWnd, DM_SETDEFID, (WPARAM)IDCANCEL, (LPARAM)0);
        }

        lDBU = GetDialogBaseUnits();
        xBU = LOWORD(lDBU);
        yBU = HIWORD(lDBU);

        xArrow = (10 * xBU) / 4;        // about yea big
        xEdit = (40 * xBU) / 4;         // 10 chars wide
        yEdit = (10 * yBU) / 8;         // cookie heaven

        rcBox.left = (HORZMARGIN * xBU) / 4;
        for (i = 0, rcBox.right = rcBox.left; i < 4; i++) {
                rgxPos [i] = rcBox.right;

                switch (i) {

                case 0 :
                        // width of src key # text (3.5 chars wide)
                        rcBox.right += xEdit;
                        break;

                case 1 :
                        // width of src key (percussion) name text
                        rcBox.right += (64 * xBU) / 4; // 16 chars wide
                        break;

                case 2 :
                        // width of dst key # edit control
                        xWidth = xEdit;
                        SetWindowPos(hEdit, NULL, 0L, 0L,
                                xWidth, yEdit, SWP_NOZORDER | SWP_NOMOVE);

                        // set global arrow control offset to proper position
                        rcBox.right += xArrowOffset = xWidth - 1;

                        // width of dst key # arrow control
                        xWidth = xArrow;
                        SetWindowPos(hArrow, NULL, 0L, 0L,
                                xWidth, yEdit, SWP_NOZORDER | SWP_NOMOVE);
                        rcBox.right += xWidth - 1;
                        break;

                case 3 :
                        break;

                }
        }

        if (!fNew) {
                DWORD   dwSize;

                dwSize = mapGetSize(MMAP_KEY, szCurrent);
                if (dwSize < MMAPERR_MAXERROR)
                        return (MMAPERR)dwSize;
                if ((hKeyMap = GlobalAlloc(GHND, dwSize)) == NULL)
                        return MMAPERR_MEMORY;
                lpKey = (LPMIDIKEYMAP)GlobalLock(hKeyMap);
                mmaperr = mapRead( MMAP_KEY, szCurrent, (LPVOID)lpKey);
                if (mmaperr == MMAPERR_SUCCESS)
                        if (lstrcmp(lpKey->szDesc, szCurDesc)) {
                                lstrcpy(lpKey->szDesc, szCurDesc);
                                fNew = TRUE;
                        }
                GlobalUnlock (hKeyMap);
                if (mmaperr != MMAPERR_SUCCESS) {
                        GlobalFree(hKeyMap);
                        hKeyMap = NULL;
                        return mmaperr;
                }
        } else if ((mmaperr = MmaperrKeyInitNew()) != MMAPERR_SUCCESS)
                return mmaperr;

        LoadString(hLibInst, IDS_KEYS, szCaptionFormat, sizeof(szCaptionFormat));
        wsprintf(szCaption, szCaptionFormat, (LPSTR)szCurrent);
        SetWindowText(hWnd, szCaption);

        SendMessage(GetDlgItem(hWnd, ID_KEYDESTMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        KeySize(TRUE);
        SetWindowPos(GetDlgItem(hWnd, ID_KEYDESTMNEM), NULL,
                rgxPos [2], yChar, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
        Modify(fNew);
        fKeyView = GetProfileInt(aszMidiSection, aszMidiKey, 0);
        return MMAPERR_SUCCESS;
} /* MmaperrKeyInit */

/*
 * MmaperrKeyInitNew
 */
static  MMAPERR PASCAL MmaperrKeyInitNew(
        VOID)
{
        LPMIDIKEYMAP    lpKey;
        int     i;

        if ((hKeyMap = GlobalAlloc(GHND,
                (DWORD)sizeof(MIDIKEYMAP))) == NULL)
                return MMAPERR_MEMORY;
        lpKey = (LPMIDIKEYMAP)GlobalLock(hKeyMap);
        lstrcpy(lpKey->szName, szCurrent);
        lstrcpy(lpKey->szDesc, szCurDesc);
        for (i = 0; i < MIDIPATCHSIZE; i++)
                lpKey->bKMap [i] = (BYTE) i;
        GlobalUnlock(hKeyMap);
        return MMAPERR_SUCCESS;
} /* MmaperrKeyInitNew */

/*
 * KEYSIZE
 */
static
VOID PASCAL KeySize(BOOL fMaximize)
{
        RECT    rcOK,
                rcWnd;
        LONG    lDBU;
        UINT    xBU,
                yBU;
        int     xButton,
                xCenter,
                yTopMar,
                yBotMar,
                yLeftOver,
                yBox,
                yMiniBotMar;

        lDBU = GetDialogBaseUnits();
        xBU = LOWORD(lDBU);
        yBU = HIWORD(lDBU);

        // get the rectangle of the OK button
        GetClientRect(GetDlgItem(hWnd, IDOK), &rcOK);

        // get x-extent of button
        xButton = rcOK.right - rcOK.left;

        // top margin is 2 characters
        yTopMar = (16 * yBU) / 8 - 6; // cookie land

        // bottom margin is 2 * minimum bottom margin dialog units +
        // height of button in pixels
        yBotMar = (VERTMARGIN * 2 * yBU) / 8 + rcOK.bottom - rcOK.top;

        if (fMaximize) {
                // maximize the key box
                SetWindowPos(hWnd, NULL, 0L, 0L,
                        rcBox.right - rcBox.left +
                        (2 * HORZMARGIN * xBU) / 4 +
                        GetSystemMetrics(SM_CXVSCROLL) +
                        (GetSystemMetrics(SM_CXDLGFRAME) + 1) * 2,
                        (DEF_KEY_ROWS * 10 * yBU) / 8 +
                        yTopMar + yBotMar +
                        GetSystemMetrics(SM_CYCAPTION) +
                        GetSystemMetrics(SM_CYDLGFRAME) * 2,
                        SWP_NOZORDER | SWP_NOMOVE);
        }

        // get the x and y extents of the client rectangle
        GetClientRect(hWnd, &rcWnd);
        xClient = rcWnd.right - rcWnd.left;
        yClient = rcWnd.bottom - rcWnd.top;

        // yChar is the height of one row in pixels - 1
        yChar = (10 * yBU) / 8 - 1;

        // xChar is the average width of a character
        xChar = xBU;

        // yBox is the room we actually have to display patchmap rows
        yBox = yClient - yTopMar - yBotMar;

        // nLines is the number of setup rows we can display
        // what is this 16 doing here?
        nLines = min(16, yBox / yChar);

        // yLeftOver is how many pixels are left over
        yLeftOver = yBox - nLines * yChar;

        // add half the leftovers to the top margin
        yTopMar += yLeftOver / 2;

        // rcBox is the box of rows and columns inside the client area
        SetRect(
                &rcBox,
                rcBox.left,
                yTopMar,
                rcBox.right,
                yTopMar + nLines * yChar);

        // xCenter is used to center the OK and CANCEL buttons horizontally
        xCenter =(rcBox.right - rcBox.left - xButton * 3) / 4;

        // yMiniBotMar is the spacing above and below the button
        yMiniBotMar = (VERTMARGIN * yBU) / 8 + yLeftOver / 4;

        SetWindowPos(
                GetDlgItem(hWnd, IDOK),
                NULL,
                rcBox.left + xCenter,
                rcBox.bottom + yMiniBotMar,
                0,
                0,
                SWP_NOSIZE | SWP_NOZORDER);

        SetWindowPos(
                GetDlgItem(hWnd, IDCANCEL),
                NULL,
                rcBox.left + xButton + xCenter * 2,
                rcBox.bottom + yMiniBotMar,
                0,
                0,
                SWP_NOSIZE | SWP_NOZORDER);

        SetWindowPos(
                GetDlgItem(hWnd, IDH_DLG_MIDI_KEYEDIT),
                NULL,
                rcBox.left + xButton * 2 + xCenter * 3,
                rcBox.bottom + yMiniBotMar,
                0,
                0,
                SWP_NOSIZE | SWP_NOZORDER);

        SetWindowPos(
                hScroll,
                NULL,
                rcBox.right,
                rcBox.top,
                GetSystemMetrics(SM_CXVSCROLL),
                rcBox.bottom - rcBox.top + 1,
                SWP_NOZORDER);

        iVertMax = max(0, MIDIPATCHSIZE - nLines);
        iVertPos = min(iVertMax, iVertPos);
        SetScrollRange(hScroll, SB_CTL, 0, iVertMax, FALSE);
        SetScrollPos(hScroll, SB_CTL, iVertPos, TRUE);

        if (iCurPos >= 0 && iCurPos < nLines)
                KeySetFocus(PSF_SHOWIFHIDDEN, 1);
        else
                KeyActiveLine(PAL_HIDE, SWP_NOREDRAW);
} /* KeySize */

/*
 * KEYPAINT
 */
static
VOID PASCAL KeyPaint(VOID)
{
        HPEN    hPen = NULL;
        LPMIDIKEYMAP lpKey;
        PAINTSTRUCT ps;
        int     i,
                iVert,
                iLeft,
                nBegin,
                nEnd,
                iTop,
                iBottom,
                iOctave,
                iNote;
        BOOL    fSelected = FALSE;
        char    szBuf [30];

        BeginPaint(hWnd, &ps);

        if (!ps.rcPaint.bottom)
                goto DonePainting;

        hPen = SelectObject(ps.hdc, GetStockObject(BLACK_PEN));
        hFont = SelectObject(ps.hdc, hFont);
        fSelected = TRUE;

        SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkMode(ps.hdc, TRANSPARENT);

        if (ps.rcPaint.top < rcBox.top) {
                iVert = yChar; // rcBox.top - (yChar * 2) - 1;
                TextOut(ps.hdc, 11, iVert, aszSourceKey, lstrlen(aszSourceKey));
                TextOut(ps.hdc, rgxPos [1] + xChar - 10, iVert,
                        aszSourceKeyName, lstrlen(aszSourceKeyName));
        }

        // calculate top and bottom y coordinates of invalid area
        iTop = max(ps.rcPaint.top, rcBox.top);

        // if top is below the box, forget about painting
        if (iTop > rcBox.bottom)
                goto DonePainting;

        iBottom = min(ps.rcPaint.bottom, rcBox.bottom);

        // calculate left x coordinate of invalid area
        iLeft = max(ps.rcPaint.left, rcBox.left);

        // calculate beginning and ending data row to be repainted
        nBegin = max(0, (iTop - rcBox.top) / yChar);
        nEnd = min(nLines, (iBottom - rcBox.top) / yChar);

        for (i = 0; i < 4; i++) {
                MMoveTo(ps.hdc, rgxPos [i], iTop);
                LineTo(ps.hdc, rgxPos [i], iBottom + 1);
        }
        // vertical position of first line we have to draw
        iVert = rcBox.top + nBegin * yChar;

        // lock the map
        lpKey = (LPMIDIKEYMAP)GlobalLock(hKeyMap);
        iOctave = (iVertPos + nBegin) / 12 - 1;
        iNote = (iVertPos + nBegin) % 12;
        for (i = nBegin; i <= nEnd; i++, iVert += yChar) {
                MMoveTo(ps.hdc, iLeft, iVert);
                LineTo(ps.hdc, min(ps.rcPaint.right, rcBox.right), iVert);

                if (i == nLines)
                        break;

                if (iLeft < rgxPos [1]) {
                        wsprintf(szBuf, aszKeyNumFormat, iVertPos + i);
                        TextOut(ps.hdc, rcBox.left + 2, iVert + 2, szBuf, 3);
                }
                if (iLeft < rgxPos [2]) {
                        if (!fKeyView) {
                                if (!LoadString(hLibInst, IDS_KEYMAP_BASE +
                                                iVertPos + i, szBuf, sizeof(szBuf)))
                                        LoadString(hLibInst, IDS_RESERVED, szBuf, sizeof(szBuf));
                        }
                        else wsprintf(szBuf, aszNoteOctaveFormat,
                                (LPSTR)szNotes [iNote], iOctave);
                        TextOut(ps.hdc, rgxPos [1] + 2, iVert + 2, szBuf,
                                lstrlen(szBuf));
                }
                if (iLeft < rgxPos [3] && i != iCurPos) {
                        wsprintf(szBuf, aszKeyNumFormat, lpKey->bKMap [iVertPos + i]);
                        TextOut(ps.hdc, rgxPos [2] + 2, iVert + 2, szBuf, 3);
                }
                if (++iNote > 11) {
                        iNote = 0;
                        iOctave++;
                }
        }
        GlobalUnlock(hKeyMap);

DonePainting:
        if (fSelected) {
                hFont = SelectObject(ps.hdc, hFont);
                hPen = SelectObject(ps.hdc, hPen);
        }
        EndPaint(hWnd, &ps);
} /* KeyPaint */

/*
 * KEYARROWSCROLL
 *
 * Interpret a scroll message for the arrow control and modify
 * the value in corresponding Keymap array.
 */
static
VOID PASCAL KeyArrowScroll(UINT wParam)
{
        LPMIDIKEYMAP lpKey;
        BYTE    bKey;

        lpKey = (LPMIDIKEYMAP)GlobalLock(hKeyMap);
        bKey = lpKey->bKMap [iVertPos + iCurPos];
        GlobalUnlock(hKeyMap);

        switch (wParam) {

        case SB_LINEDOWN :
                if (!bKey--)
                        bKey = 127;
                break;

        case SB_LINEUP :
                if (++bKey > 127)
                        bKey = 0;
                break;

        default:
                break;
        }
        SetDlgItemInt(hWnd, ID_KEYEDIT, bKey, FALSE);
} /* KeyArrowScroll */

/*
 * KEYWINDOWSCROLL
 */
static
VOID PASCAL KeyWindowScroll(    UINT    wParam,
                                int     iPos   )
{
        HDC     hDC;
        RECT    rc;
        int     iVertInc;
        BOOL    fWillBeVisible;         // will active line be visible?

        switch (wParam) {

        case SB_LINEUP :
                iVertInc = -1;
                break;

        case SB_LINEDOWN :
                iVertInc = 1;
                break;

        case SB_PAGEUP :
                iVertInc = min(-1, -nLines);
                break;

        case SB_PAGEDOWN :
                iVertInc = max(1, nLines);
                break;

        case SB_THUMBTRACK :
        case SB_THUMBPOSITION :
                iVertInc = iPos - iVertPos;
                break;

        default :
                iVertInc = 0;
        }

        iVertInc = max (-iVertPos, min(iVertInc, iVertMax - iVertPos));

        if (iVertInc != 0)
        {
                iVertPos += iVertInc;
                iCurPos -= iVertInc;

                if (iCurPos < 0 || iCurPos >= nLines) {
                        SetFocus(NULL);
                        fWillBeVisible = FALSE;
                }
                else
                        fWillBeVisible = TRUE;

                SetScrollPos(hScroll, SB_CTL, iVertPos, TRUE);

                hDC = GetDC(hWnd);
                ScrollDC(hDC, 0L, -yChar * iVertInc, &rcBox, &rcBox, NULL,
                        &rc);
                ReleaseDC(hWnd, hDC);

                if (!fHidden)
                        KeyActiveLine(PAL_HIDE, SWP_NOREDRAW);

                if (fWillBeVisible) {
                        KeySetFocus(0, 0);
                        KeyActiveLine(PAL_SHOW, SWP_NOREDRAW);
                }

                InvalidateRect(hWnd, &rc, TRUE);
                UpdateWindow(hWnd);
        }
} /* KeyWindowScroll */

/*
 * KEYEDITMSG
 *
 * This function deals with EN_UPDATE and EN_ACTIVATE messages sent
 * to the key number edit control through the WM_COMMAND message.
 */
static
VOID PASCAL KeyEditMsg(WORD NotifCode)
{
        LPMIDIKEYMAP lpKey;
        LPBYTE  lpbKey;
        UINT    uVal;
        BOOL    bTranslate;

        if (NotifCode != EN_UPDATE && NotifCode != EN_ACTIVATE)
                return;

        lpKey = (LPMIDIKEYMAP)GlobalLock(hKeyMap);

        switch (NotifCode) {

        case EN_UPDATE :
                lpbKey = &lpKey->bKMap [iVertPos + iCurPos];
                uVal = (UINT)GetDlgItemInt(hWnd, ID_KEYEDIT, &bTranslate, FALSE);
                if (uVal <= 127) {
                        if (*lpbKey != (BYTE) uVal) {
                                *lpbKey = (BYTE)uVal;
                                Modify(TRUE);
                        }
                }
                else SetDlgItemInt(hWnd, ID_KEYEDIT, *lpbKey, FALSE);
                break;

        case EN_ACTIVATE :
                SetDlgItemInt(hWnd, ID_KEYEDIT, lpKey->bKMap [iVertPos +
                        iCurPos], FALSE);
                break;

        default :
                break;

        }

        GlobalUnlock(hKeyMap);
} /* KeyEditMsg */

/*
 * KEYBUTTONDOWN
 */
static
VOID PASCAL KeyButtonDown(LONG lParam)
{
        int     x = LOWORD(lParam),
                y = HIWORD(lParam),
                iPos;
        UINT    uFlags;

        if (x < rcBox.left || x > rcBox.right)
                return;
        if (y < rcBox.top || y > rcBox.bottom)
                return;

        iPos = min(nLines - 1, (y - rcBox.top) / yChar);

        if (iPos == iCurPos)
                return;

        if (iCurPos >= 0 && iCurPos < nLines) {
                uFlags = PSF_REDRAW;
                UpdateWindow(hWnd);
        }
        else uFlags = PSF_SHOWIFHIDDEN;

        iCurPos = iPos;
        KeySetFocus(uFlags, x);
} /* KeyButtonDown */

/*
 * KEYSETFOCUS
 */
static
VOID PASCAL KeySetFocus(        UINT    uFlags,
                                int     xPos )
{
        RECT    rc;
        int     yPos = rcBox.top + iCurPos * yChar;

        KeyEditMsg(EN_ACTIVATE);

        GetWindowRect(hEdit, &rc);
        /* on NT this returns a BOOL success indicator.  So what? */

        SetWindowPos(hEdit, NULL, rgxPos [2], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);
        SetWindowPos(hArrow, NULL, rgxPos [2] + xArrowOffset, yPos, 0,
                0L, SWP_NOZORDER | SWP_NOSIZE);

        if (fHidden && uFlags & PSF_SHOWIFHIDDEN) {
                KeyActiveLine(PAL_SHOW, 0L);
                UpdateWindow(hEdit);
                UpdateWindow(hArrow);
        }

        if (uFlags & PSF_REDRAW && rc.right) {
                ScreenToClient(hWnd, (LPPOINT)&rc);
                ScreenToClient(hWnd, (LPPOINT)&rc + 1);
                rc.right = rcBox.right + 1;
                InvalidateRect(hWnd, &rc, FALSE);
                UpdateWindow(hWnd);
        }
        if (!fHidden)
                SetFocus(hEdit);
#if defined(WIN16)
        SendMessage(hEdit, EM_SETSEL, (WPARAM)NULL, MAKELPARAM(0, 32767));
#else
        SendMessage(hEdit, EM_SETSEL, (WPARAM)NULL, (LPARAM)-1);
#endif //WIN16
} /* KeySetFocus */

/*
 * KEYACTIVELINE
 */
static
VOID PASCAL KeyActiveLine(      UINT    uCase,
                                UINT    uFlags )
{
        static const UINT uDefFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER;

        switch (uCase) {

        case PAL_SHOW :
                if (!fHidden)
                        return;

                uFlags |= SWP_SHOWWINDOW;
                fHidden = FALSE;
                break;

        case PAL_HIDE :
                if (fHidden)
                        return;

                uFlags |= SWP_HIDEWINDOW;
                fHidden = TRUE;
                break;

        default :
                break;

        }
        uFlags |= uDefFlags;
        SetWindowPos(hEdit, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hArrow, NULL, 0L, 0L, 0L, 0L, uFlags);

        if (uCase == PAL_SHOW && !fHidden)
                SetFocus(hEdit);
} /* KeyActiveLine */

/*
 * KEYSAVE
 */
static  int PASCAL KeySave(
        HWND    hdlg,
        BOOL    bQuery)
{
        LPMIDIKEYMAP    lpKey;
        MMAPERR mmaperr;
        int     iRet = 0;    // Should be a value which is NOT IDCANCEL or IDYES

        if (bQuery) {
                iRet = QuerySave();

                if (iRet != IDYES)
                        return iRet;
        }
        lpKey = (LPMIDIKEYMAP)GlobalLock(hKeyMap);
        mmaperr = mapWrite(MMAP_KEY, (LPVOID)lpKey);
        GlobalUnlock(hKeyMap);
        if (mmaperr != MMAPERR_SUCCESS) {
                VShowError(hdlg, mmaperr);
                return IDCANCEL;
        }
        Modify(FALSE);
        if (fNew)
                fNew = FALSE;

        return iRet;
} /* KeySave */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\midi.c ===
/*

 * MIDI.C
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * The MIDI control panel applet.
 *
 * History:
 *
 *  t-mikemc    10-Apr-90 Created.
 */
/* Revision history:
   March 92 Ported to 16/32 common code by Laurie Griffiths (LaurieGr)
*/

/*-=-=-=-=- Include Files       -=-=-=-=-*/

#include        "preclude.h"
#include        <windows.h>
#include        <mmsystem.h>
#if defined(WIN32)
#include        <port1632.h>
#endif
#include "hack.h"
#include        "midimap.h"
#include        <cpl.h>
#include        "cphelp.h"
#include        "cparrow.h"
#include        "midi.h"

/*-=- poop -=-*/

#define MM_MAXRESLEN    32      // arbitrary maximum resource string length
/*-=-=-=-=- Prototypes          -=-=-=-=-*/

INT_PTR CALLBACK MainBox (HWND, UINT, WPARAM, LPARAM);

BOOL NEAR PASCAL LibMain(HINSTANCE,UINT,LPSTR);
#if defined(WIN16)
#pragma alloc_text(_INIT, LibMain)
#endif //WIN16

LRESULT FAR PASCAL _loadds CPlApplet(HWND,UINT,WPARAM,LPARAM);
#if defined(WIN16)
#pragma alloc_text(_INIT, CPlApplet)
#endif //WIN16

void NEAR PASCAL InitCPL(void);
#if defined(WIN16)
#pragma alloc_text(_INIT, InitCPL)
#endif //WIN16


/*-=-=-=-=- Global Variables    -=-=-=-=-*/

/* This many global variables is a sure sign of sickness.  LaurieGr */

HINSTANCE       hLibInst;               // Library instance handle.
HGLOBAL hKeyMap;                        // Midikeymap handle.
HFONT   hFont;                          // Dialog box font handle.
HWND    hWnd,                           // Current window handle.
        hCombo,                         // Combo box handle.
        hEdit,                          // Edit control handle.
        hArrow;                         // Arrow control handle.
RECT    rcBox;                          // Clipping/scroll rectangle.
int     rgxPos[8],                      // horizontal line positions.
        yBox,                           // rows of data y extent
        xClient,                        // Window client area x pixels.
        yClient,                        // Window client area y pixels.
        iCurPos,                        // Current position on screen.
        iVertPos,                       // Current vertical scroll position.
        iVertMax,                       // Maximum veritcal scroll position.
        nLines,                         // Number of lines of data.
        yChar,                          // Height of character in font.
        xChar,                          // Width of average character in font.
        iMap;                           // Current map type being edited.
char    szCurrent[MMAP_MAXNAME],        // Current map name.
        szCurDesc[MMAP_MAXDESC],        // Current map description.
        szCurSetup[MMAP_MAXNAME],       // Current setup
        szNone[16],                     // Generic global string.
        szMidiCtl[64],                  // Window caption for midicpl.
        aszSourceKey[32],
        aszSourceKeyName[40],
        aszPatchNumber[40],
        aszSourcePatch[32],
        aszSourcePatchName[40],
        aszSourceMnumonic[5],
        aszSourceChannel[32],
        aszActive[32],
        szMidiHlp[24];
BOOL    fModified,                      // Flag; Has the map been modified?
        fChanged,                       // Flag; Has anything ever been changed?
        fNew,                           // Flag; Is this a new map?
        fHidden;                        // Flag; Is the acitve line hidden?
BOOL    fReadOnly;
char    aszClose[16];

static  char aszCaptionFormat[24];
static  SZCODE szHelpMessage[] = "ShellHelp";
static  SZCODE aszTempPrefix[] = "mmr";         // limited to 3 characters
static  SZCODE aszFontName[] = "MS Sans Serif";
static  BOOL fAppletEntered;            // Disallow multiple applet instances
UINT near uHelpMessage;
DWORD near dwContext;

typedef struct {
        int idIcon;
        int idName;
        int idInfo;
        BOOL bEnabled;
        DWORD dwContext;
        PSTR pszHelp;
} APPLET_INFO;

#define NUM_APPLETS 1
APPLET_INFO near applets[NUM_APPLETS];


/* Move the window, if necessary, to keep it on the desktop, as far as possible */
VOID PlaceWindow(HWND hwnd)
{
    RECT rcWind;  /* window rectangle */
    HDC hdc;      /* so we can get device capabilities -i.e. screen size */
    int up;       /* amount to move window up */
    int left;     /* amount to move window left */
    int HorzRes;  /* horizontal screen resolution in pixels */
    int VertRes;  /* vertical screen resolution in lines */

     /* GetWindowRect(HWND_DESKTOP, &rcDesk) doesn't work! */
    hdc = GetDC(hwnd);
    HorzRes = GetDeviceCaps(hdc,HORZRES);
    VertRes = GetDeviceCaps(hdc,VERTRES);
    GetWindowRect(hwnd, &rcWind);
    up = rcWind.bottom - VertRes;       /* how much to move up to get onto screen... */
    if (up<0) up = 0;			/* don't bother to go down to get to the bottom */
    if (up>rcWind.top) up = rcWind.top;	/* don't ever go off the top */

    left = rcWind.right - HorzRes;       /* how much to move left to get all on screen... */
    if (left<0) left = 0;		 /* don't bother to go right */
    if (left>rcWind.left) left = rcWind.left; /* but don't ever go off the left */

    SetWindowPos( hwnd, HWND_TOP, rcWind.left-left, rcWind.top-up, 0,0,SWP_NOSIZE);

} /* PlaceWindow */


VOID NEAR PASCAL CancelToClose(HWND hDlg)
{
    if (!fReadOnly) {
        char    aszText[16];

        GetDlgItemText(hDlg, IDOK, aszText, sizeof(aszText));
        if (lstrcmp(aszText, aszClose))
            SetDlgItemText(hDlg, IDOK, aszClose);
    }
}

//      -       -       -       -       -       -       -       -       -

//      Windows entry point.

BOOL NEAR PASCAL LibMain(
        HINSTANCE       hInstance,
        UINT    uHeapSize,
        LPSTR   lpCmdLine)
{
        hLibInst = hInstance;
        return TRUE;
}


void NEAR PASCAL InitCPL(void)
{
        if ( applets[0].idIcon == 0 )
        {
                LoadString(hLibInst, IDS_CLOSE,  aszClose, sizeof(aszClose));
                applets[0].idIcon = ID_ICON;
                applets[0].idName = IDS_NAME;
                applets[0].idInfo = IDS_INFO;
                applets[0].bEnabled = TRUE;
                applets[0].dwContext = IDH_CHILD_MIDI;
                applets[0].pszHelp = szMidiHlp;
                LoadString(hLibInst, IDS_NONE, szNone, sizeof(szNone));
                LoadString(hLibInst, IDS_HELPFILE, szMidiHlp, sizeof(szMidiHlp));
                LoadString(hLibInst, IDS_SOURCEKEY, aszSourceKey, sizeof(aszSourceKey));
                LoadString(hLibInst, IDS_SOURCEKEYNAME, aszSourceKeyName, sizeof(aszSourceKeyName));
                LoadString(hLibInst, IDS_PATCHNUMBER, aszPatchNumber, sizeof(aszPatchNumber));
                LoadString(hLibInst, IDS_SOURCEPATCH, aszSourcePatch, sizeof(aszSourcePatch));
                LoadString(hLibInst, IDS_SOURCEPATCHNAME, aszSourcePatchName, sizeof(aszSourcePatchName));
                LoadString(hLibInst, IDS_SOURCEMNUMONIC, aszSourceMnumonic, sizeof(aszSourceMnumonic));
                LoadString(hLibInst, IDS_SOURCECHANNEL, aszSourceChannel, sizeof(aszSourceChannel));
                LoadString(hLibInst, IDS_ACTIVETITLE, aszActive, sizeof(aszActive));
        }
}

#ifdef STUPID
/*
 * ComboBox String Lookup, written because we
 * let an intern design this applet.
 */

int FAR PASCAL ComboLookup(
        HWND hCombo,
        LPSTR szLookup)
{
        int iEntries;
        static char szBuf[29];
        PSTR pstrBuf;

        iEntries = (int)(LONG)SendMessage(hCombo,CB_GETCOUNT,(WPARAM)0,(LPARAM)0);

        if (iEntries > CB_ERR)
        {
                do
                {
                        iEntries--;
                        pstrBuf = szBuf;
                        if ((int)(LONG)SendMessage(hCombo,CB_GETLBTEXT,(WPARAM)iEntries,(LPARAM)(LPSTR)szBuf) == CB_ERR)
                                return CB_ERR;

                        if (lstrcmpi(szLookup,pstrBuf) == 0)
                                return iEntries;
                }
                while(iEntries);
        }
        return CB_ERR;
}
#endif

//      Given an error code, display an error message.  If the error code
//      was invalid, displays a default bogus English-language text string.

VOID FAR PASCAL VShowError(
        HWND    hwnd,           // Window to tie the message box to.
        MMAPERR mmaperr)        // Error code to display text for.
{
        char    asz[256];

        LoadString(hLibInst, IDS_MMAPERR_BASE + mmaperr, asz, sizeof(asz));
        MessageBox(hwnd, asz, NULL, MB_ICONEXCLAMATION | MB_OK);
}

//      -       -       -       -       -       -       -       -       -

//      Returns TRUE if the file exists and is correct, or was initialized
//      properly.  Returns FALSE if the user didn't want it initialized, or
//      if the initialization failed.
//
//      This function deals with English-language specific stuff.  There is
//      no good reason for this that I can see.

static  BOOL FAR PASCAL FGetMapFile(
        HWND    hwnd)
{
        char    aszBuf[256];
        DWORD   dwVersion;
        MMAPERR mmaperr;

        //
        //      An error return from "mapFileVersion" indicates a problem that
        //      I don't want to go into too specifically at this time.  The
        //      most likely event is that the file doesn't exist.  The code in
        //      in this function assumes that this is what happened.  If it
        //      was another problem, hopefully initializing the file will
        //      solve it.  This can be looked into later.
        //
        dwVersion = mapFileVersion();
        if ((HIWORD(dwVersion) == MMAPERR_SUCCESS) &&
                (LOWORD(dwVersion) == 1))
                return TRUE;    // File was fine (opened + was right version).
        //
        //      This code is executing if there was a problem opening the
        //      file.  Hopefully this problem involved non-existence.
        //
        LoadString(hLibInst, IDS_CREATE_QUESTION, aszBuf, sizeof(aszBuf));
        if (MessageBox(hwnd, aszBuf, szMidiCtl,
                MB_YESNO | MB_ICONHAND) == IDYES)
                if ((mmaperr = mapInitMapFile()) == MMAPERR_SUCCESS)
                        return TRUE;
                else
                        VShowError(hwnd, mmaperr);

        return FALSE;
}

//      -       -       -       -       -       -       -       -       -

//      Control panel entry point.

LRESULT FAR PASCAL _loadds CPlApplet(
        HWND    hCPlWnd,
        UINT    uMessage,
        WPARAM  lParam1,
        LPARAM  lParam2)
{
        LPNEWCPLINFO    lpCPlInfo;
        BOOL    fSuccess = TRUE;
        BOOL    fBackup;
        LPSTR   lpstrBakPath;
        LPSTR   lpstrCfgPath;
        int     iApplet;

        switch (uMessage) {
        case CPL_INIT :
                InitCPL();
                uHelpMessage = RegisterWindowMessage(szHelpMessage);
                hWnd = hCPlWnd;
                return (LRESULT)TRUE;
        case CPL_GETCOUNT :
                return (LRESULT)NUM_APPLETS;
        case CPL_NEWINQUIRE :
                lpCPlInfo = (LPNEWCPLINFO)lParam2;
                iApplet = (int)(LONG)lParam1;
                lpCPlInfo->hIcon = LoadIcon(hLibInst,
                                          MAKEINTRESOURCE(applets[iApplet].idIcon));
                LoadString(hLibInst, applets[iApplet].idName, lpCPlInfo->szName, sizeof(lpCPlInfo->szName));
                LoadString(hLibInst, applets[iApplet].idInfo, lpCPlInfo->szInfo, sizeof(lpCPlInfo->szInfo));
                lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
                lpCPlInfo->lData = (LONG)iApplet;
                lpCPlInfo->dwHelpContext = applets[iApplet].dwContext;
                lstrcpy(lpCPlInfo->szHelpFile, applets[iApplet].pszHelp);
                return (LRESULT)TRUE;
        case CPL_DBLCLK :
                if (fAppletEntered)
                        break;
                //
                // We can enter into lots of bizarre states:

                // We become READ-ONLY IF:
                //      We cannot lock the mapper.
                //      There is a disk or memory exception backing up the
                //              existing MIDIMAP.CFG file or the MIDIMAP.CFG
                //              is READ ONLY.
                // We DO NOT use a backup IF:
                //      The mapper is locked.
                //      No MIDIMAP.CFG file is found.
                //      There is an exception dealing with backing up the
                //              the existing MIDIMAP.CFG file.
                //

                lpstrCfgPath = GlobalLock(GlobalAlloc(GHND,MAXPATHLEN));
                if (lpstrCfgPath == NULL)
                {
                        VShowError(hCPlWnd,IDS_MMAPERR_MEMORY);
                        break;
                }

                lpstrBakPath = GlobalLock(GlobalAlloc(GHND,MAXPATHLEN));
                if (lpstrBakPath == NULL)
                {
                        VShowError(hCPlWnd,IDS_MMAPERR_MEMORY);
                        goto exitfree;
                }

                fAppletEntered = TRUE;
                if (!mapLock()) // Attempt to lock the mapper
                {
                        char szApp[32],
                             szMessage[256];

                        LoadString(hLibInst, IDS_READONLYMODE, szMessage, sizeof(szMessage));
                        LoadString(hLibInst, IDS_TITLE, szApp, sizeof(szApp));

                        MessageBox(hCPlWnd, szMessage, szApp,
                                MB_ICONINFORMATION | MB_OK);

                        fBackup = FALSE;        // No backups
                        fReadOnly = TRUE;       // Read Only Mode
                }
                else
                {
                        fBackup = TRUE;         // Try to do a backup
                        fReadOnly = FALSE;      // Not in READ ONLY mode
                }

                if (fBackup)
                {
                        char    szMapCfg[MMAP_MAXCFGNAME];

                        LoadString(hLibInst,IDS_MIDIMAPCFG,szMapCfg,MMAP_MAXCFGNAME);
                        GetSystemDirectory(lpstrCfgPath,MAXPATHLEN - sizeof(szMapCfg));
                        lstrcat(lpstrCfgPath,szMapCfg);

                        MGetTempFileName(0, aszTempPrefix,0,lpstrBakPath);

                        if (DupMapCfg(lpstrCfgPath,lpstrBakPath)) {
                                mapConnect(lpstrBakPath);

                        }
                        else
                        {
                                // No Backups.
                                fBackup = FALSE;
                                // if fReadOnly == TRUE, the exception
                                //    has forced us into READ-ONLY mode
                                // else
                                //    we didn't have a MIDIMAP.CFG file
                                //    and we'll read/write directly.
                                if (fReadOnly)
                                        mapUnlock();

                                DosDelete(lpstrBakPath);  // GetTempFileName Creates a File of size 0
                        }
                }

                if (!FGetMapFile(hCPlWnd))
                {
                        fSuccess = FALSE;
                        goto appexit;
                }
                // !!! Never unregisters the class, so this will come back
                //  FALSE on subsequent startups.  This is of course bogus.
                (VOID)RegisterArrowClass(hLibInst);
#if 0
                if ((hFont = CreateFont(8, NULL, NULL, NULL,
                        FW_NORMAL, NULL, NULL, NULL,
                        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, PROOF_QUALITY,
                        VARIABLE_PITCH | FF_DONTCARE, aszFontName)) == NULL)
                        goto appexit;
#else
                {
                        LOGFONT lf;

                        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf, 0);
                        if (!(hFont = CreateFontIndirect(&lf)))
                                goto appexit;
                }
#endif

                fSuccess = (BOOL)DialogBox(hLibInst, MAKEINTRESOURCE(ID_MAINBOX),
                        hCPlWnd, MainBox);
                UnregisterArrowClass(hLibInst);
                DeleteObject(hFont);

appexit:
                if (fBackup)
                {
                        MDOUT("Disconnecting from mapper");
                        mapDisconnect();
                        if (fSuccess)
                        {
                                MDOUT("Updating Backup");
                                UpdateMapCfg(lpstrCfgPath,lpstrBakPath);
                        }
                        mapUnlock();
                        DosDelete(lpstrBakPath);
                }
                else
                if (!fReadOnly)
                {
                        mapUnlock();
                        if (!fSuccess)
                                DosDelete(lpstrCfgPath);
                }

                fAppletEntered = FALSE;
                GlobalFree((HGLOBAL)lpstrBakPath);
exitfree:       GlobalFree((HGLOBAL)lpstrCfgPath);

                break;
        }
        return (LRESULT)0;
}

//      -       -       -       -       -       -       -       -       -

//      This will return either "MMAPERR_SUCCESS" if everything is fine,
//      or will return "MMAPERR_INVALIDPORT" if the setup references a
//      bogus port.  These are both expected conditions.
//
//      Unexpected conditions can also happen, which are returned.

static  MMAPERR NEAR PASCAL MmaperrInvalidPortCheck(
        LPSTR   lszName)                // Name of current setup.
{
        LPMIDIMAP lpMap;
        MMAPERR mmaperr;
        DWORD   dwSize;
        HGLOBAL hMidiMap;

        if ((dwSize = mapGetSize(MMAP_SETUP, lszName)) < MMAPERR_MAXERROR)
                return (MMAPERR)dwSize;
        if ((hMidiMap = GlobalAlloc(GHND, dwSize)) == NULL)
                return MMAPERR_MEMORY;
        lpMap = (LPMIDIMAP)GlobalLock(hMidiMap);
        mmaperr = mapRead(MMAP_SETUP, lszName, (LPVOID)lpMap);
        GlobalUnlock(hMidiMap);
        GlobalFree(hMidiMap);
        return mmaperr;
}

//      -       -       -       -       -       -       -       -       -

//      Converts a "MMAP_" into a "IDS_", i.e. converts "MMAP_SETUP" into
//      "IDS_SETUP", which can be used to get the word "Setup" out of the
//      "midi.rc" file.

static  int PASCAL IdsGetMapNameId( int iMap)
{
        if (iMap == MMAP_SETUP)
                return IDS_SETUP;
        if (iMap == MMAP_PATCH)
                return IDS_PATCH;
        return IDS_KEY;
}

//      -       -       -       -       -       -       -       -       -

/*
 * DELETEMAP
 *
 * This function returns TRUE if it is OK to delete whatever map
 * exists in szCurrent.
 */

static  BOOL NEAR PASCAL FConfirmDeleteMap(
        HWND    hwnd)
{
        char    szSetup[MMAP_MAXNAME],
                szSrc[MM_MAXRESLEN],
                szUsedBy[MM_MAXRESLEN],
                szDel[50],
                szCap[50],
                szRsrc[256],
                szBuf[256];
        DWORD   dwRet;
        UINT    uSrcID;
        UINT    uUsage;
        MMAPERR mmaperr;


        uSrcID = IdsGetMapNameId(iMap);
        LoadString(hLibInst, uSrcID, szSrc, sizeof(szSrc));
        LoadString(hLibInst, IDS_DELETE, szDel, sizeof(szDel));
        wsprintf(szCap, szDel, (LPSTR)szSrc);
//      AnsiUpperBuff(szSrc, 1);        // Upper-case first character.
        switch (iMap) {
        case MMAP_SETUP:
                if ((mmaperr = mapGetCurrentSetup(szSetup,
                        MMAP_MAXNAME)) != MMAPERR_SUCCESS) {
                        VShowError(hwnd, mmaperr);
                        return FALSE;
                }
                if (lstrcmpi(szSetup, szCurrent))
                        break;
                LoadString(hLibInst, IDS_NODELISCURRENT, szRsrc, sizeof(szRsrc));
                wsprintf(szBuf, szRsrc, (LPSTR)szCurrent);
                MessageBox(hwnd, szBuf, szCap,
                        MB_ICONINFORMATION | MB_OK);
                return FALSE;
        case MMAP_PATCH:
        case MMAP_KEY:
                dwRet = mapGetUsageCount(iMap, szCurrent);
                if (LOWORD(dwRet) != MMAPERR_SUCCESS) {
                        VShowError(hwnd, LOWORD(dwRet));
                        return FALSE;
                }
                if (!(uUsage = HIWORD(dwRet)))
                        break;
                uSrcID--;               // Patch->Setup, Key->Patch
                if (uUsage > 1)         // Make a singular a plural.  This
                        uSrcID += 3;    //  "3" is commented in "midi.h".
                LoadString(hLibInst, uSrcID, szUsedBy, sizeof(szUsedBy));
//              AnsiLowerBuff(szUsedBy, 1);     // Lower-case first character.
                LoadString(hLibInst, IDS_NODELISREFERENCED, szRsrc, sizeof(szRsrc));
                wsprintf(szBuf, szRsrc, (LPSTR)szSrc, (LPSTR)szCurrent,
                        uUsage, (LPSTR)szUsedBy);
                MessageBox (hwnd, szBuf, szCap,
                        MB_ICONINFORMATION | MB_OK);
                return FALSE;
        }
        LoadString(hLibInst, IDS_VERIFYDELETE, szRsrc, sizeof(szRsrc));
        wsprintf(szBuf, szRsrc, (LPSTR)szSrc, (LPSTR)szCurrent);
        return (IDYES == MessageBox (hwnd, szBuf, szCap,
                MB_ICONEXCLAMATION | MB_YESNO));
}

static VOID NEAR PASCAL VFreeItemData(
        HWND    hdlg,
        int     idCtrl)
{
        UINT    uCount;

        uCount = (UINT)SendDlgItemMessage(hdlg, idCtrl, CB_GETCOUNT, (WPARAM)NULL, (LPARAM)0);
        for (; uCount--; ) {
                HGLOBAL hDescription;

                if ((hDescription = (HGLOBAL)(DWORD)SendDlgItemMessage(hdlg, idCtrl,
                        CB_GETITEMDATA, (WPARAM)uCount, (LPARAM)0)) != NULL)
                        GlobalFree(hDescription);
        }
}

static  VOID NEAR PASCAL GetMBData(
        UINT    uFlag,
        LPMBDATA        lpmbData)
{
        switch (uFlag) {
        case MMAP_SETUP:
                lpmbData->lpfnBox = SetupBox;
                lpmbData->idBox = DLG_SETUPEDIT;
                break;
        case MMAP_PATCH:
                lpmbData->lpfnBox = PatchBox;
                lpmbData->idBox = DLG_PATCHEDIT;
                break;
        case MMAP_KEY:
                lpmbData->lpfnBox = KeyBox;
                lpmbData->idBox = DLG_KEYEDIT;
                break;
        default:
                lpmbData->lpfnBox = 0L;
                lpmbData->idBox = 0;
                break;
        }
} /* GetMBData */

static  BOOL PASCAL FEditMap(
        HWND    hwnd)
{
        HWND    hTmpWnd;
        MBDATA  mbData;
        DWORD   dwRet;
        int     iRet;
        BOOL    fInSetup;
        char    szSetup[MMAP_MAXNAME];
        MMAPERR mmaperr;

        if ((mmaperr = mapGetCurrentSetup(szSetup,
                MMAP_MAXNAME)) != MMAPERR_SUCCESS) {
                VShowError(hwnd, mmaperr);
                return FALSE;
        }
        switch (iMap) {
        case MMAP_SETUP :
                fInSetup = (BOOL)!lstrcmpi(szCurrent, szSetup);
                break;
        case MMAP_PATCH :
                dwRet = mapPatchMapInSetup(szCurrent, szSetup);
                if (LOWORD(dwRet) != MMAPERR_SUCCESS)
                        return FALSE;
                fInSetup = (BOOL)HIWORD(dwRet);
                break;
        case MMAP_KEY :
                dwRet = mapKeyMapInSetup (szCurrent, szSetup);
                if (LOWORD(dwRet) != MMAPERR_SUCCESS)
                        return FALSE;
                fInSetup = (BOOL)HIWORD(dwRet);
                break;
        }
        hTmpWnd = hWnd;         // "hWnd", not "hwnd".
        GetMBData(iMap, &mbData);
        iRet = (int)DialogBox(hLibInst, MAKEINTRESOURCE(mbData.idBox),
                hWnd, mbData.lpfnBox);
        hWnd = hTmpWnd;
        return iRet;
} /* FEditMap */

static  VOID NEAR PASCAL EnableMain(
        BOOL    fEnable)
{
        char    aszNoEntries[48];

        EnableWindow(hCombo, fEnable);
        if (fReadOnly)
        {
                EnableWindow(GetDlgItem (hWnd, ID_MAINDELETE), FALSE);
                EnableWindow(GetDlgItem (hWnd,ID_MAINNEW),FALSE);
        }
        else
                EnableWindow(GetDlgItem (hWnd, ID_MAINDELETE), fEnable);
        EnableWindow(GetDlgItem (hWnd, ID_MAINEDIT), fEnable);
        EnableWindow(GetDlgItem (hWnd, ID_MAINDESC), fEnable);
        EnableWindow(GetDlgItem (hWnd, ID_MAINNAME), fEnable);
        if (!fEnable) {
                LoadString(hLibInst, IDS_NOENTRIES, aszNoEntries, sizeof(aszNoEntries));
                SetDlgItemText(hWnd, ID_MAINDESC, aszNoEntries);
        }

} /* EnableMain */

static VOID NEAR PASCAL ShowMaps (int nMap)
{
        if (iMap == nMap)
                return;
        iMap = nMap;
        SendMessage(hWnd, WM_MY_INITDIALOG, (WPARAM)NULL, (LPARAM)0);
} /* ShowMaps */

INT_PTR CALLBACK MainBox(
        HWND    hdlg,
        UINT    uMessage,
        WPARAM  wParam,
        LPARAM  lParam)
{
        static BOOL     fChange,                // has edittext changed?
                        fPatchEnum,             // have patches been enum'd?
                        fKeyEnum,               // have keys been enum'd?
                        fEnabled;
        static UINT     uDeleted;               // which maps types deleted
        static char     aszInitialSetup[MMAP_MAXNAME]; // initial setup name
        MMAPERR mmaperr;
        HGLOBAL hDesc;
        LPSTR   lpDesc;
        UINT    uIdx;
        int     idCurCombo;
        BOOL    fEnum;
//      char    szBuf[128];
        char    szTmpDesc[MMAP_MAXDESC];

        switch (uMessage) {
        case WM_INITDIALOG:
                // get the current setup name and store in
                // static aszInitialSetup
                fChanged = FALSE;
                if ((mmaperr = mapGetCurrentSetup(aszInitialSetup,
                        MMAP_MAXNAME)) != MMAPERR_SUCCESS) {
exit00:                 VShowError(hdlg, mmaperr);
/*exit01:*/             EndDialog (hdlg, FALSE);
                        return TRUE;
                }
                lstrcpy(szCurSetup, aszInitialSetup);
                // Load caption string and set the window text
                LoadString(hLibInst, IDS_TITLE, szMidiCtl, sizeof(szMidiCtl));
                hWnd = hdlg;
                SetWindowText(hdlg, szMidiCtl);
/*!!
                // check for invalid devices
                if ((mmaperr = MmaperrInvalidPortCheck(
                        aszInitialSetup)) == MMAPERR_INVALIDPORT) {
                        if (!InvalidPortMsgBox(hdlg))
                                goto exit01;
                }
                else if (mmaperr != MMAPERR_SUCCESS)
                        goto exit00;
!!*/
                // hide the patch and key comboboxes
                ShowWindow(GetDlgItem(hdlg, ID_MAINPATCHCOMBO), SW_HIDE);
                ShowWindow(GetDlgItem(hdlg, ID_MAINKEYCOMBO), SW_HIDE);
                // enumerate setups into setup combo box
                mmaperr = mapEnumerate( MMAP_SETUP
                                      , EnumFunc
                                      , MMENUM_INTOCOMBO
                                      , GetDlgItem( hdlg, ID_MAINSETUPCOMBO)
                                      , NULL
                                      );
                if ( mmaperr != MMAPERR_SUCCESS )
                        goto exit00;
                // set up the auto-radiobuttons
                CheckRadioButton(hdlg, ID_MAINFIRSTRADIO,
                        ID_MAINLASTRADIO, ID_MAINSETUP);
                // intialize some variables
                *szCurrent = 0;
                hCombo = NULL;
                iMap = MMAP_SETUP;
                fEnabled = FALSE;       // Fix for bug #2039.  13-Feb-90, BLM.
                                        //  It used to set the variable TRUE.
                fChange = FALSE;
                fPatchEnum = FALSE;
                fKeyEnum = FALSE;
                uDeleted = 0;
                // fall through
        case WM_MY_INITDIALOG:
                fEnum = FALSE;
                switch (iMap) {
                case MMAP_SETUP:
                        idCurCombo = ID_MAINSETUPCOMBO;
                        uIdx = ComboLookup(GetDlgItem(hdlg,idCurCombo),(LPSTR)szCurSetup);//-jyg
                        break;
                case MMAP_PATCH:
                        idCurCombo = ID_MAINPATCHCOMBO;
                        if (!fPatchEnum) {
                                fEnum = TRUE;
                                fPatchEnum = TRUE;
                        }
                        uIdx = 0;
                        break;
                case MMAP_KEY:
                        idCurCombo = ID_MAINKEYCOMBO;
                        if (!fKeyEnum) {
                                fEnum = TRUE;
                                fKeyEnum = TRUE;
                        }
                        uIdx = 0;
                        break;
                default:uIdx = 0;
                        idCurCombo = 0; /* kill compiler warning about use before set */
                }
                // hide the old combobox, if any
                if (hCombo != NULL)
                        ShowWindow (hCombo, SW_HIDE);
                // get the new combobox handle
                hCombo = GetDlgItem (hdlg, idCurCombo);
                // show the new combobox
                ShowWindow(hCombo, SW_SHOW);
                // if not done already, enumerate maps into the box
                if (fEnum)
                {       mmaperr = mapEnumerate(iMap, EnumFunc, MMENUM_INTOCOMBO, hCombo, NULL);
                        if (mmaperr != MMAPERR_SUCCESS)
                                goto exit00;
                }
                // set the current selection
                uIdx = (UINT)SendMessage(hCombo, CB_SETCURSEL, (WPARAM)uIdx, (LPARAM)0);
                // if no maps of that type, disable all necessary controls
                if (uIdx == CB_ERR) {
                        *szCurrent = 0;
                        EnableMain(fEnabled = FALSE);
                        break;
                }
                // if we were disabled, enable us
                if (!fEnabled)
                        EnableMain(fEnabled = TRUE);
                // fill the edit control with description
#if defined(WIN16)
                SendMessage(hdlg, WM_COMMAND, (WPARAM)ID_MAINCOMBO,
                        MAKELPARAM(hCombo, CBN_SELCHANGE));
#else
                SendMessage( hdlg
                           , WM_COMMAND
                           , (WPARAM)MAKELONG(ID_MAINCOMBO, CBN_SELCHANGE)
                           , (LPARAM)hCombo
                           );

#endif  // WIN16
                break;
        case WM_COMMAND:
            {   WORD wNotifCode;
#if defined(WIN16)
                wNotifCode = HIWORD(lParam);
#else
                wNotifCode = HIWORD(wParam);
#endif //WIN16

                switch (LOWORD(wParam)) {

                case  IDH_CHILD_MIDI:
                        goto DoHelp;

                case IDOK:
                        if (fReadOnly || !fChanged)
                        {
                                PostMessage(hdlg,WM_COMMAND,(WPARAM)IDCANCEL,(LPARAM)0);
                                break;
                        }
                        // check for invalid ports
                        if ((mmaperr = MmaperrInvalidPortCheck(
                                szCurSetup)) == MMAPERR_INVALIDPORT) {
                                if (!InvalidPortMsgBox(hdlg))
                                        break;
                        } else if (mmaperr != MMAPERR_SUCCESS)
                                goto exit00;
                        if (lstrcmpi(szCurSetup, aszInitialSetup))
                                {
                                        mmaperr = mapSetCurrentSetup(
                                                szCurSetup);
                                        if (mmaperr !=
                                                MMAPERR_SUCCESS)
                                                goto exit00;
                                }


                        // this is where any deleted maps actually get the axe
                        //
                        //      I'm going to leave this as is until I figure
                        //      out how to deal with any errors that happen.
                        //      brucemo
                        //
#if 0
                        if (uDeleted & MMAP_SETUP)
                                mapEnumerate( iMap = MMAP_SETUP
                                            , EnumFunc
                                            , MMENUM_DELETE
                                            , GetDlgItem(hdlg,ID_MAINSETUPCOMBO)
                                            , NULL
                                            );
                        if (uDeleted & MMAP_PATCH)
                                mapEnumerate( iMap = MMAP_PATCH
                                            , EnumFunc
                                            , MMENUM_DELETE
                                            , GetDlgItem(hdlg,ID_MAINPATCHCOMBO)
                                            , NULL
                                            );
                        if (uDeleted & MMAP_KEY)
                                mapEnumerate( iMap = MMAP_KEY
                                            , EnumFunc,
                                            , MMENUM_DELETE
                                            , GetDlgItem (hdlg,ID_MAINKEYCOMBO)
                                            , NULL
                                            );
#endif

                case IDCANCEL:
                        // clean up and go home
                        VFreeItemData(hdlg, ID_MAINSETUPCOMBO);
                        if (fPatchEnum)
                                VFreeItemData(hdlg, ID_MAINPATCHCOMBO);
                        if (fKeyEnum)
                                VFreeItemData(hdlg, ID_MAINKEYCOMBO);
                        if (LOWORD(wParam) == IDOK)                    // eh?
                                EndDialog(hdlg,TRUE);
                        else
                                EndDialog(hdlg,FALSE);
                        break;
                case ID_MAINDELETE:
                        if (!FConfirmDeleteMap(hdlg))
                                break;
                        CancelToClose(hdlg);
                        // set a bit in the deleted word
                        uDeleted |= iMap;
                        // get the current selections index
                        uIdx = (UINT)SendMessage(hCombo,
                                CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
                        // get the handle to selections description
                        if ((hDesc = (HGLOBAL)(DWORD)SendMessage(hCombo,
                                CB_GETITEMDATA, (WPARAM)uIdx, (LPARAM)0)) != NULL)
                                GlobalFree(hDesc);
                        // delete the entry from the combobox
                        SendMessage(hCombo, CB_DELETESTRING, (WPARAM)uIdx, (LPARAM)0);

                        // -jyg-

                        mapEnumerate(iMap, EnumFunc, MMENUM_DELETE, hCombo, NULL);

                        // reset to initial setup or first entry
                        if (iMap == MMAP_SETUP)
                        {
                                uIdx = ComboLookup(hCombo,(LPSTR)aszInitialSetup); //-jyg
                                lstrcpy(szCurSetup,aszInitialSetup); // reset current string to initial setup
                        }
                        else
                                uIdx = 0;

                        uIdx = (UINT)SendMessage(hCombo, CB_SETCURSEL, (WPARAM)uIdx, (LPARAM)0);
                        // if deleted last one then disable window,
                        // otherwise update the edit control
                        if (uIdx == CB_ERR) {
                                EnableMain(fEnabled = FALSE);
                                SendMessage(hdlg, DM_SETDEFID, (WPARAM)ID_MAINNEW, (LPARAM)0);
                                SetFocus(GetDlgItem(hdlg, ID_MAINNEW));

                        } else
#if defined(WIN16)
                        SendMessage(hdlg, WM_COMMAND,
                                (WPARAM)ID_MAINCOMBO, MAKELPARAM(hCombo,
                                CBN_SELCHANGE));
#else
                        SendMessage( hdlg
                                   , WM_COMMAND
                                   , (WPARAM)MAKELONG(ID_MAINCOMBO, CBN_SELCHANGE)
                                   , (LPARAM)hCombo
                                   );
#endif //WIN16
                        break;
                case ID_MAINNEW:
                        // if they don't specify a new map get outta here
                        fNew = TRUE;
                        if (!DialogBox(hLibInst, MAKEINTRESOURCE(ID_PROPBOX),
                                hdlg, (DLGPROC)PropBox)) {
                                fNew = FALSE;
                                break;
                        }
                        // if they don't want to save new map, restore
                        // name and description and get outta here
                        if (!FEditMap(hdlg)) {
                                fNew = FALSE;
                                GetWindowText(hCombo, (LPSTR)szCurrent,
                                        MMAP_MAXNAME);
                                GetDlgItemText(hdlg, ID_MAINDESC, szCurDesc,
                                        MMAP_MAXDESC);
                                break;
                        }
                        uIdx = ComboLookup(hCombo,(LPSTR)szCurrent);//-jyg
                        if (uIdx != CB_ERR) {
                                char    aszName[MMAP_MAXNAME];
                                SendMessage(hCombo, CB_GETLBTEXT, (WPARAM)uIdx, (LPARAM)(LPSTR)aszName);
                                if (!lstrcmpi(aszName, szCurrent)) {
                                        hDesc = (HGLOBAL)(DWORD)SendMessage(hCombo, CB_GETITEMDATA, (WPARAM)uIdx, (LPARAM)0);
                                        if (hDesc != NULL)
                                                GlobalFree(hDesc);
                                        //break;
                                } else
                                        uIdx = (UINT)CB_ERR;
                        }
                        if (uIdx == CB_ERR)
                                uIdx = (UINT)SendMessage(hCombo, CB_ADDSTRING,
                                        (WPARAM)0, (LPARAM)(LPCSTR)szCurrent);
                        // make the new map the current one
                        SendMessage(hCombo, CB_SETCURSEL, (WPARAM)uIdx, (LPARAM)0);
                        if (IsDlgButtonChecked(hdlg, ID_MAINSETUP))
                                lstrcpy(szCurSetup, szCurrent);
                        // allocate buffer for map description data
                        if ((hDesc = GlobalAlloc(GHND, (DWORD)(sizeof(char) *
                                (lstrlen (szCurDesc) + 1)))) != NULL) {
                                lpDesc = (LPSTR)GlobalLock(hDesc);
                                lstrcpy(lpDesc, szCurDesc);
                                GlobalUnlock(hDesc);
                        }
                        SetDlgItemText (hdlg, ID_MAINDESC, szCurDesc);
                        // put the handle in the entrys item data
                        SendMessage(hCombo, CB_SETITEMDATA,
                                (WPARAM)uIdx, (LPARAM)hDesc);
                        // enable windows if it is the first map of type
                        if (!IsWindowEnabled(hCombo))
                                EnableMain(TRUE);
                        CancelToClose(hdlg);
                        break;
                case ID_MAINEDIT:
                        if (!FEditMap(hdlg))
                                break;
                        CancelToClose(hdlg);
                        if (iMap != MMAP_SETUP)
                                break;
                        // reset to current setup
                        uIdx = ComboLookup(hCombo,(LPSTR)szCurSetup); //-jyg
                        SendMessage(hCombo, CB_SETCURSEL, (WPARAM)uIdx, (LPARAM)0);

#if defined(WIN16)
                        SendMessage(hdlg, WM_COMMAND, (WPARAM)ID_MAINCOMBO,
                                MAKELPARAM(hCombo, CBN_SELCHANGE));
#else
                        SendMessage( hdlg
                                   , WM_COMMAND
                                   , (WPARAM)MAKELONG(ID_MAINCOMBO, CBN_SELCHANGE)
                                   , (LPARAM)hCombo
                                   );
#endif //WIN16
                        break;
                case ID_MAINSETUP:
                        ShowMaps(MMAP_SETUP);
                        break;
                case ID_MAINPATCH:
                        ShowMaps(MMAP_PATCH);
                        break;
                case ID_MAINKEY:
                        ShowMaps(MMAP_KEY);
                        break;
                case ID_MAINSETUPCOMBO:
                case ID_MAINPATCHCOMBO:
                case ID_MAINKEYCOMBO:
                case ID_MAINCOMBO:
                        if (wNotifCode == CBN_SELENDOK) {
                                CancelToClose(hdlg);
                                fChanged = TRUE;
                        }
                        if (wNotifCode != CBN_SELCHANGE)
                                return FALSE;
                        uIdx = (UINT)SendMessage(hCombo, CB_GETCURSEL,
                                (WPARAM)0, (LPARAM)0);
                        if (LOWORD(wParam) == ID_MAINSETUPCOMBO)
                                SendMessage(hCombo, CB_GETLBTEXT, (WPARAM)uIdx,
                                        (LPARAM) (LPSTR) szCurSetup);
                        hDesc = (HGLOBAL)(DWORD)SendMessage(hCombo, CB_GETITEMDATA,
                                (WPARAM)uIdx, (LPARAM)0);
                        lpDesc = GlobalLock(hDesc);
                        lstrcpy(szCurDesc, lpDesc);
                        GlobalUnlock(hDesc);
                        SetDlgItemText (hdlg, ID_MAINDESC, szCurDesc);
                        SendMessage(hCombo, CB_GETLBTEXT, (WPARAM)uIdx,
                                (LPARAM)(LPSTR)szCurrent);
                        break;
                case ID_MAINDESC:
                        // NOTE:  this is not implemented.
                        if (wNotifCode == EN_CHANGE)
                                fChange = TRUE;
                        else if ((wNotifCode == EN_KILLFOCUS) && fChange) {
                                GetDlgItemText (hdlg, ID_MAINDESC, szTmpDesc,
                                        MMAP_MAXDESC);
                                if (!lstrcmpi(szCurDesc, szTmpDesc)) {
                                        // description change logic here.
                                        // There's no API to changedesc!!
                                }
                        }
                        break;
                default:
                        return FALSE;
                }
            }  /* end of WM_COMMAND */
                break;
        default:
                if (uMessage == uHelpMessage) {
DoHelp:
                        WinHelp(hWnd, szMidiHlp, HELP_CONTEXT,
                                                        IDH_CHILD_MIDI);
                        return TRUE;
                }
                else
                        return FALSE;
        break;
        }
        return TRUE;
} /* MainBox */

BOOL    FAR PASCAL InvalidPortMsgBox (
        HWND    hwnd)
{
        int     iRet;
        char    szBuf[256];

        LoadString(hLibInst, IDS_INVALIDPORT, szBuf, sizeof(szBuf));
        iRet = MessageBox (hwnd, szBuf, szMidiCtl,
                MB_ICONSTOP | MB_YESNO);
        return iRet == IDYES;
} /* InvalidPortMsgBox */

VOID FAR PASCAL Modify(
        BOOL    fSet)
{
        fModified = fSet;
        if (fModified)
                fChanged = TRUE;
} /* Modify */

/*
 * ENUMFUNC
 *
 * Enumerate setup, patchmap or keymap names.
 */
BOOL FAR PASCAL _loadds EnumFunc(
        LPSTR   lpName,
        LPSTR   lpDesc,
        UINT    uCase,
        HWND    hCombo,
        LPSTR   unused
        )
{
        HGLOBAL hMem;
        LPSTR   lpStr;
        UINT    uIdx;
        MMAPERR mmaperr;

        // see if we're dealing with 'delete' enumeration.
        if (uCase == MMENUM_DELETE) {
                uIdx = ComboLookup(hCombo, (LPSTR)lpName);//-jyg

                if (uIdx != CB_ERR)
                        return TRUE;
                mmaperr = mapDelete(iMap, lpName);
                if (mmaperr == MMAPERR_SUCCESS)
                        return TRUE;
                VShowError(hWnd, mmaperr);
                return FALSE;
        }
        uIdx = (UINT)SendMessage(hCombo, CB_ADDSTRING, (WPARAM)NULL, (LPARAM)lpName);
        // see if we're dealing with enumeration from the main dialog
        if (uCase == MMENUM_INTOCOMBO) {
                hMem = GlobalAlloc(GHND, (DWORD)(lstrlen(lpDesc) + 1));
                if (hMem != NULL) {
                        lpStr = (LPSTR)GlobalLock(hMem);
                        lstrcpy(lpStr, lpDesc);
                        GlobalUnlock(hMem);
                }
                SendMessage( hCombo,
                        CB_SETITEMDATA, (WPARAM)uIdx, (LPARAM)hMem);
        }
        return TRUE;
 } /* EnumFunc */

#if 0
/*
 * SETWINDOWCAPTION
 *
 * Set the caption of a 'window', such as 'MIDI Setup: "foo"', even though
 * these are actually dialog boxes.
 */
VOID FAR PASCAL SetWindowCaption(
        VOID)
{
        char    szCaption[80],
                szName[MM_MAXRESLEN];

        LoadString(hLibInst, IdsGetMapNameId(iMap), szName, sizeof(szName));
        wsprintf(szCaption, aszCaptionFormat,
                (LPSTR)szName, (LPSTR)szCurrent);
        SetWindowText(hWnd, szCaption);
} /* SetWindowCaption */
#endif //0

int FAR PASCAL QuerySave (VOID)
{
        char    szBuf[256];
        char    aszSave[64];
        char    aszFormat[128];
        char    szFunc[MM_MAXRESLEN];

        LoadString(hLibInst, IdsGetMapNameId(iMap), szFunc, sizeof(szFunc));
        if (fNew) {
//              AnsiUpperBuff(szFunc, 1);       // Upper-case first character.
                LoadString(hLibInst, IDS_NEW_QUESTION, aszFormat, sizeof(aszFormat));
                wsprintf (szBuf, aszFormat, (LPSTR)szCurrent, (LPSTR)szFunc);
        }
    else {
                LoadString(hLibInst, IDS_CHANGE_QUESTION, aszFormat, sizeof(aszFormat));
                wsprintf (szBuf, aszFormat, (LPSTR)szFunc, (LPSTR)szCurrent);
    }
        LoadString(hLibInst, IDS_SAVE_CHANGES, aszSave, sizeof(aszSave));
        return MessageBox(hWnd, szBuf, aszSave, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
} /* QuerySave */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\midimap.h ===
/*
 * MIDIMAP.H
 *
 * Copyright (C) 1990 Microsoft Corporation.  All rights reserved.
 */

/****************************************************************************

   MIDI output mapping definitions

*****************************************************************************/

/*
 * Error code definitions.
 */


typedef UINT    MMAPERR;

#define MMAPERR_SUCCESS     (MMAPERR)0  // Nothing bad happened.
#define MMAPERR_FILENOTFOUND    (MMAPERR)1  // midimap.cfg not found
#define MMAPERR_INVALIDFLAG (MMAPERR)2  // invalid flag was passed
#define MMAPERR_INVALIDPORT (MMAPERR)3  // setup accesses invalid port
#define MMAPERR_INVALIDSETUP    (MMAPERR)4  // invalid setup name
#define MMAPERR_INVALIDPATCH    (MMAPERR)5  // invalid patchmap name
#define MMAPERR_INVALIDKEY  (MMAPERR)6  // invalid keymap name
#define MMAPERR_MEMORY      (MMAPERR)7  // "Out of memory."
#define MMAPERR_READ        (MMAPERR)8  // "Can't read file."
#define MMAPERR_WRITE       (MMAPERR)9  // "Can't write file."
#define MMAPERR_OPEN        (MMAPERR)10 // "Can't open file."
#define MMAPERR_OPEN_READONLY   (MMAPERR)11 // "Can't open file (read-only)."
#define MMAPERR_CREATE      (MMAPERR)12 // "Can't create file."
#define MMAPERR_UNDEFINED   (MMAPERR)13 // "Internal error."
#define MMAPERR_FULL        (MMAPERR)14 // "Map table full."

#define MMAPERR_MAXERROR    (MMAPERR)15

/*
 * Map flag definitions.
 */
#define MMAP_SETUP      0x01        // map is a setup
#define MMAP_PATCH      0x02        // map is a patchmap
#define MMAP_KEY        0x04        // map is a keymap

#define MMAP_PORTS      0xFF        // enumerate ports

/*
 * String length definitions.
 */
#define MMAP_MAXNAME        16      // max map name length
#define MMAP_MAXDESC        32      // max map description length
#define MMAP_MAXCFGNAME     24      // max file name len for cfg file

/*
 * MIDICHANNELMAP definitions.
 */
// dwFlags
#define MMAP_ACTIVE     0x00000001  // is this channel active?
#define MMAP_PATCHMAP       0x00000002  // is there a patch map for
                        // this channel?

#define MMAP_ID_NOPORT      0xFFFF      // chnl mapped to [none] entry

/****************************************************************************

   MIDI output mapping support structures

*****************************************************************************/

typedef struct midichannelmap_tag {
    DWORD       dwFlags;        // flags for channel map
    WORD        wDeviceID;      // port ID of device
    WORD        wChannel;       // port channel of device
    DWORD       oPMap;          // offset of patch map
} MIDICHANNELMAP, FAR *LPMIDICHANNELMAP;

typedef struct midimap_tag {
    DWORD       dwFlags;        // flags (none defined yet)
    BYTE        szName[MMAP_MAXNAME];   // name
    BYTE        szDesc[MMAP_MAXDESC];   // description
    MIDICHANNELMAP  chMap[16];      // array of channel maps
} MIDIMAP, FAR *LPMIDIMAP;

typedef struct midipatchmap_tag {
    DWORD       dwFlags;        // flags (none defined yet)
    BYTE        szName[MMAP_MAXNAME];   // name
    BYTE        szDesc[MMAP_MAXDESC];   // description
    WORD        wPMap[MIDIPATCHSIZE];   // lobyte=patch, hibyte=volume
    DWORD       okMaps[MIDIPATCHSIZE];  // offsets of key maps
    BYTE        bVMax;          // max volume scalar
    BYTE        bDummy;         // alignment byte
    WORD        wDummy;         // alignment word
} MIDIPATCHMAP, FAR *LPMIDIPATCHMAP;

typedef struct midikeymap_tag {
    DWORD       dwFlags;        // flags (none defined yet)
    BYTE        szName[MMAP_MAXNAME];   // name
    BYTE        szDesc[MMAP_MAXDESC];   // description
    BYTE        bKMap[MIDIPATCHSIZE];   // xlat table for key number
} MIDIKEYMAP, FAR *LPMIDIKEYMAP;

/****************************************************************************

   MIDI output mapping support routines

*****************************************************************************/

typedef BOOL    (CALLBACK *ENUMPROC) (LPSTR, LPSTR, UINT, HWND, LPSTR);

MMAPERR     FAR PASCAL     mapSetCurrentSetup (LPSTR);
MMAPERR     FAR PASCAL     mapGetCurrentSetup (LPSTR, UINT);

MMAPERR     FAR PASCAL     mapDelete (UINT, LPSTR);
MMAPERR     FAR PASCAL     mapEnumerate ( UINT uFlag
                                        , ENUMPROC lpfnCallback
                                        , UINT uCase        // passed to lpfnCallback
                                        , HWND hCombo       // passed to lpfnCallback
                                        , LPSTR lpSetupName // passed to lpfnCallback
                                        );

DWORD       FAR PASCAL     mapGetSize (UINT, LPSTR);
DWORD       FAR PASCAL     mapGetPatchSize(LPMIDIPATCHMAP lpPatch);

MMAPERR     FAR PASCAL     mapRead (UINT, LPSTR, LPVOID);
MMAPERR     FAR PASCAL     mapWrite (UINT, LPVOID);

DWORD       FAR PASCAL     mapGetUsageCount (UINT, LPSTR);
DWORD       FAR PASCAL     mapPatchMapInSetup (LPSTR, LPSTR);
DWORD       FAR PASCAL     mapKeyMapInSetup (LPSTR, LPSTR);
DWORD       FAR PASCAL     mapExists (UINT, LPSTR);

MMAPERR     FAR PASCAL     mapInitMapFile (void);
DWORD       FAR PASCAL     mapFileVersion (void);

// services from midi.c
void        FAR PASCAL     mapUnlock(void);
BOOL        FAR PASCAL     mapLock(void);

// death fix
void        FAR PASCAL mapConnect(LPSTR);
void        FAR PASCAL mapDisconnect(void);

/************************************************************************/
/*
**  Edit structures.
*/

typedef struct tagChannel {
    DWORD   dFlags;
    WORD    wDeviceID;
    WORD    wChannel;
    char    aszPatchName[MMAP_MAXNAME];
}   CHANNEL;

typedef struct tagSetup {
    DWORD   dFlags;
    char    aszSetupName[MMAP_MAXNAME];
    char    aszSetupDescription[MMAP_MAXDESC];
    CHANNEL channels[16];
}   SETUP;

typedef struct tagKeyMap {
    BYTE    bVolume;
    BYTE    bDestination;
    char    aszKeyMapName[MMAP_MAXNAME];
}   KEYMAP;

typedef struct tagPatchMap {
    char    aszPatchMapName[MMAP_MAXNAME];
    char    aszPatchMapDescription[MMAP_MAXDESC];
    KEYMAP  keymaps[128];
}   PATCHMAP;

MMAPERR FAR PASCAL mapReadSetup(
    LPSTR   lszSetupName,
    SETUP FAR*  lpSetup);
MMAPERR FAR PASCAL mapReadPatchMap(
    LPSTR   lszPatchMapName,
    PATCHMAP FAR*   lpPatch);

/* place window so as to avoid going off screen */
VOID PlaceWindow(HWND hwnd);

/************************************************************************/

/*
** Values used to communicate between the caller of mapEnumerate and the
** function called by mapEnumerate for each element.
*/

#define MMENUM_BASIC     0
#define MMENUM_INTOCOMBO 1
#define MMENUM_DELETE    2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\midimap.c ===
/*
 * MIDIMAP.C
 *
 * Copyright (C) 1990 Microsoft Corporation.  All rights reserved.
 *
 * File I/O support routines for MIDI mapper and control panel.
 *
 * History:
 *
 * gregsi       30-Apr-91 midimap.ini -> midimap.cfg
 * t-mikemc     27-Sep-90 mapKeyMapInSetup, mapPatchMapInSetup, mapExists,
 *                        and mapGetUsageCount now all return DWORDS.
 *                        mapGetSize can return an error now.
 * t-mikemc     24-Sep-90 Added count to MMTABLE data structure.  Made
 *                        deleting setups and patchmaps update usage count
 *                        of patchmaps and keymaps, respectively.
 * t-mikemc     23-Sep-90 Finally got that wNameID taken out of memory
 *                        data structures.
 * t-mikemc     22-Sep-90 Made MmaperrWriteSetup look for invalid port ID's
 *                        and write "invalid" device names correctly.
 * t-mikemc     21-Sep-90 Mucked about with the mapEnumerate function to
 *                        allow for enumeration of ports accessed by a setup.
 * t-mikemc     31-Jul-90 Added volume mapping and mapGetUsageCount API.
 * t-mikemc     15-Jul-90 Slew-o-changes! Munged Write/Read/Enum/Delete
 *                        API's together into single functions.  Finished
 *                        up work on 'use-count' for patch and key maps.
 *                        Commented and generally cleaned up lots-o-code.
 * t-mikemc     05-Jul-90 Added mapPatchMapInSetup and mapKeyMapInSetup
 *                        functions.
 * t-mikemc     13-Jun-90 Removed wSize element from setup data structure.
 *                        Setups now read in size of each referenced
 *                        patchmap.
 * t-mikemc     20-May-90 Added DWORD dwFlags to all internal file data
 *                        structures.
 * t-mikemc     11-May-90 Changed enumeration functions so they send
 *                        name and description.
 * t-mikemc     19-Apr-90 Changed routines to use binary file format.
 * t-mikemc     17-Apr-90 Created.
 */

//      Please note that the use of "goto" statements in this module isn't
//      disgusting.
//
//      brucemo

//      Well it disgusts me.  I put readability before writeability.
//      The compiler generates no less than 17 messages saying that a
//      variable may be used before initialised, and that means that
//      either the thing is full of bugs (so Dijkstra was right) or
//      else it's having a tough time following the flow of the logic.
//      Me too.
//      For good measure, the optimisation in compilers is almost always
//      inhibited by goto.
//      LaurieGr

#include <windows.h>
#include <string.h>
#define MMNOMCI
#define MMNOJOY
#define MMNOSOUND
#define MMNOWAVE
#include <mmsystem.h>
#if defined(WIN32)
#include <port1632.h>
#endif //WIN32
#include "hack.h"
#include "midimap.h"
#include "midi.h"
#include "extern.h"

/*-=-=-=-=- Global Definitions  -=-=-=-=-*/

#define MM_VERSION      1               // mapfile version number

#define MM_NUMSETUP     100             // number of setups
#define MM_NUMPATCH     100             // number of patchmaps
#define MM_NUMKEY       100             // number of keymaps

#define MAP_FOPEN       1               // open file
#define MAP_FCREATE     2               // create/open file
#define MAP_FCLOSE      3               // close file

#define MAKEID(id)      ((LPSTR) (LONG) (id))

#define LSB             1               // LSB for usage byte
#define MSB             128             // MSB for usage byte

#define MAX_UNIQUENAME  32              // max length of unique name

/*-=-=-=-=- Internal Data Structures    -=-=-=-=-*/

#pragma pack(1)

// Internal file data structures

typedef struct midimapkey_tag {
                  WORD    wUsing;                 // number of patchmaps using this
                  BYTE    bKMap[MIDIPATCHSIZE];   // translate table for key map
                  DWORD   dwFlags;                // flags
} MMKEY;
typedef MMKEY UNALIGNED FAR *LPMMKEY;

typedef struct midimappatch_tag {
                  WORD    wUsing;                 // number of setups using this
                  BYTE    bVMax;                  // max volume scalar
                  WORD    wPMap[MIDIPATCHSIZE];   // lobyte=xlat table, hibyte=volume  // a PATCHARRAY?
                  DWORD   dwSize;                 // size of patchmap
                  WORD    idxKMapNames[MIDIPATCHSIZE];    // keymap name table indexes // a KEYARRAY?
                  DWORD   dwFlags;                // flags
} MMPATCH;
typedef MMPATCH UNALIGNED FAR *LPMMPATCH;

typedef struct midimapchannel_tag {
                  WORD    wChannel;               // port channel of device
                  BYTE    szDevice[MAXPNAMELEN];  // device name
                  WORD    idxPMapName;            // patchmap name table index
                  DWORD   dwFlags;                // flags
} MMCHANNEL;
typedef MMCHANNEL UNALIGNED FAR *LPMMCHANNEL;

typedef struct midimapsetup_tag {
                  MMCHANNEL chMap[16];            // array of channel maps
                  DWORD   dwFlags;                // flags
} MMSETUP;
typedef MMSETUP UNALIGNED FAR *LPMMSETUP;

typedef struct midimaptableentry_tag {
                  BYTE    szName[MMAP_MAXNAME];   // name of map
                  BYTE    szDesc[MMAP_MAXDESC];   // description of map
                  WORD    idxEntry;               // index of this entry in table
                  DWORD   doData;                 // file offset of data structure
} MMTABLEENTRY;
typedef MMTABLEENTRY UNALIGNED FAR *LPMMTABLEENTRY;

typedef struct midimaptableheader_tag {
                  WORD    wEntrys;                // number of entries in table
                  WORD    wUsed;                  // number of entries being used
} MMTABLEHEADER;
typedef MMTABLEHEADER UNALIGNED FAR *LPMMTABLEHEADER;

typedef struct midimapheader_tag {
                  WORD    wVersion;               // version number of file
                  DWORD   dwGarbage;              // garbage collection bytes
                  WORD    idxCurSetup;            // current setup table index
                  WORD    oSetup;                 // setup table offset
                  WORD    oPatch;                 // patchmap table offset
                  WORD    oKey;                   // keymap table offset
} MMHEADER;

// Internal memory data structures.

typedef struct midimaptable_tag {
                  WORD            wCount;         // times this table has been opened
                  MMTABLEHEADER   mmHeader;       // header for this table
                  HANDLE          hEntrys;        // handle to array of entrys
} MMTABLE;
typedef MMTABLE UNALIGNED FAR *LPMMTABLE;

typedef struct uniquemap_tag {
                  BYTE    szName[MAX_UNIQUENAME];// unique map or port name
                  DWORD   dwOffset;               // offset from base or device ID
                  HANDLE  hNext;                  // next one
} UNIQUEMAP;
typedef UNIQUEMAP UNALIGNED FAR *LPUNIQUEMAP;

#pragma pack()

/*-=-=-=-=- Function Prototypes -=-=-=-=-*/

#define STATIC /**/
STATIC MMAPERR  NEAR PASCAL     MmaperrAddMap(UINT, LPVOID, LPDWORD);
STATIC MMAPERR  NEAR PASCAL     MmaperrChangeUsing(UINT, UINT, int);
STATIC MMAPERR  NEAR PASCAL     MmaperrEnumPorts(ENUMPROC, UINT, HWND, LPSTR);
STATIC MMAPERR  NEAR PASCAL     MmaperrFileAccess(int, int);
STATIC VOID     NEAR PASCAL     VFreeUniqueList(LPHANDLE);
STATIC VOID     NEAR PASCAL     VFreeTable(UINT);
STATIC MMAPERR  NEAR PASCAL     MmaperrGarbage(UINT);
STATIC DWORD    NEAR PASCAL     DwGetMapSize(UINT, LPSTR);
STATIC DWORD    NEAR PASCAL     DwGetSetupSize(LPSTR);
STATIC LPMMTABLEENTRY NEAR PASCAL LpGetTableEntry(HANDLE, LPSTR);
STATIC LPSTR    NEAR PASCAL     LszGetUniqueAtOffset (DWORD, HANDLE);
STATIC DWORD    NEAR PASCAL     LiNotUnique(LPSTR, LPHANDLE, DWORD);
STATIC MMAPERR  NEAR PASCAL     MmaperrReadKeymap (LPSTR, LPMIDIKEYMAP);
STATIC DWORD    NEAR PASCAL     DwReadPatchmap(LPSTR, LPMIDIPATCHMAP, BOOL);
STATIC MMAPERR  NEAR PASCAL     MmaperrReadSetup(LPSTR, LPMIDIMAP);
STATIC MMAPERR  NEAR PASCAL     MmaperrReadTable(UINT);
STATIC MMAPERR  NEAR PASCAL     MmaperrWriteKeymap(LPMIDIKEYMAP);
STATIC MMAPERR  NEAR PASCAL     MmaperrWritePatchmap(PATCHMAP FAR*);
STATIC MMAPERR  NEAR PASCAL     MmaperrWriteSetup (SETUP FAR*);
STATIC MMAPERR  NEAR PASCAL     MmaperrWriteTabEntry(UINT,
                                        UINT, LPMMTABLEENTRY);
STATIC MMAPERR  NEAR PASCAL     MmaperrWriteTabHeader(UINT, LPMMTABLEHEADER);

/*-=-=-=-=- Global Constants    -=-=-=-=-*/
TCHAR RegEntry[] =
    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Midimap");
TCHAR RegCurrent[] = TEXT("Mapping Name");

/*-=-=-=-=- Global Variables    -=-=-=-=-*/

char aszMapperPath[MAXPATHLEN+1]; // A Path Buffer to mapper file (real or temp)

static HANDLE   hPortList,      // Unique port names list.
                hPatchList,     // Unique patchmaps list.
                hKeyList;       // Unique keymaps list.
static HANDLE   hSetupTable,    // Setup table handle.
                hPatchTable,    // Patch table handle.
                hKeyTable;      // Key table handle.
static HFILE    iFile = HFILE_ERROR;    // File handle.
static UINT     ucFileOpen;     // times the (.CFG?) file has been opened

static BOOL     fEditing;

//      -       -       -       -       -       -       -       -       -

void FAR PASCAL mapConnect(LPSTR lpszTmpPath)
{
        // mapFileVersion will force the mapper to open the file
        // so we can change the filename from under it anyway
        lstrcpy(aszMapperPath,lpszTmpPath);
        fEditing = TRUE;
}

void FAR PASCAL mapDisconnect(void)
{
        // We can't leave the temporary file open.  Otherwise someone
        // might reference it after the applet disconnects.

        if (iFile != HFILE_ERROR)
        {
                ucFileOpen = 1; // Force it to close
                (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        }

        fEditing = FALSE;
}

/*
 * @doc INTERNAL
 *
 * @api int | mapFileVersion | This function obtains the version number of the
 *      user's midi data file.
 *
 * @rdesc Returns a DWORD, the high word of which is an error code.  If the
 *      error code is MMAPERR_SUCCESS, the low word contains the version
 *      number.
 */

DWORD FAR PASCAL mapFileVersion (void)
{
        MMHEADER        mmHeader;
        DWORD   dwRet;
        MMAPERR mmaperr;

        // This kludge is here in case MMSYSTEM crashes inside one of the
        // midimap functions that has the file open. In this case, iFile
        // will be non-null and the cpl applet will think there is no
        // midimap.cfg file.

        hPortList = NULL;
        hPatchList = NULL;
        hKeyList = NULL;
        hSetupTable = NULL;
        hPatchTable = NULL;
        hKeyTable = NULL;
        iFile = HFILE_ERROR;
        ucFileOpen = 0;
        mmaperr = MmaperrFileAccess(MAP_FOPEN,OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return MAKELONG(0, mmaperr);

        dwRet = ( _lread(iFile, (LPSTR)&mmHeader,sizeof(MMHEADER))
                    != sizeof(MMHEADER)
                )
                ? MAKELONG(0, MMAPERR_READ)
                : MAKELONG(mmHeader.wVersion, MMAPERR_SUCCESS);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return dwRet;
} /* mapFileVersion */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api BOOL | mapInitMapFile | This function initializes the user's
 *      midi data file.  It creates a file in the user's windows directory,
 *      and fills it with the necessary header information.  If the file
 *      exists, it will be truncated to zero length first.
 *
 * @rdesc Returns non-zero if successful, otherwise zero.
 */

//      Issues:
//
//      1.      Need to install "DeleteFile" code.

MMAPERR FAR PASCAL mapInitMapFile (void)
{
        SETUP           setup;
        MMHEADER        mmHeader;
        MMTABLEHEADER   mmtHeader;
        MMTABLEENTRY    mmtEntry;
        MMAPERR mmaperr;
        WORD            wNum        ;

        if ((mmaperr = MmaperrFileAccess(MAP_FCREATE,
                0)) != MMAPERR_SUCCESS)
                return mmaperr;
        mmHeader.wVersion = MM_VERSION;
        mmHeader.dwGarbage = 0L;
        mmHeader.idxCurSetup = 0;       // Set later in mapSetCurrentSetup
        mmHeader.oSetup = (wNum         = sizeof(MMHEADER));
        mmHeader.oPatch = ( wNum += sizeof(MMTABLEHEADER) + MM_NUMSETUP*sizeof(MMTABLEENTRY) );
        mmHeader.oKey = (wNum += sizeof(MMTABLEHEADER) + MM_NUMPATCH*sizeof(MMTABLEENTRY) );
        if (_lwrite(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER))
           != sizeof(MMHEADER)
           ) {
                mmaperr = MMAPERR_WRITE;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
exit01:         // Delete file here.
                return mmaperr;
        }
        _fmemset(&mmtEntry, 0, sizeof(MMTABLEENTRY));
        mmtHeader.wUsed = 0;
        {   UINT i;
            for (i = 0; i < 3; i++) {
                    switch (i) {
                    case 0:
                            mmtHeader.wEntrys = MM_NUMSETUP;
                            break;
                    case 1:
                            mmtHeader.wEntrys = MM_NUMPATCH;
                            break;
                    case 2:
                            mmtHeader.wEntrys = MM_NUMKEY;
                            break;
                    }
                    if (_lwrite(iFile, (LPSTR)&mmtHeader, sizeof(MMTABLEHEADER))
                       != sizeof(MMTABLEHEADER)
                       ) {
                            mmaperr = MMAPERR_WRITE;
                            goto exit00;
                    }
                    for (wNum         = mmtHeader.wEntrys; wNum        ; wNum        --)
                            if (_lwrite(iFile, (LPSTR)&mmtEntry,
                                    sizeof(MMTABLEENTRY)) !=
                                    sizeof(MMTABLEENTRY)) {
                                    mmaperr = MMAPERR_WRITE;
                                    goto exit00;
                            }
            }
        }
        _fmemset(&setup, 0, sizeof(SETUP));
        LoadString( hLibInst
                  , IDS_VANILLANAME
                  , setup.aszSetupName
                  , sizeof(setup.aszSetupName)
                  );
        LoadString( hLibInst
                  , IDS_VANILLADESC
                  , setup.aszSetupDescription
                  , sizeof(setup.aszSetupDescription)
                  );
        {   UINT wChan;
            for (wChan = 0; wChan < 16; wChan++) {
                    setup.channels[wChan].wDeviceID = MMAP_ID_NOPORT;
                    setup.channels[wChan].wChannel = (WORD)wChan;
            }
        }
        if ((mmaperr = MmaperrWriteSetup(&setup)) != MMAPERR_SUCCESS)
                goto exit00;
        if ((mmaperr = mapSetCurrentSetup(MAKEID(1))) != MMAPERR_SUCCESS)
                goto exit00;
        if ((mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0)) != MMAPERR_SUCCESS)
                goto exit01;            // 01, not 00.
        return MMAPERR_SUCCESS;
} /* mapInitMapFile */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api UINT | mapSetCurrentSetup | This function sets the name of the current
 *      setup.
 *
 * @parm LPSTR | lpSetupName | Specifies the name of a setup which you
 *      want to be the current setup.
 *
 * @rdesc The return value is currently undefined.
 */

//      Issues:
//
//      1.      None.

MMAPERR FAR PASCAL mapSetCurrentSetup (LPSTR lpSetupName)
{
        LPMMTABLEENTRY  lpmmEntry;
        MMHEADER        mmHeader;
        MMAPERR mmaperr;

        HKEY    hKey;
        LONG    lRet;

        /*
        ** See if the information is stored in the registry.
        ** If so write the stuff there.  Otherwise fall thru and try to
        ** write the stuff into the mapper file.
        */
        lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RegEntry, &hKey );

        if ( lRet == ERROR_SUCCESS ) {

              lRet = RegSetValueEx( hKey, RegCurrent, 0L, REG_SZ,
                                    (LPBYTE)lpSetupName,
                                    sizeof(TCHAR) * (1 + lstrlen(lpSetupName)));
              RegCloseKey( hKey );

              if ( lRet == ERROR_SUCCESS) {
                  return MMAPERR_SUCCESS;
              }
        }

        if ((mmaperr = MmaperrFileAccess(MAP_FOPEN,
                OF_READWRITE)) != MMAPERR_SUCCESS)
                return mmaperr;
        if ((mmaperr = MmaperrReadTable(MMAP_SETUP)) != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        lpmmEntry = LpGetTableEntry(hSetupTable,
                lpSetupName);
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit01:         VFreeTable(MMAP_SETUP);
                goto exit00;
        }
        if (_lread(iFile, (LPSTR)&mmHeader,
                sizeof(MMHEADER)) != sizeof(MMHEADER)) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        mmHeader.idxCurSetup = lpmmEntry->idxEntry;
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_WRITE;
                goto exit01;
        }
        if (_lwrite(iFile, (LPSTR)&mmHeader,
                sizeof(MMHEADER)) != sizeof(MMHEADER)) {
                mmaperr = MMAPERR_WRITE;
                goto exit01;
        }
        VFreeTable(MMAP_SETUP);
        if ((mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0)) != MMAPERR_SUCCESS)
                return mmaperr;
        return MMAPERR_SUCCESS;
} /* mapSetCurrentSetup */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api LPSTR | mapGetCurrentSetup | This function retrieves the name of the
 * current setup.
 *
 * @parm LPSTR | lpBuf | Specifies a buffer into which the current setup
 *      name will be copied.
 *
 * @parm UINT | wSize | Specifies the size in bytes of <p lpBuf>.
 *
 * @rdesc Returns an MMAP error, or zero on success.
 *
 * @comm You should make sure that the supplied buffer and size are at
 *      least MMAP_MAXNAME characters (defined in MMSYSTEM.H).
 */

//      Issues:
//
//      1.      None.

MMAPERR FAR PASCAL mapGetCurrentSetup(
        LPSTR   lpBuf,
        UINT    uSize)
{
        LPMMTABLEENTRY  lpmmEntry;
        MMHEADER        mmHeader;
        MMAPERR mmaperr;
        LPSTR           lpEntryName;
        LPSTR           lp;

        HKEY    hKey;
        LONG    lRet;

        /*
        ** See if the information is stored in the registry.
        ** If so read the stuff from there.  Otherwise fall thru and try to
        ** get the stuff from the mapper file.
        */
        lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             RegEntry,
                             0L,
                             KEY_QUERY_VALUE,
                             &hKey );

        if (lRet == ERROR_SUCCESS) {

            DWORD  dwType, dwLen;

            dwLen = uSize;

            lRet = RegQueryValueEx( hKey, RegCurrent, 0L, &dwType,
                                    (LPBYTE)lpBuf, &dwLen );
            RegCloseKey( hKey );

            if ( lRet == ERROR_SUCCESS) {
                return MMAPERR_SUCCESS;
            }
        }

        /* attempt to open file, read setup table */
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_SETUP);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        // read the file header
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit01:         VFreeTable(MMAP_SETUP);
                goto exit00;
        }
        if (_lread(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER))
           != sizeof(MMHEADER)
           ) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        lpmmEntry = LpGetTableEntry(hSetupTable, MAKEID(mmHeader.idxCurSetup)); // Always succeed.
        // lstrncmp (lpBuf, lpmmEntry->szName, uSize - 1);
        for (lp = lpBuf, lpEntryName = (LPSTR)(lpmmEntry->szName); --uSize; )
                *lp++ = *lpEntryName++;
        *lp = '\0';
        // free table, close file and leave
        VFreeTable(MMAP_SETUP);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return MMAPERR_SUCCESS;
} /* mapGetCurrentSetup */

//      -       -       -       -       -       -       -       -       -

MMAPERR FAR PASCAL mapReadSetup(
        LPSTR   lszSetupName,
        SETUP FAR*      lpSetup)
{
        LPMMCHANNEL     lpmmChan;
        LPMMTABLEENTRY  lpmmEntry;
        MMSETUP mmSetup;
        MMAPERR mmaperr;
        UINT    wNumDevs;
        BOOL    fNoPort;
        int     i;
        UINT    wDev;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)  {
                return mmaperr;
        }
        fNoPort = FALSE;
        mmaperr = MmaperrReadTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        lpmmEntry = LpGetTableEntry(hSetupTable, lszSetupName);
        if (lpmmEntry == NULL) {
                mmaperr = MMAPERR_INVALIDSETUP;
exit01:         VFreeTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
                goto exit00;
        }
        // read in setup data from file
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmSetup, sizeof(MMSETUP)) != sizeof(MMSETUP)){
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        // copy over setup name, description, and flags
        lstrcpy(lpSetup->aszSetupName, (LPCSTR)(lpmmEntry->szName));
        lstrcpy(lpSetup->aszSetupDescription, (LPCSTR)(lpmmEntry->szDesc));
        lpSetup->dFlags = mmSetup.dwFlags;
        // grab the number of devices in the current environment
        wNumDevs = midiOutGetNumDevs();
        // set up a couple of optimization-pointers
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
        for (i = 0; i < 16; i++, lpmmChan++) {
                // convert device name to device ID.  If device name doesn't
                // exist in the current environment, set ID to MMAP_ID_NOPORT
                if (!*lpmmChan->szDevice)
                        wDev = wNumDevs;
                else
                    for (wDev = 0; wDev < wNumDevs; wDev++) {
                        MIDIOUTCAPS     moCaps;

                        midiOutGetDevCaps(wDev, &moCaps, sizeof(MIDIOUTCAPS));
                        if (!lstrcmpi( moCaps.szPname
                                     , (LPCSTR)(lpmmChan->szDevice)))
                                    break;
                    }
                // copy over channel and flag info
                lpSetup->channels[i].wChannel = lpmmChan->wChannel;
                lpSetup->channels[i].dFlags = lpmmChan->dwFlags;
                if (wDev < wNumDevs)
                        lpSetup->channels[i].wDeviceID = (WORD)wDev;
                else {
                        lpSetup->channels[i].wDeviceID = MMAP_ID_NOPORT;
                        // this error code only if there was a port
                        // name but it does not exist on the current system.
                        if (*lpmmChan->szDevice)
                                fNoPort = TRUE;
                }
                // if channel has no patchmap then on to next channel
                if (!lpmmChan->idxPMapName) {
                        lstrcpy(lpSetup->channels[i].aszPatchName, szNone);
                        continue;
                }
                lpmmEntry = LpGetTableEntry(hPatchTable, MAKEID(lpmmChan->idxPMapName));
                lstrcpy( lpSetup->channels[i].aszPatchName
                       , (LPCSTR)(lpmmEntry->szName));
        }
        VFreeTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
        MmaperrFileAccess(MAP_FCLOSE, 0);
        if (fNoPort)
                return MMAPERR_INVALIDPORT;
        return MMAPERR_SUCCESS;
}

MMAPERR FAR PASCAL mapReadPatchMap(
        LPSTR   lszPatchMapName,
        PATCHMAP FAR*   lpPatch)
{
        LPMMTABLEENTRY  lpmmEntry;
        MMPATCH mmPatch;
        UNALIGNED WORD  *lpwKey;
        MMAPERR mmaperr;
        int     i;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN,OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_PATCH | MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        lpmmEntry = LpGetTableEntry(hPatchTable, lszPatchMapName);
        if (lpmmEntry == NULL) {
                mmaperr = MMAPERR_INVALIDPATCH;
exit01:         VFreeTable(MMAP_PATCH | MMAP_KEY);
                goto exit00;
        }
        // read in patch data from file
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        if ( _lread(iFile, (LPSTR)&mmPatch, sizeof(MMPATCH))
           != sizeof(MMPATCH)
           ) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        // copy data from file structure to memory structure
        lstrcpy(lpPatch->aszPatchMapName, (LPCSTR)(lpmmEntry->szName));
        lstrcpy(lpPatch->aszPatchMapDescription, (LPCSTR)(lpmmEntry->szDesc));
        // set up an optimization pointer
        lpwKey = mmPatch.idxKMapNames;
        for (i = 0; i < MIDIPATCHSIZE; i++, lpwKey++) {
                lpPatch->keymaps[i].bVolume = HIBYTE(mmPatch.wPMap[i]);
                lpPatch->keymaps[i].bDestination = LOBYTE(mmPatch.wPMap[i]);
                if (!*lpwKey) {
                        lstrcpy(lpPatch->keymaps[i].aszKeyMapName, szNone);
                        continue;
                }
                lpmmEntry = LpGetTableEntry(hKeyTable, MAKEID(*lpwKey));
                lstrcpy( lpPatch->keymaps[i].aszKeyMapName
                       , (LPCSTR)(lpmmEntry->szName));
        }
        // free table, close file and leave
        VFreeTable(MMAP_PATCH | MMAP_KEY);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return MMAPERR_SUCCESS;
}

//      -       -       -       -       -       -       -       -       -

/* @doc INTERNAL
 *
 * @api DWORD | mapRead | Read a map specified by <p lpName> into a buffer
 *      specified by <p lpvBuf>.  This includes any patchmaps or keymaps
 *      that the map may contain.
 *
 * @parm UINT | wFlag | Specifies the type of map to be read into memory.
 *      It may be any of the following:
 *
 *      @flag MMAP_SETUP | Read a setup.
 *      @flag MMAP_PATCH | Read a patchmap.
 *      @flag MMAP_KEY | Read a keymap.
 *
 * @parm LPSTR | lpName | Specifies the name of the map of which you
 *      want read into memory.
 *
 * @rdesc Returns an MMAP error code, or zero on success.
 */

//      Issues:
//
//      1.      None.

MMAPERR FAR PASCAL mapRead(
        UINT    uFlag,
        LPSTR   lpName,
        LPVOID  lpvBuf)
{
        switch (uFlag) {
                DWORD   dwRet;

        case MMAP_SETUP:
                return MmaperrReadSetup(lpName, (LPMIDIMAP)lpvBuf);
        case MMAP_PATCH:
                dwRet = DwReadPatchmap(lpName,(LPMIDIPATCHMAP)lpvBuf, FALSE);
                if (dwRet < MMAPERR_MAXERROR)
                        return LOWORD(dwRet);
                return MMAPERR_SUCCESS;
        case MMAP_KEY:
                return MmaperrReadKeymap(lpName, (LPMIDIKEYMAP)lpvBuf);
        }
} /* mapRead */

//      -       -       -       -       -       -       -       -       -

//      MmaperrReadSetup
//
//      Read a setup into a buffer.  This includes any patchmaps or keymaps
//      that the setup may contain.
//
//      NOTE:  This function will return MMAPERR_INVALIDPORT if the setup to
//      be read accesses ports that are not available on the system.  That is,
//      if it accesses ports not listed as a 'midix=xxx.drv' entry under the
//      [drivers] section in system.ini.  The entire setup WILL BE read into
//      memory but the uDeviceID for the channels with inaccessible ports will
//      be set to MMAP_ID_NOPORT.  This error also has NO EFFECT on the
//      active/inactive status of any such channels.
//
//      Issues:
//
//      1.      There's a comment about something breaking a segment
//              boundary in here, but if it does break the segment boundary
//              the way it's dealt with it looks like it will wipe out.
//
//      2.      Freeing the "hKeyList" chain may be unnecessary if the
//              patch map read routine cleans up after itself properly.

STATIC  MMAPERR NEAR PASCAL MmaperrReadSetup(
        LPSTR   lpName,
        LPMIDIMAP       lpmMap)
{
        LPMIDICHANNELMAP lpChan;
        LPMMCHANNEL     lpmmChan;
        LPMIDIPATCHMAP  lpPatch;
        LPMMTABLEENTRY  lpmmEntry;
        MMSETUP mmSetup;
        MIDIOUTCAPS     moCaps;
        MMAPERR mmaperr;
        DWORD   dwOffset;
        UINT    wNumDevs;
        BOOL    fNoPort;
        int     i;
        UINT    wDev;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        fNoPort = FALSE;
        mmaperr = MmaperrReadTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        dwOffset = sizeof(MIDIMAP);
        lpmmEntry = LpGetTableEntry(hSetupTable, lpName);
        if (lpmmEntry == NULL) {
                mmaperr = MMAPERR_INVALIDSETUP;
exit01:         VFreeTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
                goto exit00;
        }
        // read in setup data from file
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmSetup, sizeof(MMSETUP)) != sizeof(MMSETUP)){
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        // copy over setup name, description, and flags
        lstrcpy(lpmMap->szName, (LPCSTR)(lpmmEntry->szName));
        lstrcpy(lpmMap->szDesc, (LPCSTR)(lpmmEntry->szDesc));
        lpmMap->dwFlags = mmSetup.dwFlags;
        // grab the number of devices in the current environment
        wNumDevs = midiOutGetNumDevs();
        // set up a couple of optimization-pointers
        lpChan = lpmMap->chMap;
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
        for (i = 0; i < 16; i++, lpChan++, lpmmChan++) {
                // convert device name to device ID.  If device name doesn't
                // exist in the current environment, set ID to MMAP_ID_NOPORT
                if (!*lpmmChan->szDevice)
                        wDev = wNumDevs;
                else
                        for (wDev = 0; wDev < wNumDevs; wDev++) {
                                midiOutGetDevCaps(wDev, &moCaps, sizeof(MIDIOUTCAPS));
                                if (!lstrcmpi(moCaps.szPname,
                                              (LPCSTR)(lpmmChan->szDevice)))
                                        break;
                        }
                // copy over channel and flag info
                lpChan->wChannel = lpmmChan->wChannel;
                lpChan->dwFlags = lpmmChan->dwFlags;
                if (wDev < wNumDevs)
                        lpChan->wDeviceID = (WORD)wDev;
                else {
                        lpChan->wDeviceID = MMAP_ID_NOPORT;
                        // this error code only if there was a port
                        // name but it does not exist on the current system.
                        if (*lpmmChan->szDevice)
                                fNoPort = TRUE;
                }
                // if channel has no patchmap then on to next channel
                if (!lpmmChan->idxPMapName)
                        continue;
                // channel has a patchmap - if its not unique, point offset
                // to first occurance, otherwise offset = dwOffset.
                // assuming this patchmap ID is valid!
                lpmmEntry = LpGetTableEntry(hPatchTable,
                        MAKEID(lpmmChan->idxPMapName));
                lpChan->oPMap = LiNotUnique( (LPSTR)(lpmmEntry->szName)
                                           , &hPatchList
                                           , dwOffset
                                           );
                if (lpChan->oPMap == -1L) {
                        mmaperr = MMAPERR_MEMORY;
exit02:                 VFreeUniqueList(&hPatchList);
                        VFreeUniqueList(&hKeyList);
                        goto exit01;
                } else if (!lpChan->oPMap) {
                        DWORD   dwRet;

                        lpChan->oPMap = dwOffset;
                        // setup patchmap pointer; could break segment bounds
                        lpPatch = (LPMIDIPATCHMAP)((LPSTR)lpmMap + dwOffset);
                        // read in patchmap (this also updates global offset)
                        dwRet = DwReadPatchmap(0L, lpPatch, TRUE);
                        if (dwRet < MMAPERR_MAXERROR) {
                                mmaperr = LOWORD(dwRet);
                                goto exit02;
                        }
                        dwOffset += dwRet;
                }
        }
        VFreeUniqueList(&hPatchList);
        VFreeUniqueList(&hKeyList);
        VFreeTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        if (fNoPort)
                return MMAPERR_INVALIDPORT;
        return MMAPERR_SUCCESS;
} /* MmaperrReadSetup */

//      -       -       -       -       -       -       -       -       -

//      DwReadPatchmap
//
//      Read a patchmap into a buffer.  This includes any keymaps the patchmap
//      may contain.
//
//      Remarks:
//
//      1.      Use of "fInSetup" flag is very bogus, may cause problems, is
//              probably wrong.

STATIC  DWORD NEAR PASCAL DwReadPatchmap(
        LPSTR   lpName,
        LPMIDIPATCHMAP  lpPatch,
        BOOL    fInSetup)
{
        LPMMTABLEENTRY  lpmmEntry;
        LPMIDIKEYMAP    lpKey;
        MMPATCH mmPatch;
        UNALIGNED WORD *lpwKey;
        MMAPERR mmaperr;
        DWORD   dwOffset;
        int     i;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN,OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return MAKELONG(mmaperr, 0);
        mmaperr = MmaperrReadTable(MMAP_PATCH |MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return MAKELONG(mmaperr, 0);
        }
        // save global offset then initialize it to patch size
        dwOffset = sizeof(MIDIPATCHMAP);
        lpmmEntry = LpGetTableEntry(hPatchTable, lpName);
        if (lpmmEntry == NULL) {
                mmaperr = MMAPERR_INVALIDPATCH;
exit01:         VFreeTable(MMAP_PATCH | MMAP_KEY);
                goto exit00;
        }
        // read in patch data from file
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmPatch,sizeof(MMPATCH)) != sizeof(MMPATCH)) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        // copy data from file structure to memory structure
        lstrcpy(lpPatch->szName, (LPCSTR)(lpmmEntry->szName));
        lstrcpy(lpPatch->szDesc, (LPCSTR)(lpmmEntry->szDesc));
        _fmemcpy((LPSTR)lpPatch->wPMap, (LPSTR)mmPatch.wPMap, MIDIPATCHSIZE * sizeof(WORD));
        _fmemset((LPSTR)lpPatch->okMaps, 0, MIDIPATCHSIZE * sizeof(DWORD));
        lpPatch->dwFlags = mmPatch.dwFlags;
        lpPatch->bVMax = mmPatch.bVMax;
        // set up an optimization pointer
        lpwKey = mmPatch.idxKMapNames;
        for (i = 0; i < MIDIPATCHSIZE; i++, lpwKey++) {
            // if no keymap for this patch then continue
            if (!*lpwKey)
                    continue;
            // patch has a keymap - if its unique point offset to
            // to first occurance, otherwise offset = dwOffset.
            // assuming this keymap ID is valid!
            lpmmEntry = LpGetTableEntry(hKeyTable, MAKEID(*lpwKey));
            lpPatch->okMaps[i] = LiNotUnique( (LPSTR)(lpmmEntry->szName)
                                            , &hKeyList, dwOffset);
            if (lpPatch->okMaps[i] == -1L) {
                mmaperr = MMAPERR_MEMORY;
                goto exit01;
            } else if (!lpPatch->okMaps[i]) {
                lpPatch->okMaps[i] = dwOffset;
                // set the keymap pointer; could break segment bounds
                lpKey = (LPMIDIKEYMAP)((LPSTR)lpPatch + dwOffset);
                // read in the keymap, update global offset
                mmaperr = MmaperrReadKeymap(0L, lpKey);
                if (mmaperr != MMAPERR_SUCCESS) {
                    VFreeUniqueList(&hKeyList);
                    goto exit01;
                }
                dwOffset += sizeof(MIDIKEYMAP);
            }
        }
        if (!fInSetup) {
                // if we're not called from ReadSetup, free the unique
                // keymap name list.
                VFreeUniqueList(&hKeyList);
        }
        // free table, close file and leave
        VFreeTable(MMAP_PATCH | MMAP_KEY);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return dwOffset;
} /* DwReadPatchmap */

//      -       -       -       -       -       -       -       -       -

//      MmaperrReadKeymap
//
//      Read a keymap into a buffer.
//
//      Remarks:
//
//      1.      None.

STATIC  MMAPERR NEAR PASCAL MmaperrReadKeymap(
        LPSTR   lpName,
        LPMIDIKEYMAP    lpKey)
{
        LPMMTABLEENTRY  lpmmEntry;
        MMKEY           mmKey;
        MMAPERR mmaperr;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        // assuming keymap exists
        lpmmEntry = LpGetTableEntry(hKeyTable, lpName);
        // read in key data from file
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit01:         VFreeTable(MMAP_KEY);
                goto exit00;
        }
        if (_lread(iFile, (LPSTR)&mmKey, sizeof(mmKey)) != sizeof(mmKey)) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        // copy data from file structure to memory structure
        lstrcpy(lpKey->szName, (LPCSTR)(lpmmEntry->szName));
        lstrcpy(lpKey->szDesc, (LPCSTR)(lpmmEntry->szDesc));
        _fmemcpy(lpKey->bKMap, (LPCSTR)(mmKey.bKMap), MIDIPATCHSIZE * sizeof(BYTE));
        lpKey->dwFlags = mmKey.dwFlags;
        // free table, close file and leave
        VFreeTable(MMAP_KEY);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return MMAPERR_SUCCESS;
} /* MmaperrReadKeymap */

//      -       -       -       -       -       -       -       -       -

/* @doc INTERNAL
 *
 * @api DWORD | mapWrite | Write a map specified by <p lpvMap> to the
 *      midi data file.
 *
 * @parm UINT | uFlag | Specifies the type of map to write.
 *      It may be any of the following:
 *
 *      @flag MMAP_SETUP | Write a setup.
 *      @flag MMAP_PATCH | Write a patchmap.
 *      @flag MMAP_KEY   | Write a keymap.
 *
 * @parm LPVOID | lpvMap | Specifies the map to write to the midi data file.
 *
 * @rdesc Returns non-zero if it could do the write, zero if it failed.
 */

//      Remarks:
//
//      1.      None.

MMAPERR FAR PASCAL mapWrite(
        UINT    uFlag,
        LPVOID  lpvMap)
{
        switch (uFlag) {
        case MMAP_SETUP :
                return MmaperrWriteSetup((SETUP FAR*)lpvMap);
        case MMAP_PATCH :
                return MmaperrWritePatchmap((PATCHMAP FAR*)lpvMap);
        case MMAP_KEY :
                return MmaperrWriteKeymap((LPMIDIKEYMAP)lpvMap);
        }
} /* mapWrite */

//      -       -       -       -       -       -       -       -       -

//      MmaperrWriteSetup
//
//      Write a setup to the midi data file.

STATIC  MMAPERR NEAR PASCAL MmaperrWriteSetup(SETUP FAR* lpSetup)
{
        HANDLE          hPatchUsage;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmEntry;
        LPMMCHANNEL     lpmmChan;
        LPBYTE          lpbPatchUsage = NULL;  // Kill spurious use before set diagnostic
        MMSETUP         mmOldSetup;
        MMSETUP         mmSetup;
        MIDIOUTCAPS     moCaps;
        MMAPERR mmaperr;
        DWORD   doData;
        UINT    wNumDevs;
        UINT    wOldDevs;
        UINT    uSize;
        BOOL    fExists;
        UINT    uIndex;
        UINT    wDev;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_SETUP | MMAP_PATCH);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        // check to see if setup name already exists
        fExists = FALSE;
        lpmmEntry = LpGetTableEntry(hSetupTable, lpSetup->aszSetupName);
        if (lpmmEntry != NULL) {
            // setup name exists.  if the description has changed, we
            // have to re-write the table entry with new description
            if (lstrcmpi((LPCSTR)(lpmmEntry->szDesc)
                        , lpSetup->aszSetupDescription)) {
                lstrcpy( (LPSTR)(lpmmEntry->szDesc)
                       , lpSetup->aszSetupDescription);
                mmaperr = MmaperrWriteTabEntry(MMAP_SETUP, 0, lpmmEntry);
                if (mmaperr != MMAPERR_SUCCESS) {
exit01:             VFreeTable(MMAP_SETUP | MMAP_PATCH);
                    goto exit00;
                }
            }
            doData = lpmmEntry->doData;
            fExists = TRUE;
        }
        // name non-existent, so add a new table entry
        else if ((mmaperr = MmaperrAddMap(MMAP_SETUP, (LPVOID)lpSetup, &doData))
                != MMAPERR_SUCCESS
                )
                goto exit01;
        // zero-out the new setup data structure
        _fmemset((LPSTR)&mmSetup, 0, sizeof(MMSETUP));
        // obtain the number of entrys in the patch table
        lpmmTable = (LPMMTABLE)GlobalLock(hPatchTable);
        uSize = lpmmTable->mmHeader.wEntrys;
        GlobalUnlock(hPatchTable);
        // if there are any patchmaps
        hPatchUsage = NULL;
        if (uSize) {
                // Create table which is 'number-of-patchmaps' in length
                hPatchUsage = GlobalAlloc(GHND, (LONG)uSize);
                if (hPatchUsage == NULL) {
                        mmaperr = MMAPERR_MEMORY;
                        goto exit01;
                }
                lpbPatchUsage = (LPBYTE)GlobalLock(hPatchUsage);
                // if this is not a new map
                if (fExists) {
                        // read in old setup data from file
                        if (_llseek(iFile, doData, 0) == -1L) {
                                mmaperr = MMAPERR_READ;
exit02:                         if (hPatchUsage != NULL) {
                                        GlobalUnlock(hPatchUsage);
                                        GlobalFree(hPatchUsage);
                                }
                                goto exit01;
                        }
                        if ( _lread(iFile, (LPSTR)&mmOldSetup,sizeof(MMSETUP))
                           != sizeof(MMSETUP)
                           ) {
                                mmaperr = MMAPERR_READ;
                                goto exit02;
                        }
                        // set LSB of usage table indices where old setup
                        // referenced any respective patchmaps
                        for (uIndex = 0; uIndex < 16; uIndex++)
                        {
                            UINT    u;
                            u = mmOldSetup.chMap[uIndex].idxPMapName;
                            if (u)
                                 lpbPatchUsage[u - 1] = LSB;
                        }
                }
        }
        // get the number of devices
        wNumDevs = wOldDevs = midiOutGetNumDevs();
        // enumerate any invalid ports from old setup this is not a new map
        if (fExists) {
                uIndex = 0;
                lpmmChan = (LPMMCHANNEL)(mmOldSetup.chMap); // MIPS silliness
        } else {
                uIndex = 16;
                lpmmChan = 0;                           // wasn't set. LKG
        }
        for (; uIndex < 16; uIndex++, lpmmChan++) {
            // find out if the port is in the current environment
            wDev = *lpmmChan->szDevice ? 0 : wNumDevs;
            for (; wDev < wNumDevs; wDev++) {
                    midiOutGetDevCaps(wDev, &moCaps, sizeof(MIDIOUTCAPS));
                    if (!lstrcmpi(moCaps.szPname, (LPCSTR)(lpmmChan->szDevice)))
                            break;
            }
            // if not, add the unique port name to the invalid port list
            if (wDev == wNumDevs) {
                DWORD   dwUniqueRet;

                // unique-list entry will save this offset
                dwUniqueRet = LiNotUnique( (LPSTR)(lpmmChan->szDevice)
                                         , &hPortList
                                         , (DWORD)wOldDevs);
                if (dwUniqueRet == -1L) {
                        mmaperr = MMAPERR_MEMORY;
exit03:                 VFreeUniqueList(&hPortList);
                        goto exit02;
                } else if (!dwUniqueRet)
                        wOldDevs++;
            }
        }
        // copy over the data for each channel
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
        for (uIndex = 0; uIndex < 16; uIndex++, lpmmChan++) {
                // convert the device ID to a device name.
                if (lpSetup->channels[uIndex].wDeviceID == MMAP_ID_NOPORT)
                        *lpmmChan->szDevice = 0;
                else if (lpSetup->channels[uIndex].wDeviceID >= wNumDevs)
                    lstrcpy( (LPSTR)(lpmmChan->szDevice)
                           , LszGetUniqueAtOffset( (DWORD)lpSetup->channels[uIndex].wDeviceID
                                                 , hPortList
                                                 )
                           );
                else {
                        midiOutGetDevCaps( lpSetup->channels[uIndex].wDeviceID
                                         , &moCaps
                                         , sizeof(MIDIOUTCAPS)
                                         );
                        lstrcpy((LPSTR)(lpmmChan->szDevice), moCaps.szPname);
                }
                // copy over channel number and flags.
                lpmmChan->wChannel = lpSetup->channels[uIndex].wChannel;
                lpmmChan->dwFlags = lpSetup->channels[uIndex].dFlags;
                if (lpmmChan->dwFlags & MMAP_PATCHMAP) {
                        // do I want a uniqueness-check in here?
                        // get the table entry
                        lpmmEntry = LpGetTableEntry(hPatchTable,
                                lpSetup->channels[uIndex].aszPatchName);
                        // set patch name table entry index
                        lpmmChan->idxPMapName = lpmmEntry->idxEntry;
                        // set MSB at current table index where
                        // this setup references a patchmap
                        if (uSize)
                                lpbPatchUsage[lpmmChan->idxPMapName - 1] |= MSB;
                }
                // not needed if MMAP_PATCHMAP isn't there, seems clean though
                else
                        lpmmChan->idxPMapName = 0;
        }
        // if there are any patchmaps
        if (uSize) {
            // Check for differences in patchmap referencing.  Compare
            // what patchmaps are now being used to what patchmaps were
            // being used before.  Change the using count accordingly.

            for (uIndex = 0; uIndex < uSize; uIndex++, lpbPatchUsage++)
                if ((*lpbPatchUsage & MSB) &&
                    (!(*lpbPatchUsage & LSB))) {
                    mmaperr = MmaperrChangeUsing(MMAP_PATCH,uIndex + 1, 1);
                    if (mmaperr != MMAPERR_SUCCESS)
                            goto exit03;
                } else if (! (*lpbPatchUsage & MSB)
                          && (*lpbPatchUsage & LSB)
                          )
                    mmaperr = MmaperrChangeUsing(MMAP_PATCH,uIndex + 1, -1);
                    if (mmaperr != MMAPERR_SUCCESS)
                            goto exit03;
            // nuke the usage table
            GlobalUnlock(hPatchUsage);
            GlobalFree(hPatchUsage);
            hPatchUsage = NULL;
        }
        // copy over the setup flags.
        mmSetup.dwFlags = lpSetup->dFlags;
        // write the setup
        if (_llseek(iFile, doData, 0) == -1L) {
                mmaperr = MMAPERR_WRITE;
                goto exit03;
        }
        if ( _lwrite(iFile, (LPSTR)&mmSetup, sizeof(MMSETUP))
           != sizeof(MMSETUP)
           ) {
                mmaperr = MMAPERR_WRITE;
                goto exit03;
        }
        // free the unique invalid port name list
        VFreeUniqueList(&hPortList);
        // free tables, close file and leave
        VFreeTable(MMAP_SETUP | MMAP_PATCH);
        mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        return MMAPERR_SUCCESS;
} /* MmaperrWriteSetup */

//      -       -       -       -       -       -       -       -       -

//      MmaperrWritePatchmap
//
//      Write a patchmap to the midi data file.

STATIC  MMAPERR NEAR PASCAL MmaperrWritePatchmap(
        PATCHMAP FAR*   lpPatch)
{
        KEYMAP FAR*     keymap;
        HANDLE          hKeyUsage;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmEntry;
        MMPATCH mmOldPatch;
        MMPATCH mmPatch;
        UNALIGNED WORD *lpidxNames;
        LPBYTE  lpbKeyUsage = NULL;  // Kill spurious use before set diagnostic
        DWORD   doData;
        DWORD   dwOffset;
        UINT    uSize = 0;
        BOOL    fExists = FALSE;
        MMAPERR mmaperr;
        UINT    uIndex;

        // open file, read in pertinent tables
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_PATCH | MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        // check to see if patch name already exists
        lpmmEntry = LpGetTableEntry(hPatchTable, lpPatch->aszPatchMapName);
        if (lpmmEntry != NULL) {
            // patch name exists.  if the description has changed, we
            // have to re-write the table entry with new description
            if (lstrcmpi( (LPSTR)(lpmmEntry->szDesc)
                        , lpPatch->aszPatchMapDescription)) {
                lstrcpy( (LPSTR)(lpmmEntry->szDesc)
                       , lpPatch->aszPatchMapDescription);
                mmaperr = MmaperrWriteTabEntry(MMAP_PATCH, 0, lpmmEntry);
                if (mmaperr != MMAPERR_SUCCESS) {
exit01:                 VFreeTable(MMAP_PATCH | MMAP_KEY);
                        goto exit00;
                }
            }
            doData = lpmmEntry->doData;
            fExists = TRUE;
        }
        // name is non-existent, so add a new table entry
        else {
                mmaperr = MmaperrAddMap(MMAP_PATCH,lpPatch, &doData);
                if (mmaperr != MMAPERR_SUCCESS)
                        goto exit01;
        }
        // zero-out the patch data structure.
        _fmemset((LPSTR)&mmPatch, 0, sizeof(MMPATCH));
        // obtain the number of entrys in the key table
        lpmmTable = (LPMMTABLE)GlobalLock(hKeyTable);
        uSize = lpmmTable->mmHeader.wEntrys;
        GlobalUnlock(hKeyTable);
        // Create table which is 'number-of-keymaps' in length
        hKeyUsage = NULL;
        if (uSize) {
                hKeyUsage = GlobalAlloc(GHND, (LONG)uSize);
                if (hKeyUsage == NULL) {
                        mmaperr = MMAPERR_MEMORY;
                        goto exit01;
                }
                lpbKeyUsage = (LPBYTE)GlobalLock(hKeyUsage);
        }
        // if not a new patchmap, we need old usage count
        if (fExists) {
                // read in old patch data from file
                if (_llseek(iFile, doData, 0) == -1L) {
                        mmaperr = MMAPERR_READ;
exit02:                 if (hKeyUsage != NULL) {
                                GlobalUnlock(hKeyUsage);
                                GlobalFree(hKeyUsage);
                        }
                        goto exit01;
                }
                if ( _lread(iFile, (LPSTR)&mmOldPatch, sizeof(MMPATCH))
                   != sizeof(MMPATCH)
                   ) {
                        mmaperr = MMAPERR_READ;
                        goto exit02;
                }
                mmPatch.wUsing = mmOldPatch.wUsing;
                // if there are keymaps and map is not new, set LSB
                // of usage table indices where old patchmap referenced
                // any respective keymaps
                if (uSize) {
                        lpidxNames = mmOldPatch.idxKMapNames;
                        for (uIndex = 0; uIndex < MIDIPATCHSIZE; uIndex++, lpidxNames++)
                                if (*lpidxNames)
                                        lpbKeyUsage[*lpidxNames - 1] = LSB;
                }
        }
        dwOffset = sizeof(MIDIPATCHMAP);
        // set max volume scalar to minimum value
        mmPatch.bVMax = 1;
        // copy over data for each patch entry
        keymap = lpPatch->keymaps;
        lpidxNames = mmPatch.idxKMapNames;
        for (uIndex = 0; uIndex < MIDIPATCHSIZE; uIndex++, keymap++, lpidxNames++) {
                DWORD   dwUniqueRet;

                mmPatch.wPMap[uIndex] = ((WORD)keymap->bVolume << 8) | keymap->bDestination;

                // if the current volume is greater than the max volume
                // then set max volume to it
                if (keymap->bVolume > mmPatch.bVMax)
                        mmPatch.bVMax = keymap->bVolume;

                // if patch has no keymap, zero out keymap table entry
                // index in file data structure and continue
                if (!lstrcmpi(keymap->aszKeyMapName, szNone)) {
                        *lpidxNames = 0;
                        continue;
                }
                // get the table entry
                lpmmEntry = LpGetTableEntry(hKeyTable, keymap->aszKeyMapName);
                // set keymap table entry index in file data structure
                *lpidxNames = lpmmEntry->idxEntry;
                // if keymap is unique, add size to global offset
                dwUniqueRet = LiNotUnique(keymap->aszKeyMapName, &hKeyList, dwOffset);
                if (dwUniqueRet == -1L) {
                        mmaperr = MMAPERR_MEMORY;
exit03:                 VFreeUniqueList(&hKeyList);
                        goto exit02;
                } else if (!dwUniqueRet) {
                        DWORD   dwSize;

                        dwSize = DwGetMapSize(MMAP_KEY,keymap->aszKeyMapName);
                        if (dwSize < MMAPERR_MAXERROR) {
                                mmaperr = LOWORD(dwSize);
                                goto exit03;
                        }
                        dwOffset += dwSize;
                        // set MSB at current usage table index where
                        // this patchmap references a keymap
                        if (uSize)
                                lpbKeyUsage[*lpidxNames - 1] |= MSB;
                }
        }
        // if there are any keymaps
        if (uSize) {
            // Check for differences in keymap referencing.  Compare
            // what keymaps are now being used to what keymaps were being
            // used before.  Change the using count accordingly.

            for (uIndex = 0; uIndex < uSize; uIndex++, lpbKeyUsage++)
                if ((*lpbKeyUsage & MSB) && (!(*lpbKeyUsage & LSB))) {
                    mmaperr = MmaperrChangeUsing(MMAP_KEY,uIndex + 1, 1);
                    if (mmaperr != MMAPERR_SUCCESS)
                            goto exit03;
                } else if (! (*lpbKeyUsage & MSB) &&
                    (*lpbKeyUsage & LSB))
                    mmaperr = MmaperrChangeUsing(MMAP_KEY, uIndex + 1, -1);
                    if (mmaperr != MMAPERR_SUCCESS)
                            goto exit03;
            // nuke the usage table
            GlobalUnlock(hKeyUsage);
            GlobalFree(hKeyUsage);
            hKeyUsage = NULL;
        }
        // set patch size to global offset.
        mmPatch.dwSize = dwOffset;
        // write the patchmap
        if (_llseek(iFile, doData, 0) == -1L) {
                mmaperr = MMAPERR_WRITE;
                goto exit03;
        }
        if ( _lwrite(iFile, (LPSTR)&mmPatch,sizeof(MMPATCH))
           != sizeof(MMPATCH)
           ) {
                mmaperr = MMAPERR_WRITE;
                goto exit03;
        }
        // free the unique keymap name list
        VFreeUniqueList(&hKeyList);
        // free tables, close file and leave
        VFreeTable(MMAP_PATCH | MMAP_KEY);
        mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        return MMAPERR_SUCCESS;
} /* MmaperrWritePatchmap */

//      -       -       -       -       -       -       -       -       -

//      MmaperrWriteKeymap
//
//      Write a keymap to the midi data file.
//
//      1.      If this routine fails it will corrupt the database.

STATIC  MMAPERR NEAR PASCAL MmaperrWriteKeymap (LPMIDIKEYMAP lpKey)
{
        LPMMTABLEENTRY  lpmmEntry;
        MMKEY   mmOldKey;
        MMKEY   mmKey;
        MMAPERR mmaperr;
        DWORD   doData;
        BOOL    fExists;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        lpmmEntry = LpGetTableEntry(hKeyTable, lpKey->szName);
        if (lpmmEntry != NULL) {
            if (lstrcmpi((LPSTR)(lpmmEntry->szDesc), lpKey->szDesc)) {
                lstrcpy((LPSTR)(lpmmEntry->szDesc), lpKey->szDesc);
                mmaperr = MmaperrWriteTabEntry(MMAP_KEY, 0, lpmmEntry);
                if (mmaperr != MMAPERR_SUCCESS) {
exit01:             VFreeTable(MMAP_KEY);
                    goto exit00;
                }
            }
            doData = lpmmEntry->doData;
            fExists = TRUE;
        } else {
                mmaperr = MmaperrAddMap(MMAP_KEY, (LPVOID)lpKey, &doData);
                if (mmaperr != MMAPERR_SUCCESS)
                        goto exit01;
                mmKey.wUsing = 0;
                fExists = FALSE;
        }
        // zero-out the keymap data structure
        _fmemset((LPSTR)&mmKey, 0, sizeof(MMKEY));
        // if not a new keymap, get old usage count
        if (fExists) {
                if ( _llseek(iFile, doData, 0) == -1L) {
                        mmaperr = MMAPERR_READ;
                        goto exit01;
                }
                if ( _lread(iFile, (LPSTR)&mmOldKey, sizeof(MMKEY))
                   != sizeof(MMKEY)
                   ) {
                        mmaperr = MMAPERR_READ;
                        goto exit01;
                }
                mmKey.wUsing = mmOldKey.wUsing;
        }
        // copy over flags and keymap data
        mmKey.dwFlags = lpKey->dwFlags;
        _fmemcpy( (LPSTR)(mmKey.bKMap)
                , lpKey->bKMap
                , MIDIPATCHSIZE * sizeof(BYTE));
        if (_llseek(iFile, doData, 0) == -1L) {
                mmaperr = MMAPERR_WRITE;
                goto exit01;
        }
        if (_lwrite(iFile, (LPSTR)&mmKey, sizeof(MMKEY)) != sizeof(MMKEY)) {
                mmaperr = MMAPERR_WRITE;
                goto exit01;
        }
        VFreeTable(MMAP_KEY);
        mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        return MMAPERR_SUCCESS;
} /* MmaperrWriteKeymap */

//      -       -       -       -       -       -       -       -       -

//      MmaperrAddMap
//
//      Generic add map routine.
//      Add a map table entry, increment table use count.
//
//      Issues:
//
//      1.      None.

STATIC  MMAPERR NEAR PASCAL MmaperrAddMap(
        UINT    uFlag,
        LPVOID  lpvMap,
        LPDWORD lpdoData)
{
        HANDLE  hTable;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmEntry;
        LPSTR   lpName;
        LPSTR   lpDesc;
        MMTABLEENTRY    mmEntry;
        MMAPERR mmaperr;
        DWORD   doData;
        WORD    wEntry;
        WORD    wEntrys;

        switch (uFlag) {
        case MMAP_SETUP :
                hTable = hSetupTable;
                lpName = ((SETUP FAR*)lpvMap)->aszSetupName;
                lpDesc = ((SETUP FAR*)lpvMap)->aszSetupDescription;
                break;
        case MMAP_PATCH :
                hTable = hPatchTable;
                lpName = ((PATCHMAP FAR*)lpvMap)->aszPatchMapName;
                lpDesc = ((PATCHMAP FAR*)lpvMap)->aszPatchMapDescription;
                break;
        case MMAP_KEY :
                hTable = hKeyTable;
                lpName = ((LPMIDIKEYMAP)lpvMap)->szName;
                lpDesc = ((LPMIDIKEYMAP)lpvMap)->szDesc;
                break;
        default:lpDesc = NULL;  // Kill spurious use before set diagnostic
                lpName = NULL;  // Kill spurious use before set diagnostic
                hTable = NULL;  // Kill spurious use before set diagnostic
        }
        lpmmTable = (LPMMTABLE)GlobalLock(hTable);
        wEntrys = lpmmTable->mmHeader.wEntrys;
        lpmmEntry = (LPMMTABLEENTRY)GlobalLock(lpmmTable->hEntrys);
        for (wEntry = 0; wEntry < wEntrys; wEntry++, lpmmEntry++)
                if (!*lpmmEntry->szName)
                        break;
        GlobalUnlock(lpmmTable->hEntrys);
        if (wEntry == wEntrys) {
                // Filled table;
                mmaperr = MMAPERR_FULL;
                goto exit00;
        }
        _fmemset(&mmEntry, 0, sizeof(MMTABLEENTRY));
        lstrcpy((LPSTR)(mmEntry.szName), lpName);
        lstrcpy((LPSTR)(mmEntry.szDesc), lpDesc);
        mmEntry.idxEntry = wEntry + 1;
        doData = mmEntry.doData = _llseek(iFile, 0L, 2);
        if (doData == -1L) {
                mmaperr = MMAPERR_WRITE;
exit00:         GlobalUnlock(hTable);
                return mmaperr;
        }
        mmaperr = MmaperrWriteTabEntry(uFlag, 0, &mmEntry);
        if (mmaperr != MMAPERR_SUCCESS)
                goto exit00;
        lpmmTable->mmHeader.wUsed++;
        mmaperr = MmaperrWriteTabHeader( uFlag
                                     , (LPMMTABLEHEADER)(&lpmmTable->mmHeader));
        if (mmaperr != MMAPERR_SUCCESS)
                goto exit00;
        GlobalUnlock(hTable);
        *lpdoData = doData;
        return MMAPERR_SUCCESS;
} /* MmaperrAddMap */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapGetSize | This function retrieves the size in bytes
 *      that will be required to read an entire map into memory.  This
 *      includes the size of any patchmaps and keymaps that the map may
 *      contain.
 *
 * @parm UINT | uFlag | Specifies the type of map of which to get the size.
 *      It may be any of the following:
 *
 *      @flag MMAP_SETUP | Get the size of a setup.
 *      @flag MMAP_PATCH | Get the size of a patchmap.
 *      @flag MMAP_KEY | Get the size of a keymap.
 *
 * @parm LPSTR | lpName | Specifies the name of the map of which you
 *      want to get the size.
 *
 * @rdesc An MMAP error code, or the size in bytes required to read in the
 *      map specified by <p lpName>.  If the return value is greater than
 *      MMAPERR_MAXERROR then the return value is a size and not an error.
 */

//
//      This function returns either an error code or the size of the thing.
//      The way you tell the difference is to guess.  The best way to guess
//      is to compare the return value against MMAPERR_MAXERROR, and if it is
//      greater than or equal to that value you've got a size, not an error.
//
//      Issues:
//
//      1.      None.

DWORD   FAR PASCAL mapGetSize(
        UINT    uFlag,
        LPSTR   lpName)
{
        switch (uFlag) {
        case MMAP_SETUP :
                return DwGetSetupSize(lpName);
        case MMAP_PATCH :
        case MMAP_KEY :
                return DwGetMapSize(uFlag, lpName);
        }
} /* mapGetSize */

//      -       -       -       -       -       -       -       -       -

//      DwGetSetupSize
//
//      Get the size of a setup.
//
//      This function returns either an error code or the size of the thing.
//      The way you tell the difference is to guess.  The best way to guess
//      is to compare the return value against MMAPERR_MAXERROR, and if it is
//      greater than or equal to that value you've got a size, not an error.
//
//      Issues:
//
//      1.      None.

STATIC  DWORD NEAR PASCAL DwGetSetupSize(
        LPSTR   lpName)
{
        LPMMTABLEENTRY  lpmmEntry;
        LPMMCHANNEL     lpmmChan;
        MMAPERR mmaperr;
        MMSETUP mmSetup;
        DWORD   dwRet;
        DWORD   dwOffset;
        int     i;

        mmaperr = MmaperrFileAccess(MAP_FOPEN,OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return (DWORD)mmaperr;
        mmaperr = MmaperrReadTable(MMAP_SETUP | MMAP_PATCH);
        if (mmaperr != MMAPERR_SUCCESS) {
                dwRet = (DWORD)mmaperr;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return dwRet;
        }
        // if name isn't in the file, get outta here
        lpmmEntry = LpGetTableEntry(hSetupTable, lpName);
        if (lpmmEntry == NULL) {
                dwRet = (DWORD)MMAPERR_INVALIDSETUP;
exit01:         VFreeTable(MMAP_SETUP | MMAP_PATCH);
                goto exit00;
        }
        // intialize offset
        dwOffset = sizeof(MIDIMAP);
        // read in the setup data
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                dwRet = (DWORD)MMAPERR_READ;
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmSetup,
                sizeof(MMSETUP)) != sizeof(MMSETUP)) {
                dwRet = (DWORD)MMAPERR_READ;
                goto exit01;
        }
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
        for (i = 0; i < 16; i++, lpmmChan++) {
                DWORD   dwUniqueRet;

                // if no patchmap then continue
                if (!lpmmChan->idxPMapName)
                        continue;
                // assuming patchmap actually exists here
                lpmmEntry = LpGetTableEntry(hPatchTable,
                        MAKEID(lpmmChan->idxPMapName));
                // if patchmap is unique, add size to global offset
                dwUniqueRet = LiNotUnique( (LPSTR)(lpmmEntry->szName)
                                         , &hPatchList
                                         , dwOffset);
                if (dwUniqueRet == -1L) {
                        dwRet = (DWORD)MMAPERR_MEMORY;
                        goto exit01;
                } else if (!dwUniqueRet) {
                        dwRet = DwGetMapSize(MMAP_PATCH,NULL);
                        if (dwRet < MMAPERR_MAXERROR) {
                                VFreeUniqueList(&hPatchList);
                                goto exit01;
                        }
                        dwOffset += dwRet;
                }
        }
        // free the unique patchmap list
        VFreeUniqueList(&hPatchList);
        VFreeTable(MMAP_SETUP | MMAP_PATCH);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return (dwOffset < (DWORD)MMAPERR_MAXERROR) ? (DWORD)MMAPERR_INVALIDSETUP : dwOffset;
} /* DwGetSetupSize */

//      -       -       -       -       -       -       -       -       -

//      DwGetMapSize
//
//      Get the size of a patchmap or keymap.
//
//      This function returns either an error code or the size of the thing.
//      The way you tell the difference is to guess.  The best way to guess
//      is to compare the return value against MMAPERR_MAXERROR, and if it is
//      greater than or equal to that value you've got a size, not an error.
//
//      Remarks:
//
//      1.      None.

STATIC  DWORD NEAR PASCAL DwGetMapSize(
        UINT    uFlag,
        LPSTR   lpName)
{
        LPMMTABLEENTRY lpmmEntry;
        LPHANDLE lphTable;
        MMPATCH mmPatch;
        MMAPERR mmaperr;
        DWORD   dwRet;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return (DWORD)mmaperr;
        mmaperr = MmaperrReadTable(uFlag);
        if (mmaperr != MMAPERR_SUCCESS) {
                dwRet = (DWORD)mmaperr;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return dwRet;
        }
        lphTable = (uFlag == MMAP_PATCH) ? &hPatchTable : &hKeyTable;
        lpmmEntry = LpGetTableEntry(*lphTable, lpName);
        if (lpmmEntry == NULL) {
                dwRet = (uFlag == MMAP_PATCH)
                        ? (DWORD)MMAPERR_INVALIDPATCH
                        : (DWORD)MMAPERR_INVALIDKEY;
                VFreeTable(uFlag);
                goto exit00;
        }
        switch (uFlag) {
        case MMAP_PATCH :
                // patchmaps have the size stored in the file.
                if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                        dwRet = (DWORD)MMAPERR_READ;
                        break;
                }
                if ( _lread(iFile, (LPSTR)&mmPatch, sizeof(MMPATCH))
                   != sizeof(MMPATCH)
                   ) {
                        dwRet = (DWORD)MMAPERR_READ;
                        break;
                }
                dwRet = mmPatch.dwSize;
                if (dwRet < (DWORD)MMAPERR_MAXERROR)
                        dwRet = MMAPERR_INVALIDPATCH;
                break;
        case MMAP_KEY:
                // keymaps are all the same size.
                dwRet = sizeof(MIDIKEYMAP);
                break;
        default: dwRet = (DWORD)MMAPERR_READ;
        }
        VFreeTable(uFlag);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return dwRet;
} /* DwGetMapSize */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapDelete | This function deletes a map from the midi
 *       data file.
 *
 * @parm UINT | uFlag | Specifies the type of map to be deleted.
 *      It may be any of the following:
 *
 *      @flag MMAP_SETUP | Delete a setup.
 *      @flag MMAP_PATCH | Delete a patchmap.
 *      @flag MMAP_KEY | Delete a keymap.
 *
 * @parm LPSTR | lpName | Specifies the name of the map to be deleted.
 *
 * @rdesc Returns a MMAP error code or zero on success.
 */

//      Issues:
//
//      1.      If this function fails it will corrupt the database.

MMAPERR FAR PASCAL mapDelete(
        UINT    uFlag,
        LPSTR   lpName)
{
        HANDLE          hUsage;
        LPMMCHANNEL     lpmmChan = NULL; // Kill spurious use before set diag
        LPMMTABLE       lpmmTable;
        LPMMTABLEHEADER lpmmHeader;
        LPMMTABLEENTRY  lpmmEntry;
        LPHANDLE        lphTable;
        LPHANDLE        lphUsageTable;
        UNALIGNED WORD  *lpidxNames = NULL;   // Kill spurious use before set diagnostic
        LPBYTE  lpbUsage;
        MMSETUP mmSetup;
        MMPATCH mmPatch;
        MMAPERR mmaperr;
        UINT    uGarbage;            // size of thing getting deleted
        UINT    uSize;
        UINT    uIdx;                // index of deleted entry in table
        UINT    uUsageFlag = 0;      // SETUP or PATCH => same as uFlag, else 0
        UINT    uNumPos;             // # of positions; setup=16, patch=128
        int     idxEntry;            // table index
        UINT    uIndex;

        // grab the appropriate table, structure size and usage info
        switch (uFlag) {
        case MMAP_SETUP:
                lphTable = &hSetupTable;
                uGarbage = sizeof(MIDIMAP);
                lphUsageTable = &hPatchTable;
                uUsageFlag = MMAP_PATCH;
                uNumPos = 16;
                break;
        case MMAP_PATCH:
                lphTable = &hPatchTable;
                lphUsageTable = &hKeyTable;
                uUsageFlag = MMAP_KEY;
                uGarbage = sizeof(MIDIPATCHMAP);
                uNumPos = MIDIPATCHSIZE;
                break;
        case MMAP_KEY:
                lphTable = &hKeyTable;
                uGarbage = sizeof(MIDIKEYMAP);
                uNumPos = 0;     // Kill spurious diagnostic
                lphUsageTable = NULL; // Kill spurious diagnostic
                break;
        default:uGarbage = 0;
                lphTable = NULL; // kill spurious use before set diagnostic
                lphUsageTable = NULL; // Kill spurious diagnostic
                uNumPos = 0;     // kill spurious use before set diagnostic
        }
        // open file, read in appropriate table(s)
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(uFlag |uUsageFlag);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        lpmmEntry = LpGetTableEntry(*lphTable, lpName);
        if (lpmmEntry == NULL) {
                switch (uFlag) {
                case MMAP_SETUP:
                        mmaperr = MMAPERR_INVALIDSETUP;
                        break;
                case MMAP_PATCH:
                        mmaperr = MMAPERR_INVALIDPATCH;
                        break;
                case MMAP_KEY:
                        mmaperr = MMAPERR_INVALIDKEY;
                        break;
                }
exit01:         VFreeTable(uFlag | uUsageFlag);
                goto exit00;
        }
        // save the table index
        idxEntry = lpmmEntry->idxEntry;
        if (uUsageFlag) {
                // obtain the number of entrys in the usage table
                lpmmTable = (LPMMTABLE)GlobalLock(*lphUsageTable);
                uSize = lpmmTable->mmHeader.wEntrys;
                GlobalUnlock(*lphUsageTable);
                // read in setup or patchmap, set optimization pointer
                if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                        mmaperr = MMAPERR_READ;
                        goto exit01;
                }
                if (uUsageFlag == MMAP_PATCH) {
                        if (_lread(iFile, (LPSTR)&mmSetup,
                                sizeof(MMSETUP)) != sizeof(MMSETUP)) {
                                mmaperr = MMAPERR_READ;
                                goto exit01;
                        }
                        lpmmChan =(LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
                } else {
                        if (_lread(iFile, (LPSTR)&mmPatch,
                                sizeof(MMPATCH)) != sizeof(MMPATCH)) {
                                mmaperr = MMAPERR_READ;
                                goto exit01;
                        }
                        lpidxNames = mmPatch.idxKMapNames;
                }
                // create table which is 'number-of-maps' in length
                if (uSize) {
                    hUsage = GlobalAlloc(GHND, (LONG)uSize);
                    if (hUsage == NULL) {
                            mmaperr = MMAPERR_MEMORY;
                            goto exit01;
                    }
                    lpbUsage = (LPBYTE)GlobalLock(hUsage);
                    // set flags in table saying which patchmaps or
                    // keymaps this setup or patchmap references,
                    // respectively
                    for (uIndex = 0; uIndex < uNumPos; uIndex++) {
                        if (uUsageFlag == MMAP_PATCH) {
                            uIdx = lpmmChan->idxPMapName;
                            lpmmChan++;
                        } else {
                            uIdx = *lpidxNames;
                            lpidxNames++;
                        }
                        if (uIdx)
                            lpbUsage[uIdx - 1] = 1;
                    }
                    // go through table and decrement usage count
                    // of any entrys that are non zero
                    for (uIndex = 0; uIndex < uSize; uIndex++, lpbUsage++) {
                        if (!*lpbUsage)
                            continue;
                        mmaperr = MmaperrChangeUsing(uUsageFlag,uIndex + 1, -1);
//                                                              uIndex + -1, 1)
                        if (mmaperr != MMAPERR_SUCCESS) {
                            GlobalUnlock(hUsage);
                            GlobalFree(hUsage);
                            goto exit01;
                        }
                    }
                    GlobalUnlock(hUsage);
                    GlobalFree(hUsage);
                }
        }
        _fmemset((LPSTR)(lpmmEntry->szName), 0L, MMAP_MAXNAME);
        _fmemset((LPSTR)(lpmmEntry->szDesc), 0L, MMAP_MAXDESC);
        lpmmEntry->doData = 0L;
        lpmmEntry->idxEntry = 0L;
        mmaperr = MmaperrWriteTabEntry(uFlag, idxEntry, lpmmEntry);
        if (mmaperr != MMAPERR_SUCCESS)
                goto exit01;                    // Yes, 01, not 02.
        lpmmTable = (LPMMTABLE)GlobalLock(*lphTable);
        lpmmHeader = (LPMMTABLEHEADER)(&lpmmTable->mmHeader);
        lpmmHeader->wUsed--;
        mmaperr = MmaperrWriteTabHeader(uFlag,lpmmHeader);
        if (mmaperr != MMAPERR_SUCCESS) {
                GlobalUnlock(*lphTable);
                goto exit01;                    // Yes, 01, not 02.
        }
        GlobalUnlock(*lphTable);
        mmaperr = MmaperrGarbage(uGarbage);
        if (mmaperr != MMAPERR_SUCCESS)
                goto exit01;                    // Yes, 01, not 02.
        VFreeTable(uFlag | uUsageFlag);
        mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        return MMAPERR_SUCCESS;
} /* mapDelete */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapEnumerate | This function enumerates the names and
 *      descriptions of all the maps of the specified type found in the
 *      midi data file, or the names and device id's of the ports a setup
 *      accesses.
 *
 * @parm UINT | uFlag | Specifies the type of enumerate to be performed.  It
 *       may be any one of the following values:
 *
 * @flag MMAP_SETUP | Enumerate setup names.
 * @flag MMAP_PATCH | Enumerate patchmap names.
 * @flag MMAP_KEY   | Enumerate keymap names.
 * @flag MMAP_PORTS | Enumerate ports in a setup.
 *
 * @parm ENUMPROC | lpfnCallback | Specifies the procedure-instance address of
 *      the callback function to be called with the name of each map.
 *
 * @parm DWORD | dwUser | If <p uFlag> is <f MMAP_SETUP>, <f MMAP_PATCH>, or
 *      <f MMAP_KEY>, this parameter specifies a user variable that will be
 *      passed to the callback function along with the name of each map.  If
 *      <p uFlag> is <f MMAP_PORTS>, this parameter specifies a far pointer
 *      to a setup name.
 *
 * @rdesc Returns a MMAP error code or zero on success.
 *
 * @comm <p lpfnCallBack> must be obtained using the <f MakeProcInstance>
 *      call, must use the pascal calling convention, must be declared FAR,
 *      and must be under the EXPORTS section in your applications .DEF file.
 *
 * @cb BOOL FAR PASCAL | EnumerateCallback | The callback function for
 *      <f mapEnumerate>.
 *
 * @parm LPSTR | lpName | If <p uFlag> is <f MMAP_SETUP>, <f MMAP_PATCH>, or
 *      <f MMAP_KEY>, this parameter specifies the name of a map of that type.
 *      If <p uFlag> is <f MMAP_PORTS>, this parameter is a number in the
 *      range of 1 to 16 which specifies the channel on which the supplied
 *      port <p lpDesc> is mapped.
 *
 * @parm LPSTR | lpDesc | If <p uFlag> is <f MMAP_SETUP>, <f MMAP_PATCH>, or
 *      <f MMAP_KEY>, this parameter specifies the description of the map in
 *      the <p lpName> parameter.  If <p uFlag> is <f MMAP_PORTS>, this
 *      parameter specifies the name of a port accessed by the setup.
 *
 * @parm DWORD | dwUser | If <p uFlag> is <f MMAP_SETUP>, <f MMAP_PATCH>, or
 *      <f MMAP_KEY>, this parameter specifies a user variable.  If <p uFlag>
 *      is <f MMAP_PORTS>, this parameter specifies the device ID of the
 *      supplied port <p lpDesc>.  In this case, if the port is not available
 *      in the current environment, the device ID is equal to the constant
 *      MMAP_ID_NOPORT.
 *
 * @rdesc It should return non-zero as long as it wants to continue being
 *      called with successive map or port names.  <f mapEnumerate> will stop
 *      enumerating when the callback function returns zero.
 */

//      Issues:
//
//      1.      It regards elements with a zero first byte as "not counting"
//              in the count of elements in a table.  If this is a bad
//              assertion, this routine has a bug.

MMAPERR FAR PASCAL mapEnumerate ( UINT uFlag
                                , ENUMPROC lpfnCallback
                                , UINT uCase        // passed to lpfnCallback
                                , HWND hCombo       // passed to lpfnCallback
                                , LPSTR lpSetupName // passed to lpfnCallback
                                )
{
        LPHANDLE        lphTable;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmEntry;
        UINT            wEnum;
        UINT            wUsed;
        MMAPERR mmaperr;

        switch (uFlag) {
        case MMAP_SETUP :
                lphTable = &hSetupTable;
                break;
        case MMAP_PATCH :
                lphTable = &hPatchTable;
                break;
        case MMAP_KEY :
                lphTable = &hKeyTable;
                break;
        case MMAP_PORTS :
                return MmaperrEnumPorts(lpfnCallback, uCase, hCombo, lpSetupName);
        default: lphTable = NULL;  // kill spurious use before set diagnostic
        }
        mmaperr = MmaperrReadTable(uFlag);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        lpmmTable = (LPMMTABLE)GlobalLock(*lphTable);
        lpmmEntry = (LPMMTABLEENTRY)GlobalLock(lpmmTable->hEntrys);
        wUsed = lpmmTable->mmHeader.wUsed;
        for (wEnum = 0; wEnum < wUsed; lpmmEntry++) {
                if (!*lpmmEntry->szName)
                        continue;
                if (!(*lpfnCallback)( (LPSTR)lpmmEntry->szName
                                    , (LPSTR)lpmmEntry->szDesc
                                    , uCase
                                    , hCombo
                                    , lpSetupName
                                    )
                   )
                        break;
                wEnum++;
        }
        GlobalUnlock(lpmmTable->hEntrys);
        GlobalUnlock(*lphTable);
        VFreeTable(uFlag);
        return MMAPERR_SUCCESS;
} /* mapEnumerate */

//      -       -       -       -       -       -       -       -       -

//      MmaperrEnumPorts
//
//      Enumerate the ports in a setup.
//
//      Side-effects:
//
//      1.      None.
//
//      Remarks:
//
//      1.      If the enumeration function fails, this function won't
//              let you know.

STATIC  MMAPERR NEAR PASCAL MmaperrEnumPorts(
        ENUMPROC    lpfnCallback,
        UINT        uCase,          // unused
        HWND        hCombo,         // unused
        LPSTR       lpSetupName)
{
        LPMMTABLEENTRY  lpmmEntry;
        LPMMCHANNEL     lpmmChan;
        MIDIOUTCAPS     moCaps;
        MMSETUP mmSetup;
        MMAPERR mmaperr;
        UINT    wNumDevs;
        UINT    uDeviceID;
        int     i;

        // open file, read in setup table
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        mmaperr = MmaperrReadTable(MMAP_SETUP);
        if (mmaperr != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        // assuming setup actually exists
        lpmmEntry = LpGetTableEntry(hSetupTable, lpSetupName);
        if (lpmmEntry == NULL) {
                mmaperr = MMAPERR_INVALIDSETUP;
exit01:         VFreeTable(MMAP_SETUP);
                goto exit00;
        }
        // read in setup data from file
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmSetup, sizeof(MMSETUP)) != sizeof(MMSETUP)) {
                mmaperr = MMAPERR_READ;
                goto exit01;
        }
        // grab the number of devices in the current environment
        wNumDevs = midiOutGetNumDevs();
        // set an optimization-pointer
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
        for (i = 0; i < 16; i++, lpmmChan++) {
                // if no device name, then nothing to enumerate
                if (!*lpmmChan->szDevice)
                        continue;
                // convert device name to device ID.  If device name doesn't
                // exist in the current environment, set ID to MMAP_ID_NOPORT
                for (uDeviceID = 0; uDeviceID < wNumDevs; uDeviceID++) {
                        midiOutGetDevCaps(uDeviceID, &moCaps, sizeof(MIDIOUTCAPS));
                        if (!lstrcmpi( moCaps.szPname
                                     , (LPCSTR)(lpmmChan->szDevice)))
                                break;
                }
                if (uDeviceID == wNumDevs)
                        uDeviceID = MMAP_ID_NOPORT;
                if (!(*lpfnCallback)( (LPSTR)(DWORD)i + 1
                                    , (LPSTR)(lpmmChan->szDevice)
                                    , uCase         // garbage parameter
                                    , hCombo        // garbage parameter
                                    , (LPSTR)uDeviceID
                                    )
                   )
                        break;
        }
        // free table, close file and leave
        VFreeTable(MMAP_SETUP);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return MMAPERR_SUCCESS;
} /* MmaperrEnumPorts */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapGetUsageCount | Get the usage count for a patchmap or
 *      keymap.
 *
 * @parm UINT | uFlag | Specifies the type of map to get the usage count for.
 *      It may be any one of the following values:
 *
 * @flag MMAP_PATCH | Get the usage count for a patchmap.
 * @flag MMAP_KEY | Get the usage count for a keymap.
 *
 * @parm LPSTR | lpName | Specifies the name of the map to get the usage
 *      count for.
 *
 * @rdesc Returns a MMAP error code, or the usage count for the map
 *      specified by <p lpName> in the high-order word.
 *
 * @comm Usage counts are used in order to determine whether it is okay to
 *      delete a patchmap or keymap.  If a setup accesses a patchmap, the
 *      usage count for that patchmap will be 1, and hence it should not be
 *      deleted.  The same is true for patchmaps accessing keymaps.  The
 *      mapDelete function does not look for or care about this number, so
 *      it is up to YOU to determine whether a patchmap or keymap has a zero
 *      usage count before calling mapDelete.
 */

//      Side-effects:
//
//      1.      None.

DWORD   FAR PASCAL mapGetUsageCount(
        UINT    uFlag,
        LPSTR   lpName)
{
        LPMMTABLEENTRY  lpmmEntry;
        MMPATCH mmPatch;
        MMKEY   mmKey;
        MMAPERR mmaperr;
        DWORD   dwRet;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return MAKELONG(mmaperr, 0);
        mmaperr = MmaperrReadTable(uFlag);
        if (mmaperr != MMAPERR_SUCCESS) {
                dwRet = MAKELONG(mmaperr, 0);
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return dwRet;
        }
        switch (uFlag) {
        case MMAP_PATCH:
                lpmmEntry = LpGetTableEntry(hPatchTable, lpName);
                if (lpmmEntry != NULL) {
                        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                                dwRet = MAKELONG(MMAPERR_READ, 0);
exit01:                         VFreeTable(uFlag);
                                goto exit00;
                        }
                        if ( _lread(iFile, (LPSTR)&mmPatch, sizeof(MMPATCH))
                           != sizeof(MMPATCH)
                           ) {
                                dwRet = MAKELONG(MMAPERR_READ, 0);
                                goto exit01;
                        }
                        dwRet = MAKELONG(MMAPERR_SUCCESS, mmPatch.wUsing);
exit02:                 VFreeTable(uFlag);
                        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                        return dwRet;
                } else {
                        dwRet = MAKELONG(MMAPERR_INVALIDPATCH, 0);
                        goto exit01;
                }
                break;          // This "break" is actually unreachable.
        case MMAP_KEY:
                lpmmEntry = LpGetTableEntry(hKeyTable, lpName);
                if (lpmmEntry != NULL) {
                        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                                dwRet = MAKELONG(MMAPERR_READ, 0);
                                goto exit01;
                        }
                        if (_lread(iFile, (LPSTR)&mmKey, sizeof(MMKEY))
                           != sizeof(MMKEY)
                           ) {
                                dwRet = MAKELONG(MMAPERR_READ, 0);
                                goto exit01;
                        }
                        dwRet = MAKELONG (MMAPERR_SUCCESS, mmKey.wUsing);
                        goto exit02;
                } else {
                        dwRet = MAKELONG(MMAPERR_INVALIDPATCH, 0);
                        goto exit01;
                }
                break;          // This "break" is actually unreachable.
        }
} /* mapGetUsageCount */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapPatchMapInSetup | Determine if a patchmap is used within a
 *      setup.
 *
 * @parm LPSTR | lpPatchName | Specifies the name of the patchmap.
 *
 * @parm LPSTR | lpSetupName | Specifies the name of the setup.
 *
 * @rdesc Returns a MMAP error code, or non-zero in the high-order word if the
 *      given patchmap is used within the given setup.
 *
 * @xref mapKeyMapInSetup
 */

//      Side-effects:
//
//      1.      None.

DWORD   FAR PASCAL mapPatchMapInSetup(
        LPSTR   lpPatchName,
        LPSTR   lpSetupName)
{
        LPMMTABLEENTRY  lpmmEntry;
        LPMMCHANNEL     lpmmChan;
        MMSETUP mmSetup;
        DWORD   dwRet;
        MMAPERR mmaperr;
        int     i;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return MAKELONG(mmaperr, 0);
        mmaperr = MmaperrReadTable(MMAP_SETUP | MMAP_PATCH);
        if (mmaperr != MMAPERR_SUCCESS) {
                dwRet = MAKELONG(mmaperr, 0);
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return dwRet;
        }
        lpmmEntry = LpGetTableEntry(hSetupTable, lpSetupName);
        if (lpmmEntry == NULL) {
                dwRet = MAKELONG(MMAPERR_INVALIDSETUP, 0);
exit01:         VFreeTable(MMAP_SETUP | MMAP_PATCH);
                goto exit00;
        }
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                dwRet = MAKELONG(MMAPERR_READ, 0);
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmSetup, sizeof(MMSETUP)) != sizeof(MMSETUP)){
                dwRet = MAKELONG(MMAPERR_READ, 0);
                goto exit01;
        }
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap); // MIPS silliness
        for (i = 0; i < 16; i++, lpmmChan++) {
                if (!lpmmChan->idxPMapName)
                        continue;
                lpmmEntry = LpGetTableEntry(hPatchTable,
                        MAKEID(lpmmChan->idxPMapName));
                if (!lstrcmpi(lpPatchName, (LPCSTR)(lpmmEntry->szName)))
                        break;
        }
        VFreeTable(MMAP_SETUP | MMAP_PATCH);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return MAKELONG(MMAPERR_SUCCESS, (i < 16) ? 1 : 0);
} /* mapPatchMapInSetup */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapKeyMapInSetup | Determine if a keymap is used within a
 *      setup.
 *
 * @parm LPSTR | lpKeyName | Specifies the name of the keymap.
 *
 * @parm LPSTR | lpSetupName | Specifies the name of the setup.
 *
 * @rdesc Returns a MMAP error code, or non-zero in the high-order word
 *      if the given keymap is used within the given patchmap.
 *
 * @xref mapPatchMapInSetup
 */

DWORD   FAR PASCAL mapKeyMapInSetup(
        LPSTR   lpKeyName,
        LPSTR   lpSetupName)
{
        LPMMTABLEENTRY  lpmmEntry;
        LPMMCHANNEL     lpmmChan;
        MMSETUP mmSetup;
        MMPATCH mmPatch;
        UNALIGNED WORD  *lpidxKMap;
        DWORD   dwRet;
        MMAPERR mmaperr;
        int     i;
        int     j;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return MAKELONG(mmaperr, 0);
        mmaperr = MmaperrReadTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
        if (mmaperr != MMAPERR_SUCCESS) {
                dwRet = MAKELONG(mmaperr, 0);
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return dwRet;
        }
        if ((lpmmEntry = LpGetTableEntry(hSetupTable, lpSetupName)) == NULL) {
                dwRet = MAKELONG(MMAPERR_INVALIDSETUP, 0);
exit01:         VFreeTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
                goto exit00;
        }
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                dwRet = MAKELONG(MMAPERR_READ, 0);
                goto exit01;
        }
        if (_lread(iFile, (LPSTR)&mmSetup, sizeof(MMSETUP)) != sizeof(MMSETUP)){
                dwRet = MAKELONG(MMAPERR_READ, 0);
                goto exit01;
        }
        lpmmChan = (LPMMCHANNEL)(mmSetup.chMap);  // MIPS silliness
        dwRet = MAKELONG(MMAPERR_SUCCESS, 0);
        for (i = 0; i < 16; i++, lpmmChan++) {
                DWORD   dwUniqueRet;

                if (!lpmmChan->idxPMapName)
                        continue;
                lpmmEntry = LpGetTableEntry(hPatchTable,
                        MAKEID(lpmmChan->idxPMapName));
                dwUniqueRet = LiNotUnique( (LPSTR)(lpmmEntry->szName)
                                         , &hPatchList
                                         , 0L);
                        //  0L in the "dwOffset" field  because it's never used.
                if (dwUniqueRet == -1L) {
                        dwRet = MAKELONG(MMAPERR_MEMORY, 0);
exit02:                 VFreeUniqueList(&hPatchList);
                        goto exit01;
                } else if (dwUniqueRet)
                        continue;
                if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                        dwRet = MAKELONG(MMAPERR_READ, 0);
                        goto exit02;
                }
                if ( _lread(iFile, (LPSTR)&mmPatch, sizeof(MMPATCH))
                   != sizeof(MMPATCH)
                   ) {
                        dwRet = MAKELONG(MMAPERR_READ, 0);
                        goto exit02;
                }
                lpidxKMap = mmPatch.idxKMapNames;
                for (j = 0; j < MIDIPATCHSIZE; j++, lpidxKMap++) {
                        if (!*lpidxKMap)
                                continue;
                        lpmmEntry = LpGetTableEntry(hKeyTable,
                                MAKEID(*lpidxKMap));
                        if (!lstrcmpi(lpKeyName, (LPCSTR)(lpmmEntry->szName))) {
                                dwRet = MAKELONG(MMAPERR_SUCCESS, 1);
                                break;
                        }
                }
                if (j < MIDIPATCHSIZE)
                        break;
        }
        VFreeUniqueList(&hPatchList);
        // free tables, close file and leave
        VFreeTable(MMAP_SETUP | MMAP_PATCH | MMAP_KEY);
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return dwRet;
} /* mapKeyMapInSetup */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api DWORD | mapExists | Deterine if a map exists by the given name.
 *
 * @parm UINT | uFlag | Specifies the type of map of which existence is
 *      to be determined. It may be any of the following:
 *
 *      @flag MMAP_SETUP | Determine if a setup exists.
 *      @flag MMAP_PATCH | Determine if a patchmap exists.
 *      @flag MMAP_KEY |  Determine if a keymap exists.
 *
 * @parm LPSTR | lpName | Specifies the name of the map.
 *
 * @rdesc Returns a MMAP error code in the low word.  The the call succeeds,
 *      returns non-zero in the high-order word if a map exists by the given
 *      name.
 */

//      Side-effects:
//
//      1.      None.

DWORD FAR PASCAL mapExists(
        UINT    uFlag,
        LPSTR   lpName)
{
        LPHANDLE        lphTable;
        LPMMTABLEENTRY  lpmmEntry;
        MMAPERR mmaperr;

        switch (uFlag) {
        case MMAP_SETUP:
                lphTable = &hSetupTable;
                break;
        case MMAP_PATCH:
                lphTable = &hPatchTable;
                break;
        case MMAP_KEY:
                lphTable = &hKeyTable;
                break;
        default:lphTable = NULL; // kill spurious use before sete diagnostic
        }
        if ((mmaperr = MmaperrReadTable(uFlag)) != MMAPERR_SUCCESS)
                return MAKELONG(mmaperr, 0);
        lpmmEntry = LpGetTableEntry(*lphTable, lpName);
        VFreeTable(uFlag);
        return MAKELONG(MMAPERR_SUCCESS, (lpmmEntry != NULL) ? 1 : 0);
} /* mapExists */

//      -       -       -       -       -       -       -       -       -

//      LiNotUnique
//
//      Return 0L if the supplied name is unique, and in this case add it to
//      the end of the list with the offset given in parm 3.
//
//      Return -1 if the GlobalAlloc fails so that the unique name
//      cannot be added.
//
//      Otherwise return an offset from the base of the current setup
//      or patchmap where the map exists, or the channel number which
//      accesses the invalid port.
//
//      Uniqueness is determined by the presence of the name on its respective
//      list; hPatchList for patchmap names; hKeyList for keymap names;
//      hPortList for port names.  It's up to the caller to give us the
//      right list to search.
//

STATIC  DWORD NEAR PASCAL LiNotUnique(
        LPSTR   lpName,
        LPHANDLE lphList,
        DWORD   dwOffset)
{
        LPUNIQUEMAP  lpumEntry = NULL; //; kill spurious use before set diag
        HANDLE  hCur;
        HANDLE  hPrev = NULL;

        for (hCur = *lphList; hCur;) {
                lpumEntry = (LPUNIQUEMAP)GlobalLock(hCur);
                if (!lstrcmpi((LPCSTR)(lpumEntry->szName), lpName)) {
                        DWORD   liRet;

                        liRet = lpumEntry->dwOffset;
                        GlobalUnlock(hCur);
                        return liRet;
                }
                hPrev = hCur;
                hCur = lpumEntry->hNext;
                if (hCur != NULL) {
                        GlobalUnlock(hPrev);
                }

        }
        hCur = GlobalAlloc(GHND, (DWORD)sizeof(UNIQUEMAP));
        if (hCur  == NULL) {
                if (hPrev != NULL) {
                        GlobalUnlock(hPrev);
                }
                return (DWORD)-1L;
        }
        if (hPrev != NULL) {
                lpumEntry->hNext = hCur;
                GlobalUnlock(hPrev);
        } else
                *lphList = hCur;
        lpumEntry = (LPUNIQUEMAP)GlobalLock(hCur);
        lstrcpy((LPSTR)(lpumEntry->szName), lpName);
        lpumEntry->dwOffset = dwOffset;
        lpumEntry->hNext = NULL;
        GlobalUnlock(hCur);
        return 0L;
} /* LiNotUnique */

//      -       -       -       -       -       -       -       -       -

//      LszGetUniqueAtOffset
//
//      Return a unique name given an offset.
//
//      Remarks:
//
//      1.      I don't think this can fail, although there's a weird case
//              if you run out of list.  In this case you get an empty string.
//              I'm not sure if this is bad or not.

STATIC  LPSTR NEAR PASCAL LszGetUniqueAtOffset(
        DWORD   dwOffset,
        HANDLE  hList)
{
        static char szUnique[MAX_UNIQUENAME];

        *szUnique = 0;
        while (hList) {
                HANDLE  hNext;
                LPUNIQUEMAP lpumEntry;

                lpumEntry = (LPUNIQUEMAP)GlobalLock(hList);
                if (dwOffset == lpumEntry->dwOffset) {
                        lstrcpy(szUnique, (LPCSTR)(lpumEntry->szName));
                        GlobalUnlock(hList);
                        break;
                }
                hNext = lpumEntry->hNext;
                GlobalUnlock(hList);
                hList = hNext;
        }
        return (LPSTR)szUnique;
} /* LszGetUniqueAtOffset */

//      -       -       -       -       -       -       -       -       -

//
//      VFreeUniqueList
//
//      Free up the memory associated with a unique name list.
//
//      Side-effects:
//
//      1.      None.

STATIC  VOID NEAR PASCAL VFreeUniqueList(
        LPHANDLE        lphList)
{
        // there was a code generation compiler bug
        // it thought that hPrev and *lphList were synonyms.  Worrying!!
        HANDLE          hPrev;
        HANDLE          hList;
        hList = *lphList;
        *lphList = NULL;
        for (; hList != NULL; ) {
                LPUNIQUEMAP     lpumEntry;

                hPrev = hList;
                lpumEntry = (LPUNIQUEMAP)GlobalLock(hPrev);
                hList = lpumEntry->hNext;
                GlobalUnlock(hPrev);
                GlobalFree(hPrev);
        }
} /* VFreeUniqueList */

//      -       -       -       -       -       -       -       -       -

//      MmaperrChangeUsing
//
//      Change the usage count of a patchmap or keymap.
//
//      Side-effects:
//
//      1.      None.

STATIC  MMAPERR NEAR PASCAL MmaperrChangeUsing(
        UINT    uFlag,
        UINT    uIdx,
        int     iVal)
{
        HANDLE  hTable;
        LPMMTABLEENTRY  lpmmEntry;
        MMPATCH mmPatch;
        MMAPERR mmaperr;
        MMKEY   mmKey;

        if ((mmaperr = MmaperrFileAccess(MAP_FOPEN,
                OF_READWRITE)) != MMAPERR_SUCCESS)
                return mmaperr;
        if ((mmaperr = MmaperrReadTable(uFlag)) != MMAPERR_SUCCESS) {
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        hTable = (uFlag == MMAP_PATCH) ? hPatchTable : hKeyTable;
        lpmmEntry = LpGetTableEntry(hTable,             // No error return
                MAKEID(uIdx));                          //  is possible.
        if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit01:         VFreeTable(uFlag);
                goto exit00;
        }
        switch (uFlag) {
        case MMAP_PATCH:
                if ( _lread(iFile, (LPSTR)&mmPatch, sizeof(MMPATCH))
                   != sizeof(MMPATCH)
                   ) {
                        mmaperr = MMAPERR_READ;
                        goto exit01;
                }
                mmPatch.wUsing += (WORD)iVal;
                if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                        mmaperr = MMAPERR_WRITE;
                        goto exit01;
                }
                if ( _lwrite(iFile, (LPSTR)&mmPatch, sizeof(MMPATCH))
                   != sizeof(MMPATCH)
                   ) {
                        mmaperr = MMAPERR_WRITE;
                        goto exit01;
                }
                break;
        case MMAP_KEY:
                if (_lread(iFile, (LPSTR)&mmKey, sizeof(MMKEY)) != sizeof(MMKEY)) {
                        mmaperr = MMAPERR_READ;
                        goto exit01;
                }
                mmKey.wUsing += (WORD)iVal;
                if (_llseek(iFile, lpmmEntry->doData, 0) == -1L) {
                        mmaperr = MMAPERR_WRITE;
                        goto exit01;
                }
                if (_lwrite(iFile, (LPSTR)&mmKey, sizeof(MMKEY)) != sizeof(MMKEY)) {
                        mmaperr = MMAPERR_WRITE;
                        goto exit01;
                }
                break;
        }
        VFreeTable(uFlag);
        if ((mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0)) != MMAPERR_SUCCESS)
                return mmaperr;
        return MMAPERR_SUCCESS;
} /* MmaperrChangeUsing */

//      -       -       -       -       -       -       -       -       -

//
//      MmaperrReadTable
//
//      Read in table(s) of names/descriptions from the midimap file.
//
//      Returns boolean.
//
//      Side-effects:
//
//      1.      None anymore.

STATIC  MMAPERR NEAR PASCAL MmaperrReadTable(
        UINT    APIn)
{
        MMHEADER        mmHeader;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmEntry;
        LPHANDLE        lpTable;
        MMAPERR mmaperr;
        UINT    oPos;
        UINT    uTableSize;
        UINT    mmap;
        UINT    mmapCompleted;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READ);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        if (_lread(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER)) != sizeof(MMHEADER)) {
                mmaperr = MMAPERR_READ;
                goto exit00;
        }
        mmapCompleted = 0;
        for (mmap = 1; mmap < 5; mmap <<= 1) {
                if (!(APIn & mmap))
                        continue;
                switch (mmap) {
                default:
                        continue;
                case MMAP_SETUP:
                        lpTable = &hSetupTable;
                        oPos = mmHeader.oSetup;
                        break;
                case MMAP_PATCH:
                        lpTable = &hPatchTable;
                        oPos = mmHeader.oPatch;
                        break;
                case MMAP_KEY:
                        lpTable = &hKeyTable;
                        oPos = mmHeader.oKey;
                        break;
                }
                if (*lpTable)
                        lpmmTable = (LPMMTABLE)GlobalLock(*lpTable);
                else {
                        *lpTable = GlobalAlloc(GHND, (DWORD)sizeof(MMTABLE));
                        if (*lpTable == NULL) {
                                mmaperr = MMAPERR_MEMORY;
exit01:                         VFreeTable(mmapCompleted);
                                goto exit00;
                        }
                        lpmmTable = (LPMMTABLE)GlobalLock(*lpTable);
                        if (_llseek(iFile, (LONG)oPos, 0) == -1L) {
                                mmaperr = MMAPERR_READ;
exit02:                         GlobalUnlock(*lpTable);
                                GlobalFree(*lpTable);
                                *lpTable = NULL;
                                goto exit01;
                        }
                        if ( _lread(iFile, (LPSTR)&lpmmTable->mmHeader,sizeof(MMTABLEHEADER))
                           != sizeof(MMTABLEHEADER)
                           ) {
                                mmaperr = MMAPERR_READ;
                                goto exit02;
                        }
                        uTableSize = lpmmTable->mmHeader.wEntrys *
                                sizeof(MMTABLEENTRY);
                        lpmmTable->hEntrys = GlobalAlloc( GHND
                                                        , (DWORD)uTableSize
                                                        );
                        if (lpmmTable->hEntrys == NULL) {
                                mmaperr = MMAPERR_MEMORY;
                                goto exit02;
                        }
                        lpmmEntry = (LPMMTABLEENTRY)GlobalLock(
                                                          lpmmTable->hEntrys);
                        if ( _lread(iFile, (LPSTR)lpmmEntry, uTableSize)
                           != uTableSize
                           ) {
                                mmaperr = MMAPERR_READ;
/*exit03:*/                     GlobalUnlock(lpmmTable->hEntrys);
                                GlobalFree(lpmmTable->hEntrys);
                                goto exit02;
                        }
                        GlobalUnlock(lpmmTable->hEntrys);
                }
                lpmmTable->wCount++;
                GlobalUnlock(*lpTable);
                mmapCompleted |= mmap;
        }
        (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
        return MMAPERR_SUCCESS;
} /* MmaperrReadTable */

//      -       -       -       -       -       -       -       -       -

//
//      VFreeTable
//
//      Free a table (or tables) from memory.
//
//      Side-effects:
//
//      1.      None.

STATIC  VOID NEAR PASCAL VFreeTable(
        UINT    APIn)
{
        LPMMTABLE       lpmmTable;
        LPHANDLE        lpTable;
        UINT    mmap;

        for (mmap = 1; mmap < 5; mmap <<= 1) {
                if (!(APIn & mmap))
                        continue;
                switch (mmap) {
                default:
                        continue;
                case MMAP_SETUP:
                        lpTable = &hSetupTable;
                        break;
                case MMAP_PATCH:
                        lpTable = &hPatchTable;
                        break;
                case MMAP_KEY:
                        lpTable = &hKeyTable;
                        break;
                }
                if (!*lpTable)
                        continue;
                lpmmTable = (LPMMTABLE)GlobalLock(*lpTable);
                if (--lpmmTable->wCount) {
                        GlobalUnlock(*lpTable);
                        continue;
                }
                GlobalFree(lpmmTable->hEntrys);
                GlobalUnlock(*lpTable);
                GlobalFree(*lpTable);
                *lpTable = NULL;
        }
} /* VFreeTable */

//      -       -       -       -       -       -       -       -       -

//
//      LpGetTableEntry
//
//      Given a name or index, return a table entry.  If lpName is NULL, it
//      assumes you have already called this and simply returns whatever
//      happens to be in the local static mmEntry.
//
//      Side-effects:
//
//      1.      None.
//
//      Remarks:
//
//      1.      This can't return an error if "lpName" is NULL, or if the
//              HIWORD of it is zero.

STATIC  LPMMTABLEENTRY NEAR PASCAL LpGetTableEntry(
        HANDLE  hTable,
        LPSTR   lpName         // Name or index
        )
{
        static MMTABLEENTRY mmEntry;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmEntry;
        UINT    wNum        ;
        UINT    wUsed;

        if (lpName == NULL) {
                return &mmEntry;
        }
        lpmmTable = (LPMMTABLE)GlobalLock(hTable);
        lpmmEntry = (LPMMTABLEENTRY)GlobalLock(lpmmTable->hEntrys);
        wNum  = 0;
        if (!HIWORD(lpName)) {
                lpmmEntry += LOWORD ((LONG_PTR)lpName) - 1;
                wUsed = 1;
        } else {
                /* search through storage handled by lpmmTable->hEntrys for lpName */
                /* set wNum to its number and lpmmEntry to the entry               */
                wUsed = lpmmTable->mmHeader.wUsed;
                for (; wNum         < wUsed; lpmmEntry++) {
                        if (!*lpmmEntry->szName) {
                                continue;
                        }

                        if (!lstrcmpi((LPCSTR)(lpmmEntry->szName), lpName))
                                break;
                        wNum++;
                }
        }
        if (wNum < wUsed)
                mmEntry = *lpmmEntry;
        GlobalUnlock(lpmmTable->hEntrys);
        GlobalUnlock(hTable);
        if (wNum == wUsed)
                return NULL;
        return (LPMMTABLEENTRY)&mmEntry;
} /* LpGetTableEntry */

//      -       -       -       -       -       -       -       -       -

/*
 * @doc INTERNAL
 *
 * @api MMAPERR | MmaperrWriteTabEntry | Write a table entry to disk.
 *
 * uIdx may be a table entry index (1 ... n) or it may be zero if
 * you want to use lpmmEntry->idxEntry as the index.
 */

//      Side-effects of failure:
//
//      1.      If the "close" fails something bad has happened to the file.
//
//      Remarks:
//
//      1.      This function used to modify the in-memory table first, then
//              go on to tackle the on-disk entry.  It now does this in
//              reverse order in order to avoid a situation where the
//              in-memory table is changed but the disk representation isn't.

STATIC  MMAPERR NEAR PASCAL MmaperrWriteTabEntry(
        UINT    uFlag,
        UINT    uIdx,
        LPMMTABLEENTRY  lpmmEntry)
{
        HANDLE          hTable;
        LPMMTABLE       lpmmTable;
        LPMMTABLEENTRY  lpmmOldEntry;
        MMHEADER        mmHeader;
        UNALIGNED WORD  *lpoTable;
        MMAPERR mmaperr;

        switch (uFlag) {
        case MMAP_SETUP:
                lpoTable = &mmHeader.oSetup;
                hTable = hSetupTable;
                break;
        case MMAP_PATCH:
                lpoTable = &mmHeader.oPatch;
                hTable = hPatchTable;
                break;
        case MMAP_KEY:
                lpoTable = &mmHeader.oKey;
                hTable = hKeyTable;
                break;
        default:hTable = NULL;   // Kill spurious use before set diag
                lpoTable = NULL; // Kill spurious use before set diag
        }
        if (!uIdx)
                uIdx = lpmmEntry->idxEntry;
        uIdx--;
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
exit01:         return mmaperr;
        }
        if ( _lread(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER))
           != sizeof(MMHEADER)
           ) {
                mmaperr = MMAPERR_READ;
                goto exit00;                            // 00, not 01.
        }
        if (_llseek( iFile
                   , (LONG) ( *lpoTable
                            + sizeof(MMTABLEHEADER)
                            + uIdx * sizeof(MMTABLEENTRY)
                            )
                   , 0
                   ) == -1L
           ) {
                mmaperr = MMAPERR_WRITE;
                goto exit00;                            // 00, not 01.
        }
        if ( _lwrite(iFile, (LPSTR)lpmmEntry, sizeof(MMTABLEENTRY))
           != sizeof(MMTABLEENTRY)
           ) {
                mmaperr = MMAPERR_WRITE;
                goto exit00;                            // 00, not 01.
        }
        mmaperr = MmaperrFileAccess(MAP_FCLOSE, 0);
        if (mmaperr != MMAPERR_SUCCESS)
                goto exit01;
        // if the table is in memory, modify the in-memory table entry
        if (hTable) {
                lpmmTable = (LPMMTABLE)GlobalLock(hTable);
                lpmmOldEntry = (LPMMTABLEENTRY)GlobalLock(lpmmTable->hEntrys);
                lpmmOldEntry += uIdx;
                *lpmmOldEntry = *lpmmEntry;
                GlobalUnlock(lpmmTable->hEntrys);
                GlobalUnlock(hTable);
        }
        return MMAPERR_SUCCESS;
} /* MmaperrWriteTabEntry */

//      -       -       -       -       -       -       -       -       -

//      MmaperrWriteTabHeader
//
//      Write a table header.
//
//      Side-effects of failure:
//
//      1.      If the "close" fails something bad has happened to the file.

STATIC  MMAPERR NEAR PASCAL MmaperrWriteTabHeader(
        UINT    uFlag,
        LPMMTABLEHEADER lpmmHeader)
{
        MMHEADER        mmHeader;
        UNALIGNED WORD  *lpoTable;
        MMAPERR mmaperr;

        switch (uFlag) {
        case MMAP_SETUP:
                lpoTable = &mmHeader.oSetup;
                break;
        case MMAP_PATCH:
                lpoTable = &mmHeader.oPatch;
                break;
        case MMAP_KEY:
                lpoTable = &mmHeader.oKey;
                break;
        default:lpoTable = NULL; // Kill spurious use before set diagnostic
        }
        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        if (_lread(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER)) != sizeof(MMHEADER))
        {
                mmaperr = MMAPERR_READ;
                goto exit00;
        }
        if (_llseek(iFile, (LONG)*lpoTable, 0) == -1L) {
                mmaperr = MMAPERR_WRITE;
                goto exit00;
        }
        if ( _lwrite(iFile, (LPSTR)lpmmHeader, sizeof(MMTABLEHEADER))
           != sizeof(MMTABLEHEADER)
           ) {
                mmaperr = MMAPERR_WRITE;
                goto exit00;
        }
        return MmaperrFileAccess(MAP_FCLOSE, 0);
} /* MmaperrWriteTabHeader */

//      MmaperrGarbage
//
//      Increase the garbage-byte count.
//
//      Side-effects:
//
//      1.      None.

STATIC  MMAPERR NEAR PASCAL MmaperrGarbage(
        UINT    uBytes)
{
        MMHEADER mmHeader;
        MMAPERR mmaperr;

        mmaperr = MmaperrFileAccess(MAP_FOPEN, OF_READWRITE);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_READ;
exit00:         (VOID)MmaperrFileAccess(MAP_FCLOSE, 0);
                return mmaperr;
        }
        if (_lread(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER)) != sizeof(MMHEADER)) {
                mmaperr = MMAPERR_READ;
                goto exit00;
        }
        mmHeader.dwGarbage += uBytes;
        if (_llseek(iFile, 0L, 0) == -1L) {
                mmaperr = MMAPERR_WRITE;
                goto exit00;
        }
        if (_lwrite(iFile, (LPSTR)&mmHeader, sizeof(MMHEADER)) != sizeof(MMHEADER)) {
                mmaperr = MMAPERR_WRITE;
                goto exit00;
        }
        return MmaperrFileAccess(MAP_FCLOSE, 0);
} /* MmaperrGarbage */

//      -       -       -       -       -       -       -       -       -

//
//      MmaperrFileAccess
//
//      Control the global file descriptor.
//
//      Returns TRUE on success, FALSE on error.
//
//      Remarks:
//
//      1.      Opens/closes file potentially.
//      2.      Modifies "iFile".
//      3.      Modifies "ucFileOpen".

MMAPERR NEAR PASCAL MmaperrFileAccess(
        int     iFunc,    /* MAP_FOPEN, MAP_FCREATE or MAP_FCLOSE */
        int     iMode)
{
    OFSTRUCT of;

    if (!fEditing)
    {
        char    szMapCfg[MMAP_MAXCFGNAME];

        GetSystemDirectory(aszMapperPath, sizeof(aszMapperPath));
        LoadString(hLibInst,IDS_MIDIMAPCFG,szMapCfg,MMAP_MAXCFGNAME);
        lstrcat(aszMapperPath, szMapCfg);
    }

    switch (iFunc) {
    case MAP_FOPEN :
        if (iFile != HFILE_ERROR) {
                ucFileOpen++;
                break;
        }
        iFile = OpenFile(aszMapperPath, &of, iMode);
        if (iFile == HFILE_ERROR) {
                if (of.nErrCode == 0x05)
                        return MMAPERR_OPEN_READONLY;
                else
                        return MMAPERR_OPEN;
        }
        ucFileOpen++;
        break;
    case MAP_FCREATE :
        iFile = OpenFile(aszMapperPath, &of,iMode|OF_CREATE|OF_READWRITE);
        if (iFile == HFILE_ERROR)
                return MMAPERR_CREATE;
        ucFileOpen++;
        break;
    case MAP_FCLOSE :
        if (!--ucFileOpen) {
                _lclose(iFile);
                iFile = HFILE_ERROR;
        }
        break;
    }
    return MMAPERR_SUCCESS;
} /* MmaperrFileAccess */

//      -       -       -       -       -       -       -       -       -
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\preclude.h ===
/*
 * MMSYSTEM precludes
 */

#define         MMNOSOUND
#define         MMNOWAVE
#define         MMNOSEQ
#define         MMNOTIMER
#define         MMNOJOY
#define         MMNOMCI
#define         MMNOTASK

/*
 * WINDOWS precludes
*/

#define         NOGDICAPMASKS           //- CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#define         NOVIRTUALKEYCODES       //- VK_*
#define         NOICONS                 //- IDI_*
#define         NOKEYSTATES             //- MK_*
#define         NOSYSCOMMANDS           //- SC_*
#define         NORASTEROPS             //- Binary and Tertiary raster ops
#define         OEMRESOURCE             //- OEM Resource values
//#define               NOATOM                  //- Atom Manager routines
#define         NOCLIPBOARD             //- Clipboard routines
#define         NOMETAFILE              //- typedef METAFILEPICT
//#define               NOOPENFILE              //- OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define         NOSOUND                 //- Sound driver routines
#define         NOWH                    //- SetWindowsHook and WH_*
#define         NOCOMM                  //- COMM driver routines
#define         NOKANJI                 //- Kanji support stuff.
//#define               NOHELP                  //- Help engine interface.
#define         NOPROFILER              //- Profiler interface.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\propbox.c ===
/*
 * PROPBOX.C
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * Dialog box for creating a new map.
 */
/* Revision history:
   March 92 Ported to 16/32 common code by Laurie Griffiths (LaurieGr)
*/

#include "preclude.h"
#include <windows.h>
#include <mmsystem.h>
#if defined(WIN32)
#include <port1632.h>
#endif
#include <string.h>
#include "hack.h"
#include "midimap.h"
#include "cphelp.h"
#include "midi.h"
#include "extern.h"


/* How about a f***ing comment ??? */
static UINT PackString(LPSTR szStr)
{
    UINT i;
    LPSTR lpstrBegin,lpstrPtr;

    // remove leading whitespace

    for (lpstrBegin=lpstrPtr=szStr; ISSPACE(*lpstrPtr) ; lpstrPtr++);

    // move backwards from the end

    for(i = lstrlen(szStr)-1; i > 0 && ISSPACE(szStr[i]);i--);

    if (lpstrPtr > szStr+i )
        return 0;

    szStr[i+1] = '\0';

    // while(*szStr++ = *lpstrPtr++);               // Was coded like this - I wonder why?
    strcpy(szStr, lpstrPtr);

    return lstrlen(lpstrBegin);
}



BOOL FAR PASCAL _loadds PropBox(
        HWND    hdlg,
        UINT    uMessage,
        WPARAM  wParam,
        LPARAM  lParam)
{
        static BOOL     fEnabled;
        DWORD   dwExists;
        int     idName = 0;
        int     idHelp = 0;
        char    szName [24],
                szCaption[80],
                szTextBuf [256],
                szRsrc [256],
                szBuf [MMAP_MAXNAME];

        switch (uMessage)
        {
        case WM_INITDIALOG:
                switch (iMap)
                {
                        case MMAP_SETUP:
                                LoadString(hLibInst, IDS_NEW_SETUP, szCaption, sizeof(szCaption));
                                break;
                        case MMAP_PATCH:
                                LoadString(hLibInst, IDS_NEW_PATCH, szCaption, sizeof(szCaption));
                                break;
                        case MMAP_KEY:
                                LoadString(hLibInst, IDS_NEW_KEY, szCaption, sizeof(szCaption));
                                break;
                }

                SetWindowText(hdlg, szCaption);
#ifdef FSAVEAS
                if (fSaveAs) {
                        SetDlgItemText(hdlg, ID_PROPNAME, szCurrent);
                        SetDlgItemText(hdlg, ID_PROPDESC, szCurDesc);
                        fEnabled = TRUE;
                } else
#endif
                        EnableWindow(GetDlgItem(hdlg, IDOK), FALSE);

                SendDlgItemMessage(hdlg, ID_PROPNAME, EM_LIMITTEXT,
                        (WPARAM)(MMAP_MAXNAME - 1), (LPARAM)0);
                SendDlgItemMessage(hdlg, ID_PROPDESC, EM_LIMITTEXT,
                        (WPARAM)(MMAP_MAXDESC - 1), (LPARAM)0);
                fEnabled = FALSE;
                break;
        case WM_COMMAND:
                switch (LOWORD(wParam)) {
                case  IDH_DLG_MIDI_NEW:
                  goto DoHelp;

                case IDOK:
                        GetDlgItemText(hdlg, ID_PROPNAME, szBuf,
                                MMAP_MAXNAME);
            if (PackString(szBuf) == 0)
                return FALSE;
                       //fSaveAs is never set
//!!                    if (/* !fSaveAs || */ lstrcmpi(szBuf, szCurrent)) {
                                dwExists = mapExists(iMap, szBuf);
                                if (LOWORD(dwExists) != MMAPERR_SUCCESS) {
                                        VShowError(hdlg, LOWORD(dwExists));
                                        EndDialog(hdlg, FALSE);
                                        return TRUE;
                                }
                                if (HIWORD(dwExists)) {
                                        switch (iMap)
                                        {
                                                case MMAP_SETUP:
                                                        idName = IDS_SETUP;
                                                        break;
                                                case MMAP_PATCH:
                                                        idName = IDS_PATCH;
                                                        break;
                                                case MMAP_KEY:
                                                        idName = IDS_KEY;
                                                        break;
                                        }
                                        LoadString(hLibInst, idName, szName,
                                                sizeof(szName));
//                                      AnsiUpperBuff(szName, 1);
                                        LoadString(hLibInst, IDS_DUPLICATE,
                                                szRsrc, sizeof(szRsrc));
                                        wsprintf(szTextBuf, szRsrc, (LPSTR)
                                                szName);
                                        if (IDNO == MessageBox(hdlg,
                                                        szTextBuf, szBuf,
                                                        MB_YESNO |
                                                        MB_ICONEXCLAMATION))
                                                break;
                                        fNew = FALSE;
                                }
                                lstrcpy(szCurrent, szBuf);
//!!                    }
                        GetDlgItemText(hdlg, ID_PROPDESC, szCurDesc,
                                MMAP_MAXDESC);
                        EndDialog(hdlg, TRUE);
                        break;
                case IDCANCEL:
                        EndDialog(hdlg, FALSE);
                        break;
                case ID_PROPNAME:
                        if (!GetDlgItemText(hdlg, ID_PROPNAME, szBuf,
                              MMAP_MAXNAME))
                        {
                                if (fEnabled)
                                {
                                        EnableWindow(GetDlgItem(hdlg, IDOK),
                                                FALSE);
                                        fEnabled = FALSE;
                                }
                        } else
                                if (!fEnabled)
                                {
                                  EnableWindow(GetDlgItem(hdlg, IDOK), TRUE);
                                  fEnabled = TRUE;
                                }
                        break;
                default:
                        return FALSE;
                }
                break;
        default:
                if (uMessage == uHelpMessage)
                {
DoHelp:
                   switch (iMap)
                   {
                        case MMAP_SETUP:
                                idHelp = IDH_DLG_MIDI_SETUPNEW;
                                break;
                        case MMAP_PATCH:
                                idHelp = IDH_DLG_MIDI_PATCHNEW;
                                break;
                        case MMAP_KEY:
                                idHelp = IDH_DLG_MIDI_KEYNEW;
                                break;
                   }
                   WinHelp(hWnd, szMidiHlp, HELP_CONTEXT, idHelp);
                   return TRUE;
                }
                else
                         return FALSE;
                break;
        }
        return TRUE;
} /* PropBox */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\setup.c ===
/*
 * SETUP.C
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * Edit setups dialog box and support functions.
 */
/* Revision history:
   March 92 Ported to 16/32 common code by Laurie Griffiths (LaurieGr)
*/

#include "preclude.h"
#include <windows.h>
#include <string.h>
#include <mmsystem.h>
#include <port1632.h>
#include "hack.h"
#include "midimap.h"
#include "midi.h"
#include <cphelp.h>
#include "extern.h"
#include "stdio.h"
#include "stdarg.h"

#if defined(WIN32)
#define _based(x)
#endif //WIN32

BOOL FAR PASCAL _loadds FSetupEnumPortsFunc(LPSTR, LPSTR, UINT, HWND, LPSTR);

#define PAL_SHOW                0       // show active line
#define PAL_HIDE                1       // hide active line

#define PSF_REDRAW              0x0001  // redraw where line used to be
#define PSF_SHOWIFHIDDEN        0x0002  // show line if hidden

#define BTN3S_UNCHECK           0       // uncheck a 3-state button
#define BTN3S_CHECK             1       // check a 3-state button
#define BTN3S_GRAY              2       // gray a 3-state button

#define DEF_SETUP_ROWS          16      // number of default setup rows

static HGLOBAL  hSetup;                 // Setup handle
static HWND     hPortList,              // invalid port list box ctrl handle
                hPortCombo,             // port combo-box ctrl handle
                hPatchCombo;            // patch combo-box ctrl handle
static UINT     nPorts;                 // number of ports available
static int      nPatches,               // number of user-defined patchmaps
                iOldPos,                // old position of active edit line
                xArrowOffset;           // arrow control positional offset
static  SZCODE aszNull[] = "";
static  SZCODE aszSetupNumFormat[] = "%3d";

#if DBG
void FAR cdecl dprintf(LPSTR szFormat, ...)
{

    char ach[128];
   va_list va;
    int  s,d;

   va_start(va, szFormat);
    s = vsprintf (ach, szFormat, va);
    va_end(va);
#if 0
    lstrcat(ach,"\n");
    s++;
#endif
    for (d=sizeof(ach)-1; s>=0; s--)
    {
        if ((ach[d--] = ach[s]) == '\n')
            ach[d--] = '\r';
    }

    OutputDebugString("MIDI: ");
    OutputDebugString(ach+d+1);
}
#else
#define dprintf  if (0) ((int (*)(char *, ...)) 0)
#endif //DBG

static  BOOL NEAR PASCAL FHasInvalidPort(
        void)
{
        SETUP FAR* lpSetup;
        WORD    wNumDevs;
        int     i;

        wNumDevs = (WORD)midiOutGetNumDevs();
        // dprintf("numDevs = %d\n", wNumDevs);
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        for (i = 0; i < 16; i++)
        {   // dprintf("device id[%d]=%d\n",i,lpSetup->channels[i].wDeviceID);
            if ((lpSetup->channels[i].wDeviceID != LOWORD(MIDI_MAPPER)) &&
                (lpSetup->channels[i].wDeviceID >= wNumDevs))
                break;
        }

        GlobalUnlock(hSetup);
        return (i < 16);
} /* FHasInvalidPort */

static  int PASCAL ISetupSave(
        HWND    hdlg,
        BOOL    bQuery)
{
        SETUP FAR* lpSetup;
        MMAPERR mmaperr;
        int     iRet = 0;           // choose a value not IDCANCEL or IDYES

        if (bQuery)
                if ((iRet = QuerySave()) != IDYES)
                        return iRet;
        if (FHasInvalidPort())
                if (!InvalidPortMsgBox(hdlg))
                        return IDCANCEL;
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        mmaperr = mapWrite(MMAP_SETUP, lpSetup);
        GlobalUnlock(hSetup);
        if (mmaperr != MMAPERR_SUCCESS) {
                VShowError(hdlg, mmaperr);
                return IDCANCEL;
        }
        Modify(FALSE);
        if (fNew)
                fNew = FALSE;
        return iRet;
} /* ISetupSave */

/*
 * VSetupEditMsg
 *
 * This function deals with EN_UPDATE and EN_ACTIVATE messages sent
 * to the channel number edit control through the WM_COMMAND message.
 */

static  void PASCAL VSetupEditMsg(
        HWND    hdlg,
        WORD    NotifCode)
{
        SETUP FAR*      lpSetup;
        int     i;
        LPWORD  lpwChan;
        WORD    wChan;
        BOOL    bTranslate;

        switch (NotifCode) {
        case EN_UPDATE:
                lpSetup = (SETUP FAR*)GlobalLock(hSetup);
                lpwChan = &lpSetup->channels[iVertPos + iCurPos].wChannel;
                i = GetDlgItemInt(hdlg, ID_SETUPEDIT, &bTranslate, FALSE);
                if (i > 0 && i <= 16) {
                        if (*lpwChan != (BYTE)(i - 1)) {
                                *lpwChan = (BYTE)(i - 1);
                                Modify(TRUE);
                        }
                } else {
                        char    aszMessage[256];
                        char    aszTitle[32];

                        // may want to experiment with EM_UNDO here.
                        LoadString(hLibInst, IDS_INVALIDDESTINATION, aszMessage, sizeof(aszMessage));
                        LoadString(hLibInst, IDS_USERERROR, aszTitle, sizeof(aszTitle));
                        MessageBox(hdlg, aszMessage, aszTitle, MB_ICONEXCLAMATION | MB_OK);
                        SetDlgItemInt(hdlg, ID_SETUPEDIT,
                                *lpwChan + 1, FALSE);
                }
                GlobalUnlock(hSetup);
                break;
        case EN_ACTIVATE:
                lpSetup = (SETUP FAR*)GlobalLock(hSetup);
                wChan = lpSetup->channels[iVertPos + iCurPos].wChannel;
                GlobalUnlock(hSetup);
                SetDlgItemInt(hdlg, ID_SETUPEDIT, wChan + 1, FALSE);
                break;
        }
} /* VSetupEditMsg */

/*
 * VSetupActiveChan
 *
 * This function controls the checked/unchecked/grayed state of the 'Active'
 * button for a specific channel.  If the function is being grayed, it will
 * be disabled as well.
 */

static  void NEAR PASCAL VSetupActiveChan(
        int     iPos,
        LPDWORD lpdwFlags,
        UINT    uCheck)
{
        HWND    hCheck;
        BOOL    fEnable;

        if (lpdwFlags)
                if (uCheck == BTN3S_CHECK)
                        *lpdwFlags |= MMAP_ACTIVE;
                else
                        *lpdwFlags &= ~MMAP_ACTIVE;
        hCheck = GetDlgItem(hWnd, ID_SETUPCHECK + iPos);
        if ((UINT)SendMessage(hCheck, BM_GETCHECK, (WPARAM)0, (LPARAM)0) != uCheck)
                SendMessage(hCheck, BM_SETCHECK, (WPARAM)uCheck, (LPARAM)0);
        fEnable = (uCheck != BTN3S_GRAY);
        if (fEnable != IsWindowEnabled(hCheck))
                EnableWindow(hCheck, fEnable);
} /* VSetupActiveChan */

/*
 * VSetupComboMsg
 *
 * This function deals with the CBN_ACTIVATE and CBN_SELCHANGE messages sent
 * to the port or patch combo boxes through the WM_COMMAND message.
 */

static  void NEAR PASCAL VSetupComboMsg(
        HWND    hdlg,
        UINT    id,
        WORD    NotifCode)
{
        HWND    hCombo = GetDlgItem(hdlg, id);
        SETUP FAR* lpSetup;
        CHANNEL FAR* lpChannel;
        UINT    uIdx;
        char    szBuf[MAXPNAMELEN];

        if (NotifCode != CBN_ACTIVATE && NotifCode != CBN_SELCHANGE)
                return;
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        lpChannel = &lpSetup->channels[iVertPos + iCurPos];
        switch (NotifCode) {
        case CBN_ACTIVATE:
                uIdx = MMAP_ID_NOPORT;
                // if its a port combo box message
                if (id == ID_SETUPPORTCOMBO)
                        if (lpChannel->wDeviceID != MMAP_ID_NOPORT)
                                uIdx = lpChannel->wDeviceID;
                        else
                                uIdx = nPorts;
                // otherwise its a patch combo box message
                else if (lpChannel->dFlags & MMAP_PATCHMAP)
                        uIdx = ComboLookup(hCombo, lpChannel->aszPatchName);
                else
                        uIdx = nPatches;
                SendMessage(hCombo, CB_SETCURSEL, (WPARAM)uIdx, (LPARAM)0);
                break;
        case CBN_SELCHANGE:
                GetWindowText(hCombo, szBuf, MAXPNAMELEN);
                // if we're dealing with a port combo message
                if (id == ID_SETUPPORTCOMBO) {
                        // get the index of the newly selected port
                        uIdx = (UINT)SendMessage(hCombo,
                                CB_GETCURSEL, (WPARAM)NULL, (LPARAM)0);
                        // if it's the same as old index, we don't care
                        if (uIdx == lpChannel->wDeviceID)
                                break;
                        // if it's the last port index, it's the[none] entry
                        if (uIdx == (UINT)nPorts) {
                                // set id to bogus port value
                                lpChannel->wDeviceID = MMAP_ID_NOPORT;
                                // deactivate the channel
                                VSetupActiveChan(iCurPos, &lpChannel->dFlags,
                                        BTN3S_GRAY);
                        } else {
                                // ok so it's not the[none] entry
                                // if it used to be[none], activate channel
                                if (lpChannel->wDeviceID == MMAP_ID_NOPORT)
                                        VSetupActiveChan(iCurPos,
                                                &lpChannel->dFlags,
                                                BTN3S_CHECK);
                                // set the id to the new index
                                lpChannel->wDeviceID = (WORD)uIdx;
                        }
                        Modify(TRUE);
                } else {
                        if (!lstrcmpi(szBuf, lpChannel->aszPatchName))
                                break;
                        lstrcpy(lpChannel->aszPatchName, szBuf);
                        if (!lstrcmpi(szBuf, szNone))
                                lpChannel->dFlags &= ~MMAP_PATCHMAP;
                        else
                                lpChannel->dFlags |= MMAP_PATCHMAP;
                        Modify(TRUE);
                }
                break;
        }
        GlobalUnlock(hSetup);
} /* VSetupComboMsg */

static  void NEAR PASCAL VSetupActiveLine(
        UINT    uCase,
        UINT    uFlags)
{
        static const UINT uDefFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER;

        switch (uCase) {
        case PAL_SHOW:
                if (!fHidden)
                        return;
                uFlags |= SWP_SHOWWINDOW;
                fHidden = FALSE;
                break;
        case PAL_HIDE:
                if (fHidden)
                        return;
                uFlags |= SWP_HIDEWINDOW;
                fHidden = TRUE;
                break;
        }
        uFlags |= uDefFlags;
        SetWindowPos(hEdit, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hArrow, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hPortCombo, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hPatchCombo, NULL, 0L, 0L, 0L, 0L, uFlags);
        if (uCase == PAL_SHOW)
                SetFocus(hEdit);
} /* VSetupActiveLine */

static  void NEAR PASCAL VSetupSetFocus(
        HWND    hdlg,
        UINT    uFlags,
        int     xPos)
{
        HWND    hOldCheck;
        HWND    hNewCheck;
        RECT    rc;
        DWORD   dwFlags;
        int     yPos = rcBox.top + iCurPos * yChar;

        // change tabstop flag on new checkbox
        hNewCheck = GetDlgItem(hdlg, ID_SETUPCHECK + iCurPos);
        dwFlags = (DWORD)GetWindowLong(hNewCheck, GWL_STYLE);
        dwFlags |= WS_TABSTOP;
        SetWindowLong(hNewCheck, GWL_STYLE, dwFlags);
        // set mnemonic on new window
        SetWindowText(hNewCheck, aszSourceMnumonic);
        // take the tabstop away from the old checkbox if it exists
        if (iOldPos > -1) {
                hOldCheck = GetDlgItem(hdlg, ID_SETUPCHECK + iOldPos);
                dwFlags = (DWORD)GetWindowLong(hOldCheck, GWL_STYLE);
                dwFlags &= ~(DWORD)WS_TABSTOP;
                SetWindowLong(hOldCheck, GWL_STYLE, dwFlags);
                // take away mnemonic from old window
                SetWindowText(hOldCheck, aszNull);
        }
        iOldPos = iCurPos;
        GetWindowRect(hEdit, &rc);
        SetWindowPos(hEdit, NULL, rgxPos[1], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);
        VSetupEditMsg(hdlg, EN_ACTIVATE);
//      UpdateWindow(hEdit);
        SetWindowPos(hArrow, NULL, rgxPos[1] + xArrowOffset, yPos, 0L,
                0L, SWP_NOZORDER | SWP_NOSIZE);
        SetWindowPos(hPortCombo, NULL, rgxPos[2], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);
        VSetupComboMsg(hdlg, ID_SETUPPORTCOMBO, CBN_ACTIVATE);
        SetWindowPos(hPatchCombo, NULL, rgxPos[3], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);
        VSetupComboMsg(hdlg, ID_SETUPPATCHCOMBO, CBN_ACTIVATE);
        if ((fHidden) && (uFlags & PSF_SHOWIFHIDDEN)) {
                VSetupActiveLine(PAL_SHOW, 0L);
                UpdateWindow(hArrow);
                UpdateWindow(hPortCombo);
                UpdateWindow(hPatchCombo);
        }
//      ValidateRect(hdlg, NULL);
        if (uFlags & PSF_REDRAW && rc.right) {
                ScreenToClient(hdlg, (LPPOINT)&rc);
                ScreenToClient(hdlg, (LPPOINT)&rc + 1);
                rc.right = rcBox.right + 1;
                InvalidateRect(hdlg, &rc, FALSE);
                UpdateWindow(hdlg);
        }
        if (!xPos)
                return;
        if (xPos < rgxPos[2]) {
                SetFocus(hEdit);
#if defined(WIN16)
                SendMessage(hEdit, EM_SETSEL, (WPARAM)NULL, MAKELPARAM(0, 32767));
#else
                SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
#endif //WIN16
        } else if (xPos < rgxPos[3])
                SetFocus(hPortCombo);
        else if (xPos < rgxPos[4])
                SetFocus(hPatchCombo);
} /* VSetupSetFocus */

/*
 * VSetupSize
 */
static
void PASCAL VSetupSize(
        HWND    hdlg,
        BOOL    fMaximize)
{
        RECT    rcOK;
        RECT    rc3S;
        RECT    rcWnd;
        LONG    lDBU;
        UINT    xBU;
        UINT    yBU;
        int     xButton;
        int     xCenter;
        int     yTopMar;
        int     yBotMar;
        int     yLeftOver;
        int     yMiniBotMar;
        int     i;

        lDBU = GetDialogBaseUnits();
        xBU = LOWORD(lDBU);
        yBU = HIWORD(lDBU);
        // get the rectangle of the OK button
        GetClientRect(GetDlgItem(hdlg, IDOK), &rcOK);
        // get x-extent of button
        xButton = rcOK.right - rcOK.left;
        // top margin is 2 characters
        yTopMar = (16 * yBU) / 8 - 6; // cookie land
        // bottom margin is 2 * minimum bottom margin dialog units +
        // height of button in pixels
        yBotMar = (VERTMARGIN * 2 *yBU) / 8 + rcOK.bottom - rcOK.top;
        if (fMaximize) {
                // get the rectangle of a 3-state button
                GetClientRect(GetDlgItem(hdlg, ID_SETUPCHECK), &rc3S);
                SetWindowPos(hdlg, NULL, 0L, 0L,
                        rcBox.right - rcBox.left +
                        (rc3S.right - rc3S.left) +
                        (HORZMARGIN * 3 * xBU) / 4 +
                        (GetSystemMetrics(SM_CXDLGFRAME) + 1) * 2,
                        (DEF_SETUP_ROWS * 10 * yBU) / 8 +
                        yTopMar + yBotMar +
                        GetSystemMetrics(SM_CYCAPTION) +
                        (GetSystemMetrics(SM_CYDLGFRAME) + 1) * 2,
                        SWP_NOZORDER | SWP_NOMOVE);
        }
        // get the x and y extents of the client rectangle
        GetClientRect(hdlg, &rcWnd);
        xClient = rcWnd.right - rcWnd.left;
        yClient = rcWnd.bottom - rcWnd.top;
        // yChar is the height of one row in pixels - 1
        yChar = (10 * yBU) / 8 - 1;
        // xChar is the average width of a character
        xChar = xBU;
        // yBox is the room we actually have to display setup rows
        yBox = yClient - yTopMar - yBotMar;
        // nLines is the number of setup rows we can display
        nLines = min(16, yBox / yChar);
        // yLeftOver is how many pixels are left over
        yLeftOver = yBox - nLines * yChar;
        // add half the leftovers to the top margin
        yTopMar += yLeftOver / 2;
        // calculate scroll bar maximum and position
        iVertMax = max(0, 16 - nLines);
        iVertPos = min(iVertMax, iVertPos);
        // rcBox is the box of rows and columns inside the client area
        SetRect(&rcBox,
                rcBox.left,
                yTopMar,
                rcBox.right,
                yTopMar + nLines * yChar);
        // xCenter is used to center the OK and CANCEL buttons horizontally
        xCenter = (rcBox.right - rcBox.left - xButton * 3) / 4;
        // yMiniBotMar is the spacing above and below the button
        yMiniBotMar = (VERTMARGIN * yBU) / 8 + yLeftOver / 4;
        SetWindowPos(GetDlgItem(hdlg, IDOK), NULL, rcBox.left + xCenter,
                rcBox.bottom + yMiniBotMar, 0L, 0L,
                SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(GetDlgItem(hdlg, IDCANCEL), NULL,
                rcBox.left + xButton + xCenter * 2,
                rcBox.bottom + yMiniBotMar, 0L, 0L,
                SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(GetDlgItem(hdlg, IDH_DLG_MIDI_SETUPEDIT), NULL,
                rcBox.left + xButton * 2 + xCenter * 3,
                rcBox.bottom + yMiniBotMar, 0L, 0L,
                SWP_NOSIZE | SWP_NOZORDER);
        // this loop could be optimized
        // then again, so could the u.s. judicial system
        for (i = 0; i < 16; i++, yTopMar += yChar) {
                HWND    hCheck;

                hCheck = GetDlgItem(hdlg, ID_SETUPCHECK + i);
                if (i < nLines) {
                        SetWindowPos(hCheck, NULL,
                                rcBox.right + (HORZMARGIN * xBU) / 4,
                                yTopMar + 3, 0L, 0L,
                                SWP_NOSIZE | SWP_NOZORDER);
                        ShowWindow(hCheck, SW_SHOWNORMAL);
                } else
                        ShowWindow(hCheck, SW_HIDE);
        }
        if (iCurPos >= 0 && iCurPos < nLines)
                VSetupSetFocus(hdlg, PSF_SHOWIFHIDDEN, 1);
        else
                VSetupActiveLine(PAL_HIDE, SWP_NOREDRAW);
} /* VSetupSize */

static  MMAPERR PASCAL MmaperrInitNew(void)
{
        SETUP FAR*      lpSetup;
        WORD     wChan;

        if ((hSetup = GlobalAlloc(GHND, (DWORD)sizeof(SETUP))) == NULL)
                return MMAPERR_MEMORY;
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        lstrcpy(lpSetup->aszSetupName, szCurrent);
        lstrcpy(lpSetup->aszSetupDescription, szCurDesc);
        for (wChan = 0; wChan < 16; wChan++) {
                lpSetup->channels[wChan].wChannel = wChan;
                lpSetup->channels[wChan].wDeviceID = MMAP_ID_NOPORT;
                lstrcpy(lpSetup->channels[wChan].aszPatchName, szNone);
        }
        GlobalUnlock(hSetup);
        return MMAPERR_SUCCESS;
} /* MmaperrInitNew */

/*
 * VSetupEnumPorts
 *
 * Enumerate available port names and throw them in a combo box.
 */

static  void PASCAL VSetupEnumPorts(
        void)
{
        MIDIOUTCAPS moCaps;
        UINT     i;

        nPorts = midiOutGetNumDevs();
        for (i = 0; i < nPorts; i++) {
                midiOutGetDevCaps(i, &moCaps, sizeof(MIDIOUTCAPS));
                SendMessage(hPortCombo, CB_ADDSTRING, (WPARAM)NULL,
                        (LPARAM)(LPSTR)moCaps.szPname);
        }
} /* VSetupEnumPorts */

/*
 * MmaperrEnumPatches
 *
 * This function calls mapEnumerate to enumerate all the user-defined
 * patchmaps into a combo box.
 */
static  MMAPERR NEAR PASCAL MmaperrEnumPatches(void)
{
        MMAPERR mmaperr;

        mmaperr = mapEnumerate(MMAP_PATCH, EnumFunc, MMENUM_BASIC, hPatchCombo, NULL);
        if (mmaperr != MMAPERR_SUCCESS)
                return mmaperr;
        nPatches = (int)(LONG)SendMessage(hPatchCombo, CB_GETCOUNT, (WPARAM)NULL, (LPARAM)0);
        SendMessage(hPatchCombo, CB_ADDSTRING, (WPARAM)NULL, (LPARAM)(LPSTR)szNone);
        return MMAPERR_SUCCESS;
} /* MmaperrEnumPatches */

static  BOOL NEAR PASCAL FInitSetup(
        HWND    hdlg)
{
        SETUP FAR* lpSetup;
        LONG    lDBU;
        UINT    xBU;
        UINT    yBU;
        UINT    xWidth; // width of current column
        UINT    xEdit;  // width of edit controls
        UINT    yEdit;  // height of edit/arrow controls
        UINT    xCombo; // width of combo boxes
        UINT    yCombo; // height of combo boxes
        UINT    wCheck;
        char    szCaption[80];
        char    szCaptionFormat[80];
        MMAPERR mmaperr;
        int     i;

        if (!fNew) {
                if ((hSetup = GlobalAlloc(GHND, sizeof(SETUP))) == NULL) {
                        mmaperr = MMAPERR_MEMORY;
exit00:                 VShowError(hdlg, mmaperr);
                        return FALSE;
                }
        } else if ((mmaperr = MmaperrInitNew()) != MMAPERR_SUCCESS)
                goto exit00;
        fHidden = FALSE;
        iVertPos = 0;
        iCurPos = 0;
        nLines = 0; // necessary?
        nPatches = 0;
        nPorts = 0;
        hPortList = GetDlgItem(hdlg, ID_SETUPPORTLIST);
        hEdit = GetDlgItem(hdlg, ID_SETUPEDIT);
        hArrow = GetDlgItem(hdlg, ID_SETUPARROW);
        hPortCombo = GetDlgItem(hdlg, ID_SETUPPORTCOMBO);
        hPatchCombo = GetDlgItem(hdlg, ID_SETUPPATCHCOMBO);
        if (fReadOnly)
        {
                EnableWindow(GetDlgItem(hdlg,IDOK),FALSE);
                SendMessage(hdlg, DM_SETDEFID, (WPARAM)IDCANCEL, (LPARAM)0);
        }
        lDBU = GetDialogBaseUnits();
        xBU = LOWORD(lDBU);
        yBU = HIWORD(lDBU);
        xEdit = (40 * xBU) / 4;         // 10 chars wide
        yEdit = (10 * yBU) / 8;         // 10 is a magic cookie
        xCombo = (64 * xBU) / 4;        // 16 characters long
        yCombo = (46 * yBU) / 8;        // 46 is a magic cookie
        rcBox.left = (HORZMARGIN * xBU) / 4;
        rcBox.right = rcBox.left;
        rgxPos[0] = rcBox.right;
        rcBox.right += xEdit;
        rgxPos[1] = rcBox.right;
        xWidth = xEdit;
        SetWindowPos(hEdit, NULL, 0L, 0L, xWidth, yEdit,
                SWP_NOZORDER | SWP_NOMOVE);
        // set global arrow control offset to proper position
        rcBox.right += xArrowOffset = xWidth - 1;
        // width of dst channel arrow control
        xWidth = (10 * xBU) / 4;
        SetWindowPos(hArrow, NULL, 0L, 0L, xWidth, yEdit,
                SWP_NOZORDER | SWP_NOMOVE);
        rcBox.right += xWidth - 1;
        rgxPos[2] = rcBox.right;
        xWidth = (80 * xBU) / 4;        // 20 characters long
        SetWindowPos(hPortCombo, NULL, 0L, 0L, xWidth,
                yCombo, SWP_NOZORDER | SWP_NOMOVE);
        rcBox.right += xWidth - 1;
        rgxPos[3] = rcBox.right;
        xWidth = xCombo;
        SetWindowPos(hPatchCombo, NULL, 0L, 0L, xWidth,
                yCombo, SWP_NOZORDER | SWP_NOMOVE);
        rcBox.right += xWidth - 1;
        rgxPos[4] = rcBox.right;
        if (!nPorts)
                VSetupEnumPorts();
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        if (!nPatches)
                if ((mmaperr = MmaperrEnumPatches()) != MMAPERR_SUCCESS) {
exit01:                 GlobalUnlock(hSetup);
                        GlobalFree(hSetup);
                        goto exit00;
                }
        if (!fNew) {
                mmaperr = mapReadSetup(szCurrent, lpSetup);
                if (mmaperr == MMAPERR_INVALIDPORT) {
                        if (!InvalidPortMsgBox(hdlg)) {
                                GlobalUnlock(hSetup);
                                GlobalFree(hSetup);
                                return FALSE;
                        }
                        mmaperr = mapEnumerate( MMAP_PORTS
                                              , FSetupEnumPortsFunc
                                              , MMENUM_BASIC
                                              , NULL
                                              , (LPSTR)szCurrent
                                              );
                }
                if (mmaperr != MMAPERR_SUCCESS){
                        goto exit01;
                }
                if (lstrcmp(lpSetup->aszSetupDescription, szCurDesc)) {
                        lstrcpy(lpSetup->aszSetupDescription, szCurDesc);
                        fNew = TRUE;
                }
        }
        SendMessage(hPortCombo, CB_ADDSTRING, (WPARAM)NULL, (LPARAM)(LPSTR)szNone);
        for (i = 0; i < 16; i++) {
                // check a 3-state button if the channel is active, or gray
                // it if the channel is not mapped to a port
                if (lpSetup->channels[i].wDeviceID == MMAP_ID_NOPORT)
                        wCheck = BTN3S_GRAY;
                else if (lpSetup->channels[i].dFlags & MMAP_ACTIVE)
                        wCheck = BTN3S_CHECK;
                else
                        continue;
                VSetupActiveChan(i, 0L, wCheck);
        }
        GlobalUnlock(hSetup);

        LoadString(hLibInst, IDS_SETUPS ,szCaptionFormat, sizeof(szCaptionFormat));
        wsprintf(szCaption, szCaptionFormat, (LPSTR)szCurrent);
        SetWindowText(hWnd, szCaption);

        SendMessage(GetDlgItem(hdlg, ID_SETUPDESTMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        SendMessage(GetDlgItem(hdlg, ID_SETUPPORTMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        SendMessage(GetDlgItem(hdlg, ID_SETUPPATCHMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        VSetupSize(hdlg, TRUE);
        SetWindowPos(GetDlgItem(hdlg, ID_SETUPDESTMNEM), NULL,
                rgxPos[1], yChar, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(GetDlgItem(hdlg, ID_SETUPPORTMNEM), NULL,
                rgxPos[2], yChar, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(GetDlgItem(hdlg, ID_SETUPPATCHMNEM), NULL,
                rgxPos[3], yChar, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
        Modify(fNew);
        return TRUE;
} /* FInitSetup */

static  void PASCAL VSetupButtonDown(
        HWND    hdlg,
        LONG    lParam)
{
        int     x = LOWORD(lParam);
        int     y = HIWORD(lParam);
        int     iPos;
        UINT    uFlags;

        if (x < rcBox.left || x > rcBox.right)
                return;
        if (y < rcBox.top || y > rcBox.bottom)
                return;
        if ((iPos = min(nLines - 1, (y - rcBox.top) / yChar)) == iCurPos)
                return;
        if (iCurPos >= 0 && iCurPos < nLines) {
                uFlags = PSF_REDRAW;
                SendMessage(hPortCombo, CB_SHOWDROPDOWN, (WPARAM)FALSE, (LPARAM)0);
                SendMessage(hPatchCombo, CB_SHOWDROPDOWN, (WPARAM)FALSE, (LPARAM)0);
                UpdateWindow(hdlg);
        } else
                uFlags = PSF_SHOWIFHIDDEN;
        iCurPos = iPos;
        VSetupSetFocus(hdlg, uFlags, x);
} /* VSetupButtonDown */

static  void PASCAL VSetupPaint(
        HWND    hdlg)
{
        HPEN            hPen;    // previous pen to restore
        SETUP FAR*      lpSetup;
        CHANNEL FAR*    lpChannel;
        PAINTSTRUCT     ps;      // from BeginPaint
        RECT    rcText;
        UINT    uDev;
        int     i;      // loop counter
        int     iVert;
        int     nBegin;    // first row to repaint
        int     nEnd;      // last row to repaint
        int     iLeft;     // left of invalid area
        int     iTop;      // top of invalid area
        int     iBottom;   // bottom of invalid area
        char    szBuf[MAXPNAMELEN];
   // uses GLOBAL hFont - Lord knows why.
   // uses GLOBAL rcBox = clipping rectangle???

        BeginPaint(hdlg, &ps);
        if (!ps.rcPaint.bottom) {    // bottom==0 => area must be empty
exit00:         EndPaint(hdlg, &ps);
                return;
        }
        hPen = SelectObject(ps.hdc, GetStockObject(BLACK_PEN));
        hFont = SelectObject(ps.hdc, hFont);
        SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkMode(ps.hdc, TRANSPARENT);
        if (ps.rcPaint.top < rcBox.top) { // need to paint top headings?
                iVert = yChar;
                TextOut(ps.hdc, 11, iVert, aszSourceChannel, lstrlen(aszSourceChannel));
                SetRect(&rcText, rcBox.right + 2, yChar, 0, 0);
                DrawText(ps.hdc, aszActive, -1, &rcText,
                        DT_LEFT | DT_NOCLIP);
        }
        // calculate top and bottom y coordinates of invalid area
        iTop = max(ps.rcPaint.top, rcBox.top);
        // if top is below the box, forget about painting
        if (iTop > rcBox.bottom) {
exit01:         hFont = SelectObject(ps.hdc, hFont);   // restore
                hPen = SelectObject(ps.hdc, hPen);     // restore
                goto exit00;
        }
        iBottom = min(ps.rcPaint.bottom, rcBox.bottom);
        // calculate left x coordinate of invalid area
        iLeft = max(ps.rcPaint.left, rcBox.left);
        // calculate beginning and ending data row to be repainted
        nBegin = max(0, (iTop - rcBox.top) / yChar);
        nEnd = min(nLines, (iBottom - rcBox.top) / yChar);
        // draw vertical lines of the box
        for (i = 0; i < 5; i++) {
                MMoveTo(ps.hdc, rgxPos[i], iTop);
                LineTo(ps.hdc, rgxPos[i], iBottom + 1);
        }
        // vertical position of first line we have to draw
        iVert = rcBox.top + nBegin * yChar;
        // lock the map
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        // set up an optimization pointer
        lpChannel = &lpSetup->channels[iVertPos + nBegin];
        for (i = nBegin; i <= nEnd; i++, iVert += yChar, lpChannel++) {
                MMoveTo(ps.hdc, iLeft, iVert);
                LineTo(ps.hdc, rcBox.right, iVert);
                if (i == nLines)
                        break;
                if (iLeft < rgxPos[1]) {
                        wsprintf(szBuf, aszSetupNumFormat, iVertPos + i + 1);
                        TextOut(ps.hdc, rgxPos[0] + xChar, iVert + 2,
                                szBuf, 3);
                }
                if (iLeft < rgxPos[2]) {
                        wsprintf(szBuf, aszSetupNumFormat, lpChannel->wChannel + 1);
                        TextOut(ps.hdc, rgxPos[1] + 2 * xChar, iVert + 2,
                                szBuf, 3);
                }
                if (i == iCurPos)
                        continue;
                if (iLeft < rgxPos[3]) {
                        *szBuf = 0;
                        uDev = lpChannel->wDeviceID;
                        if (uDev == MMAP_ID_NOPORT)
                                uDev = nPorts;
                        if (uDev <= nPorts) {
                                RECT sTextRect;
                                TEXTMETRIC sTM;

                                SendMessage(hPortCombo, CB_GETLBTEXT,
                                        uDev, (LPARAM)(LPSTR)szBuf);

                                GetTextMetrics(ps.hdc,(LPTEXTMETRIC)&sTM);
                                SetRect((LPRECT)&sTextRect,rgxPos[2]+2,iVert+2,rgxPos[3]-2,iVert+2+sTM.tmHeight);
                                DrawText(ps.hdc, szBuf, -1,(LPRECT)&sTextRect ,DT_NOPREFIX|DT_LEFT|DT_SINGLELINE);
                        }
                }
                if (iLeft < rgxPos[4]) {
              RECT rc;
         SetRect(&rc, rgxPos[3]+2, iVert, rgxPos[4]-2, iVert+yChar);
              DrawText(ps.hdc,
                  lpChannel->aszPatchName,
                  lstrlen(lpChannel->aszPatchName),
             &rc,
             DT_LEFT|DT_SINGLELINE|DT_VCENTER
             );
         // was:
                        // TextOut(ps.hdc, rgxPos[3] + 2, iVert + 2, lpChannel->aszPatchName,
                        //         lstrlen(lpChannel->aszPatchName));
                }
        }
        GlobalUnlock(hSetup);
        goto exit01;
} /* VSetupPaint */

static  void PASCAL VSetupArrowScroll(
        HWND    hdlg,
        WORD    ScrollCode)
{
        SETUP FAR* lpSetup;
        WORD    wChan;

        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        wChan = lpSetup->channels[iVertPos + iCurPos].wChannel;
        GlobalUnlock(hSetup);
        switch (ScrollCode) {
        case SB_LINEDOWN:
                if (!wChan--)
                        wChan = 15;
                break;
        case SB_LINEUP:
                if (++wChan > 15)
                        wChan = 0;
                break;
        }
        SetDlgItemInt(hWnd, ID_SETUPEDIT, wChan + 1, FALSE);
} /* VSetupArrowScroll */

/*
 * VSetupCheckMsg
 */
static  void PASCAL VSetupCheckMsg(
        WORD    id,
        WORD    NotifCode)
{
        SETUP FAR*      lpSetup;
        CHANNEL FAR*    lpChannel;

        if (NotifCode != BN_CLICKED)
                return;
        lpSetup = (SETUP FAR*)GlobalLock(hSetup);
        lpChannel = &lpSetup->channels[iVertPos + id - ID_SETUPCHECK];
        if (lpChannel->wDeviceID != MMAP_ID_NOPORT) {
                VSetupActiveChan( id - ID_SETUPCHECK
                                , &lpChannel->dFlags
                                ,   (lpChannel->dFlags & MMAP_ACTIVE)
                                  ? BTN3S_UNCHECK
                                  : BTN3S_CHECK
                                );
                Modify(TRUE);
        }
        GlobalUnlock(hSetup);
} /* VSetupCheckMsg */

BOOL    FAR PASCAL _loadds SetupBox(
        HWND    hdlg,
        UINT    uMessage,
        WPARAM  wParam,
        LPARAM  lParam)
{
        int     iRet;
        HWND    hwndCheckBox;

        switch (uMessage) {
        case WM_INITDIALOG:
                hWnd = hdlg;
                iOldPos = -1;
                SetFocus(GetDlgItem(hdlg, ID_SETUPEDIT));
                if (!FInitSetup(hdlg))
                        EndDialog(hdlg, FALSE);
                SetFocus(hEdit);
      PlaceWindow(hWnd);
                return FALSE;
        case WM_COMMAND:
            {   WORD id = LOWORD(wParam);
#if defined(WIN16)
                WORD NotifCode = HIWORD(lParam);
                HWND hwnd = LOWORD(lParam);
#else
                WORD NotifCode = HIWORD(wParam);
                HWND hwnd = (HWND)lParam;
#endif //WIN16

                switch (id) {
                case  IDH_DLG_MIDI_SETUPEDIT:
                  goto DoHelp;

                case IDOK:
                case IDCANCEL:
                        if (NotifCode != BN_CLICKED)
                                break;
                        if (!fReadOnly && ((id == IDOK) && fModified)) {
                                iRet = ISetupSave(hdlg, TRUE);
                                if (iRet == IDCANCEL)
                                        break;
                                iRet = (iRet == IDYES);
                        } else
                                iRet = FALSE;
                        GlobalFree(hSetup);
                        EndDialog(hdlg, iRet);
                        break;

                case ID_SETUPGHOSTEDITFIRST:

                        /* assume the user back-tabbed before the first
                         * control on the current row, so jump to the
                         * previous row (if iCurPos > 0) or the last row
                         * (if iCurPos == 0)
                         */

                        if (NotifCode != EN_SETFOCUS)
                                break;
                        if (iCurPos < 0)
                                /* do nothing */ ;
                        else
                        if (iCurPos > 0)
                                iCurPos--;
                        else
                                iCurPos = nLines - 1;
                        VSetupSetFocus(hdlg, PSF_REDRAW, 0);
                        hwndCheckBox = GetDlgItem(hdlg, ID_SETUPCHECK + iOldPos);
                        if (IsWindowEnabled(hwndCheckBox))
                                SetFocus(hwndCheckBox);
                        else
                                SetFocus(hPatchCombo);
                        break;

                case ID_SETUPGHOSTEDITLAST:

                        /* assume the user forward-tabbed beyond the last
                         * control on the current row, so jump to the
                         * next row (if iCurPos < nLines - 1) or the first row
                         * (if iCurPos == nLines - 1)
                         */

                        if (NotifCode != EN_SETFOCUS)
                                break;
                        if (iCurPos < 0)
                                /* do nothing */ ;
                        else
                        if (iCurPos < nLines - 1)
                                iCurPos++;
                        else
                                iCurPos = 0;
                        VSetupSetFocus(hdlg, PSF_REDRAW, 0);
                        SetFocus(hEdit);
#if defined(WIN16)
                        SendMessage(hEdit, EM_SETSEL, (WPARAM)NULL, MAKELPARAM(0, 32767));
#else
                        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
#endif //WIN16
                        break;

                case ID_SETUPEDIT:
                        VSetupEditMsg(hdlg, NotifCode);
                        break;
                case ID_SETUPPORTCOMBO:
                case ID_SETUPPATCHCOMBO:
                        VSetupComboMsg(hdlg, id, NotifCode);
                        break;
                default:
                        if ((id >= ID_SETUPCHECK) &&
                                (id < ID_SETUPCHECK + 16))
                                VSetupCheckMsg(id, NotifCode);
                        else
                                return FALSE;
                }
                break;
            } /* end of WM_COMMAND */
        case WM_PAINT:
                VSetupPaint(hdlg);
                break;
        case WM_LBUTTONDOWN:
                VSetupButtonDown(hdlg, (LONG)lParam);
                break;
        case WM_VSCROLL:
//              if (HIWORD(lParam))  // in DOS this is the window ID - I don't see why we need the test
                                     // and in NT we don't have that ID anyway
                        VSetupArrowScroll(hdlg, LOWORD(wParam));
                                     // LOWORD(wParam) is scroll code.  See cpArrow:
                                     // actually the whole of wParam is.
                break;
        case WM_CHAR:
                if ((LONG)lParam == 14)
                        if (iCurPos == 15)
                                iCurPos = 0;
                        else
                                iCurPos++;
                else if ((LONG)lParam == 16)
                        if (!iCurPos)
                                iCurPos = 15;
                        else
                                iCurPos--;
                else
                        return FALSE;
                VSetupSetFocus(hdlg, 0L, 0L);
                break;
        case WM_CLOSE:
                PostMessage(hdlg, WM_COMMAND, (WPARAM)IDOK, (LPARAM)0);
                break;

        default:
                if (uMessage == uHelpMessage) {
DoHelp:
                        WinHelp(hWnd, szMidiHlp, HELP_CONTEXT,
                                                IDH_DLG_MIDI_SETUPEDIT);
                        return TRUE;
                }
                else
                        return FALSE;
                break;
        }
        return TRUE;
} /* SetupBox */

/*
 * FSetupEnumPortsFunc
 *
 * This function receives port information for each channel in a setup,
 * determines if the port is not available in the current environment, and
 * if so adds it to a listbox of invalid port names.
 *
 * The types and parameters are weird because it is being forced into the straightjacket
 * of an enumfunc.
 */

BOOL FAR PASCAL _loadds FSetupEnumPortsFunc(
        LPSTR   lpChannel,
        LPSTR   lpPort,
        UINT    uCase,   // unused
        HWND    hCombo,  //unused
        LPSTR   DeviceID)
{
        SETUP FAR* lpSetup;
        INT    Idx;

        if (DeviceID == (LPSTR)MMAP_ID_NOPORT) {
                Idx = ComboLookup(hPortCombo, lpPort);
                if (Idx == CB_ERR) {
                        SendMessage(hPortCombo, CB_ADDSTRING, (WPARAM)NULL,
                                (LPARAM)lpPort);
                        Idx = nPorts++;
                }
                lpSetup = (SETUP FAR*)GlobalLock(hSetup);
                lpSetup->channels[(WORD)(DWORD_PTR)lpChannel - 1].wDeviceID = (WORD)Idx;
                GlobalUnlock(hSetup);
        }
        return TRUE;
} /* FSetupEnumPortsFunc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\add.c ===
/*  ADD.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for removing
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  This file deals with the case where an OEM driver being installed.
**
**  History:
**
**      Thu Nov 1 1991 -by- Sanjaya
**      Created. Originally part of drivers.c
*/

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include <string.h>
#include <cpl.h>

#include "drivers.h"
#include <cphelp.h>
#include "sulib.h"
extern PINF       pinfOldDefault;
extern BOOL       bBadOemSetup;
TCHAR *szFilter[] = {TEXT("Inf Files(*.inf)"), TEXT("*.inf"), TEXT("Drv Files(*.drv)"), TEXT("*.drv"), TEXT("")};

BOOL GetDir          (HWND);
void BrowseDlg           (HWND, int);

/*  AddDriversDlg
 *
 * Returns 2 if dialog needs to be redrawn
 * Returns 1 if the oem file has been succesfully located
 * Returns 0 if Cancel has been pressed
 */

INT_PTR AddDriversDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:

            SetDlgItemText(hDlg, ID_TEXT, (LPTSTR)szUnlisted);
            SetDlgItemText(hDlg, ID_EDIT, (LPTSTR)szDirOfSrc);
            return(TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if (GetDir(hDlg))
                    {
                        DialogBox(myInstance, MAKEINTRESOURCE(DLG_UPDATE),
                        GetParent(hDlg), AddUnlistedDlg);
                        break;
                    } else {
                        EndDialog(hDlg, 2);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    return(TRUE);

                case IDS_BROWSE:
                    lstrcpy(szDrv, szOemInf);
                    BrowseDlg(hDlg, 1);
                    break;

                case IDH_DLG_INSERT_DISK:
                    goto DoHelp;
            }
            break;

        default:
            if (message == wHelpMessage) {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_INSERT_DISK);
                return TRUE;
            } else
                return FALSE;

    }
    return (FALSE);                         /* Didn't process a message    */
}


BOOL GetDir(HWND hDlg)
{
    LPTSTR    pstr;
    OFSTRUCT of;

    wsStartWait();

   /*
    * Test the edit box for a proper path
    * and look for the oemsetup.inf
    * file.  If we don't find it , highlight the
    * text in the edit box and bring up a dialog box
    */

    GetDlgItemText( hDlg, ID_EDIT, szDirOfSrc, MAX_PATH);
    RemoveSpaces(szFullPath, szDirOfSrc);
    lstrcpy(szDirOfSrc, szFullPath);
    for (pstr = szFullPath;*pstr;pstr++);
        if (*(pstr-1) != TEXT('\\'))
            *pstr++ = TEXT('\\');

    *pstr = TEXT('\0');

    lstrcpy(szDiskPath, szFullPath);

   /*
    * Look for an oemsetup.inf
    * If you can't find it return false
    *
    */

    lstrcpy(pstr, szOemInf);

    if ((HFILE)HandleToUlong(CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == -1)
    {
       SendDlgItemMessage(hDlg, ID_EDIT, EM_SETSEL, 0, -1L);
       wsEndWait();
       return (FALSE);
    }

   /*
    * Change the default inf to this new oemsetup.inf
    * Discard the value of the previous .inf, since it might
    * just be another set of oem drivers.
    */

    if (bBadOemSetup)
       infSetDefault(infOpen(szFullPath));
    else
       pinfOldDefault = infSetDefault(infOpen(szFullPath));
    EndDialog(hDlg, 1);
    wsEndWait();
    return(TRUE);
}


/*
 * Hooks into common dialog to show only directories
 */

UINT_PTR CALLBACK AddFileHookProc(HWND hDlg, UINT iMessage,
                              WPARAM wParam, LPARAM lParam)
{
  TCHAR szTemp[200];
  HWND hTemp;

    switch (iMessage)
    {
        case WM_INITDIALOG:

            GetDlgItemText(((LPOPENFILENAME)lParam)->hwndOwner, ID_TEXT,
                  szTemp, sizeof(szTemp)/sizeof(TCHAR));
            SetDlgItemText(hDlg, ctlLast+1, szTemp);

            goto PostMyMessage;

        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                case lst2:
                case cmb2:
                case IDOK:

  PostMyMessage:
                  PostMessage(hDlg, WM_COMMAND, ctlLast+2, 0L);
                  break;

                case IDH_DLG_BROWSE:
                  goto DoHelp;

                case ctlLast+2:
                   if (bFindOEM)
                   {
                     if (SendMessage(hTemp=GetDlgItem(hDlg, lst1), LB_GETCOUNT,
                       0, 0L))
                       {
                         SendMessage(hTemp, LB_SETCURSEL, 0, 0L);
                         SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(lst1, LBN_SELCHANGE),
                                     (LONG_PTR)hTemp);
                         break;
                       }
                   }
                   SetDlgItemText(hDlg, edt1, szDrv);
                   break;
            }
            break;

        default:

            if (iMessage == wHelpMessage)
            {
DoHelp:
                WinHelp(hDlg, szDriversHlp, HELP_CONTEXT, IDH_DLG_BROWSE);
                return(TRUE);
            }
    }

    return FALSE;  // commdlg, do your thing
}


/*
 * Function : BrowseDlg
 *
 *     Call the GetOpenFileName dialog to open a file
 *
 * Parameters :
 *
 *     hDlg : Parent Dialog box
 *
 *     iIndex : Index into szFilter to determine which filter(s) to use
 */


void BrowseDlg(HWND hDlg, int iIndex)
{
    OPENFILENAME OpenFileName;
    TCHAR szPath[MAX_PATH];
    TCHAR szFile[MAX_PATH];

    *szPath = TEXT('\0');
    *szFile = TEXT('\0');
    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hDlg;
    OpenFileName.hInstance = myInstance;
    OpenFileName.lpstrFilter = szFilter[0];
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = iIndex;
    OpenFileName.lpstrFile = (LPTSTR)szPath;
    OpenFileName.nMaxFile = sizeof(szPath) / sizeof(TCHAR);
    OpenFileName.lpstrFileTitle = szFile;
    OpenFileName.nMaxFileTitle = sizeof(szFile) / sizeof(TCHAR);
    OpenFileName.lpstrInitialDir = NULL;
    OpenFileName.lpstrTitle = NULL;
    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK |
      /*  OFN_FILEMUSTEXIST | */ OFN_ENABLETEMPLATE | OFN_NOCHANGEDIR |
            OFN_SHOWHELP;
    OpenFileName.lCustData = (LONG_PTR)hDlg;
    OpenFileName.lpfnHook = AddFileHookProc;

    OpenFileName.lpTemplateName = (LPTSTR)MAKEINTRESOURCE(DLG_BROWSE);
    OpenFileName.nFileOffset = 0;
    OpenFileName.nFileExtension = 0;
    OpenFileName.lpstrDefExt = NULL;
    if (GetOpenFileName(&OpenFileName))
    {
        UpdateWindow(hDlg); // force buttons to repaint
        szPath[OpenFileName.nFileOffset] = TEXT('\0');
        SetDlgItemText(hDlg, ID_EDIT, szPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\midi\patch.c ===
/*
 * PATCH.C
 *
 * Copyright (C) 1990 Microsoft Corporation.
 *
 * Edit patchmaps dialog box and support functions.
 */

/* Revision history:
   March 92 Ported to 16/32 common code by Laurie Griffiths (LaurieGr)
*/
/*-=-=-=-=- Include Files       -=-=-=-=-*/

#include "preclude.h"
#include <windows.h>
#include <mmsystem.h>
#include <port1632.h>
#include <string.h>
#include "hack.h"
#include "midimap.h"
#include "cphelp.h"
#include "midi.h"
#include "extern.h"

#if defined(WIN32)
#define _based(x)
#endif //WIN32

/*-=-=-=-=- Prototypes          -=-=-=-=-*/

static  SZCODE aszPatchNumFormat[] = "%3d";
static MMAPERR PASCAL   MmaperrPatchInit(HWND);
static MMAPERR PASCAL   MmaperrPatchInitNew(VOID);
static VOID PASCAL      PatchEnumKeys(HWND);
static VOID PASCAL      PatchSize(HWND, BOOL);
static VOID PASCAL      PatchPaint(VOID);
static VOID PASCAL      PatchArrowScroll(WPARAM, LPARAM);
static VOID PASCAL      PatchWindowScroll(HWND, UINT, int);
static VOID PASCAL      PatchEditMsg(UINT id , WORD NotifCode);
static VOID PASCAL      PatchComboMsg(HWND hDlg, WORD NotifCode);
static VOID PASCAL      PatchButtonDown(HWND, LONG);
static VOID PASCAL      PatchSetFocus(HWND, UINT, int);
static VOID PASCAL      PatchActiveLine(UINT, UINT);
static int PASCAL       PatchSave(HWND, BOOL);

/*-=-=-=-=- Global Definitions  -=-=-=-=-*/

#define PAL_SHOW                0       // show active line
#define PAL_HIDE                1       // hide active line

#define PSF_REDRAW              0x0001  // redraw where line used to be
#define PSF_SHOWIFHIDDEN        0x0002  // show line if hidden

#define DEF_PATCH_ROWS          16      // number of default patch rows

/*-=-=-=-=- Global Variables    -=-=-=-=-*/

static HWND     hCombo,                 // keymap combo-box control handle
                hScroll,                // scroll bar control handle
                hVolEdit,               // volume edit control handle
                hVolArrow;              // volume arrow control handle
static  HGLOBAL hPatchMap;
static int      nKeys,                  // number of key maps in mapfile
                iPatchBase,
                xArrowOffset,           // patch arrow ctrl positional offset
                xVolArrowOffset;        // volume arrow ctrl positional offset

static  char    szCaption[80];
static  char    szCaptionFormat[80];

/*-=-=-=-=- Functions           -=-=-=-=-*/

/*
 * PATCHBOX
 */
BOOL FAR PASCAL _loadds PatchBox(        HWND    hDlg,
                                UINT    uMessage,
                                WPARAM  wParam,
                                LPARAM  lParam  )
{
        int     iRet = FALSE;
        char    szBuf [50];
        MMAPERR mmaperr;

        switch (uMessage) {
        case WM_INITDIALOG :
                hWnd = hDlg;
                SetFocus(GetDlgItem(hDlg, ID_PATCHNUMEDIT));
                if ((mmaperr = MmaperrPatchInit(hDlg)) != MMAPERR_SUCCESS) {
                        VShowError(hDlg, mmaperr);
                        EndDialog(hDlg, FALSE);
                }
                SetScrollRange(hScroll, SB_CTL, 0, iVertMax, FALSE);
                SetScrollPos(hScroll, SB_CTL, iVertPos, TRUE);
		PlaceWindow(hWnd);
                return FALSE;

        case WM_COMMAND :
           {  WORD id = LOWORD(wParam);
#if defined(WIN16)
              WORD NotifCode = HIWORD(lParam);
              HWND hwnd = LOWORD(lParam);
#else
              WORD NotifCode = HIWORD(wParam);
              HWND hwnd = (HWND)lParam;
#endif //WIN16
                switch(id) {
                case  IDH_DLG_MIDI_PATCHEDIT:
                  goto DoHelp;

                case ID_PATCHGHOSTEDITFIRST:

                        /* assume the user back-tabbed before the first
                         * control on the current row, so jump to the
                         * previous row (if iCurPos > 0) or the last row
                         * (if iCurPos == 0)
                         */
                        if (fHidden)    // we shouldn't get these
                                break;  // messages when we're hidden -jyg

                        if (NotifCode != EN_SETFOCUS)
                                break;
                        if (iCurPos < 0)
                                /* do nothing */ ;
                        else if (iCurPos > 0)
                                iCurPos--;
                        else
                        {
                                if (iVertPos != 0)
                                {
                                        /* at top -- scroll up one line */
                                        PatchWindowScroll(hDlg, SB_LINEUP, 0);
                                        iCurPos = 0;
                                }
                                else
                                {
                                        PatchWindowScroll(hDlg, SB_THUMBPOSITION,iVertMax);
                                        iCurPos = nLines - 1;

                                        PatchSetFocus(hDlg, PSF_REDRAW|PSF_SHOWIFHIDDEN, 0L);
                                        PatchActiveLine(PAL_SHOW, SWP_SHOWWINDOW);
                                }
                        }
                        PatchSetFocus(hDlg, PSF_REDRAW, 1);
                        SetFocus(hCombo);
                        break;

                case ID_PATCHGHOSTEDITLAST:

                        /* assume the user forward-tabbed beyond the last
                         * control on the current row, so jump to the
                         * next row (if iCurPos < nLines - 1) or the first row
                         * (if iCurPos == nLines - 1)
                         */
                        if (fHidden)    //we shouldn't get these messages
                                break;  //when we're hidden -jyg

                        if (NotifCode != EN_SETFOCUS)
                                break;
                        if (iCurPos < 0)
                                /* do nothing */ ;
                        else if (iCurPos < nLines - 1)
                                iCurPos++;
                        else
                        {
                                if (iVertPos != iVertMax)
                                {
                                        /* at bottom -- scroll down one line */
                                        PatchWindowScroll(hDlg, SB_LINEDOWN, 0);
                                        iCurPos = nLines - 1;
                                }
                                else
                                {
                                        /* wrap to the top cell */
                                        PatchWindowScroll(hDlg, SB_THUMBPOSITION,-iVertMax);
                                        iCurPos = 0;

                                        PatchSetFocus(hDlg, PSF_REDRAW|PSF_SHOWIFHIDDEN, 0L);
                                        PatchActiveLine(PAL_SHOW, SWP_SHOWWINDOW);
                                }
                        }
                        PatchSetFocus(hDlg, PSF_REDRAW, 1);
                        SetFocus(hEdit);

#if defined(WIN16)
                        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, MAKELPARAM(0, 32767));
#else
                        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
#endif //WIN16
                        break;

                case IDOK :
                case IDCANCEL :
                        if (NotifCode != BN_CLICKED)
                                break;
                        if (!fReadOnly && (id == IDOK) && fModified) {
                                iRet = PatchSave(hDlg, TRUE);
                                if (iRet == IDCANCEL)
                                        break;
                                iRet = (iRet == IDYES);
                        }
                        else
                                iRet = FALSE;

                        GlobalFree(hPatchMap);
                        nKeys = 0;
                        EndDialog(hDlg, iRet);
                        break;

                case ID_PATCHNUMEDIT :
                case ID_PATCHVOLEDIT :
                        PatchEditMsg(id, NotifCode);
                        break;

                case ID_PATCHCOMBO :
                        PatchComboMsg(hDlg, NotifCode);
                        break;

                case ID_PATCHBASED :
                        if (NotifCode != BN_CLICKED)
                                break;
                        iPatchBase = !iPatchBase;
                        wsprintf(szBuf, aszPatchNumber,
                                !iPatchBase);
                        SetWindowText(hwnd, szBuf);
                        PatchEditMsg(ID_PATCHNUMEDIT, EN_ACTIVATE);
                        SetFocus(hEdit);
#if defined(WIN16)
                        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, MAKELPARAM(0, 32767));
#else
                        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
#endif //WIN16
                        InvalidateRect(hWnd, &rcBox, TRUE);
                        break;

                default :
                        return FALSE;
                }
                break;
           } /* end of WM_COMMAND */
        case WM_PAINT :
                PatchPaint();
                break;

        case WM_LBUTTONDOWN :
                PatchButtonDown(hDlg, (LONG)lParam);
                break;

        case WM_VSCROLL :
#if defined(WIN16)
                if ((HWND)HIWORD(lParam) == hScroll)
                        PatchWindowScroll(hDlg, (WORD)wParam, (int)LOWORD(lParam));
                else
                        PatchArrowScroll((WORD)wParam, (LONG)lParam);
#else
                if ((HWND)(lParam) == hScroll)
                        PatchWindowScroll(hDlg, LOWORD(wParam), HIWORD(wParam));
                else
                        PatchArrowScroll(LOWORD(wParam), lParam);

#endif //WIN16
                break;

        case WM_CLOSE :
                PostMessage(hDlg, WM_COMMAND, (WPARAM)IDOK, (LPARAM)0);
                break;

        default:
                if (uMessage == uHelpMessage) {
DoHelp:
                        WinHelp(hWnd, szMidiHlp, HELP_CONTEXT,
                                                IDH_DLG_MIDI_PATCHEDIT);
                        return TRUE;
                }
                else
                        return FALSE;
                break;
        }

        return TRUE;
} /* PatchBox */

/*
 * MmaperrPatchInit
 */
static  MMAPERR PASCAL MmaperrPatchInit(
        HWND hDlg)
{
        PATCHMAP FAR* lpPatch;
        LONG    lDBU;
        MMAPERR mmaperr;
        UINT    xBU,
                yBU,
                xWidth, // width of current column
                xArrow, // width of arrow control
                xEdit,  // width of edit controls
                yEdit,  // height of edit/arrow controls
                xCombo, // width of combo boxes
                yCombo; // height of combo boxes
        int     i;

        fHidden = FALSE;
        iVertPos = 0;
        iCurPos = 0;
        nKeys = 0;
        nLines = 0; // necessary?
        iPatchBase = 1; // getprofile

        hEdit = GetDlgItem(hWnd, ID_PATCHNUMEDIT);
        hArrow = GetDlgItem(hWnd, ID_PATCHNUMARROW);
        hVolEdit = GetDlgItem(hWnd, ID_PATCHVOLEDIT);
        hVolArrow = GetDlgItem(hWnd, ID_PATCHVOLARROW);
        hCombo = GetDlgItem(hWnd, ID_PATCHCOMBO);
        hScroll = GetDlgItem(hWnd, ID_PATCHSCROLL);

        if (fReadOnly)
        {
                EnableWindow(GetDlgItem(hWnd,IDOK),FALSE);
                SendMessage(hWnd, DM_SETDEFID, (WPARAM)IDCANCEL, (LPARAM)0);
        }

        lDBU = GetDialogBaseUnits();
        xBU = LOWORD(lDBU);
        yBU = HIWORD(lDBU);

        xArrow = (10 * xBU) / 4;        // about yea big
        xEdit = (40 * xBU) / 4;         // 10 chars wide
        yEdit = (10 * yBU) / 8;         // cookie heaven
        xCombo = (64 * xBU) / 4;        // 16 chars wide
        yCombo = (46 * yBU) / 8;        // oreos

        rcBox.left = (HORZMARGIN * xBU) / 4;
        for (i = 0, rcBox.right = rcBox.left; i < 6; i++) {
                rgxPos [i] = rcBox.right;

                switch (i) {

                case 0 :
                        // width of src patch # text (3.5 chars wide)
                        rcBox.right += xEdit;
                        break;

                case 1 :
                        // width of src patch name text
                        rcBox.right += (72 * xBU) / 4; // 18 chars wide
                        break;

                case 2 :
                        // width of dst patch # edit control
                        xWidth = xEdit;
                        SetWindowPos(hEdit, NULL, 0L, 0L,
                                xWidth, yEdit, SWP_NOZORDER | SWP_NOMOVE);

                        // set global arrow control offset to proper position
                        rcBox.right += xArrowOffset = xWidth - 1;

                        // width of dst patch # arrow control
                        xWidth = xArrow;
                        SetWindowPos(hArrow, NULL, 0L, 0L,
                                xWidth, yEdit, SWP_NOZORDER | SWP_NOMOVE);
                        rcBox.right += xWidth - 1;
                        break;

                case 3 :
                        // width of volume % edit control
                        xWidth = xEdit;
                        SetWindowPos(hVolEdit, NULL, 0L, 0L,
                                xWidth, yEdit, SWP_NOZORDER | SWP_NOMOVE);

                        // set global arrow control offset to proper position
                        rcBox.right += xVolArrowOffset = xWidth - 1;

                        // width of volume % arrow control
                        xWidth = xArrow;
                        SetWindowPos(hVolArrow, NULL, 0L, 0L,
                                xWidth, yEdit, SWP_NOZORDER | SWP_NOMOVE);
                        rcBox.right += xWidth - 1;
                        break;

                case 4 :
                        // width of keymap combo box.  I'd use MMAP_MAXLEN
                        xWidth = xCombo;
                        SetWindowPos(hCombo, NULL, 0L, 0L,
                                xWidth, yCombo, SWP_NOZORDER | SWP_NOMOVE);
                        rcBox.right += xWidth - 1;
                        break;

                case 5 :
                        break;

                }
        }

        if (!nKeys)
                PatchEnumKeys(hCombo);

        if (!fNew) {
                if ((hPatchMap = GlobalAlloc(GHND, sizeof(PATCHMAP))) == NULL)
                        return MMAPERR_MEMORY;
                lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);
                if ((mmaperr = mapReadPatchMap(szCurrent, lpPatch)) == MMAPERR_SUCCESS)
                        if (lstrcmp(lpPatch->aszPatchMapDescription, szCurDesc)) {
                                lstrcpy(lpPatch->aszPatchMapDescription, szCurDesc);
                                fNew = TRUE;
                        }
                GlobalUnlock(hPatchMap);
                if (mmaperr != MMAPERR_SUCCESS) {
                        GlobalFree(hPatchMap);
                        hPatchMap = NULL;
                        return mmaperr;
                }
        } else if ((mmaperr = MmaperrPatchInitNew()) != MMAPERR_SUCCESS)
                return mmaperr;

        LoadString(hLibInst, IDS_PATCHES ,szCaptionFormat, sizeof(szCaptionFormat));
        wsprintf(szCaption, szCaptionFormat, (LPSTR)szCurrent);
        SetWindowText(hWnd, szCaption);

        SendMessage(GetDlgItem(hWnd, ID_PATCHDESTMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        SendMessage(GetDlgItem(hWnd, ID_PATCHVOLMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        SendMessage(GetDlgItem(hWnd, ID_PATCHKEYMNEM),
                WM_SETFONT, (WPARAM)hFont, (LPARAM)0);
        PatchSize(hDlg, TRUE);
        i = rcBox.top - yChar + 5;
        SetWindowPos(GetDlgItem(hWnd, ID_PATCHDESTMNEM), NULL,
                rgxPos [2] - xChar + 7, i, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(GetDlgItem(hWnd, ID_PATCHVOLMNEM), NULL,
                rgxPos [3] + xChar - 6, i, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(GetDlgItem(hWnd, ID_PATCHKEYMNEM), NULL,
                rgxPos [4] + xChar, i, 0L, 0L, SWP_NOSIZE | SWP_NOZORDER);
#if defined(WIN16)
        SendMessage(hWnd, WM_COMMAND, (WPARAM)ID_PATCHBASED, MAKELPARAM(GetDlgItem(hWnd, ID_PATCHBASED), BN_CLICKED));
#else
        SendMessage( hWnd
                   , WM_COMMAND
                   , (WPARAM)MAKELONG(ID_PATCHBASED, BN_CLICKED)
                   , (LPARAM)GetDlgItem(hWnd, ID_PATCHBASED)
                   );
#endif //WIN16
        Modify(fNew);
        return MMAPERR_SUCCESS;
} /* MmaperrPatchInit */

/*
 * MmaperrPatchInitNew
 */
static  MMAPERR PASCAL MmaperrPatchInitNew(
        VOID)
{
        PATCHMAP FAR*  lpPatch;
        UINT    u;

        if ((hPatchMap = GlobalAlloc(GHND,
                (DWORD)sizeof(PATCHMAP))) == NULL)
                return MMAPERR_MEMORY;
        lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);
        lstrcpy(lpPatch->aszPatchMapName, szCurrent);
        lstrcpy(lpPatch->aszPatchMapDescription, szCurDesc);
        for (u = 0; u < MIDIPATCHSIZE; u++) {
                lpPatch->keymaps[u].bVolume = 100;
                lpPatch->keymaps[u].bDestination = (BYTE)u;
                lstrcpy(lpPatch->keymaps[u].aszKeyMapName, szNone);
        }
        GlobalUnlock(hPatchMap);
        return MMAPERR_SUCCESS;
} /* MmaperrPatchInitNew */

/*
 * PATCHENUMKEYS
 */
static
VOID PASCAL PatchEnumKeys(HWND hCombo)
{
        mapEnumerate(MMAP_KEY, EnumFunc, MMENUM_BASIC, hCombo, NULL);
        SendMessage(hCombo, CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPSTR)szNone);
        nKeys = (int)(LONG)SendMessage(hCombo, CB_GETCOUNT, (WPARAM)NULL, (LPARAM)0);
} /* PatchEnumKeys */

/*
 * PATCHSIZE
 */
static
VOID PASCAL PatchSize(HWND hDlg, BOOL fMaximize)
{
        HWND    hBanana;
        RECT    rcBanana;
        RECT    rcOK,
                rcWnd;
        LONG    lDBU;
        UINT    xBU,
                yBU;
        int     xButton,
                xCenter,
                yTopMar,
                yBotMar,
                yLeftOver,
                yBox,
                yMiniBotMar;

        lDBU = GetDialogBaseUnits();
        xBU = LOWORD(lDBU);
        yBU = HIWORD(lDBU);

        // get the rectangle of the OK button
        GetClientRect(GetDlgItem(hWnd, IDOK), &rcOK);

        // get x-extent of button
        xButton = rcOK.right - rcOK.left;

        // top margin is 4 characters
        yTopMar = (32 * yBU) / 8 - 6; // cookie land

        // bottom margin is 2 * minimum bottom margin dialog units +
        // height of button in pixels
        yBotMar = (VERTMARGIN * 2 * yBU) / 8 + rcOK.bottom - rcOK.top;

        if (fMaximize) {
                // maximize the patch box
                SetWindowPos(hWnd, NULL, 0L, 0L,
                        rcBox.right - rcBox.left +
                        (2 * HORZMARGIN * xBU) / 4 +
                        GetSystemMetrics(SM_CXVSCROLL) +
                        (GetSystemMetrics(SM_CXDLGFRAME) + 1) * 2,
                        (DEF_PATCH_ROWS * 10 * yBU) / 8 +
                        yTopMar + yBotMar +
                        GetSystemMetrics(SM_CYCAPTION) +
                        GetSystemMetrics(SM_CYDLGFRAME) * 2,
                        SWP_NOZORDER | SWP_NOMOVE);
        }

        // get the x and y extents of the client rectangle
        GetClientRect(hWnd, &rcWnd);
        xClient = rcWnd.right - rcWnd.left;
        yClient = rcWnd.bottom - rcWnd.top;

        // yChar is the height of one row in pixels - 1
        yChar = (10 * yBU) / 8 - 1;

        // xChar is the average width of a character
        xChar = xBU;

        // yBox is the room we actually have to display patchmap rows
        yBox = yClient - yTopMar - yBotMar;

        // nLines is the number of setup rows we can display
        nLines = min(16, yBox / yChar);

        // yLeftOver is how many pixels are left over
        yLeftOver = yBox - nLines * yChar;

        // add half the leftovers to the top margin
        yTopMar += yLeftOver / 2;

        // rcBox is the box of rows and columns inside the client area
        SetRect(
                &rcBox,
                rcBox.left,
                yTopMar,
                rcBox.right,
                yTopMar + nLines * yChar);

        // xCenter is used to center the OK and CANCEL buttons horizontally
        xCenter = (rcBox.right - rcBox.left - xButton * 3) / 4;

        // yMiniBotMar is the spacing above and below the button
        yMiniBotMar = (VERTMARGIN * yBU) / 8 + yLeftOver / 4;

        SetWindowPos(
                GetDlgItem(hWnd, IDOK),
                NULL,
                rcBox.left + xCenter,
                rcBox.bottom + yMiniBotMar,
                0L,
                0L,
                SWP_NOSIZE | SWP_NOZORDER);

        SetWindowPos(
                GetDlgItem(hWnd, IDCANCEL),
                NULL,
                rcBox.left + xButton + xCenter * 2,
                rcBox.bottom + yMiniBotMar,
                0L,
                0L,
                SWP_NOSIZE | SWP_NOZORDER);

        SetWindowPos(
                GetDlgItem(hWnd, IDH_DLG_MIDI_PATCHEDIT),
                NULL,
                rcBox.left + xButton * 2 + xCenter * 3,
                rcBox.bottom + yMiniBotMar,
                0L,
                0L,
                SWP_NOSIZE | SWP_NOZORDER);

        // get the banana button
        hBanana = GetDlgItem(hWnd, ID_PATCHBASED);

        // get the rectangle of the banana button
        GetClientRect(hBanana, &rcBanana);

        // set the banana position
        SetWindowPos(
                hBanana,
                NULL,
                rcBox.left + (rcBox.right - rcBox.left - rcBanana.right) / 2,
                (6 * yBU) / 8,
                0L,
                0L,
                SWP_NOSIZE | SWP_NOZORDER);

        SetWindowPos(
                hScroll,
                NULL,
                rcBox.right,
                rcBox.top,
                GetSystemMetrics(SM_CXVSCROLL),
                rcBox.bottom - rcBox.top + 1,
                SWP_NOZORDER);

        iVertMax = max(0, MIDIPATCHSIZE - nLines);
        iVertPos = min(iVertMax, iVertPos);
        SetScrollRange(hScroll, SB_CTL, 0, iVertMax, FALSE);
        SetScrollPos(hScroll, SB_CTL, iVertPos, TRUE);

        if (iCurPos >= 0 && iCurPos < nLines)
                PatchSetFocus(hDlg, PSF_SHOWIFHIDDEN, 1);
        else
                PatchActiveLine(PAL_HIDE, SWP_NOREDRAW);
} /* PatchSize */

/*
 * PATCHPAINT
 */
static
VOID PASCAL PatchPaint(VOID)
{
        HPEN            hPen = 0;
        PATCHMAP FAR*   lpPatch;
        PAINTSTRUCT     ps;
        int     i,
                iVert,
                iLeft,
                nBegin,
                nEnd,
                iTop,
                iBottom;
        BOOL    fSelected = FALSE;
        char    szBuf [50];

        BeginPaint(hWnd, &ps);

        if (!ps.rcPaint.bottom)
                goto DonePainting;

        hPen = SelectObject(ps.hdc, GetStockObject(BLACK_PEN));
        hFont = SelectObject(ps.hdc, hFont);
        fSelected = TRUE;

        SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkMode(ps.hdc, TRANSPARENT);

        if (ps.rcPaint.top < rcBox.top) {
                iVert = rcBox.top - yChar + 5;
                TextOut(ps.hdc, 11, iVert, aszSourcePatch, lstrlen(aszSourcePatch));
                TextOut(ps.hdc, rgxPos [1] + xChar * 2 - 15, iVert,
                        aszSourcePatchName, lstrlen(aszSourcePatchName));
        }

        // calculate top and bottom y coordinates of invalid area
        iTop = max(ps.rcPaint.top, rcBox.top);

        // if top is below the box, forget about painting
        if (iTop > rcBox.bottom)
                goto DonePainting;

        iBottom = min(ps.rcPaint.bottom, rcBox.bottom);

        // calculate left x coordinate of invalid area
        iLeft = max(ps.rcPaint.left, rcBox.left);

        // calculate beginning and ending data row to be repainted
        nBegin = max(0, (iTop - rcBox.top) / yChar);
        nEnd = min(nLines, (iBottom - rcBox.top) / yChar);

        for (i = 0; i < 6; i++) {
                MMoveTo(ps.hdc, rgxPos [i], iTop);
                LineTo(ps.hdc, rgxPos [i], iBottom + 1);
        }
        // vertical position of first line we have to draw
        iVert = rcBox.top + nBegin * yChar;

        // lock the map
        lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);
        for (i = nBegin; i <= nEnd; i++, iVert += yChar) {
                MMoveTo(ps.hdc, iLeft, iVert);
                LineTo(ps.hdc, min(ps.rcPaint.right, rcBox.right), iVert);

                if (i == nLines)
                        break;

                if (iLeft < rgxPos [1]) {
                        wsprintf(szBuf, aszPatchNumFormat, iVertPos + iPatchBase + i);
                        TextOut(ps.hdc, rgxPos [0] + xChar, iVert + 2,
                                szBuf, 3);
                }
                if (iLeft < rgxPos [2]) {
                        if (!LoadString(hLibInst, IDS_PATCHMAP_BASE +
                                        iVertPos + i + 1, szBuf, sizeof(szBuf)))
                                LoadString(hLibInst, IDS_RESERVED, szBuf, sizeof(szBuf));
                        TextOut(ps.hdc, rgxPos [1] + 2, iVert + 2,
                                szBuf, lstrlen(szBuf));
                }

                if (i == iCurPos)
                        continue;

                if (iLeft < rgxPos [3]) {
                        wsprintf(szBuf, aszPatchNumFormat, lpPatch->keymaps[iVertPos + i].bDestination + iPatchBase);
                        TextOut(ps.hdc, rgxPos [2] + xChar * 2, iVert + 2,
                                szBuf, 3);
                }
                if (iLeft < rgxPos [4]) {
                        wsprintf(szBuf, aszPatchNumFormat, lpPatch->keymaps[iVertPos + i].bVolume);
                        TextOut(ps.hdc, rgxPos [3] + xChar * 2, iVert + 2,
                                szBuf, 3);
                }
                if (iLeft < rgxPos [5])
                        TextOut(ps.hdc, rgxPos [4] + 2, iVert + 2, lpPatch->keymaps[iVertPos + i].aszKeyMapName,
                                lstrlen(lpPatch->keymaps[iVertPos + i].aszKeyMapName));
        }
        GlobalUnlock(hPatchMap);

DonePainting:
        if (fSelected) {
                hFont = SelectObject(ps.hdc, hFont);
                hPen = SelectObject(ps.hdc, hPen);
        }
        EndPaint(hWnd, &ps);
} /* PatchPaint */

/*
 * PATCHARROWSCROLL
 *
 * Interpret a scroll message for the arrow control.
 */
static
VOID PASCAL PatchArrowScroll(   WPARAM  wParam,    // scroll code only (even on 32 bit)
                                LPARAM  lParam )   // (hwnd,posn) (16 bit),  hwnd (32 bit)
                                                   // posn not actually used.
{
        PATCHMAP FAR* lpPatch;
        UINT    uId;
        BYTE    bPatch,
                bMax,
                bMin;

        lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);

#if defined(WIN16)
        if ((HWND)HIWORD(lParam) == hArrow) {
#else
        if ((HWND)lParam == hArrow) {
#endif
                uId = ID_PATCHNUMEDIT;
                bPatch = lpPatch->keymaps[iVertPos + iCurPos].bDestination + (BYTE)iPatchBase;
                bMax = (BYTE)(127 + iPatchBase);        // MMAP_MAXPATCHES
                bMin = (BYTE)iPatchBase;
        }
        else {
                uId = ID_PATCHVOLEDIT;
                bPatch = lpPatch->keymaps[iVertPos + iCurPos].bVolume;
                bMax = 200;                     // MMAP_MAXVOLUME
                bMin = 0;
        }
        GlobalUnlock(hPatchMap);

        switch (wParam) {

        case SB_LINEDOWN :
                if (bPatch-- == bMin)
                        bPatch = bMax;
                break;

        case SB_LINEUP :
                if (bPatch++ == bMax)
                        bPatch = bMin;
                break;

        default:
                break;
        }
        SetDlgItemInt(hWnd, uId, bPatch, FALSE);
} /* PatchArrowScroll */

/*
 * PATCHWINDOWSCROLL
 */
static
VOID PASCAL PatchWindowScroll(  HWND    hDlg,
                                UINT    wParam,
                                int     iPos )
{
        HDC     hDC;
        RECT    rc;
        int     iVertInc;
        BOOL    fWillBeVisible;         // will it be visible after scroll?

        switch (wParam) {

        case SB_LINEUP :
                iVertInc = -1;
                break;

        case SB_LINEDOWN :
                iVertInc = 1;
                break;

        case SB_PAGEUP :
                iVertInc = min(-1, -nLines);
                break;

        case SB_PAGEDOWN :
                iVertInc = max(1, nLines);
                break;

        case SB_THUMBTRACK :
        case SB_THUMBPOSITION :
                iVertInc = iPos - iVertPos;
                break;

        default :
                iVertInc = 0;
        }


        iVertInc = max(-iVertPos, min(iVertInc, iVertMax - iVertPos));

        if (iVertInc != 0)
        {
                iVertPos += iVertInc;
                iCurPos -= iVertInc;

                if (iCurPos < 0 || iCurPos >= nLines) {
                        SetFocus(NULL);
                        fWillBeVisible = FALSE;
                }
                else
                        fWillBeVisible = TRUE;

                // Scroll to the correct position

                SetScrollPos(hScroll, SB_CTL, iVertPos, TRUE);

                hDC = GetDC(hWnd);
                ScrollDC(hDC, 0L, -yChar * iVertInc, &rcBox, &rcBox, NULL, &rc);
                ReleaseDC(hWnd, hDC);

                if (!fHidden)
                        PatchActiveLine(PAL_HIDE, SWP_NOREDRAW);

                if (fWillBeVisible) {
                        PatchSetFocus(hDlg, 0L, 0L);
                        PatchActiveLine(PAL_SHOW, SWP_NOREDRAW);
                }
                InvalidateRect(hWnd, &rc, TRUE);
                UpdateWindow(hWnd);
        }
} /* PatchWindowScroll */

/*
 * PatchEditMsg
 *
 * This function deals with EN_UPDATE and EN_ACTIVATE messages sent
 * to the patch number and volume percent edit controls through the
 * WM_COMMAND message.
 */
static
VOID PASCAL PatchEditMsg( UINT id, WORD NotifCode )
{
        PATCHMAP FAR*  lpPatch;
        UINT
                uVal,                   // value of control
                uMin,                   // min value allowed
                uMax;                   // max value allowed
        BOOL    bTranslate;

        if (NotifCode != EN_UPDATE && NotifCode != EN_ACTIVATE)
                return;

        lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);

        switch (NotifCode) {

        case EN_UPDATE :
                if (id == ID_PATCHNUMEDIT) {
                        uMax = 127 + iPatchBase;// MMAP_MAXPATCHES
                        uMin = iPatchBase;
                }
                else {
                        uMax = 200;             // MMAP_MAXVOLUME
                        uMin = 0;
                }

                uVal = (UINT)GetDlgItemInt(hWnd, id, &bTranslate, TRUE);

                if ((int)uVal < (int)uMin) {
                        uVal = uMin;
                        SetDlgItemInt(hWnd, id, uVal, FALSE);
                } else if (uVal > uMax) {
                        uVal = uMax;
                        SetDlgItemInt(hWnd, id, uVal, FALSE);
                } else {
                        if (id == ID_PATCHNUMEDIT) {
                                uVal -= iPatchBase;
                                if (uVal != lpPatch->keymaps[iVertPos + iCurPos].bDestination) {
                                        lpPatch->keymaps[iVertPos + iCurPos].bDestination = (BYTE)uVal;
                                        Modify(TRUE);
                                }
                        } else if (uVal != lpPatch->keymaps[iVertPos + iCurPos].bVolume) {
                                lpPatch->keymaps[iVertPos + iCurPos].bVolume = (BYTE)uVal;
                                Modify(TRUE);
                        }
                }
                break;

        case EN_ACTIVATE :
                if (id == ID_PATCHNUMEDIT)
                        SetDlgItemInt(hWnd, id, lpPatch->keymaps[iVertPos + iCurPos].bDestination + iPatchBase, FALSE);
                else
                        SetDlgItemInt(hWnd, id, lpPatch->keymaps[iVertPos + iCurPos].bVolume, FALSE);
                break;

        default :
                break;

        }

        GlobalUnlock(hPatchMap);
} /* PatchEditMsg */

/*
 * PatchComboMsg
 *
 * This function deals with the CBN_ACTIVATE and CBN_SELCHANGE messages sent
 * to the keymap name combo box through the WM_COMMAND message.
 */
static
VOID PASCAL PatchComboMsg(HWND hDlg, WORD NotifCode)
{
        PATCHMAP FAR*  lpPatch;
        char    szBuf [MMAP_MAXNAME];

        if (NotifCode != CBN_ACTIVATE && NotifCode != CBN_SELCHANGE)
                return;

        lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);

        switch (NotifCode) {

        case CBN_ACTIVATE :
                SendMessage(hCombo, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(lpPatch->keymaps[iVertPos + iCurPos].aszKeyMapName));
                break;

        case CBN_SELCHANGE:
                GetWindowText(hCombo, szBuf, MMAP_MAXNAME);
                if (!lstrcmpi(szBuf, lpPatch->keymaps[iVertPos + iCurPos].aszKeyMapName))
                        break;
                lstrcpy(lpPatch->keymaps[iVertPos + iCurPos].aszKeyMapName, szBuf);
                Modify(TRUE);
                break;

        default :
                break;
        }

        GlobalUnlock(hPatchMap);
} /* PatchComboMsg */

/*
 * PATCHBUTTONDOWN
 */
static
VOID PASCAL PatchButtonDown(HWND hDlg, LONG lParam)
{
        int     x = LOWORD(lParam),
                y = HIWORD(lParam),
                iPos;
        UINT    uFlags;

        if (x < rcBox.left || x > rcBox.right)
                return;
        if (y < rcBox.top || y > rcBox.bottom)
                return;

        iPos = min(nLines - 1, (y - rcBox.top) / yChar);

        if (iPos == iCurPos)
                return;

        if (iCurPos >= 0 && iCurPos < nLines) {
                uFlags = PSF_REDRAW;
                SendMessage(hCombo, CB_SHOWDROPDOWN, (WPARAM)FALSE, (LPARAM)0);
                UpdateWindow(hWnd);
        }
        else
                uFlags = PSF_SHOWIFHIDDEN;

        iCurPos = iPos;
        PatchSetFocus(hDlg, uFlags, x);
} /* PatchButtonDown */

/*
 * PATCHSETFOCUS
 */
static
VOID PASCAL PatchSetFocus(      HWND    hDlg,
                                UINT    uFlags,
                                int     xPos )
{
        RECT    rc;
        int     yPos = rcBox.top + iCurPos * yChar;

        PatchEditMsg(ID_PATCHNUMEDIT, EN_ACTIVATE);
        PatchEditMsg(ID_PATCHVOLEDIT, EN_ACTIVATE);
        PatchComboMsg(hDlg, CBN_ACTIVATE);

        GetWindowRect(hEdit, &rc);

        SetWindowPos(hEdit, NULL, rgxPos [2], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);
        SetWindowPos(hArrow, NULL, rgxPos [2] + xArrowOffset, yPos, 0L,
                0L, SWP_NOZORDER | SWP_NOSIZE);
        SetWindowPos(hVolEdit, NULL, rgxPos [3], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);
        SetWindowPos(hVolArrow, NULL, rgxPos [3] + xVolArrowOffset, yPos,
                0L, 0L, SWP_NOZORDER | SWP_NOSIZE);
        SetWindowPos(hCombo, NULL, rgxPos [4], yPos, 0L, 0L,
                SWP_NOZORDER | SWP_NOSIZE);

        if (fHidden && uFlags & PSF_SHOWIFHIDDEN) {
                PatchActiveLine(PAL_SHOW, 0L);
                UpdateWindow(hEdit);
                UpdateWindow(hArrow);
                UpdateWindow(hVolEdit);
                UpdateWindow(hVolArrow);
                UpdateWindow(hCombo);
        }

        if (uFlags & PSF_REDRAW && rc.right) {
                ScreenToClient(hWnd, (LPPOINT)&rc);
                ScreenToClient(hWnd, (LPPOINT)&rc + 1);
                rc.right = rcBox.right + 1;
                InvalidateRect(hWnd, &rc, FALSE);
                UpdateWindow(hWnd);
        }

        if (xPos < rgxPos [3]) {
                if (!fHidden)
                        SetFocus(hEdit);
#if defined(WIN16)
                SendMessage(hEdit, EM_SETSEL, (WPARAM)NULL, MAKELPARAM(0, 32767));
#else
                SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
#endif //WIN16
        }
        else if (xPos < rgxPos [4]) {
                if (!fHidden)
                        SetFocus(hVolEdit);
#if defined(WIN16)
                SendMessage(hVolEdit, EM_SETSEL, (WPARAM)NULL, MAKELPARAM(0, 32767));
#else
                SendMessage(hVolEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
#endif //WIN16
        }
        else if (xPos < rgxPos [5] && !fHidden)
                SetFocus(hCombo);
} /* PatchSetFocus */

/*
 * PATCHACTIVELINE
 */
static
VOID PASCAL PatchActiveLine(    UINT    uCase,
                                UINT    uFlags )
{
        static const UINT uDefFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER;

        switch (uCase) {

        case PAL_SHOW :
                if (!fHidden)
                        return;

                uFlags |= SWP_SHOWWINDOW;
                fHidden = FALSE;
                break;

        case PAL_HIDE :
                if (fHidden)
                        return;

                uFlags |= SWP_HIDEWINDOW;
                fHidden = TRUE;
                break;

        default :
                break;

        }
        uFlags |= uDefFlags;
        SetWindowPos(hEdit, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hArrow, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hVolEdit, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hVolArrow, NULL, 0L, 0L, 0L, 0L, uFlags);
        SetWindowPos(hCombo, NULL, 0L, 0L, 0L, 0L, uFlags);

        if (uCase == PAL_SHOW && !fHidden)
                SetFocus(hEdit);
} /* PatchActiveLine */

/*
 * PATCHSAVE
 */
static  int PASCAL PatchSave(
        HWND    hDlg,
        BOOL bQuery)
{
        PATCHMAP FAR*  lpPatch;
        MMAPERR mmaperr;
        int     iRet = 0;            // a value other than IDCANCEL or IDYES

        if (bQuery) {
                iRet = QuerySave();
                if (iRet != IDYES)
                        return iRet;
        }
        lpPatch = (PATCHMAP FAR*)GlobalLock(hPatchMap);
        mmaperr = mapWrite(MMAP_PATCH, lpPatch);
        GlobalUnlock(hPatchMap);
        if (mmaperr != MMAPERR_SUCCESS) {
                VShowError(hDlg, mmaperr);
                return IDCANCEL;
        }
        Modify(FALSE);
        if (fNew)
                fNew = FALSE;
        return iRet;
} /* PatchSave */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\advaudio.cpp ===
//--------------------------------------------------------------------------;
//
//  File: advaudio.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;


#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"
#include "gfxui.h"

#include <dsound.h>
#include "advaudio.h"
#include "speakers.h"
#include "perfpage.h"
#include "dslevel.h"
#include "drivers.h"

////////////
// Globals
////////////

AUDDATA         gAudData;
HINSTANCE       ghInst;
const TCHAR *    gszHelpFile;

////////////
// Functions
////////////
extern INT_PTR CALLBACK  SoundEffectsDlg(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

STDAPI_(void) ToggleApplyButton(HWND hWnd)
{
    BOOL fChanged = FALSE;
    HWND hwndSheet;

    if (memcmp(&gAudData.stored,&gAudData.current,sizeof(CPLDATA)))
    {
        fChanged = TRUE;
    }

    hwndSheet = GetParent(hWnd);

    if (fChanged)
    {
        PropSheet_Changed(hwndSheet,hWnd);
    }
    else
    {
        PropSheet_UnChanged(hwndSheet,hWnd);
    }
}


void VerifyRanges(LPCPLDATA pData)
{
    pData->dwHWLevel        = min(pData->dwHWLevel,MAX_HW_LEVEL);
    pData->dwSRCLevel       = min(pData->dwSRCLevel,MAX_SRC_LEVEL);
    pData->dwSpeakerType    = min(pData->dwSpeakerType,MAX_SPEAKER_TYPE);
}


void GetCurrentSettings(LPAUDDATA pAD, DWORD dwWaveId, LPTSTR szDeviceName, BOOL fRecord)
{
    HRESULT hr = E_FAIL;

    if (pAD)
    {
        CPLDATA cplData = { DEFAULT_HW_LEVEL, DEFAULT_SRC_LEVEL, SPEAKERS_DEFAULT_CONFIG, SPEAKERS_DEFAULT_TYPE };

        memset(pAD,0,sizeof(AUDDATA));
        pAD->dwDefaultHWLevel = MAX_HW_LEVEL;
        pAD->fRecord = fRecord;

        hr = DSGetGuidFromName(szDeviceName, fRecord, &pAD->devGuid);

        if (SUCCEEDED(hr))
        {
            hr = DSGetCplValues(pAD->devGuid, fRecord, &cplData);

            if (SUCCEEDED(hr))
            {
                VerifyRanges(&cplData);
                VerifySpeakerConfig(cplData.dwSpeakerConfig,&cplData.dwSpeakerType);
            }
        }

        pAD->waveId = dwWaveId;
        pAD->stored = cplData;
        pAD->current = cplData;
        pAD->fValid = SUCCEEDED(hr);
    }
}


STDAPI_(void) ApplyCurrentSettings(LPAUDDATA pAD)
{
    HRESULT hr = S_OK;

    if (pAD && pAD->fValid)        // Only apply changes if there are changes to be applied
    {
        if (memcmp(&pAD->stored,&pAD->current,sizeof(CPLDATA)))
        {
            hr = DSSetCplValues(pAD->devGuid, pAD->fRecord, &pAD->current);

            if (SUCCEEDED(hr))
            {
                pAD->stored = pAD->current;
            }
        }
    }
}

typedef BOOL (WINAPI* UPDATEDDDLG)(HWND,HINSTANCE,const TCHAR *,LPTSTR,BOOL);

STDAPI_(BOOL) RunUpgradedDialog(HWND hwnd, HINSTANCE hInst, const TCHAR *szHelpFile, LPTSTR szDeviceName, BOOL fRecord)
{
    BOOL            fUsedUpgradedDLG = FALSE;
    TCHAR            path[_MAX_PATH];
    UPDATEDDDLG        UpdatedDialog;
    HMODULE         hModule;

    GetSystemDirectory(path, sizeof(path)/sizeof(TCHAR));
    lstrcat(path, TEXT("\\DSNDDLG.DLL") );
    
    hModule = LoadLibrary(path);

    if (hModule)
    {
        UpdatedDialog = (UPDATEDDDLG) GetProcAddress( hModule,"DSAdvancedAudio");
    
        if (UpdatedDialog)
        {
            fUsedUpgradedDLG = UpdatedDialog(hwnd,hInst,szHelpFile,szDeviceName,fRecord);
        }

        FreeLibrary( hModule );
    }

    return fUsedUpgradedDLG;
}

HRESULT CheckDSAccelerationPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet)
{
    HRESULT hr;

    DWORD dwHWLevel = gAudData.dwDefaultHWLevel;
    hr = DSGetAcceleration(guidDevice, fRecord, &dwHWLevel);

    if (phrGet)
    {
        *phrGet = hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = DSSetAcceleration(guidDevice, fRecord, dwHWLevel);
    } //end if Get is OK

    return (hr);
}

HRESULT CheckDSSrcQualityPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet)
{
    HRESULT hr;

    DWORD dwSRCLevel = DEFAULT_SRC_LEVEL;
    hr = DSGetSrcQuality(guidDevice, fRecord, &dwSRCLevel);

    if (phrGet)
    {
        *phrGet = hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = DSSetSrcQuality(guidDevice, fRecord, dwSRCLevel);
    } //end if Get is OK

    return (hr);
}

HRESULT CheckDSSpeakerConfigPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet)
{
    HRESULT hr;

    DWORD dwSpeakerConfig = SPEAKERS_DEFAULT_CONFIG;
    DWORD dwSpeakerType = SPEAKERS_DEFAULT_TYPE;
    hr = DSGetSpeakerConfigType(guidDevice, fRecord, &dwSpeakerConfig, &dwSpeakerType);

    if (phrGet)
    {
        *phrGet = hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = DSSetSpeakerConfigType(guidDevice, fRecord, dwSpeakerConfig, dwSpeakerType);
    } //end if Get is OK

    return (hr);
}

STDAPI_(void) AdvancedAudio(HWND hwnd, HINSTANCE hInst, const TCHAR *szHelpFile, 
                            DWORD dwWaveId, LPTSTR szDeviceName, BOOL fRecord)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[3];
    int page;
    TCHAR str[255];
    HMODULE hModDirectSound = NULL;
    HRESULT hrAccelGet = E_FAIL;
    HRESULT hrQualityGet = E_FAIL;
    HRESULT hrSpeakerConfigGet = E_FAIL;
    bool fDisplayGFXTab = false;

    if (!RunUpgradedDialog(hwnd,hInst,szHelpFile,szDeviceName,fRecord))
    {
        //load DirectSound
        hModDirectSound = LoadLibrary(TEXT("dsound.dll"));
        if (hModDirectSound)
        {
            // Initialize gAudData
            memset(&gAudData,0,sizeof(AUDDATA));
            gAudData.dwDefaultHWLevel = MAX_HW_LEVEL;
            gAudData.fRecord = fRecord;

            // If not a Capture device, check if we can read any of the DirectSound device settings
            if (!fRecord && SUCCEEDED(DSGetGuidFromName(szDeviceName, fRecord, &gAudData.devGuid)))
            {
                CheckDSAccelerationPriv(gAudData.devGuid, fRecord, &hrAccelGet);

                CheckDSSrcQualityPriv(gAudData.devGuid, fRecord, &hrQualityGet);

                CheckDSSpeakerConfigPriv(gAudData.devGuid, fRecord, &hrSpeakerConfigGet);
            }

            // Check if we should show the GFX tab
            UINT uMixId;
            if( !fRecord )
            {
                if (!mixerGetID(HMIXEROBJ_INDEX(dwWaveId), &uMixId, MIXER_OBJECTF_WAVEOUT) &&
                    GFXUI_CheckDevice(uMixId, GFXTYPE_RENDER))
                {
                    fDisplayGFXTab = true;
                }
            }
            else
            {
                if (!mixerGetID(HMIXEROBJ_INDEX(dwWaveId), &uMixId, MIXER_OBJECTF_WAVEIN) &&
                    GFXUI_CheckDevice(uMixId, GFXTYPE_CAPTURE))
                {
                    fDisplayGFXTab = true;
                }
            }
 
            // If there's anything to display
            if (fDisplayGFXTab || SUCCEEDED(hrAccelGet) || SUCCEEDED(hrQualityGet) ||
                SUCCEEDED(hrSpeakerConfigGet))
            {
                ghInst = hInst;
                gszHelpFile = szHelpFile;

                // Get the current settings
                GetCurrentSettings(&gAudData, dwWaveId, szDeviceName, fRecord);

                // Now, add the property sheets
                page = 0;

                // Only add speaker configuration if we're not in record mode
                if (!fRecord)
                {
                    if (SUCCEEDED(hrSpeakerConfigGet))
                    {
                        memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                        psp[page].dwSize = sizeof(PROPSHEETPAGE);
                        psp[page].dwFlags = PSP_DEFAULT;
                        psp[page].hInstance = ghInst;
                        psp[page].pszTemplate = MAKEINTRESOURCE(IDD_SPEAKERS);
                        psp[page].pfnDlgProc = SpeakerHandler;
                        page++;
                    }
                }

                // Always check to add performance sheet
                if (SUCCEEDED(hrAccelGet) || SUCCEEDED(hrQualityGet))
                {
                    memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                    psp[page].dwSize = sizeof(PROPSHEETPAGE);
                    psp[page].dwFlags = PSP_DEFAULT;
                    psp[page].hInstance = ghInst;
                    psp[page].pszTemplate = MAKEINTRESOURCE(IDD_PLAYBACKPERF);
                    psp[page].pfnDlgProc = PerformanceHandler;
                    page++;
                }

                // Always check to add GFX sheet
                if (fDisplayGFXTab)
                {
                    memset(&psp[page],0,sizeof(PROPSHEETPAGE));
                    psp[page].dwSize = sizeof(PROPSHEETPAGE);
                    psp[page].dwFlags = PSP_DEFAULT;
                    psp[page].hInstance = ghInst;
                    psp[page].pszTemplate = MAKEINTRESOURCE(EFFECTSDLG);
                    psp[page].pfnDlgProc = SoundEffectsDlg;
                    page++;
                }

                LoadString( hInst, IDS_ADVAUDIOTITLE, str, sizeof( str )/sizeof(TCHAR) );

                memset(&psh,0,sizeof(psh));
                psh.dwSize = sizeof(psh);
                psh.dwFlags = PSH_DEFAULT | PSH_PROPSHEETPAGE; 
                psh.hwndParent = hwnd;
                psh.hInstance = ghInst;
                psh.pszCaption = str;
                psh.nPages = page;
                psh.nStartPage = 0;
                psh.ppsp = psp;

                PropertySheet(&psh);
            }
            else
            {
                TCHAR szCaption[MAX_PATH];
                TCHAR szMessage[MAX_PATH];
                bool fAccessDenied;

                fAccessDenied = (hrAccelGet == DSERR_ACCESSDENIED) || (hrQualityGet == DSERR_ACCESSDENIED) ||
                    (hrSpeakerConfigGet == DSERR_ACCESSDENIED);

                LoadString(hInst,IDS_ERROR,szCaption,sizeof(szCaption)/sizeof(TCHAR));
                LoadString(hInst,fAccessDenied ? IDS_ERROR_DSPRIVS : IDS_ERROR_DSGENERAL,szMessage,sizeof(szMessage)/sizeof(TCHAR));
                MessageBox(hwnd,szMessage,szCaption,MB_OK|MB_ICONERROR);
            }

            FreeLibrary(hModDirectSound);
        } //end if DS loaded
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\advaudio.h ===
//--------------------------------------------------------------------------;
//
//  File: advaudio.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef ADVAUDIO_HEADER
#define ADVAUDIO_HEADER

typedef struct CPLDATA
{
	DWORD dwHWLevel;
	DWORD dwSRCLevel;
	DWORD dwSpeakerConfig;
	DWORD dwSpeakerType;
} CPLDATA, *LPCPLDATA;


typedef struct AUDDATA
{
	GUID		devGuid;
	BOOL		fValid;
    BOOL        fRecord;
    DWORD       waveId;
	CPLDATA		stored;
	CPLDATA		current;
    DWORD       dwDefaultHWLevel;     // Obtain the default acceleration from DSound
} AUDDATA, *LPAUDDATA;


STDAPI_(void) AdvancedAudio(HWND hWnd, HINSTANCE hInst, const TCHAR *szHelpFile, 
                            DWORD dwWaveId, LPTSTR szDeviceName, BOOL fRecord);
STDAPI_(void) ToggleApplyButton(HWND hWnd);
STDAPI_(void) ApplyCurrentSettings(LPAUDDATA pAD);
HRESULT CheckDSAccelerationPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet);
HRESULT CheckDSSrcQualityPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet);
HRESULT CheckDSSpeakerConfigPriv(GUID guidDevice, BOOL fRecord, HRESULT *phrGet);

extern AUDDATA		gAudData;
extern HINSTANCE	ghInst;
extern const TCHAR*	gszHelpFile;

#endif // ADVAUDIO_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\copy.c ===
/*
 *  copy.c - Copy routine for WinDosSetup
 *  Todd Laney
 *
 *  Modification History:
 *
 *  6/03/91 Vlads        Change copy process to incorporate new Install API
 *
 *  3/24/89  Toddla      Wrote it
 *
 *
 *  notes:
 *   we now use the LZCopy stuff for compression
 *   we now set the crit error handler ourselves so CHECKFLOPPY is
 *   NOT defined
 */

#include <windows.h>

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <mmsystem.h>

#include "drivers.h"
#include "sulib.h"
//#include <ver.h>


#define MAX_COPY_ATTEMPTS  15

/*
 *  Maximum number of install disks we support
 */

#define MAX_DISKS 100

/*
 *  Flags for VerInstallFile
 */

#define FORCEABLE_FLAGS  (VIF_MISMATCH + VIF_SRCOLD + VIF_DIFFLANG + VIF_DIFFTYPE + VIF_DIFFCODEPG )

/**********************************************************************
 *
 * Local function prototypes.
 *
 **********************************************************************/

 // Retrieve disk path for logical disk

 BOOL GetDiskPath(LPTSTR Disk, LPTSTR szPath);

 // Convert VIF_... to ERROR... return codes

 UINT ConvertFlagToValue(DWORD dwFlags);

 // Do the work of trying to copy a file

 LONG TryCopy(LPTSTR    szSrc,     // Full source file path
              LPTSTR    szLogSrc,  // Logical source name
              LPTSTR    szDestPath,// Destination path
              FPFNCOPY fpfnCopy); // Callback routine

 #ifdef CHECK_FLOPPY
 BOOL NEAR IsDiskInDrive(int iDisk);
 #endif

 // GLOBAL VARIABLES

 //  directory where windows will be setup to

 TCHAR szSetupPath[MAX_PATH];

 // directory where the root of the setup disks are!

 TCHAR szDiskPath[MAX_PATH];

 // Name of driver being copied (or oemsetup.inf)

 TCHAR szDrv[120];

/*
 *  global vars used by DosCopy
 */
 static LPTSTR    lpBuf = NULL;   // copy buffer
 static int      iBuf = 0;       // usage count
 static UINT     nBufSize;
 BOOL     bRetry = FALSE;
 BOOL     bQueryExist;

 extern BOOL bCopyEvenIfOlder;  // From DRIVERS.C


 BOOL DefCopyCallback(int msg, DWORD_PTR n, LPTSTR szFile)
 {
     return FC_IGNORE;
 }



/*  UINT FileCopy (szSource, szDir, fpfnCopy, UINT fCopy)
 *
 *  This function will copy a group of files to a single destination
 *
 *  ENTRY:
 *
 *  szSourc      : pointer to a SETUP.INF section
 *  szDir        : pointer to a string containing the target DIR
 *  fpfnCopy     : callback function used to notify called of copy status
 *  fCopy        : flags
 *
 *      FC_SECTION            - szSource is a section name
 *      FC_LIST               - szSource is a pointer to a char **foo;
 *      FC_LISTTYPE           - szSource is a pointer to a char *foo[];
 *      FC_FILE               - szSource is a file name.
 *      FC_QUALIFIED          - szSource is a fully qualified file name.
 *      FC_DEST_QUALIFIED     - szDir is fully qualified. Don't expand this.
 *      FC_CALLBACK_WITH_VER  - call back if file exists and report version information.
 *
 *  NOTES:
 *      if szSource points to a string of the form '#name' the section
 *      named by 'name' will be used as the source files
 *
 *      the first field of each line in the secion is used as the name of the
 *      source file.  A file name has the following form:
 *
 *          #:name
 *
 *          #       - Disk number containing file 1-9,A-Z
 *          name    - name of the file, may be a wild card expression
 *
 *  Format for copy status function
 *
 *  BOOL FAR PASCAL CopyStatus(int msg, int n, LPSTR szFile)
 *
 *      msg:
 *          COPY_ERROR          error occured while copying file(s)
 *                              n      is the DOS error number
 *                              szFile is the file that got the error
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_STATUS         Called each time a new file is copied
 *                              n      is the percent done
 *                              szFile is the file being copied
 *                              return: TRUE ok, FALSE abort copy
 *
 *          COPY_INSERTDISK     Please tell the user to insert a disk
 *                              n      is the disk needed ('1' - '9')
 *                              return: TRUE try again, FALSE abort copy
 *
 *          COPY_QUERYCOPY      Should this file be copied?
 *                              n      line index in SETUP.INF section (0 based)
 *                              szFile is the line from section
 *                              return: TRUE copy it, FALSE dont copy
 *
 *          COPY_START          Sent before any files are copied
 *
 *          COPY_END            Sent after all files have been copied
 *                              n   is dos error if copy failed
 *
 *          COPY_EXISTS         Sent if the FC_CALL_ON_EXIST bit was set
 *                              and the file exists at the destination
 *                              given for the filecopy.
 *
 *
 *  EXIT: returns TRUE if successful, FALSE if failure.
 *
 */

UINT FileCopy (LPTSTR szSource, LPTSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy)
{
   int   err = ERROR_SUCCESS;     // Return code from this routine

   TCHAR  szPath[MAX_PATH];
   TCHAR  szLogSrc[MAX_PATH];
   TCHAR  szSrc[MAX_PATH];

   LPTSTR pFileBegin;              // First file

   LPTSTR * List;                  // Handle lists of files
   LPTSTR * ListHead;

   int   nDisk;                   // The disk we're on

   int   cntFiles = 0;            // How many files we've got to do

   if (fpfnCopy == NULL) {
      fpfnCopy = DefCopyCallback;
   }

   if (!szSource || !*szSource || !szDir || !*szDir) {
      return ERROR_FILE_NOT_FOUND;
   }


  /*
   *  fix up the drive in the destination
   */

   if ( fCopy & FC_DEST_QUALIFIED ) {
      lstrcpy(szPath, szDir);
      fCopy &= ~FC_DEST_QUALIFIED;
   } else {
      ExpandFileName(szDir, szPath);
   }

   if (szSource[0] == TEXT('#') && fCopy == FC_FILE) {
       fCopy = FC_SECTION;
       ++szSource;
   }

   switch (fCopy) {
       case FC_SECTION:
       {
           szSource = infFindSection(NULL,szSource);

          /*
           * We are called even when the section doesn't exist
           */

           if (szSource == NULL) {
               return ERROR_SUCCESS;
           }

           fCopy = FC_LIST;
       }
       // fall through to FC_LIST

       case FC_LIST:
          pFileBegin = szSource;
          cntFiles = infLineCount(szSource);
          break;

       case FC_LISTTYPE:
          ListHead = List = (LPTSTR far *)szSource;
          pFileBegin = *ListHead;
          while ( *List++ )           // Count files to be copied.
             ++cntFiles;
          break;

       case FC_FILE:
       case FC_QUALIFIED:
       default:
          pFileBegin = szSource;
          cntFiles = 1;
    }

  /*
   *  walk all files in the list and call TryCopy ....
   *
   *  NOTES:
   *      we must walk file list sorted by disk number.
   *      we should use the disk that is currently inserted.
   *      we should do a find first/find next on the files????
   *      we need to check for errors.
   *      we need to ask the user to insert disk in drive.
   *
   */

   (*fpfnCopy)(COPY_START,0,NULL);

  /*
   *  Go through all possible disks: 1 to 100 and A to Z (26)
   */

   for (nDisk = 1;
        err == ERROR_SUCCESS && (cntFiles > 0) &&
            (nDisk <= MAX_DISKS + 'Z' - 'A' + 1);
        nDisk++)
   {
      TCHAR Disk[10];              // Maximum string is "100:"
      LPTSTR pFile;
      int FileNumber;             // Which file in the list we're on
                                  // (to pass to callback)

      pFile      = pFileBegin;    // Start at first file
      List       = ListHead;      // Handled chained lists
      FileNumber = 0;             // Informational for callback - gives
                                  // which file in list we're on
     /*
      *  Work out the string representing our disk letter
      */

      if (nDisk > MAX_DISKS) {
          Disk[0] = TEXT('A') + nDisk - MAX_DISKS - 1;
          Disk[1] = TEXT('\0');
      } else {
          _itow(nDisk, Disk, 10);
      }

      wcscat(Disk, TEXT(":"));

      for (;
           err == ERROR_SUCCESS && pFile;
           FileNumber++,
           pFile = fCopy == FC_LISTTYPE ? *(++List) :
                   fCopy == FC_LIST ? infNextLine(pFile) :
                   NULL)
      {
        /*
         *  We have to reset high bit of first byte because it could be set
         *  by translating service in OEM setup to show that file name was
         *  mapped
         */

         *pFile = toascii(*pFile);


        /*
         *  should we copy this file?
         *  copy the files in disk order.
         */

         if (_wcsnicmp(pFile, Disk, wcslen(Disk)) == 0 || // File has disk
                                                         // number and we're
                                                         // on that disk
             RemoveDiskId(pFile) == pFile &&
                nDisk == 1 && *pFile ||                  // First disk and
                                                         // no disk number

             fCopy == FC_QUALIFIED) {                    // Fully qualified


            /*
             * done with a file. decrement count.
             */

             cntFiles--;

             lstrcpy(szDrv, RemoveDiskId(pFile));

             switch ((*fpfnCopy)(COPY_QUERYCOPY, FileNumber, pFile))
             {
                 case CopyCurrent:                // Skip

                         continue;

                 case CopyNeither:

                         err = ERROR_FILE_EXISTS; // File already exists

                 case CopyNew:
                         break;

                 default:
                         break;

             }

            /*
             *  Pick up bad return code from switch
             */

             if (err != ERROR_SUCCESS) {
                 break;
             }

            /*
             *  now we convert logical dest into a physical
             *    (unless FC_QUALIFIED)
             */

             infParseField(pFile, 1, szLogSrc);    // logical source

             if ( fCopy != FC_QUALIFIED ) {
                ExpandFileName(szLogSrc, szSrc); // full physical source
             } else {
                lstrcpy(szSrc,szLogSrc);
             }


            /*
             *  Attempt copy
             */

             err = TryCopy(szSrc,      // Qualified Source file
                           szLogSrc,   // Logical source file name (with disk #)
                           szPath,     // Path for directory to install in
                           fpfnCopy);  // Copy callback function

            /*
             *  If failed to find file try the windows directory
             */

             if (err != ERROR_SUCCESS) {
                 break;
             }

         } /* End if dor if DoCopy */
      }
   }

   (*fpfnCopy)(COPY_END,err,NULL);

   return err;
}

/**********************************************************************
 *
 *  TryCopy
 *
 *  Copy a single file from source to destination using the VerInstallFile
 *  API - interpreting the return code as :
 *
 *    ERROR_SUCCESS  - OK
 *    Other          - failure type
 *
 **********************************************************************/

LONG TryCopy(LPTSTR    szSrc,      // Full expanded source file path
             LPTSTR    szLogSrc,   // Logical source name
             LPTSTR    szDestPath, // Destination path
             FPFNCOPY fpfnCopy)   // Callback routine

{
    DWORD wTmpLen;
    DWORD dwRetFlags;
    TCHAR  szTempFile[MAX_PATH];
    TCHAR  szErrFile[MAX_PATH];
    TCHAR  DriversPath[MAX_PATH];
    BOOL  bRetVal;               // Return code from callback
    LPTSTR szFile;
    TCHAR  szSrcPath[MAX_PATH];
    int   iAttemptCount;
    WORD  wVerFlags;
    LONG  err;

   /*
    *  Fix up destination if file is a kernel driver
    */

    if (IsFileKernelDriver(szSrc) && szDestPath) 
    {
        wcscpy(DriversPath, szDestPath);
        wcscat(DriversPath, TEXT("\\drivers"));
        szDestPath = DriversPath;
    }

   /*
    *  Create file name from current string
    */

    szFile = FileName(szSrc);
    lstrcpy(szSrcPath, szSrc);
    StripPathName(szSrcPath);

    for(iAttemptCount = 0, wVerFlags = 0 ;
        iAttemptCount <= MAX_COPY_ATTEMPTS;
        iAttemptCount++) {

        HCURSOR  hcurPrev;             // Saved cursor state

        // Central operation - attempt to install file szFile in directory
        // pointed by szPath from directory pointed by szSrc
        // If operation will fail but with possibility to force install
        // in last parameter buffer we will have temporary file name ==>
        // therefore we can avoid excessive copying.
        // NOTE: now szFile consists of only file name and other buffers
        // only path names.

        wTmpLen = MAX_PATH;

        hcurPrev = SetCursor(LoadCursor(NULL,IDC_WAIT));
        dwRetFlags = VerInstallFile(wVerFlags,
                                    (LPTSTR) szFile,
                                    (LPTSTR) szFile,
                                    (LPTSTR) szSrcPath,
                                    (LPTSTR) szDestPath,
                                    (LPTSTR) szDestPath,
                                    (LPTSTR) szTempFile,
                                    (LPDWORD) &wTmpLen);
        SetCursor(hcurPrev);

       /*
        *  Operation failed if at least one bit of return flags is non-zero
        *  That is unusual but defined so in Version API.
        */

        if ( !dwRetFlags )
            return ERROR_SUCCESS;    // If no errors - goto next file


       /*
        *  If flag MISMATCH is set - install can be forced and we have
        *  temporary file in destination subdirectory
        */

        if ( dwRetFlags  &  VIF_MISMATCH ) {

            if ( (dwRetFlags & VIF_SRCOLD) && (!bCopyEvenIfOlder) ) {

              /*
               *  If we need not call back with question - automatically
               *  force install with same parameters.
               *  michaele, *only* if src file is *newer* than dst file
               */

               DeleteFile(szTempFile);

               return ERROR_SUCCESS;
            }

           /*
            *  If we need not call back with question - automatically
            *  force install with same parameters.
            */

            wVerFlags |= VIFF_FORCEINSTALL;
            iAttemptCount--;             // Make sure we get another go.
            continue;

        }   /* End if MISMATCH */

       /*
        *  If real error occured - call back with error file info
        *  In all dialogs we use our error codes - so I will convert
        *  flags returned from Ver API to ours.
        */

        err = ConvertFlagToValue(dwRetFlags);


       /*
        *  If source path or file is nor readable - try to change disk
        */

        if ( dwRetFlags & VIF_CANNOTREADSRC )
        {
          /*
           *  Now new path in szSrc so I deleted logic for creating it
           */

           if (RemoveDiskId(szLogSrc) == szLogSrc)

             /*
              *  if disk # not provided, default to 1
              */

              bRetVal = (*fpfnCopy)(COPY_INSERTDISK, (DWORD_PTR)"1", szSrcPath);
           else
              bRetVal = (*fpfnCopy)(COPY_INSERTDISK, (DWORD_PTR)szLogSrc, szSrcPath);


           switch (bRetVal)
              {
              case FC_RETRY:
                  continue;              // and try again...

              case FC_ABORT:
                  return ERROR_FILE_NOT_FOUND;

              case FC_IGNORE:
                  break;
              }
        }

        ExpandFileName(szLogSrc, szErrFile);

#if WINDOWSDIR

        if (!*bWindowsDir  &&
            err != FC_ERROR_LOADED_DRIVER &&
            err != ERROR_DISK_FULL)
        {
            GetWindowsDirectory(szPath, MAX_PATH);
            *bWindowsDir = TRUE;
            continue;
        }

#endif // WINDOWSDIR

        switch ((*fpfnCopy)(COPY_ERROR, err, szErrFile)) {

            case FC_IGNORE:
                return ERROR_SUCCESS;

            case FC_RETRY:
                break;

            case FC_ABORT:
                return ERROR_FILE_NOT_FOUND;
        }
    } // End of attempts

    return err;
}

/*  BOOL GetDiskPath(Disk, szPath)
 *
 *  This function will retrive the full path name for a logical disk
 *
 *  The code reads the [disks] section of SETUP.INF and looks for
 *  n = path where n is the disk char.  NOTE the disk '0' defaults to
 *  the root windows directory.
 *
 *  ENTRY:
 *
 *  cDisk        : what disk to find 0-9,A-Z
 *  szPath       : buffer to hold disk path
 *
 *  Returns :
 *     TRUE if a disk path was found
 *     FALSE if there was no disk specified (ie no ':'
 *
 */

BOOL GetDiskPath(LPTSTR Disk, LPTSTR szPath)
{
   TCHAR    ach[MAX_PATH];
   TCHAR    szBuf[MAX_PATH];
   int i;


  /*
   *  Check to see if there is actually a disk id.
   *  If not return FALSE
   */

   if (RemoveDiskId(Disk) == Disk) {
       return FALSE;
   }

  /*
   *  Create our copy of the disk id
   */

   for (i = 0; Disk[i] != TEXT(':'); i++) {
       ach[i] = Disk[i];
   }
   ach[i] = TEXT('\0');


  /*
   *  Zero disk letter means windows setup directory
   */

   if (_wcsicmp(ach, TEXT("0")) == 0) {

      /*
       * return the windows setup directory
       */

       lstrcpy(szPath,szSetupPath);
       return TRUE;
   }

  /*
   *  now look in the [disks] section for a full path name
   *
   *  This is a pretty bogus concept and is not supported
   *  in win 32 style disks section [Source Media Descriptions]
   */

   if ( !infGetProfileString(NULL,DISK_SECT,ach,szPath) &&
        !infGetProfileString(NULL,OEMDISK_SECT,ach,szPath)) {

       lstrcpy(szPath, szDiskPath);
   } else {
       infParseField(szPath,1,szPath);

      /*
       *  is the path relative? is so prepend the szDiskPath
       */

       if (szPath[0] == TEXT('.') || szPath[0] == TEXT('\0')) {
           lstrcpy(szBuf,szDiskPath);
           catpath(szBuf,szPath);
           lstrcpy(szPath,szBuf);
       }

   }

   return TRUE;
}


/*  BOOL FAR PASCAL ExpandFileName(LPSTR szFile, LPTSTR szPath)
 *
 *  This function will retrive the full path name for a file
 *  it will expand, logical disk letters to pyshical ones
 *  will use current disk and directory if non specifed.
 *
 *  if the drive specifed is 0-9, it will expand the drive into a
 *  full pathname using GetDiskPath()
 *
 *  IE  0:system ==>  c:windows\system
 *      1:foo.txt     a:\foo.txt
 *
 *  ENTRY:
 *
 *  szFile       : File name to expand
 *  szPath       : buffer to hold full file name
 *
 */
BOOL ExpandFileName(LPTSTR szFile, LPTSTR szPath)
{
   TCHAR    szBuf[MAX_PATH*2];

   if (GetDiskPath(szFile, szBuf)) {
       lstrcpy(szPath,szBuf);
       if (szFile[2])
          catpath(szPath,szFile + 2);
   } else {
       lstrcpy(szPath,szFile);
   }
   return TRUE;
}




void catpath(LPTSTR path, LPTSTR sz)
{
   //
   // Remove any drive letters from the directory to append
   //
   sz = RemoveDiskId(sz);

   //
   // Remove any current directories ".\" from directory to append
   //
   while (sz[0] == TEXT('.') && SLASH(sz[1]))
      sz += 2;

   //
   // Dont append a NULL string or a single "."
   //
   if (*sz && ! (sz[0] == TEXT('.') && sz[1] == 0))
   {
      // Add a slash separator if necessary.
      if ((! SLASH(path[lstrlen(path) - 1])) &&    // slash at end of path
          ((path[lstrlen(path) - 1]) != TEXT(':')) &&    // colon at end of path
          (! SLASH(sz[0])))                        // slash at beginning of file
         lstrcat(path, CHSEPSTR);

      lstrcat(path, sz);
   }
}

/*
 *  Return a pointer to the file name part of a string
 */

LPTSTR FileName(LPTSTR szPath)
{
   LPTSTR   sz;

   for (sz=szPath; *sz; sz++)
      ;

   for (; sz>=szPath && !SLASH(*sz) && *sz!=TEXT(':'); sz--)
      ;

   return ++sz;
}

/*
 *  Return the portion of a file name following the disk (ie anything
 *  before the colon).
 *  If there is no colon just return a pointer to the original string
 */

LPTSTR RemoveDiskId(LPTSTR szPath)
{
   LPTSTR sz;

   for (sz = szPath; *sz; sz++) {
       if (*sz == TEXT(':')) {
           return sz + 1;
       }
   }

   return szPath;
}

LPTSTR StripPathName(LPTSTR szPath)
{
    LPTSTR   sz;

    sz = FileName(szPath);

    if (sz > szPath+1 && SLASH(sz[-1]) && sz[-2] != TEXT(':'))
       sz--;

    *sz = 0;
    return szPath;
}

/*
 *  See if a file is a kernel driver.  Unfortunately the VersionInfo APIs
 *  don't seem coded up to take care of this at the moment so we just check
 *  to see if the file extension is ".SYS"
 */

 BOOL IsFileKernelDriver(LPTSTR szPath)
 {
     TCHAR drive[MAX_PATH];
     TCHAR dir[MAX_PATH];
     TCHAR fname[MAX_PATH];
     TCHAR ext[MAX_PATH];

     lsplitpath(szPath, drive, dir, fname, ext);
     return !_wcsicmp(ext, TEXT(".sys"));
 }


/**************************************************************************
 *
 * This function converts returned flags from Ver API to the numerical
 * error codes used in SETUP.
 *
 ***************************************************************************/

UINT ConvertFlagToValue(DWORD dwFlags)
{
    if ( ! dwFlags  )
       return(NO_ERROR);
    if ( dwFlags & VIF_CANNOTREADSRC )
       return(ERROR_FILE_NOT_FOUND);
    if ( dwFlags & VIF_OUTOFMEMORY )
       return(ERROR_OUTOFMEMORY);
    if ( dwFlags & VIF_ACCESSVIOLATION )
       return(ERROR_ACCESS_DENIED);
    if ( dwFlags & VIF_SHARINGVIOLATION )
       return(ERROR_SHARING_VIOLATION);
    if ( dwFlags & VIF_FILEINUSE)
       return(FC_ERROR_LOADED_DRIVER);

    return(ERROR_CANNOT_COPY);    // General error
}



#ifdef CHECK_FLOPPY
/*--------------------------------------------------------------------------

  IsValidDiskette() -

--------------------------------------------------------------------------*/

#define CBSECTORSIZE   512
#define INT13_READ   2

BOOL IsValidDiskette(int iDrive)
{
   TCHAR       buf[CBSECTORSIZE];

   iDrive |= 0x0020;   // make lower case

   iDrive -= 'a';   // A = 0, B = 1, etc. for BIOS stuff

   return MyReadWriteSector(buf, INT13_READ, iDrive, 0, 0, 1);
}



/*  BOOL IsDiskInDrive(char cDisk)
 *
 *  Is the specifed disk in the drive
 *
 *  ENTRY:
 *
 *  cDisk        : what disk required to be in the drive (logical)
 *
 *  return TRUE if the specifed disk is in the drive
 *         FALSE if the wrong disk is in the drive or disk error
 *
 */
BOOL IsDiskInDrive(int iDisk)
{

   if ((iDisk  >= 'A' && iDisk <= 'Z') ||
      (iDisk  >= 'a' && iDisk <= 'z'))
      {
      if (DosRemoveable(iDisk))
         {
         if (!IsValidDiskette(iDisk))
            return FALSE;
         }
      return TRUE;
      }
   return TRUE;   // for non drive letters assume a path
                  // and thus always in.
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\cdaudio.c ===
/*
 ***************************************************************
 *  sprop.c
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Displays the Simple media properties
 *
 *  History:
 *
 *  July 1994 -by- VijR (Created)
 *        
 ***************************************************************
 */

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <mmddk.h>
#include <mmreg.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"
#include "mmcpl.h"

#include <winerror.h>

//for digital cd audio
#include "devguid.h"
#include "setupapi.h"
#include "cfgmgr32.h"
#include "winioctl.h"
#include "tchar.h"

const TCHAR gszCreateCDFile[] = TEXT("\\\\.\\%c:");

#define MYREGSTR_PATH_MEDIA  TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources") 
const TCHAR gszRegstrCDAPath[] = MYREGSTR_PATH_MEDIA TEXT("\\mci\\cdaudio");
const TCHAR gszUnitEnum[] = TEXT("%s\\unit %d");
const TCHAR gszSettingsKey[] = TEXT("Volume Settings");
const TCHAR gszDefaultCDA[] = TEXT("Default Drive");

const TCHAR gszRegstrCDROMPath[] = TEXT("System\\CurrentControlSet\\Services\\Class\\CDROM\\");
const TCHAR gszDigitalPlay[] = TEXT("DigitalAudioPlay");

const TCHAR gszRegstrDrivePath[] = TEXT("Enum\\SCSI");

#define CDA_VT_UNSET 0
#define CDA_VT_AUX  1
#define CDA_VT_MIX  2


#define CDROM_DIGITAL_PLAY_ENABLED      0x01
#define CDROM_DIGITAL_PLAY_CAPABLE      0x02
#define CDROM_DIGITAL_DEVICE_KNOWN      0x04


typedef struct {                // This struct is used in other places DO NOT CHANGE
    DWORD   unit;
    DWORD   dwVol;
} CDAREG, *PCDAREG;

typedef struct {                // This is now the local version with addition data, this can change, but has to keep the
    CDAREG              cdar;
    BOOLEAN             fDigFlags;
    BOOLEAN             DigitalEnabled;
    BOOLEAN             DigitalKnownDevice;
    BOOLEAN             oldDigEnabled;
    DWORD               dwOldVol;
    TCHAR               chDrive;
    HDEVINFO            hDevInfo;
    PSP_DEVINFO_DATA    pDevInfoData;
} CDSTATE, *PCDSTATE;


BOOL g_fWDMEnabled = FALSE;
HMODULE g_hModStorProp = NULL;

typedef LONG (WINAPI *CDROMISDIGITALPLAYBACKENABLEDPROC)(HDEVINFO,PSP_DEVINFO_DATA,BOOLEAN*);
typedef BOOL (WINAPI *CDROMKNOWNGOODDIGITALPLAYBACKPROC)(HDEVINFO,PSP_DEVINFO_DATA);
typedef LONG (WINAPI *CDROMENABLEDIGITALPLAYBACKPROC)(HDEVINFO,PSP_DEVINFO_DATA,BOOLEAN);
typedef LONG (WINAPI *CDROMDISABLEDIGITALPLAYBACKPROC)(HDEVINFO,PSP_DEVINFO_DATA);

CDROMISDIGITALPLAYBACKENABLEDPROC   _gCdromIsDigitalPlaybackEnabled = NULL;
CDROMKNOWNGOODDIGITALPLAYBACKPROC   _gCdromKnownGoodDigitalPlayback = NULL;
CDROMENABLEDIGITALPLAYBACKPROC      _gCdromEnableDigitalPlayback = NULL;
CDROMDISABLEDIGITALPLAYBACKPROC     _gCdromDisableDigitalPlayback = NULL;

void GetPrefInfo(PAUDIODLGINFO pai, HWND hDlg );

HANDLE GetHandleForDevice(LPCTSTR DeviceName)
{
    int i = 0;
    TCHAR fakeDeviceName[MAX_PATH];
    HANDLE h = INVALID_HANDLE_VALUE;
    BOOL success = FALSE;
    TCHAR buf[MAX_PATH];
    
    while (!success && i < 10)
    {
        wsprintf(buf, TEXT("DISK_FAKE_DEVICE_%d_"), i++);
        success = DefineDosDevice(DDD_RAW_TARGET_PATH,
                                  buf, 
                                  DeviceName);
        if (success)
        {
            _tcscpy(fakeDeviceName, TEXT("\\\\.\\"));
            _tcscat(fakeDeviceName, buf);
            h = CreateFile(fakeDeviceName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
            DefineDosDevice(DDD_REMOVE_DEFINITION,
                            buf,
                            NULL);
        }
    } //end while

    return h;
}

HANDLE GetHandleForDeviceInst(DEVINST DevInst)
{
    TCHAR DeviceName[MAX_PATH];
    CONFIGRET cr;
    DWORD len = MAX_PATH;

    cr = CM_Get_DevNode_Registry_Property(DevInst,
                                          CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                          NULL,
                                          DeviceName,
                                          &len,
                                          0);

    if (cr != CR_SUCCESS)
    {
        return 0;
    }
       
    return GetHandleForDevice(DeviceName);
} 

BOOL EnableCdromFunctions(HMODULE* pMod)
{
    BOOL fRet = FALSE;
    
    if (!*pMod)
    {
        *pMod = LoadLibrary(TEXT("STORPROP.DLL"));
    }

    if (*pMod)
    {
        _gCdromIsDigitalPlaybackEnabled = (CDROMISDIGITALPLAYBACKENABLEDPROC)GetProcAddress(*pMod,"CdromIsDigitalPlaybackEnabled");
        _gCdromKnownGoodDigitalPlayback = (CDROMKNOWNGOODDIGITALPLAYBACKPROC)GetProcAddress(*pMod,"CdromKnownGoodDigitalPlayback");
        _gCdromEnableDigitalPlayback = (CDROMENABLEDIGITALPLAYBACKPROC)GetProcAddress(*pMod,"CdromEnableDigitalPlayback");
        _gCdromDisableDigitalPlayback = (CDROMDISABLEDIGITALPLAYBACKPROC)GetProcAddress(*pMod,"CdromDisableDigitalPlayback");

        if (
            (_gCdromIsDigitalPlaybackEnabled)
            &&
            (_gCdromKnownGoodDigitalPlayback)
            &&
            (_gCdromEnableDigitalPlayback)
            &&
            (_gCdromDisableDigitalPlayback)
        )
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

BYTE CDAudio_GetSetDigitalFlags(PCDSTATE pcds, BYTE fSetFlags, BOOL fSet)
{
    BYTE bFlags = 0;
    BOOLEAN bEnabled = FALSE;

    if (EnableCdromFunctions(&g_hModStorProp))
    {
        bFlags = 0;

        if (fSet)
        {
            BOOLEAN bEnable = fSetFlags & CDROM_DIGITAL_PLAY_ENABLED;
            BOOLEAN bAlready = FALSE;
            _gCdromIsDigitalPlaybackEnabled(pcds->hDevInfo,pcds->pDevInfoData,&bAlready);

            if (bEnable != bAlready)
            {
                if (bEnable)
                {
                    _gCdromEnableDigitalPlayback(pcds->hDevInfo,pcds->pDevInfoData,FALSE);
                }
                else
                {
                    _gCdromDisableDigitalPlayback(pcds->hDevInfo,pcds->pDevInfoData);
                }
            }
        }

        //always do a get after a set
        _gCdromIsDigitalPlaybackEnabled(pcds->hDevInfo,pcds->pDevInfoData,&bEnabled);

        if (bEnabled)
        {
            bFlags |= CDROM_DIGITAL_PLAY_ENABLED;
        }

        if (_gCdromKnownGoodDigitalPlayback(pcds->hDevInfo,pcds->pDevInfoData))
        {
            bFlags |= CDROM_DIGITAL_DEVICE_KNOWN;
        }
    }

    return bFlags;
}

BYTE CDAudio_SetDigitalFlags(PCDSTATE pcds, BYTE fDigFlags)
{
    return CDAudio_GetSetDigitalFlags(pcds,fDigFlags,TRUE);
}

BYTE CDAudio_GetDigitalFlags(PCDSTATE pcds)
{
    return CDAudio_GetSetDigitalFlags(pcds,0,FALSE);
}


/*
 * */
void CDAudio_GetRegData(PCDSTATE pcds,ULONG uDrive)
{
    TCHAR    szRegstrCDAudio[_MAX_PATH];
    HKEY    hkTmp;
    
    if (!pcds)
    	return;
    
    wsprintf(szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, uDrive);

    pcds->cdar.dwVol = 0xFF;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE
			     , szRegstrCDAudio
			     , 0
			     , KEY_READ
			     , &hkTmp ) == ERROR_SUCCESS)
    {
	    DWORD cbCDA = sizeof(CDAREG);
	    RegQueryValueEx(hkTmp
			    , gszSettingsKey
			    , NULL
			    , NULL
			    , (LPBYTE)&pcds->cdar
			    , &cbCDA);
	    RegCloseKey(hkTmp);
    }
    
    pcds->cdar.unit = uDrive;

    pcds->fDigFlags = CDAudio_GetDigitalFlags(pcds);

    pcds->DigitalEnabled = pcds->fDigFlags & CDROM_DIGITAL_PLAY_ENABLED;
    pcds->DigitalKnownDevice = pcds->fDigFlags & CDROM_DIGITAL_DEVICE_KNOWN;

    pcds->oldDigEnabled = pcds->DigitalEnabled;
    pcds->dwOldVol = pcds->cdar.dwVol;
}

/*
 * */
void CDAudio_SetRegData(
    PCDSTATE pcds, HWND hwnd)
{
    TCHAR        szRegstrCDAudio[_MAX_PATH];
    HKEY        hkTmp;
    BYTE        bFlags = 0;

    wsprintf(szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, pcds->cdar.unit);
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE
		       , szRegstrCDAudio
		       , 0
		       , NULL
		       , 0
		       , KEY_WRITE
		       , NULL
		       , &hkTmp
		       , NULL ) == ERROR_SUCCESS)
    {
	RegSetValueEx(hkTmp
		      , gszSettingsKey
		      , 0L
		      , REG_BINARY
		      , (LPBYTE)&pcds->cdar
		      , sizeof(CDAREG));
	RegCloseKey(hkTmp);
    }

    if (pcds->DigitalEnabled)
    {
	    pcds->fDigFlags |= CDROM_DIGITAL_PLAY_ENABLED;
    }
    else
    {
	    pcds->fDigFlags &= ~CDROM_DIGITAL_PLAY_ENABLED;
    }

    bFlags = CDAudio_SetDigitalFlags(pcds,pcds->fDigFlags);

    //check for success
    if ((bFlags & CDROM_DIGITAL_PLAY_ENABLED) != (pcds->DigitalEnabled))
    {
        pcds->DigitalEnabled = bFlags & CDROM_DIGITAL_PLAY_ENABLED;
        Button_SetCheck(GetDlgItem(hwnd, IDC_CDEN_DIGAUDIO), pcds->DigitalEnabled);
    }
}

void ChangeCDVolume(PCDSTATE pcds)
{
    MCI_OPEN_PARMS  mciOpen;
    TCHAR           szElementName[4];
    TCHAR           szAliasName[32];
    DWORD           dwFlags;
    DWORD           dwAliasCount = GetCurrentTime();
    DWORD           dwRet;
    CDAREG          cdarCache;
    HKEY            hkTmp;
    TCHAR            szRegstrCDAudio[_MAX_PATH];
    
    ASSERT(pcds);

    if (pcds != NULL)
    { 
        wsprintf(szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, pcds->cdar.unit);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szRegstrCDAudio , 0 , KEY_READ , &hkTmp ) == ERROR_SUCCESS)
        {
            DWORD cbCDA = sizeof(CDAREG);
            RegQueryValueEx(hkTmp , gszSettingsKey , NULL , NULL , (LPBYTE)&cdarCache , &cbCDA);
            RegCloseKey(hkTmp);
        }
        else
        {
            cdarCache = pcds->cdar;
        }

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegstrCDAudio, 0, NULL, 0, KEY_WRITE, NULL, &hkTmp, NULL ) == ERROR_SUCCESS)
        {
            CDAREG cdar;
        
            cdar = pcds->cdar;      
            RegSetValueEx(hkTmp , gszSettingsKey , 0L , REG_BINARY , (LPBYTE)&cdar , sizeof(CDAREG));
            RegCloseKey(hkTmp);
        }

        ZeroMemory( &mciOpen, sizeof(mciOpen) );

        mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
        wsprintf( szElementName, TEXT("%c:"), pcds->chDrive );
        wsprintf( szAliasName, TEXT("SJE%lu:"), dwAliasCount );

        mciOpen.lpstrElementName = szElementName;
        mciOpen.lpstrAlias = szAliasName;

        dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS | MCI_OPEN_SHAREABLE | 
                  MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

        dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, (DWORD_PTR)(LPVOID)&mciOpen);

        if ( dwRet == MMSYSERR_NOERROR )
        {     
            mciSendCommand(mciOpen.wDeviceID, MCI_CLOSE, 0L, 0L );
        }

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE , szRegstrCDAudio , 0 , KEY_WRITE , &hkTmp ) == ERROR_SUCCESS)
        {
            RegSetValueEx(hkTmp , gszSettingsKey , 0L , REG_BINARY , (LPBYTE)&cdarCache , sizeof(CDAREG));
            RegCloseKey(hkTmp);
        }
    }
}

/*
 * */
void CDAudio_SaveState(
    HWND        hwnd)
{
    PCDSTATE pcds;
    pcds = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);

    if (pcds)
    { 
        CDAudio_SetRegData(pcds,hwnd);
        pcds->oldDigEnabled = pcds->DigitalEnabled;
        pcds->dwOldVol = pcds->cdar.dwVol;

        ChangeCDVolume(pcds);
    }
}

void CDAudio_DigitalPlaybackEnable(HWND hDlg)
{
    PCDSTATE pcds;
    pcds = (PCDSTATE)GetWindowLongPtr(hDlg,DWLP_USER);   

    if (pcds)
    {
        pcds->DigitalEnabled = (BOOLEAN)Button_GetCheck(GetDlgItem(hDlg, IDC_CDEN_DIGAUDIO));
    }
}

ULONG MatchDriveToDevInst(DWORD DevInst)
{
    HANDLE hMatch = INVALID_HANDLE_VALUE;
    STORAGE_DEVICE_NUMBER sDevice, sMatch;
    DWORD bytesReturned;
    ULONG uRet = 0;

    if (INVALID_HANDLE_VALUE != (hMatch = 
                                 GetHandleForDeviceInst(DevInst)))
    {
        if (DeviceIoControl(hMatch,
                             IOCTL_STORAGE_GET_DEVICE_NUMBER,
                             NULL,
                             0,
                             &sMatch,
                             sizeof(STORAGE_DEVICE_NUMBER),
                             &bytesReturned,
                             NULL))
        {
            uRet = sMatch.DeviceNumber;
        }

        CloseHandle(hMatch);
    }

    return uRet;
}

/*
 * */
DWORD CDAudio_InitDrives(HWND hwnd, PCDSTATE pcds)
{
    DWORD cch;
    DWORD cCDs = 0;
    ULONG uDrive = 0;

    uDrive = MatchDriveToDevInst(pcds->pDevInfoData->DevInst);
    CDAudio_GetRegData(pcds,uDrive);

    if (cch = GetLogicalDriveStrings(0, NULL))
    {
	LPTSTR   lpDrives,lp;
	lp = lpDrives = GlobalAllocPtr(GHND, cch * sizeof(TCHAR));
	cch = GetLogicalDriveStrings(cch, lpDrives);
	if (lpDrives && cch)
	{
	    // upon the last drive enumerated, there will be a double
	    // null termination
	    while (*lpDrives)
	    {
		    if (GetDriveType(lpDrives) == DRIVE_CDROM)
		    {
			    int   i;
			    LPTSTR lp;
			    lp = CharUpper(lpDrives);
			    
			    while (*lp != TEXT('\\'))
			        lp = CharNext(lp);
			    
			    while (*lp)
			    {
			        *lp = TEXT(' ');
			        lp = CharNext(lp);
			    }
			        
			    if (cCDs == uDrive)
			    {
                   pcds->chDrive = lpDrives[0];
			    }

		        cCDs++;
		    }
		    for ( ; *lpDrives ; lpDrives++ );
		    lpDrives++;
	    }
	}
	
	if (lp)
	    GlobalFreePtr(lp);

    }
    return cCDs;
}

//
//  Determines what device is currently being used by the mapper to play audio
//
MMRESULT GetWaveID(UINT *puWaveID)

{
    PAUDIODLGINFO pInfo = (PAUDIODLGINFO)LocalAlloc(LPTR, sizeof(AUDIODLGINFO));;

	if (!pInfo) return MMSYSERR_NOMEM;

	GetPrefInfo(pInfo, NULL);
	if(-1 == pInfo->uPrefOut)
	{
		LocalFree((HLOCAL)pInfo);
		return MMSYSERR_BADDEVICEID;
	}

	*puWaveID = pInfo->uPrefOut;
	LocalFree((HLOCAL)pInfo);

	return MMSYSERR_NOERROR;
}


//
// Checks to see if the current output audio device is a WDM Device or not
//
BOOL WDMAudioEnabled(void)
{
    BOOL fResult = FALSE;

    UINT uWaveID;

    if (GetWaveID(&uWaveID) == MMSYSERR_NOERROR)
    {
        WAVEOUTCAPS woc;

        if (waveOutGetDevCaps(uWaveID, &woc, sizeof(WAVEOUTCAPS)) == MMSYSERR_NOERROR)
        {
            if ((woc.wMid == MM_MICROSOFT) && (woc.wPid == MM_MSFT_WDMAUDIO_WAVEOUT))
            {
                fResult = TRUE;
            }
        }
    }

    return(fResult);
}



BOOL CDAudio_OnInitDialog(
    HWND        hwnd,
    HWND        hwndFocus,
    LPARAM      lParam)
{
    HWND     hwndTB1 = GetDlgItem(hwnd, IDC_CD_TB_VOLUME);
    HWND     hwndCK3 = GetDlgItem(hwnd, IDC_CDEN_DIGAUDIO);
    HWND     hwndTX1 = GetDlgItem(hwnd, IDC_TEXT_24);
    UINT     uDrive;
    int      i;
    PCDSTATE pcds = NULL;
    PALLDEVINFO pDevInfo = NULL;

    pcds = (PCDSTATE)GlobalAllocPtr(GHND, sizeof(CDSTATE));

	if (!pcds) return FALSE;

    SetWindowLongPtr(hwnd,DWLP_USER,(LONG_PTR)pcds);

    pDevInfo = (ALLDEVINFO *) ((LPPROPSHEETPAGE) lParam)->lParam;

    if (pDevInfo)
    {
        pcds->hDevInfo = pDevInfo->hDevInfo;
        pcds->pDevInfoData = pDevInfo->pDevInfoData;
        GlobalFreePtr(pDevInfo);
        ((LPPROPSHEETPAGE) lParam)->lParam = (LPARAM) NULL;
    }

    SendMessage(hwndTB1, TBM_SETTICFREQ, 10, 0);
    SendMessage(hwndTB1, TBM_SETRANGE, FALSE, MAKELONG(0,100));

    i = CDAudio_InitDrives(hwnd,pcds);
    
    if (i)
    {
        if (pcds)
        {
            SendMessage(hwndTB1, TBM_SETPOS, TRUE, (pcds->cdar.dwVol * 100L)/255L );
            Button_SetCheck(hwndCK3, pcds->DigitalEnabled);
        }

        g_fWDMEnabled = WDMAudioEnabled();

//        if (!g_fWDMEnabled)             // Per bug 20964, never disable "Enable Digital CD" checkbox
//        {
//            EnableWindow(hwndCK3, FALSE);
//            EnableWindow(hwndTX1, FALSE);
//        }
    }
//    else
//    {
//        EnableWindow(hwndCK3, FALSE);
//        EnableWindow(hwndTB1, FALSE);
//        EnableWindow(hwndTX1, FALSE);
//    }

    return FALSE;
}

void CDToggleApply(HWND hDlg)
{
    PCDSTATE    pcds;
    BOOL        fChanged = FALSE;

    pcds = (PCDSTATE)GetWindowLongPtr(hDlg,DWLP_USER); 

    if (pcds)
    {
        if (pcds->DigitalEnabled != pcds->oldDigEnabled)
        {
            fChanged = TRUE;
        }

        if (pcds->dwOldVol != pcds->cdar.dwVol)
        {
            fChanged = TRUE;
        }
    }

    if (fChanged)
    {
        PropSheet_Changed(GetParent(hDlg),hDlg);
    }
    else
    {
        PropSheet_UnChanged(GetParent(hDlg),hDlg);
    }
}

void CDAudio_OnDestroy(
    HWND        hwnd)
{
    PCDSTATE lp = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);
    if (lp)
        GlobalFreePtr(lp);

    if (g_hModStorProp)
    {
        FreeLibrary(g_hModStorProp);
        g_hModStorProp = NULL;
    }
}

void CDAudio_OnHScroll(
    HWND        hwnd,
    HWND        hwndCtl,
    UINT        code,
    int         pos)
{
    if (code == TB_ENDTRACK || code == SB_THUMBTRACK) 
    {
        HWND        hwndTB1 = GetDlgItem(hwnd, IDC_CD_TB_VOLUME);
        int         i; 
        PCDSTATE    pcds;
        DWORD       dwVol;

        pcds = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);

        if (CB_ERR != (UINT_PTR) pcds && pcds)
        {
            dwVol = (((DWORD)SendMessage(hwndTB1, TBM_GETPOS, 0, 0)) * 255L) / 100L;

            if (dwVol != pcds->cdar.dwVol)
            {
                pcds->cdar.dwVol = dwVol;
                ChangeCDVolume(pcds);   
                CDToggleApply(hwnd);
            }
        }
    }
}
    
void CDAudio_OnCancel(
    HWND        hwnd)
{
    PCDSTATE    pcds;

    pcds = (PCDSTATE)GetWindowLongPtr(hwnd,DWLP_USER);
    pcds->cdar.dwVol = pcds->dwOldVol;
    ChangeCDVolume(pcds);
}

BOOL PASCAL CDAudio_OnCommand(
    HWND        hDlg,
    int         id,
    HWND        hwndCtl,
    UINT        codeNotify)
{
    BOOL fResult = FALSE;

    switch (id)
    {
	case ID_APPLY:
	{
	    CDAudio_SaveState(hDlg);
	    fResult = TRUE;
	}
	break;

	case IDCANCEL:
	{
	    CDAudio_OnCancel(hDlg);
	    fResult = TRUE;
	}
	break;

	case IDC_CDEN_DIGAUDIO:
	{
	    CDAudio_DigitalPlaybackEnable(hDlg);
	    CDToggleApply(hDlg);
	}
	break;
    }

    return fResult;
}


const static DWORD aCDHelpIds[] = {  // Context Help IDs

    IDI_CDAUDIO,         IDH_COMM_GROUPBOX,
    IDC_ICON_5,          IDH_COMM_GROUPBOX,
    IDC_TEXT_25,         IDH_COMM_GROUPBOX,
    IDC_GROUPBOX,        IDH_COMM_GROUPBOX,
    IDC_GROUPBOX_2,      IDH_COMM_GROUPBOX,
    IDC_TEXT_29,         IDH_CD_VOL_HEADPHONE,
    IDC_CD_TB_VOLUME,    IDH_CD_VOL_HEADPHONE,
    IDC_TEXT_30,         IDH_CD_VOL_HEADPHONE,
    IDC_TEXT_24,         IDH_CDROM_PROPERTIES_DIGITAL,
    IDC_CDEN_DIGAUDIO,   IDH_CDROM_PROPERTIES_DIGITAL,

    0, 0
};

BOOL CALLBACK CDDlg(
    HWND        hDlg,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
	case WM_NOTIFY:
	    lpnm = (NMHDR FAR *)lParam;
	    switch(lpnm->code)
	    {
		case PSN_KILLACTIVE:
		    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);  
		    break;              

		case PSN_APPLY:
		    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);      
		    break;                                                      

		case PSN_SETACTIVE:
		    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
		    break;

		case PSN_RESET:
		    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
		    break;
	    }
	    break;

	case WM_INITDIALOG:
	    HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, CDAudio_OnInitDialog);
	    break;

	case WM_DESTROY:
	    HANDLE_WM_DESTROY(hDlg, wParam, lParam, CDAudio_OnDestroy);
	    break;

	case WM_DROPFILES:
	    break;

	case WM_CONTEXTMENU:        
	    WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU, 
		  (UINT_PTR)(LPTSTR)aCDHelpIds);
	    break;

	case WM_HELP:        
	    WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp,
		  HELP_WM_HELP, (UINT_PTR)(LPTSTR)aCDHelpIds);
	    break;

	case WM_COMMAND:
	    HANDLE_WM_COMMAND(hDlg, wParam, lParam, CDAudio_OnCommand);
	    break;

	case WM_HSCROLL:
	    HANDLE_WM_HSCROLL(hDlg, wParam, lParam, CDAudio_OnHScroll);
	    break;

#if 0        
	default:
	    if (uMsg == wHelpMessage) 
	    {
		WinHelp(hDlg, gszWindowsHlp, HELP_CONTEXT, ID_SND_HELP);
		return TRUE;
	    }
	    break;
#endif
	    
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\debug.h ===
#ifndef _debug_h_
    #define _debug_h_

void OutputDebugLog(PWSTR buf);
void DebugLog(PWSTR FileName,ULONG LineNumber,PWSTR FormatStr,...);

    #ifdef DBG
        #define dlog(_fmt_)                            DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_))
        #define dlog1(_fmt_,_arg1_)                    DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_),_arg1_)
        #define dlog2(_fmt_,_arg1_,_arg2_)             DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_),_arg1_,_arg2_)
        #define dlog3(_fmt_,_arg1_,_arg2_,_arg3_)      DebugLog(TEXT(__FILE__),__LINE__,TEXT(_fmt_),_arg1_,_arg2_,_arg3_)

        #define dlogt(_fmt_)                           DebugLog(TEXT(__FILE__),__LINE__,_fmt_)
    #else
        #define dlog(_fmt_)
        #define dlog1(_fmt_,_arg1_)
        #define dlog2(_fmt_,_arg1_,_arg2_)
        #define dlog3(_fmt_,_arg1_,_arg2_,_arg3_)

        #define dlogt(_fmt_)
    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\debug.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>

void OutputDebugLog(PWSTR buf)
{
    ULONG Bytes;
    char str[2048];
    static HANDLE hFile = NULL;

    Bytes = wcslen( buf );

    WideCharToMultiByte(CP_ACP,
                        0,
                        buf,
                        -1,
                        str,
                        Bytes + 4,
                        NULL,
                        NULL
                       );

    if (hFile == NULL)
    {
        WCHAR LogFileName[MAX_PATH];

        if (!GetWindowsDirectory( LogFileName, sizeof(LogFileName)/sizeof(WCHAR))) LogFileName[0] = '\0';
        wcscat( LogFileName, L"\\mmsyslog.txt" );
        hFile = CreateFile(
                          LogFileName,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                          NULL
                          );
        SetFilePointer(hFile,0,NULL,FILE_END);
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    WriteFile(
             hFile,
             str,
             Bytes,
             &Bytes,
             NULL
             );

    return;
}

void
    DebugLog(
            PWSTR FileName,
            ULONG LineNumber,
            PWSTR FormatStr,
            ...
            )
{
    WCHAR buf[2048];
    PWSTR s,p;
    SYSTEMTIME CurrTime;

    va_list arg_ptr;

    GetSystemTime( &CurrTime );

    _try
    {
        p = buf;
        *p = 0;
        swprintf( p, L"%02d:%02d:%02d.%03d ",
                  CurrTime.wHour,
                  CurrTime.wMinute,
                  CurrTime.wSecond,
                  CurrTime.wMilliseconds
                );
        p += wcslen(p);
        if (FileName && LineNumber)
        {
            s = wcsrchr( FileName, L'\\' );
            if (s)
            {
                wcscpy( p, s+1 );
                p += wcslen(p);
                swprintf( p, L" @ %d ", LineNumber );
                p += wcslen(p);
            }
        }
        va_start( arg_ptr, FormatStr );
        wvsprintf(p,FormatStr,arg_ptr);
        va_end( arg_ptr );
        p += wcslen(p);
        wcscat( p, L"\r\n" );
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        buf[0] = 0;
    }

    if (buf[0] == 0)
    {
        return;
    }

    OutputDebugLog(buf);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\class.c ===
/*==========================================================================*/
//
//  class.c
//
//  Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.
//  Mod Log:   Modified by Shawn Brown (10/95)
//                - Ported to NT (Unicode, etc.)
/*==========================================================================*/

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <cpl.h> 
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <string.h>
#include <memory.h>
#include <idf.h>
#include <regstr.h>
#include "utils.h"

#include "midi.h"
#include "mmdebug.h"
#if defined DEBUG || defined DEBUG_RETAIL
 extern TCHAR szNestLevel[];
#endif

#include "medhelp.h"

#ifndef TVIS_ALL
#define TVIS_ALL 0xFF7F
#endif


static CONST TCHAR cszIdfWildcard[]    = TEXT ("*.idf");
static CONST TCHAR cszIdf[]            = TEXT (".idf");
static CONST TCHAR cszSetupKey[]       = REGSTR_PATH_SETUP REGSTR_KEY_SETUP;
static CONST TCHAR cszMachineDir[]     = REGSTR_VAL_WINDIR;
static CONST TCHAR cszConfigDir[]      = TEXT ("config\\");

extern CONST TCHAR cszMidiSlash[];
extern CONST TCHAR cszFriendlyName[];
extern CONST TCHAR cszDescription[];
extern CONST TCHAR cszSlashInstruments[];
extern CONST TCHAR cszExternal[];
extern CONST TCHAR cszDefinition[];
extern CONST TCHAR cszPort[];
extern CONST TCHAR cszDriversRoot[];
extern CONST TCHAR cszSchemeRoot[];
extern CONST TCHAR cszMidiMapRoot[];
extern CONST TCHAR cszDriversRoot[];
extern CONST TCHAR csz02d[];
extern CONST TCHAR cszSlash[];
extern CONST TCHAR cszEmpty[];

extern int lstrnicmp (LPTSTR pszA, LPTSTR pszB, size_t cch);


typedef struct _midi_class {
    LPPROPSHEETPAGE ppsp;
    HKEY            hkMidi;
    BOOL            bDetails;
    BOOL            bRemote;  // device connected via midi cable
    UINT            bChanges;
    UINT            ixDevice; // registry enum index of driver key
    BYTE            nPort;
    BYTE            bFill[3];
    BOOL            bFillingList;
  #ifdef USE_IDF_ICONS
    HIMAGELIST      hIDFImageList;
  #endif
    LPTSTR          pszKey;
    TCHAR           szFullKey[MAX_PATH];
    TCHAR           szAlias[MAX_PATH];
    TCHAR           szFile[MAX_PATH*2];
    } MCLASS, FAR * PMCLASS;

#define MCL_ALIAS_CHANGED 1
#define MCL_TREE_CHANGED  2
#define MCL_IDF_CHANGED   4
#define MCL_PORT_CHANGED  8


/*+
 * Determines if a given string has a given prefix and if
 * the next character in the string is a given charater.
 *
 * if so, it returns a pointer to the first character in the
 * string after the prefix.
 *
 * this is useful for parsing off the file in  file<Instrument>
 * or parts of registry paths.
 *
 * note that we do NOT consider a string to be a prefix of itself.
 * psz MUST be longer than than pszPrefix or this function returns NULL.
 *
 *-=================================================================*/

STATICFN LPTSTR WINAPI IsPrefix (
    LPTSTR pszPrefix,
    LPTSTR psz,
    TCHAR  chTerm)
{
    UINT  cb  = lstrlen(pszPrefix);
    UINT  cb2 = lstrlen(psz);
    TCHAR ch;

    if (cb2 < cb)
        return NULL;

    ch = psz[cb];
    if (ch != chTerm)
        return NULL;

    psz[cb] = 0;
    if (lstrcmpi(pszPrefix, psz))
    {
        psz[cb] = ch;
        return NULL;
    }

    psz[cb] = ch;
    return psz + cb;
}


/*+ IsFullPath
 *
 * returns true if the filename passed in is a fully qualified
 * pathname. returns false if it is a relative path
 *
 * unc paths are treated as fully qualified always
 *
 *-=================================================================*/

BOOL IsFullPath (
    LPTSTR pszFile)
{
    // fully qualified paths either begin with a backslash
    // or with a drive letter, colon, then backslash
    //
    if ((pszFile[0] == TEXT('\\')) ||
        (pszFile[1] == TEXT(':') && pszFile[2] == TEXT('\\')))
        return TRUE;

    return FALSE;
}


/*+ GetIDFDirectory
 *
 *-=================================================================*/

BOOL GetIDFDirectory (
    LPTSTR pszDir,
    UINT   cchDir)
{
    HKEY  hKey;
    UINT  cbSize;

    *pszDir = 0;

#if(_WIN32_WINNT >= 0x0400)
    if (!GetSystemDirectory (pszDir, cchDir))
        return FALSE;
#else
    if (!RegOpenKey (HKEY_LOCAL_MACHINE, cszSetupKey, &hKey))
    {
        cbSize = cchDir * sizeof(TCHAR);
        RegQueryValueEx (hKey, 
                         cszMachineDir, 
                         NULL, 
                         NULL, 
                         (LPBYTE)pszDir, 
                         &cbSize);
        RegCloseKey (hKey);

        cchDir = cbSize/sizeof(TCHAR);

        if (!cchDir--)
            return FALSE;
    }
    else if (!GetWindowsDirectory (pszDir, cchDir))
        return FALSE;
#endif

    cchDir = lstrlen (pszDir);
    if (pszDir[cchDir -1] != TEXT('\\'))
        pszDir[cchDir++] = TEXT('\\');
    lstrcpy (pszDir + cchDir, cszConfigDir);

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT("IDFDir='%s'\r\n"), pszDir);
#endif
    return TRUE;
}


/*+ GetIDFFileName
 *
 *-=================================================================*/

BOOL GetIDFFileName (
    HWND    hWnd,
    LPTSTR  lpszFile,
    UINT    cchFile)
    {
    OPENFILENAME ofn;
    TCHAR        szFilter[MAX_PATH];
    UINT         cch;

    assert (hWnd);

    // load filter string from resource and convert '#' characters
    // into NULLs
    //
    LoadString (ghInstance, IDS_IDFFILES, szFilter, NUMELMS(szFilter));
    cch = lstrlen(szFilter);
    assert2 (cch, TEXT ("IDFFILES resource is empty!"));
    while (cch--)
    {
        if (TEXT('#') == szFilter[cch])
            szFilter[cch] = 0;
    }

    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize  = sizeof(ofn);
    ofn.hwndOwner    = hWnd;
    ofn.hInstance    = ghInstance;
    ofn.lpstrFilter  = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile    = lpszFile;
    ofn.nMaxFile     = cchFile;
    ofn.Flags        = OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
    ofn.lpstrDefExt  = cszIdf;

    return GetOpenFileName (&ofn);
    }


/*+ InstallNewIDF
 *
 *-=================================================================*/

BOOL WINAPI InstallNewIDF (
    HWND hWnd)
{
    TCHAR szWinPath[MAX_PATH];
    TCHAR szNewIDF[MAX_PATH];
    UINT  cch;
    UINT  oBasename;

    // prompt for an IDF file
    //
    szNewIDF[0] = 0;
    if ( ! GetIDFFileName (hWnd, szNewIDF, NUMELMS(szNewIDF)))
        return FALSE;

    // set oBasename to pointer to the first character of the
    // basename of the new idf file
    //
    oBasename = lstrlen (szNewIDF);
    if (!oBasename)
        return FALSE;
    while (oBasename && (TEXT('\\') != szNewIDF[oBasename-1]))
        --oBasename;

    // build the new filename from windows directory and idf basename
    //
    GetIDFDirectory (szWinPath, NUMELMS(szWinPath));
    cch = lstrlen (szWinPath);
    if (cch && szWinPath[cch-1] != TEXT('\\'))
        szWinPath[cch++] = TEXT('\\');
    lstrcpyn (szWinPath + cch, szNewIDF + oBasename, NUMELMS(szWinPath)-cch);
    oBasename = cch;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT("install IDF to '%s'\r\n"), szWinPath);
#endif
    // now force .idf as the extension for new file
    //
    for (cch = lstrlen (szWinPath); cch && szWinPath[cch] != TEXT('.'); --cch)
        if (TEXT('\\') == szWinPath[cch])
        {
            cch = lstrlen(szWinPath);
            break;
        }
    lstrcpy (szWinPath + cch, cszIdf);

    // quit now if we are trying to copy a file to itself
    //
    if (IsSzEqual(szWinPath, szNewIDF))
        return FALSE;

    // copy the file, but fail if destination already exists
    //
#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT("Copying %s to %s\r\n"), szNewIDF, szWinPath);
#endif
    if (CopyFile (szNewIDF, szWinPath, TRUE))
        return TRUE;
    //
    // if copy fails, query to overwrite because destination
    // already exists.
    //
    else
    {
        TCHAR szQuery[255];
        TCHAR sz[255];

#ifdef DEBUG
        AuxDebugEx (1, DEBUGLINE TEXT ("InstallIDF -CopyFile failed w/ %d\r\n"),
                    GetLastError());
#endif

        LoadString (ghInstance, IDS_QUERY_OVERIDF, sz, NUMELMS(sz));
        wsprintf (szQuery, sz, szWinPath + oBasename);

        LoadString (ghInstance, IDS_IDF_CAPTION, sz, NUMELMS(sz));

        if (MessageBox (hWnd, szQuery, sz, MB_YESNO | MB_ICONQUESTION) == IDYES)
            return CopyFile (szNewIDF, szWinPath, FALSE);
    }
    return FALSE;
}

/*+
 *
 * FEATURE: Please remove the #ifdef UNICODE sections 
 *          when mmioOpen gets UNICODE enabled !!!
 *-=================================================================*/

typedef BOOL (WINAPI * FNIDFENUM)(LPVOID        pvArg,
                                  UINT          nEnum,
                                  LPIDFHEADER   pHdr,
                                  LPIDFINSTINFO pInst);

UINT WINAPI idfEnumInstruments (
    LPTSTR     lpszFile,
    FNIDFENUM  fnEnum,
    LPVOID     lpvArg)
{
    MMCKINFO    chkIDFX;         // Grandparent chunk
    MMCKINFO    chkMMAP;         // Parent chunk
    HMMIO       hmmio;           // Handle to the file.
    UINT        nInstruments;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT("idfEnumInstruments('%s',%08X,%08X)\r\n"),
                lpszFile, fnEnum, lpvArg);
#endif

    // Open the file for reading.
    hmmio = mmioOpen(lpszFile, NULL, MMIO_READ);
    if ( ! hmmio)
    {
// What were they thinking??  You can't assert this.
//      assert3(0, TEXT("Cant open IDF file %s"), lpszFile ? lpszFile : TEXT("<null>"));
        return 0;
    }

    // the whole IDF instrument stuff is wrapped in an 'IDF ' RIFF chunk
    //
    chkIDFX.fccType = MAKEFOURCC('I','D','F',' ');
    if (mmioDescend(hmmio, &chkIDFX, NULL, MMIO_FINDRIFF))
    {
#ifdef DEBUG
        AuxDebugEx (0, DEBUGLINE TEXT ("idfEnum: '%s' is not a valid IDF File\r\n"), lpszFile);
#endif
        mmioClose(hmmio, 0);
        return 0;
    }

    // Count the number of instruments by counting
    // the number of "MMAP"'s in the file.
    //
    nInstruments = 0;
    chkMMAP.fccType = MAKEFOURCC('M','M','A','P');
    while ( ! mmioDescend(hmmio, &chkMMAP, &chkIDFX, MMIO_FINDLIST))
    {
        union {
            IDFHEADER idf;
            TCHAR      sz[MAX_ALIAS + sizeof(IDFHEADER)];
            } hdr;
        union {
            IDFINSTINFO iii;
            BYTE        ab[MAX_ALIAS * 8 + sizeof(IDFINSTINFO)];
            } inst;
        MMCKINFO chk;
        DWORD    cb;

#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT ("MMAP[%d] id=%08X siz=%08x\r\n"),
                    nInstruments, chkMMAP.ckid, chkMMAP.cksize);
#endif

        // read the hdr chunk
        //
        chk.ckid = MAKEFOURCC('h','d','r',' ');
        if (mmioDescend(hmmio, &chk, &chkMMAP, MMIO_FINDCHUNK))
            break;

#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT("  hdr.id=%08X hdr.siz=%08x\r\n"),
                    chk.ckid, chk.cksize);
#endif
        assert (chk.cksize > 0 && chk.cksize < 0x0080000);

        //AuxDebugDump (6, &chk, sizeof(chk));

        cb = min(chk.cksize, sizeof(hdr));
        if ((DWORD)mmioRead (hmmio, (LPVOID)&hdr, cb) != cb)
           break;

        //AuxDebugDump (6, &chk, sizeof(chk));

        hdr.sz[NUMELMS(hdr.sz)-1] = 0;
        mmioAscend (hmmio, &chk, 0);
#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT("hdr = '%s'\r\n"), hdr.idf.abInstID);
#endif

        //AuxDebugDump (6, &chk, sizeof(chk));

        // read the inst chunk and locate the product name
        // field.
        //
        chk.ckid = MAKEFOURCC('i','n','s','t');
        if (mmioDescend(hmmio, &chk, &chkMMAP, MMIO_FINDCHUNK))
        {
#ifdef DEBUG
            AuxDebug (TEXT ("mmioDescend failed for 'inst' chunk"));
#endif
        }

#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT("  inst.id=%08X inst.siz=%08x\r\n"),
                    chk.ckid, chk.cksize);
#endif
        assert (chk.cksize > 0 && chk.cksize < 0x0080000);
        cb = min(chk.cksize, sizeof(inst));
        if ((DWORD)mmioRead (hmmio, (LPVOID)&inst, cb) != cb)
        {
#ifdef DEBUG
            AuxDebug ( TEXT ("mmioRead failed for 'inst' chunk"));
#endif
        }

        inst.ab[NUMELMS(inst.ab)-1] = 0;
        mmioAscend (hmmio, &chk, 0);
#ifdef DEBUG
        AuxDebugEx (15, DEBUGLINE TEXT ("inst.mfg = '%s'\r\n"), inst.iii.abData);
        AuxDebugEx (15, TEXT ("\t.prod = '%s'\r\n"), inst.iii.abData
                                                   + inst.iii.cbManufactASCII
                                                   + inst.iii.cbManufactUNICODE);
#endif
        // call the enum callback for this instrument
        //
        if ( ! fnEnum (lpvArg, nInstruments, &hdr.idf, &inst.iii))
            break;

        ++nInstruments;
        assert (nInstruments < 20);

        // ascend and loop back to look for the next instrument
        //
        if (mmioAscend(hmmio, &chkMMAP, 0))
            break;
    }

    mmioClose(hmmio, 0);
    return nInstruments;
}


/*+ LoadTypesIntoTree
 *
 *-=================================================================*/

struct types_enum_data {
    HANDLE            hWndT;
    TV_INSERTSTRUCT * pti;
    LPTSTR            pszInstr;
    HTREEITEM         htiSel;
    };

STATICFN BOOL WINAPI fnTypesEnum (
    LPVOID        lpv,
    UINT          nEnum,
    LPIDFHEADER   pHdr,
    LPIDFINSTINFO pInst)
{
    struct types_enum_data * pted = lpv;
    HTREEITEM hti;

    assert (pted);

#ifdef DEBUG
    AuxDebugEx (7, DEBUGLINE TEXT ("enum[%d] '%s' instr=%x\r\n"),
                nEnum, pHdr->abInstID, pted->pszInstr);
#endif

    MultiByteToWideChar(GetACP(), 0,
                        pHdr->abInstID, -1,
                        pted->pti->item.pszText, sizeof(pted->pti->item.pszText));

    hti = TreeView_InsertItem (pted->hWndT, pted->pti);

    // this item is the 'selected' one, if it is the first
    // item or if it matches the name
    //
    if ((nEnum == 0) ||
        (pted->pszInstr && pted->pszInstr[0] &&
         IsPrefix(pted->pti->item.pszText, pted->pszInstr + sizeof(TCHAR), TEXT('>'))))
    {
        pted->htiSel = hti;
#ifdef DEBUG
        AuxDebugEx (7, DEBUGLINE TEXT("\t'%s' hti %08X is select\r\n"),
                    pted->pszInstr ? pted->pszInstr : TEXT (""), hti);
#endif
    }

    // return true to continue enumeration
    //
    return TRUE;
}

STATICFN void SetTypesEdit (
    HWND    hWnd,
    UINT    uId,
    PMCLASS pmcl)
{
    SetDlgItemText (hWnd, uId, pmcl->szFile);
}

STATICFN void LoadTypesIntoTree (
    HWND     hWnd,
    UINT     uId,
    PMCLASS  pmcl)
{
    HWND  hWndT;
    UINT  cchBase;
    TCHAR szPath[MAX_PATH];
    TCHAR szDefaultIDF[MAX_PATH];
    int   ix;
    WIN32_FIND_DATA ffd;
    HANDLE          hFind;
   #ifdef USE_IDF_ICONS
    HIMAGELIST      hImageList;
   #endif
    HTREEITEM       htiSelect = NULL; // item to select

    hWndT = GetDlgItem (hWnd, uId);
    if (!hWndT)
        return;

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("LoadTypesIntoTree( ,%x, )\r\n"), uId);
#endif

    LoadString (ghInstance, IDS_GENERAL, szDefaultIDF, NUMELMS(szDefaultIDF));

   #ifdef USE_IDF_ICONS

    // if we have not already loaded an image list for the IDF types
    // do so now.
    //
    if (!(hImageList = pmcl->hIDFImageList))
    {
        static LPCTSTR aid[] = {
            MAKEINTRESOURCE(IDI_IDFICON),
            MAKEINTRESOURCE(IDI_BLANK),
            };

        int cx = GetSystemMetrics(SM_CXSMICON);
        int cy = GetSystemMetrics(SM_CYSMICON);
        DWORD dwLayout;

        UINT uFlags = ILC_MASK | ILC_COLOR32;
    
        if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
        {
            uFlags |= ILC_MIRROR;
        }

        pmcl->hIDFImageList =
        hImageList = ImageList_Create (cx, cy, uFlags, NUMELMS(aid), 2);

        if (hImageList)
        {
            UINT  ii;

            for (ii = 0; ii < NUMELMS(aid); ++ii)
            {
                HICON hIcon = LoadImage (ghInstance, aid[ii], IMAGE_ICON,
                                         cx, cy, LR_DEFAULTCOLOR);
                if (hIcon)
                    ImageList_AddIcon (hImageList, hIcon);
            }
        }
    }

   #endif

    pmcl->bFillingList = TRUE;

    //SetWindowRedraw (hWndT, FALSE);
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_deleteAllItems(%08X)\r\n"), hWndT);
#endif
    TreeView_DeleteAllItems(hWndT);
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("tv_deleteAllItems(%08X) ends\r\n"), hWndT);
#endif
   #ifdef USE_IDF_ICONS
    TreeView_SetImageList (hWndT, hImageList, TVSIL_NORMAL);
   #endif
    htiSelect = NULL;

    pmcl->bFillingList = FALSE;

    GetIDFDirectory (szPath, NUMELMS(szPath));
    cchBase = lstrlen (szPath);
    if (cchBase && szPath[cchBase-1] != TEXT('\\'))
        szPath[cchBase++] = TEXT('\\');
    lstrcpyn (szPath + cchBase, cszIdfWildcard, NUMELMS(szPath)-cchBase);

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("scanning for idfs at '%s'\r\n"), szPath);
#endif

    ix = 0;

    hFind = FindFirstFile (szPath, &ffd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
       TV_INSERTSTRUCT ti;
       struct types_enum_data ted = {hWndT, &ti, NULL, NULL};
       ZeroMemory (&ti, sizeof(ti));

       do
       {
           UINT   nInstr;
           UINT   cch;

           // patch off the extension before we add
           // this name to the list
           //
           cch = lstrlen(ffd.cFileName);
           while (cch)
              if (ffd.cFileName[--cch] == TEXT('.'))
              {
                 ffd.cFileName[cch] = 0;
                 break;
              }

           ti.hParent      = TVI_ROOT;
           ti.hInsertAfter = TVI_SORT;
          #ifdef USE_IDF_ICONS
           ti.item.mask      = TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
          #else
           ti.item.mask      = TVIF_TEXT | TVIF_STATE;
          #endif

           // the TV_ITEM structure may not be unicode enabled ?!?
           ti.item.pszText   = ffd.cFileName;
           ti.item.state     = 0;
           ti.item.stateMask = TVIS_ALL;

#ifdef DEBUG
           AuxDebugEx (7, DEBUGLINE TEXT ("adding '%s' to types tree\r\n"), ti.item.pszText);
#endif

           ti.hParent = TreeView_InsertItem (hWndT, &ti);
           if ( ! ti.hParent)
              break;
           ti.hInsertAfter = TVI_LAST;

           // put the extension back
           //
           if (cch > 0)
              ffd.cFileName[cch] = TEXT('.');

           // check to see if this file is a match for the
           // current definition file.
           //
#ifdef DEBUG
           AuxDebugEx (7, DEBUGLINE TEXT ("comparing '%s' with '%s'\r\n"),
                       ffd.cFileName, pmcl->szFile);
#endif
           ted.pszInstr = IsPrefix (ffd.cFileName, pmcl->szFile, TEXT('<'));
#ifdef DEBUG
           AuxDebugEx (7, DEBUGLINE TEXT ("\tpszInstr = '%s'\r\n"), ted.pszInstr ? ted.pszInstr : TEXT ("NULL"));
#endif

           // add instruments as subkeys to this file
           // this also has the side effect of setting ted.htiSel
           // when the instrument name matches
           //
           lstrcpy (szPath + cchBase, ffd.cFileName);
           nInstr = idfEnumInstruments (szPath, fnTypesEnum, &ted);

           // if this idf has no instruments. ignore it.
           // if it has more than one instrument, expand the list
           // so that instruments are visible
           //
           if (0 == nInstr)
               TreeView_DeleteItem (hWndT, ti.hParent);
           else if (nInstr > 1)
               TreeView_Expand (hWndT, ti.hParent, TVE_EXPAND);
           else
               ted.htiSel = ti.hParent;

           // if we have a match on filename, then we need to select
           // either the parent or one of the children
           //
           if (ted.pszInstr ||
               IsSzEqual(ffd.cFileName,pmcl->szFile) ||
               IsSzEqual(ffd.cFileName,szDefaultIDF))
           {
#ifdef DEBUG
               AuxDebugEx (7, DEBUGLINE TEXT ("will be selecting %08X '%s'\r\n"),
                           ted.htiSel, ffd.cFileName);
#endif
               htiSelect = ted.htiSel;
           }

        } while (FindNextFile (hFind, &ffd));

        FindClose (hFind);
    }

    if (htiSelect)
    {
        pmcl->bFillingList = TRUE;
#ifdef DEBUG
        AuxDebugEx (7, DEBUGLINE TEXT ("selecting %08X\r\n"), htiSelect);
#endif
        TreeView_SelectItem (hWndT, htiSelect);
#ifdef DEBUG
        AuxDebugEx (7, DEBUGLINE TEXT ("FirstVisible %08X\r\n"), htiSelect);
#endif
        TreeView_SelectSetFirstVisible (hWndT, htiSelect);
        pmcl->bFillingList = FALSE;
    }

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("LoadTypesIntoTree( ,%d, ) ends\r\n"), uId);
#endif
    //SetWindowRedraw (hWndT, TRUE);
}

/*+
 *
 *-=================================================================*/

STATICFN void WINAPI HandleTypesSelChange (
    PMCLASS pmcl,
    LPNMHDR lpnm)
{
    LPNM_TREEVIEW pntv = (LPVOID)lpnm;
    LPTV_ITEM     pti  = &pntv->itemNew;
    HTREEITEM     htiParent;
    TV_ITEM       ti;

    assert (pmcl->bDetails);

    // setup ti to get text & # of children
    // from the IDF filename entry.
    //
    ti.mask       = TVIF_TEXT;
    ti.pszText    = pmcl->szFile;
    ti.cchTextMax = NUMELMS(pmcl->szFile);
    ti.hItem      = pti->hItem;

#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("Type Change pti=%08X hItem=%08X\r\n"), pti, pti->hItem);
#endif

    // if this entry has a parent, it must be a IDF
    // instrument name.  if so, then we want to read
    // from its parent first.
    //
    htiParent = TreeView_GetParent (lpnm->hwndFrom, pti->hItem);
    if (htiParent)
        ti.hItem = htiParent;

    TreeView_GetItem (lpnm->hwndFrom, &ti);
    lstrcat (pmcl->szFile, cszIdf);

#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("mask=%08x htiParent=%08X %08x nChild=%d '%s'\r\n"),
                ti.mask, htiParent, ti.hItem, ti.cChildren, ti.pszText);
#endif

    // if the selection had a parent, and we are not it's first child
    // then we need to append child (delimited by <>) after parent
    //
    if (htiParent &&
        (TreeView_GetChild(lpnm->hwndFrom, htiParent) != pti->hItem))
    {
        static CONST TCHAR cszAngle[] = TEXT(">");
        UINT cch = lstrlen(pmcl->szFile);

        pmcl->szFile[cch++] = TEXT('<');

        ti.mask       = TVIF_TEXT;
        ti.pszText    = pmcl->szFile + cch;
        ti.cchTextMax = NUMELMS(pmcl->szFile) - cch;
        ti.hItem      = pti->hItem;

        TreeView_GetItem (lpnm->hwndFrom, &ti);
        lstrcat (pmcl->szFile, cszAngle);
#ifdef DEBUG
        AuxDebugEx (6, DEBUGLINE TEXT ("appending child %08X; '%s'\r\n"), pti->hItem, pmcl->szFile);
#endif
    }

    pmcl->bChanges |= MCL_IDF_CHANGED;
}


/*+
 *
 *-=================================================================*/

STATICFN void LoadDevicesIntoList (
    HWND     hWnd,
    UINT     uId,
    PMCLASS  pmcl,
    BOOL     bList)
{
    HWND   hWndT;
    TCHAR  sz[MAX_ALIAS];
    DWORD  cch = sizeof(sz) / sizeof(TCHAR);
    UINT   ii;
    BOOL   bAdded = FALSE;

    hWndT = GetDlgItem (hWnd, uId);
    if (!hWndT)
        return;

    SetWindowRedraw (hWndT, FALSE);
    if (bList)
        ListBox_ResetContent(hWndT);
    else
        ComboBox_ResetContent(hWndT);

    if (!pmcl->hkMidi &&
        RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &pmcl->hkMidi))
        return;

    for (cch = sizeof(sz)/sizeof(TCHAR), ii = 0; ! RegEnumKey (pmcl->hkMidi, ii, sz, cch); ++ii)
    {
        TCHAR  szAlias[MAX_ALIAS];
        int    ix;
        BOOL   bExtern;
        BOOL   bActive;

        // read in the friendly name for this driver
        //
        if (GetAlias (pmcl->hkMidi, sz, szAlias, sizeof(szAlias)/sizeof(TCHAR), &bExtern, &bActive))
            continue;

        if (IsPrefix (sz, pmcl->pszKey, TEXT('\\')))
            pmcl->ixDevice = ii;

        // ignore if this is not an external device or if it is disabled
        //
        if ( ! bExtern || ! bActive)
            continue;

        // otherwise, add the driver name to the combobox/list
        //
        if (bList)
        {
            ix = ListBox_AddString (hWndT, szAlias);
            if (ix >= 0)
            {
                ListBox_SetItemData (hWndT, ix, ii);
                bAdded = TRUE;
            }
        }
        else
        {
            ix = ComboBox_AddString (hWndT, szAlias);
            if (ix >= 0)
            {
                ComboBox_SetItemData (hWndT, ix, ii);
                bAdded = TRUE;
            }
        }
    }

    SetWindowRedraw (hWndT, TRUE);
    EnableWindow (hWndT, bAdded);
    if (ii > 0)
        InvalidateRect (hWndT, NULL, TRUE);

    // iterate back through the items and select the one
    // that has item data that corresponds to driver that
    // owns the current device
    //
    if (bList)
    {
        UINT jj;

        for (jj = 0; jj < ii; ++jj)
        {
            if ((UINT)ListBox_GetItemData (hWndT, jj) == pmcl->ixDevice)
            {
                ListBox_SetCurSel (hWndT, jj);
                break;
            }
        }
        if (jj >= ii)
            ListBox_SetCurSel (hWndT, 0);
    }
    else
    {
        UINT jj;

        for (jj = 0; jj < ii ; ++jj)
        {
            if ((UINT)ComboBox_GetItemData (hWndT, jj) == pmcl->ixDevice)
            {
                ComboBox_SetCurSel (hWndT, jj);
                break;
            }
        }
        if (jj >= ii)
            ComboBox_SetCurSel (hWndT, 0);
    }
}


/*+ LoadClass
 *
 *-=================================================================*/

STATICFN BOOL WINAPI LoadClass (
    HWND    hWnd,
    PMCLASS pmcl)
{
    HKEY  hKeyA = NULL;
    BOOL  bRet = FALSE;
    UINT  cbSize;
    UINT  cch;
    DWORD dw;

    if (!pmcl->hkMidi &&
        RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &pmcl->hkMidi))
        goto cleanup;

    if (RegOpenKey (pmcl->hkMidi, pmcl->pszKey, &hKeyA))
        goto cleanup;

    // read data from this key
    //
    cbSize = sizeof(pmcl->szFile);
    RegQueryValueEx (hKeyA, cszDefinition, NULL, &dw, (LPBYTE)pmcl->szFile, &cbSize);

    // strip off leading directory (if there is one).
    //
    cch = lstrlen(pmcl->szFile);
    while (cch && (pmcl->szFile[cch-1] != TEXT('\\')))
        --cch;
    if (cch)
    {
        TCHAR szFile[MAX_PATH];
        lstrcpy (szFile, pmcl->szFile + cch);
        lstrcpy (pmcl->szFile, szFile);
    }

    // get scheme alias
    //
    cbSize = sizeof(pmcl->szAlias);
    RegQueryValueEx (hKeyA, cszFriendlyName, NULL, &dw, (LPBYTE)pmcl->szAlias, &cbSize);

    //
    //
    pmcl->nPort = 0;
    cbSize = sizeof(pmcl->nPort);
    RegQueryValueEx (hKeyA, cszPort, NULL, &dw, (LPVOID)&pmcl->nPort, &cbSize);

    pmcl->bChanges = 0;
    bRet = TRUE;

  cleanup:
    if (hKeyA)
       RegCloseKey (hKeyA);

    return bRet;
}


/*+ RebuildSchemes
 *
 * correct key references in the midi schemes when an instrument
 * is moved from one external midi port to another
 *
 *-=================================================================*/

STATICFN BOOL WINAPI RebuildSchemes (
    LPTSTR pszOldKey,
    LPTSTR pszNewKey)
{
    HKEY  hkSchemes;
    UINT  ii;
    TCHAR sz[MAX_ALIAS];
    UINT  cchNew;

    cchNew = 0;
    if (pszNewKey)
        cchNew = lstrlen(pszNewKey) + 1;

#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("RebuildSchemes('%s','%s')\r\n"),
                pszOldKey, pszNewKey ? pszNewKey : TEXT ("NULL"));
#endif

    if (RegCreateKey (HKEY_LOCAL_MACHINE, cszSchemeRoot, &hkSchemes))
        return FALSE;


    for (ii = 0; ! RegEnumKey (hkSchemes, ii, sz, sizeof(sz)/sizeof(TCHAR)); ++ii)
    {
        HKEY  hKeyA;
        UINT  jj;

        if (RegOpenKey (hkSchemes, sz, &hKeyA))
            continue;

        for (jj = 0; ! RegEnumKey (hKeyA, jj, sz, sizeof(sz)/sizeof(TCHAR)); ++jj)
        {
            UINT  cb;
            TCHAR szKey[MAX_PATH];

            cb = sizeof(szKey);
            if (RegQueryValue (hKeyA, sz, szKey, &cb))
                continue;

            if (IsSzEqual(pszOldKey, szKey))
            {
                if (cchNew)
                    RegSetValue (hKeyA, sz, REG_SZ, pszNewKey, cchNew);
                else
                    RegDeleteKey (hKeyA, sz);

#ifdef DEBUG
                AuxDebugEx (4, DEBUGLINE TEXT ("RebuildSchemes - fixing %d\\%d\r\n"), ii, jj);
#endif
            }
        }
    }

    return TRUE;
}


/*+ OpenInstrumentKey
 *
 *-=================================================================*/

STATICFN HKEY WINAPI OpenInstrumentKey (
    HWND    hWnd,
    PMCLASS pmcl,
    BOOL    bCreate)   // create an new key (do not remove or rebuild existing)
{
    TCHAR  szKey[MAX_ALIAS];
    HKEY   hkInst;
    HKEY   hKeyA = NULL;
    ZeroMemory (szKey, sizeof (szKey));

#ifdef DEBUG
    AuxDebugEx (5, DEBUGLINE TEXT ("OpenInstrumentKey(%X,%08X,%d) szKey=%s\r\n"),
                hWnd, pmcl, bCreate, pmcl->pszKey ? pmcl->pszKey : TEXT ("NULL"));
#endif

    hkInst = NULL;

    if (!pmcl->hkMidi &&
        RegCreateKey (HKEY_LOCAL_MACHINE, cszDriversRoot, &pmcl->hkMidi))
        goto cleanup;

    if (RegEnumKey (pmcl->hkMidi, pmcl->ixDevice, szKey, sizeof(szKey)/sizeof(TCHAR)))
    {
        assert3(0, TEXT ("Failed to enum Midi device %d"), pmcl->ixDevice);
        goto cleanup;
    }
#ifdef DEBUG
    AuxDebugEx (6, DEBUGLINE TEXT ("ixDevice = %d, Key is %s\r\n"),
                pmcl->ixDevice, szKey);
#endif

    // if this is a driver key, or if we are not creating and
    // the instrument has not changed parentage, we can just
    // open the existing key and update its content
    //
    if (!pmcl->bRemote ||
        (!bCreate && IsPrefix (szKey, pmcl->pszKey, TEXT('\\'))))
    {
        if (RegOpenKey (pmcl->hkMidi, pmcl->pszKey, &hKeyA))
            goto cleanup;
#ifdef DEBUG
        AuxDebugEx (6, DEBUGLINE TEXT ("opened key %s\r\n"), pmcl->pszKey);
#endif
    }
    else
    {
        UINT  kk;
        TCHAR szEnum[10];

        pmcl->bChanges |= MCL_TREE_CHANGED;

        lstrcat (szKey, cszSlashInstruments);
        if (RegCreateKey (pmcl->hkMidi, szKey, &hkInst))
            goto cleanup;

        // find an unused keyname
        //
        for (kk = 0; kk < 128; ++kk)
        {
           wsprintf (szEnum, csz02d, kk);
           if (RegOpenKey (hkInst, szEnum, &hKeyA))
               break;
           RegCloseKey (hKeyA);
        }
        lstrcat (szKey, cszSlash);
        lstrcat (szKey, szEnum);

        // create a key with that name
        //
        if (RegCreateKey (hkInst, szEnum, &hKeyA))
            goto cleanup;

#ifdef DEBUG
        AuxDebugEx (6, DEBUGLINE TEXT ("created key %s\r\n"), szKey);
#endif

        // we are moving an instrument from one
        // external midi port to another
        //
        if (!bCreate)
        {
#ifdef DEBUG
            AuxDebugEx (3, DEBUGLINE TEXT ("Deleting key midi\\%s\r\n"), pmcl->pszKey);
#endif
            RegDeleteKey (pmcl->hkMidi, pmcl->pszKey);
            RebuildSchemes (pmcl->pszKey, szKey);
        }

        lstrcpy (pmcl->pszKey, szKey);
    }


  cleanup:
    if (hkInst)
       RegCloseKey (hkInst);

    return hKeyA;
}

/*+ SaveDetails
 *
 *-=================================================================*/

STATICFN UINT WINAPI SaveDetails (
    HWND    hWnd,
    PMCLASS pmcl,
    BOOL    bCreate)
{
    HWND   hWndT;
    HKEY   hKeyA;
    UINT   bChanges;
    UINT   cbSize;

    // this should only be called on shutdown
    // of details page (or on exit of wizard)
    //
    assert (pmcl->bDetails);

    hKeyA = OpenInstrumentKey (hWnd, pmcl, bCreate);
    if ( ! hKeyA)
        return FALSE;

    hWndT = GetDlgItem (hWnd, IDE_ALIAS);
    if (hWndT)
    {
        TCHAR sz[NUMELMS(pmcl->szAlias)];
        GetWindowText (hWndT, sz, NUMELMS(sz));
        if ( ! IsSzEqual(sz, pmcl->szAlias))
        {
            lstrcpy (pmcl->szAlias, sz);
            pmcl->bChanges |= MCL_ALIAS_CHANGED;
        }
    }

#ifdef DEBUG
    AuxDebugEx (2, DEBUGLINE TEXT ("--------SaveInstrument---------\r\n"));
    AuxDebugEx (2, TEXT ("\tChanges=%x\r\n"), pmcl->bChanges);
    AuxDebugEx (2, TEXT ("\tFriendly='%s'\r\n"), pmcl->szAlias);
    AuxDebugEx (2, TEXT ("\tDefinition='%s'\r\n"), pmcl->szFile);
#endif

    // save value data from this key
    //
    cbSize = (lstrlen(pmcl->szFile)+1) * sizeof(TCHAR);
    RegSetValueEx (hKeyA, cszDefinition, 0, REG_SZ, (LPBYTE)pmcl->szFile,
                   cbSize);

    cbSize = (lstrlen(pmcl->szAlias)+1) * sizeof(TCHAR);
    RegSetValueEx (hKeyA, cszFriendlyName, 0, REG_SZ,
                   (LPBYTE)pmcl->szAlias, cbSize);

    RegSetValueEx (hKeyA, cszPort, 0, REG_BINARY, (LPVOID)&pmcl->nPort, 1);

    RegCloseKey (hKeyA);

    bChanges = pmcl->bChanges;
    pmcl->bChanges = 0;

    // return 'changed' flag
    //
    return bChanges;
}


/*+ ParseAngleBrackets
 *
 *  replace '<>' delimiters with 0s and return a pointer
 *  to the delimited string. This function does nothing if
 *  the string does not end in a '>' delimiter
 *
 *-=================================================================*/

static LPTSTR __inline WINAPI ParseAngleBrackets (
    LPTSTR pszArg)
{
    LPTSTR psz = pszArg + lstrlen(pszArg);

    while (--psz > pszArg)
    {
        if (*psz == TEXT('>'))
        {
            *psz = 0;
            while (--psz >= pszArg)
            {
                if (*psz == TEXT('<'))
                {
                    *psz = 0;
                    return psz+1;
                }
            }
        }
    }

    return NULL;
}


/*+ fnFindDevice
 *
 *-=================================================================*/

struct _find_data {
    HWND   hWnd;
    UINT   idMfg;
    UINT   idProd;
    LPTSTR pszInstr;
    };

STATICFN BOOL WINAPI fnFindDevice (
    LPVOID        lpv,
    UINT          nEnum,
    LPIDFHEADER   pHdr,
    LPIDFINSTINFO pInst)
{
    struct _find_data * pfd = lpv;
    TCHAR szTemp[MAX_PATH];

    assert (pfd);

    MultiByteToWideChar(GetACP(), 0,
                        pHdr->abInstID, -1,
                        szTemp, sizeof(szTemp)/sizeof(TCHAR));

    if (!pfd->pszInstr ||
        IsSzEqual (pfd->pszInstr, szTemp))
    {
        if (SetDlgItemText (pfd->hWnd, pfd->idMfg, (TCHAR*)(pInst->abData+pInst->cbManufactASCII )))
            pfd->idMfg = 0;

        if (SetDlgItemText (pfd->hWnd, pfd->idProd,
                            (TCHAR*)(pInst->abData
                            + pInst->cbManufactASCII + pInst->cbManufactUNICODE)))
            pfd->idProd = 0;

        // we can stop enumerating now
        //
        return FALSE;
    }

    // return true to consider ennumeration
    //
    return TRUE;
}


/*+ ActivateInstrumentPage
 *
 *-=================================================================*/

STATICFN void WINAPI ActivateInstrumentPage (
    HWND    hWnd,
    PMCLASS pmcl)
{
    pmcl->bDetails = FALSE;
    if (GetDlgItem (hWnd, IDC_TYPES))
    {
        pmcl->bDetails = TRUE;
        LoadTypesIntoTree (hWnd, IDC_TYPES, pmcl);
        SetTypesEdit (hWnd, IDE_TYPES, pmcl);

        LoadDevicesIntoList (hWnd, IDC_DEVICES, pmcl, FALSE);

        if ( ! pmcl->bRemote)
        {
            HWND hWndT = GetDlgItem (hWnd, IDC_DEVICES);

            if (hWndT)
                EnableWindow (hWndT, FALSE);
        }
    }
    else
    {
        struct _find_data fd;
        TCHAR  szFile[NUMELMS(pmcl->szFile)];

        if ( ! IsFullPath (pmcl->szFile))
        {
           UINT  cch;

           GetIDFDirectory (szFile, NUMELMS(szFile));
           cch = lstrlen (szFile);
           if (cch && szFile[cch-1] != TEXT('\\'))
               szFile[cch++] = TEXT('\\');
           lstrcpyn (szFile + cch, pmcl->szFile, NUMELMS(szFile)-cch);
        }
        else
           lstrcpy (szFile, pmcl->szFile);

        fd.hWnd = hWnd;
        fd.idMfg = IDC_MANUFACTURER;
        fd.idProd = IDC_DEVICE_TYPE;
        fd.pszInstr = ParseAngleBrackets(szFile);

        idfEnumInstruments (szFile, fnFindDevice, &fd);

        if (fd.idMfg)
            SetDlgItemText (hWnd, fd.idMfg, cszEmpty);
        if (fd.idProd)
        {
            LoadString (ghInstance, IDS_UNSPECIFIED, szFile, NUMELMS(szFile));
            SetDlgItemText (hWnd, fd.idProd, szFile);
        }
    }
}


/*+ IsInstrumentKey
 *
 * return TRUE if the keyname passed refers to an instrument key
 * rather than a device key.  device keys usually end in '>',
 * while instrument keys will always be of the form
 * <dev>\Instruments\<enum>  where <dev> and <enum> can be arbitrary
 * strings.
 *
 *-=================================================================*/

STATICFN BOOL WINAPI IsInstrumentKey (
    LPTSTR pszKey)
{
    UINT cch = lstrlen(pszKey);
    if (!cch)
        return FALSE;

    if (pszKey[cch-1] == TEXT('>'))
        return FALSE;

    while (--cch)
        if (pszKey[cch] == TEXT('\\'))
            return TRUE;

    return FALSE;
}


/*+ InitInstrumentProps
 *
 *-=================================================================*/

STATICFN BOOL WINAPI InitInstrumentProps (
    HWND    hWnd,
    PMCLASS pmcl)
{
    LPPROPSHEETPAGE ppsp = pmcl->ppsp;
    PMPSARGS        pmpsa;

    assert (ppsp && ppsp->dwSize == sizeof(*ppsp));
    if (!ppsp)
        return FALSE; // EndDialog (hWnd, FALSE);

    pmcl->bRemote = FALSE;

    pmpsa = (LPVOID)ppsp->lParam;
    if (pmpsa && pmpsa->lpfnMMExtPSCallback)
    {
       pmpsa->lpfnMMExtPSCallback (MM_EPS_GETNODEDESC,
                                   (DWORD_PTR)pmcl->szAlias,
                                   sizeof(pmcl->szAlias),
                                   (DWORD_PTR)pmpsa->lParam);
#ifdef DEBUG
       AuxDebugEx (3, TEXT ("\tgot szAlias='%s'\r\n"), pmcl->szAlias);
#endif
       pmpsa->lpfnMMExtPSCallback (MM_EPS_GETNODEID,
                                   (DWORD_PTR)pmcl->szFullKey,
                                   sizeof(pmcl->szFullKey),
                                   (DWORD_PTR)pmpsa->lParam);
#ifdef DEBUG
       AuxDebugEx (3, TEXT ("\tgot szFullKey='%s'\r\n"), pmcl->szFullKey);
#endif
       // skip over the midi\ part of the key if we have been
       // passed that.  we want the driver name to be the first
       // part of the key
       //
       pmcl->pszKey = pmcl->szFullKey;
       if (!lstrnicmp (pmcl->pszKey,
                       (LPTSTR)cszMidiSlash,
                       lstrlen(cszMidiSlash)))
       {
           pmcl->pszKey += lstrlen(cszMidiSlash);
       }

       // If this is an instrument key, set bRemote to true
       //
       if (IsInstrumentKey(pmcl->pszKey))
          pmcl->bRemote = TRUE;
    }
    else
       LoadString (ghInstance, IDS_UNSPECIFIED,
                   pmcl->szAlias, NUMELMS(pmcl->szAlias));

    SetDlgItemText (hWnd, IDE_ALIAS, pmcl->szAlias);
    Static_SetIcon(GetDlgItem (hWnd, IDC_CLASS_ICON),
                   LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_INSTRUMENT)));

    LoadClass (hWnd, pmcl);

    //ActivateInstrumentPage(hWnd, pmcl);

    return TRUE;
}


/*+ NotifyMapper
 *
 *-=================================================================*/

STATICFN void WINAPI NotifyMapper (
    PMCLASS pmcl,
    UINT    bChanges,
    HWND    hWnd)
{
    // tell midi mapper about tree changes, IDF changes and port changes
    //
    if (bChanges & (MCL_TREE_CHANGED | MCL_IDF_CHANGED | MCL_PORT_CHANGED))
    {
        KickMapper (hWnd);
    }
}


/*+
 *
 *-=================================================================*/

STATICFN BOOL WINAPI RemoveInstrument (
    HWND    hWnd,
    PMCLASS pmcl)
{
    RegDeleteKey (pmcl->hkMidi, pmcl->pszKey);
    RebuildSchemes (pmcl->pszKey, NULL);
    return TRUE;
}

BOOL WINAPI RemoveInstrumentByKeyName (
    LPCTSTR pszKey)
{
    MCLASS  mcl;
    BOOL    rc = FALSE;

    memset ((TCHAR *)&mcl, 0x00, sizeof(mcl));
    mcl.pszKey = (LPTSTR)pszKey;

    if (!lstrnicmp (mcl.pszKey,
                    (LPTSTR)cszMidiSlash,
                    lstrlen(cszMidiSlash)))
    {
        mcl.pszKey += lstrlen(cszMidiSlash);
    }

    if (LoadClass (NULL, &mcl))
    {
        rc = RemoveInstrument (NULL, &mcl);

        if (mcl.hkMidi)
            RegCloseKey (mcl.hkMidi);
    }

    return rc;
}


/*+ MidiInstrumentCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiInstrumentCommands (
    HWND        hWnd,
    UINT_PTR    uId,
    LPNMHDR     lpnm)
{
    PMCLASS pmcl = GetDlgData(hWnd);

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("InstrumentCommands(..%d..) %d(%xx)\r\n"),
                uId, lpnm->code, lpnm->code);
#endif

    if (!pmcl)
        return FALSE;
    
    switch (uId)
    {
        case IDE_ALIAS:
            if (lpnm->code == EN_CHANGE)
                PropSheet_Changed(GetParent(hWnd), hWnd);
            break;

        case IDB_REMOVE:
            if (RemoveInstrument (hWnd, pmcl))
            {
                PMPSARGS  pmpsa = (LPVOID)pmcl->ppsp->lParam;
                if (pmpsa && pmpsa->lpfnMMExtPSCallback)
                    pmpsa->lpfnMMExtPSCallback (MM_EPS_TREECHANGE, 0, 0, (DWORD_PTR)pmpsa->lParam);

                NotifyMapper (pmcl, MCL_TREE_CHANGED, hWnd);
                SetDlgData(hWnd, NULL);
                if (pmcl->hkMidi)
                    RegCloseKey (pmcl->hkMidi), pmcl->hkMidi = NULL;

                LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
                PropSheet_PressButton(GetParent(hWnd), PSBTN_CANCEL);
            }
            break;

        case IDB_NEWTYPE:
            InstallNewIDF (hWnd);
            LoadTypesIntoTree (hWnd, IDC_TYPES, pmcl);
            SetTypesEdit (hWnd, IDE_TYPES, pmcl);
            break;

        case IDC_TYPES:
            if ((lpnm->code == TVN_SELCHANGED) && !pmcl->bFillingList)
            {
                HandleTypesSelChange (pmcl, lpnm);
                SetTypesEdit (hWnd, IDE_TYPES, pmcl);
                PropSheet_Changed(GetParent(hWnd), hWnd);
#ifdef DEBUG
                AuxDebugEx (5, DEBUGLINE TEXT ("file='%s'\r\n"), pmcl->szFile);
#endif
            }
            break;

        case IDC_DEVICES:
            if (lpnm->code == CBN_SELCHANGE)
            {
                int ix = ComboBox_GetCurSel (lpnm->hwndFrom);
                pmcl->ixDevice = (UINT) ((ix >= 0) ? ComboBox_GetItemData (lpnm->hwndFrom, ix) : -1);
                PropSheet_Changed(GetParent(hWnd), hWnd);
#ifdef DEBUG
                AuxDebugEx (4, DEBUGLINE TEXT ("IDC_DEVICES.selChange(%d) %d\r\n"), ix, pmcl->ixDevice);
#endif
            }
            break;

        // we get these only if invoked as a dialog, not as a property
        // sheet
        //
        case IDOK:
            {
            UINT bChanges = SaveDetails (hWnd, pmcl, FALSE);
            NotifyMapper (pmcl, bChanges, hWnd);
            }
            // fall through
        case IDCANCEL:
            EndDialog (hWnd, uId);
            break;

        case 0:
        {
            LONG lRet = FALSE;

            switch (lpnm->code)
            {
                case PSN_APPLY:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("ID_APPLY\r\n"));
#endif
                    if (pmcl->bDetails)
                    {
                        UINT bChanges = SaveDetails (hWnd, pmcl, FALSE);

                        NotifyMapper (pmcl, bChanges, hWnd);

                        // tell mmsys.cpl about tree & alias changes
                        //
                        if (bChanges & (MCL_TREE_CHANGED | MCL_ALIAS_CHANGED))
                        {
                            PMPSARGS  pmpsa = (LPVOID)pmcl->ppsp->lParam;
                            if (pmpsa && pmpsa->lpfnMMExtPSCallback)
                                pmpsa->lpfnMMExtPSCallback (MM_EPS_TREECHANGE, 0, 0, (DWORD_PTR)pmpsa->lParam);
                        }

                        // we do this because the SysTreeView for IDF files
                        // forgets its selection when APPLY is pressed. go figure
                        //
#ifdef DEBUG
                        AuxDebugEx (7,  DEBUGLINE TEXT ("PSN_APPLY: re-doing selection '%s'\r\n"), pmcl->szFile);
                        //ActivateInstrumentPage (hWnd, pmcl);
                        AuxDebugEx (7,  DEBUGLINE TEXT ("PSN_APPLY: done re-doing selection '%s'\r\n"), pmcl->szFile);
#endif
                    }
                    break;

                case PSN_KILLACTIVE:
                    break;

                case PSN_SETACTIVE:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_SETACTIVE\r\n"));
#endif
                    ActivateInstrumentPage (hWnd, pmcl);
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_SETACTIVE ends\r\n"));
#endif
                    break;
            }
            SetWindowLongPtr (hWnd, DWLP_MSGRESULT, (LONG_PTR)lRet);
            break;
        }
    }

    return FALSE;
}

const static DWORD aKeyWordIds[] = {  // Context Help IDs
    IDC_CLASS_ICON, IDH_MMCPL_DEVPROP_DETAILS_INSTRUMENT,
    IDE_ALIAS,      IDH_MMCPL_DEVPROP_DETAILS_INSTRUMENT,
    IDC_DEVICES,    IDH_MMCPL_DEVPROP_DETAILS_MIDI_PORT,
    IDC_TYPES,      IDH_MMCPL_DEVPROP_DETAILS_INS_DEF,
    IDB_NEWTYPE,    IDH_MMCPL_DEVPROP_DETAILS_BROWSE,

    0, 0
};

/*+ MidiInstrumentDlgProc
 *
 *-=================================================================*/

INT_PTR CALLBACK MidiInstrumentDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
   #if defined DEBUG || defined DEBUG_RETAIL
    TCHAR chNest = szNestLevel[0]++;
   #endif

    switch (uMsg)
    {
        case WM_COMMAND:
            {
            NMHDR nmh;
            nmh.hwndFrom = GET_WM_COMMAND_HWND(wParam, lParam);
            nmh.idFrom   = GET_WM_COMMAND_ID(wParam, lParam);
            nmh.code     = GET_WM_COMMAND_CMD(wParam, lParam);

            MidiInstrumentCommands(hWnd, nmh.idFrom, &nmh);
            }
            break;
        
        case WM_NOTIFY:
#ifdef DEBUG
            AuxDebugEx (3, DEBUGLINE TEXT ("WM_NOTIFY(%x,%x,%x)\r\n"), hWnd, wParam, lParam);
#endif

           #if defined DEBUG || defined DEBUG_RETAIL
            ++szNestLevel[0];
           #endif

            MidiInstrumentCommands(hWnd, wParam, (LPVOID)lParam);

           #if defined DEBUG || defined DEBUG_RETAIL
            --szNestLevel[0];
           #endif
            break;
        
        case WM_INITDIALOG:
        {
            PMCLASS         pmcl;

            pmcl = (LPVOID)LocalAlloc(LPTR, sizeof(*pmcl));
            if (!pmcl)
			{
                EndDialog(hWnd, FALSE);
				break;
			}

            pmcl->ppsp = (LPVOID)lParam;
            SetDlgData (hWnd, pmcl);

#ifdef DEBUG
            AuxDebugEx (5, DEBUGLINE TEXT ("midiInstrument.WM_INITDLG ppsp=%08X\r\n"));
#endif
            //AuxDebugDump (8, pmcl->ppsp, sizeof(*(pmcl->ppsp)));

            InitInstrumentProps (hWnd, pmcl);
            break;
        }

        case WM_DESTROY:
        {
            PMCLASS pmcl = GetDlgData(hWnd);

            if (pmcl)
            {
                if (pmcl->hkMidi)
                    RegCloseKey (pmcl->hkMidi), pmcl->hkMidi = NULL;

               #ifdef USE_IDF_ICONS

                if (pmcl->hIDFImageList)
                {
                    HWND hWndT = GetDlgItem (hWnd, IDC_TYPES);
                    if (hWndT)
                        TreeView_SetImageList (hWndT, NULL, TVSIL_NORMAL);

                    ImageList_Destroy (pmcl->hIDFImageList);
                    pmcl->hIDFImageList = NULL;
                }

               #endif

                LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)pmcl);
            }

            break;
        }

        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (UINT_PTR) (LPTSTR) aKeyWordIds);
            break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
                    (UINT_PTR) (LPTSTR) aKeyWordIds);
            break;
        }
    }

   #if defined DEBUG || defined DEBUG_RETAIL
    szNestLevel[0] = chNest;
   #endif
    return FALSE;
}


/// --------------------- Wizard stuff ----------------------

static LPTSTR aidWiz[] = {
    MAKEINTRESOURCE(IDD_MIDIWIZ02),
    MAKEINTRESOURCE(IDD_MIDIWIZ03),
    MAKEINTRESOURCE(IDD_MIDIWIZ04)
    };

#define WIZ_TEMPLATE_DEVICE  aidWiz[0]
#define WIZ_TEMPLATE_IDF     aidWiz[1]
#define WIZ_TEMPLATE_ALIAS   aidWiz[2]

typedef struct _wizdata {
    LPPROPSHEETPAGE ppspActive;
    HBITMAP         hBmp;
    MCLASS          mcl;
    PMCMIDI         pmcm;
    HPROPSHEETPAGE  ahpsp[NUMELMS(aidWiz)];
    } WIZDATA, * PWIZDATA;

/*+ FindInstrument
 *
 *-=================================================================*/

STATICFN PINSTRUM WINAPI FindInstrument (
    PMCMIDI  pmcm,
    LPTSTR   pszFriendly)
{
    UINT  ii;

    for (ii = 0; ii < pmcm->nInstr; ++ii)
    {
        assert (pmcm->api[ii]);
        if (IsSzEqual(pszFriendly, pmcm->api[ii]->szFriendly))
            return pmcm->api[ii];
    }

    return NULL;
}

/*+ UniqueFriendlyName
 *
 *-=================================================================*/

STATICFN BOOL WINAPI fnFirstInstr (
    LPVOID        lpv,
    UINT          nEnum,
    LPIDFHEADER   pHdr,
    LPIDFINSTINFO pInst)
{
    LPTSTR pszInstr = lpv;

    assert (pszInstr);

    MultiByteToWideChar(GetACP(), 0,
                        pHdr->abInstID, -1,
                        pszInstr, MAX_ALIAS);

    return FALSE;
}

STATICFN BOOL WINAPI UniqueFriendlyName (
    PMCMIDI pmcm,
    PMCLASS pmcl,
    LPTSTR  pszAlias,
    UINT    cchAlias)
{
    TCHAR  szFile[MAX_PATH * 2];
    LPTSTR pszInstr;
    UINT   cch;
    UINT   ii;

    GetIDFDirectory (szFile, sizeof(szFile)/sizeof(TCHAR));
    cch = lstrlen(szFile);
    if (cch && szFile[cch-1] != TEXT('\\'))
        szFile[cch++] = TEXT('\\');
    lstrcpy (szFile + cch, pmcl->szFile);
    pszInstr = ParseAngleBrackets (szFile);
    if ( ! pszInstr)
    {
        pszInstr = szFile + lstrlen(szFile) + 1;
        idfEnumInstruments (szFile, fnFirstInstr, pszInstr);
    }

    // if no instrument name from the IDF file, get a default
    // from our resources
    //
    if ( ! lstrlen (pszInstr))
    {
        LoadString (ghInstance, IDS_DEF_INSTRNAME, pszInstr, MAX_ALIAS);
        return FALSE;
    }

    // make the instrument name the same as the alias, and prepare
    // to append a number if the alias turns out not to be unique
    //
    lstrcpyn (pszAlias, pszInstr, cchAlias);
    cch = lstrlen (pszAlias);
    cch = min (cch, (UINT)MAX_ALIAS-3);
    ii = 1;

    // loop while we are trying to use an instrument name
    // that has already been used
    //
    while (FindInstrument (pmcm, pszAlias))
    {
        static CONST TCHAR cszSpaceD[] = TEXT (" %d");

        wsprintf (pszAlias + cch, cszSpaceD, ++ii);
        if (ii > NUMELMS(pmcm->api))
        {
            assert2(0, TEXT ("infinite loop in UniqueFriendlyName!"));
            break;
        }
    }

    return TRUE;
}


/*+ MidiWizardCommands
 *
 *-=================================================================*/

BOOL WINAPI MidiWizardCommands (
    HWND        hWnd,
    UINT_PTR    uId,
    LPNMHDR     lpnm)
{
    PWIZDATA         pwd;
    LPPROPSHEETPAGE  ppsp = GetDlgData(hWnd);
    LONG             lRet = TRUE;

#ifdef DEBUG
    AuxDebugEx (4, DEBUGLINE TEXT ("WizardCmd ppsp=%08X code=%d(0x%X)\r\n"),
                ppsp, lpnm->code, lpnm->code);
#endif

    pwd = NULL;
    if (ppsp)
        pwd = (LPVOID)ppsp->lParam;
    assert (pwd);

    switch (uId)
    {
        case IDC_TYPES:
            if ((lpnm->code == TVN_SELCHANGED) && !pwd->mcl.bFillingList)
            {
                HandleTypesSelChange (&pwd->mcl, lpnm);
                UniqueFriendlyName (pwd->pmcm, &pwd->mcl, pwd->mcl.szAlias, NUMELMS(pwd->mcl.szAlias));
#ifdef DEBUG
                AuxDebugEx (5, DEBUGLINE TEXT ("file='%s'\r\n"), pwd->mcl.szFile);
#endif
            }
            break;

        case IDB_NEWTYPE:
            InstallNewIDF (hWnd);
            LoadTypesIntoTree (hWnd, IDC_TYPES, &pwd->mcl);
            break;

        //case IDC_DEVICES:
        //    break;
        //case IDE_ALIAS:
        //    break;

        case 0:
        {
            switch (lpnm->code)
            {
                case PSN_HELP:
                    break;

                case PSN_KILLACTIVE:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_KILLACTIVE\r\n"));
#endif
                    break;

                case PSN_SETACTIVE:
                {
                    DWORD dwWizBtn;

#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_SETACTIVE\r\n"));
#endif
                    if (pwd)
                        pwd->ppspActive = ppsp;

                    if (ppsp->pszTemplate == WIZ_TEMPLATE_DEVICE) // midi device
                        LoadDevicesIntoList (hWnd, IDC_DEVICES, &pwd->mcl, TRUE);
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_IDF) // idf file
                        LoadTypesIntoTree (hWnd, IDC_TYPES, &pwd->mcl);
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_ALIAS) // alias
                        SetDlgItemText (hWnd, IDE_ALIAS, pwd->mcl.szAlias);

                    dwWizBtn = PSWIZB_NEXT | PSWIZB_BACK;
                    if (ppsp->pszTemplate == aidWiz[NUMELMS(aidWiz)-1])
                        dwWizBtn = PSWIZB_FINISH | PSWIZB_BACK;
                    else if (ppsp->pszTemplate == aidWiz[0])
                        dwWizBtn = PSWIZB_NEXT;

                    PropSheet_SetWizButtons (GetParent(hWnd), dwWizBtn);
                }
                    break;

                case PSN_WIZNEXT:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_WIZNEXT\r\n"));
#endif

                    if (ppsp->pszTemplate == WIZ_TEMPLATE_DEVICE) // midi device
                    {
                        HWND   hWndT;
                        int    ix;

                        pwd->mcl.ixDevice = (UINT)-1;
                        pwd->mcl.nPort = 0;

                        hWndT = GetDlgItem (hWnd, IDC_DEVICES);
                        if (hWndT)
                        {
                            ix = ListBox_GetCurSel (hWndT);
                            if (ix >= 0)
                                pwd->mcl.ixDevice = (UINT) ListBox_GetItemData (hWndT, ix);
                        }

                        if (pwd->mcl.ixDevice == (UINT)-1)
                            SetWindowLongPtr (hWnd, DWLP_MSGRESULT, (LONG_PTR)-1);
                    }
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_IDF) // idf file
                    {
                        if ( ! pwd->mcl.szAlias[0])
                        {
                            LoadString (ghInstance, IDS_DEF_INSTRNAME,
                                        pwd->mcl.szAlias,
                                        NUMELMS(pwd->mcl.szAlias));
                        }
                    }
                    else if (ppsp->pszTemplate == WIZ_TEMPLATE_IDF) // alias
                    {
                        GetDlgItemText (hWnd, IDE_ALIAS, pwd->mcl.szAlias,
                                        NUMELMS(pwd->mcl.szAlias));
                    }
                    break;

                case PSN_WIZBACK:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_WIZBACK\r\n"));
#endif
                    break;

                case PSN_WIZFINISH:
#ifdef DEBUG
                    AuxDebugEx (4, DEBUGLINE TEXT ("PSN_WIZFINISH\r\n"));
#endif
                    //if (!save success)
                       lRet = FALSE;
                    //SetWindowLong (hWnd, DWL_MSGRESULT, lRet);
                    SaveDetails (hWnd, &pwd->mcl, TRUE);
                    break;

                default:
                    lRet = FALSE;
            }
        }
            break;
    }

    return lRet;
}


/*+ MidiWizardDlgProc
 *
 *-=================================================================*/

INT_PTR CALLBACK MidiWizardDlgProc (
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL bRet = TRUE;
   #if defined DEBUG || defined DEBUG_RETAIL
    TCHAR chNest = szNestLevel[0]++;
   #endif

    switch (uMsg)
    {
        case WM_COMMAND:
            {
            NMHDR nmh;
            nmh.hwndFrom = GET_WM_COMMAND_HWND(wParam, lParam);
            nmh.idFrom   = GET_WM_COMMAND_ID(wParam, lParam);
            nmh.code     = GET_WM_COMMAND_CMD(wParam, lParam);

            bRet = MidiWizardCommands(hWnd, nmh.idFrom, &nmh);
            }
            break;
        
        case WM_NOTIFY:
#ifdef DEBUG
            AuxDebugEx (6, DEBUGLINE TEXT ("WM_NOTIFY(%x,%x,%x)\r\n"), hWnd, wParam, lParam);
#endif
            bRet = MidiWizardCommands(hWnd, wParam, (LPVOID)lParam);
            break;
        
        case WM_INITDIALOG:
        {
            PWIZDATA         pwd;
            LPPROPSHEETPAGE  ppsp = (LPVOID)lParam;

            SetDlgData (hWnd, lParam);

            pwd = (LPVOID)ppsp->lParam;

            SendDlgItemMessage(hWnd, IDC_WIZBMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)pwd->hBmp);

#ifdef DEBUG
            AuxDebugEx (5, DEBUGLINE TEXT ("MidiWizard.WM_INITDLG ppsp=%08X\r\n"), ppsp);
#endif
        }
            break;

        case WM_DESTROY:
        {
            PWIZDATA         pwd;
            LPPROPSHEETPAGE  ppsp = GetDlgData(hWnd);

            if (ppsp && (pwd = (LPVOID)ppsp->lParam) != NULL)
            {
                if (pwd->mcl.hkMidi)
                    RegCloseKey (pwd->mcl.hkMidi), pwd->mcl.hkMidi = NULL;

               #ifdef USE_IDF_ICONS

                if (pwd->mcl.hIDFImageList)
                {
                    HWND hWndT = GetDlgItem (hWnd, IDC_TYPES);
                    if (hWndT)
                        TreeView_SetImageList (hWndT, NULL, TVSIL_NORMAL);

                    ImageList_Destroy (pwd->mcl.hIDFImageList);
                    pwd->mcl.hIDFImageList = NULL;
                }

               #endif

            }
        }
            break;

        default:
            bRet = FALSE;
            break;
    }

   #if defined DEBUG || defined DEBUG_RETAIL
    szNestLevel[0] = chNest;
   #endif
    return bRet;
}


INT CALLBACK
iSetupDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{
    switch( uMsg )
    {
        case PSCB_INITIALIZED:
            break;

        case PSCB_PRECREATE:
            if( lParam ){
                DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
                pDlgTemplate->style &= ~DS_CONTEXTHELP;
            }
            break;
    }

    return FALSE;
}

/*+ MidiInstrumentsWizard
 *
 *-=================================================================*/

INT_PTR MidiInstrumentsWizard (
    HWND    hWnd,
    PMCMIDI pmcm,       // optional
    LPTSTR  pszDriverKey) // optional
{
    WIZDATA         wd;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    UINT            ii;
    INT_PTR         iRet = -1;
    LPTSTR          psz;

    ZeroMemory (&wd, sizeof(wd));
    wd.mcl.bDetails = TRUE;
    wd.mcl.bRemote = TRUE;
    wd.mcl.ixDevice = 0;
    LoadString (ghInstance, IDS_DEF_DEFINITION, wd.mcl.szFile,
                NUMELMS(wd.mcl.szFile));

    // set the default driver key to what was passed.
    // If someone passed us a path, rather than a driver key
    // null out the '\\' characters so that we see only the
    // leading driver part of the key.
    //
    wd.mcl.pszKey = wd.mcl.szFullKey;
    if (pszDriverKey)
       lstrcpy (wd.mcl.szFullKey, pszDriverKey);
    if (!lstrnicmp (wd.mcl.pszKey, (LPTSTR)cszMidiSlash, lstrlen(cszMidiSlash)))
        wd.mcl.pszKey += lstrlen(cszMidiSlash);
    psz = wd.mcl.pszKey;
    while (*psz)
    {
        if (*psz == TEXT('\\'))
            *psz = 0;
        ++psz;
    }

    // load all current instrument names from the registry
    //
    if (!(wd.pmcm = pmcm))
    {
        wd.pmcm = (LPVOID) LocalAlloc (LPTR, sizeof(MCMIDI));
		if (!wd.pmcm) return -1;
        LoadInstruments (wd.pmcm, FALSE);
    }

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = ghInstance;
    psp.pfnDlgProc = MidiWizardDlgProc;
    psp.lParam = (LPARAM)&wd;

    for (psh.nPages = 0, ii = 0; ii < NUMELMS(aidWiz); ++ii)
    {
        HPROPSHEETPAGE hpsp;

        psp.pszTemplate = aidWiz[ii];
        wd.ahpsp[psh.nPages] = hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
            ++psh.nPages;
    }

    if ( ! psh.nPages)
        return -1;

    wd.hBmp = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_WIZBMP));
#ifdef DEBUG
    AuxDebugEx (3, DEBUGLINE TEXT ("Wizard bitmap = %08X\r\n"));
#endif

    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE | PSH_WIZARD_LITE | PSH_USECALLBACK;
    psh.hwndParent = hWnd;
    psh.hInstance = ghInstance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_WIZNAME);
    psh.nPages = NUMELMS(aidWiz);
    psh.nStartPage = 0;
    psh.phpage = wd.ahpsp;
    psh.pfnCallback = iSetupDlgCallback;

    iRet = PropertySheet (&psh);

    // free dynamically allocated stuff.
    //
    if (wd.hBmp)
       DeleteObject (wd.hBmp);

    // if no MCMIDI was passed, we dynamically loaded one,
    // so now we need to free it.
    //
    if ( ! pmcm)
    {
        if (wd.pmcm->hkMidi)
            RegCloseKey (wd.pmcm->hkMidi);
        FreeInstruments (wd.pmcm);
        LocalFree ((HLOCAL)(UINT_PTR)(DWORD_PTR)wd.pmcm);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\dispfram.c ===
/*
 **************************************************************************
 *
 *  dispfram.c
 *
 *  DispFrame Control DLL defines a bitmap display control to be used
 *  by any windows application.
 *
 *  Copyright 1991-3, Microsoft Corporation
 *
 *  History:
 *
 *  In Sik Rhee - 7/15/91 (original slider.dll)
 *  Ben Mejia - 1/22/92 (made display.dll)	 
 **************************************************************************
 */
#pragma warning(disable:4704)
#include <windows.h>
#include <custcntl.h>
#include <commctrl.h>
#include "draw.h"

/*
 **************************************************************************
 * global static variables 
 **************************************************************************
 */
UINT				gwPm_DispFrame;
extern HINSTANCE	ghInstance;


/*
 **************************************************************************
 * prototypes 
 **************************************************************************
 */

LONG PASCAL dfPaint				(HWND hWnd);
LONG PASCAL dfSetBitmap			(HWND hWnd, HBITMAP hBmpNew, HPALETTE 
																hPalNew);
BOOL PASCAL RegSndCntrlClass	(LPCTSTR lpszSndCntrlClass);
LRESULT PASCAL dfDispFrameWndFn	(HWND hWnd, UINT wMessage, WPARAM wParam, 
																LPARAM lParam);
BOOL dfDrawRect					(HDC hdcRect, RECT rFrame);

/*
 **************************************************************************
 * RegSndCntrlClass
 *
 * Description: Registers the SndCntrlClass, must be called in LibMain
 *
 * Arguments:
 *   LPTSTR		lpszSndCntrlClass
 *
 *  Returns:	BOOL
 *      TRUE if RegisterClass succeeds, else FALSE
 *
 **************************************************************************
 */
BOOL PASCAL RegSndCntrlClass(LPCTSTR lpszSndCntrlClass)
{

    extern UINT     gwPm_DispFrame;

    /* local variables */
    WNDCLASS    ClassStruct;

    /* check to see if class already exists;  if so, simply return TRUE */
    if (GetClassInfo(ghInstance, lpszSndCntrlClass, &ClassStruct))
        return TRUE;

	/* define dispfram class attributes */
	ClassStruct.lpszClassName   = (LPTSTR)DISPFRAMCLASS;
	ClassStruct.hCursor         = LoadCursor( NULL, IDC_ARROW );
	ClassStruct.lpszMenuName    = (LPTSTR)NULL;
	ClassStruct.style           = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
	ClassStruct.lpfnWndProc     = dfDispFrameWndFn;
	ClassStruct.hInstance       = ghInstance;
	ClassStruct.hIcon           = NULL;
	ClassStruct.cbWndExtra      = DF_DISP_EXTRA;
	ClassStruct.cbClsExtra      = 0;
	ClassStruct.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1 );

	/* register display frame window class */
	if (!RegisterClass(&ClassStruct))
		return FALSE;
	gwPm_DispFrame = RegisterWindowMessage((LPTSTR) DF_WMDISPFRAME);

	if (!gwPm_DispFrame)    /* failed to create message */
		return FALSE;
	return TRUE;
}

/*
 **************************************************************************
 * dfDispFrameWndFn
 * 
 * Description:   Window function for display frame control.
 *
 * Arguments:     
 *	 HWND	hWnd - handle to control window.
 *   UINT	wMessage - the message
 *   WPARAM	wParam
 *   LPARAM	lParam
 * Returns: LONG
 *     result of message processing... depends on message sent.
 * 
 **************************************************************************
 */

LRESULT PASCAL dfDispFrameWndFn(HWND hWnd, UINT wMessage, WPARAM wParam, 
																LPARAM lParam)
{
	HBITMAP		hBmp;

    switch (wMessage)
    {
    case WM_CREATE:
        DF_SET_BMPHANDLE(0);
        DF_SET_BMPPAL(0);
        return 0;

    case WM_DESTROY:
		/* Free up stored bitmap and palette, if any.
		*/
		hBmp = (HBITMAP)DF_GET_BMPHANDLE;
		if (hBmp)
	        DeleteObject(hBmp);
        return 0;

	case WM_SYSCOLORCHANGE:
		InvalidateRect(hWnd, NULL, TRUE);
		return 0;

    case WM_PAINT:
		return dfPaint(hWnd);

    /* Custom Control Messages */
    case DF_PM_SETBITMAP:
		return dfSetBitmap(hWnd, (HBITMAP)wParam, (HPALETTE)lParam);
    }
    return DefWindowProc(hWnd, wMessage, wParam, lParam);
}

/*
 **************************************************************************
 * dfDrawRect
 *
 * Description:  Draws background of control window.
 *
 * Params:     
 *   HWND	hWnd - handle to control window.
 *   RECT	rFrame - bounding rectangle.
 *
 * Returns:    BOOL
 *	Pass/Fail indicator 0 indicates failure.
 **************************************************************************	 
 */
BOOL dfDrawRect(HDC hdcRect, RECT rFrame)
{
    HANDLE      hBrush;
    HANDLE      hOldBrush;
    HANDLE      hPen;
    HANDLE      hOldPen;
    HANDLE      hPen3DHILIGHT;
											    
    /* Get DC's pen and brush for frame redraw
    */
    hBrush = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
    if (!hBrush)
        return FALSE;
	hPen = CreatePen(PS_SOLID, 2, GetSysColor(COLOR_WINDOWFRAME));

	if (!hPen)
	{
		DeleteObject(hBrush);
		return FALSE;
	}

	hPen3DHILIGHT = CreatePen(PS_SOLID, 2, GetSysColor(COLOR_3DHILIGHT));

	if (!hPen3DHILIGHT)
	{
		DeleteObject(hBrush);
		DeleteObject(hPen);
		return FALSE;
	}
    hOldBrush = SelectObject(hdcRect, hBrush);
    //hOldPen = SelectObject(hdcRect, hPen);
	hOldPen = SelectObject(hdcRect, hPen3DHILIGHT);

	/* paint the window.
	*/
    //Rectangle(hdcRect, rFrame.left, rFrame.top, rFrame.right,
    //    rFrame.bottom);
	MoveToEx(hdcRect, rFrame.left,rFrame.bottom, NULL);
	LineTo(hdcRect, rFrame.right,rFrame.bottom);
	LineTo(hdcRect, rFrame.right,rFrame.top);
	SelectObject(hdcRect, hPen);
	LineTo(hdcRect, rFrame.left,rFrame.top);
	LineTo(hdcRect, rFrame.left,rFrame.bottom);
	SelectObject(hdcRect, hOldPen);
	SelectObject(hdcRect, hOldBrush);

    /*clean up brush and pen */
    //DeleteObject();
    DeleteObject(hBrush);
    DeleteObject(hPen3DHILIGHT);
    DeleteObject(hPen);
    return TRUE;
}

/*
 **************************************************************************
 * dfPaint
 *
 * Description:   Paints background and bitmap, if any.
 *
 * Params:     
 *    HWND	hWnd - handle to control window
 *		 
 * Returns: LONG   
 *			0 if OK, -1 otherwise. (for windproc return)
 * 
 **************************************************************************
 */
LONG PASCAL dfPaint(HWND hWnd)
{
	HBITMAP hBmp;
	HBITMAP hPrev;
	RECT rFrame;
	PAINTSTRUCT ps;
	HDC hdcMem;
	BITMAP bmp;
	int x, y, dx, dy;

	/* Setup to do the painting
	*/
 	if(!GetUpdateRect(hWnd,NULL,FALSE))
 		return 0L;
    BeginPaint(hWnd, &ps);
	GetClientRect(hWnd, &rFrame);
	hBmp = (HBITMAP)DF_GET_BMPHANDLE;
	if (hBmp)
	{
		hdcMem = CreateCompatibleDC(ps.hdc);
		if (!hdcMem)
		{
			EndPaint(hWnd, &ps);
			return -1L;
		}
		hPrev = SelectObject(hdcMem, hBmp);
	
		/* Get the size of the bitmap to center it in the frame.
		*/
		GetObject(hBmp, sizeof(BITMAP), (LPTSTR)&bmp);
		if (bmp.bmWidth > (rFrame.right-rFrame.left))
		{
			x = 0;
			dx = rFrame.right-rFrame.left;
		}
		else
		{
			x = ((rFrame.right-rFrame.left - bmp.bmWidth) >> 1);
			dx = bmp.bmWidth;
		}
		if (bmp.bmHeight > (rFrame.bottom-rFrame.top))
		{
			y = 0;
			dy = rFrame.bottom-rFrame.top;
		}
		else
		{
			y = ((rFrame.bottom-rFrame.top - bmp.bmHeight) >> 1);
			dy = bmp.bmHeight;
		}
	
		/* Draw the frame & background, then blt in the bitmap.
		*/
		dfDrawRect(ps.hdc, rFrame);
		BitBlt(ps.hdc, x, y, dx, dy, hdcMem, 0, 0, SRCCOPY);

		/* Cleanup and exit.
		*/
		SelectObject(hdcMem, hPrev);
		DeleteDC(hdcMem);
	}
	else
		/* if no bitmap, just repaint the background.
		*/
		dfDrawRect(ps.hdc, rFrame);
		
	EndPaint(hWnd, &ps);
	return 0L;
}


/*
 **************************************************************************
 * dfSetBitmap
 * 
 * Description:   Load a new bitmap into the control.
 *
 * Arguments:     
 *		HWND		hWnd - handle to control window.
 *		HBITMAP		hBmpNew - handle to new bitmap.
 *		HPALETTE	hPalNew - handle to new bitmap's palette (Optional).
 * Returns:			LONG
 *				0 for success; -1 if fails (for return by wndproc).
 * 
 **************************************************************************
 */
LONG PASCAL dfSetBitmap(HWND hWnd, HBITMAP hBmpNew, HPALETTE hPalNew)
{
	HBITMAP hBmp;
	HANDLE hPrev;
	HANDLE hPrevNew;
	HDC hdcMem;
	HDC hdcNew;
	HDC hDC;
	RECT rFrame;
	int dx, dy;
	BITMAP bmp;

	/* Cleanup any existing bitmap & palette
	*/
	hBmp = (HBITMAP)DF_GET_BMPHANDLE;
	if (hBmp)
		DeleteObject(hBmp);
    DF_SET_BMPHANDLE(0);
    DF_SET_BMPPAL(0);
	InvalidateRect(hWnd, NULL, TRUE);

	/* Copy the displayable portion of the bitmap into a private copy.
	*/
    if (hBmpNew)
    {
		/* get all the req'd DC's etc.
		*/
        hDC = GetDC(hWnd);
        hdcMem = CreateCompatibleDC(hDC);
        if (!hdcMem)
        {
            ReleaseDC(hWnd, hDC);
            return -1L;
        }
        hdcNew = CreateCompatibleDC(hDC);
        if (!hdcNew)
        {
            ReleaseDC(hWnd, hDC);
            return -1L;
        }
        GetObject(hBmpNew, sizeof(BITMAP), (LPTSTR)&bmp);
        hBmp = CreateCompatibleBitmap(hDC, bmp.bmWidth, bmp.bmHeight);
        if (!hBmp)
        {
            DeleteDC(hdcMem);
            DeleteDC(hdcNew);
            ReleaseDC(hWnd, hDC);
            return -1L;
        }
  	    hPrevNew = SelectObject(hdcNew, hBmpNew);
        hPrev = SelectObject(hdcMem, hBmp);

		/* figure out how much of the bitmap we need to copy.
		*/    
		GetClientRect(hWnd, &rFrame);
        if (bmp.bmWidth > (rFrame.right-rFrame.left))
            dx = rFrame.right-rFrame.left;
        else
            dx = bmp.bmWidth;
        if (bmp.bmHeight > (rFrame.bottom-rFrame.top))
            dy = rFrame.bottom-rFrame.top;
        else
            dy = bmp.bmHeight;

		/* copy the bitmap.
		*/
        BitBlt(hdcMem, 0, 0, dx, dy, hdcNew, 0 , 0, SRCCOPY);

		/* cleanup
		*/
		hBmp = SelectObject(hdcMem, hPrev);
        DF_SET_BMPHANDLE(hBmp);
		DeleteDC(hdcMem);
		SelectObject(hdcNew, hPrevNew);
		DeleteDC(hdcNew);
		ReleaseDC(hWnd, hDC);

		/* if a palette is handed in, store it too.
		*/
	    DF_SET_BMPPAL(hPalNew);
   }
   return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\dib.c ===
/****************************************************************************
 *
 *  MODULE  : DIB.C
 *
 *  DESCRIPTION : Routines for dealing with Device Independent Bitmaps.
 *
 *  FUNCTION   :bmfNumDIBColors(HANDLE hDib)
 *
 *  FUNCTION   :bmfCreateDIBPalette(HANDLE hDib)
 *
 *  FUNCTION   :bmfDIBSize(HANDLE hDIB)
 *
 *  FUNCTION   :bmfDIBFromBitmap(HBITMAP hBmp, DWORD biStyle, WORD biBits,
 *                               HPALETTE hPal)
 *
 *  FUNCTION   :bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
 *
 *  FUNCTION   :bmfBitmapFromIcon (HICON hIcon, DWORD dwColor)
 *
 *  FUNCTION   :bmfDrawBitmap(HDC hdc, int xpos, int ypos, HBITMAP hBmp,
 *                            DWORD rop)
 *
 *  FUNCTION   :bmfDrawBitmapSize(HDC hdc, int x, int y, int xSize,
 *                                int ySize, HBITMAP hBmp, DWORD rop)
 *
 *  FUNCTION   :DIBInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi)
 *
 *  FUNCTION   :CreateBIPalette(LPBITMAPINFOHEADER lpbi)
 *
 *  FUNCTION   :PaletteSize(VOID FAR * pv)
 *
 *  FUNCTION   :NumDIBColors(VOID FAR * pv)
 *
 *  FUNCTION   :LoadUIBitmap(HANDLE hInstance, LPCTSTR szName, 
 *							 COLORREF rgbText,
 *                           COLORREF rgbFace, COLORREF rgbShadow,
 *                           COLORREF rgbHighlight, COLORREF rgbWindow,
 *                           COLORREF rgbFrame)
 *
 ****************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <stdlib.h>
#include <shellapi.h>
#include "draw.h"

/* global variables */
extern      HANDLE        ghInstance;    //instance handle of DIB.DLL

/***************************************************************************
 *
 *  FUNCTION   :bmfNumDIBColors(HANDLE hDib)
 *
 *  PURPOSE    :Returns the number of colors required to display the DIB
 *              indicated by hDib.
 *
 *  RETURNS    :The number of colors in the DIB. Possibilities are
 *              2, 16, 256, and 0 (0 indicates a 24-bit DIB).  In
 *              the case of an error, -1 is returned.
 *
 ****************************************************************************/

WORD WINAPI bmfNumDIBColors (HANDLE hDib)
{
    WORD                bits;
    LPBITMAPINFOHEADER  lpbi;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (!lpbi)
	return ((WORD)-1);

    /* The function NumDIBColors will return the number of colors in the
     * DIB by looking at the BitCount field in the info block
     */
    bits = NumDIBColors(lpbi);
    GlobalUnlock(hDib);
    return(bits);
}


/***************************************************************************
 *
 *  FUNCTION   :bmfCreateDIBPalette(HANDLE hDib)
 *
 *  PURPOSE    :Creates a palette suitable for displaying hDib.
 *
 *  RETURNS    :A handle to the palette if successful, NULL otherwise.
 *
 ****************************************************************************/

HPALETTE WINAPI bmfCreateDIBPalette (HANDLE hDib)
{
    HPALETTE            hPal;
    LPBITMAPINFOHEADER  lpbi;

    if (!hDib)
	return NULL;    //bail out if handle is invalid

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (!lpbi)
	return NULL;

    hPal = CreateBIPalette(lpbi);
    GlobalUnlock(hDib);
    return hPal;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDIBSize(HANDLE hDIB)
 *
 *  PURPOSE    :Return the size of a DIB.
 *
 *  RETURNS    :DWORD with size of DIB, include BITMAPINFOHEADER and
 *              palette.  Returns 0 if failed.
 *
 *  HISTORY:
 *  92/08/13 -  BUG 1642: (w-markd)
 *              Added this function so Quick Recorder could find out the
 *              size of a DIB.
 *  92/08/29 -  BUG 2123: (w-markd)
 *              If the biSizeImage field of the structure we get is zero,
 *              then we have to calculate the size of the image ourselves.
 *              Also, after size is calculated, we bail out if the 
 *              size we calculated is larger than the size of the global
 *              object, since this indicates that the structure data
 *              we used to calculate the size was invalid.
 *
 ****************************************************************************/

DWORD WINAPI bmfDIBSize(HANDLE hDIB)
{
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwSize;

    /* Lock down the handle, and cast to a LPBITMAPINFOHEADER
    ** so we can read the fields we need
    */
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
    if (!lpbi)
	return 0;

    /* BUG 2123: (w-markd)
    ** Since the biSizeImage could be zero, we may have to calculate
    ** the size ourselves.
    */
    dwSize = lpbi->biSizeImage;
    if (dwSize == 0)
	dwSize = WIDTHBYTES((WORD)(lpbi->biWidth) * lpbi->biBitCount) *
	    lpbi->biHeight;


    /* The size of the DIB is the size of the BITMAPINFOHEADER
    ** structure (lpbi->biSize) plus the size of our palette plus
    ** the size of the actual data (calculated above).
    */
    dwSize += lpbi->biSize + (DWORD)PaletteSize(lpbi);

    /* BUG 2123: (w-markd)
    ** Check to see if the size is greater than the size
    ** of the global object.  If it is, the hDIB is corrupt.
    */
    GlobalUnlock(hDIB);
    if (dwSize > GlobalSize(hDIB))
	return 0;
    else
	return(dwSize);
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDIBFromBitmap(HBITMAP hBmp, DWORD biStyle, WORD biBits,
 *                               HPALETTE hPal)
 *
 *  PURPOSE    :Converts the device-dependent BITMAP indicated by hBmp into
 *              a DIB.  biStyle indicates whether the palette contains
 *              DIB_RGB_COLORS or DIB_PAL_COLORS.  biBits indicates the
 *              desired number of bits in the destination DIB.  If biBits
 *              is zero, the destination DIB will be created with the
 *              minimum required bits.  hPal is a handle to the palette to be
 *              stored with the DIB data.  If hPal is NULL, the default
 *              system palette is used.
 *
 *  RETURNS    :A global handle to a memory block containing the DIB
 *              information in CF_DIB format.  NULL is returned if errors
 *              are encountered.
 *
 *  HISTORY:
 *
 *  92/08/12 -  BUG 1642: (angeld)
 *              Check the return value from GetObject, it will tell us
 *              if the handle hBmp was valid. bail out right away if it isn't
 *  92/08/29 -  BUG 2123: (w-markd)
 *              Use temporary variable to store old palette, then
 *              reselect the old palette when we are done.
 *
 ****************************************************************************/

HANDLE WINAPI bmfDIBFromBitmap (HBITMAP hBmp, DWORD biStyle, WORD biBits,
				    HPALETTE hPal)
{
    BITMAP                  bm;
    BITMAPINFOHEADER        bi;
    BITMAPINFOHEADER FAR    *lpbi;
    DWORD                   dwLen;
    HANDLE                  hDib;
    HANDLE                  hMem;
    HDC                     hdc;
    HPALETTE                hOldPal;

    if (!hBmp || !(GetObject(hBmp,sizeof(bm),(LPSTR)&bm)))
	 {
#if DEBUG
	  OutputDebugString(TEXT("bmfDIBFromBitmap:   INVALID HBITMAP!!!\n\r"));
#endif          
	return NULL;    //bail out if handle is invalid
	 }

    /* get default system palette if hPal is invalid */
    if (hPal == NULL)
	hPal = GetStockObject(DEFAULT_PALETTE);

    if (biBits == 0)
	biBits =  bm.bmPlanes * bm.bmBitsPixel;

    /* set up BITMAPINFOHEADER structure */
    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = GetDC(NULL);
    /* BUG 2123: (w-markd)
    ** Store the previous palette in hOldPal, restore it on exit.
    */
    hOldPal = SelectPalette(hdc,hPal,FALSE);
    RealizePalette(hdc);

    /* get global memory for DIB */
    hDib = GlobalAlloc(GHND,dwLen);

    if (!hDib)
    {
	/* could not allocate memory; clean up and exit */
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }

    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
    {
	/* could not lock memory; clean up and exit */
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	GlobalFree(hDib);
	return NULL;
    }

    *lpbi = bi;

    /*  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hBmp, 0, (WORD)bi.biHeight,
	NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    bi = *lpbi;
    GlobalUnlock(hDib);

    /* If the driver did not fill in the biSizeImage field, make one up */
    if (bi.biSizeImage == 0)
    {
	bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

	if (biStyle != BI_RGB)
	    bi.biSizeImage = (bi.biSizeImage * 3) / 2;
    }

    /*  realloc the buffer big enough to hold all the bits */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    hMem = GlobalReAlloc(hDib,dwLen,GMEM_MOVEABLE);
    if (!hMem)
    {
	/* could not allocate memory; clean up and exit */
	GlobalFree(hDib);
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }
    else
	hDib = hMem;

    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
    {
	/* could not lock memory; clean up and exit */
	GlobalFree(hDib);
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }

    if (GetDIBits( hdc, hBmp, 0, (WORD)bi.biHeight,
	   (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi),
	   (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0)
    {
	/* clean up and exit */
	GlobalUnlock(hDib);
	GlobalFree(hDib);
	SelectPalette(hdc,hOldPal,FALSE);
	ReleaseDC(NULL,hdc);
	return NULL;
    }

    bi = *lpbi;

    /* clean up and exit */
    GlobalUnlock(hDib);
    SelectPalette(hdc,hOldPal,FALSE);
    ReleaseDC(NULL,hdc);
    return hDib;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
 *
 *  PURPOSE    :Converts DIB information into a device-dependent BITMAP
 *              suitable for display on the current display device.  hDib is
 *              a global handle to a memory block containing the DIB
 *              information in CF_DIB format.  hPal is a handle to a palette
 *              to be used for displaying the bitmap.  If hPal is NULL, the
 *              default system palette is used during the conversion.
 *
 *  RETURNS    :Returns a handle to a bitmap is successful, NULL otherwise.
 *
 *  HISTORY:
 *  92/08/29 -  BUG 2123: (w-markd)
 *              Check if DIB is has a valid size, and bail out if not.
 *              If no palette is passed in, try to create one.  If we
 *              create one, we must destroy it before we exit.
 *
 ****************************************************************************/

HBITMAP WINAPI bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hPalT;
    HDC                 hdc;
    HBITMAP             hBmp;
    DWORD               dwSize;
    BOOL                bMadePalette = FALSE;

    if (!hDib)
	return NULL;    //bail out if handle is invalid
    
    /* BUG 2123: (w-markd)
    ** Check to see if we can get the size of the DIB.  If this call
    ** fails, bail out.
    */
    dwSize = bmfDIBSize(hDib);
    if (!dwSize)
	return NULL;

    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
	return NULL;

    /* prepare palette */
    /* BUG 2123: (w-markd)
    ** If the palette is NULL, we create one suitable for displaying
    ** the dib.
    */
    if (!hPal)
    {
	hPal = bmfCreateDIBPalette(hDib);
	if (!hPal)
	{
	    GlobalUnlock(hDib);
	    #ifdef V101
	    #else
	    bMadePalette = TRUE;
	    #endif
	    return NULL;
	}
	#ifdef V101
	/* BUGFIX: mikeroz 2123 - this flag was in the wrong place */
	bMadePalette = TRUE;
	#endif
    }
    hdc = GetDC(NULL);
    hPalT = SelectPalette(hdc,hPal,FALSE);
    RealizePalette(hdc);     // GDI Bug...????

    /* Create the bitmap.  Note that a return value of NULL is ok here */
    hBmp = CreateDIBitmap(hdc, (LPBITMAPINFOHEADER)lpbi, (LONG)CBM_INIT,
			  (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
			  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS );

    /* clean up and exit */
    /* BUG 2123: (w-markd)
    ** If we made the palette, we need to delete it.
    */
    if (bMadePalette)
	DeleteObject(SelectPalette(hdc,hPalT,FALSE));
    else
	SelectPalette(hdc,hPalT,FALSE);
    ReleaseDC(NULL,hdc);
    GlobalUnlock(hDib);
    return hBmp;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfBitmapFromIcon (HICON hIcon, DWORD dwColor)
 *
 *  PURPOSE    :Converts an icon into a bitmap.  hIcon is a handle to a
 *              windows ICON object.  dwColor sets the background color for
 *              the bitmap.
 *
 *  RETURNS    :A handle to the bitmap is successful, NULL otherwise.
 *
 ****************************************************************************/


HBITMAP WINAPI bmfBitmapFromIcon (HICON hIcon, DWORD dwColor)
{
    HDC     hDC;
    HDC     hMemDC = 0;
    HBITMAP hBitmap = 0;
    HBITMAP hOldBitmap;
    HBRUSH  hBrush = 0;
    HBRUSH  hOldBrush;
    int     xIcon, yIcon;

    hDC = GetDC(NULL);
    hMemDC = CreateCompatibleDC( hDC );
    if (hMemDC)
    {
	/* get the size for the destination bitmap */
	xIcon = GetSystemMetrics(SM_CXICON);
	yIcon = GetSystemMetrics(SM_CYICON);
	hBitmap = CreateCompatibleBitmap(hDC, xIcon, yIcon);
	if (hBitmap)
	{
	    hBrush = CreateSolidBrush(dwColor);
	    if (hBrush)
	    {
		hOldBitmap = SelectObject (hMemDC, hBitmap);
		hOldBrush  = SelectObject (hMemDC, hBrush);

		/* draw the icon on the memory device context */
		PatBlt   (hMemDC, 0, 0, xIcon, yIcon, PATCOPY);
		DrawIcon (hMemDC, 0, 0, hIcon);

		/* clean up and exit */
		DeleteObject(SelectObject(hMemDC, hOldBrush));
		SelectObject(hMemDC, hOldBitmap);
		DeleteDC(hMemDC);
		ReleaseDC(NULL, hDC);
		return hBitmap;
	    }
	}
    }

    /* clean up resources and exit */
    if (hBitmap)
	DeleteObject(hBitmap);
    if (hMemDC)
	DeleteDC(hMemDC);
    ReleaseDC (NULL, hDC);
    return NULL;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDrawBitmap(HDC hdc, int xpos, int ypos, HBITMAP hBmp,
 *                            DWORD rop)
 *
 *  PURPOSE    :Draws bitmap hBmp at the specifed position in DC hdc
 *
 *  RETURNS    :Return value of BitBlt() or FALSE if in an error is
 *              encountered.  Note that BitBlt returns true if successful.
 *
 ****************************************************************************/

BOOL WINAPI bmfDrawBitmap (HDC hdc, int xpos, int ypos, HBITMAP hBmp,
			       DWORD rop)
{
    HDC       hdcBits;
    BITMAP    bm;
    BOOL      bResult;

    if (!hdc || !hBmp)
	return FALSE;

    hdcBits = CreateCompatibleDC(hdc);
    if (!hdcBits)
	return FALSE;
    GetObject(hBmp,sizeof(BITMAP),(LPSTR)&bm);
    SelectObject(hdcBits,hBmp);
    bResult = BitBlt(hdc,xpos,ypos,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop);
    DeleteDC(hdcBits);

    return bResult;
}


/***************************************************************************
 *
 *  FUNCTION   :DIBInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi)
 *
 *  PURPOSE    :Retrieves the DIB info associated with a CF_DIB
 *              format memory block.
 *
 *  RETURNS    :TRUE (non-zero) if successful;  FALSE (zero) otherwise.
 *
 ****************************************************************************/

BOOL DIBInfo (HANDLE hbi, LPBITMAPINFOHEADER lpbi)
{
    if (!hbi)
	return FALSE;

    *lpbi = *(LPBITMAPINFOHEADER)GlobalLock (hbi);
    if (!lpbi)
	return FALSE;
    /* fill in the default fields */
    if (lpbi->biSize != sizeof (BITMAPCOREHEADER))
    {
	if (lpbi->biSizeImage == 0L)
	    lpbi->biSizeImage =
	    WIDTHBYTES(lpbi->biWidth*lpbi->biBitCount) * lpbi->biHeight;
	if (lpbi->biClrUsed == 0L)
	    lpbi->biClrUsed = NumDIBColors (lpbi);
    }
    GlobalUnlock (hbi);
    return TRUE;
}

/***************************************************************************
 *
 *  FUNCTION   :CreateBIPalette(LPBITMAPINFOHEADER lpbi)
 *
 *  PURPOSE    :Given a Pointer to a BITMAPINFO struct will create a
 *              a GDI palette object from the color table.
 *
 *  RETURNS    :A handle to the palette if successful, NULL otherwise.
 *
 ****************************************************************************/

HPALETTE CreateBIPalette (LPBITMAPINFOHEADER lpbi)
{
    LPLOGPALETTE        pPal;
    HPALETTE            hPal = NULL;
    WORD                nNumColors;
    BYTE                red;
    BYTE                green;
    BYTE                blue;
    int                 i;
    RGBQUAD             FAR *pRgb;
    HANDLE hMem;

    if (!lpbi)
	return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
	return NULL;

    /* Get a pointer to the color table and the number of colors in it */
    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = NumDIBColors(lpbi);

    if (nNumColors)
    {
	/* Allocate for the logical palette structure */
	hMem = GlobalAlloc(GMEM_MOVEABLE,
	sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));
	if (!hMem)
	    return NULL;
	pPal = (LPLOGPALETTE)GlobalLock(hMem);
	if (!pPal)
	{
	    GlobalFree(hMem);
	    return NULL;
	}

	pPal->palNumEntries = nNumColors;
	pPal->palVersion    = PALVERSION;

	/* Fill in the palette entries from the DIB color table and
	 * create a logical color palette.
	 */
	for (i = 0; (unsigned)i < nNumColors; i++)
	{
	    pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
	    pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
	    pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
	    pPal->palPalEntry[i].peFlags = (BYTE)0;
	}
	hPal = CreatePalette(pPal);
	/* note that a NULL return value for the above CreatePalette call
	 * is acceptable, since this value will be returned, and is not
	 * used again here
	 */
	GlobalUnlock(hMem);
	GlobalFree(hMem);
    }
    else if (lpbi->biBitCount == 24)
    {
	/* A 24 bitcount DIB has no color table entries so, set the number of
	 * to the maximum value (256).
	 */
	nNumColors = MAXPALETTE;
	hMem =GlobalAlloc(GMEM_MOVEABLE,
	sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));
	if (!hMem)
	    return NULL;
	pPal = (LPLOGPALETTE)GlobalLock(hMem);
	if (!pPal)
	{
	    GlobalFree(hMem);
	    return NULL;
	}

	pPal->palNumEntries = nNumColors;
	pPal->palVersion    = PALVERSION;

	red = green = blue = 0;

	/* Generate 256 (= 8*8*4) RGB combinations to fill the palette
	 * entries.
	 */
	for (i = 0; (unsigned)i < pPal->palNumEntries; i++)
	{
	    pPal->palPalEntry[i].peRed   = red;
	    pPal->palPalEntry[i].peGreen = green;
	    pPal->palPalEntry[i].peBlue  = blue;
	    pPal->palPalEntry[i].peFlags = (BYTE)0;

	    if (!(red += 32))
	    if (!(green += 32))
		blue += 64;
	}
	hPal = CreatePalette(pPal);
	/* note that a NULL return value for the above CreatePalette call
	 * is acceptable, since this value will be returned, and is not
	 * used again here
	 */
	GlobalUnlock(hMem);
	GlobalFree(hMem);
    }
    return hPal;
}
/***************************************************************************
 *
 *  FUNCTION   :PaletteSize(VOID FAR * pv)
 *
 *  PURPOSE    :Calculates the palette size in bytes. If the info. block
 *              is of the BITMAPCOREHEADER type, the number of colors is
 *              multiplied by 3 to give the palette size, otherwise the
 *              number of colors is multiplied by 4.
 *
 *  RETURNS    :Palette size in number of bytes.
 *
 ****************************************************************************/

WORD PaletteSize (VOID FAR *pv)
{
    LPBITMAPINFOHEADER  lpbi;
    WORD                NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = NumDIBColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return (NumColors * sizeof(RGBTRIPLE));
    else
	return (NumColors * sizeof(RGBQUAD));
}


/***************************************************************************
 *
 *  FUNCTION   :NumDIBColors(VOID FAR * pv)
 *
 *  PURPOSE    :Determines the number of colors in the DIB by looking at
 *              the BitCount field in the info block.
 *              For use only internal to DLL.
 *
 *  RETURNS    :The number of colors in the DIB.
 *
 ****************************************************************************/

WORD NumDIBColors (VOID FAR * pv)
{
    int                 bits;
    LPBITMAPINFOHEADER  lpbi;
    LPBITMAPCOREHEADER  lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (WORD)lpbi->biClrUsed;
	bits = lpbi->biBitCount;
    }
    else
	bits = lpbc->bcBitCount;

    switch (bits)
    {
    case 1:
	return 2;
    case 4:
	return 16;
    case 8:
	return 256;
    default:
	/* A 24 bitcount DIB has no color table */
	return 0;
    }
}


/***************************************************************************
 *
 *  FUNCTION   :bmfDrawBitmapSize(HDC hdc, int x, int y, int xSize,
 *              int ySize, HBITMAP hBmp, DWORD rop)
 *
 *  PURPOSE    :Draws bitmap <hBmp> at the specifed position in DC <hdc> with
 *              a specified size.
 *
 *  RETURNS    :Return value of BitBlt() or false in an error is
 *              encountered.  Note that BitBlt returns true if successful.
 *
 *  HISTORY:
 *  92/08/13 -  BUG 1642: (w-markd)
 *              Exported this function.
 *              Also stored object that was returned from SelectObject,
 *              and selected this back into the hdc before deleting.
 *
 ****************************************************************************/

BOOL WINAPI bmfDrawBitmapSize (HDC hdc, int xpos, int ypos, int xSize, int ySize, HBITMAP hBmp, DWORD rop)
{
    HDC         hdcBits;
    BOOL        bResult;
    HBITMAP     hOldBmp;

    if (!hdc || !hBmp)
	return FALSE;

    hdcBits = CreateCompatibleDC(hdc);
    if (!hdcBits)
	return FALSE;
    /* BUG 1642: (w-markd)
    ** Remeber old bmp and reselect into hdc before DeleteDC
    */
    hOldBmp = SelectObject(hdcBits,hBmp);
    bResult = BitBlt(hdc,xpos,ypos,xSize, ySize,hdcBits, 0,0,rop);
    SelectObject(hdcBits, hOldBmp);
    DeleteDC(hdcBits);

    return bResult;
}

//----------------------------------------------------------------------------
//  LoadUIBitmap() - load a bitmap resource
//
//      load a bitmap resource from a resource file, converting all
//      the standard UI colors to the current user specifed ones.
//
//      this code is designed to load bitmaps used in "gray ui" or
//      "toolbar" code.
//
//      the bitmap must be a 4bpp windows 3.0 DIB, with the standard
//      VGA 16 colors.
//
//      the bitmap must be authored with the following colors
//
//          Button Text        Black        (index 0)
//          Button Face        lt gray      (index 7)
//          Button Shadow      gray         (index 8)
//          Button Highlight   white        (index 15)
//          Window Color       yellow       (index 11)
//          Window Frame       green        (index 10)
//
//      Example:
//
//          hbm = LoadUIBitmap(hInstance, "TestBmp",
//              GetSysColor(COLOR_BTNTEXT),
//              GetSysColor(COLOR_BTNFACE),
//              GetSysColor(COLOR_BTNSHADOW),
//              GetSysColor(COLOR_BTNHIGHLIGHT),
//              GetSysColor(COLOR_WINDOW),
//              GetSysColor(COLOR_WINDOWFRAME));
//
//      Author:     JimBov, ToddLa
//      History:    5/13/92 - added to dib.c in sndcntrl.dll, t-chrism
//
//----------------------------------------------------------------------------
HBITMAP WINAPI LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCTSTR      szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame)           // color to use for "Window Frame"
{
    LPBYTE              lpb;
    HBITMAP             hbm;
    LPBITMAPINFOHEADER  lpbi = NULL;
    HANDLE              h;
    HDC                 hdc;
    LPDWORD             lprgb;
    HRSRC               hrsrc;

    // convert a RGB into a RGBQ
    #define RGBQ(dw) RGB(GetBValue(dw),GetGValue(dw),GetRValue(dw))

    hrsrc = FindResource(hInstance, szName, RT_BITMAP);
    if (hrsrc)
    {
        h = LoadResource(hInstance,hrsrc);
        if (h)
            lpbi = (LPBITMAPINFOHEADER)LockResource(h);
    }

    if (!lpbi)
	return(NULL);

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
	return NULL;

    if (lpbi->biBitCount != 4)
	return NULL;

    lprgb = (LPDWORD)((LPBYTE)lpbi + (int)lpbi->biSize);
    lpb   = (LPBYTE)(lprgb + 16);

    lprgb[0]  = RGBQ(rgbText);          // Black
    lprgb[7]  = RGBQ(rgbFace);          // lt gray
    lprgb[8]  = RGBQ(rgbShadow);        // gray
    lprgb[15] = RGBQ(rgbHighlight);     // white
    lprgb[11] = RGBQ(rgbWindow);        // yellow
    lprgb[10] = RGBQ(rgbFrame);         // green

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap(hdc, lpbi, CBM_INIT, (LPVOID)lpb,
	(LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);
    UnlockResource(h);
    FreeResource(h);
    return(hbm);
}// LoadUIBitmap
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\dmproppg.c ===
#pragma warning( disable: 4103)
#include "mmcpl.h"
#include <cpl.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <infstr.h>
#include <devguid.h>

#include "draw.h"
#include "utils.h"
#include "drivers.h"
#include "sulib.h"
#include "medhelp.h"
#include <tchar.h>

#define GetString(_psz,_id) LoadString(myInstance,(_id),(_psz),sizeof((_psz))/sizeof(TCHAR))

// Global info struct. One instance for the whole dialog
typedef struct _OUR_PROP_PARAMS
{
    HDEVINFO            DeviceInfoSet;
    PSP_DEVINFO_DATA    DeviceInfoData;
    HKEY                hkDrv;      // Key to classguid\0000
    HKEY                hkDrivers;  // Key to classguid\0000\Drivers
    BOOL                bClosing;   // Set to TRUE while dialog is closing
    TCHAR szSubClasses[256];         // Subclasses to process
} OUR_PROP_PARAMS, *POUR_PROP_PARAMS;

typedef enum
{
    NodeTypeRoot,
    NodeTypeClass,
    NodeTypeDriver
} NODETYPE;

// Tree node. One per node on tree.
typedef struct _DMTREE_NODE;
typedef BOOL (*PFNCONFIG)     (HWND ParentHwnd, struct _DMTREE_NODE *pTreeNode);
typedef BOOL (*PFNQUERYCONFIG)(HWND ParentHwnd, struct _DMTREE_NODE *pTreeNode);
typedef struct _DMTREE_NODE
{
    NODETYPE NodeType;              // Type of node
    PFNCONFIG pfnConfig;            // Ptr to config function
    PFNQUERYCONFIG pfnQueryConfig;  // Ptr to query config function
    int QueryConfigInfo;            // Data for config function
    TCHAR szDescription[MAXSTR];     // Node description
    TCHAR szDriver[MAXSTR];          // Driver name of this node
    WCHAR wszDriver[MAXSTR];        // Wide char driver name
    TCHAR szAlias[MAXSTR];          // Alias
    WCHAR wszAlias[MAXSTR];         // Wide char alias
    DriverClass dc;                 // Legacy-style driver class, if available
    HTREEITEM hti;                  // For use with MIDI prop sheet callback
} DMTREE_NODE, *PDMTREE_NODE;

INT_PTR APIENTRY DmAdvPropPageDlgProc(IN HWND   hDlg,
                                      IN UINT   uMessage,
                                      IN WPARAM wParam,
                                      IN LPARAM lParam
                                     );

UINT CALLBACK DmAdvPropPageDlgCallback(HWND hwnd,
                                       UINT uMsg,
                                       LPPROPSHEETPAGE ppsp
                                      );

BOOL DmAdvPropPage_OnCommand(
                            HWND ParentHwnd,
                            int  ControlId,
                            HWND ControlHwnd,
                            UINT NotifyCode
                            );

BOOL DmAdvPropPage_OnContextMenu(
                                HWND HwndControl,
                                WORD Xpos,
                                WORD Ypos
                                );

BOOL DmAdvPropPage_OnHelp(
                         HWND       ParentHwnd,
                         LPHELPINFO HelpInfo
                         );

BOOL DmAdvPropPage_OnInitDialog(
                               HWND    ParentHwnd,
                               HWND    FocusHwnd,
                               LPARAM  Lparam
                               );

BOOL DmAdvPropPage_OnNotify(
                           HWND    ParentHwnd,
                           LPNMHDR NmHdr
                           );

void DmAdvPropPage_OnPropertiesClicked(
                                      HWND             ParentHwnd,
                                      POUR_PROP_PARAMS Params
                                      );


BOOL DmOverrideResourcesPage(LPVOID        Info,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam,
                             POUR_PROP_PARAMS     Params
                            );

BOOL AddCDROMPropertyPage( HDEVINFO             hDeviceInfoSet,
                           PSP_DEVINFO_DATA     pDeviceInfoData,
                           LPFNADDPROPSHEETPAGE AddFunc,
                           LPARAM               Lparam
                          );

BOOL AddSpecialPropertyPage( DWORD                SpecialDriverType,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam
                            );

BOOL DmInitDeviceTree(HWND hwndTree, POUR_PROP_PARAMS Params);

BOOL DmAdvPropPage_OnDestroy(
                            HWND    ParentHwnd,
                            LPNMHDR NmHdr
                            );

void DoProperties(HWND ParentHwnd, HWND hWndI, HTREEITEM htiCur);

BOOL QueryConfigDriver(HWND ParentHwnd, PDMTREE_NODE pTreeNode)
{
    HANDLE       hDriver;

    if (pTreeNode->NodeType!=NodeTypeDriver)
    {
        return FALSE;
    }

    if (pTreeNode->QueryConfigInfo==0)  // if 0, the we haven't checked yet
    {
        INT_PTR IsConfigurable;

        //  open the driver
        hDriver = OpenDriver(pTreeNode->wszDriver, NULL, 0L);
        if (!hDriver)
        {
            return FALSE;
        }

        // Send the DRV_CONFIGURE message to the driver
        IsConfigurable = SendDriverMessage(hDriver,
                                           DRV_QUERYCONFIGURE,
                                           0L,
                                           0L);

        CloseDriver(hDriver, 0L, 0L);

        // 1->Is configurable, -1->Not configurable
        pTreeNode->QueryConfigInfo = IsConfigurable ? 1 : -1;
    }

    return (pTreeNode->QueryConfigInfo>0);
}

BOOL PNPDriverToIResource(PDMTREE_NODE pTreeNode, IRESOURCE* pir)
{
    IDRIVER tempIDriver;

    if ((pir->pcn = (PCLASSNODE)LocalAlloc (LPTR, sizeof(CLASSNODE))) == NULL)
    {
        return FALSE;
    }

    if (!DriverClassToClassNode(pir->pcn, pTreeNode->dc))
    {
        LocalFree ((HANDLE)pir->pcn);
        return FALSE;
    }

    pir->iNode = 2;   // 1=class, 2=device, 3=acm, 4=instmt

    lstrcpy (pir->szFriendlyName, pTreeNode->szDescription);
    lstrcpy (pir->szDesc,         pTreeNode->szDescription);
    lstrcpy (pir->szFile,         pTreeNode->szDriver);
    lstrcpy (pir->szDrvEntry,     pTreeNode->szAlias);
    lstrcpy (pir->szClass,        pir->pcn->szClass);

    pir->fQueryable = (short)QueryConfigDriver(NULL, pTreeNode);
    pir->iClassID = (short)DriverClassToOldClassID(pTreeNode->dc);
    pir->szParam[0] = 0;
    pir->dnDevNode = 0;
    pir->hDriver = NULL;

    // Find fStatus, which despite its name is really a series of
    // flags--in Win95 it's composed of DEV_* flags (from the old
    // mmcpl.h), but those are tied with PNP.  Here, we use the
    // dwStatus* flags:
    //
    ZeroMemory(&tempIDriver,sizeof(IDRIVER));

    lstrcpy(tempIDriver.wszAlias,pTreeNode->wszAlias);
    lstrcpy(tempIDriver.szAlias,pTreeNode->szAlias);
    lstrcpy(tempIDriver.wszFile,pTreeNode->wszDriver);
    lstrcpy(tempIDriver.szFile,pTreeNode->szDriver);
    lstrcpy(tempIDriver.szDesc,pTreeNode->szDescription);
    lstrcpy(tempIDriver.szSection,wcsstr(pTreeNode->szDescription, TEXT("MCI")) ? szMCI : szDrivers);
    lstrcpy(tempIDriver.wszSection,wcsstr(pTreeNode->szDescription, TEXT("MCI")) ? szMCI : szDrivers);

    pir->fStatus = (int)GetDriverStatus (&tempIDriver);

    return TRUE;
}

BOOL ConfigDriver(HWND ParentHwnd, PDMTREE_NODE pTreeNode)
{
    //need to pop up the legacy properties dialog
    IRESOURCE ir;
    DEVTREENODE dtn;
    TCHAR        szTab[ cchRESOURCE ];

    if ((pTreeNode->NodeType == NodeTypeDriver) && (pTreeNode->dc != dcINVALID))
    {
        if (PNPDriverToIResource(pTreeNode, &ir))
        {
            GetString (szTab, IDS_GENERAL);

            dtn.lParam = (LPARAM)&ir;
            dtn.hwndTree = ParentHwnd;

            //must call this function twice to fill in the array of PIDRIVERs in drivers.c
            //otherwise, many of the "settings" calls won't work
            InitInstalled (GetParent (ParentHwnd), szDrivers);
            InitInstalled (GetParent (ParentHwnd), szMCI);

            switch (pTreeNode->dc)
            {
                case dcMIDI :
                   ShowWithMidiDevPropSheet (szTab,
                                             DevPropDlg,
                                             DLG_DEV_PROP,
                                             ParentHwnd,
                                             pTreeNode->szDescription,
                                             pTreeNode->hti,
                                             (LPARAM)&dtn,
                                             (LPARAM)&ir,
                                             (LPARAM)ParentHwnd);
                break;

                case dcWAVE :
                    ShowPropSheet (szTab,
                              DevPropDlg,
                              DLG_WAVDEV_PROP,
                              ParentHwnd,
                              pTreeNode->szDescription,
                              (LPARAM)&dtn);
                break;

                default:
                   ShowPropSheet (szTab,
                                  DevPropDlg,
                                  DLG_DEV_PROP,
                                  ParentHwnd,
                                  pTreeNode->szDescription,
                                  (LPARAM)&dtn);
                break;
            } //end switch

            FreeIResource (&ir);
        }
    }

    return (FALSE);
}

const static DWORD aDMPropHelpIds[] = {  // Context Help IDs
    IDC_ADV_TREE,    IDH_GENERIC_DEVICES,
    ID_ADV_PROP,     IDH_ADV_PROPERTIES,
    0, 0
};

//******************************************************************************
//* Subtype code
//******************************************************************************
//
// Subtype info. Array of one per device class subtype
typedef struct _SUBTYPE_INFO
{
    TCHAR *szClass;
    DWORD DescId;
    DWORD IconId;
    PFNCONFIG pfnConfig;
    PFNQUERYCONFIG pfnQueryConfig;
    DriverClass dc;
    TCHAR  szDescription[64];
    DWORD IconIndex;
} SUBTYPE_INFO;

static SUBTYPE_INFO SubtypeInfo[] =
{
    { TEXT(""),            IDS_MM_HEADER,       IDI_MMICON,   ConfigDriver, QueryConfigDriver, dcOTHER},
    { TEXT("waveaudio"),   IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("wavemap"),     IDS_WAVE_HEADER,     IDI_WAVE,     ConfigDriver, QueryConfigDriver, dcWAVE},
    { TEXT("wave"),        IDS_WAVE_HEADER,     IDI_WAVE,     ConfigDriver, QueryConfigDriver, dcWAVE},
    { TEXT("vids"),        IDS_ICM_HEADER,      IDI_ICM,      ConfigDriver, QueryConfigDriver, dcVCODEC},
    { TEXT("vidc"),        IDS_ICM_HEADER,      IDI_ICM,      ConfigDriver, QueryConfigDriver, dcVCODEC},
    { TEXT("sequencer"),   IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("msvideo"),     IDS_VIDCAP_HEADER,   IDI_VIDEO,    ConfigDriver, QueryConfigDriver, dcVIDCAP},
    { TEXT("msacm"),       IDS_ACM_HEADER,      IDI_ACM,      ConfigDriver, QueryConfigDriver, dcACODEC},
    { TEXT("mpegvideo"),   IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("mixer"),       IDS_MIXER_HEADER,    IDI_MIXER,    ConfigDriver, QueryConfigDriver, dcMIXER},
    { TEXT("midimapper"),  IDS_MIDI_HEADER,     IDI_MIDI,     ConfigDriver, QueryConfigDriver, dcMIDI},
    { TEXT("midi"),        IDS_MIDI_HEADER,     IDI_MIDI,     ConfigDriver, QueryConfigDriver, dcMIDI},
    { TEXT("mci"),         IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("icm"),         IDS_ICM_HEADER,      IDI_ICM,      ConfigDriver, QueryConfigDriver, dcVCODEC},
    { TEXT("cdaudio"),     IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("avivideo"),    IDS_MCI_HEADER,      IDI_MCI,      ConfigDriver, QueryConfigDriver, dcMCI},
    { TEXT("aux"),         IDS_AUX_HEADER,      IDI_AUX,      ConfigDriver, QueryConfigDriver, dcAUX},
    { TEXT("acm"),         IDS_ACM_HEADER,      IDI_ACM,      ConfigDriver, QueryConfigDriver, dcACODEC},
    { TEXT("joy"),         IDS_JOYSTICK_HEADER, IDI_JOYSTICK, ConfigDriver, QueryConfigDriver, dcJOY}
};

#define SUBTYPE_INFO_SIZE (sizeof(SubtypeInfo)/sizeof(SUBTYPE_INFO))

BOOL LoadSubtypeInfo(HWND hwndTree)
{
    UINT i;
    UINT  uFlags;
    int cxMiniIcon;
    int cyMiniIcon;
    DWORD dwLayout;

    HIMAGELIST hImagelist;

    // Create the image list
    cxMiniIcon = (int)GetSystemMetrics(SM_CXSMICON);
    cyMiniIcon = (int)GetSystemMetrics(SM_CYSMICON);
    uFlags = ILC_MASK | ILC_COLOR32;
   
    if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
    {
        uFlags |= ILC_MIRROR;
    }

    hImagelist = ImageList_Create(cxMiniIcon, cyMiniIcon, uFlags, SUBTYPE_INFO_SIZE, 4);
    if (!hImagelist)
        return FALSE;

    for (i=0;i<SUBTYPE_INFO_SIZE;i++)
    {
        HICON hIcon;

        // Load the description
        LoadString(ghInstance, SubtypeInfo[i].DescId, SubtypeInfo[i].szDescription, 64);

        // Load the image into the image list
        hIcon = LoadImage (ghInstance,
                           MAKEINTRESOURCE( SubtypeInfo[i].IconId ),
                           IMAGE_ICON,
                           cxMiniIcon,
                           cyMiniIcon,
                           LR_DEFAULTCOLOR);

        if (hIcon)  // PREFIX 160723
        {
            SubtypeInfo[i].IconIndex = ImageList_AddIcon(hImagelist, hIcon);
            DestroyIcon(hIcon);
        }
        else
        {
            SubtypeInfo[i].IconIndex = -1;
        }
    }

    // Clean out and initialize tree control
    TreeView_SetImageList(hwndTree, hImagelist, TVSIL_NORMAL);

    return TRUE;
}

SUBTYPE_INFO *GetSubtypeInfo(TCHAR *pszClass)
{
    UINT iClass;
    if (pszClass)
    {
        for (iClass=0;iClass<SUBTYPE_INFO_SIZE;iClass++)
        {
            if (!lstrcmpi(pszClass,SubtypeInfo[iClass].szClass))
                return &SubtypeInfo[iClass];
        }
    }

    return &SubtypeInfo[0];
}

//******************************************************************************

/*

Routine Description: MediaPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96C-E325-11CE-BFC1-08002BE10318}
    EnumPropPage32="mmsys.cpl,thisproc"

    This entry-point gets called only when the DeviceManager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

*/
BOOL APIENTRY MediaPropPageProvider(LPVOID               Info,
                                    LPFNADDPROPSHEETPAGE AddFunc,
                                    LPARAM               Lparam
                                   )
{
    PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
    PROPSHEETPAGE             psp;
    HPROPSHEETPAGE            hpsp;
    POUR_PROP_PARAMS          Params;
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
    DWORD SpecialDriverType;

    HKEY hkDrv;
    HKEY hkDrivers;
    DWORD cbLen;

    pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

    if (pprPropPageRequest->PageRequested != SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
    {
        return TRUE;
    }

    DeviceInfoSet  = pprPropPageRequest->DeviceInfoSet;
    DeviceInfoData = pprPropPageRequest->DeviceInfoData;

    // This API is called for both devices and the class as a whole
    // (when someone right-clicks on the class and chooses properties).
    // In the class case the DeviceInfoData field of the propPageRequest structure is NULL.
    // We don't do anything in that case, so just return.
    if (!DeviceInfoData)
    {
        return TRUE;
    }

    SpecialDriverType = IsSpecialDriver(DeviceInfoSet, DeviceInfoData);
    if (SpecialDriverType)
    {
        SP_DEVINSTALL_PARAMS DeviceInstallParams;

        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
        SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
        DeviceInstallParams.Flags |= DI_RESOURCEPAGE_ADDED | DI_DRIVERPAGE_ADDED; // | DI_GENERALPAGE_ADDED;
        SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
        AddSpecialPropertyPage(SpecialDriverType, AddFunc, Lparam);
        return TRUE;
    }

    if (AddCDROMPropertyPage(DeviceInfoSet,DeviceInfoData, AddFunc, Lparam))
    {
        return TRUE;
    }

    // Open device reg key to see if this is a WDM driver
    hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                 DeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_ALL_ACCESS);
    if (!hkDrv)
        return FALSE;

    // Allocate and zero out memory for the struct that will contain page specific data
    Params = (POUR_PROP_PARAMS)LocalAlloc(LPTR, sizeof(OUR_PROP_PARAMS));
    if (!Params)
    {
        RegCloseKey(hkDrv);
        return FALSE;
    }

    // Initialize Params structure
    Params->DeviceInfoSet  = DeviceInfoSet;
    Params->DeviceInfoData = DeviceInfoData;
    Params->hkDrv          = hkDrv;

    // Override Resource page if this is not a WDM (PNP) driver
    DmOverrideResourcesPage(Info, AddFunc, Lparam, Params);

    // Try a couple of things to see if there are actually any drivers under this key
    // and cache the results

    // Try to open up the Drivers subkey
    if (RegOpenKey(Params->hkDrv, TEXT("Drivers"), &hkDrivers))
    {
        RegCloseKey(hkDrv);
        LocalFree(Params);
        return TRUE;
    }

    // Try to read the SubClasses key to determine which subclasses to process
    cbLen=sizeof(Params->szSubClasses);
    if (RegQueryValueEx(hkDrivers, TEXT("Subclasses"), NULL, NULL, (LPBYTE)Params->szSubClasses, &cbLen))
    {
        RegCloseKey(hkDrv);
        RegCloseKey(hkDrivers);
        LocalFree(Params);
        return TRUE;
    }

    Params->hkDrivers      = hkDrivers;

    // Initialize the property sheet page
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp.hInstance   = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_DM_ADVDLG);
    psp.pfnDlgProc  = DmAdvPropPageDlgProc;     // dlg window proc
    psp.lParam      = (LPARAM) Params;
    psp.pfnCallback = DmAdvPropPageDlgCallback; // control callback of the dlg window proc

    // Create the page & get back a handle
    hpsp = CreatePropertySheetPage(&psp);
    if (!hpsp)
    {
        RegCloseKey(hkDrv);
        LocalFree(Params);
        return FALSE;
    }

    // Add the property page
    if (!(*AddFunc)(hpsp, Lparam))
    {
        DestroyPropertySheetPage(hpsp);
        return FALSE;
    }

    return TRUE;
} /* DmAdvPropPageProvider */

UINT CALLBACK DmAdvPropPageDlgCallback(HWND hwnd,
                                       UINT uMsg,
                                       LPPROPSHEETPAGE ppsp)
{
    POUR_PROP_PARAMS Params;

    switch (uMsg)
    {
    case PSPCB_CREATE:  // This gets called when the page is created
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE: // This gets called when the page is destroyed
        Params = (POUR_PROP_PARAMS) ppsp->lParam;
        RegCloseKey(Params->hkDrv);
        RegCloseKey(Params->hkDrivers);
        LocalFree(Params);  // Free our local params

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

/*++

Routine Description: DmAdvPropPageDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR APIENTRY DmAdvPropPageDlgProc(IN HWND   hDlg,
                                      IN UINT   uMessage,
                                      IN WPARAM wParam,
                                      IN LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_COMMAND:
        return DmAdvPropPage_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));

    case WM_CONTEXTMENU:
        return DmAdvPropPage_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        return DmAdvPropPage_OnHelp(hDlg, (LPHELPINFO) lParam);

    case WM_INITDIALOG:
        return DmAdvPropPage_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return DmAdvPropPage_OnNotify(hDlg,  (NMHDR *)lParam);

    case WM_DESTROY:
        return DmAdvPropPage_OnDestroy(hDlg, (NMHDR *)lParam);
    }

    return FALSE;
} /* DmAdvPropPageDlgProc */

BOOL DmAdvPropPage_OnCommand(
                            HWND ParentHwnd,
                            int  ControlId,
                            HWND ControlHwnd,
                            UINT NotifyCode
                            )
{
    POUR_PROP_PARAMS params =
        (POUR_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (ControlId)
    {
    case ID_ADV_PROP:
        DmAdvPropPage_OnPropertiesClicked(ParentHwnd, params);
        break;
    }

    return FALSE;
}

BOOL DmAdvPropPage_OnContextMenu(
                                HWND HwndControl,
                                WORD Xpos,
                                WORD Ypos
                                )
{
    WinHelp(HwndControl,
            gszWindowsHlp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) aDMPropHelpIds);
    return FALSE;
}

BOOL DmAdvPropPage_OnHelp(
                         HWND       ParentHwnd,
                         LPHELPINFO HelpInfo
                         )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW)
    {
        WinHelp((HWND) HelpInfo->hItemHandle,
                gszWindowsHlp,
                HELP_WM_HELP,
                (ULONG_PTR) aDMPropHelpIds);
    }
    return FALSE;
}

BOOL DmAdvPropPage_OnInitDialog(
                               HWND    ParentHwnd,
                               HWND    FocusHwnd,
                               LPARAM  Lparam
                               )
{
    HWND hwndTree;
    POUR_PROP_PARAMS Params;
    HCURSOR hCursor;
    BOOL bSuccess;

    // on WM_INITDIALOG call, lParam points to the property sheet page.
    //
    // The lParam field in the property sheet page struct is set by the
    // caller. When I created the property sheet, I passed in a pointer
    // to a struct containing information about the device. Save this in
    // the user window long so I can access it on later messages.
    Params = (POUR_PROP_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) Params);

    // Put up the wait cursor
    hCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    //create the device tree.
    hwndTree = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

    // Initialize the tree
    bSuccess = DmInitDeviceTree(hwndTree, Params);

    // Enable the adv properties button
    EnableWindow(GetDlgItem(ParentHwnd, ID_ADV_PROP), TRUE);

    // Tear down the wait cursor
    SetCursor(hCursor);

    return bSuccess;
}

BOOL DmAdvPropPage_OnNotify(
                           HWND    ParentHwnd,
                           LPNMHDR NmHdr
                           )
{
    POUR_PROP_PARAMS Params = (POUR_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (NmHdr->code)
    {
    case PSN_APPLY:    // Sent when the user clicks on Apply OR OK !!
        SetWindowLongPtr(ParentHwnd, DWLP_MSGRESULT, (LONG_PTR)PSNRET_NOERROR);
        return TRUE;

    case TVN_SELCHANGED:
        //Don't bother if we are closing. This helps avoid irritating
        //redraw problems as destroy causes several of these messages to be sent.
        if (!Params->bClosing)
        {
            LPNM_TREEVIEW   lpnmtv;
            TV_ITEM         tvi;
            PDMTREE_NODE    pTreeNode;
            BOOL            fEnablePropButton;
            HWND            hwndProp;

            lpnmtv    = (LPNM_TREEVIEW)NmHdr;
            tvi       = lpnmtv->itemNew;
            pTreeNode = (PDMTREE_NODE)tvi.lParam;
            fEnablePropButton = pTreeNode->pfnQueryConfig(ParentHwnd, pTreeNode);

            //override the enabling for driver entries
            if ((pTreeNode->NodeType == NodeTypeDriver) && (pTreeNode->dc != dcINVALID))
            {
                fEnablePropButton = TRUE;
            }

            // Enable or disable the Properties button depending upon
            // whether this driver can be configured
            hwndProp  = GetDlgItem(ParentHwnd, ID_ADV_PROP);
            EnableWindow(hwndProp, fEnablePropButton);
        }
        break;

    case NM_DBLCLK:
        //show properties on a double-click
        if (NmHdr->idFrom == (DWORD)IDC_ADV_TREE)
        {
            HWND            hwndTree;
            TV_HITTESTINFO  tvht;

            hwndTree = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

            // Find out which tree item the cursor is on and call properties on it
            GetCursorPos(&tvht.pt);
            ScreenToClient(hwndTree, &tvht.pt);
            TreeView_HitTest(hwndTree, &tvht);
            if (tvht.flags & TVHT_ONITEM)
            {
                DoProperties(ParentHwnd, hwndTree, tvht.hItem);
            }
        }
        break;

#if 0 // stolen from Win98, not integrated yet
    case PSN_KILLACTIVE:
        FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
        break;

    case PSN_APPLY:
        FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
        break;

    case PSN_SETACTIVE:
        FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
        break;

    case PSN_RESET:
        FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
        break;

    case TVN_ITEMEXPANDING:
        {
            TV_ITEM tvi;
            HWND hwndTree = GetDlgItem(hDlg,IDC_ADV_TREE);

            tvi = lpnmtv->itemNew;
            tvi.mask = TVIF_PARAM;
            if (!TreeView_GetItem(hwndTree, &tvi))
                break;

            if (!tvi.lParam || IsBadReadPtr((LPVOID)tvi.lParam, 2))
            {
                DPF("****TVN_ITEMEXPANDING: lParam = 0 || BadReadPtr***\r\n");
                break;
            }
            if (*((short *)(tvi.lParam)) == 1)
            {
                //re-enum ACM codecs on expand because their states could have been programmatically changed.
                PCLASSNODE     pcn = (PCLASSNODE)(tvi.lParam);

                if (lpnmtv->action == TVE_EXPAND && !lstrcmpi(pcn->szClass, ACM))
                {
                    if (gfLoadedACM)
                        ACMNodeChange(hDlg);
                }
            }
            else if (!tvi.lParam && lpnmtv->action == TVE_COLLAPSE)
            {
                //dont let the root collapse.
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
                return TRUE;
            }
            break;
        }


    case TVN_BEGINLABELEDIT:
        //we don't want to allow editing of label unless the user explicitly wants it by
        //clicking context menu item
        if (!gfEditLabel)
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
        return TRUE;

    case TVN_ENDLABELEDIT:
        {
            HWND hwndTree;
            LPSTR pszFriendlyName = ((TV_DISPINFO *) lpnm)->item.pszText;
            TV_ITEM item;
            HTREEITEM hti;
            PIRESOURCE pIResource;
            char szWarn[128];
            char ach[MAXSTR];

            //user has chosen a new friendly name. COnfirm with the user and put it in the
            //registry. ALso unhook KB hook which was used to track Esc and Return
            if (gfnKBHook)
            {
                UnhookWindowsHookEx(gfnKBHook);
                gfnKBHook = NULL;
            }
            if (!pszFriendlyName)
                return FALSE;
            hwndTree = GetDlgItem(hDlg, IDC_ADV_TREE);
            hti = TreeView_GetSelection(hwndTree);
            item.hItem =  hti;
            item.mask = TVIF_PARAM;
            TreeView_GetItem(hwndTree, &item);

            LoadString(ghInstance, IDS_FRIENDLYWARNING, szWarn, sizeof(szWarn));
            wsprintf(ach, szWarn, pszFriendlyName);
            LoadString(ghInstance, IDS_FRIENDLYNAME, szWarn, sizeof(szWarn));
            if (mmse_MessageBox(hDlg, ach, szWarn, MMSE_YESNO) == MMSE_NO)
            {
                SetFocus(hwndTree);
                return FALSE;
            }
            if (*((short *)(item.lParam)) == 2)
            {
                pIResource = (PIRESOURCE)item.lParam;
                lstrcpy(pIResource->szFriendlyName, pszFriendlyName);
                SaveDevFriendlyName(pIResource);
            }
            else
            {
                PINSTRUMENT pInstr = (PINSTRUMENT)item.lParam;
                lstrcpy(pInstr->szFriendlyName, pszFriendlyName);
                SaveInstrFriendlyName(pInstr);
            }
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
            return TRUE;
        }
    case NM_RCLICK:
        //popup context menu.
        TreeContextMenu(hDlg,  GetDlgItem(hDlg, IDC_ADV_TREE));
        return TRUE;

#endif
    default:
        return FALSE;
    }

    return FALSE;
}


void DoProperties(HWND ParentHwnd, HWND hWndI, HTREEITEM htiCur)
{
    TV_ITEM      tvi;
    PDMTREE_NODE pTreeNode;
    BOOL         bRestart;

    // Get item struct attached to selected node
    tvi.mask = TVIF_PARAM;
    tvi.hItem = htiCur;
    if (TreeView_GetItem (hWndI, &tvi))
    {
        // Get my private data structure from item struct
        pTreeNode = (PDMTREE_NODE)tvi.lParam;

        if (pTreeNode->NodeType != NodeTypeDriver)
        {
            if (!pTreeNode->pfnQueryConfig(ParentHwnd, pTreeNode))
            {
                return;
            }
        }

        // Call config and get back whether restart needed
        pTreeNode->hti = htiCur; //this allows us to work with the legacy MIDI setup code
        bRestart = pTreeNode->pfnConfig(ParentHwnd, pTreeNode);

        if (bRestart)
        {
            PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
        }
    }

    return;
}

void DmAdvPropPage_OnPropertiesClicked(
                                      HWND             ParentHwnd,
                                      POUR_PROP_PARAMS Params
                                      )
{
    HWND         hWndI;
    HTREEITEM    htiCur;

    // Get handle to treeview control
    hWndI  = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

    // Get handle to currently selected node
    htiCur = TreeView_GetSelection (hWndI);

    if (htiCur != NULL)
    {
        DoProperties(ParentHwnd, hWndI, htiCur);
    }

    return;
}

INT_PTR APIENTRY DmResourcesPageDlgProc(IN HWND   hDlg,
                                        IN UINT   uMessage,
                                        IN WPARAM wParam,
                                        IN LPARAM lParam)
{
    return FALSE;
} /* DmAdvPropPageDlgProc */



INT_PTR CALLBACK CDDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL AddCDROMPropertyPage( HDEVINFO             hDeviceInfoSet,
                           PSP_DEVINFO_DATA     pDeviceInfoData,
                           LPFNADDPROPSHEETPAGE AddFunc,
                           LPARAM               Lparam
                          )
{
    BOOL fHandled = FALSE;

    if (IsEqualGUID(&pDeviceInfoData->ClassGuid,&GUID_DEVCLASS_CDROM))
    {
        PROPSHEETPAGE    psp;
        HPROPSHEETPAGE   hpsp;
        PALLDEVINFO      padi;

        padi = GlobalAllocPtr(GHND, sizeof(ALLDEVINFO));

		if (!padi) return FALSE;

        padi->hDevInfo = hDeviceInfoSet;
        padi->pDevInfoData = pDeviceInfoData;

        // Add our own page for DLG_DM_LEGACY_RESOURCES
        // Initialize the property sheet page
        psp.dwSize      = sizeof(PROPSHEETPAGE);
        psp.dwFlags     = 0;
        psp.hInstance   = ghInstance;
        psp.pszTemplate = MAKEINTRESOURCE(DM_CDDLG);
        psp.pfnDlgProc  = CDDlg;                       // dlg window proc
        psp.lParam      = (LPARAM) padi;
        psp.pfnCallback = 0;                          // control callback of the dlg window proc

        // Create the page & get back a handle
        hpsp = CreatePropertySheetPage(&psp);
        if (!hpsp)
        {
            fHandled = TRUE;
        }
        else if (!(*AddFunc)(hpsp, Lparam))
        {
            GlobalFreePtr(padi);
            DestroyPropertySheetPage(hpsp);
            fHandled = FALSE;
        }
    }

    return(fHandled);
}

INT_PTR CALLBACK AdvDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);



BOOL AddSpecialPropertyPage( DWORD                SpecialDriverType,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam
                            )
{
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;

    // Add our own page for DLG_DM_LEGACY_RESOURCES
    // Initialize the property sheet page
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = 0;
    psp.hInstance   = ghInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DM_ADVDLG);
    psp.pfnDlgProc  = AdvDlg;                       // dlg window proc
    psp.lParam      = (LPARAM)SpecialDriverType;
    psp.pfnCallback = 0;                          // control callback of the dlg window proc

    // Create the page & get back a handle
    hpsp = CreatePropertySheetPage(&psp);
    if (!hpsp)
    {
        return FALSE;
    }

    // Add the property page
    if (!(*AddFunc)(hpsp, Lparam))
    {
        DestroyPropertySheetPage(hpsp);
        return FALSE;
    }

    return TRUE;
}



BOOL DmOverrideResourcesPage(LPVOID        Info,
                             LPFNADDPROPSHEETPAGE AddFunc,
                             LPARAM               Lparam,
                             POUR_PROP_PARAMS     Params
                            )
{
    HKEY             hkDrv;
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE            hpsp;

    TCHAR szDriverType[16];
    DWORD cbLen;

    hkDrv          = Params->hkDrv;
    DeviceInfoSet  = Params->DeviceInfoSet;
    DeviceInfoData = Params->DeviceInfoData;

    // Query value of DriverType field to decide if this is a WDM driver
    cbLen = sizeof(szDriverType);
    if (!RegQueryValueEx(hkDrv, TEXT("DriverType"), NULL, NULL, (LPBYTE)szDriverType, &cbLen))
    {
        if ( lstrcmpi(szDriverType,TEXT("Legacy")) || lstrcmpi(szDriverType,TEXT("PNPISA")) )
        {
            // This is a PNPISA or Legacy device. Override resource page.
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
            DeviceInstallParams.Flags |= DI_RESOURCEPAGE_ADDED;
            SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);

            // Add our own page for DLG_DM_LEGACY_RESOURCES
            // Initialize the property sheet page
            psp.dwSize      = sizeof(PROPSHEETPAGE);
            psp.dwFlags     = 0;
            psp.hInstance   = ghInstance;
            psp.pszTemplate = MAKEINTRESOURCE(DLG_DM_LEGACY_RESOURCES);
            psp.pfnDlgProc  = DmResourcesPageDlgProc;     // dlg window proc
            psp.lParam      = (LPARAM)0;
            psp.pfnCallback = 0;                          // control callback of the dlg window proc

            // Create the page & get back a handle
            hpsp = CreatePropertySheetPage(&psp);
            if (!hpsp)
            {
                return FALSE;
            }

            // Add the property page
            if (!(*AddFunc)(hpsp, Lparam))
            {
                DestroyPropertySheetPage(hpsp);
                return FALSE;
            }

        }
    }

    return TRUE;
}

/*
 ***************************************************************
 * BOOL DmInitDeviceTree
 *
 *      This function calls commctrl to create the image list and tree and
 *      the opens the registry, reads each class and loads all devices under
 *      the class by calling ReadNodes. For ACM however it uses ACM
 *      APIs (this enumeration code is in msacmcpl.c)
 ***************************************************************
 */
BOOL DmInitDeviceTree(HWND hwndTree, POUR_PROP_PARAMS Params)
{
    TV_INSERTSTRUCT ti;

    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;

    TCHAR *strtok_State;         // strtok state
    TCHAR *pszClass;             // Information about e.g. classguid\0000\Drivers\wave
    HKEY hkClass;

    DWORD idxR3DriverName;      // Information about e.g. classguid\0000\Drivers\wave\foo.drv
    HKEY hkR3DriverName;
    TCHAR szR3DriverName[64];

    DWORD cbLen;

    PDMTREE_NODE pTreeNode;

    SUBTYPE_INFO *pSubtypeInfo;

    HTREEITEM htiRoot;
    HTREEITEM htiClass;
    HTREEITEM htiDriver;

    // Load up all the class descriptions and icons
    LoadSubtypeInfo(hwndTree);

    // Clear out the tree
    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0L);

    // Allocate my private data structure for this class
    pTreeNode = (PDMTREE_NODE)LocalAlloc(LPTR, sizeof(DMTREE_NODE));
    if (!pTreeNode)
    {
        return FALSE;
    }

    pSubtypeInfo = GetSubtypeInfo(NULL);

    pTreeNode->NodeType = NodeTypeRoot;
    pTreeNode->pfnConfig = pSubtypeInfo->pfnConfig;
    pTreeNode->pfnQueryConfig = pSubtypeInfo->pfnQueryConfig;

    // Insert root entry
    ti.hParent = TVI_ROOT;
    ti.hInsertAfter = TVI_LAST;
    ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    ti.item.iImage = ti.item.iSelectedImage = pSubtypeInfo->IconIndex;
    ti.item.pszText = pSubtypeInfo->szDescription;
    ti.item.lParam = (LPARAM)pTreeNode;
    htiRoot = NULL; //TreeView_InsertItem(hwndTree, &ti);

    // Enumerate all the subclasses
    for (
        pszClass = mystrtok(Params->szSubClasses,NULL,&strtok_State);
        pszClass;
        pszClass = mystrtok(NULL,NULL,&strtok_State)
        )
    {

        // Get an ID for this class
        pSubtypeInfo = GetSubtypeInfo(pszClass);

        // Open up each subclass
        if (RegOpenKey(Params->hkDrivers, pszClass, &hkClass))
        {
            continue;
        }

        // Allocate my private data structure for this class
        pTreeNode = (PDMTREE_NODE)LocalAlloc(LPTR, sizeof(DMTREE_NODE));
        if (!pTreeNode)
        {
            RegCloseKey(hkClass);
            continue;
        }

        pTreeNode->NodeType = NodeTypeClass;
        pTreeNode->pfnConfig = pSubtypeInfo->pfnConfig;
        pTreeNode->pfnQueryConfig = pSubtypeInfo->pfnQueryConfig;

        // Initialize tree insert struct
        ti.hParent = htiRoot;
        ti.hInsertAfter = TVI_LAST;
        ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        ti.item.iImage = ti.item.iSelectedImage = pSubtypeInfo->IconIndex;
        ti.item.pszText = pSubtypeInfo->szDescription;
        ti.item.lParam = (LPARAM)pTreeNode;

        // Insert Class entry into tree
        htiClass = TreeView_InsertItem(hwndTree, &ti);

        // Under each class is a set of driver name subkeys.
        // For each driver (e.g. foo1.drv, foo2.drv, etc.)
        for (idxR3DriverName = 0;
            !RegEnumKey(hkClass, idxR3DriverName, szR3DriverName, sizeof(szR3DriverName)/sizeof(TCHAR));
            idxR3DriverName++)
        {

            // Open the key to the driver name
            if (RegOpenKey(hkClass, szR3DriverName, &hkR3DriverName))
            {
                continue;
            }

            // Create the branch for this subclass
            pTreeNode = (PDMTREE_NODE)LocalAlloc(LPTR, sizeof(DMTREE_NODE));
            pTreeNode->NodeType = NodeTypeDriver;
            pTreeNode->pfnConfig = pSubtypeInfo->pfnConfig;
            pTreeNode->pfnQueryConfig = pSubtypeInfo->pfnQueryConfig;
            pTreeNode->dc = pSubtypeInfo->dc;

            // Get driver name
            cbLen = sizeof(pTreeNode->szDriver);
            RegQueryValueEx(hkR3DriverName, TEXT("Driver"), NULL, NULL, (LPBYTE)pTreeNode->szDriver, &cbLen);
            wcscpy(pTreeNode->wszDriver, pTreeNode->szDriver);

            // Get driver description
            cbLen = sizeof(pTreeNode->szDescription);
            RegQueryValueEx(hkR3DriverName, TEXT("Description"), NULL, NULL, (LPBYTE)pTreeNode->szDescription, &cbLen);

            // Get driver alias
            cbLen = sizeof(pTreeNode->szAlias);
            RegQueryValueEx(hkR3DriverName, TEXT("Alias"), NULL, NULL, (LPBYTE)pTreeNode->szAlias, &cbLen);
            wcscpy(pTreeNode->wszAlias, pTreeNode->szAlias);

            // Insert Class entry
            ti.hParent = htiClass;
            ti.hInsertAfter = TVI_LAST;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            ti.item.iImage = ti.item.iSelectedImage = pSubtypeInfo->IconIndex;
            ti.item.pszText = pTreeNode->szDescription;
            ti.item.lParam = (LPARAM)pTreeNode;

            htiDriver = TreeView_InsertItem(hwndTree, &ti);

            // Close the Driver Name key
            RegCloseKey(hkR3DriverName);
        }
        // Close the class key
        RegCloseKey(hkClass);
    }

    // Open up the tree and display
    TreeView_Expand(hwndTree, htiRoot, TVE_EXPAND);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0L);

    return TRUE;
}


// Free up the tree
void DmFreeAdvDlgTree (HWND hTree, HTREEITEM hti)
{
    HTREEITEM htiChild;
    TV_ITEM tvi;

    // Delete all children by calling myself recursively
    while ((htiChild = TreeView_GetChild(hTree, hti)) != NULL)
    {
        DmFreeAdvDlgTree(hTree, htiChild);
    }

    if (hti!=TVI_ROOT)
    {
        // Delete my attached data structures
        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        tvi.lParam = 0;
        TreeView_GetItem(hTree, &tvi);
        if (tvi.lParam != 0)
            LocalFree ((HANDLE)tvi.lParam);

        // Delete myself
        TreeView_DeleteItem (hTree, hti);
    }

    return;
}

BOOL DmAdvPropPage_OnDestroy(
                            HWND    ParentHwnd,
                            LPNMHDR NmHdr
                            )
{
    HWND hTree;
    HIMAGELIST hImageList;
    POUR_PROP_PARAMS Params = (POUR_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    if (Params)
    {
        Params->bClosing = TRUE;    // Remember that we're now closing
    }

    // Get handle to treeview control
    hTree = GetDlgItem(ParentHwnd, IDC_ADV_TREE);

    // Free all the entries on the control
    DmFreeAdvDlgTree(hTree,TVI_ROOT);

    // Free up the image list attached to the control
    hImageList = TreeView_GetImageList(hTree, TVSIL_NORMAL);
    if (hImageList)
    {
        TreeView_SetImageList(hTree, NULL, TVSIL_NORMAL);
        ImageList_Destroy (hImageList);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\dslevel.h ===
//--------------------------------------------------------------------------;
//
//  File: dslevel.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;
#pragma once 

#include "advaudio.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

HRESULT DSGetGuidFromName(LPTSTR szName, BOOL fRecord, LPGUID pGuid);
HRESULT DSGetCplValues(GUID guid, BOOL fRecord, LPCPLDATA pData);
HRESULT DSSetCplValues(GUID guid, BOOL fRecord, const LPCPLDATA pData);
HRESULT DSGetAcceleration(GUID guid, BOOL fRecord, LPDWORD pdwHWLevel);
HRESULT DSGetSrcQuality(GUID guid, BOOL fRecord, LPDWORD pdwSRCLevel);
HRESULT DSGetSpeakerConfigType(GUID guid, BOOL fRecord, LPDWORD pdwSpeakerConfig, LPDWORD pdwSpeakerType);
HRESULT DSSetAcceleration(GUID guid, BOOL fRecord, DWORD dwHWLevel);
HRESULT DSSetSrcQuality(GUID guid, BOOL fRecord, DWORD dwSRCLevel);
HRESULT DSSetSpeakerConfigType(GUID guid, BOOL fRecord, DWORD dwSpeakerConfig, DWORD dwSpeakerType);

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\drivers.h ===
/*  DRIVERS.H
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**
**  Multimedia Control Panel Drivers Applet.
**
**  Display a list of all installed drivers, allow user to configure
**  existing or install new ones.
**
*/
#include "dlgs.h"
#include "commdlg.h"
#include <multimed.h>
#include <commctrl.h>
#include "mmcpl.h"
#include <setupapi.h>

#define SECTION         512                   // Maximum size of section
#define MAXSTR          256
#define DLG_BROWSE      38
#define UNLIST_LINE     1
#define NO_UNLIST_LINE  0
#define WEC_RESTART     0x42
#define DESC_SYS        3
#define DESC_INF        2
#define DESC_EXE        1
#define DESC_NOFILE     0

#define dwStatusHASSERVICE   0x00000001  // bit set if driver has service
#define dwStatusSvcENABLED   0x00000002  // bit set if has -enabled- service
#define dwStatusSvcSTARTED   0x00000004  // bit set if has now-running service
#define dwStatusDRIVEROK     0x00000008  // bit set if !svc and can open driver
#define dwStatusMAPPABLE     0x00000010  // bit set if doesn't have Mappable=0

#ifndef cchRESOURCE
#define cchRESOURCE     256
#endif

typedef struct _IDRIVER
{
    WCHAR   wszSection[MAXSTR];
    WCHAR   wszAlias[MAXSTR];
    WCHAR   wszFile[MAX_PATH];
    TCHAR    szSection[MAXSTR];
    TCHAR    szAlias[MAXSTR];
    TCHAR    szFile[MAX_PATH];
    TCHAR    szDesc[MAXSTR];
    struct  _IDRIVER *related;
    BOOL    bRelated;
    TCHAR    szRelated[MAXSTR];
    TCHAR    szRemove[MAXSTR];
    int     fQueryable;     // 0 -> can't, 1 -> can, -1 -> need to check
    BOOL    bInstall;       // 0 -> no,    1 -> yes
    BOOL    KernelDriver;   // If TRUE this is a kernel driver, not an
                            // 'installable' driver so it can't be opened,
                            // process messages etc.
#ifdef INFFILE
    BOOL    infFileProcessing;
#endif // INFFILE

    LPARAM  lp;
} IDRIVER, *PIDRIVER;

typedef enum    // DriverClass (in no particular order)
{
    dcINVALID = -1,
    dcAUX = 0,   // Aux devices
    dcMIDI,  // MIDi devices, MIDI mapper
    dcMIXER, // Mixer devices
    dcWAVE,  // Wave audio devices, Wave mapper
    dcACODEC,    // Audio codecs
    dcVCODEC,    // Video codecs
    dcMCI,   // MCI devices
    dcVIDCAP,    // Video capture devices
    dcJOY,   // Joystick devices
    dcLEGACY,    // Legacy Devices for wave, midi and mixer
    dcOTHER  // Any unknown device
} DriverClass;

typedef struct _DevTreeNode // legacy from win95 devpropsheet code
{
    HWND hwndTree;
    LPARAM lParam;
} DEVTREENODE, * PDEVTREENODE;

extern HANDLE         myInstance;
extern TCHAR           szNULL[];
extern TCHAR           szDrivers[];
extern TCHAR           szBoot[];
extern TCHAR           szDriversHlp[];
extern TCHAR           szAppName[];
extern TCHAR           szUnlisted[];
extern TCHAR           szFullPath[];
extern TCHAR           szOemInf[];
extern TCHAR           szDirOfSrc[];
extern TCHAR           szUserDrivers[];
extern TCHAR           szControlIni[];
extern TCHAR           szDriversDesc[];
extern TCHAR           szSetupInf[];
extern TCHAR           szSysIni[];
extern TCHAR           szMCI[];
extern TCHAR           szRestartDrv[];
extern TCHAR           szRelated[];
extern TCHAR           szNULL[];
extern TCHAR           szBackslash[];
extern TCHAR           szOutOfRemoveSpace[];
extern TCHAR           szKnown[];
extern TCHAR           szRelatedDesc[];
extern TCHAR           szDrv[];
extern TCHAR           szRemove[];
extern TCHAR           szSystem[];
extern TCHAR           szSystemDrivers[];
extern int            iRestartMessage;
extern UINT           wHelpMessage;
extern DWORD          dwContext;
extern BOOL           bCopyVxD;
extern BOOL           bVxd;
extern BOOL           bInstallBootLine;
extern BOOL           bFindOEM;
extern BOOL           bRestart;
extern BOOL           bCopyingRelated;
extern BOOL           bRelated;
extern HWND           hAdvDlgTree;
extern BOOL           IniFileReadAllowed;
extern BOOL           IniFileWriteAllowed;

//------------------------------------------------------------------------
//
// Public routines
//
//------------------------------------------------------------------------
extern void RemoveDriverEntry   (LPTSTR, LPTSTR, LPTSTR, BOOL);
extern int  FileNameCmp         (TCHAR *, TCHAR *);
extern void OpenDriverError     (HWND, LPTSTR, LPTSTR);
extern void RemoveSpaces        (LPTSTR, LPTSTR);
extern INT_PTR RestartDlg          (HWND, unsigned, WPARAM, LPARAM);
extern INT_PTR AddDriversDlg       (HWND, unsigned, WPARAM, LPARAM);
extern INT_PTR AddUnlistedDlg      (HWND, unsigned, WPARAM, LPARAM);
extern BOOL mmAddNewDriver      (LPTSTR, LPTSTR, PIDRIVER);
extern LONG_PTR PostRemove          (PIDRIVER, BOOL);
extern BOOL RemoveService       (LPTSTR);
extern BOOL CopyToSysDir        (void);
extern BOOL InstallDrivers      (HWND, HWND, LPTSTR);
extern void InitDrvConfigInfo   (LPDRVCONFIGINFO, PIDRIVER);
extern BOOL AddIDriverToArray   (PIDRIVER);
extern BOOL FillTreeInAdvDlg    (HWND, PIDRIVER);
extern PIDRIVER FindIDriverByName (LPTSTR);
extern void RemoveIDriver       (HWND, PIDRIVER, BOOL);
extern BOOL IsConfigurable      (PIDRIVER, HWND);
extern void BrowseDlg           (HWND, int);
extern int  LoadDescFromFile    (PIDRIVER, LPTSTR, LPTSTR);
extern BOOL wsInfParseInit      (void);
extern void wsStartWait         (void);
extern void wsEndWait           (void);
extern UINT wsCopySingleStatus  (int, DWORD_PTR, LPTSTR);
extern BOOL QueryRemoveDrivers  (HWND, LPTSTR, LPTSTR);
#ifdef FIX_BUG_15451
extern void ConfigureDriver     (HWND, LPTSTR);
extern BOOL fDeviceHasMixers    (LPTSTR);
extern BOOL WaitForNewCPLWindow (HWND);
extern void GetTreeItemNodeDesc (LPTSTR, PIRESOURCE);
extern void GetTreeItemNodeID   (LPTSTR, PIRESOURCE);
#endif // FIX_BUG_15451
extern void RefreshAdvDlgTree   (void);

extern DWORD InstallDriversForPnPDevice (HWND, HDEVINFO, PSP_DEVINFO_DATA);

// From drivers.c
extern void        lsplitpath     (LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

// From remove.c
LPTSTR mystrtok(LPTSTR SrcString, LPCTSTR Seps, LPTSTR FAR *State);
extern DWORD Media_RemoveDevice(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               );
extern BOOL RemoveDriver (HDEVINFO, PSP_DEVINFO_DATA);
#ifdef _WIN64
extern void mmWOW64ThunkMediaClassInstaller(DWORD dwInstallationFlag, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
#endif //_WIN64

// From install.c
extern BOOL FilterOutNonNTInfs(IN HDEVINFO         DeviceInfoSet,
                               IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
                               IN DWORD DriverType
                              );
extern DWORD Media_SelectBestCompatDrv(IN HDEVINFO         DeviceInfoSet,
                                       IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                                      );
extern DWORD Media_AllowInstall(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               );
extern DWORD Media_InstallDevice(IN HDEVINFO         DeviceInfoSet,
                                 IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                                );

// From legcyinf.c
extern DWORD Media_SelectDevice(IN HDEVINFO         DeviceInfoSet,
                                IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                               );


extern DWORD Media_MigrateLegacy(IN HDEVINFO         DeviceInfoSet,
                                 IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
                                );

#define IS_MS_MMMCI 1
#define IS_MS_MMVID 2
#define IS_MS_MMACM 3
#define IS_MS_MMVCD 4
#define IS_MS_MMDRV 5
extern int IsSpecialDriver(IN HDEVINFO         DeviceInfoSet,
                           IN PSP_DEVINFO_DATA DeviceInfoData
                          );

extern BOOL IsPnPDriver(IN PTSTR szName);

void acmDeleteCodec (WORD, WORD);       // (from MSACMCPL.C)

#ifdef FIX_BUG_15451
extern TCHAR    szDriverWhichNeedsSettings[MAX_PATH]; // See MMCPL.C
#endif // FIX_BUG_15451

void                FreeIResource             (PIRESOURCE);
INT_PTR CALLBACK    DevPropDlg                (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL                DriverClassToClassNode    (PCLASSNODE, DriverClass);
int                 DriverClassToOldClassID   (DriverClass);
DWORD               GetDriverStatus           (PIDRIVER);
BOOL                InitInstalled             (HWND, LPTSTR);

/* Resource IDs */

#define IDOK                1
#define IDCANCEL            2
#define ID_IGNORE           3
#define ID_CURRENT          4
#define ID_RETRY            5
#define ID_NEW              6

#define ID_DISK             101
#define ID_ADV_ADD          102
#define ID_EDIT             105
#define ID_TEXT             106

#define ID_DIR              202
#define ID_FILE_LIST        203
#define ID_DIR_LIST         204
#define ID_TYPE             205

#define LB_AVAILABLE        301
#define ID_DRV              302
#define ID_LIST             303
#define ID_DRVSTRING        304
#define LB_UNLISTED         306
#define ID_ADV_PROP         307
#define ID_ADV_TSHOOT       308

#define ADVDLG              1001
#define DLG_UPDATE          1002
#define DLG_KNOWN           1003
#define DLG_RESTART         1004
#define DLG_EXISTS          1005
#define DLG_INSERTDISK      1006

#define DLG_COPYERR         1007
#define ID_STATUS2          1008
#define DLG_DM_ADVDLG       1009
#define DLG_DM_LEGACY_RESOURCES 1010

#define IDS_NOINF                       2003
#define IDS_DEFDRIVE                    2004
#define IDS_OUTOFDISK                   2005
#define IDS_DISKS                       2006
#define IDS_INSTALLDRIVERS              2007
#define IDS_INSTALLDRIVERS32            2067
#define IDS_DRIVERDESC                  2008
#define IDS_OUT_OF_REMOVE_SPACE         2009
#define IDS_AVAILABLE_DRIVERS_DEFAULT   2010
#define IDS_ERROR                       2011
#define IDS_INSTALLING_DRIVERS          2012
#define IDS_NO_DESCRIPTION              2013
#define IDS_ERRORBOX                    2014
#define IDS_RESTARTTEXT                 2015
#define IDS_CONFIGURE_DRIVER            2016
#define IDS_TOO_MANY_DRIVERS            2017
#define IDS_CANNOT_FIND                 2018
#define IDS_APPNAME                     2019
#define IDS_DRIVERS                     2020
#define IDS_SETUPINF                    2021
#define IDS_CONTROLINI                  2022
#define IDS_SYSINI                      2023
#define IDS_MCI                         2024
#define IDS_CONTROL_INI                 2025
#define IDS_WIN                         2027
#define IDS_DOS                         2028
#define IDS_BROWSE                      2029
#define IDS_UPDATED                     2031
#define IDS_CLOSE                       2032
#define IDS_REMOVEORNOT                 2033
#define IDS_UNLISTED                    2034
#define IDS_KNOWN                       2035
#define IDS_REMOVE                      2036
#define IDS_REMOVEORNOTSTRICT           2037
#define IDS_USERINSTALLDRIVERS          2038
#define IDS_OEMSETUP                    2044
#define IDS_SYSTEM                      2045
#define IDS_FILE_ERROR                  2046
#define IDS_UNABLE_TOINSTALL            2049
#define IDS_BOOT                        2050
#define IDS_RESTART_ADD                 2051
#define IDS_RESTART_REM                 2052
#define IDS_FILEINUSEADD                2053
#define IDS_OEMDISKS                    2054
#define IDS_FILEINUSEREM                2055
#define IDS_LASTQUERY                   2056
#define IDS_RELATEDDESC                 2057
#define IDS_DRIVER_EXISTS               2058
#define IDS_SYSTEM_DRIVERS              2060
#define IDS_INSUFFICIENT_PRIVILEGE      2061
#define IDS_CANNOT_RESTART_PRIVILEGE    2062
#define IDS_CANNOT_RESTART_UNKNOWN      2063
#define IDS_DRIVER_CONFIG_ERROR         2064
#define IDS_CANTADD                     2065
#define IDS_CONTROL_HLP_FILE            2066
#define IDS_TSHOOT                      2068
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\drivers.c ===
/*  DRIVERS.C
**
**  Copyright (C) Microsoft, 1990, All Rights Reserved.
**
**  Multimedia Control Panel Applet for installing/configuring installable
**  device drivers.  See the ispec doc DRIVERS.DOC for more information.
**
**  History:
**
**      Tue Jul 31 1990 -by- MichaelE
**          Created.
**
**      Thu Oct 25 1990 -by- MichaelE
**          Added restart, horz. scroll, added SKIPDESC reading desc. strings.
**
**      Sat Oct 27 1990 -by- MichaelE
**          Added FileCopy.  Uses SULIB.LIB and LZCOPY.LIB. Finished stuff
**          for case of installing a driver with more than one type.
**
**      May 1991 -by- JohnYG
**          Added and replaced too many things to list.  Better management
**          of removed drivers, correct usage of DRV_INSTALL/DRV_REMOVE,
**          installing VxD's, replaced "Unknown" dialog with an OEMSETUP.INF
**          method, proper "Cancel" method, fixed many potential UAE's.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <cpl.h>
#include <cphelp.h>
#include <commctrl.h>
#include <mmcpl.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <regstr.h>

#include "drivers.h"
#include "sulib.h"
#include "utils.h"
#include "medhelp.h"
#include "midi.h"
#ifdef FIX_BUG_15451
#include "trayvol.h"
#endif // FIX_BUG_15451

#ifndef cchLENGTH
#define cchLENGTH(_sz)  (sizeof(_sz) / sizeof((_sz)[0]))
#endif

#ifndef TreeView_GetGrandParent
#define TreeView_GetGrandParent(_htree,_hti) \
        TreeView_GetParent(_htree,TreeView_GetParent(_htree,_hti))
#endif

/*
 * Enable the definition below to cause MCI devices to be listed by their
 * internal descriptions in the tree, rather than their descriptions as
 * read from Drivers.Desc.
 *
 */
// #define GET_MCI_DEVICE_DESCRIPTIONS_FROM_THEIR_DEVICES

typedef struct
{
        int idIcon;
        int idName;
        int idInfo;
        BOOL bEnabled;
        DWORD dwContext;
        LPTSTR pszHelp;
} APPLET_INFO;

#define NUM_APPLETS     1
#define OBJECT_SIZE     1024

BOOL     bBadOemSetup;
BOOL     bRestart = FALSE;
int      iRestartMessage = 0;
BOOL     bInstallBootLine = FALSE;
BOOL     bCopyVxD;
BOOL     bFindOEM = FALSE;
BOOL     bRelated = FALSE;
BOOL     bCopyEvenIfOlder = FALSE;
BOOL     bDriversAppInUse;
BOOL     bCopyingRelated;
BOOL     bDescFileValid;
HANDLE   myInstance;
HWND     hAdvDlgTree;
UINT     wHelpMessage;
DWORD    dwContext;
PINF     pinfOldDefault = NULL;
TCHAR     szDriversHlp[24];
TCHAR     szLastQuery[20];
TCHAR     szSetupInf[18];
TCHAR     szKnown[250];
TCHAR     szRestartDrv[80];
TCHAR     szUnlisted[150];
TCHAR     szRelatedDesc[30];
TCHAR     szAppName[26];
TCHAR     szDrivers[12];
TCHAR     szRemove[12];
TCHAR     szControlIni[20];
TCHAR     szSysIni[20];
TCHAR     szMCI[6];
TCHAR     szOutOfRemoveSpace[54];
TCHAR     szDriversDesc[38];
TCHAR     szUserDrivers[38];

// Where the source of files to copy is - user updates

TCHAR     szDirOfSrc[MAX_PATH];
TCHAR     szAddDriver[36];
TCHAR     szNoDesc[36];
TCHAR     szError[20];
TCHAR     szRemoveOrNot[250];
TCHAR     szRemoveOrNotStrict[250];
TCHAR     szStringBuf[128];
TCHAR     szMDrivers[38];
TCHAR     szMDrivers32[38];
TCHAR     szFullPath[MAXFILESPECLEN];
TCHAR     szSystem[MAX_PATH];
TCHAR     szOemInf[MAX_PATH];
TCHAR     aszClose[16];
TCHAR     szFileError[50];

#ifdef FIX_BUG_15451
TCHAR    szDriverWhichNeedsSettings[MAX_PATH]; // See MMCPL.C
#endif // FIX_BUG_15451

static   HANDLE   hIList;
static   HANDLE   hWndMain;

/*
 *  Global flag telling us if we're allowed to write to ini files
 */

 BOOL IniFileReadAllowed;
 BOOL IniFileWriteAllowed;


/*
 *** Stuff for keeping track of the TreeView window
 *
 */

#define GetString(_psz,_id) LoadString(myInstance,(_id),(_psz),sizeof((_psz))/sizeof(TCHAR))

static struct   // aDriverKeyword
   {
   LPTSTR       psz;    // text found as alias for driver
   DriverClass  dc; // DriverClass inferred from keyword
   }
aDriverKeyword[] =  // (used by GuessDriverClass())
   {
      { TEXT("waveaudio"),   dcMCI      },    // (sort in inverse alphabetical;
      { TEXT("wavemap"),     dcWAVE     },    //  in particular, longer names first)
      { TEXT("wave"),        dcWAVE     },
      { TEXT("vids"),        dcVCODEC   },
      { TEXT("vidc"),        dcVCODEC   },
      { TEXT("sequencer"),   dcMCI      },
      { TEXT("msvideo"),     dcVIDCAP   },
      { TEXT("msacm"),       dcACODEC   },
      { TEXT("mpegvideo"),   dcMCI      },
      { TEXT("mixer"),       dcMIXER    },
      { TEXT("midimapper"),  dcMIDI     },
      { TEXT("midi"),        dcMIDI     },
      { TEXT("mci"),         dcMCI      },
      { TEXT("icm"),         dcVCODEC   },
      { TEXT("cdaudio"),     dcMCI      },
      { TEXT("avivideo"),    dcMCI      },
      { TEXT("aux"),         dcAUX      },
      { TEXT("acm"),         dcACODEC   },
      { TEXT("joy"),         dcJOY      }
   };

#define nDriverKEYWORDS ((int)(sizeof(aDriverKeyword) / \
                               sizeof(aDriverKeyword[0])))

static struct   // aKeywordDesc
   {
   DriverClass  dc; // DriverClass
   LPTSTR       psz;    // alias which best describes class
   }
aKeywordDesc[] =    // (used by DriverClassToClassNode())
   {
      { dcWAVE,    TEXT("wave")     },
      { dcMIXER,   TEXT("mixer")    },
      { dcVIDCAP,  TEXT("msvideo")  },
      { dcVCODEC,  TEXT("icm")      },
      { dcAUX,     TEXT("aux")      },
      { dcACODEC,  TEXT("acm")      },
      { dcMIDI,    TEXT("midi")     },
      { dcJOY,     TEXT("joystick") }
   };

#define nKeywordDESCS   ((int)(sizeof(aKeywordDesc) / \
                               sizeof(aKeywordDesc[0])))

static struct   // aDriverRoot
   {
   DriverClass  dc; // corresponding driver classification
   BOOL         fAlwaysMake;    // TRUE if should exist even w/o child
   int          idIcon; // icon for items under this tree
   int          idDesc; // description string for parent
   int          idEnable;   // string to describe enabling action
   int          idDisable;  // string to describe disabling action
   HTREEITEM    hti;    // item within tree
   DWORD        dwBit;  // bit mask representing this node
   }
aDriverRoot[] = // (order will define order in display)
   {
      { dcINVALID, TRUE,  IDI_MMICON, IDS_MM_HEADER,
                                      0,
                                      0 },
      { dcWAVE,    TRUE,  IDI_WAVE,   IDS_WAVE_HEADER,
                                      IDS_ENABLEAUDIO,
                                      IDS_DISABLEAUDIO },
      { dcMIDI,    TRUE,  IDI_MIDI,   IDS_MIDI_HEADER,
                                      IDS_ENABLEMIDI,
                                      IDS_DISABLEMIDI },
      { dcMIXER,   TRUE,  IDI_MIXER,  IDS_MIXER_HEADER,
                                      IDS_ENABLEMIXER,
                                      IDS_DISABLEMIXER },
      { dcAUX,     TRUE,  IDI_AUX,    IDS_AUX_HEADER,
                                      IDS_ENABLEAUX,
                                      IDS_DISABLEAUX },
      { dcMCI,     TRUE,  IDI_MCI,    IDS_MCI_HEADER,
                                      IDS_ENABLEMCI,
                                      IDS_DISABLEMCI },
      { dcVCODEC,  TRUE,  IDI_ICM,    IDS_ICM_HEADER,
                                      IDS_ENABLEICM,
                                      IDS_DISABLEICM },
      { dcACODEC,  TRUE,  IDI_ACM,    IDS_ACM_HEADER,
                                      IDS_ENABLEACM,
                                      IDS_DISABLEACM },
      { dcVIDCAP,  TRUE,  IDI_VIDEO,  IDS_VIDCAP_HEADER,
                                      IDS_ENABLECAP,
                                      IDS_DISABLECAP },
      { dcJOY,     TRUE, IDI_JOYSTICK,IDS_JOYSTICK_HEADER,
                                      IDS_ENABLEJOY,
                                      IDS_DISABLEJOY },
      { dcOTHER,   FALSE, IDI_MMICON, IDS_OTHER_HEADER,
                                      IDS_ENABLEJOY,
                                      IDS_DISABLEJOY },
   };

#define nDriverROOTS ((int)(sizeof(aDriverRoot) / sizeof(aDriverRoot[0])))

static LPCTSTR aDriversToSKIP[] =
   {
   TEXT( "MMDRV.DLL" ),
   TEXT( "MIDIMAP.DLL" ),
   TEXT( "MSACM32.DRV" )
   };


static TCHAR cszMMDRVDLL[]    = TEXT("MMDRV.DLL");
static TCHAR cszAliasKERNEL[] = TEXT("KERNEL");
static TCHAR cszRegValueLOADTYPE[] = TEXT("Load Type");

#define nDriversToSKIP ((int)( sizeof(aDriversToSKIP)   \
                             / sizeof(aDriversToSKIP[0]) ))

static HIMAGELIST  hImageList = NULL;   // image list for treeview in advdlg
DriverClass g_dcFilterClass = dcINVALID;

short       DriverClassToRootIndex        (DriverClass);
DriverClass GuessDriverClass              (PIDRIVER);
#ifdef FIX_BUG_15451
DriverClass GuessDriverClassFromAlias     (LPTSTR);
#endif // FIX_BUG_15451
DriverClass GuessDriverClassFromTreeItem  (HTREEITEM hti);
BOOL        EnsureRootIndexExists         (HWND, short);
HTREEITEM   AdvDlgFindTopLevel            (void);
BOOL        InitAdvDlgTree                (HWND);
void        FreeAdvDlgTree                (HWND);
void        TreeContextMenu               (HWND, HWND);

int         lstrnicmp      (LPTSTR, LPTSTR, size_t);
LPTSTR      lstrchr        (LPTSTR, TCHAR);
void        lstrncpy       (LPTSTR, LPTSTR, size_t);

void        ShowDeviceProperties          (HWND, HTREEITEM);

PIDRIVER    FindIDriverByTreeItem         (HTREEITEM);

#ifdef FIX_BUG_15451
HTREEITEM   FindTreeItemByDriverName      (LPTSTR);
#endif // FIX_BUG_15451

// We want to run "control joy.cpl" when the joystick devices
// are highlight and the user clicks Add/Remove/Properties buttons.
BOOL RunJoyControlPanel(void);  //qzheng

/*
 ***
 *
 */


DWORD GetFileDateTime     (LPTSTR);
LPTSTR  GetProfile          (LPTSTR,LPTSTR, LPTSTR, LPTSTR, int);
void  AddIDrivers         (HWND, LPTSTR, LPTSTR);
HTREEITEM AddIDriver      (HWND, PIDRIVER, DriverClass);
BOOL  AddIDriverByName    (HWND, LPCWSTR, DriverClass);
PIDRIVER GetSelectedIDriver (HWND);
BOOL  FillTreeFromWinMM   (HWND);
BOOL  FillTreeFromMSACM   (HWND);
BOOL  FillTreeFromMCI     (HWND);
BOOL  FillTreeFromMIDI    (HWND);
BOOL  FillTreeFromRemaining (HWND);
void  FillTreeFromRemainingBySection (HWND, long ii, LPCTSTR, DriverClass);
BOOL CALLBACK FillTreeFromMSACMQueryCallback (HACMDRIVERID, DWORD_PTR, DWORD);
int __cdecl FillTreeFromMSACMSortCallback (const void *p1, const void *p2);
BOOL  InitAvailable       (HWND, int);
void  RemoveAvailable     (HWND);
BOOL  UserInstalled       (LPTSTR);
INT_PTR  RestartDlg          (HWND, unsigned, WPARAM, LPARAM);
INT_PTR  AddUnlistedDlg      (HWND, unsigned, WPARAM, LPARAM);
INT_PTR   AvailableDriversDlg (HWND, unsigned, WPARAM, LPARAM);
INT_PTR  AdvDlg              (HWND, unsigned, WPARAM, LPARAM);
void  ReBoot              (HWND);
BOOL  GetMappable         (PIDRIVER);
BOOL  SetMappable         (PIRESOURCE, BOOL);

#define REGSTR_PATH_WAVEMAPPER  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Wave Mapper")
#define REGSTR_VALUE_MAPPABLE   TEXT("Mappable")

#define REGSTR_PATH_MCI         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\MCI")
#define REGSTR_PATH_MCI32       TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\MCI32")
#define REGSTR_PATH_DRIVERS     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers")
#define REGSTR_PATH_DRIVERS32   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32")


/*
 * REALLOC - Allows expansion of GlobalAlloc()'d block while retaining contents
 *
 *    Newly-allocated portions of memory are initialized to zero, while
 *    the contents of reallocated portions of memory are retained.
 *
 * Parameters:
 *    LPVOID   _pData....allocated array
 *    mysize_t _cOld.....current count of elements in allocated array
 *    mysize_t _cNew.....minimum number of elements requested
 *    mysize_t _cDelta...granularity of increase
 *
 * Example:
 *    {
 *    mysize_t   cElements = 0; // Number of elements allocated so far
 *    DataType  *aElements = NULL;  // Allocated array of DataType
 *
 *    // At this point, cElements == 0 (obviously)
 *
 *    REALLOC (aElements, cElements, 10, 16)
 *
 *    // The line above requested 10 elements, and indicated that elements
 *    // should be allocated in increments of 16.  So cElements is 16 at this
 *    // point (thus, sizeof(aElements) == sizeof(DataType)*16).
 *
 *    REALLOC (aElements, cElements, 12, 16)
 *
 *    // The line above requested 12 elements.  Since cElements is already 16,
 *    // REALLOC knows that 12 elements are already available--and does nothing.
 *
 *    REALLOC (aElements, cElements, 17, 16)
 *
 *    // The line above requested 17 elements, in increments of 16.  aElements
 *    // has been reallocated to contain 32 elements, and cElements is
 *    // therefore 32.
 *
 *    GlobalFree ((HGLOBAL)aElements);  // All done!
 *    aElements = NULL;
 *    cElements = 0;
 *    }
 *
 *
 */

typedef signed long mysize_t;

#ifdef REALLOC
#undef REALLOC
#endif
#define REALLOC(_pData,_cOld,_cNew,_cDelta) \
        ReallocFn (sizeof(*_pData), (void **)&_pData, &_cOld, _cNew, _cDelta)

#ifdef DivRoundUp
#undef DivRoundUp
#endif
#define DivRoundUp(_a,_b) ( (LONG)(((_a) + (_b) -1) / (_b)) )

#ifdef RoundUp
#undef RoundUp
#endif
#define RoundUp(_a,_b) ( DivRoundUp(_a,_b) * (LONG)_b )

BOOL ReallocFn (mysize_t cbElement,
                LPVOID *ppOld, mysize_t *pcOld, mysize_t cNew, mysize_t cDelta)
{
   LPVOID     pNew;
   mysize_t   cbOld, cbNew;

            // First check if we actually need to reallocate or not.
            // It's possible that {ppOld} was already allocated with
            // enough space.
            //
   if ( ((*ppOld) != NULL)  && (cNew <= (*pcOld)) )
      return TRUE;

            // Oh well.  Determine how much space we need, and how much
            // is allocated now.
            //
   cNew  = RoundUp (cNew, cDelta);
   cbNew = cbElement * cNew;
   cbOld = (ppOld == NULL) ? 0 : (cbElement * (*pcOld));

            // Allocate the space and copy over the original contents.
            // Zero-fill the remaining space.
            //
   if ((pNew = (LPVOID)GlobalAlloc (GMEM_FIXED, cbNew)) == NULL)
      return FALSE;

   if (cbOld != 0)
      {
      memcpy (pNew, *ppOld, cbOld);
      GlobalFree ((HGLOBAL)(*ppOld));
      }

   memset (&((char*)pNew)[ cbOld ], 0x00, cbNew -cbOld);

            // Finally, update the passed-in pointers and we're done.
            //
   *pcOld = cNew;
   *ppOld = pNew;

   return TRUE;
}


/*
 * PIDRIVER ARRAY
 *
 * The AddIDrivers() routine LocalAlloc()'s a single IDRIVER structure
 * for each installed device driver.  Pointers to these structures are
 * retained in the InstalledDriver array, and indices into this array
 * are stored as the LPARAM values for each tree item.  Each element
 * in the array stores not only a pointer to the driver's IDRIVER structure,
 * but also a DWORD which, as a combination of aDriverRoot[].dwBit values,
 * reflects the tree root items under which the driver has tree items.
 *
 */

typedef struct  // InstalledDriver
   {
   PIDRIVER  pIDriver;     // Pointer to AddIDrivers()'s PIDRIVER structure
   DWORD     dwBits;       // Combination of aDriverRoot[].dwBit flags
   } InstalledDriver;

InstalledDriver  *aInstalledDrivers = NULL;
mysize_t          cInstalledDrivers = 0;

#define NOPIDRIVER  ((LPARAM)-1)



/*
 *  CheckSectionAccess()
 *
 *  See if we can read/write to a given section
 */


 BOOL CheckSectionAccess(TCHAR *szIniFile, TCHAR *SectionName)
 {
     static TCHAR TestKey[] = TEXT("TestKey!!!");
     static TCHAR TestData[] = TEXT("TestData");
     static TCHAR ReturnData[50];

    /*
     *   Check we can write, read back and delete our key
     */

     return WritePrivateProfileString(SectionName,
                                      TestKey,
                                      TestData,
                                      szIniFile) &&

            GetPrivateProfileString(SectionName,
                                    TestKey,
                                    TEXT(""),
                                    ReturnData,
                                    sizeof(ReturnData) / sizeof(TCHAR),
                                    szIniFile) == (DWORD)wcslen(TestData) &&

            WritePrivateProfileString(SectionName,
                                      TestKey,
                                      NULL,
                                      szIniFile);
 }


/*
 *  CheckIniAccess()
 *
 *  Checks access to our 2 .ini file sections - DRIVERS_SECTION and
 *  MCI_SECTION by just writing and reading some junk
 *
 *  Basically if we don't have access to these sections we're not
 *  going to allow Add and Remove.  The individual MCI drivers must
 *  take care not to put their data into non-writeable storage although
 *  this completely messes up the default parameters thing so we're going
 *  to put these into a well-known key in the win.ini file (ie per user).
 *
 */

 BOOL CheckIniAccess(void)
 {
     return CheckSectionAccess(szSysIni, szDrivers) &&
            CheckSectionAccess(szSysIni, szMCI) &&
            CheckSectionAccess(szControlIni, szUserDrivers) &&
            CheckSectionAccess(szControlIni, szDriversDesc) &&
            CheckSectionAccess(szControlIni, szRelatedDesc);
 }

/*
 *  QueryRemoveDrivers()
 *
 *  Ask the user if they're sure.  If the Driver is one required by the
 *  system (ie not listed in [Userinstallable.drivers] in control.ini)
 *  warn the user of that too.
 */

 BOOL QueryRemoveDrivers(HWND hDlg, LPTSTR szKey, LPTSTR szDesc)
 {
     TCHAR bufout[MAXSTR];

     if (UserInstalled(szKey))
          wsprintf(bufout, szRemoveOrNot, (LPTSTR)szDesc);
     else
          wsprintf(bufout, szRemoveOrNotStrict, (LPTSTR)szDesc);

     return (MessageBox(hDlg, bufout, szRemove,
                    MB_ICONEXCLAMATION | MB_TASKMODAL | MB_YESNO) == IDYES );
 }

/*
 *  GetProfile()
 *
 *  Get private profile strings.
 */

 LPTSTR GetProfile(LPTSTR pstrAppName, LPTSTR pstrKeyName, LPTSTR pstrIniFile,
                 LPTSTR pstrRet, int cbSize)
 {
     TCHAR szNULL[2];

     szNULL[0] = TEXT('\0');
     GetPrivateProfileString(pstrAppName, (pstrKeyName==NULL) ? NULL :
         (LPTSTR)pstrKeyName, szNULL, pstrRet, cbSize/sizeof(TCHAR), pstrIniFile);
     return(pstrRet);
 }

/*********************************************************************
 *
 *  AddIDrivers()
 *
 *  Add drivers in the passed key strings list to the InstalledDrivers array
 *
 *********************************************************************/

void AddIDrivers(HWND hWnd, LPTSTR pstrKeys, LPTSTR pstrSection)
{
    PIDRIVER    pIDriver;
    LPTSTR        pstrKey;
    LPTSTR        pstrDesc;

    pstrKey = pstrKeys;
    pstrDesc = (LPTSTR)LocalAlloc(LPTR, MAXSTR);

	if (!pstrDesc) return;

   /*
    *  parse key strings for profile, and make IDRIVER structs
    */

    while ( *pstrKey )
    {
        pIDriver = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER));
        if ( pIDriver )
        {
            LPTSTR        pstr;

            if (*GetProfile(pstrSection, pstrKey, szSysIni, pIDriver->szFile,
                sizeof(pIDriver->szFile)) == TEXT('\0'))
            {
                LocalFree((HANDLE)pIDriver);
                goto nextkey;
            }

            for ( pstr=pIDriver->szFile; *pstr && (*pstr!=COMMA) &&
                (*pstr!=SPACE); pstr++ )
                    ;
            *pstr = TEXT('\0');

#ifdef TRASHDRIVERDESC
            if (bDescFileValid)
#endif
              /*
               *  try to load the cached description
               */

               GetProfile(szDriversDesc,
                          pIDriver->szFile,
                          szControlIni,
                          pIDriver->szDesc,
                          sizeof(pIDriver->szDesc));

           /*
            *  if we failed, then try to get the information from
            *  mmdriver.inf or the exehdr
            */

            if (pIDriver->szDesc[0] == TEXT('\0'))
            {
               if (LoadDescFromFile(pIDriver, pstrKey, pstrDesc) != DESC_NOFILE)
               {
                   if (!*pstrDesc)
                   {
                       /*
                        *  failed to load a description.
                        *  The file isn't in setup.inf
                        *  and doesn't have exehdr information
                        */

                        lstrcpy(pIDriver->szDesc, pIDriver->szFile);
                        lstrcat(pIDriver->szDesc, szNoDesc);
                   }
                   else
                        lstrcpy(pIDriver->szDesc, pstrDesc);

                   WritePrivateProfileString(szDriversDesc, pIDriver->szFile,
                               pIDriver->szDesc, szControlIni);
               } else {
                    LocalFree((HANDLE)pIDriver);
                    goto nextkey;
               }
            }

            wcsncpy(pIDriver->szAlias, pstrKey, sizeof(pIDriver->szAlias)/sizeof(TCHAR));
            pIDriver->szAlias[sizeof(pIDriver->szAlias)/sizeof(TCHAR) - 1] = TEXT('\0');
            wcscpy(pIDriver->wszAlias, pIDriver->szAlias);

            wcsncpy(pIDriver->szSection, pstrSection,sizeof(pIDriver->szSection)/sizeof(TCHAR));
            pIDriver->szSection[sizeof(pIDriver->szSection)/sizeof(TCHAR) - 1] = TEXT('\0');
            wcscpy(pIDriver->wszSection, pIDriver->szSection);

            pIDriver->KernelDriver = IsFileKernelDriver(pIDriver->szFile);
            pIDriver->fQueryable = pIDriver->KernelDriver ? 0 : -1;

            pIDriver->lp = 0L;

            if (!AddIDriverToArray (pIDriver))
               LocalFree((HANDLE)pIDriver);
        }
        else
           break;  //ERROR Low Memory

nextkey: while (*pstrKey++);
    }
    LocalFree((HANDLE)pstrDesc);
}


/*
 * AddIDriverToArray - Adds the given PIDRIVER to the InstalledDrivers array
 *
 */

BOOL AddIDriverToArray (PIDRIVER pIDriver)
{
    mysize_t  ii;

    if (pIDriver == NULL)
    {
        return FALSE;
    }

            // Don't create duplicate entries in this array; one PIDRIVER
            // per driver-file is sufficient.
            //
    for (ii = 0; ii < cInstalledDrivers; ++ii)
    {
        if (aInstalledDrivers[ ii ].pIDriver != NULL)
        {
            if (!lstrcmpi (aInstalledDrivers[ ii ].pIDriver->szFile,
                           pIDriver->szFile))
            {
                return FALSE;
            }
        }
    }

            // To reduce repetitive calls to GlobalAlloc(), we'll allocate
            // space for an additional 50 InstalledDriver entries within
            // the aInstalledDrivers array each time we run out of space.
            //
#define nDriverEntriesToAllocAtONCE   50

    for (ii = 0; ii < cInstalledDrivers; ++ii)
    {
        if (aInstalledDrivers[ ii ].pIDriver == NULL)
            break;
    }

    if (ii >= cInstalledDrivers)
    {
        if (!REALLOC (aInstalledDrivers,   // Array
                      cInstalledDrivers,   // Current size of array
                      1+ii,                // Requested size of array
                      nDriverEntriesToAllocAtONCE))
        {
            return FALSE;
        }
    }

    aInstalledDrivers[ ii ].pIDriver = pIDriver;
    aInstalledDrivers[ ii ].dwBits = 0L;

    return TRUE;
}


/*********************************************************************
 *
 *  FindInstallableDriversSection()
 *
 *********************************************************************/

PINF FindInstallableDriversSection(PINF pinf)
{
    PINF pinfFound;

    pinfFound = infFindSection(pinf, szMDrivers32);

    if (pinfFound == NULL) {
        pinfFound = infFindSection(pinf, szMDrivers);
    }

    return pinfFound;
}

//NOTE: Returns nSize as a count of bytes, not characters (later calls expect this)
int GetINISectionSize(LPCTSTR pstrSection, LPCTSTR pstrFile)
{
    int ncbSize = 0;
    int ncbMaxSize = 0;

    while (ncbSize >= ncbMaxSize)
    {
        TCHAR szNULL[2];
        LPTSTR pStr = NULL;

        szNULL[0] = TEXT('\0');

        ncbMaxSize += SECTION; //allocate another 512 bytes

        pStr = (LPTSTR)LocalAlloc(LPTR, ncbMaxSize);

        if (!pStr)
        {
            //we're trying to allocate too much memory ...
            //drop out and use the last smaller size that worked
            break;
        }

        ncbSize = GetPrivateProfileString(pstrSection, NULL, szNULL, pStr, ncbMaxSize/sizeof(TCHAR), pstrFile);
        ncbSize = (ncbSize+2) * sizeof(TCHAR);  //convert to byte count, adding two chars
                                                //to account for terminating null and API's truncation

        LocalFree(pStr);
    }

    return (ncbSize);
}


/*********************************************************************
 *
 *  InitInstalled()
 *
 *  Add the drivers installed in [DRIVERS] and [MCI] to the Installed
 *  Drivers list box.
 *
 *********************************************************************/

BOOL InitInstalled(HWND hWnd, LPTSTR pstrSection)
{
    BOOL    bSuccess=FALSE;
    LPTSTR    pstr;
    int nSize = SECTION;

#ifdef TRASHDRIVERDESC
    UINT    wTime;
    BOOL    fForce;
    TCHAR    szOut[10];

    wTime = LOWORD(GetFileDateTime(szControlIni)) >> 1;
    if (fForce = (GetPrivateProfileInt((LPTSTR)szUserDrivers,
                   (LPTSTR)szLastQuery,  0, (LPTSTR)szControlIni) != wTime))
    {
        wsprintf(szOut, TEXT("%d"), wTime);
        WritePrivateProfileString((LPTSTR)szUserDrivers, (LPTSTR)szLastQuery,
                                        szOut, (LPTSTR)szControlIni);
        WritePrivateProfileString((LPTSTR)szDriversDesc, NULL, NULL,
                                                (LPTSTR)szControlIni);
        bDescFileValid = FALSE;
    }
    else
        bDescFileValid = TRUE;
#endif

    nSize = GetINISectionSize(pstrSection, szSysIni);

    pstr = (LPTSTR)LocalAlloc(LPTR, nSize);
    if ( pstr )
    {
        if (*GetProfile(pstrSection, NULL, szSysIni, pstr, nSize ))
        {
            AddIDrivers(hWnd,pstr,pstrSection);
            bSuccess = TRUE;
        }

        LocalFree((HANDLE)pstr);
    }

    return(bSuccess);
}


/*
 * RefreshAdvDlgTree - Clears the Devices tree, and fills it back in
 *
 */

void RefreshAdvDlgTree (void)
{
   if (hAdvDlgTree != NULL)
      {
      SendMessage (hAdvDlgTree, WM_SETREDRAW, FALSE, 0L);

      FreeAdvDlgTree (hAdvDlgTree);
      InitAdvDlgTree (hAdvDlgTree);
      InitInstalled (GetParent (hAdvDlgTree), szDrivers);
      InitInstalled (GetParent (hAdvDlgTree), szMCI);
      FillTreeInAdvDlg (hAdvDlgTree, NULL);

      SendMessage (hAdvDlgTree, WM_SETREDRAW, TRUE, 0L);
      }
}


/*
 * FillTreeInAdvDlg - Adds TreeItems for each entry in aInstalledDrivers
 *
 * If pIDriver is specified, the first treeitem to mention that driver
 * will be highlighted.
 *
 */

BOOL FillTreeInAdvDlg (HWND hTree, PIDRIVER pIDriver)
{
   if (!FillTreeFromWinMM (hTree))
      return FALSE;

   if (!FillTreeFromMSACM (hTree))
      return FALSE;

   if (!FillTreeFromMCI (hTree))
      return FALSE;

   if (!FillTreeFromMIDI (hTree))
      return FALSE;

   if (!FillTreeFromRemaining (hTree))
      return FALSE;

   if (pIDriver != NULL)    // Do we have to highlight a pIDriver?
      {
      short idr;

      for (idr = 0; idr < nDriverROOTS; idr++)
         {
         HTREEITEM  hti;

         if ((hti = aDriverRoot[ idr ].hti) == NULL)
            continue;

         for (hti = TreeView_GetChild (hTree, hti);
              hti != NULL;
              hti = TreeView_GetNextSibling (hTree, hti))
            {
            if (pIDriver == FindIDriverByTreeItem (hti))
               {
               TreeView_SelectItem (hTree, hti);
               break;
               }
            }

         if (hti != NULL)   // Found and selected a TreeItem?
            break;  // Then we're done!
         }
      }

   return TRUE;
}


/*
 * FillTreeFromWinMM - Adds tree items for all WinMM-controlled MM devices
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcWAVE    - waveOut*
 *    dcMIXER   - mixer*
 *    dcAUX     - aux*
 *
 */

BOOL FillTreeFromWinMM (HWND hTree)
{
   UINT     iDevice;
   UINT     cDevices;
   WCHAR    szDriver[ cchRESOURCE ];

            // Add entries for each waveOut device
            //
   cDevices = waveOutGetNumDevs ();
   for (iDevice = 0; iDevice < cDevices; ++iDevice)
      {
      if (waveOutMessage (HWAVEOUT_INDEX(iDevice),
                          DRV_QUERYFILENAME,
                          (DWORD_PTR)szDriver,
                          (DWORD_PTR)cchRESOURCE) == MMSYSERR_NOERROR)
         {
         AddIDriverByName (hTree, szDriver, dcWAVE);
         }
      }

            // Add entries for each mixer device
            //
   cDevices = mixerGetNumDevs ();
   for (iDevice = 0; iDevice < cDevices; ++iDevice)
      {
      if (mixerMessage (HMIXER_INDEX(iDevice),
                        DRV_QUERYFILENAME,
                        (DWORD_PTR)szDriver,
                        (DWORD_PTR)cchRESOURCE) == MMSYSERR_NOERROR)
         {
         AddIDriverByName (hTree, szDriver, dcMIXER);
         }
      }

            // Add entries for each aux device
            //
   cDevices = auxGetNumDevs ();
   for (iDevice = 0; iDevice < cDevices; ++iDevice)
      {
      if (auxOutMessage (iDevice,
                         DRV_QUERYFILENAME,
                         (DWORD_PTR)szDriver,
                         (DWORD_PTR)cchRESOURCE) == MMSYSERR_NOERROR)
         {
         AddIDriverByName (hTree, szDriver, dcAUX);
         }
      }

   return TRUE;
}


/*
 * FillTreeFromMSACM - Adds tree items for all MSACM-controlled MM devices
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcACODEC  - acmDriverEnum()
 *
 * Note that, since audio codecs are supposed to be sorted in the tree,
 * all audio codec treeitems are first deleted from the tree (if there
 * are any at this point) then all audio codecs are added in their
 * sorted order.
 *
 */

typedef struct
   {
   DWORD     dwPriority;    // priority of this audio codec
   PIDRIVER  pIDriver;      // matching driver file (or NULL)
   WORD      wMid;          // manufacturer ID
   WORD      wPid;          // product ID
   TCHAR      szDesc[ ACMDRIVERDETAILS_LONGNAME_CHARS ];
   } AudioCodec;

AudioCodec  *pCodecs;
mysize_t     cCodecs;

extern BOOL gfLoadedACM;   // From MSACMCPL.C

BOOL FillTreeFromMSACM (HWND hTree)
{
   MMRESULT  mmr;
   short     idr;
   mysize_t  ii;

   if (!gfLoadedACM)
      {
      if (LoadACM())
         gfLoadedACM = TRUE;
      }
   if (!gfLoadedACM)
      return FALSE;

            // Step one: get rid of any audio codecs listed in the tree
            //
   if ((idr = DriverClassToRootIndex (dcACODEC)) != -1)
      {
      if (aDriverRoot[ idr ].hti != NULL)
         {
         HTREEITEM hti;

         while ((hti = TreeView_GetChild (hTree, aDriverRoot[ idr ].hti)) != 0)
            {
            TreeView_DeleteItem (hTree, hti);

            if (hti == TreeView_GetChild (hTree, aDriverRoot[ idr ].hti))
               break;  // if it didn't delete, make sure we don't loop forever!
            }
         }

      for (ii = 0; ii < cInstalledDrivers; ++ii)
         {
         aInstalledDrivers[ ii ].dwBits &= ~aDriverRoot[ idr ].dwBit;
         }
      }

            // Step two: query ACM to obtain the list of codecs
            //
   pCodecs = NULL;
   cCodecs = 0;

   mmr = (MMRESULT)acmDriverEnum (FillTreeFromMSACMQueryCallback,
                        0,
                        ACM_DRIVERENUMF_NOLOCAL | ACM_DRIVERENUMF_DISABLED);

               // Step three: sort the list of codecs and add each to the tree
               //
   if ((mmr == MMSYSERR_NOERROR) && (pCodecs != NULL))
      {
      mysize_t  iiDr;

      qsort (pCodecs, (size_t)cCodecs, sizeof(AudioCodec),
             FillTreeFromMSACMSortCallback);

                  // Assign lp=wMid+wPid for each audio codec we find
                  //
      for (iiDr = 0; iiDr < cInstalledDrivers; ++iiDr)
         {
         if (aInstalledDrivers[ iiDr ].pIDriver == NULL)
            continue;
         if (aInstalledDrivers[ iiDr ].pIDriver->lp != 0L)  // already did this
            continue;

         if (GuessDriverClass (aInstalledDrivers[ iiDr ].pIDriver) == dcACODEC)
            {
            HANDLE hDriver;

            hDriver = OpenDriver (aInstalledDrivers[iiDr].pIDriver->wszAlias,
                                  aInstalledDrivers[iiDr].pIDriver->wszSection,
                                  0L);
            if (hDriver != NULL)
               {
               ACMDRIVERDETAILSW add;
               memset ((TCHAR *)&add, 0x00, sizeof(add));
               add.cbStruct = sizeof(add);
               SendDriverMessage (hDriver, ACMDM_DRIVER_DETAILS, (LONG_PTR)&add, 0);
               CloseDriver (hDriver, 0L, 0L);

               aInstalledDrivers[ iiDr ].pIDriver->lp = MAKELONG( add.wMid,
                                                                  add.wPid );
               }
            }
         }

                  // Search for installed drivers with matching lp=wMid+wPid's
                  //
      for (iiDr = 0; iiDr < cInstalledDrivers; ++iiDr)
         {
         if (aInstalledDrivers[ iiDr ].pIDriver == NULL)
            continue;

         if ((aInstalledDrivers[ iiDr ].pIDriver->szAlias[0] == TEXT('\0')) ||
             (GuessDriverClass (aInstalledDrivers[iiDr].pIDriver) == dcACODEC))
            {
            for (ii = 0; ii < cCodecs; ++ii)
               {
               if (pCodecs[ ii ].dwPriority == 0)
                  continue;

               if ( (pCodecs[ ii ].wMid ==
                     LOWORD( aInstalledDrivers[ iiDr ].pIDriver->lp )) &&
                    (pCodecs[ ii ].wPid ==
                     HIWORD( aInstalledDrivers[ iiDr ].pIDriver->lp )) )
                  {
                  pCodecs[ ii ].pIDriver = aInstalledDrivers[ iiDr ].pIDriver;
                  break;
                  }
               }
            }
         }

                  // Add each in-use entry in pCodecs to the treeview
                  //
      for (ii = 0; ii < cCodecs; ++ii)
         {
         if (pCodecs[ ii ].dwPriority == 0)
            continue;

                     // The PCM converter, for instance, won't have a matching
                     // PID.  So create a bogus one--the lack of an szAlias
                     // will let us know it's bogus--and insert it into the
                     // aInstalledDrivers array.
                     //
         if (pCodecs[ ii ].pIDriver == NULL)
            {
            PIDRIVER  pid = (PIDRIVER)LocalAlloc(LPTR, sizeof(IDRIVER));

            if (pid != NULL)
               {
               memset (pid, 0x00, sizeof(IDRIVER));
               pid->lp = MAKELONG( pCodecs[ ii ].wMid, pCodecs[ ii ].wPid );
               lstrcpy (pid->szDesc, pCodecs[ ii ].szDesc);

               if (!AddIDriverToArray (pid))
                  LocalFree ((HLOCAL)pid);
               else
                  {
                  pCodecs[ ii ].pIDriver = pid;
                  }
               }
            }

         if (pCodecs[ ii ].pIDriver != NULL)
            {
            AddIDriver (hTree, pCodecs[ ii ].pIDriver, dcACODEC);
            }
         }
      }

               // Cleanup
               //
   if (pCodecs != NULL)
      {
      GlobalFree ((HGLOBAL)pCodecs);
      pCodecs = NULL;
      cCodecs = 0;
      }

   return (mmr == MMSYSERR_NOERROR) ? TRUE : FALSE;
}


/*
 * FillTreeFromMCI - Adds tree items for all MCI devices
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcMCI     - mciSendCommand
 *
 */

BOOL FillTreeFromMCI (HWND hTree)
{
   MCI_SYSINFO_PARMS mciSysInfo;
   TCHAR szAlias[ cchRESOURCE ];

            // How many MCI devices does WinMM know about?
            //
   memset ((TCHAR *)&mciSysInfo, 0x00, sizeof(mciSysInfo));
   mciSysInfo.lpstrReturn = szAlias;
   mciSysInfo.dwRetSize = cchLENGTH(szAlias);
   mciSysInfo.wDeviceType = MCI_ALL_DEVICE_ID;

   if (mciSendCommand (MCI_ALL_DEVICE_ID,
                       MCI_SYSINFO,
                       MCI_SYSINFO_QUANTITY,
                       (DWORD_PTR)&mciSysInfo) == 0)
      {
      DWORD    iDevice;
      DWORD    cDevices;

      cDevices = *((DWORD *)(mciSysInfo.lpstrReturn));

               // Get the name of each MCI device in turn.
               //
      for (iDevice = 0; iDevice < cDevices; ++iDevice)
         {
         mysize_t ii;

         memset ((TCHAR *)&mciSysInfo, 0x00, sizeof(mciSysInfo));
         mciSysInfo.lpstrReturn = szAlias;
         mciSysInfo.dwRetSize = cchLENGTH(szAlias);
         mciSysInfo.wDeviceType = MCI_ALL_DEVICE_ID;
         mciSysInfo.dwNumber = 1+iDevice;  // note: 1-based, not 0-based!

         if (mciSendCommand (MCI_ALL_DEVICE_ID,
                             MCI_SYSINFO,
                             MCI_SYSINFO_NAME,
                             (DWORD_PTR)&mciSysInfo) != 0)
            {
            continue;
            }

                  // Got an alias--search the InstalledDrivers array
                  // and try to find a matching PIDRIVER.
                  //
         for (ii = 0; ii < cInstalledDrivers; ++ii)
            {
            if (aInstalledDrivers[ ii ].pIDriver == NULL)
               continue;
            if (!lstrcmpi (aInstalledDrivers[ ii ].pIDriver->szAlias, szAlias))
               {
#ifdef GET_MCI_DEVICE_DESCRIPTIONS_FROM_THEIR_DEVICES
               MCI_OPEN_PARMS  mciOpen;
               MCI_INFO_PARMS  mciInfo;
               MCIERROR        rc;

                        // It's an installed, functioning, happy MCI device.
                        // Open it up and see what it calls itself; update the
                        // description in the PIDRIVER (what's in there was
                        // obtained from the registry, thus from MMDRIVER.INF,
                        // and we instead want what Media Player lists in its
                        // Device menu).
                        //
               memset ((TCHAR *)&mciOpen, 0x00, sizeof(mciOpen));
               mciOpen.lpstrDeviceType = szAlias;

               rc = mciSendCommand (0,MCI_OPEN,MCI_OPEN_TYPE,(DWORD)&mciOpen);
               if (rc == MCIERR_MUST_USE_SHAREABLE)
                  {
                  rc = mciSendCommand (0, MCI_OPEN,
                                       MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE,
                                       (DWORD)&mciOpen);
                  }
               if (rc == 0)
                  {
                  TCHAR szDesc[ cchRESOURCE ];
                  szDesc[0] = 0;

                  mciInfo.lpstrReturn = szDesc;
                  mciInfo.dwRetSize = cchLENGTH(szDesc);

                  if (mciSendCommand (mciOpen.wDeviceID,
                                      MCI_INFO,
                                      MCI_INFO_PRODUCT,
                                      (DWORD)&mciInfo) == 0)
                     {
                     lstrcpy (aInstalledDrivers[ ii ].pIDriver->szDesc, szDesc);
                     }

                  mciSendCommand (mciOpen.wDeviceID, MCI_CLOSE, 0L, 0);
                  }
#endif // GET_MCI_DEVICE_DESCRIPTIONS_FROM_THEIR_DEVICES

               AddIDriver (hTree, aInstalledDrivers[ ii ].pIDriver, dcMCI);
               break;
               }
            }
         }
      }

   return TRUE;
}


/*
 * FillTreeFromMIDI - Adds tree items for all MIDI devices and instruments
 *
 * This routine adds tree items under the following DriverClasses:
 *    dcMIDI    - LoadInstruments() provides necessary data
 *
 */

BOOL FillTreeFromMIDI (HWND hTree)
{
   MCMIDI mcm;
   UINT   iiRoot;
   int    idrMIDI;

   if ((idrMIDI = DriverClassToRootIndex (dcMIDI)) == -1)
   return FALSE;

            // First load in all relevant information regarding MIDI
            // instruments.  Fortunately, all that work is encapsulated
            // nicely within one routine.
            //
   memset (&mcm, 0x00, sizeof(mcm));
   LoadInstruments (&mcm, FALSE);

            // Each entry in mcm's api array is one of three things:
            //  - a parent (say, a sound card)
            //  - a child (say, an external instrument)
            //  - the "(none)" thing that we want to skip
            //
            // Add each parent to the tree, and when we find a parent,
            // add all its children.
            //
   for (iiRoot = 0; iiRoot < mcm.nInstr; ++iiRoot)
      {
      TCHAR    szName[ MAXSTR ];
      LPTSTR   pch;
      PIDRIVER pid;

      if (mcm.api[ iiRoot ] == NULL)
         continue;
      if (mcm.api[ iiRoot ]->piParent != NULL)
         continue;
      if (mcm.api[ iiRoot ]->szKey[0] == TEXT('\0'))
         continue;

               // Found a parent!  If we can match it to an installed driver,
               // add it to the tree.  Note that mcm.api[]->szKey will
               // be of the form "MMDRV.DLL<0000>"--we need to strip off
               // the "<0000>" before we can match this thing to a PIDRIVER.
               //
      lstrcpy (szName, mcm.api[ iiRoot ]->szKey);
      if ((pch = lstrchr (szName, TEXT('<'))) != NULL)
         *pch = TEXT('\0');

      if ((pid = FindIDriverByName (szName)) != NULL)
         {
         HTREEITEM hti;
         UINT      ii;
         TV_ITEM   tvi;

         if ((hti = AddIDriver (hTree, pid, dcMIDI)) == NULL)
            continue;

#if 0
         tvi.mask = TVIF_TEXT;
         tvi.hItem = hti;
         tvi.pszText = mcm.api[ iiRoot ]->szFriendly;
         TreeView_SetItem(hTree, &tvi);
#endif

                  // We've added this parent.  See if it has any children,
                  // and if so, stick 'em in the tree.
                  //
         for (ii = 0; ii < mcm.nInstr; ++ii)
            {
            PINSTRUM lp;
            TV_INSERTSTRUCT ti;

            if (mcm.api[ ii ] == NULL)
               continue;
            if (mcm.api[ ii ]->piParent != mcm.api[ iiRoot ])
               continue;

                     // Yep--it's got a parent.  Allocate a second copy
                     // of this PINSTRUM; that copy will be our LPARAM value.
                     //
            if ((lp = (PINSTRUM)LocalAlloc(LPTR,sizeof (INSTRUM))) == NULL)
               continue;
            memcpy ((TCHAR *)lp, (TCHAR *)mcm.api[ ii ], sizeof (INSTRUM));

                     // Now add a treeitem for this instrument.
                     //
            ti.hParent = hti;
            ti.hInsertAfter = TVI_LAST;
            ti.item.mask = TVIF_TEXT | TVIF_PARAM |
                           TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            ti.item.iImage = (int)idrMIDI;
            ti.item.iSelectedImage = (int)idrMIDI;
            ti.item.pszText = mcm.api[ ii ]->szFriendly;
            ti.item.lParam = (LPARAM)lp;

            if (!TreeView_InsertItem (hTree, &ti))
               break;
            }
         }
      }

            // Done--cleanup and we're out of here.
            //
   FreeInstruments (&mcm);

   if (mcm.hkMidi)
      RegCloseKey (mcm.hkMidi);

   return TRUE;
}


            // To reduce repetitive calls to GlobalAlloc(), we'll allocate
            // space for an additional 10 AudioCodec entries within
            // the pCodecs array each time we run out of space.
            //
#define nAudioCodecEntriesToAllocAtONCE   10

BOOL CALLBACK FillTreeFromMSACMQueryCallback (HACMDRIVERID hadid,
                                              DWORD_PTR dwUser,
                                              DWORD fdwSupport)
{
   short       ii;
   AudioCodec *pac;
   ACMDRIVERDETAILS add;

            // Find or create a place in which to store information
            // about this codec
            //
   for (ii = 0; ii < cCodecs; ++ii)
      {
      if (pCodecs[ ii ].dwPriority == 0)
         break;
      }
   if (ii >= cCodecs)
      {
        if (!REALLOC (pCodecs, cCodecs, 1+ii, nAudioCodecEntriesToAllocAtONCE))
            return FALSE;
      }
   pac = &pCodecs[ ii ];    // for shorthand

            // Find out about this codec
            //
   memset ((TCHAR *)&add, 0x00, sizeof(add));
   add.cbStruct = sizeof(add);
   if (acmDriverDetails (hadid, &add, 0) == MMSYSERR_NOERROR)
      {
      acmMetrics ((HACMOBJ)hadid,ACM_METRIC_DRIVER_PRIORITY,&pac->dwPriority);

      lstrcpy (pac->szDesc, add.szLongName);

      pac->wMid = add.wMid;
      pac->wPid = add.wPid;

      pac->pIDriver = NULL;
      }

   return TRUE; // keep counting
}


int __cdecl FillTreeFromMSACMSortCallback (const void *p1, const void *p2)
{
   if (((AudioCodec *)p1)->dwPriority == 0)
      return 1;
   if (((AudioCodec *)p2)->dwPriority == 0)
      return -1;
   return ((AudioCodec *)p1)->dwPriority - ((AudioCodec *)p2)->dwPriority;
}



/*
 * FillTreeFromRemaining - Adds tree items for all remaining MM devices
 *
 * This routine adds a single tree item for each entry in the aInstalledDrivers
 * array which is not already represented somewhere in the tree.  The
 * classification is based on the driver's alias--if that fails, it is lumped
 * under dcOTHER.
 *
 */

BOOL FillTreeFromRemaining (HWND hTree)
{
   mysize_t ii;

   for (ii = 0; ii < cInstalledDrivers; ++ii)
      {
      UINT iiSkipCheck;

      if (aInstalledDrivers[ ii ].pIDriver == NULL)
         continue;
      if (aInstalledDrivers[ ii ].pIDriver->szAlias[0] == TEXT('\0'))
         continue;

            // (don't do this for any not-to-be-displayed drivers)
            //
      for (iiSkipCheck = 0; iiSkipCheck < nDriversToSKIP; iiSkipCheck++)
         {
         if (!FileNameCmp ((LPTSTR)aDriversToSKIP[ iiSkipCheck ],
                           (LPTSTR)aInstalledDrivers[ ii ].pIDriver->szFile))
            break;
         }
      if (iiSkipCheck < nDriversToSKIP)
         continue;

            // Zip through the {drivers,drivers32,mci,mci32} sections, to
            // try to classify this driver. If we find a classification
            // for which we haven't already added an entry in the tree,
            // add another.
            //
      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_DRIVERS,
                                      dcINVALID);

      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_DRIVERS32,
                                      dcINVALID);

      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_MCI,
                                      dcMCI);

      FillTreeFromRemainingBySection (hTree,
                                      ii,
                                      REGSTR_PATH_MCI32,
                                      dcMCI);

            // If the dwBits element is zero, then this driver hasn't
            // already been assigned a treeitem elsewhere.  In that event,
            // call AddIDriver() with dcOTHER--to tell it to lump this
            // driver under "Other Drivers".
            //
      if (aInstalledDrivers[ ii ].dwBits == 0)
         {
         AddIDriver (hTree, aInstalledDrivers[ ii ].pIDriver, dcOTHER);
         }
      }

   return TRUE;
}


void FillTreeFromRemainingBySection (HWND hTree,
                                     long iiDriver,
                                     LPCTSTR pszSection,
                                     DriverClass dcSection)
{
   HKEY hk;
   UINT ii;

   if (RegOpenKey (HKEY_LOCAL_MACHINE, pszSection, &hk))
      return;

   for (ii = 0; ; ++ii)
      {
      TCHAR  szLHS[ cchRESOURCE ];
      TCHAR  szRHS[ cchRESOURCE ];
      DWORD  dw1;
      DWORD  dw2;
      DWORD  dw3;

      dw1 = cchRESOURCE;
      dw3 = cchRESOURCE;
      if (RegEnumValue (hk, ii,  szLHS, &dw1,
                        0, &dw2, (LPBYTE)szRHS, &dw3) != ERROR_SUCCESS)
         {
         break;
         }

      if (!FileNameCmp (szRHS, aInstalledDrivers[ iiDriver ].pIDriver->szFile))
         {
         DriverClass dc;

         if ((dc = dcSection) == dcINVALID)
            dc = GuessDriverClassFromAlias (szLHS);

         if ((dc == dcINVALID) || (dc == dcOTHER))
            continue;

         (void)AddIDriver (hTree, aInstalledDrivers[ iiDriver ].pIDriver, dc);
         }
      }

   RegCloseKey (hk);
}


#ifdef FIX_BUG_15451
HWND MakeThisCPLLookLikeTheOldCPL (HWND hWndCPL)
{
   TCHAR  szTitle[ cchRESOURCE ];
   HWND   hWndOldCPL = NULL;

   GetWindowText (hWndCPL, szTitle, cchRESOURCE);

   for (hWndOldCPL = GetWindow (hWndCPL, GW_HWNDFIRST);
        hWndOldCPL != NULL;
        hWndOldCPL = GetWindow (hWndOldCPL, GW_HWNDNEXT))
      {
      TCHAR  szTitleTest[ cchRESOURCE ];
      GetWindowText (hWndOldCPL, szTitleTest, cchRESOURCE);
      if ( (!lstrcmpi (szTitle, szTitleTest)) && (hWndCPL != hWndOldCPL) )
         {
         RECT  rOld;
         GetWindowRect (hWndOldCPL, &rOld);
         SetWindowPos (hWndCPL, hWndOldCPL, rOld.left, rOld.top,
                       0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
         SetWindowPos (hWndOldCPL, hWndCPL, 0, 0, 0, 0,
                       SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
         }
      }

    return hWndOldCPL;
}


HWND MakeThisDialogLookLikeTheOldDialog (HWND hDlg)
{
   TCHAR  szTitle[ cchRESOURCE ];
   RECT   rOld;
   POINT  pt;
   HWND   hWndOldDlg;

   GetWindowText (hDlg, szTitle, cchRESOURCE);

   for (hWndOldDlg = GetWindow (hDlg, GW_HWNDFIRST);
        hWndOldDlg != NULL;
        hWndOldDlg = GetWindow (hWndOldDlg, GW_HWNDNEXT))
      {
      TCHAR  szTitleTest[ cchRESOURCE ];
      GetWindowText (hWndOldDlg, szTitleTest, cchRESOURCE);
      if ( (!lstrcmpi (szTitle, szTitleTest)) && (hDlg != hWndOldDlg) )
         {
         GetWindowRect (hWndOldDlg, &rOld);

         SetWindowPos (hDlg, NULL, rOld.left, rOld.top, 0, 0,
                       SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

         return hWndOldDlg;
         }
      }

   return NULL;
}



BOOL WaitForNewCPLWindow (HWND hWndMyDlg)
{
   TCHAR  szTitle[ cchRESOURCE ];
   HWND   hWnd;
   DWORD  tickStart;

#define msecMAXWAIT   5000

   hWndMyDlg = GetParent (hWndMyDlg); // (hWndMyDlg was a property sheet)

   GetWindowText (hWndMyDlg, szTitle, cchRESOURCE);

   for (tickStart = GetTickCount();
        GetTickCount() - tickStart < msecMAXWAIT;)
      {
      MSG msg;

      for (hWnd = GetWindow (hWndMyDlg, GW_HWNDFIRST);
           hWnd != NULL;
           hWnd = GetWindow (hWnd, GW_HWNDNEXT))
         {
         TCHAR  szTitleTest[ cchRESOURCE ];
         if (!IsWindowVisible (hWnd))
            continue;
         GetWindowText (hWnd, szTitleTest, cchRESOURCE);
         if ( (!lstrcmpi (szTitle, szTitleTest)) && (hWnd != hWndMyDlg) )
            {
            PropSheet_PressButton (hWndMyDlg, PSBTN_CANCEL);
            hWnd = GetParent (GetParent (hAdvDlgTree));
            PropSheet_PressButton (hWnd, PSBTN_CANCEL);
            return TRUE;
            }
         }

      if (PeekMessage (&msg, NULL, 0, 0, PM_NOREMOVE))
         {
         if (GetMessage (&msg, NULL, 0, 0))
            {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
            }
         }
      }

   return FALSE;
}
#endif // FIX_BUG_15451


        // Prevent any more REMOVE button presses
        // Otherwise one can get stacked up and cause trouble,
        // particularly if it is assocated with a driver that
        // is automatically removed.  We have to use a static
        // as any focus changes cause the button to change state.
        //
static long fWorking = 0;




/********************************************************************
 *
 *  AdvDlg ()
 *
 *  Display list of installed installable drivers.  Return TRUE/FALSE
 *  indicating if should restart windows.
 *
 ********************************************************************/

const static DWORD aAdvDlgHelpIds[] = {  // Context Help IDs
    IDC_ADV_TREE,    IDH_GENERIC_DEVICES,
    ID_ADV_PROP,     IDH_ADV_PROPERTIES,
    ID_ADV_REMOVE,   IDH_MMCPL_DEVPROP_REMOVE,
    0, 0
};

void MapDriverClass(DWORD_PTR dwSetupClass)
{
    g_dcFilterClass = dcINVALID;

    switch (dwSetupClass)
    {
        case IS_MS_MMMCI :
        {
            g_dcFilterClass = dcMCI;
        }
        break;

        case IS_MS_MMVID :
        {
            g_dcFilterClass = dcVCODEC;
        }
        break;

        case IS_MS_MMACM :
        {
            g_dcFilterClass = dcACODEC;
        }
        break;

        case IS_MS_MMVCD :
        {
            g_dcFilterClass = dcVIDCAP;
        }
        break;

        case IS_MS_MMDRV :
        {
            g_dcFilterClass = dcLEGACY;
        }
        break;
    }
}

INT_PTR AdvDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HANDLE          hWndI, hWnd;
    PIDRIVER        pIDriver;
    DWORD_PTR       dwType = 0;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
#ifdef FIX_BUG_15451
        if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
        {
            MakeThisCPLLookLikeTheOldCPL (GetParent(hDlg));
        }
#endif // FIX_BUG_15451

            wsStartWait();

            if (lParam)
            {
                dwType = ((LPPROPSHEETPAGE) lParam)->lParam;
            }

            MapDriverClass(dwType);

            hWndI = GetDlgItem(hDlg, IDC_ADV_TREE);
            SendMessage(hWndI,WM_SETREDRAW, FALSE, 0L);

            InitAdvDlgTree (hWndI); // initialize the treeview display

           /*
            *  Handle the fact that we may not be able to update our .ini
            *  sections
            *
            */

            IniFileWriteAllowed = CheckIniAccess();

                  // Note nasty sneaky hack: using (A|B) instead of (A&&B)
                  // makes both functions evaluate in either success or
                  // failure cases.
                  //
            IniFileReadAllowed = ( InitInstalled (hDlg, szDrivers) |
                                   InitInstalled (hDlg, szMCI) );

            FillTreeInAdvDlg (GetDlgItem (hDlg, IDC_ADV_TREE), NULL);

            wsEndWait();

            if ((!IniFileReadAllowed) || (!IniFileWriteAllowed))
            {
                TCHAR szCantAdd[120];
                EnableWindow(GetDlgItem(hDlg, ID_ADV_ADD),FALSE);
                EnableWindow(GetDlgItem(hDlg, ID_ADV_REMOVE),FALSE);
                LoadString(myInstance,IDS_CANTADD,szCantAdd,sizeof(szCantAdd)/sizeof(TCHAR));
                MessageBox(hDlg, szCantAdd, szError,
                                MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
            }


            SendMessage (hWndI, WM_SETREDRAW, TRUE, 0L);

            break;

        case WM_COMMAND:
            hWndI = GetDlgItem(hDlg, IDC_ADV_TREE);
            hWndMain = hDlg;

            pIDriver = GetSelectedIDriver (hWndI);

            switch ( LOWORD(wParam ))
            {
                case ID_ADV_PROP:
                    {
                HTREEITEM    htiCur = TreeView_GetSelection (hWndI);
                DriverClass  dc = GuessDriverClassFromTreeItem (htiCur);

                        if (fWorking)
                            break;

                        ++fWorking; // Just starting an operation

                        if( dc == dcJOY )
                            // We want to run "control joy.cpl" when the joystick devices
                            // are highlight and the user clicks Properties buttons.
                            RunJoyControlPanel();
            else
                        ShowDeviceProperties (hDlg, TreeView_GetSelection(hWndI));

                    --fWorking; // Finished with this operation
                    }
                    break;

                case ID_WHATSTHIS:
                    {
                    WinHelp((HWND)GetDlgItem (hDlg, IDC_ADV_TREE),
                            gszWindowsHlp, HELP_WM_HELP,
                           (UINT_PTR)(LPTSTR)aAdvDlgHelpIds);
                    }
                    break;

                case ID_ADV_REMOVE:
                    {
                    HWND         hTree = GetDlgItem (hDlg, IDC_ADV_TREE);
                    HTREEITEM    htiCur = TreeView_GetSelection (hTree);
                    DriverClass  dc = GuessDriverClassFromTreeItem (htiCur);
                    PIDRIVER     pid;
                    LONG_PTR         Status;

                    if ((!IniFileReadAllowed) || (!IniFileWriteAllowed))
                       break;   // (button should be disabled)

                    if( dc == dcJOY ) {
                         RunJoyControlPanel();
                break;
            }

                    if (TreeView_GetParent (hAdvDlgTree, htiCur) &&
                        TreeView_GetGrandParent (hAdvDlgTree, htiCur) &&
                        (GuessDriverClassFromTreeItem (
                                 TreeView_GetGrandParent (hAdvDlgTree, htiCur)
                                                      ) == dcMIDI))
                       {
                       TV_ITEM tvi;
                       PINSTRUM pin;

                       tvi.mask = TVIF_PARAM;
                       tvi.hItem = htiCur;
                       tvi.lParam = 0;
                       TreeView_GetItem(hAdvDlgTree, &tvi);

                       if ((pin = (PINSTRUM)tvi.lParam) != NULL)
                          {
                          RemoveInstrumentByKeyName (pin->szKey);
                          RefreshAdvDlgTree ();
                          KickMapper (hDlg);
                          }

                       break;
                       }

                    if ((pid = FindIDriverByTreeItem (htiCur)) == NULL)
                       break;

                    if (dc == dcLEGACY)
                    {
                        dc = GuessDriverClass(pid);
                    }

                    if (pid->szAlias[0] == TEXT('\0'))
                       {
                       TCHAR szCantRemove[ cchRESOURCE ];
                       GetString(szCantRemove, IDS_ACMREMOVEFAIL);
                       MessageBox(hDlg, szCantRemove, szError,
                                  MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
                       break;
                       }

                    if (fWorking)
                       break;
                    ++fWorking; // Just starting an operation

                    if (QueryRemoveDrivers (hDlg, pid->szAlias, pid->szDesc))
                       {
                       if ((Status = PostRemove (pid, TRUE)) != DRVCNF_CANCEL)
                          {
                          switch (dc)
                             {
                             case dcMIDI:
                                   break;
                             case dcACODEC:
                                   acmDeleteCodec (LOWORD(pid->lp),
                                                   HIWORD(pid->lp));
                                   break;
                             default:
                                   break;
                             }

                          iRestartMessage = IDS_RESTART_REM;

                          if (Status == DRVCNF_RESTART)
                             {
                             DialogBox (myInstance,
                                        MAKEINTRESOURCE(DLG_RESTART),
                                        hDlg,
                                        RestartDlg);
                             }
                          }
                       }

                    --fWorking; // Finished with this operation
                    }
                    break;

                case ID_ADV_ADD:
                    {
                HTREEITEM    htiCur = TreeView_GetSelection (hWndI);
                DriverClass  dc = GuessDriverClassFromTreeItem (htiCur);

                        if ((!IniFileReadAllowed) || (!IniFileWriteAllowed))
                            break;  // (button should be disabled)

                        if( dc == dcJOY ) {
                            RunJoyControlPanel();
                break;
            }

                    if (fWorking)
                       break;
                    ++fWorking; // Just starting an operation

                    bCopyEvenIfOlder = FALSE;

                    DialogBox(myInstance, MAKEINTRESOURCE(DLG_KNOWN), hDlg,
                              AvailableDriversDlg);

                    bCopyEvenIfOlder = FALSE;

                    --fWorking; // Finished with this operation
                    }
                    break;


                case ID_ADV_TSHOOT:
                    {
                        TCHAR szCommand[ MAX_PATH ];
                        STARTUPINFO si;
                        PROCESS_INFORMATION pi;
                        LoadString(myInstance,IDS_TSHOOT, szCommand, sizeof(szCommand)/sizeof(TCHAR));
                        ZeroMemory(&si, sizeof(si));
                        si.cb = sizeof(si);
                        si.dwFlags = STARTF_USESHOWWINDOW;
                        si.wShowWindow = SW_NORMAL;
                        if (CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, 0, NULL, &si, &pi)) {
                            CloseHandle(pi.hThread);
                            CloseHandle(pi.hProcess);
                        }
                    }
                    break;

#ifdef FIX_BUG_15451
        case ID_INIT:
            if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
               {
               HTREEITEM hti;

               if ((hti = FindTreeItemByDriverName (
                        szDriverWhichNeedsSettings)) != 0)
               {
               TreeView_Expand (hAdvDlgTree,
                        TreeView_GetParent(hAdvDlgTree,hti),
                        TVE_EXPAND);
               TreeView_SelectItem(hAdvDlgTree,hti);
               FORWARD_WM_COMMAND(hDlg,ID_ADV_PROP,0,0,PostMessage);
               }
               else
               {
               szDriverWhichNeedsSettings[0] = 0;
               }
               }
                    break;
#endif // FIX_BUG_15451

                default:
                    return(FALSE);
            }
            break;

      case WM_NOTIFY:
            {
            NMHDR         *lpnm   = (NMHDR *)lParam;
            LPNM_TREEVIEW  lpnmtv = (LPNM_TREEVIEW)lParam;

            switch (lpnm->code)
               {
               case PSN_KILLACTIVE:
                     FORWARD_WM_COMMAND (hDlg, IDOK, 0, 0, SendMessage);
                    break;

               case PSN_APPLY:
                     FORWARD_WM_COMMAND (hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

               case PSN_SETACTIVE:
                     FORWARD_WM_COMMAND (hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

               case PSN_RESET:
                     FORWARD_WM_COMMAND (hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;

               case NM_DBLCLK:
                              // show properties or expand/collapse tree node.
                              //
                     if (lpnm->idFrom == (UINT)IDC_ADV_TREE)
                        {
                        HWND           hTree =  GetDlgItem (hDlg, IDC_ADV_TREE);
                        HTREEITEM      htiCur = TreeView_GetSelection (hTree);
                        TV_HITTESTINFO tvht;

                        if (!htiCur)
                           break;

                        GetCursorPos (&tvht.pt);
                        ScreenToClient (hTree, &tvht.pt);
                        TreeView_HitTest (hTree, &tvht);

                        if ( (tvht.flags & TVHT_ONITEM) &&
                             (TreeView_GetChild (hTree, htiCur) == NULL) &&
                             (IsWindowEnabled (GetDlgItem(hDlg,ID_ADV_PROP))) )
                           {
                           FORWARD_WM_COMMAND(hDlg,ID_ADV_PROP,0,0,PostMessage);
                           }
                        }
                    break;

               case NM_RCLICK:
                     TreeContextMenu (hDlg, GetDlgItem (hDlg, IDC_ADV_TREE));
                     return TRUE;
                    break;
               }
            }
           break;


        // The TreeView has its own right-click handling, and presents a
        // "What's This?" automatically--so don't handle WM_CONTEXTMENU
        // for that control.
        //
        case WM_CONTEXTMENU:
            if (wParam != (WPARAM)GetDlgItem (hDlg, IDC_ADV_TREE))
            {
                WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                       (UINT_PTR)(LPTSTR)aAdvDlgHelpIds);
            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp,
                  HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAdvDlgHelpIds);
            break;

        case WM_DESTROY:
            FreeAdvDlgTree (GetDlgItem (hDlg, IDC_ADV_TREE));
            return FALSE;
            break;

        default:
            return FALSE;
            break;
    }
    return(TRUE);
}


/*
 *** TreeContextMenu
 *
 * This function displays the context menu that pops up when the
 * user right clicks on any of the tree view items.
 *
 */
void TreeContextMenu (HWND hWnd, HWND hKeyTreeWnd)
{
   DWORD MessagePos;
   POINT MessagePoint;
   TV_HITTESTINFO TVHitTestInfo;
   HMENU hContextMenu;
   HMENU hContextPopupMenu;
   TV_ITEM TVItem;
   int MenuCommand;
   TCHAR szCollapse[32];

            // dont bring up a menu unless click is on the item.
            //
   MessagePos = GetMessagePos();
   MessagePoint.x = GET_X_LPARAM(MessagePos);
   MessagePoint.y = GET_Y_LPARAM(MessagePos);

   TVHitTestInfo.pt = MessagePoint;
   ScreenToClient(hKeyTreeWnd, &TVHitTestInfo.pt);
   TVItem.hItem = TreeView_HitTest(hKeyTreeWnd, &TVHitTestInfo);

   if (TVItem.hItem == NULL)
      return;

   hContextMenu = LoadMenu(ghInstance, MAKEINTRESOURCE(POPUP_TREE_CONTEXT));
   if (hContextMenu == NULL)
      return;

   hContextPopupMenu = GetSubMenu (hContextMenu, 0);

   TVItem.mask = TVIF_STATE | TVIF_HANDLE | TVIF_CHILDREN | TVIF_PARAM;
   TreeView_GetItem(hKeyTreeWnd, &TVItem);

               // show collapse item because we are expanded?
               //
   if (TVItem.state & TVIS_EXPANDED)
      {
      LoadString(ghInstance, IDS_COLLAPSE, szCollapse, sizeof(szCollapse)/sizeof(TCHAR));
      ModifyMenu(hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND | MF_STRING,
                 ID_TOGGLE, szCollapse);
      }
   SetMenuDefaultItem (hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND);

   if (TVItem.cChildren == 0) //gray expand/collaps if no children
      {
      SetMenuDefaultItem(hContextPopupMenu, ID_ADV_PROP, MF_BYCOMMAND);
      EnableMenuItem(hContextPopupMenu, ID_TOGGLE, MF_GRAYED |MF_BYCOMMAND);
      }

   TreeView_SelectItem (hKeyTreeWnd, TVItem.hItem);
   MenuCommand = TrackPopupMenuEx (hContextPopupMenu,
                                   TPM_RETURNCMD | TPM_RIGHTBUTTON |
                                   TPM_LEFTALIGN | TPM_TOPALIGN,
                                   MessagePoint.x, MessagePoint.y,
                                   hWnd, NULL);

   DestroyMenu (hContextMenu);
   FORWARD_WM_COMMAND(hWnd, MenuCommand, 0, 0, SendMessage);
}



/*--------------------------------------------------------------------------*
 *                                                                          *
 *                                                                          *
 *  LB_AVAILABLE Dialog Routines                                            *
 *                                                                          *
 *                                                                          *
 *--------------------------------------------------------------------------*/

/*
 *  DLG: LB_AVAILABLE
 *
 *  InitAvailable()
 *
 *  Add the available drivers from mmdriver.inf to the passed list box.
 *  The format of [Installable.drivers] in setup.inf is:
 *  profile=disk#:driverfile,"type1,type2","Installable driver Description","vxd1.386,vxd2.386","opt1,2,3"
 *
 *  for example:
 *
 *  driver1=6:sndblst.drv,"midi,wave","SoundBlaster MIDI and Waveform drivers","vdmad.386,vadmad.386","3,260"
 */

BOOL InitAvailable(HWND hWnd, int iLine)
{
    PINF    pinf;
    BOOL    bInitd=FALSE;
    LPTSTR    pstrKey;
    int     iIndex;
    TCHAR    szDesc[MAX_INF_LINE_LEN];

    SendMessage(hWnd,WM_SETREDRAW, FALSE, 0L);

   /*
    *  Parse the list of keywords and load their strings
    */

    for (pinf = FindInstallableDriversSection(NULL); pinf; pinf = infNextLine(pinf))
    {
        //
        // found at least one keyname!
        //
        bInitd = TRUE;
        if ( (pstrKey = (LPTSTR)LocalAlloc(LPTR, MAX_SYS_INF_LEN)) != NULL )
                infParseField(pinf, 0, pstrKey);
        else
            break;
       /*
        *  add the installable driver's description to listbox, and filename as data
        */

        infParseField(pinf, 3, szDesc);

        if ( (iIndex = (int)SendMessage(hWnd, LB_ADDSTRING, 0, (LONG_PTR)(LPTSTR)szDesc)) != LB_ERR )

            SendMessage(hWnd, LB_SETITEMDATA, iIndex, (LONG_PTR)pstrKey);

    }

    if (iLine == UNLIST_LINE)
    {
        //
        // Add the "Install unlisted..." choice to the top of the list
        // box.
        LoadString(myInstance, IDS_UPDATED, szDesc, sizeof(szDesc)/sizeof(TCHAR));
        if ((iIndex = (int)(LONG)SendMessage(hWnd, LB_INSERTSTRING, 0, (LPARAM)(LPTSTR)szDesc)) != LB_ERR)
            SendMessage(hWnd, LB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)0);
     }
     if (bInitd)

         SendMessage(hWnd, LB_SETCURSEL, 0, 0L );


     SendMessage(hWnd,WM_SETREDRAW, TRUE, 0L);
     return(bInitd);
}


/*
 *  DLG: LB_AVAILABLE
 *
 *  RemoveAvailable()
 *
 *  Remove all drivers from the listbox and free all storage associated with
 *  the keyname
 */

void RemoveAvailable(HWND hWnd)
{
    int iIndex;
    HWND hWndA;
    LPTSTR pstrKey;

    hWndA = GetDlgItem(hWnd, LB_AVAILABLE);
    iIndex = (int)SendMessage(hWndA, LB_GETCOUNT, 0, 0L);
    while ( iIndex-- > 0)
    {
        if (( (pstrKey = (LPTSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex,
            0L)) != (LPTSTR)LB_ERR ) && pstrKey)
            LocalFree((HLOCAL)pstrKey);
    }
}


/*
 *  DLG: LB_AVAILABLE
 *
 *  AvailableDriversDlg()
 *
 *  List the available installable drivers or return FALSE if there are none.
 */

const static DWORD aAvailDlgHelpIds[] = {  // Context Help IDs
    LB_AVAILABLE,    IDH_ADD_DRIVER_LIST,
    ID_DRVSTRING,    IDH_ADD_DRIVER_LIST,

    0, 0
};

INT_PTR AvailableDriversDlg(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPTSTR    pstrKey;    //-jyg- added

    HWND    hWndA;
    int     iIndex;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            ShowWindow(hWnd, TRUE);
            wsStartWait();
            if (pinfOldDefault)
            {
                infSetDefault(pinfOldDefault);
                pinfOldDefault = NULL;
            }

            if ( !InitAvailable(hWndA = GetDlgItem(hWnd, LB_AVAILABLE), UNLIST_LINE))
            {
               /*
                *  We weren't able to find the [installable.drivers] section
                *  of the
                *  mmdriver.inf OR it was corrupt.  Go ahead and query the
                *  user to find an oemsetup.inf to make our default.  This
                *  is a bad state.
                */
                EndDialog(hWnd, FALSE);
                bFindOEM = TRUE;
                wcscpy(szDrv, szOemInf);
                if (DialogBox(myInstance, MAKEINTRESOURCE(DLG_INSERTDISK),
                        hWnd,  AddDriversDlg) == TRUE)
                    PostMessage(hWnd, WM_INITDIALOG, 0, 0L);
                else
                    pinfOldDefault = infSetDefault(pinfOldDefault);

                bFindOEM = FALSE;
            }
            wsEndWait();
            break;

        case WM_COMMAND:

            switch ( LOWORD(wParam ))
            {
                case LB_AVAILABLE:

                    // Hm... We've picked it.

                    if ( HIWORD(wParam) == LBN_DBLCLK )
                        SendMessage(hWnd, WM_COMMAND, IDOK, 0L);
                    break;

                case IDOK:

                   /*
                    *  We've made our selection
                    */

                    hWndA = GetDlgItem(hWnd, LB_AVAILABLE);

                    if ( (iIndex = (int)SendMessage(hWndA, LB_GETCURSEL, 0, 0L)) != LB_ERR)
                    {
                        if (!iIndex)
                        {
                           /*
                            *  The first entry is for OEMs
                            */

                            INT_PTR iFound;
                            bBadOemSetup = FALSE;

                            bCopyEvenIfOlder = TRUE;
                            bFindOEM = TRUE;
                            hMesgBoxParent = hWnd;
                            while ((iFound = DialogBox(myInstance,
                                    MAKEINTRESOURCE(DLG_INSERTDISK), hWnd,
                                            AddDriversDlg)) == 2);
                            if (iFound == 1)
                            {
                                    RemoveAvailable(hWnd);
                                    SendDlgItemMessage(hWnd, LB_AVAILABLE,
                                            LB_RESETCONTENT, 0, 0L);
                                    PostMessage(hWnd, WM_INITDIALOG, 0, 0L);
                            }
                            bFindOEM = FALSE;
                        }
                        else
                        {
                           /*
                            *  The user selected an entry from our .inf
                            */

                            wsStartWait();

                           /*
                            *  The  data associated with the list item is
                            *  the driver key name (field 0 in the inf file).
                            */

                            pstrKey = (LPTSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex, 0L);
                            bCopyingRelated = FALSE;
                            bQueryExist = TRUE;

                            if (InstallDrivers(hWndMain, hWnd, pstrKey))
                            {
                               RefreshAdvDlgTree ();
                               wsEndWait();


                              /*
                               *  If bRestart is true then the system must
                               *  be restarted to activate these changes
                               */

                               if (bRestart)
                               {
                                  iRestartMessage= IDS_RESTART_ADD;
                                  DialogBox(myInstance,
                                          MAKEINTRESOURCE(DLG_RESTART), hWnd,
                                              RestartDlg);
                               }
                            }
                            else
                               wsEndWait();

                            bRestart = FALSE;
                            bRelated = FALSE;
                        }
                    }
                    EndDialog(hWnd, FALSE);
                    break;

                case IDCANCEL:
                    EndDialog(hWnd, FALSE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszWindowsHlp, HELP_CONTEXTMENU,
                  (UINT_PTR)(LPTSTR)aAvailDlgHelpIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszWindowsHlp,
                  HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAvailDlgHelpIds);
            break;

        case WM_DESTROY:
            //
            // free the strings added as DATAITEM to the avail list

            RemoveAvailable(hWnd);
            return(FALSE);

        default:
            return FALSE;
         break;
    }
    return(TRUE);
}


BOOL DriversDllInitialize( IN PVOID hInstance
                  , IN DWORD ulReason
                  , IN PCONTEXT pctx OPTIONAL
                  )
{
    if (ulReason != DLL_PROCESS_ATTACH)
        return TRUE;

    myInstance = hInstance;
    LoadString(myInstance, IDS_CLOSE,  aszClose, sizeof(aszClose)/sizeof(TCHAR));
    LoadString(myInstance, IDS_DRIVERDESC, szDriversDesc, sizeof(szDriversDesc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_FILE_ERROR, szFileError, sizeof(szFileError)/sizeof(TCHAR));
    LoadString(myInstance, IDS_INSTALLDRIVERS, szMDrivers, sizeof(szMDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_INSTALLDRIVERS32, szMDrivers32, sizeof(szMDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_RELATEDDESC, szRelatedDesc, sizeof(szRelatedDesc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_USERINSTALLDRIVERS, szUserDrivers, sizeof(szUserDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_UNLISTED, (LPTSTR)szUnlisted, sizeof(szUnlisted)/sizeof(TCHAR));
    LoadString(myInstance, IDS_KNOWN, szKnown, sizeof(szKnown)/sizeof(TCHAR));
    LoadString(myInstance, IDS_OEMSETUP, szOemInf, sizeof(szOemInf)/sizeof(TCHAR));
    LoadString(myInstance, IDS_SYSTEM, szSystem, sizeof(szSystem)/sizeof(TCHAR));
    LoadString(myInstance, IDS_OUT_OF_REMOVE_SPACE, szOutOfRemoveSpace, sizeof(szOutOfRemoveSpace)/sizeof(TCHAR));
    LoadString(myInstance, IDS_NO_DESCRIPTION, szNoDesc, sizeof(szNoDesc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_ERRORBOX, szError, sizeof(szError)/sizeof(TCHAR));
    LoadString(myInstance, IDS_REMOVEORNOT, szRemoveOrNot, sizeof(szRemoveOrNot)/sizeof(TCHAR));
    LoadString(myInstance, IDS_REMOVEORNOTSTRICT, szRemoveOrNotStrict, sizeof(szRemoveOrNotStrict)/sizeof(TCHAR));
    LoadString(myInstance, IDS_SETUPINF, szSetupInf, sizeof(szSetupInf)/sizeof(TCHAR));
    LoadString(myInstance, IDS_APPNAME, szAppName, sizeof(szAppName)/sizeof(TCHAR));

    LoadString(myInstance, IDS_DRIVERS, szDrivers, sizeof(szDrivers)/sizeof(TCHAR));
    LoadString(myInstance, IDS_REMOVE, szRemove, sizeof(szRemove)/sizeof(TCHAR));
    LoadString(myInstance, IDS_CONTROLINI, szControlIni, sizeof(szControlIni)/sizeof(TCHAR));
    LoadString(myInstance, IDS_SYSINI, szSysIni, sizeof(szSysIni)/sizeof(TCHAR));
    LoadString(myInstance, IDS_MCI, szMCI, sizeof(szMCI)/sizeof(TCHAR));
    LoadString(myInstance, IDS_DEFDRIVE, szDirOfSrc, sizeof(szDirOfSrc)/sizeof(TCHAR));
    LoadString(myInstance, IDS_CONTROL_HLP_FILE, szDriversHlp, sizeof(szDriversHlp)/sizeof(TCHAR));
    LoadString(myInstance, IDS_LASTQUERY, szLastQuery, sizeof(szLastQuery)/sizeof(TCHAR));

    return TRUE;
}

void DeleteCPLCache(void)
{
    HKEY hKeyCache;

    if (ERROR_SUCCESS ==
        RegOpenKey(HKEY_CURRENT_USER,
                   TEXT("Control Panel\\Cache\\multimed.cpl"),
                   &hKeyCache)) {
        for ( ; ; ) {
            TCHAR Name[50];

            if (ERROR_SUCCESS ==
                RegEnumKey(hKeyCache,
                           0,
                           Name,
                           sizeof(Name)/sizeof(TCHAR))) {
                HKEY hSubKey;

                RegDeleteKey(hKeyCache, Name);
            } else {
                break;    // leave loop
            }
        }

        RegDeleteKey(hKeyCache, NULL);
        RegCloseKey(hKeyCache);
    }
}


/*
** RestartDlg()
**
** Offer user the choice to (not) restart windows.
*/
INT_PTR RestartDlg(HWND hDlg, unsigned uiMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uiMessage)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
               case IDCANCEL:
                    //
                    // don't restart windows
                    //
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    //
                    // do restart windows, *dont* dismiss dialog incase
                    // the user canceled it.
                    //
                    ReBoot(hDlg);
                    SetActiveWindow(hDlg);
                    //EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_INITDIALOG:
              /*
              **  Delete the control panel's cache so it will get it
              **  right!
              */

              DeleteCPLCache();


              if (iRestartMessage)
              {
                TCHAR szMesg1[300];
                TCHAR szMesg2[300];

                LoadString(myInstance, iRestartMessage, szMesg1, sizeof(szMesg1)/sizeof(TCHAR));
                wsprintf(szMesg2, szMesg1, (LPTSTR)szRestartDrv);
                SetDlgItemText(hDlg, IDS_RESTARTTEXT, (LPTSTR)szMesg2);

                if (iRestartMessage == IDS_RESTART_NOSOUND)
                {
                  PostMessage (hDlg, WM_NEXTDLGCTL,
                               (WPARAM)GetDlgItem(hDlg,IDOK), (LPARAM)TRUE);
                }
              }
              return TRUE;

        case WM_KEYUP:
            if (wParam == VK_F3)
                //
                // don't restart windows
                //
                EndDialog(hDlg, FALSE);
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * UserInstalled()
 *
 *
 */

BOOL UserInstalled(LPTSTR szKey)
{
        TCHAR buf[MAXSTR];
        LPTSTR lpstr = NULL;
        ZeroMemory (buf, sizeof (buf)); // make prefix happy.

        lpstr = GetProfile (szUserDrivers, (LPTSTR)szKey, szControlIni, buf, sizeof(buf));
        if (lpstr && *lpstr != TEXT('\0'))
            return(TRUE);
        else
            return(FALSE);
}

/*
 *   AddUnlistedDlg()
 *
 *   The following function processes requests by the user to install unlisted
 *   or updated drivers.
 *
 *   PARAMETERS:  The normal Dialog box parameters
 *   RETURN VALUE:  The usual Dialog box return value
 */

INT_PTR AddUnlistedDlg(HWND hDlg, unsigned nMsg, WPARAM wParam, LPARAM lParam)
{
  switch (nMsg)
  {
      case WM_INITDIALOG:
      {
          HWND hListDrivers;
          BOOL bFoundDrivers;

          wsStartWait();
          hListDrivers = GetDlgItem(hDlg, LB_UNLISTED);

          /* Search for drivers */
          bFoundDrivers = InitAvailable(hListDrivers, NO_UNLIST_LINE);
          if (!bFoundDrivers)
          {
                //
                // We weren't able to find the MMDRIVERS section of the
                // setup.inf OR it was corrupt.  Go ahead and query the
                // user to find an oemsetup.inf to make our default.  This
                // is a bad state.
                //

                INT_PTR iFound;

                bFindOEM = TRUE;
                bBadOemSetup = TRUE;
                while ((iFound = DialogBox(myInstance,
                        MAKEINTRESOURCE(DLG_INSERTDISK), hMesgBoxParent,
                                AddDriversDlg)) == 2);
                bFindOEM = FALSE;
                if (iFound == 1)
                {
                        SendDlgItemMessage(hDlg, LB_AVAILABLE,
                                LB_RESETCONTENT, 0, 0L);
                        PostMessage(hDlg, WM_INITDIALOG, 0, 0L);
                }
                EndDialog(hDlg, FALSE);
          }
          SendMessage(hListDrivers, LB_SETCURSEL, 0, 0L);
          wsEndWait();

          break;
        }

      case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDH_DLG_ADD_UNKNOWN:
              goto DoHelp;

            case LB_UNLISTED:
              if (HIWORD(wParam) != LBN_DBLCLK)
                  break;

              // else Fall through here
            case IDOK:
            {
             HWND hWndA;
             int iIndex;
             LPTSTR pstrKey;

             hWndA = GetDlgItem(hDlg, LB_UNLISTED);
             if ( (iIndex = (int)SendMessage(hWndA, LB_GETCURSEL, 0, 0L))
                                                             != LB_ERR)
             {
                wsStartWait();
                pstrKey = (LPTSTR)SendMessage(hWndA, LB_GETITEMDATA, iIndex, 0L);
                bCopyingRelated = FALSE;
                bQueryExist = TRUE;
                if (InstallDrivers(hWndMain, hDlg, pstrKey))
                {
                   RefreshAdvDlgTree ();
                   wsEndWait();

                   if (bRestart)
                   {
                      iRestartMessage= IDS_RESTART_ADD;
                      DialogBox(myInstance,   MAKEINTRESOURCE(DLG_RESTART),
                                                      hDlg, RestartDlg);
                   }
                 }
                 else
                   wsEndWait();
                 bRelated = FALSE;
                 bRestart = FALSE;
              }
              EndDialog(hDlg, FALSE);
            }
            break;

            case IDCANCEL:
              EndDialog(hDlg, wParam);
              break;

            default:
              return FALSE;
          }
        break;

      case WM_HELP:
DoHelp:
        WinHelp (hDlg, gszWindowsHlp, HELP_CONTEXT, IDH_MMCPL_DEVPROP_ENABLE);
        break;

      default:
        return FALSE;
   }
   return TRUE;
}
/*
 *  ReBoot()
 *
 *  Restart the system.  If this fails we put up a message box
 */

 void ReBoot(HWND hDlg)
 {
     DWORD Error;
     BOOLEAN WasEnabled;

    /*
     *  We must adjust our privilege level to be allowed to restart the
     *  system
     */

     RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                         TRUE,
                         FALSE,
                         &WasEnabled
                       );
    /*
     *  Try to reboot the system
     */

     if (!ExitWindowsEx(EWX_REBOOT, 0xFFFFFFFF)) {

         Error = GetLastError();

        /*
         *  Put up a message box if we failed
         */

         if (Error != NO_ERROR) {
            TCHAR szCantRestart[80];
            LoadString(myInstance,
                       Error == ERROR_PRIVILEGE_NOT_HELD  ||
                       Error == ERROR_NOT_ALL_ASSIGNED  ||
                       Error == ERROR_ACCESS_DENIED ?
                           IDS_CANNOT_RESTART_PRIVILEGE :
                           IDS_CANNOT_RESTART_UNKNOWN,
                       szCantRestart,
                       sizeof(szCantRestart)/sizeof(TCHAR));

            MessageBox(hDlg, szCantRestart, szError,
                       MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
         }
     }
 }


void OpenDriverError(HWND hDlg, LPTSTR szDriver, LPTSTR szFile)
{
        TCHAR szMesg[MAXSTR];
        TCHAR szMesg2[MAXSTR];

        LoadString(myInstance, IDS_INSTALLING_DRIVERS, szMesg, sizeof(szMesg)/sizeof(TCHAR));
        wsprintf(szMesg2, szMesg, szDriver, szFile);
        MessageBox(hDlg, szMesg2, szError, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

}


/*
 *** AddIDriver - Adds a treeitem referencing the given PIDRIVER
 *
 * Note that the listed PIDRIVER should already have been added to the
 * aInstalledDrivers array (via AddIDriverToArray()) before calling this
 * routine.
 *
 */

HTREEITEM AddIDriver (HWND hTree, PIDRIVER pIDriver, DriverClass dc)
{
   short           idr;
   TV_INSERTSTRUCT ti;
   HTREEITEM       hti;
   short           ii;
   TCHAR           szFile[ _MAX_FNAME +1 +_MAX_EXT +1 ];
   TCHAR           szExt[ _MAX_EXT +1 ];
   TCHAR           szDesc[ cchRESOURCE ];

            // don't add an entry for one of the to-be-skipped drivers
            //
   lsplitpath (pIDriver->szFile, NULL, NULL, szFile, szExt);

   if (szExt[0] != TEXT('\0'))
      lstrcat (szFile, szExt);

    //check to see if we're trying to put a PNP driver into the legacy tree
    if (g_dcFilterClass == dcLEGACY)
    {
        if ((dc == dcWAVE) ||
            (dc == dcMIDI) ||
            (dc == dcMIXER) ||
            (dc == dcAUX))
        {
            if (IsPnPDriver(szFile))
            {
                return FALSE;
            }
        }
    }

   if (dc != dcMIDI)
      {
      for (ii = 0; ii < nDriversToSKIP; ii++)
         {
         if (!lstrcmpi (szFile, aDriversToSKIP[ ii ]))
            return FALSE;
         }
      }

            // If we were given a DriverClass, then the caller has
            // specified where we should create an entry--add the "Audio for"
            // (etc) tag before the description, and add it.
            //
            // Otherwise, determine where this driver belongs in the tree
            //
   if (dc != dcINVALID)
      {
      TCHAR   szTag[ cchRESOURCE ];

      switch (dc)
         {
         case dcWAVE:   GetString (szTag, IDS_AUDIOFOR);
                       break;
         case dcMIDI:   GetString (szTag, IDS_MIDIFOR);
                       break;
         case dcMIXER:  GetString (szTag, IDS_MIXERFOR);
                       break;
         case dcAUX:    GetString (szTag, IDS_AUXFOR);
                       break;
         default:       lstrcpy (szTag, TEXT("%s"));
                       break;
         }

      wsprintf (szDesc, szTag, pIDriver->szDesc);
      }
   else
      {
      if ((dc = GuessDriverClass (pIDriver)) == dcINVALID)
         return FALSE;

      lstrcpy (szDesc, pIDriver->szDesc);
      }

            // map that classification into an index within the
            // root entries of the tree (aDriverRoot[])
            //
   if ((idr = DriverClassToRootIndex (dc)) == -1)
      return FALSE;

            // if this driver already has an entry under this DriverClass,
            // then don't add another.
            //
   for (ii =0; ii < cInstalledDrivers; ++ii)
      {
      if (aInstalledDrivers[ ii ].pIDriver == pIDriver)
         break;
      }
   if (ii >= cInstalledDrivers)
      {
      ii = (short)NOPIDRIVER;
      }
   else if (aInstalledDrivers[ ii ].dwBits & aDriverRoot[ idr ].dwBit)
      {
      return FALSE; // Already have an entry here!
      }

            // since not all roots need exist all the time, make sure
            // this classification HAS a root in the tree
            //
   if (!EnsureRootIndexExists (hTree, idr))
      return FALSE;

            // finally, insert an item into the tree for this driver
            // note that for audio codecs to be sorted properly, they must
            // be added via this routine in their appropriate order--ie,
            // call this routine for the highest-priority codec first.
            //
   ti.hParent = aDriverRoot[ idr ].hti;
   ti.hInsertAfter = (dc == dcACODEC) ? TVI_LAST : TVI_SORT;
   ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
   ti.item.iImage = (int)idr;
   ti.item.iSelectedImage = (int)idr;
   ti.item.pszText = szDesc;
   ti.item.lParam = ii;

   if ((hti = TreeView_InsertItem (hTree, &ti)) == NULL)
      return FALSE;

   if (ii != NOPIDRIVER)
      aInstalledDrivers[ ii ].dwBits |= aDriverRoot[ idr ].dwBit;

   return hti;
}


BOOL AddIDriverByName (HWND hTree, LPCWSTR wszFile, DriverClass dc)
{
   LPTSTR pch;
   TCHAR tszFile[ max(cchRESOURCE, MAX_PATH) ];
   PIDRIVER pid;

#ifdef UNICODE
   lstrcpy (tszFile, wszFile);
#else
   wcstombs (tszFile, wszFile, cchRESOURCE);
#endif

            // Strip off any trailing whitespace
            //
   if (tszFile[0] == TEXT('\0'))
      return FALSE;

   for (pch = &tszFile[ lstrlen(tszFile)-1 ];
        pch >= tszFile && (*pch == TEXT('\t') || *pch == TEXT(' '));
        --pch)
      ;
   *(1+pch) = TEXT('\0');

            // If this is MMDRV.DLL, then it's possibly providing the
            // user-mode component for kernel-mode drivers.  Since it's
            // apparently impossible to determine the name of the .SYS
            // file which is providing a "\\.\WaveIn0" device (etc),
            // we'll use a hack: Check around for anyone registered
            // under the alias "Kernel", and use that.
            //
   if (!lstrcmpi (tszFile, cszMMDRVDLL))
      {
      mysize_t ii;
      for (ii = 0; ii < cInstalledDrivers; ++ii)
         {
         if (aInstalledDrivers[ ii ].pIDriver == NULL)
            continue;
         if (!lstrnicmp (aInstalledDrivers[ ii ].pIDriver->szAlias,
                         cszAliasKERNEL,
                         lstrlen(cszAliasKERNEL)))
            {
            lstrcpy (tszFile, aInstalledDrivers[ ii ].pIDriver->szFile);
            break;
            }
         }
      if (ii >= cInstalledDrivers)
         return FALSE;
      }

            // Find the driver in the aInstalledDriver array, and add
            // an entry for it in the tree.
            //
   if ((pid = FindIDriverByName (tszFile)) == NULL)
      return FALSE;

   if (AddIDriver (hTree, pid, dc) == NULL)
      return FALSE;

   return TRUE;
}


/*
 *** RemoveIDriver - Removes (and optionally frees) an IDRIVER from hAdvDlgTree
 *
 */

void RemoveIDriver (HWND hTree, PIDRIVER pIDriver, BOOL fFreeToo)
{
   mysize_t   ii;
   short      idr;
   HTREEITEM  hti;

            // Find each TreeItem which references this entry.
            //
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if ((hti = aDriverRoot[ idr ].hti) == NULL)
         continue;

      hti = TreeView_GetChild (hTree, hti);
      while (hti != NULL)
         {
         if (pIDriver != FindIDriverByTreeItem (hti))
            {
            hti = TreeView_GetNextSibling (hTree, hti);
            continue;
            }

         // We found a tree item which uses this driver, so delete the
         // item.  Also note that this may cause the driver's parent
         // node to no longer be necessary.
         //

         TreeView_DeleteItem (hTree, hti);
         hti = TreeView_GetChild (hTree, aDriverRoot[ idr ].hti);

         if (!aDriverRoot[ idr ].fAlwaysMake)   // may no longer need parent?
            {
            if (hti == NULL)                    // parent now has no children?
               {
               TreeView_DeleteItem (hTree, aDriverRoot[ idr ].hti);
               aDriverRoot[ idr ].hti = NULL;
               }
            }
         }
      }

            // See if we can find the given pIDriver within the
            // aInstalledDriver array.
            //
   for (ii = 0; ii < cInstalledDrivers; ++ii)
      {
      if (aInstalledDrivers[ ii ].pIDriver == pIDriver)
         {
         aInstalledDrivers[ ii ].dwBits = 0L;   // no longer in tree at all

         if (fFreeToo)
            {
            LocalFree ((HANDLE)aInstalledDrivers[ ii ].pIDriver);
            aInstalledDrivers[ ii ].pIDriver = NULL;
            }

         break;   // There's only one entry in this array for each pIDriver
         }
      }
}


#ifdef FIX_BUG_15451
HTREEITEM FindTreeItemByDriverName (LPTSTR pszName)
{
   PIDRIVER   pid;
   short      idr;
   HTREEITEM  hti;

   if ((pid = FindIDriverByName (pszName)) == NULL)
      return (HTREEITEM)0;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if ((hti = aDriverRoot[ idr ].hti) == NULL)
         continue;

      for (hti = TreeView_GetChild (hAdvDlgTree, hti);
           hti != NULL;
           hti = TreeView_GetNextSibling (hAdvDlgTree, hti))
         {
         if (pid == FindIDriverByTreeItem (hti))
            {
            return hti;
            }
         }
     }

   return (HTREEITEM)0;
}
#endif // FIX_BUG_15451


PIDRIVER FindIDriverByTreeItem (HTREEITEM hti)
{
   TV_ITEM tvi;

   tvi.mask = TVIF_PARAM;
   tvi.hItem = hti;
   TreeView_GetItem (hAdvDlgTree, &tvi);

   if ( (tvi.lParam < 0) ||
        (tvi.lParam >= cInstalledDrivers) )
      {
      return NULL;
      }

   return aInstalledDrivers[ tvi.lParam ].pIDriver;
}


/*
 *** FindIDriverByName - Returns the first found IDRIVER structure with a name
 *
 */

PIDRIVER FindIDriverByName (LPTSTR szFile)
{
   mysize_t ii;

   for (ii = 0; ii < cInstalledDrivers; ++ii)
      {
      if (aInstalledDrivers[ ii ].pIDriver == NULL)
         continue;
      if (aInstalledDrivers[ ii ].pIDriver->szAlias[0] == TEXT('\0'))
         continue;

      if (!FileNameCmp (aInstalledDrivers[ ii ].pIDriver->szFile, szFile))
         return aInstalledDrivers[ ii ].pIDriver;
      }

    return NULL;
}


PIDRIVER FindIDriverByResource (PIRESOURCE pir)
{
   return FindIDriverByName (FileName( pir->szFile ));
}


/*
 *** GetSelectedIDriver - Returns the IDRIVER structure the user has selected
 *
 */

PIDRIVER GetSelectedIDriver (HWND hTree)
{
   HTREEITEM  htiCur = TreeView_GetSelection (hTree);

   if (htiCur == NULL)
      return NULL;

   return FindIDriverByTreeItem (htiCur);
}


/*
 *** DriverClassToRootIndex - obtain idr for which {aDriverRoot[idr].dc == dc}
 *
 * The array index for aDriverRoot[] is NOT a DriverClass--that is,
 * aDriverRoot[ PickAnyDC ].dc is not necessarily equal to PickAnyDC.
 * Given a DC, this routine finds the index into aDriverRoot which references
 * that DC.
 *
 */

short DriverClassToRootIndex (DriverClass dc)
{
   short  idr;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[ idr ].dc == dc)
         return idr;
      }

   return -1;
}


/*
 *** GetDriverClass - guess a DriverClass based on an IDRIVER structure
 *
 * The registry has several different aliases which it uses in the LHS
 * of HKLM\software\microsoft\windowsnt\drivers,drivers32,etc to indicate
 * the classification of a particular driver.  These include:
 *
 * AUX, MIDI, MIDIMAPPER, MIXER, MSACM.*, VIDC.* WAVE, WAVEMAPPER
 *
 * as well as others--the full array of known entries is tracked within
 * aDriverKeywords[].  In addition, any of these may be followed by a
 * string of digits by which they are distinguished.  This routine parses
 * these keywords and returns a corresponding DriverClass enum.
 *
 */

DriverClass GuessDriverClass (PIDRIVER pid)
{
#ifdef FIX_BUG_15451
   return GuessDriverClassFromAlias (pid->szAlias);
}



DriverClass GuessDriverClassFromAlias (LPTSTR pszAlias)
{
#endif // FIX_BUG_15451
   TCHAR   szAlias[ cchRESOURCE ];
   TCHAR  *pch;
   short   ii;

#ifdef FIX_BUG_15451
   lstrcpy (szAlias, pszAlias); // Make a local copy so we can munge it
#else // FIX_BUG_15451
   lstrcpy (szAlias, pid->szAlias); // Make a local copy so we can munge it
#endif // FIX_BUG_15451

   if ((pch = lstrchr (szAlias, TEXT('.'))) != NULL)
      *pch = TEXT('0');

   for (ii = 0; ii < nDriverKEYWORDS; ii++)
      {
      if (!lstrnicmp (szAlias,
                      aDriverKeyword[ii].psz,
                      lstrlen (aDriverKeyword[ii].psz)))
         {
         return aDriverKeyword[ii].dc;
         }
      }

   return dcOTHER;
}


DriverClass GuessDriverClassFromTreeItem (HTREEITEM hti)
{
   short  idr;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (hti == aDriverRoot[idr].hti)
         return aDriverRoot[idr].dc;
      }

   return (g_dcFilterClass);
}



/*
 *** EnsureRootIndexExists - makes sure a given parent exists in hAdvDlgTree
 *
 */

BOOL EnsureRootIndexExists (HWND hTree, short idr)
{
   TV_INSERTSTRUCT ti;
   TCHAR           szDesc[ cchRESOURCE ];
   HWND            hwndParent = NULL;
   HWND            hwndName   = NULL;

            // If we already HAVE a root in the tree, we're done.
            //
   if (aDriverRoot[ idr ].hti != NULL)
      return TRUE;

    if (g_dcFilterClass != dcINVALID)
    {
        if (g_dcFilterClass == dcLEGACY)
        {
            if ((aDriverRoot[ idr ].dc != dcWAVE) &&
                (aDriverRoot[ idr ].dc != dcMIDI) &&
                (aDriverRoot[ idr ].dc != dcMIXER) &&
                (aDriverRoot[ idr ].dc != dcAUX))
            {
                return FALSE;
            }
        }
        else if (aDriverRoot[ idr ].dc != g_dcFilterClass)
        {
            return FALSE;
        }
    }

   aDriverRoot[idr].hti = TVI_ROOT;

   LoadString (myInstance, aDriverRoot[idr].idDesc, szDesc, cchRESOURCE);

    if ((g_dcFilterClass == dcINVALID) || (g_dcFilterClass == dcLEGACY))
    {
       ti.hInsertAfter = TVI_LAST;
       ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
       ti.item.iImage = idr;
       ti.item.iSelectedImage = idr;
       ti.item.pszText = szDesc;
       ti.item.lParam = NOPIDRIVER;

       if (aDriverRoot[idr].dc == dcINVALID)
          ti.hParent = TVI_ROOT;
       else
          ti.hParent = AdvDlgFindTopLevel ();

       if ((aDriverRoot[idr].hti = TreeView_InsertItem (hTree, &ti)) == NULL)
          return FALSE;
    }

    if (g_dcFilterClass != dcINVALID)
    {
       hwndParent = GetParent(hTree);
       if (hwndParent)
       {
            hwndName = GetDlgItem(hwndParent,IDC_DEVICECLASS);
            if (hwndName)
            {
                if (g_dcFilterClass == dcLEGACY)
                {
                    LoadString (myInstance, IDS_WAVE_HEADER, szDesc, cchRESOURCE);
                }

                SetWindowText(hwndName,szDesc);
            }
       }
    }

   return TRUE;
}


/*
 **** AdvDlgFindTopLevel - Finds the HTREEITEM associated with the tree root
 *
 * If there's a "Multimedia Devices" tree item under which the other roots
 * are collected, this will return that item.  Otherwise, it returns TVI_ROOT.
 *
 */

HTREEITEM AdvDlgFindTopLevel (void)
{
   short  idr;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[idr].dc == dcINVALID)
         return aDriverRoot[idr].hti;
      }

   return TVI_ROOT;
}



/*
 **** InitAdvDlgTree - Prepares the AdvDlg's treeview to display devices
 *
 */

BOOL InitAdvDlgTree (HWND hTree)
{
   int   cxIcon, cyIcon;
   short idr;
   UINT  uFlags;
   DWORD dwLayout;

   #ifdef UNICODE
   TreeView_SetUnicodeFormat(hTree,TRUE);
   #endif

    // Make sure we start with a clean slate
    //
   hAdvDlgTree = hTree;
   SendMessage (hTree, WM_SETREDRAW, FALSE, 0L);

   for (idr = 0; idr < nDriverROOTS; idr++)
   {
      aDriverRoot[ idr ].hti = NULL;
      aDriverRoot[ idr ].dwBit = ((DWORD)1) << idr;
   }

            // Create an imagelist for the icons in the treeview
            //
   cxIcon = (int)GetSystemMetrics (SM_CXSMICON);
   cyIcon = (int)GetSystemMetrics (SM_CYSMICON);
   uFlags = ILC_MASK | ILC_COLOR32;

   if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
   {
       uFlags |= ILC_MIRROR;
   }

   if ((hImageList = ImageList_Create (cxIcon, cyIcon,
                                       uFlags, nDriverROOTS, 1)) == NULL)
      return FALSE;

   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      HICON hi = LoadImage (myInstance,
                            MAKEINTRESOURCE( aDriverRoot[idr].idIcon ),
                            IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR);
      ImageList_AddIcon (hImageList, hi);
      }

   TreeView_SetImageList (hTree, hImageList, TVSIL_NORMAL);


    if (g_dcFilterClass == dcINVALID)
    {
            // Create the root nodes that are supposed to exist
            // even without children (note that not all are)
            //
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[ idr ].dc == dcINVALID)
         {
         if (!EnsureRootIndexExists (hTree, idr))
            return FALSE;
         }
      }
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      if (aDriverRoot[ idr ].dc != dcINVALID && aDriverRoot[ idr ].fAlwaysMake)
         {
         if (!EnsureRootIndexExists (hTree, idr))
            return FALSE;
         }
      }
    }
            // Expand the tree somewhat, so the user doesn't get
            // greeted by a blank page
            //
   TreeView_Expand (hTree, AdvDlgFindTopLevel(), TVE_EXPAND);

   SendMessage (hTree, WM_SETREDRAW, TRUE, 0L);
   return TRUE;
}


/*
 **** FreeAdvDlgTree - Removes and frees all items within the AdvDlg treeview
 *
 */

void FreeAdvDlgTree (HWND hTree)
{
   short  idr;

            // Delete all leaf nodes
            //
   for (idr = 0; idr < nDriverROOTS; idr++)
      {
      HTREEITEM  hti;

      if (aDriverRoot[idr].dc == dcINVALID)
         continue;
      if (aDriverRoot[idr].hti == NULL)
         continue;

      while ((hti = TreeView_GetChild (hTree, aDriverRoot[idr].hti)) != NULL)
         {
         if (aDriverRoot[ idr ].dc == dcMIDI)
            {
            HTREEITEM  htiInstrument;

            while ((htiInstrument = TreeView_GetChild (hTree, hti)) != NULL)
               {
               TV_ITEM tvi;
               tvi.mask = TVIF_PARAM;
               tvi.hItem = htiInstrument;
               tvi.lParam = 0;

               TreeView_GetItem(hTree, &tvi);

               if (tvi.lParam != 0)
                  LocalFree ((HANDLE)tvi.lParam);

               TreeView_DeleteItem (hTree, htiInstrument);
               }
            }

         TreeView_DeleteItem (hTree, hti);
         }
      }

            // Delete everything else
            //
   TreeView_DeleteAllItems (hTree);

            // Delete the tree's image list
            //
   if (hImageList)
      {
      TreeView_SetImageList (hTree, NULL, TVSIL_NORMAL);
      ImageList_Destroy (hImageList);
      hImageList = NULL;
      }

            // Delete the InstalledDrivers array
            //
   if (aInstalledDrivers != NULL)
      {
      mysize_t  ii;
      for (ii = 0; ii < cInstalledDrivers; ++ii)
         {
         if (aInstalledDrivers[ ii ].pIDriver != NULL)
            {
            LocalFree ((HANDLE)aInstalledDrivers[ ii ].pIDriver);
            aInstalledDrivers[ ii ].pIDriver = NULL;
            }
         }

      GlobalFree ((HGLOBAL)aInstalledDrivers);
      aInstalledDrivers = NULL;
      cInstalledDrivers = 0;
      }
}


int lstrnicmp (LPTSTR pszA, LPTSTR pszB, size_t cch)
{
#ifdef UNICODE
   size_t  cchA, cchB;
   TCHAR  *pch;

   for (cchA = 1, pch = pszA; cchA < cch; cchA++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }
   for (cchB = 1, pch = pszB; cchB < cch; cchB++, pch++)
      {
      if (*pch == TEXT('\0'))
         break;
      }

   return (CompareStringW (GetThreadLocale(), NORM_IGNORECASE,
                           pszA, cchA, pszB, cchB)
          )-2;  // CompareStringW returns {1,2,3} instead of {-1,0,1}.
#else
   return _strnicmp (pszA, pszB, cch);
#endif
}


LPTSTR lstrchr (LPTSTR pszTarget, TCHAR ch)
{
   size_t ich;
   if (pszTarget == NULL)
      return NULL;
   for (ich = 0; pszTarget[ich] != TEXT('\0'); ich++)
      {
      if (pszTarget[ich] == ch)
         return &pszTarget[ ich ];
      }

   return NULL;
}


void lsplitpath (LPTSTR pszSource,
                 LPTSTR pszDrive, LPTSTR pszPath, LPTSTR pszName, LPTSTR pszExt)
{
   LPTSTR   pszLastSlash = NULL;
   LPTSTR   pszLastDot = NULL;
   LPTSTR   pch;
   size_t   cchCopy;

        /*
         * NOTE: This routine was snitched out of USERPRI.LIB 'cause the
         * one in there doesn't split the extension off the name properly.
         *
         * We assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *      <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *      0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *      ':'
         *  dir:
         *      0 to _MAX_DIR-1 characters in the form of an absolute path
         *      (leading '/' or '\') or relative path, the last of which, if
         *      any, must be a '/' or '\'.  E.g -
         *      absolute path:
         *          \top\next\last\     ; or
         *          /top/next/last/
         *      relative path:
         *          top\next\last\      ; or
         *          top/next/last/
         *      Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *      0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *      0 to _MAX_EXT-1 characters where, if any, the first must be a
         *      '.'
         *
         */

             // extract drive letter and :, if any
             //
   if (*(pszSource + _MAX_DRIVE - 2) == TEXT(':'))
      {
      if (pszDrive)
         {
         lstrncpy (pszDrive, pszSource, _MAX_DRIVE-1);
         pszDrive[ _MAX_DRIVE-1 ] = TEXT('\0');
         }
      pszSource += _MAX_DRIVE-1;
      }
    else if (pszDrive)
      {
      *pszDrive = TEXT('\0');
      }

          // extract path string, if any.  pszSource now points to the first
          // character of the path, if any, or the filename or extension, if
          // no path was specified.  Scan ahead for the last occurence, if
          // any, of a '/' or '\' path separator character.  If none is found,
          // there is no path.  We will also note the last '.' character found,
          // if any, to aid in handling the extension.
          //
   for (pch = pszSource; *pch != TEXT('\0'); pch++)
      {
      if (*pch == TEXT('/') || *pch == TEXT('\\'))
         pszLastSlash = pch;
      else if (*pch == TEXT('.'))
         pszLastDot = pch;
      }

          // if we found a '\\' or '/', fill in pszPath
          //
   if (pszLastSlash)
      {
      if (pszPath)
         {
         cchCopy = (size_t)min((UINT)_MAX_DIR-1, (pszLastSlash-pszSource) + 1);
         lstrncpy (pszPath, pszSource, cchCopy);
         pszPath[ cchCopy ] = 0;
         }
      pszSource = pszLastSlash +1;
      }
   else if (pszPath)
      {
      *pszPath = TEXT('\0');
      }

             // extract file name and extension, if any.  Path now points to
             // the first character of the file name, if any, or the extension
             // if no file name was given.  Dot points to the '.' beginning the
             // extension, if any.
             //

   if (pszLastDot && (pszLastDot >= pszSource))
      {
               // found the marker for an extension -
               // copy the file name up to the '.'.
               //
      if (pszName)
         {
         cchCopy = (size_t)min( (UINT)_MAX_DIR-1, (pszLastDot-pszSource) );
         lstrncpy (pszName, pszSource, cchCopy);
         pszName[ cchCopy ] = 0;
         }

               // now we can get the extension
               //
      if (pszExt)
         {
         lstrncpy (pszExt, pszLastDot, _MAX_EXT -1);
         pszExt[ _MAX_EXT-1 ] = TEXT('\0');
         }
      }
   else
      {
               // found no extension, give empty extension and copy rest of
               // string into fname.
               //
      if (pszName)
         {
         lstrncpy (pszName, pszSource, _MAX_FNAME -1);
         pszName[ _MAX_FNAME -1 ] = TEXT('\0');
         }

      if (pszExt)
         {
         *pszExt = TEXT('\0');
         }
      }

}

void lstrncpy (LPTSTR pszTarget, LPTSTR pszSource, size_t cch)
{
   size_t ich;
   for (ich = 0; ich < cch; ich++)
      {
      if ((pszTarget[ich] = pszSource[ich]) == TEXT('\0'))
         break;
      }
}



/*
 * DEVICE PROPERTY SHEETS _____________________________________________________
 *
 */

         // General flag macros
         //
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

BOOL          InstrumentToResource      (PIRESOURCE, HTREEITEM);
BOOL          DriverToResource          (HWND,PIRESOURCE,PIDRIVER,DriverClass);
DriverClass   OldClassIDToDriverClass   (int);
void          FreeClassNode             (PCLASSNODE);
PIDRIVER      FindIDriverByResource     (PIRESOURCE);
void          EnableDriverService       (PIRESOURCE, BOOL);

BOOL PASCAL DoDevPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
STATIC void SetDevStatus(int iStatus, HWND hDlg);
INT_PTR CALLBACK ACMDlg(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);


/*
 *** DriverToResource - create a PIRESOURCE structure from a PIDRIVER structure
 *
 * The Win95 code uses PIRESOURCEs (among other structures) to keep track of
 * the item in the Advanced tab's treeview; the old WinNT code used PIDRIVER
 * structures to keep track of the items in its listbox.  The tree now uses
 * PIDRIVER structures, but we create PIRESOURCE structures out of 'em before
 * passing control off to the Win95 properties dialogs, which came through
 * largely unmodified.
 *
 * BTW, I retained the PIDRIVER structures as the main treeview structure
 * because it prevented difficulty in porting over the Install/Remove Driver
 * code from the old NT code.
 *
 */

BOOL DriverToResource (HWND hPar, PIRESOURCE pir, PIDRIVER pid, DriverClass dc)
{
   if (dc == dcINVALID)
      {
      if ((dc = GuessDriverClass (pid)) == dcINVALID)
         return FALSE;
      }

   if ((pir->pcn = (PCLASSNODE)LocalAlloc (LPTR, sizeof(CLASSNODE))) == NULL)
      return FALSE;

   if (!DriverClassToClassNode (pir->pcn, dc))
      {
      LocalFree ((HANDLE)pir->pcn);
      return FALSE;
      }

   if (dc == dcACODEC)
      pir->iNode = 3;   // 1=class, 2=device, 3=acm, 4=instmt
// else if (dc == dcINSTRUMENT)
//    pir->iNode = 4;   // 1=class, 2=device, 3=acm, 4=instmt
   else
      pir->iNode = 2;   // 1=class, 2=device, 3=acm, 4=instmt

   lstrcpy (pir->szFriendlyName, pid->szDesc);
   lstrcpy (pir->szDesc,         pid->szDesc);
   lstrcpy (pir->szFile,         pid->szFile);
   lstrcpy (pir->szDrvEntry,     pid->szAlias);
   lstrcpy (pir->szClass,        pir->pcn->szClass);

   pid->fQueryable = IsConfigurable (pid, hPar);
   pir->fQueryable = (short)pid->fQueryable;
   pir->iClassID = (short)DriverClassToOldClassID (dc);
   pir->szParam[0] = 0;
   pir->dnDevNode = 0;
   pir->hDriver = NULL;

            // Find fStatus, which despite its name is really a series of
            // flags--in Win95 it's composed of DEV_* flags (from the old
            // mmcpl.h), but those are tied with PNP.  Here, we use the
            // dwStatus* flags:
            //
   pir->fStatus = (int)GetDriverStatus (pid);

   return TRUE;
}


BOOL InstrumentToResource (PIRESOURCE pir, HTREEITEM hti)
{
   TV_ITEM tvi;
   PINSTRUM pin;

   tvi.mask = TVIF_PARAM;
   tvi.hItem = hti;
   tvi.lParam = 0;
   TreeView_GetItem(hAdvDlgTree, &tvi);

   if ((pin = (PINSTRUM)tvi.lParam) == NULL)
      return FALSE;


   if ((pir->pcn = (PCLASSNODE)LocalAlloc (LPTR, sizeof(CLASSNODE))) == NULL)
      return FALSE;

   if (!DriverClassToClassNode (pir->pcn, dcMIDI))
      {
      LocalFree ((HANDLE)pir->pcn);
      return FALSE;
      }

   pir->iNode = 4;  // 1=class, 2=device, 3=acm, 4=instmt

   lstrcpy (pir->szFriendlyName, pin->szFriendly);
   lstrcpy (pir->szDesc,         pin->szKey);
// lstrcpy (pir->szFile,         TEXT("unused"));
// lstrcpy (pir->szDrvEntry,     TEXT("unused"));
   lstrcpy (pir->szClass,        pir->pcn->szClass);

   pir->fQueryable = FALSE;
   pir->iClassID = MIDI_ID;
   pir->szParam[0] = 0;
   pir->dnDevNode = 0;
   pir->hDriver = NULL;
   pir->fStatus = 0;

   return TRUE;
}


BOOL DriverClassToClassNode (PCLASSNODE pcn, DriverClass dc)
{
   short  idr;
   short  ii;
   int    cxIcon, cyIcon;

   if ((idr = DriverClassToRootIndex (dc)) == -1)
      return FALSE;

   pcn->iNode = 1;  // 1=class, 2=device, 3=acm, 4=instmt

   GetString (pcn->szClassName, aDriverRoot[idr].idDesc);
   pcn->szClass[0] = TEXT('\0');

   for (ii = 0; ii < nKeywordDESCS; ii++)
      {
      if (aKeywordDesc[ii].dc == dc)
         {
         lstrcpy (pcn->szClass, aKeywordDesc[ii].psz);
         break;
         }
      }

   cxIcon = (int)GetSystemMetrics (SM_CXICON);
   cyIcon = (int)GetSystemMetrics (SM_CYICON);

   pcn->hIcon = LoadImage (myInstance,
                           MAKEINTRESOURCE( aDriverRoot[ idr ].idIcon ),
                           IMAGE_ICON, cxIcon, cyIcon, LR_DEFAULTCOLOR);

   return TRUE;
}


int DriverClassToOldClassID (DriverClass dc)
{
   switch (dc)
      {
      case dcWAVE:   return WAVE_ID;      break;
      case dcMIDI:   return MIDI_ID;      break;
      case dcMIXER:  return MIXER_ID;     break;
      case dcAUX:    return AUX_ID;       break;
      case dcMCI:    return MCI_ID;       break;
      case dcACODEC: return ACM_ID;       break;
      case dcVCODEC: return ICM_ID;       break;
      case dcVIDCAP: return VIDCAP_ID;    break;
      case dcJOY:    return JOYSTICK_ID;  break;
      default:       return JOYSTICK_ID;  break;
      }
}


DriverClass OldClassIDToDriverClass (int ii)
{
   switch (ii)
      {
      case WAVE_ID:      return dcWAVE;    break;
      case MIDI_ID:      return dcMIDI;    break;
      case MIXER_ID:     return dcMIXER;   break;
      case AUX_ID:       return dcAUX;     break;
      case MCI_ID:       return dcMCI;     break;
      case ACM_ID:       return dcACODEC;  break;
      case ICM_ID:       return dcVCODEC;  break;
      case VIDCAP_ID:    return dcVIDCAP;  break;
      case JOYSTICK_ID:  return dcJOY;     break;
      default:           return dcOTHER;
      }
}


void FreeIResource (PIRESOURCE pir)
{
   if (pir->pcn != NULL)
      {
      FreeClassNode (pir->pcn);
      LocalFree ((HANDLE)pir->pcn);
      pir->pcn = NULL;
      }
}


void FreeClassNode (PCLASSNODE pcn)
{
   if (pcn->hIcon != NULL)
      {
      DestroyIcon (pcn->hIcon);
      pcn->hIcon = NULL;
      }
}


DWORD GetDriverStatus (PIDRIVER pid)
{
   DWORD     dwStatus;
   SC_HANDLE scManager;
   SC_HANDLE scDriver;
   TCHAR     szName[ cchRESOURCE ];

   dwStatus = 0;

   lsplitpath (pid->szFile, NULL, NULL, szName, NULL);

            // First step: determine if the driver has a service
            //
   if ((scManager = OpenSCManager (NULL, NULL, GENERIC_READ)) != NULL)
      {
      if ((scDriver = OpenService (scManager, szName, GENERIC_READ)) != NULL)
         {
         QUERY_SERVICE_CONFIG  qsc;
         SERVICE_STATUS        ss;
         DWORD                 cbReq;
         void                 *pqsc;

         SetFlag (dwStatus, dwStatusHASSERVICE);

                  // Great!  It has a service.  Find out if the service
                  // is actively running, and whether it is disabled.
                  //
         if (QueryServiceConfig (scDriver, &qsc, sizeof(qsc), &cbReq))
            {
            if (qsc.dwStartType != SERVICE_DISABLED)
               {
               SetFlag (dwStatus, dwStatusSvcENABLED);
               }
            }
         else if ((pqsc = (void *)LocalAlloc (LPTR, cbReq)) != NULL)
            {
            if (QueryServiceConfig (scDriver,
                                    (QUERY_SERVICE_CONFIG *)pqsc,
                                    cbReq, &cbReq))
               {
               if ( ((QUERY_SERVICE_CONFIG *)pqsc)->dwStartType
                     != SERVICE_DISABLED)
                  {
                  SetFlag (dwStatus, dwStatusSvcENABLED);
                  }
               }

            LocalFree ((HANDLE)pqsc);
            }

         if (QueryServiceStatus (scDriver, &ss))
            {
            if ((ss.dwCurrentState != SERVICE_STOPPED) &&
                (ss.dwCurrentState != SERVICE_STOP_PENDING))
               {
               SetFlag (dwStatus, dwStatusSvcSTARTED);
               }
            }

         CloseServiceHandle (scDriver);
         }

      CloseServiceHandle (scManager);
      }

            // If no service, see if we can talk to the driver itself
            //
   if (!IsFlagSet (dwStatus, dwStatusHASSERVICE))
      {
      HANDLE hDriver;

      if ((hDriver = OpenDriver (pid->wszAlias, pid->wszSection, 0L)) != NULL)
         {
         SetFlag (dwStatus, dwStatusDRIVEROK);

         CloseDriver (hDriver, 0L, 0L);
         }
      }

            // If it's a wave device, can we map through it?
            //
   if (GetMappable (pid))
      {
      SetFlag (dwStatus, dwStatusMAPPABLE);
      }

   return dwStatus;
}


void GetTreeItemNodeDesc (LPTSTR pszTarget, PIRESOURCE pir)
{
   lstrcpy (pszTarget, pir->szFriendlyName);
}


void GetTreeItemNodeID (LPTSTR pszTarget, PIRESOURCE pir)
{
   DriverClass dc;
   CLASSNODE cn;

   *pszTarget = 0;  // In case we fail later

   dc = OldClassIDToDriverClass (pir->iClassID);
   if (!DriverClassToClassNode (&cn, dc))
      return;

   switch (pir->iNode)  // 1=class, 2=device, 3=acm, 4=instmt
      {
      case 1:   // class
         lstrcpy (pszTarget, cn.szClass);
         break;

      case 2:   // instrument
         wsprintf (pszTarget, TEXT("%s\\%s"), cn.szClass, pir->szDrvEntry);
         break;

      case 4:   // instrument
         lstrcpy (pszTarget, pir->szDesc);
         break;

      default:
         lstrcpy (pszTarget, pir->szDesc);
         break;
      }

   FreeClassNode (&cn);
}


void ShowDeviceProperties (HWND hPar, HTREEITEM hti)
{
   IRESOURCE   ir;
   CLASSNODE   cn;
   DEVTREENODE dtn;
   short       idr;
   TCHAR        szTitle[ cchRESOURCE ];
   TCHAR        szTab[ cchRESOURCE ];
   DriverClass dc;
   PIDRIVER    pid;

   if (hti == NULL)
      return;

   if (TreeView_GetParent (hAdvDlgTree, hti) &&
       TreeView_GetGrandParent (hAdvDlgTree, hti) &&
       (GuessDriverClassFromTreeItem (
                       TreeView_GetGrandParent (hAdvDlgTree, hti)
                                     ) == dcMIDI))
      {
      if (InstrumentToResource (&ir, hti))
         {
         ShowMidiPropSheet (NULL,
                            ir.szFriendlyName,
                            hPar,
                            MIDI_INSTRUMENT_PROP,
                            ir.szFriendlyName,
                            hti,
                            (LPARAM)&ir,
                            (LPARAM)hAdvDlgTree);

         FreeIResource (&ir);
         }
      return;
      }
   else if ((pid = FindIDriverByTreeItem (hti)) != NULL)
      {
      dc = GuessDriverClassFromTreeItem (TreeView_GetParent(hAdvDlgTree,hti));
      if (dc == dcINVALID)
         {
         if ((dc = GuessDriverClass (pid)) == dcINVALID)
            return;
         }
      }
   else
      {
      if ((dc = GuessDriverClassFromTreeItem (hti)) == dcINVALID)
         return;
      }

   if (g_dcFilterClass != dcINVALID)
   {
        if ((dc == dcOTHER) || (dc == dcINVALID))
        {
            dc = g_dcFilterClass;
        }
   }

   if ((idr = DriverClassToRootIndex (dc)) == -1)
      return;

   if (pid == NULL) // Just want class properties?
      {
      if (!DriverClassToClassNode (&cn, dc))
         return;

      if (dc == dcMIDI) // MIDI class properties?
         {
         GetString (szTitle, aDriverRoot[idr].idDesc);

         ShowMidiPropSheet (NULL,
                            szTitle,
                            hPar,
                            MIDI_CLASS_PROP,
                            szTitle,
                            hti,
                            (LPARAM)&cn,
                            (LPARAM)hAdvDlgTree);
         }
      else // Generic class properties?  (nothing to do, really)
         {
         GetString (szTab,   IDS_GENERAL);
         GetString (szTitle, aDriverRoot[idr].idDesc);

         dtn.lParam = (LPARAM)&cn;
         dtn.hwndTree = hAdvDlgTree;

         ShowPropSheet (szTab,
                        DevPropDlg,
                        DLG_DEV_PROP,
                        hPar,
                        szTitle,
                        (LPARAM)&dtn);
         }

      FreeClassNode (&cn);
      }
   else
      {
      switch (dc)
         {
         case dcACODEC:
               GetString (szTab, IDS_GENERAL);

               ShowPropSheet (szTab,
                              ACMDlg,
                              DLG_ACMDEV_PROP,
                              hPar,
                              pid->szDesc,
                              pid->lp);

               // Re-sort the Audio Codec entries, in case their priorities
               // have changed.  Then find treeview item for this codec,
               // and select it.
               //
               {
               HTREEITEM  hti;
               short      idr;

               SendMessage (hAdvDlgTree, WM_SETREDRAW, FALSE, 0L);
               FillTreeFromMSACM (hAdvDlgTree);
               SendMessage (hAdvDlgTree, WM_SETREDRAW, TRUE, 0L);

               if ((idr = DriverClassToRootIndex (dcACODEC)) != -1)
                  {
                  if ((hti = aDriverRoot[ idr ].hti) != NULL)
                     {
                     for (hti = TreeView_GetChild (hAdvDlgTree, hti);
                          hti != NULL;
                          hti = TreeView_GetNextSibling (hAdvDlgTree, hti))
                        {
                        if (pid == FindIDriverByTreeItem (hti))
                           {
                           TreeView_SelectItem (hAdvDlgTree, hti);
                           break;
                           }
                        }
                     }
                  }
               }
              break;

         case dcMIDI:
               if (!DriverToResource (hPar, &ir, pid, dc))
                  break;

               GetString (szTab, IDS_GENERAL);

               dtn.lParam = (LPARAM)&ir;
               dtn.hwndTree = hAdvDlgTree;

               ShowWithMidiDevPropSheet (szTab,
                                         DevPropDlg,
                                         DLG_DEV_PROP,
                                         hPar,
                                         pid->szDesc,
                                         hti,
                                         (LPARAM)&dtn,
                                         (LPARAM)&ir,
                                         (LPARAM)hAdvDlgTree);

               FreeIResource (&ir);
              break;

         case dcWAVE:
               if (!DriverToResource (hPar, &ir, pid, dc))
                  break;

               GetString (szTab, IDS_GENERAL);

               dtn.lParam = (LPARAM)&ir;
               dtn.hwndTree = hAdvDlgTree;

               ShowPropSheet (szTab,
                              DevPropDlg,
                              DLG_WAVDEV_PROP,
                              hPar,
                              pid->szDesc,
                              (LPARAM)&dtn);

               FreeIResource (&ir);
              break;

         default:
               if (!DriverToResource (hPar, &ir, pid, dc))
                  break;

               GetString (szTab, IDS_GENERAL);

               dtn.lParam = (LPARAM)&ir;
               dtn.hwndTree = hAdvDlgTree;

               ShowPropSheet (szTab,
                              DevPropDlg,
                              DLG_DEV_PROP,
                              hPar,
                              pid->szDesc,
                              (LPARAM)&dtn);

               FreeIResource (&ir);
              break;
         }
      }
}



#include "medhelp.h"

const static DWORD aDevPropHelpIds[] = {  // Context Help IDs
    ID_DEV_SETTINGS,     IDH_MMCPL_DEVPROP_SETTINGS,
    IDC_DEV_ICON,        NO_HELP,
    IDC_DEV_DESC,        NO_HELP,
    IDC_DEV_STATUS,      NO_HELP,
    IDC_ENABLE,          IDH_MMCPL_DEVPROP_ENABLE,
    IDC_DISABLE,         IDH_MMCPL_DEVPROP_DISABLE,
    IDC_DONOTMAP,        IDH_MMCPL_DEVPROP_DONT_MAP,
    0, 0
};

/*
 ***************************************************************
 * DlgProc for device Property sheet.
 ***************************************************************
 */
INT_PTR CALLBACK DevPropDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;

        case WM_INITDIALOG:
        {
            PIRESOURCE pIResource;
            PCLASSNODE pcn;
            PDEVTREENODE pdtn = (PDEVTREENODE)(((LPPROPSHEETPAGE)lParam)->lParam);

            SetWindowLongPtr(hDlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

            if (*((short *)(pdtn->lParam)) == 1)
            {
                HWND hwndTree = pdtn->hwndTree;
                HTREEITEM  htiCur = TreeView_GetSelection(hwndTree);
                TCHAR   sz[cchRESOURCE];
                TV_ITEM tvi;

                tvi.mask = TVIF_CHILDREN;
                tvi.hItem = htiCur;
                TreeView_GetItem(hwndTree, &tvi);

                pcn = (PCLASSNODE)(pdtn->lParam);
                //set class icon.
                SendDlgItemMessage(hDlg, IDC_DEV_ICON, STM_SETICON, (WPARAM)pcn->hIcon , 0L);
                SetWindowText(GetDlgItem(hDlg, IDC_DEV_DESC), pcn->szClassName);
                DestroyWindow(GetDlgItem(hDlg, IDC_ENABLE));
                DestroyWindow(GetDlgItem(hDlg, IDC_DISABLE));
                DestroyWindow(GetDlgItem(hDlg, ID_DEV_SETTINGS));

                GetString (sz, (tvi.cChildren) ? IDS_NOPROP : IDS_NODEVS);
                SetWindowText(GetDlgItem(hDlg, IDC_DEV_STATUS), sz);
            }
            else
            {
                pIResource = (PIRESOURCE)(pdtn->lParam);
                SendDlgItemMessage(hDlg, IDC_DEV_ICON, STM_SETICON, (WPARAM)pIResource->pcn->hIcon , 0L);
                SetWindowText(GetDlgItem(hDlg, IDC_DEV_DESC), pIResource->szDesc);
                if (!IsFlagSet(pIResource->fStatus, dwStatusHASSERVICE) &&
                    !IsFlagSet(pIResource->fStatus, dwStatusDRIVEROK))
                {
                    SetDevStatus(pIResource->fStatus, hDlg);
                }
                else
                {
                    if (pIResource->iClassID == WAVE_ID)
                    {
                        CheckDlgButton (hDlg,
    IDC_DONOTMAP,
    IsFlagClear(pIResource->fStatus,
              dwStatusMAPPABLE));
                    }

                    if (!pIResource->fQueryable || pIResource->fQueryable == -1)
                        EnableWindow(GetDlgItem(hDlg, ID_DEV_SETTINGS), FALSE);
                    if (!IsFlagSet (pIResource->fStatus, dwStatusHASSERVICE))
                    {
                        DestroyWindow(GetDlgItem(hDlg, IDC_ENABLE));
                        DestroyWindow(GetDlgItem(hDlg, IDC_DISABLE));
                    }
                    else
                    {
                        TCHAR szStatusStr[MAXSTR];
                        DriverClass dc;
                        short idr;

                        dc = OldClassIDToDriverClass (pIResource->iClassID);
                        idr = DriverClassToRootIndex (dc);

                        if (idr == -1)
                        {
                           DestroyWindow (GetDlgItem(hDlg, IDC_ENABLE));
                           DestroyWindow (GetDlgItem(hDlg, IDC_DISABLE));
                        }
                        else
                        {
                           GetString (szStatusStr, aDriverRoot[idr].idEnable);
                           SetDlgItemText(hDlg, IDC_ENABLE, szStatusStr);
                           GetString (szStatusStr, aDriverRoot[idr].idDisable);
                           SetDlgItemText(hDlg, IDC_DISABLE, szStatusStr);
                        }
                    }
                }
                SetDevStatus(pIResource->fStatus, hDlg);
            }

#ifdef FIX_BUG_15451
            if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
            {
                MakeThisDialogLookLikeTheOldDialog (GetParent(hDlg));
            }
#endif // FIX_BUG_15451
            break;
        }

        case WM_DESTROY:
            break;

        case WM_DROPFILES:
            break;

        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (UINT_PTR) (LPTSTR) aDevPropHelpIds);
            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
                    (UINT_PTR) (LPTSTR) aDevPropHelpIds);
            return TRUE;
        }

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoDevPropCommand);
            break;
    }
    return FALSE;
}

/*
 ***************************************************************
 *
 ***************************************************************
 */
BOOL PASCAL DoDevPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PDEVTREENODE pdtn = (PDEVTREENODE)GetWindowLongPtr(hDlg, DWLP_USER);
    PIRESOURCE pIResource;
    static int fDevStatus;

    if (!pdtn)
        return FALSE;
    pIResource = (PIRESOURCE)(pdtn->lParam);

    switch (id)
    {

    case ID_APPLY:
        if ((pIResource->iNode == 2) && (fDevStatus != pIResource->fStatus))
        {
            if ( (IsFlagSet (fDevStatus, dwStatusMAPPABLE)) !=
                 (IsFlagSet (pIResource->fStatus, dwStatusMAPPABLE)) )
            {
                SetMappable (pIResource,
                             (BOOL)IsFlagSet (fDevStatus, dwStatusMAPPABLE));
            }

            if ( (IsFlagSet (fDevStatus, dwStatusHASSERVICE)) &&
                 (IsFlagSet (fDevStatus, dwStatusSvcENABLED) !=
                  IsFlagSet (pIResource->fStatus, dwStatusSvcENABLED)) )
            {
#if 0 // TODO: Multiportmidi
                if ( (pIResource->iClassID == MIDI_ID) &&
                     (IsFlagSet(fDevStatus, DEV_MULTIPORTMIDI)) )
                {
                    EnableMultiPortMIDI (pIResource,
                                         IsFlagSet (fDevStatus,
                dwStatusSvcENABLED));
                }
                else
#endif
                {
                    EnableDriverService (pIResource,
                                         IsFlagSet (fDevStatus,
                dwStatusSvcENABLED));
                }
            }
            DisplayMessage(hDlg, IDS_CHANGESAVED, IDS_RESTART, MB_OK);
        }
        return TRUE;

    case IDOK:
        return TRUE;
    case IDCANCEL:
        break;

    case ID_INIT:
        if (pIResource->iNode == 2)
            fDevStatus = pIResource->fStatus;
#ifdef FIX_BUG_15451
        if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
        {
            FORWARD_WM_COMMAND(hDlg,ID_DEV_SETTINGS,0,0,PostMessage);
        }
#endif // FIX_BUG_15451
        break;

    case IDC_DONOTMAP:
        if(Button_GetCheck(GetDlgItem(hDlg, IDC_DONOTMAP)))
            ClearFlag(fDevStatus, dwStatusMAPPABLE);
        else
            SetFlag(fDevStatus, dwStatusMAPPABLE);
        PropSheet_Changed(GetParent(hDlg),hDlg);
        break;

    case IDC_ENABLE:
        if (IsFlagSet (fDevStatus, dwStatusHASSERVICE))
        {
           SetFlag(fDevStatus, dwStatusSvcENABLED);
           SetDevStatus(fDevStatus, hDlg);
           PropSheet_Changed(GetParent(hDlg),hDlg);
#if 0 // TODO: Multiportmidi
           if (IsFlagSet(fDevStatus, DEV_MULTIPORTMIDI))
           {
               DisplayMessage(hDlg, IDS_ENABLE, IDS_ENABLEMULTIPORTMIDI, MB_OK);
           }
#endif
        }
        break;

    case IDC_DISABLE:
        if (IsFlagSet (fDevStatus, dwStatusHASSERVICE))
        {
           ClearFlag(fDevStatus, dwStatusSvcENABLED);
           SetDevStatus(fDevStatus, hDlg);
           PropSheet_Changed(GetParent(hDlg),hDlg);
#if 0 // TODO: Multiportmidi
           if (IsFlagSet(fDevStatus, DEV_MULTIPORTMIDI))
           {
               DisplayMessage(hDlg, IDS_DISABLE, IDS_DISABLEMULTIPORTMIDI, MB_OK);
           }
#endif
        }
        break;

    case ID_DEV_SETTINGS:
#ifdef FIX_BUG_15451
        if (szDriverWhichNeedsSettings[0] != TEXT('\0'))
        {
            ConfigureDriver (hDlg, szDriverWhichNeedsSettings);
            szDriverWhichNeedsSettings[0] = 0;
        }
        else
        {
            PIDRIVER  pid;

            if ((pid = FindIDriverByResource (pIResource)) == NULL)
                break;

            ShowDriverSettings (hDlg, pid->szFile);
        }
#else // FIX_BUG_15451
    {
        PIDRIVER  pid;
        HANDLE    hDriver;

        if ((pid = FindIDriverByResource (pIResource)) == NULL)
            break;

        if ((hDriver = OpenDriver (pid->wszAlias, pid->wszSection, 0L)) == 0)
        {
            OpenDriverError(hDlg, pid->szDesc, pid->szFile);
        }
        else
        {
            DRVCONFIGINFO   DrvConfigInfo;
            InitDrvConfigInfo(&DrvConfigInfo, pid);
            if ((SendDriverMessage(
                     hDriver,
                     DRV_CONFIGURE,
                     (LONG)hDlg,
                     (LONG)(LPDRVCONFIGINFO)&DrvConfigInfo) ==
                DRVCNF_RESTART))
            {
               iRestartMessage= 0;
               DialogBox(myInstance,
                  MAKEINTRESOURCE(DLG_RESTART), hDlg, RestartDlg);
            }
            CloseDriver(hDriver, 0L, 0L);
        }
        }
#endif // FIX_BUG_15451
        break;
    }
    return FALSE;
}


/*
 ***************************************************************
 * Check the status flag for the device and display the appropriate text the
 *  the device properties prop sheet.
 ***************************************************************
 */
STATIC void SetDevStatus(int iStatus, HWND hDlg)
{
    HWND hwndS = GetDlgItem(hDlg, IDC_DEV_STATUS);
    TCHAR szStatus[cchRESOURCE];

    if (IsFlagSet (iStatus, dwStatusHASSERVICE))
    {
        if (IsFlagSet (iStatus, dwStatusSvcENABLED))
        {
            if (IsFlagSet (iStatus, dwStatusSvcSTARTED))
                GetString (szStatus, IDS_DEVENABLEDOK);
            else
                GetString (szStatus, IDS_DEVENABLEDNOTOK);

            CheckRadioButton (hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
        }
        else // service has been disabled
        {
            if (IsFlagSet (iStatus, dwStatusSvcSTARTED))
                GetString (szStatus, IDS_DEVDISABLEDOK);
            else
                GetString (szStatus, IDS_DEVDISABLED);

            CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_DISABLE);
        }

        SetWindowText(hwndS, szStatus);
    }
    else // driver does not have a service, and thus can't be disabled
    {
        if (IsFlagSet (iStatus, dwStatusDRIVEROK))
            GetString (szStatus, IDS_DEVENABLEDOK);
        else
            GetString (szStatus, IDS_DEVENABLEDNODRIVER);

        CheckRadioButton(hDlg, IDC_ENABLE, IDC_DISABLE, IDC_ENABLE);
        SetWindowText(hwndS, szStatus);
    }
}


/*
 *** EnableDriverService - enable or disable a service-based driver
 *
 * If Enable, the service will be set to start==system_start.
 * If !Enable, the service will be set to start==disabled.
 *
 */

void EnableDriverService (PIRESOURCE pir, BOOL fEnable)
{
   SC_HANDLE scManager;
   SC_HANDLE scDriver;
   TCHAR     szName[ cchRESOURCE ];

   lsplitpath (pir->szFile, NULL, NULL, szName, NULL);

            // First step: determine if the driver has a service
            //
   if ((scManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS)) != NULL)
      {
      if ((scDriver = OpenService (scManager, szName, SERVICE_ALL_ACCESS)) != 0)
         {
         QUERY_SERVICE_CONFIG  qsc;
         SERVICE_STATUS        ss;
         DWORD                 cbReq;
         void                 *pqsc;

         ChangeServiceConfig (scDriver,
                              SERVICE_NO_CHANGE,
                              (fEnable) ? SERVICE_SYSTEM_START
                                        : SERVICE_DISABLED,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

         CloseServiceHandle (scDriver);
         }

      CloseServiceHandle (scManager);
      }
}


/*
 ***************************************************************
 * SetMappable
 *
 * Sets the "Mappable" value for wave devices in the registry.
 * The registry key is created if necessary
 *
 ***************************************************************
 */

BOOL SetMappable (PIRESOURCE pIResource, BOOL fMappable)
{
    TCHAR   szFile[ _MAX_FNAME +1 +_MAX_EXT +1 ];
    TCHAR   szExt[ _MAX_EXT +1 ];
    TCHAR   szRegKey[MAX_PATH+1];
    DWORD   dwMappable;
    HKEY    hKey;

    dwMappable = (fMappable) ? 1 : 0;

    lsplitpath (pIResource->szFile, NULL, NULL, szFile, szExt);
    if (szExt[0] != TEXT('\0'))
        lstrcat (szFile, szExt);

    wsprintf (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, szFile);

    if (RegCreateKey (HKEY_LOCAL_MACHINE, szRegKey, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (RegSetValueEx (hKey,
                       REGSTR_VALUE_MAPPABLE,
                       (DWORD)0,
                       REG_DWORD,
                       (void *)&dwMappable,
                       sizeof(dwMappable)) != ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    RegCloseKey (hKey);

    if (fMappable)
    {
        SetFlag(pIResource->fStatus, dwStatusMAPPABLE);
    }
    else
    {
        ClearFlag(pIResource->fStatus, dwStatusMAPPABLE);
    }

    return TRUE;
}


BOOL GetMappable (PIDRIVER pIDriver)
{
    TCHAR   szFile[ _MAX_FNAME +1 +_MAX_EXT +1 ];
    TCHAR   szExt[ _MAX_EXT +1 ];
    TCHAR   szRegKey[MAX_PATH+1];
    DWORD   dwMappable;
    DWORD   dwSize;
    DWORD   dwType;
    HKEY    hKey;

    lsplitpath (pIDriver->szFile, NULL, NULL, szFile, szExt);
    if (szExt[0] != TEXT('\0'))
        lstrcat (szFile, szExt);

    wsprintf (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, szFile);

    if (RegOpenKey (HKEY_LOCAL_MACHINE, szRegKey, &hKey) != ERROR_SUCCESS)
    {
        return TRUE;
    }

    dwSize = sizeof(dwMappable);
    if (RegQueryValueEx (hKey,
                         REGSTR_VALUE_MAPPABLE,
                         NULL,
                         &dwType,
                         (void *)&dwMappable,
                         &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
        return TRUE;
    }

    RegCloseKey (hKey);

    return (dwMappable) ? TRUE : FALSE;
}


#ifdef FIX_BUG_15451

        // FixDriverService - work around known problems with sound drivers
        //
        // If there was a functioning kernel-mode service in place before the
        // config dialog was presented, then there should still be one
        // afterwards.  However, there are two known problems with the
        // currently-release drivers:
        //
        // 1) The service may not have shut down properly, and is stuck
        //    in a STOP_PENDING state(*).  If this is the case, we need to
        //    ensure that the service is set to load on SYSTEM_START, and
        //    tell the user that the machine has to be rebooted before sound
        //    will work again.
        //
        // 2) The service may have failed to restart properly, and is
        //    stopped(**).  If this is the case, and LoadType!=0, try setting
        //    LoadType=1 and starting the service.
        //
        // (*) -- bug #15451 in NT/SUR, where pending IRPs and open mixer
        //        handles prevent the service from shutting down
        //
        // (**) -- bug #XXXXX in NT/SUR, where some RISC machines stop the
        //         service, set LoadType=1, and fail to restart the service
        //         after you cancel their config dialog
        //
BOOL FixDriverService (PIDRIVER pid)
{
    SC_HANDLE scManager;
    SC_HANDLE scDriver;
    SERVICE_STATUS ss;
    BOOL rc = FALSE;
    TCHAR szName[ cchRESOURCE ];

    lsplitpath (pid->szFile, NULL, NULL, szName, NULL);

    // First step: open the service...even if it's hosed, we should
    // still be able to do this.
    //
    if ((scManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS)) == 0)
    {
        return FALSE;
    }
    if ((scDriver = OpenService (scManager, szName, SERVICE_ALL_ACCESS)) == 0)
    {
        CloseServiceHandle (scManager);
        return FALSE;
    }

    // Now check its status.  Look for STOP_PENDING and STOPPED states.
    //
    if (QueryServiceStatus (scDriver, &ss))
    {
        if (ss.dwCurrentState == SERVICE_STOP_PENDING)
        {
            // The service didn't stop properly--we'll have to reboot.
            // Make sure the service is configured such that it will start
            // properly when we restart.
            //
            ChangeServiceConfig (scDriver,
                                 SERVICE_NO_CHANGE,
                                 SERVICE_SYSTEM_START,   // Enable this puppy!
                                 SERVICE_NO_CHANGE,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

            // Tell the caller that a reboot is mandatory
            rc = TRUE;
        }
        else if (ss.dwCurrentState == SERVICE_STOPPED)
        {
            TCHAR szKey[ cchRESOURCE ];
            HKEY  hkParams;

            // The service stopped, but didn't restart properly--it could
            // just be the LoadType problem.  To fix this, we'll need
            // to enumerate all the keys underneath the key
            // HKLM\System\CurrentControlSet\Services\(thisdriver)\Parameters,
            // and look for ...\Parameters\*\LoadType==(DWORD)1.
            //
            // First step is to open HKLM\System\CCS\Services\(driver)\Parms.
            //
            wsprintf (szKey, TEXT("%s\\%s\\Parameters"),
                             REGSTR_PATH_SERVICES,
                             szName);

            if (RegOpenKey (HKEY_LOCAL_MACHINE, szKey, &hkParams) == 0)
            {
                DWORD cSubKeys;
                DWORD iSubKey;
                BOOL fFixedLoadType = FALSE;

                // Find out how many subkeys there are under here--the
                // keys we want are named "Device0" through "Device(n-1)"
                //
                RegQueryInfoKey (hkParams,
                                 NULL,          // lpClass
                                 NULL,          // lpcbClass
                                 NULL,          // lpReserved
                                 &cSubKeys,     // Whoops!  We want this.
                                 NULL,          // lpcbMaxSubKeyLen
                                 NULL,          // lpcbMaxClassLen
                                 NULL,          // lpcValues
                                 NULL,          // lpcbMaxValueNameLen
                                 NULL,          // lpcbMaxValueLen
                                 NULL,          // lpcbSecurityDescriptor
                                 NULL);         // lpftLastWriteTime

                // Open each subkey in turn, and look for a LoadType=
                // which is bogus.
                //
                for (iSubKey = 0; iSubKey < cSubKeys; ++iSubKey)
                {
                    HKEY hk;
                    TCHAR szSubKey[ cchRESOURCE ];
                    wsprintf (szSubKey, TEXT("Device%lu"), (LONG)iSubKey);

                    if (RegOpenKey (hkParams, szSubKey, &hk) == ERROR_SUCCESS)
                    {
                        DWORD dwLoadType;
                        DWORD dwType;
                        DWORD dwSize = sizeof(dwType);

                        if (RegQueryValueEx (hk,
                                             cszRegValueLOADTYPE,
                                             NULL,
                                             &dwType,
                                             (void *)&dwLoadType,
                                             &dwSize) == 0)
                        {
                            if (dwLoadType == 1)
                            {
                                dwLoadType = 0;
                                fFixedLoadType = TRUE;

                                RegSetValueEx (hk,
                                               cszRegValueLOADTYPE,
                                               0,
                                               REG_DWORD,
                                               (void *)&dwLoadType,
                                               sizeof(dwLoadType));
                            }
                        }

                        RegCloseKey (hk);
                    }
                }

                // If we fixed a LoadType value, try to restart the service.
                //
                if (fFixedLoadType)
                {
                    if (StartService (scDriver, 0, NULL))
                    {
                        ChangeServiceConfig (scDriver,
                                             SERVICE_NO_CHANGE,
                                             SERVICE_SYSTEM_START,
                                             SERVICE_NO_CHANGE,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL);
                    }
                }
            }
        }
    }


    // Clean up.  We'll return TRUE if a reboot is necessary, and FALSE
    // otherwise.
    //
    CloseServiceHandle (scDriver);
    CloseServiceHandle (scManager);
    return rc;
}


void ConfigureDriver (HWND hDlg, LPTSTR pszName)
{
    PIDRIVER  pid;
    HANDLE    hDriver;
    BOOL      fShowTrayVol;
    BOOL      fRestartDialog = FALSE;

    if ((pid = FindIDriverByName (pszName)) == NULL)
        return;

    fShowTrayVol = GetTrayVolumeEnabled();
    if (fShowTrayVol)
        SetTrayVolumeEnabled(FALSE);

    if ((hDriver = OpenDriver (pid->wszAlias, pid->wszSection, 0L)) == 0)
    {
        OpenDriverError(hDlg, pid->szDesc, pid->szFile);
    }
    else
    {
        DWORD dwStatus = GetDriverStatus (pid);
        BOOL fHadService = IsFlagSet (dwStatus, dwStatusSvcSTARTED) &&
                           IsFlagSet (dwStatus, dwStatusHASSERVICE);

        DRVCONFIGINFO   DrvConfigInfo;
        InitDrvConfigInfo(&DrvConfigInfo, pid);
        if ((SendDriverMessage(
                 hDriver,
                 DRV_CONFIGURE,
                 (LONG_PTR)hDlg,
                 (LONG_PTR)(LPDRVCONFIGINFO)&DrvConfigInfo) ==
            DRVCNF_RESTART))
        {
            iRestartMessage = 0;
            fRestartDialog = TRUE;
        }
        CloseDriver(hDriver, 0L, 0L);

        // If there was a functioning kernel-mode service in place before the
        // config dialog was presented, then we should verify that there is
        // still one in place now.  See FixDriverService() for details.
        //
        if (fHadService)
        {
            dwStatus = GetDriverStatus (pid);

            if (!IsFlagSet (dwStatus, dwStatusSvcSTARTED) ||
                !IsFlagSet (dwStatus, dwStatusHASSERVICE))
            {
                if (FixDriverService (pid))
                {
                    iRestartMessage = IDS_RESTART_NOSOUND;
                    fRestartDialog = TRUE;
                }
            }
        }
    }


    if (fShowTrayVol)
        SetTrayVolumeEnabled(TRUE);

    if (fRestartDialog)
    {
        DialogBox(myInstance,MAKEINTRESOURCE(DLG_RESTART),hDlg,RestartDlg);
    }
}


BOOL fDeviceHasMixers (LPTSTR pszName)
{
    HKEY  hk;
    UINT  ii;
    BOOL  rc = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_DRIVERS32, &hk))
    {
        return FALSE;
    }

    for (ii = 0; ; ++ii)
    {
        TCHAR  szLHS[ cchRESOURCE ];
        TCHAR  szRHS[ cchRESOURCE ];
        DWORD  dw1;
        DWORD  dw2;
        DWORD  dw3;

        dw1 = cchRESOURCE;
        dw3 = cchRESOURCE;
        if (RegEnumValue (hk, ii,  szLHS, &dw1,
                          0, &dw2, (LPBYTE)szRHS, &dw3) != ERROR_SUCCESS)
        {
            break;
        }

        if ( (GuessDriverClassFromAlias (szLHS) == dcMIXER) &&
             (!FileNameCmp (pszName, szRHS)) )
        {
            rc = TRUE;
            break;
        }
    }

    RegCloseKey (hk);
    return rc;
}
#endif // FIX_BUG_15451


TCHAR c_tszControlExeS[] = TEXT("control.exe %s");

BOOL RunJoyControlPanel(void)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR tsz[MAX_PATH];
    BOOL  fRtn;

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    wsprintf(tsz, c_tszControlExeS, TEXT("joy.cpl"));
    if (CreateProcess(0, tsz, 0, 0, 0, 0, 0, 0, &si, &pi)) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    fRtn = TRUE;
    } else {
        fRtn = FALSE;
    }

    return fRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\draw.h ===
/*
 **************************************************************************
 *	 
 *	 draw.h header file
 *
 * 
 *
 ***************************************************************************
 */

#include <mmsystem.h>

// Function Prototypes

LRESULT PASCAL			dfDispFrameWndFn(HWND,UINT,WPARAM,LPARAM);
BOOL PASCAL			RegSndCntrlClass(LPCTSTR);
BOOL				dfDrawRect(HDC, RECT);
BOOL                DIBInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi);
HPALETTE            CreateBIPalette(LPBITMAPINFOHEADER lpbi);
WORD                PaletteSize(VOID FAR * pv);
WORD				NumDIBColors (VOID FAR * pv);
WORD        WINAPI  bmfGetNumDIBs(LPTSTR lpszFile);
WORD        WINAPI  bmfNumDIBColors(HANDLE hDib);
HPALETTE    WINAPI  bmfCreateDIBPalette(HANDLE hDib);
HANDLE      WINAPI  bmfDIBFromBitmap(HBITMAP hBmp, DWORD biStyle,
                                     WORD biBits,HPALETTE hPal);
HBITMAP     WINAPI  bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal);
HBITMAP     WINAPI  bmfBitmapFromIcon (HICON hIcon, DWORD dwColor);
BOOL        WINAPI  bmfDrawBitmap(HDC hdc, int xpos, int ypos,
                                  HBITMAP hBmp, DWORD rop);
DWORD       WINAPI  bmfDIBSize(HANDLE hDIB);
BOOL        WINAPI  bmfDrawBitmapSize (HDC hdc, int xpos, int ypos,
                    int xSize, int ySize, HBITMAP hBmp, DWORD rop);

// Defines

#define DF_DISP_EXTRA       8
#define DF_GET_BMPHANDLE    (HBITMAP)(GetWindowLongPtr(hWnd, 0))
#define DF_SET_BMPHANDLE(x) (SetWindowLongPtr(hWnd, 0, (LONG_PTR)(x)))
#ifndef _WIN64
#define DF_GET_BMPPAL       (HPALETTE)(GetWindowLong(hWnd, 4))
#define DF_SET_BMPPAL(x)    (SetWindowLong(hWnd, 4, (LONG)(x)))
#else
#define DF_GET_BMPPAL       (HPALETTE)(GetWindowLongPtr(hWnd, sizeof(UINT_PTR)))
#define DF_SET_BMPPAL(x)    (SetWindowLongPtr(hWnd, sizeof(UINT_PTR), (LONG_PTR)(x)))
#endif

/* Help Macros */
#define DF_MID(x,y)         (((x)+(y))/2)

#define DISPICONCLASS       TEXT("WSS_DispIcon")
#define DISPFRAMCLASS       TEXT("WSS_DispFrame")

/* Header signatutes for various resources */
#define BFT_ICON   0x4349   /* 'IC' */
#define BFT_BITMAP 0x4d42   /* 'BM' */
#define BFT_CURSOR 0x5450   /* 'PT' */

/* macro to determine if resource is a DIB */
#define ISDIB(bft) ((bft) == BFT_BITMAP)

/* Macro to align given value to the closest DWORD (unsigned long ) */
#define ALIGNULONG(i)   (((i)+3)/4*4)

/* Macro to determine to round off the given value to the closest byte */
#define WIDTHBYTES(i)   (((i)+31)/32*4)

#define PALVERSION      0x300
#define MAXPALETTE  256   /* max. # supported palette entries */


//******** DISPFRAM ********************************************************

// DispFrame Control messages.

#define DF_PM_SETBITMAP    (WM_USER+1)

/* Parent Window Message string */

#define  DF_WMDISPFRAME    TEXT("PM_DISPFRAME")

#define DISP_DIB_CHUNK  1
#define DISP_TEXT_CHUNK 2
#define LIST_INFO_CHUNK 4

#define MAXDESCSIZE         4095
#define MAXLABELSIZE        255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\dslevel.cpp ===
//--------------------------------------------------------------------------;
//
//  File: dslevel.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;


#include "mmcpl.h"

#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>

#include "utils.h"
#include "medhelp.h"
#include "dslevel.h"
#include "perfpage.h"
#include "speakers.h"

#include <initguid.h>
#include <dsound.h>
#include <dsprv.h>

#define REG_KEY_SPEAKERTYPE TEXT("Speaker Type")

typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);
typedef HRESULT (STDAPICALLTYPE *LPFNDIRECTSOUNDCREATE)(LPGUID, LPDIRECTSOUND*, IUnknown FAR *);
typedef HRESULT (STDAPICALLTYPE *LPFNDIRECTSOUNDCAPTURECREATE)(LPGUID, LPDIRECTSOUNDCAPTURE*, IUnknown FAR *);


HRESULT 
DirectSoundPrivateCreate
(
    OUT LPKSPROPERTYSET *   ppKsPropertySet
)
{
    HMODULE                 hLibDsound              = NULL;
    LPFNDLLGETCLASSOBJECT   pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;
    
    // Load dsound.dll
    hLibDsound = LoadLibrary(TEXT("dsound.dll"));

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = 
            (LPFNDLLGETCLASSOBJECT)GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Handle final success or failure
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }
    else if(pKsPropertySet)
    {
        pKsPropertySet->Release();
    }

    FreeLibrary(hLibDsound);

    return hr;
}


HRESULT 
DSGetGuidFromName
(
    IN  LPTSTR              szName, 
    IN  BOOL                fRecord, 
    OUT LPGUID              pGuid
)
{
    LPKSPROPERTYSET         pKsPropertySet  = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA 
        WaveDeviceMap;

    // Create the DirectSoundPrivate object
    hr = 
        DirectSoundPrivateCreate
        (
            &pKsPropertySet
        );

    // Attempt to map the waveIn/waveOut device string to a DirectSound device
    // GUID.
    if(SUCCEEDED(hr))
    {
        WaveDeviceMap.DeviceName = szName;
        WaveDeviceMap.DataFlow = fRecord ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice, 
                DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING, 
                NULL, 
                0, 
                &WaveDeviceMap, 
                sizeof(WaveDeviceMap), 
                NULL
            );
    }

    // Clean up
    if(pKsPropertySet)
    {
        pKsPropertySet->Release();
    }

    if(SUCCEEDED(hr))
    {
        *pGuid = WaveDeviceMap.DeviceId;
    }

    return hr;
}

HRESULT
DSSetupFunctions
(
    LPFNDIRECTSOUNDCREATE* pfnDSCreate,
    LPFNDIRECTSOUNDCAPTURECREATE* pfnDSCaptureCreate
)
{
    HMODULE                 hLibDsound              = NULL;
    HRESULT                 hr                      = DS_OK;
    
    // Load dsound.dll
    hLibDsound = LoadLibrary(TEXT("dsound.dll"));

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DirectSoundCreate
    if(SUCCEEDED(hr))
    {
        *pfnDSCreate = 
            (LPFNDIRECTSOUNDCREATE)GetProcAddress
            (
                hLibDsound, 
                "DirectSoundCreate"
            );

        if(!(*pfnDSCreate))
        {
            hr = DSERR_GENERIC;
        }
    } //end DirectSoundCreate

    // Find DirectSoundCaptureCreate
    if(SUCCEEDED(hr))
    {
        *pfnDSCaptureCreate = 
            (LPFNDIRECTSOUNDCAPTURECREATE)GetProcAddress
            (
                hLibDsound, 
                "DirectSoundCaptureCreate"
            );

        if(!(*pfnDSCaptureCreate))
        {
            hr = DSERR_GENERIC;
        }
    } //end DirectSoundCaptureCreate

    FreeLibrary(hLibDsound);

    return (hr);
}

void
DSCleanup
(
    IN  LPKSPROPERTYSET         pKsPropertySet,
    IN  LPDIRECTSOUND           pDirectSound,
    IN  LPDIRECTSOUNDCAPTURE    pDirectSoundCapture
)
{
    if(pKsPropertySet)
    {
        pKsPropertySet->Release();
    }

    if(pDirectSound)
    {
        pDirectSound->Release();
    }

    if(pDirectSoundCapture)
    {
        pDirectSoundCapture->Release();
    }
}

HRESULT
DSInitialize
(
    IN  GUID                    guid, 
    IN  BOOL                    fRecord, 
    OUT LPKSPROPERTYSET*        ppKsPropertySet,
    OUT LPLPDIRECTSOUND         ppDirectSound,
    OUT LPLPDIRECTSOUNDCAPTURE  ppDirectSoundCapture
)
{
    HRESULT                 hr;

    LPFNDIRECTSOUNDCREATE           pfnDirectSoundCreate = NULL;
    LPFNDIRECTSOUNDCAPTURECREATE    pfnDirectSoundCaptureCreate = NULL;

    // Initialize variables to return
    *ppKsPropertySet = NULL;
    *ppDirectSound = NULL;
    *ppDirectSoundCapture = NULL;

    // Find the necessary DirectSound functions
    hr = DSSetupFunctions(&pfnDirectSoundCreate, &pfnDirectSoundCaptureCreate);

    if (FAILED(hr))
    {
        return (hr);
    }

    // Create the DirectSound object
    if(fRecord)
    {
        hr = 
            pfnDirectSoundCaptureCreate
            (
                &guid, 
                ppDirectSoundCapture, 
                NULL
            );
    }
    else
    {
        hr = 
            pfnDirectSoundCreate
            (
                &guid, 
                ppDirectSound, 
                NULL
            );
    }
    
    // Create the DirectSoundPrivate object
    if(SUCCEEDED(hr))
    {
        hr = 
            DirectSoundPrivateCreate
            (
                ppKsPropertySet
            );
    }

    // Clean up
    if(FAILED(hr))
    {
        DSCleanup
        (
            *ppKsPropertySet,
            *ppDirectSound,
            *ppDirectSoundCapture
        );
        *ppKsPropertySet = NULL;
        *ppDirectSound = NULL;
        *ppDirectSoundCapture = NULL;
    }

    return hr;
}

HRESULT
DSGetAcceleration
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPDWORD             pdwHWLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   
        BasicAcceleration;
    
    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        BasicAcceleration.DeviceId = guid;

        // Get the default acceleration level
        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundBasicAcceleration, 
                DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT, 
                NULL, 
                0, 
                &BasicAcceleration, 
                sizeof(BasicAcceleration), 
                NULL
            );

        if (SUCCEEDED(hr))
        {
            gAudData.dwDefaultHWLevel = BasicAcceleration.Level;
        }
        
        // Get the basic HW acceleration level.  This property will return
        // S_FALSE if no error occurred, but the registry value did not exist.
        

        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundBasicAcceleration, 
                DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
                NULL, 
                0, 
                &BasicAcceleration, 
                sizeof(BasicAcceleration), 
                NULL
            );

        if(SUCCEEDED(hr))
        {
            *pdwHWLevel = BasicAcceleration.Level;
        }
        else
        {
            *pdwHWLevel = gAudData.dwDefaultHWLevel;
        }
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSGetSrcQuality
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPDWORD             pdwSRCLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA                 
        SrcQuality;

    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        // Get the mixer SRC quality.  This property will return S_FALSE 
        // if no error occurred, but the registry value did not exist.
        SrcQuality.DeviceId = guid;
        
        hr = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundMixer, 
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                NULL, 
                0, 
                &SrcQuality, 
                sizeof(SrcQuality), 
                NULL
            );

        if(SUCCEEDED(hr))
        {
            // The CPL only uses the 3 highest of 4 possible SRC values
            *pdwSRCLevel = SrcQuality.Quality;

            if(*pdwSRCLevel > 0)
            {
                (*pdwSRCLevel)--;
            }
        }
        else
        {
            *pdwSRCLevel = DEFAULT_SRC_LEVEL;
        }
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSGetSpeakerConfigType
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPDWORD             pdwSpeakerConfig,
    OUT LPDWORD             pdwSpeakerType
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr                  = DS_OK;
    HRESULT                 hrSpeakerType;

    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA
        SpeakerType;

    // Can't get the speaker type if we're recording
    if(fRecord)
    {
        hr = E_INVALIDARG;
    }

    // Find the necessary DirectSound functions
    if(SUCCEEDED(hr))
    {
        hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );
    }

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        // Get the speaker config
        hr = 
            pDirectSound->GetSpeakerConfig
            (
                pdwSpeakerConfig
            );

        if(FAILED(hr))
        {
            *pdwSpeakerConfig = DSSPEAKER_STEREO;
        }

        // Get the speaker type.  This property will return failure
        // if the registry value doesn't exist.
        SpeakerType.DeviceId = guid;
        SpeakerType.SubKeyName = REG_KEY_SPEAKERTYPE;
        SpeakerType.ValueName = REG_KEY_SPEAKERTYPE;
        SpeakerType.RegistryDataType = REG_DWORD;
        SpeakerType.Data = pdwSpeakerType;
        SpeakerType.DataSize = sizeof(pdwSpeakerType);

        hrSpeakerType = 
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundPersistentData, 
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA, 
                NULL, 
                0, 
                &SpeakerType, 
                sizeof(SpeakerType), 
                NULL
            );

        if(FAILED(hrSpeakerType))
        {
            *pdwSpeakerType = SPEAKERS_DEFAULT_TYPE;
        }
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT 
DSGetCplValues
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    OUT LPCPLDATA           pData
)
{
    HRESULT                 hr;

    // Get the basic HW acceleration level.
    pData->dwHWLevel = gAudData.dwDefaultHWLevel;
    hr = DSGetAcceleration
    (
        guid,
        fRecord,
        &pData->dwHWLevel
    );

    // Get the mixer SRC quality.
    pData->dwSRCLevel = DEFAULT_SRC_LEVEL;
    hr = DSGetSrcQuality
    (
        guid,
        fRecord,
        &pData->dwSRCLevel
    );

    // Get playback-specific settings
    if(!fRecord)
    {
        // Get the speaker config
        pData->dwSpeakerConfig = DSSPEAKER_STEREO;
        pData->dwSpeakerType = SPEAKERS_DEFAULT_TYPE;
        hr = DSGetSpeakerConfigType
        (
            guid,
            fRecord,
            &pData->dwSpeakerConfig,
            &pData->dwSpeakerType
        );
    }

    return DS_OK;
}


HRESULT
DSSetAcceleration
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  DWORD               dwHWLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   
        BasicAcceleration;
    
    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        BasicAcceleration.DeviceId = guid;
        BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL)dwHWLevel;

        // Set the basic HW acceleration level
        hr = 
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundBasicAcceleration, 
                DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
                NULL, 
                0, 
                &BasicAcceleration, 
                sizeof(BasicAcceleration)
            );
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSSetSrcQuality
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  DWORD               dwSRCLevel
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr;

    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA                 
        SrcQuality;
    
    // Find the necessary DirectSound functions
    hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );

    // Get properties for this device
    if(SUCCEEDED(hr))
    {
        SrcQuality.DeviceId = guid;

        // The CPL only uses the 3 highest of 4 possible SRC values
        SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)(dwSRCLevel + 1);

        // Set the mixer SRC quality
        hr = 
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundMixer, 
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                NULL, 
                0, 
                &SrcQuality, 
                sizeof(SrcQuality)
            );
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT
DSSetSpeakerConfigType
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  DWORD               dwSpeakerConfig,
    IN  DWORD               dwSpeakerType
)
{
    LPKSPROPERTYSET         pKsPropertySet      = NULL;
    LPDIRECTSOUND           pDirectSound        = NULL;
    LPDIRECTSOUNDCAPTURE    pDirectSoundCapture = NULL;
    HRESULT                 hr                  = DS_OK;

    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA
        SpeakerType;

    // Can't set the speaker type if we're recording
    if(fRecord)
    {
        hr = E_INVALIDARG;
    }

    // Find the necessary DirectSound functions
    if(SUCCEEDED(hr))
    {
        hr = DSInitialize(guid, fRecord, &pKsPropertySet, &pDirectSound, &pDirectSoundCapture );
    }

    // Set the speaker config
    if(SUCCEEDED(hr))
    {
        hr = 
            pDirectSound->SetSpeakerConfig
            (
                dwSpeakerConfig
            );
    }

    // Set the speaker type
    if(SUCCEEDED(hr))
    {
        SpeakerType.DeviceId = guid;
        SpeakerType.SubKeyName = REG_KEY_SPEAKERTYPE;
        SpeakerType.ValueName = REG_KEY_SPEAKERTYPE;
        SpeakerType.RegistryDataType = REG_DWORD;
        SpeakerType.Data = &dwSpeakerType;
        SpeakerType.DataSize = sizeof(dwSpeakerType);

        hr = 
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundPersistentData, 
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA, 
                NULL, 
                0, 
                &SpeakerType, 
                sizeof(SpeakerType)
            );
    }

    // Clean up
    DSCleanup
    (
        pKsPropertySet,
        pDirectSound,
        pDirectSoundCapture
    );

    return hr;
}

HRESULT 
DSSetCplValues
(
    IN  GUID                guid, 
    IN  BOOL                fRecord, 
    IN  const LPCPLDATA     pData
)
{
    HRESULT                 hr;

    // Set the basic HW acceleration level
    hr =
        DSSetAcceleration
        (
            guid,
            fRecord,
            pData->dwHWLevel
        );

    // Set the mixer SRC quality
    if(SUCCEEDED(hr))
    {
        hr =
            DSSetSrcQuality
            (
                guid,
                fRecord,
                pData->dwSRCLevel // +1 is done in DSSetSrcQuality
            );
    }

    // Set the speaker config
    if(SUCCEEDED(hr) && !fRecord)
    {
        DSSetSpeakerConfigType
        (
            guid,
            fRecord,
            pData->dwSpeakerConfig,
            pData->dwSpeakerType
        );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\filecopy.h ===
#ifndef FILECOPY_H
#define FILECOPY_H

BOOL GetInstallPath(LPTSTR szDirOfSrc);
void wsStartWait();
void wsEndWait();
int fDialog(int id, HWND hwnd, DLGPROC fpfn);
UINT wsCopyError(int n, LPTSTR szFile);
UINT wsInsertDisk(LPTSTR Disk, LPTSTR szSrcPath);
INT_PTR wsDiskDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);
UINT wsCopySingleStatus(int msg, DWORD_PTR n, LPTSTR szFile);
INT_PTR wsExistDlg(HWND hDlg, UINT uiMessage, UINT wParam, LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\helpid.h ===
#include "medhelp.h"

#define IDH_MIDI_DEVICE 	2410
#define IDH_MIDI_ENABLED	2411
#define IDH_MIDI_PORT		2412
#define IDH_CONFIGMIDI_POWER	2415
#define IDH_CONFIGMIDI_CHANNELS 2416
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\gfxui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  gfxui.h
//
//      This file defines the functions that are used by the Global
//      Effects (GFX) page to drive manipulate the effects for a 
//      mixer.
//
//  History:
//      10 June 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

//=============================================================================
//                            Include files
//=============================================================================
#include <mmsysp.h> // Middle Layer

// GFXUI element status flags
#define GFX_DEFAULT  0X00000000
#define GFX_CREATED  0X00000001 // Id, Order, & Type are valid
#define GFX_ADD      0X00000002

typedef struct _GFXUI GFXUI;
typedef GFXUI* PGFXUI;

typedef struct _GFXUI
{
	PWSTR  pszName;
	PWSTR  pszFactoryDi;
    DWORD  Id;
    DWORD  Type; 
    DWORD  Order;
    DWORD  nFlags;
    CLSID  clsidUI;
    PGFXUI pNext;
} **PPGFXUI;

typedef struct 
{
	DWORD  dwType;
    PWSTR  pszZoneDi;
    PGFXUI puiList;
} GFXUILIST, *PGFXUILIST, **PPGFXUILIST;


//
// API Prototypes
//

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// Interface
HRESULT GFXUI_CreateList (DWORD dwMixID, DWORD dwType, BOOL fAll, PPGFXUILIST ppList);
BOOL    GFXUI_CheckDevice (DWORD dwMixID, DWORD dwType);
void    GFXUI_FreeList (PPGFXUILIST ppList);
HRESULT GFXUI_Properties (PGFXUI puiGFX, HWND hWndOwner);
HRESULT GFXUI_CreateAddGFX (PPGFXUI ppuiGFXAdd, PGFXUI puiGFXSource);
HRESULT GFXUI_Apply (PPGFXUILIST ppListApply, PPGFXUI ppuiListDelete);

#ifdef __cplusplus
} // extern "C"
#endif

// Helpers
BOOL GFXUI_CanShowProperties (PGFXUI puiGFX);


//
// Local Function Prototypes
//
HRESULT InitList (DWORD dwMixID, DWORD dwType, PPGFXUILIST ppList);
HRESULT AddNode (PCWSTR pszGfxFactoryDi, DWORD Id, REFCLSID rclsid, DWORD Type, DWORD Order, DWORD nFlags, PPGFXUILIST ppList);
HRESULT AddFactoryNode (PCWSTR pszGfxFactoryDi, PPGFXUILIST ppList);
void    FreeNode (PPGFXUI ppNode);
void    FreeListNodes (PPGFXUI ppuiList);
HRESULT AttachNode (PPGFXUILIST ppList, PGFXUI pNode);
HRESULT CreateNode (PCWSTR pszName, PCWSTR pszGfxFactoryDi, PPGFXUI ppNode);
HRESULT GetFriendlyName (PCWSTR pszGfxFactoryDi, PWSTR* ppszName);
HKEY    OpenGfxRegKey (PCWSTR pszGfxFactoryDi, REGSAM sam);
UINT    GetListSize (PGFXUI puiList);
PTCHAR  GetInterfaceName (DWORD dwMixerID);
// Callback
LONG    GFXEnum (PVOID Context, DWORD Id, PCWSTR GfxFactoryDi, REFCLSID rclsid, DWORD Type, DWORD Order);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\gfxui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  gfxui.c
//
//      This file defines the functions that are used by the Global
//      Effects (GFX) page to drive manipulate the effects for a 
//      mixer.
//
//  History:
//      10 June 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include <windows.h>
#include <windowsx.h>
#include "mmcpl.h"
#include <mmddkp.h>
#include <olectl.h>
#include <ocidl.h>
#include "gfxui.h"

#define ADDGFX
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")


//
// IDataObject Implementation
//
class GFXDataObject : public IDataObject
{
public:
    GFXDataObject (DWORD dwGfxID) { m_cRef = 1; m_dwGfxID = dwGfxID; }

    // IUnknown interface
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef ()  { return ++m_cRef; }
    STDMETHODIMP_(ULONG) Release () { return --m_cRef; }

	STDMETHODIMP GetData (FORMATETC * pformatetcIn, STGMEDIUM * pmedium);
    STDMETHODIMP GetDataHere (FORMATETC * pformatetc, STGMEDIUM *pmedium) { return E_NOTIMPL; }
	STDMETHODIMP QueryGetData (FORMATETC * pformatetc) { return E_NOTIMPL; }
	STDMETHODIMP GetCanonicalFormatEtc (FORMATETC * pformatetcIn, FORMATETC * pFormatetcOut) { return E_NOTIMPL; }
	STDMETHODIMP SetData (FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease) { return E_NOTIMPL; }
	STDMETHODIMP EnumFormatEtc (DWORD dwDirection, IEnumFORMATETC ** ppenumFormatEtc ) { return E_NOTIMPL; }
	STDMETHODIMP DAdvise (FORMATETC * pformatetc, DWORD advf, IAdviseSink* pAdvSnk, DWORD * pdwConnection) { return E_NOTIMPL; }
	STDMETHODIMP DUnadvise (DWORD dwConnection) { return E_NOTIMPL; }
	STDMETHODIMP EnumDAdvise (IEnumSTATDATA ** ppenumAdvise) { return E_NOTIMPL; }

private:
	UINT  m_cRef;
    DWORD m_dwGfxID;

};

STDMETHODIMP GFXDataObject::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    
    if (!ppvObj)
        return E_POINTER;

	*ppvObj = NULL;
	if (IsEqualIID(riid,IID_IDataObject) ||
		IsEqualIID(riid,IID_IUnknown))
		*ppvObj = (IDataObject *) this;
	else
	    return E_NOINTERFACE;

	((IUnknown *) *ppvObj) -> AddRef ();

	return S_OK;

}

STDMETHODIMP GFXDataObject::GetData (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)							// @parm Storage to be created.
{

    HRESULT hr = E_INVALIDARG;

    if (pformatetc && pmedium && TYMED_HGLOBAL == pformatetc -> tymed)
    {
        HANDLE hGfx = NULL;

#ifdef ADDGFX
        hr = gfxOpenGfx (m_dwGfxID, &hGfx);
#endif // ADDGFX

        if (SUCCEEDED (hr))
        {
            pmedium -> tymed = TYMED_HGLOBAL;
	        pmedium -> pUnkForRelease = NULL;	
	        pmedium -> hGlobal = hGfx;
        }
    }

    return hr;

}



HRESULT InitList (DWORD dwMixID, DWORD dwType, PPGFXUILIST ppList)
{

    HRESULT hr = E_INVALIDARG;

    if (ppList)
    {
        PGFXUILIST pList = (PGFXUILIST) LocalAlloc (LPTR, sizeof (GFXUILIST));
        *ppList = NULL; // Init pointer

        if (pList)
        {
            hr = S_OK;
	        pList -> dwType    = dwType;
            pList -> puiList   = NULL;
#ifdef UNICODE
            pList -> pszZoneDi = (PWSTR) GetInterfaceName (dwMixID);
#else
            pList -> pszZoneDi = NULL; // This should not happen
#endif
            if (pList -> pszZoneDi)
            {
                // Return new list
                *ppList = pList;
            }
            else
            {
                // Error!
                LocalFree (pList);
                hr = E_OUTOFMEMORY;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;

}


void GFXUI_FreeList (PPGFXUILIST ppList)
{
    
    if (ppList)
    {
        PGFXUILIST pList = *ppList;

        if (pList)
        {
            // Free Zone
            if (pList -> pszZoneDi)
                GlobalFreePtr (pList -> pszZoneDi);
            pList -> pszZoneDi = NULL;

            // Free GFX List
            FreeListNodes (&(pList -> puiList));

            // Free list
            LocalFree (pList);
            *ppList = NULL;
        }
    }
}


void FreeListNodes (PPGFXUI ppuiList)
{

    if (ppuiList)
    {
        PGFXUI pNodeDelete;
        PGFXUI puiList = *ppuiList;

        // Free list nodes
        while (puiList)
        {
            pNodeDelete = puiList;
            puiList = puiList -> pNext;
            FreeNode (&pNodeDelete);
        }

        *ppuiList = NULL;
    }
}


void FreeNode (PPGFXUI ppNode)
{

    if (ppNode && *ppNode)
    {
        PGFXUI pNode = *ppNode;

        // Free the strings
        if (pNode -> pszName)
            LocalFree (pNode -> pszName);
        if (pNode -> pszFactoryDi)
            LocalFree (pNode -> pszFactoryDi);

        // Free the node
        LocalFree (pNode);
        *ppNode = NULL;
    }
}


HKEY OpenGfxRegKey (PCWSTR pszGfxFactoryDi, REGSAM sam)
{

    HKEY hkeyGfx = NULL;

    if (pszGfxFactoryDi)
    {
        HDEVINFO DeviceInfoSet = SetupDiCreateDeviceInfoList (NULL, NULL); 
        
        if (INVALID_HANDLE_VALUE != DeviceInfoSet)
        {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
            DeviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface (DeviceInfoSet, pszGfxFactoryDi, 
                                            0, &DeviceInterfaceData))
            {
                 hkeyGfx = SetupDiOpenDeviceInterfaceRegKey (
                                DeviceInfoSet, &DeviceInterfaceData,
                                0, sam);
            }
            SetupDiDestroyDeviceInfoList (DeviceInfoSet);
        }
    }

    return hkeyGfx;

}


HRESULT GetFriendlyName (PCWSTR pszGfxFactoryDi, PWSTR* ppszName)
{

    HRESULT hr = E_INVALIDARG;
    HKEY hkeyGfx = NULL;

    // Check parameters
    if (ppszName && pszGfxFactoryDi)
    {
        HKEY hkeyGfx = OpenGfxRegKey (pszGfxFactoryDi, KEY_READ);
        *ppszName = NULL;

        if (hkeyGfx)
        {
            WCHAR szBuffer[MAX_PATH];
            DWORD dwType = REG_SZ;
            DWORD cb     = sizeof (szBuffer) / sizeof (szBuffer[0]);

            hr = S_OK;

            if (ERROR_SUCCESS == RegQueryValueEx (hkeyGfx, REGSTR_VAL_FRIENDLYNAME, NULL, &dwType, (LPBYTE)szBuffer, &cb))
            {
                *ppszName = (PWSTR) LocalAlloc (LPTR, lstrlen (szBuffer)*2+2);
                if (*ppszName)
                    wcscpy (*ppszName, szBuffer);
                else
                    hr = E_OUTOFMEMORY;
            }
            else
                hr = REGDB_E_READREGDB;

            RegCloseKey (hkeyGfx);
        }
    }

    return hr;

}


HRESULT AddFactoryNode (PCWSTR pszGfxFactoryDi, PPGFXUILIST ppList)
{
    return AddNode (pszGfxFactoryDi, 0, GUID_NULL, 0, 0, 0, ppList);
}


HRESULT AddNode (PCWSTR pszGfxFactoryDi, DWORD Id, REFCLSID rclsid, DWORD Type, 
                 DWORD Order, DWORD nFlags, PPGFXUILIST ppList)
{

    PGFXUI pNode = NULL;
    HRESULT hr = S_OK;

    // Check parameters
    if (!ppList || !(*ppList) || !pszGfxFactoryDi)
        return E_INVALIDARG;

    // Create node
    if (SUCCEEDED (hr = CreateNode (NULL, pszGfxFactoryDi, &pNode)))
    {
        if (pNode)
        {
            // Initilize the rest of the values
            pNode -> Id      = Id; 
            pNode -> Type    = Type;
            pNode -> Order   = Order;
            pNode -> nFlags  = nFlags;
            pNode -> clsidUI = rclsid;

            if (FAILED (hr = AttachNode (ppList, pNode)))
                FreeNode (&pNode);
        }
        else
            hr = E_UNEXPECTED;

    }

    return hr;

}


// Note: This function always adds the node to the list IN ORDER
//       IFF (pNode -> nFlags & GFX_CREATED).
HRESULT AttachNode (PPGFXUILIST ppList, PGFXUI pNode)
{

    HRESULT hr = E_INVALIDARG;

    // Check parameters
    if (ppList && (*ppList) && pNode)
    {
        PGFXUI puiList = (*ppList) -> puiList;
        hr = S_OK;

        // Make sure our next pointer starts out null..
        pNode -> pNext = NULL;

        if (puiList)
        {
            if (!(pNode -> nFlags & GFX_CREATED) ||
                (puiList -> Order >= pNode -> Order))
            {
                // Order is not available, just stick it on the front or
                // the order happens to put the node at the front.
                pNode -> pNext = puiList;
                puiList = pNode;
            }
            else
            {
                PGFXUI pSearch = puiList;
            
                if (!(puiList -> pNext))
                {
                    // One element list. We know the new node doesn't belong
                    // at the head of the list, so it is behind.
                    puiList -> pNext = pNode;
                } else {

                    while (pSearch -> pNext)
                    {
                        if (!(pSearch -> pNext -> nFlags & GFX_CREATED))
                        {
                            hr = E_INVALIDARG;
                            break; // Cannot mix list types
                        }
    
                        if (pSearch -> pNext -> Order >= pNode -> Order)
                        {
                            // We found the insertion point!
                            pNode -> pNext = pSearch -> pNext;
                            pSearch -> pNext = pNode;
                            break;
                        }
    
                        if (!(pSearch -> pNext -> pNext))
                        {
                            // At end of list, attach node to end
                            pSearch -> pNext -> pNext = pNode;
                            break;
                        }
    
                        // Move to next element
                        pSearch = pSearch -> pNext;
                    }
                    
                }
            }
        }
        else
        {
            // First element of the list
            puiList = pNode;
        }

        if (SUCCEEDED (hr))
        {
            // Ensure we pass back the correct list pointer
            (*ppList) -> puiList = puiList;
        }
    }

    return hr;

}


LONG GFXEnum (PVOID Context, DWORD Id, PCWSTR GfxFactoryDi, REFCLSID rclsid, DWORD Type, DWORD Order)
{

    PGFXUILIST pList = (PGFXUILIST) Context;
    HRESULT hr = E_INVALIDARG;

    if (pList)
    {
        if (Type == pList->dwType)
        {
            if (FAILED (hr = AddNode (GfxFactoryDi, Id, rclsid, Type, Order, GFX_CREATED, &pList)))
            {
                // Error, free the list
                GFXUI_FreeList (&pList);
                Context = NULL;
            }
        }
        else hr = NOERROR;
    }

    return hr;

}


BOOL GFXUI_CheckDevice (DWORD dwMixID, DWORD dwType)
{

    HRESULT     hr = S_OK;
    BOOL        fRet = FALSE;
    PGFXUILIST  pList = NULL;
    
    if (SUCCEEDED (hr = InitList (dwMixID, dwType, &pList)))
    {
        if (pList && pList -> pszZoneDi)
        {
            PDEVICEINTERFACELIST pdiList = NULL;                    
            LONG                 lResult = NO_ERROR;
                
            lResult = gfxCreateGfxFactoriesList (pList -> pszZoneDi, &pdiList);

            if ((lResult == NO_ERROR) && pdiList)
            {
                fRet = TRUE;
                gfxDestroyDeviceInterfaceList (pdiList);
            }
            
            GFXUI_FreeList (&pList);
        }

    }
    return fRet;
}


HRESULT GFXUI_CreateList (DWORD dwMixID, DWORD dwType, BOOL fAll, PPGFXUILIST ppList)
{

    HRESULT hr = E_INVALIDARG;
    
    if (ppList)
    {
        hr = S_OK;

        if (SUCCEEDED (hr = InitList (dwMixID, dwType, ppList)))
        {
            if (*ppList && (*ppList) -> pszZoneDi)
            {
                if (!fAll)
                {
                    hr = gfxEnumerateGfxs ((*ppList) -> pszZoneDi, GFXEnum, (*ppList));
                }
                else
                {
                    PDEVICEINTERFACELIST pdiList = NULL;                    

                    hr = gfxCreateGfxFactoriesList ((*ppList) -> pszZoneDi, &pdiList);

                    if (SUCCEEDED (hr) && pdiList)
                    {
                        LONG lIndex;
                    
                        for (lIndex = 0; lIndex < pdiList -> Count; lIndex++)
                        {
                            hr = AddFactoryNode ((pdiList -> DeviceInterface)[lIndex], ppList);
                            if (FAILED (hr))
                            {
                                GFXUI_FreeList (ppList);
                                break;
                            }
                        }

                        gfxDestroyDeviceInterfaceList (pdiList);
                    }
                    else
                    {
                        GFXUI_FreeList (ppList);
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
                hr = E_UNEXPECTED;
        }

    }

    return hr;

}


HRESULT GFXUI_Properties (PGFXUI puiGFX, HWND hWndOwner)
{

    HRESULT hr = E_INVALIDARG;

    if (puiGFX && GFXUI_CanShowProperties (puiGFX) && IsWindow (hWndOwner))
    {
        ISpecifyPropertyPages* pISpecifyPropertyPages = NULL;

        // Get the Vendor UI Property Pages Interface
        hr = CoCreateInstance (puiGFX -> clsidUI, NULL, CLSCTX_INPROC_SERVER, IID_ISpecifyPropertyPages, (void**)&pISpecifyPropertyPages);
        if (SUCCEEDED (hr) && !pISpecifyPropertyPages)
            hr = E_UNEXPECTED;

        if (SUCCEEDED (hr))
        {
            CAUUID Pages;
            ZeroMemory (&Pages, sizeof (Pages));

            // Get the VendorUI Property Page CLSID's
            hr = pISpecifyPropertyPages -> GetPages (&Pages);
            if (SUCCEEDED (hr) && (Pages.cElems == 0 || !Pages.pElems))
                hr = E_UNEXPECTED;

            if (SUCCEEDED (hr))
            {
                RECT rcWindow;

                if (GetWindowRect (hWndOwner, &rcWindow))
                {
                    TCHAR szCaption[MAX_PATH];
                    GFXDataObject DataObject (puiGFX -> Id);
                    IUnknown* punkDataObject = &DataObject;

                    // Load the VendorUI caption
                    LoadString (ghInstance, IDS_EFFECTS_PROPERTY_CAPTION, szCaption, sizeof (szCaption)/sizeof(TCHAR));

                    // Bring up the Vendor UI
                    hr = OleCreatePropertyFrame (hWndOwner, rcWindow.left + 10, rcWindow.top + 10,
                                                 szCaption, 1, &punkDataObject, Pages.cElems, 
                                                 Pages.pElems, GetSystemDefaultLangID (), 
                                                 0, NULL);

                }
                else
                    hr = E_FAIL;

                CoTaskMemFree (Pages.pElems);
            }

            pISpecifyPropertyPages -> Release ();
        }
    }

    return hr;

}


UINT GetListSize (PGFXUI puiList)
{

    UINT uiSize = 0;
    PGFXUI puiListSeek = puiList;

    while (puiListSeek)
    {
        puiListSeek = puiListSeek -> pNext;
        uiSize++;
    }

    return uiSize;

}


HRESULT GFXUI_Apply (PPGFXUILIST ppListApply, PPGFXUI ppuiListDelete)
{

    HRESULT hr = E_INVALIDARG;
    PGFXUILIST pListApply  = (ppListApply  ? *ppListApply    : NULL);
    PGFXUI puiListDelete = (ppuiListDelete ? *ppuiListDelete : NULL);

    if ((pListApply && pListApply -> puiList) || puiListDelete)
    {

        PGFXREMOVEREQUEST paGfxRemoveRequests = NULL;
        PGFXMODIFYREQUEST paGfxModifyRequests = NULL;
        PGFXADDREQUEST    paGfxAddRequests    = NULL;
        ULONG cGfxRemoveRequests = 0;
	    ULONG cGfxModifyRequests = 0;
	    ULONG cGfxAddRequests    = 0;
        ULONG cApplyList = GetListSize (pListApply ? pListApply -> puiList : NULL);
        ULONG cDeleteList = GetListSize (puiListDelete);
        PGFXUI puiListSeek = NULL;

        hr = S_OK;

        // This function needs to create:
        //      - Deleted Array of GFXREMOVEREQUEST's
        //      - Modify Array of GFXMODIFYREQUEST's
        //      - Add Array of GFXADDREQUEST's
        // 
        // The deleted array is fairly easy, just pull out the 
        // marked ones. With the remaining, we need to loop through
        // them comparing order and create modify records as needed
        // to modify their order (except for the add records where
        // we must save the nessary order in the add request array).
        // Then we create the add array (perhaps with the modify array)
        // and fill in everything else (other than order).
        //
        // Then call GFX_BatchChange().
        //
        // Afterword, we need to update our list accordingly (i.e. delete 
        // nodes, update order, etc).

        // Create our parameters
        // Note: These buffers are really upper bounds on the memory we will need.
        //       We will count the actual requests we make and pass that value to
        //       the GFX function call.
        if (0 < cDeleteList)
        {
            paGfxRemoveRequests = (PGFXREMOVEREQUEST) LocalAlloc (LPTR, sizeof (*paGfxRemoveRequests) * cDeleteList);
            if (!paGfxRemoveRequests)
                hr = E_OUTOFMEMORY;
        }
        if (0 < cApplyList)
        {
            paGfxModifyRequests = (PGFXMODIFYREQUEST) LocalAlloc (LPTR, sizeof (*paGfxModifyRequests) * cApplyList);
            paGfxAddRequests    = (PGFXADDREQUEST) LocalAlloc (LPTR, sizeof (*paGfxAddRequests) * cApplyList);
            if (!paGfxModifyRequests || !paGfxAddRequests)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED (hr))
        {
            UINT uiIndx;
            DWORD dwOrder = 0;

            // Create the remove parameter
            puiListSeek = puiListDelete;
            for (uiIndx = 0; uiIndx < cDeleteList; uiIndx++)
            {
                // Make sure this is created before we ask to delete it.
                // (It may be an AddNode that was deleted before creation).
                if (puiListSeek -> nFlags & GFX_CREATED)
                {
                    (paGfxRemoveRequests + cGfxRemoveRequests) -> IdToRemove = puiListSeek -> Id;
                    (paGfxRemoveRequests + cGfxRemoveRequests) -> Error = S_OK;
                    cGfxRemoveRequests++;
                }
                puiListSeek = puiListSeek -> pNext;
            }

            // Create the modify and add parameters
            puiListSeek = pListApply ? pListApply -> puiList : NULL;
            for (uiIndx = 0; uiIndx < cApplyList; uiIndx++)
            {
                if (puiListSeek -> nFlags & GFX_ADD)
                {
                    (paGfxAddRequests + cGfxAddRequests) -> ZoneFactoryDi = pListApply  -> pszZoneDi;
                    (paGfxAddRequests + cGfxAddRequests) -> GfxFactoryDi  = puiListSeek -> pszFactoryDi;
                    (paGfxAddRequests + cGfxAddRequests) -> Type          = pListApply  -> dwType;
                    (paGfxAddRequests + cGfxAddRequests) -> Order         = dwOrder++;
                    (paGfxAddRequests + cGfxAddRequests) -> NewId         = 0;
                    (paGfxAddRequests + cGfxAddRequests) -> Error         = S_OK;
                    cGfxAddRequests++;
                }
                else
                {
                    if (puiListSeek -> nFlags & GFX_CREATED)
                    {
                        // We only need to add modify records for GFX'es
                        // that are no longer in order.
                        if (puiListSeek -> Order < dwOrder)
                        {
                            (paGfxModifyRequests + cGfxModifyRequests) -> IdToModify = puiListSeek -> Id;
                            (paGfxModifyRequests + cGfxModifyRequests) -> NewOrder   = dwOrder++;
                            (paGfxModifyRequests + cGfxModifyRequests) -> Error      = S_OK;
                            cGfxModifyRequests++;
                        }
                        else
                            dwOrder = (puiListSeek -> Order + 1);
                    }
                    else
                    {
                        // Bogus list entry, abort everything!
                        hr = E_INVALIDARG;
                        break;
                    }
                }
                puiListSeek = puiListSeek -> pNext;
            }

            if (SUCCEEDED (hr))
            {
#ifdef ADDGFX
                hr = gfxBatchChange (paGfxRemoveRequests, cGfxRemoveRequests,
                                     paGfxModifyRequests, cGfxModifyRequests,
                                     paGfxAddRequests, cGfxAddRequests);
#endif // ADDGFX
                if (SUCCEEDED (hr))
                {
                    PGFXMODIFYREQUEST paGfxModifySeek = paGfxModifyRequests;
                    PGFXADDREQUEST    paGfxAddSeek    = paGfxAddRequests;

                    // Update the passed arrays
                    FreeListNodes (ppuiListDelete);

                    puiListSeek = pListApply ? pListApply -> puiList : NULL;
                    for (uiIndx = 0; uiIndx < cApplyList; uiIndx++)
                    {
                        // Update the list items.
                        if (puiListSeek -> nFlags & GFX_ADD)
                        {
                            // Update the newly create GFX
                            puiListSeek -> nFlags = GFX_CREATED;
                            puiListSeek -> Id     = paGfxAddSeek -> NewId;
                            puiListSeek -> Type   = paGfxAddSeek -> Type;
                            puiListSeek -> Order  = paGfxAddSeek -> Order;
                            paGfxAddSeek++;
                        }
                        else // must be (puiListSeek -> nFlags & GFX_CREATED)
                        {
                            // Update the order
                            puiListSeek -> Order = paGfxModifySeek -> NewOrder;
                            paGfxModifySeek++;
                        }
                    }
                }
            }
        }

        // Free parameters
        if (paGfxRemoveRequests)
            LocalFree (paGfxRemoveRequests);
        if (paGfxModifyRequests)
            LocalFree (paGfxModifyRequests);
        if (paGfxAddRequests)
            LocalFree (paGfxAddRequests);

    }

    return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
PTCHAR GetInterfaceName (DWORD dwMixerID)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return NULL;
		}

		mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return NULL;
		}
	}

    return szInterfaceName;
}


BOOL GFXUI_CanShowProperties (PGFXUI puiGFX)
{
    return (puiGFX && (puiGFX -> nFlags & GFX_CREATED) && (puiGFX -> clsidUI != GUID_NULL));
}


HRESULT CreateNode (PCWSTR pszName, PCWSTR pszGfxFactoryDi, PPGFXUI ppNode)
{

    HRESULT hr = E_INVALIDARG;
    
    if (ppNode)
    {
        // Create node
        PGFXUI pNode = (PGFXUI) LocalAlloc (LPTR, sizeof (GFXUI));
        hr = S_OK;

        if (pNode)
        {
            ZeroMemory (pNode, sizeof (GFXUI));

            // Create the strings
            if (pszName)
            {
                pNode -> pszName = (PWSTR) LocalAlloc (LPTR, lstrlen (pszName)*2+2);
                if (pNode -> pszName)
                    wcscpy (pNode -> pszName, pszName);
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // If there is no name, get it from the factory
                pNode -> pszName = NULL;
                if (pszGfxFactoryDi)
                    hr = GetFriendlyName (pszGfxFactoryDi, &(pNode -> pszName));
            }

            if (SUCCEEDED (hr) && pszGfxFactoryDi)
            {
                pNode -> pszFactoryDi = (PWSTR) LocalAlloc (LPTR, lstrlen (pszGfxFactoryDi)*2+2);
                if (pNode -> pszFactoryDi)
                    wcscpy (pNode -> pszFactoryDi, pszGfxFactoryDi);
                else
                    hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED (hr))
                // Return node
                *ppNode = pNode;
            else
                // Free node
                FreeNode (&pNode);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


// This function creates an "addable" GFXUI element that will be able
// to create a new GFX when you call GFXUI_Apply() with this new element
// in the list.
HRESULT GFXUI_CreateAddGFX (PPGFXUI ppuiGFXAdd, PGFXUI puiGFXSource)
{

    HRESULT hr = E_INVALIDARG;

    if (ppuiGFXAdd && puiGFXSource)
    {
        *ppuiGFXAdd = NULL;

        hr = CreateNode (puiGFXSource -> pszName, 
                         puiGFXSource -> pszFactoryDi, ppuiGFXAdd);

        if (SUCCEEDED (hr))
        {
            if (*ppuiGFXAdd)
            {
                // Indicate that this is a new 'Add' node.
                (*ppuiGFXAdd) -> nFlags = GFX_ADD;
            }
            else
                hr = E_UNEXPECTED;
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\mmsys\effects.cpp ===
/*
 ***************************************************************
 *
 *  This file contains the functions to display and submit changes 
 *     for sound effects
 *
 *  Copyright 2000, Microsoft Corporation
 *
 *  History:
 *
 *    03/2000 - tsharp (Created)
 *
 ***************************************************************
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <cpl.h>
#include <shellapi.h>
#include <ole2.h>
#include <mmddkp.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "mmcpl.h"
#include "draw.h"
#include "medhelp.h"
#include "gfxui.h"

#include <dsound.h>
#include <dsprv.h>
#include "advaudio.h"

/****************** Debug Off *********************/
//#define DEBUG
//#define _INC_MMDEBUG_CODE_ TRUE
//#include "mmdebug.h"
// End debug stuff

#define MAX_GFX_COUNT                  128    // maximum number of global effects (Gfx) processed 
#define MAX_LIST_DESC                  50     // maximum length of Gfx description in list view
#define FILLER_MSG                     257    // maximum number of Gfx applicable to the system

const static DWORD aKeyWordIds[] =
{
	IDC_EFFECT_STATIC, IDH_EFFECT_STATIC,
    IDC_TEXT_32,       NO_HELP,
	IDB_EFFECT_PROP,   IDH_EFFECT_PROP,
	0,0
};

/****************************************************************
 * Definitions
 ***************************************************************/

typedef HRESULT (WINAPI *GETCLASSOBJECTFUNC)( REFCLSID, REFIID, LPVOID * );


/***************************************************************
 * File Globals
 ***************************************************************/
PGFXUILIST gpFullList;
PGFXUILIST gpGfxInitList;
PGFXUI     gpGfxNodeArray[MAX_GFX_COUNT];

/***************************************************************
 * extern
 ***************************************************************/
extern "C" {
extern DWORD GetWaveOutID(BOOL *pfPreferred);
}

/***************************************************************
 * Prototypes
 ***************************************************************/

DWORD GetWaveOutID(void)
{
    return GetWaveOutID(NULL);
}

/***************************************************************
 * GetListIndex
 *
 * Description:
 *      Returns the selected index for the combobox.  Always add one
 *      for the first entry of "None"
 *
 * Parameters:
 *      HWND    DWORD    - GFX ID
 *
 * Returns:    
 *      int              - Index number of the selected item
 *
 ***************************************************************/

int GetListIndex(PGFXUI pGfx)
{
    int iIndex = 0;
    int iCnt = 0;

    if (pGfx)
    {
        while (gpGfxNodeArray[iCnt])
        {
            if (lstrcmpi(pGfx->pszName, gpGfxNodeArray[iCnt++]->pszName) == 0 ) 
            {
                iIndex = iCnt;
                break;
            }
        }
       
        
    }
	return (iIndex);
}


/***************************************************************
 * CheckEffect
 *
 * Description:
 *      Check to see if effect has properties, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    BOOL
 *      TRUE if all the events for the selected module were read from the reg
 *        database, else FALSE
 ***************************************************************/


BOOL PASCAL CheckEffect(HWND hDlg)
{
    PGFXUI   pGfxTemp = NULL;
    PGFXUI   pGfxBase = NULL;
    DWORD    dwIndex  = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

    if (0 == dwIndex) return FALSE;

    if (!gpGfxNodeArray[dwIndex-1]) return FALSE;
    else pGfxTemp = gpGfxNodeArray[dwIndex-1];

    if (!gpGfxInitList->puiList) return FALSE;
    else pGfxBase = gpGfxInitList->puiList;

    if (lstrcmpi(pGfxTemp->pszName, pGfxBase->pszName) == 0)
        return GFXUI_CanShowProperties(pGfxBase);
    else return FALSE;

}


/***************************************************************
 * SetEffects
 *
 * Description:
 *      Adds all the effects to the ListView, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    None
 ***************************************************************/


void SetEffects(HWND hDlg)
{
    PGFXUI   pGfxDelete;
    PGFXUI   pGfxTemp;
    PGFXUI   pGfxBase;
    DWORD    dwIndex  = (DWORD)SendDlgItemMessage(hDlg, IDC_EFFECT_LIST, CB_GETCURSEL,0,0);

    // Check to see Index is in range
    if ((0 != dwIndex)&&(gpGfxNodeArray[dwIndex-1]))
        pGfxBase = gpGfxNodeArray[dwIndex-1];
    else 
        pGfxBase = NULL;

    if (gpGfxInitList->puiList)
        pGfxTemp = gpGfxInitList->puiList;
    else
        pGfxTemp = NULL;
    
    // No GFX Selected or previously set
    if ((0 == dwIndex)&&(!pGfxTemp)) return;

    // GFX has not been changed
    if (pGfxTemp && pGfxBase)
        if (lstrcmpi(pGfxTemp->pszName, pGfxBase->pszName) == 0)
            return;

    // If there was a previous GFX it is assigned to pGfxTemp
    // to be deleted
    gpGfxInitList->puiList = NULL;

    if (pGfxBase)
        GFXUI_CreateAddGFX(&(gpGfxInitList->puiList), pGfxBase);
      
    GFXUI_Apply (&gpGfxInitList, &pGfxTemp);

    EnableWindow(GetDlgItem(hDlg, IDB_EFFECT_PROP), CheckEffect(hDlg));

    return;
}


/***************************************************************
 * LoadEffects
 *
 * Description:
 *      Adds all the effects to the ListView, 
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *
 * Returns:    
 *      None
 *
 ***************************************************************/

void LoadEffects(HWND hDlg)
{
    TCHAR   szBuffer[MAX_PATH];
    DWORD   dwDefDeviceId = 0;
	DWORD   dwType =0;
    DWORD   dwDeviceId = 0;
    DWORD   dwIndex = 0;
    UINT    uMixId;
    HRESULT hr;

    PGFXUILIST pRetList = NULL;
    PGFXUI     pTempGFX = NULL;

    dwDeviceId = gAudData.waveId;
